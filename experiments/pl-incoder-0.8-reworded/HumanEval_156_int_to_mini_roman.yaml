name: HumanEval_156_int_to_mini_roman
language: pl
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman(19)\n# \"xix\"\n# >>> int_to_mini_roman(152)\n# \"clii\"\
  \n# >>> int_to_mini_roman(426)\n# \"cdxxvi\"\nsub int_to_mini_roman {\n    my($number)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&int_to_mini_roman;\n\
  \        if(eq_deeply($candidate->(19),\"xix\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(152),\"clii\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(251),\"\
  ccli\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(426),\"\
  cdxxvi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(500),\"d\")) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"i\")) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"\
  iv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(43),\"\
  xliii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(90),\"\
  xc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(94),\"\
  xciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(532),\"\
  dxxxii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(900),\"cm\")) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(994),\"cmxciv\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),\"\
  m\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    # Sanity check\n    return '' if ($number == 0);\n    if ($number\
    \ < 1 || $number > 1000) {\n\treturn '';\n    }\n    # Initialize accumulator\
    \ and numeral array\n    my(@letters);\n    my($roman);", "    my $result = '';\n\
    \    $number += 48;\n    while ($number >= 1000) {\n        $number -= 1000;\n\
    \        $result .= 'm';\n    }\n    while ($number >= 400) {\n        $number\
    \ -= 400;\n        $result .= 'c';\n    }\n    while ($number >= 100) {\n    \
    \    $number -= 100;\n        $result .= 'l';\n    }\n    while ($number >= 90)\
    \ {\n        $number -= 90;\n        $result .= 'x';\n    }\n    while ($number\
    \ >= 50) {\n        $number -= 50;\n        $result .= 'i';\n    }\n    while\
    \ ($number >= 10) {\n        $number -= 10;\n        $result .= 'v';\n    }\n\
    \    while ($number >= 9) {\n        $number -= 9;\n        $result .= 'c';\n\
    \    }\n    while ($number >= 5) {\n        $number -= 5;\n        $result .=\
    \ 'l';\n    }\n    while ($number >= 4) {\n        $number -= 4;\n        $result\
    \ .= 'x';\n    }\n    while ($number >= 1) {\n        $result .= 'l';\n    }\n\
    \    return lc($result);\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe algorithm\
    \ is pretty simple:", "    my @roman;\n    for (my $i=3; $i <= length($number);\
    \ $i++) {\n        $roman[$i] = substr($number, $i-1, 1);\n        if ($roman[$i]\
    \ == \"\") {\n            $roman[$i] = \"I\";\n        }\n    }\n    return join\
    \ \"\", map {lc($_)} @roman;\n}", "    # Handle special cases\n    my $roman =\
    \ ($number < 1)\n        ? '' : ($number < 4)\n          ? 'c'\n          : ($number\
    \ < 7)\n            ? 'cd'\n            : ($number < 10)\n              ? 'cm'\n\
    \              : ($number < 13)\n                ? 'cd'\n                : 'xc';\n\
    \    return uc($roman);\n}", "    my($result) =\"\";\n    my($thousand, $hundreth,\
    \ $tens, $units, $tenth);\n    my($number_str, $temp_str, $next_temp_str, $roman_num,\
    \ $temp_unit, $temp_tenth, $temp_hundreth, $temp_thousand);\n    \n    if ($number\
    \ < 1000){\n        $result = $number;\n    } else {\n        $number_str = $number\
    \ % 1000;\n        $temp_str = substr($number_str, 0, 3);\n        $number = int($number_str\
    \ / 1000);\n        $hundreth = substr($temp_str, 0, 1);\n        $thousand =\
    \ substr($temp_str, 1, 1);\n        $tens = substr($temp_str, 2, 1);\n       \
    \ $units = substr($temp_str, 3, 1);\n        $tenth = substr($temp_str, 4, 1);\n\
    \        $hundreth = $hundreth . $thousand . $tens;\n        $thousand = $thousand\
    \ . $units;\n        $tens = $tens . $tenth;\n        \n        $temp_str = substr($hundreth,\
    \ 0, 1);\n        $temp_hundreth = $temp_str . $hundreth;\n        \n        $temp_str\
    \ = substr($thousand, 0, 1);\n        $temp_thousand = $temp_str . $thousand;\n\
    \        \n        $temp_str = substr($tens, 0, 1);\n        $temp_units = $temp_str\
    \ . $units;\n        \n        $temp_str = substr($tenth, 0, 1);\n        $temp_tenth\
    \ = $temp_str . $tenth;\n        \n        $temp_unit = $temp_units . $tens;\n\
    \        $temp_tenth = $temp_tenth . $hundreth;\n        $temp_hundreth = $temp_hundreth\
    \ . $thousand;\n        \n        $temp_unit = $temp_unit . $tenth;\n        $temp_tenth\
    \ = $temp_tenth . $hundreth;\n        $temp_hundreth = $temp_hundreth . $thousand;\n\
    \        $temp_thousand = $temp_thousand . $units;\n        $temp_thousand = $temp_thousand\
    \ . $tens;\n        \n        $roman =\n          $temp_thousand . substr($temp_hundreth,\
    \ 0, 1) . substr($temp_tenth, 0, 1) . substr($temp_units, 0, 1) . substr($temp_tens,\
    \ 0, 1) . substr($temp_hundreth, 0, 1) . substr($temp_thousand, 0, 1);\n     \
    \   $result = $roman;\n    }\n    return $result;\n}", "    # make sure we have\
    \ a positive number\n    my($minus_one) = @{$_[0] < 1 ? @_[0] : @_}; $minus_one\
    \ -= 1;\n    \n    my $roman;\n    my $roman_string;\n    my $roman_rev_string;\n\
    \    my $digit;", "    return $number if ($number < 1);\n    my($roman) = $number\
    \ >= 1000 ? \"v\" : \"\";\n    return $roman if ($number < 1000);\n    my($tens,\
    \ $ones) = split(//, sprintf(\"%4d\", $number / 10));\n    return $roman . $ones\
    \ if $number < 400;\n    my($hundreds, $thousands) = split(//, sprintf(\"%4d\"\
    , $number % 10));\n    return $roman . $thousands if ($number < 1000);\n    my($hundreds,\
    \ $thousands, $tens) = split(//, sprintf(\"%4d\", $number % 100));\n    return\
    \ $roman . $thousands . $tens if ($number < 2000);\n    my($hundreds, $thousands,\
    \ $tens, $ones) = split(//, sprintf(\"%4d\", $number % 1000));\n    return $roman\
    \ . $thousands . $tens . $ones;\n}", "    if ($number < 1 || $number > 1000) {\n\
    \        $error = \"int_to_mini_roman passed a non-sensical value: $number\";\n\
    \        return;\n    }\n    my($roman, $roman_string, $roman_numeral);\n    my($i,\
    \ $n, $d, $x, $m, $c);\n    $roman = 'i';\n    for ($i = 1; $i <= 1000; $i++)\
    \ {\n        $n = $number % 10;\n        $number = int($number / 10);\n      \
    \  $c = substr($roman, 0, 1);\n        $m = substr($roman, 0, 1);\n        if\
    \ ($i == $n) {\n            $roman .= $c;\n            $roman .= $m;\n       \
    \ }\n        else {\n            $roman .= $d;\n            $roman .= $x;\n  \
    \      }\n    }\n    $roman =~ tr/mdcxvi/dxvi/;\n    return lc($roman);\n}", " \
    \   return '' if $number < 1;\n    return '' if $number > 1000;\n    my $roman\
    \ = ();\n    my $remainder = 0;\n    my $index = 1;\n    my $index2 = 0;\n   \
    \ my $letter = sub {\n        my ($roman) = @_;\n        $roman = [reverse $roman]\
    \ if $roman[-1] eq 'I';\n        return substr($roman, 0, length($roman) - 1)\
    \ if length($roman) > 1;\n        return $roman;\n    };\n    foreach my $i (reverse\
    \ sort { $a <=> $b } keys %roman_numeral) {\n        next if $i > $number;\n \
    \       $remainder = $roman_numeral{$i} % 10;\n        $roman = ();\n        if\
    \ ($index2 > 0) {\n            $roman .= $letter->($roman) if $index2 > 1;\n \
    \           $roman .= $index2;\n        }\n        if ($remainder >= 5) {\n  \
    \          $roman .= 'v';\n            $remainder -= 5;\n            $index2++;\n\
    \        }\n        if ($remainder >= 4) {\n            $roman .= 'vi';\n    \
    \        $remainder -= 4;\n            $index2++;\n        }\n        if ($remainder\
    \ >= 3) {\n            $roman .= 'i';\n            $remainder -= 3;\n        \
    \    $index2++;\n        }\n        if ($remainder >= 2) {\n            $roman\
    \ .= 'x';\n            $remainder -= 2;\n            $index2++;\n        }\n \
    \       if ($remainder >= 1) {\n            $roman .= 'l';\n            $remainder\
    \ -= 1;\n            $index2++;\n        }\n        $roman = reverse $roman;\n\
    \        $roman .= $letter->($roman) if $index2 > 1;\n        $roman .= $index2\
    \ if $index2 > 1;\n        $roman = reverse $roman;\n        $roman_numeral{$i}\
    \ = $roman;\n    }\n    $roman_numeral{$number};\n}", "    my $numeral = '';\n\
    \    my $roman = 'MCMXC';\n    my @roman =\n        map { $roman =~ s/^(\\d+)(\\\
    w)/$1 $2/ }\n            split(//, $roman);\n    for (my $n = 1; $n < $number;\
    \ ++$n) {\n        for (my $i = $n; $i > 0; --$i) {\n            if ($number %\
    \ $i == 0) {\n                $numeral .= $roman[$i - 1];\n                last\
    \ if $i == 1;\n            }\n        }\n        $numeral .= $roman[$n - 1];\n\
    \    }\n    $numeral = lc($numeral);\n    $numeral = reverse $numeral if $numeral\
    \ =~ /V$/;\n    return $numeral;\n}", "    my $result = '';", "    my($numeral,\
    \ $reversed);\n    my $roman_alphabet = qw(\n        M CM\n        D CD\n    \
    \    C XC\n        L XL\n        XL XXL\n        S XS\n        S SS\n        S\
    \ SSS\n        S SSSS\n        S SSSSS\n        S SSSSSS\n        S SSSSSSS\n\
    \        S SSSSSSSS\n        S SSSSSSSSS\n        S SSSSSSSSSS\n        S SSSSSSSSSSS\n\
    \        S SSSSSSSSSSSS\n        S SSSSSSSSSSSSS\n        S SSSSSSSSSSSSSS\n \
    \       S SSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSS\n        S\
    \ SSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSS\n \
    \       S SSSSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n\
    \        S SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\n        ", "    my $roman = \"\";\n\
    \    my $num_roman = \"\";\n    my $remainder = 0;\n    my $temp = 1;\n    my\
    \ $num_length = length($number);\n    my $int_length = length($number);", '    my
    $rom = 0;', "    $number += 0; # ensure it's positive", "    my @roman_array =\
    \ (\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"\
    x\", \"xi\", \"xii\", \"xiv\", \"xix\");\n    my @int_array = (\"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    );\n    my $i;\n    my $string = \"\";\n    $number = $number <= 0 ? 0 : $number;\n\
    \    while ($number) {\n        for ($i = 10; $i <= $number % 10; $i++) {\n  \
    \          my $temp = $number % 10;\n            $number /= 10;\n            $int_array[$temp]\
    \ = $roman_array[$i];\n        }\n        $string .= $int_array[$number] . $int_array[0];\n\
    \    }\n    return $string;\n}", "    my $str = '';", "    my($output) = \"\"\
    ;\n    if ($number < 1)\n    {\n        $number = 0;\n    }\n    elsif ($number\
    \ == 1)\n    {\n        $output = $number;\n    }\n    else\n    {\n        my($ii)\
    \ = $number % 100;\n        my $ii = $ii;\n        if ($ii > 10)\n        {\n\
    \            my($u) = ((($ii - 10) * 400) + 499);\n        }\n        else\n \
    \       {\n            my($u) = ((($ii - 9) * 400) + 399);\n        }\n      \
    \  if ($number < 100)\n        {\n            $output .= $u;\n        }\n    \
    \    else\n        {\n            my($u) = ((($number - 100) * 400) + 499);\n\
    \            $output .= $u;\n        }\n    }\n    return $output;\n}\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", '    my($num_to_roman);', "    return '' unless $number\
    \ =~ /^\\+?\\d+$/;", "    # Remove all non-digits from the input\n    $number\
    \ =~ s/\\D//g;\n    # Return an error if we have no digits in $number\n    return\
    \ if ($number eq '');", "    my $roman = substr int2roman($number), 0, 1;\n  \
    \  # Only change first letter\n    $roman =~ tr/MCMXCI/MMCMLX/;\n    $roman =~\
    \ tr/CX/CLX/;\n    $roman =~ tr/I/II/;\n    $roman =~ tr/V/MV/;\n    $roman =~\
    \ tr/L/LL/;\n    $roman =~ tr/M/MM/;\n    $roman =~ tr/I/II/;\n    $roman =~ tr/V/MV/;\n\
    \    $roman =~ tr/L/LL/;\n    $roman =~ tr/M/MM/;\n    $roman =~ tr/M/M/;\n  \
    \  $roman =~ tr/I/I/;\n    $roman = uc($roman);\n    return $roman;\n}", "   \
    \ my(@roman_numerals);\n    my($numeral, $roman_numeral);", '    my @roman_numeral;',
  "    my($rom);\n    my($num);\n    my($roman);\n    my $roman = \"\";\n    $roman\
    \ = $number % 100; # get modulus\n    $number -= $roman;        # subtract the\
    \ modulus\n    while(1) {\n        $roman = $roman . 'i';\n        $number -=\
    \ 7;\n        if($number == 0) {\n            $roman = $roman . \"m\";\n     \
    \       $number += 12;\n        }\n        last if $number == 0;\n    }\n    $roman\
    \ = $roman . 'x';\n    $number -= 5;\n    while(1) {\n        $roman = $roman\
    \ . \"$i\";\n        $number -= 1;\n        if($number == 0) {\n            $roman\
    \ = $roman . \"m\";\n            $number += 12;\n        }\n        last if $number\
    \ == 0;\n    }\n    $roman =~ tr/cm//d;\n    return lc($roman);\n}", "    my @digits\
    \ = split(//,$number);\n    my $roman = '';\n    my @digits_roman;", "    my $str\
    \ = '';\n    my $i = 0;\n    while ($i <= $number) {\n        my $mult = 1;\n\
    \        $i = $i + 1;\n        while ($i > $number) {\n            $str .= 'M'\
    \ * ($number % $mult);\n            $mult = $mult * 10;\n            $i = $i /\
    \ 10;\n        }\n        $str .= 'I' * ($i % $mult);\n    }\n    return lc $str;\n\
    }", "    my(@romans);\n    my($i);\n    my($count);\n    \n    $number = abs($number);\n\
    \    \n    # Special case: empty number (or zero)\n    $romans[$number] = \"\"\
    ;\n    $count++;\n    \n    if ($number > 100) {\n        # Special case: greater\
    \ than or equal to 100\n        $romans[$number] = \"M\";\n        $count++;\n\
    \    } elsif ($number >= 10) {\n        # Normal case\n        \n        $romans[$number]\
    \ = \"D\";\n        \n        # Figure out the number of multiples of $number\
    \ that are smaller than \n        # the number we are currently looking at. \n\
    \        # This is how many times we can divide $number by each number.\n    \
    \    # For example, if $number is 4 and we are looking at multiples of \n    \
    \    # 4, then this loop will run 3 times.\n        for ($i = $number, $count\
    \ = 0; $i >= 10; $i /= 10) {\n            $count++;\n        }\n        \n   \
    \     # Figure out the number of multiples of $number that are larger than \n\
    \        # the number we are currently looking at. \n        # This is how many\
    \ times we can multiply $number by each number.\n        # For example, if $number\
    \ is 15 and we are looking at multiples of \n        # 10, this loop will run\
    \ 2 times.\n        for ($i = $number, $count = 0; $i < 10; $i *= 10) {\n    \
    \        $count++;\n        }\n    }\n    \n    # Build the string.\n    for ($i\
    \ = 0; $i < $count; $i++) {\n        if ($number <= $i) {\n            push(@romans,\
    \ $romans[$number]);\n        }\n    }\n    \n    return join(\"\", @romans);\n\
    }", "    return '' unless $number >= 1 && $number <= 1000;\n    my($itoa) = $number\
    \ + 40;\n    my($mini) = ($itoa % 1000);\n    my $num_minus_one_digit = $number\
    \ - $itoa;\n    my($i_to_a_minus) = $num_minus_one_digit + 40;\n    my($mini_minus)\
    \ = ($i_to_a_minus % 1000);\n    my($i_minus_eighty) = $i_to_a_minus / 100;\n\
    \    my @result = ();\n    push(@result, $itoa, 'i') if $mini < 5;\n    push(@result,\
    \ $i_to_a_minus, 'i') if $mini_minus < 5;\n    push(@result, $i_minus_eighty,\
    \ 'e') if $number % 100;\n    my($i_minus_fifty) = $i_minus_eighty / 10;\n   \
    \ push(@result, $i_minus_fifty, 'f') if $number % 100 < 10;\n    push(@result,\
    \ $i_minus_fifty, 'v') if $number % 100 >= 10;\n    return join(\"\", map {chr\
    \ (ord $_)} @result);\n}", "    # Round to four significant figures\n    $number\
    \ /= 10**4;\n    $number %= 10**4;\n    # Turn into decimal and get the numeral\
    \ equivalent\n    my $n = 0;\n    foreach my $i (reverse (split //, $number))\
    \ {\n        my $digit = $i;\n        ++$n;\n        if ($n >= 100) {\n      \
    \      $digit += 1000;\n            --$n;\n        }\n        my $roman = (10\
    \ * $digit) + $n;\n        push @roman, $roman % 100;\n        $n /= 100;\n  \
    \  }\n    # Return as string\n    return join \"\", map {chr $_}, @roman;\n}",
  "    my($roman, @romans);\n    my($roman_size, $i);\n    my($roman_value, $j);",
  "    return undef unless $number >= 1 && $number <= 1000;\n    my @roman = ();\n\
    \    my $roman = \"\";\n    for (my $i = 1; $i <= $number; $i++) {\n        my\
    \ $n_str = $i;\n        for my $j (1 .. $roman_index) {\n            $roman .=\
    \ $romans[$j];\n        }\n        $roman = reverse $roman if $roman !~ m!^[a-z]+!;\n\
    \        $roman = $roman . $n_str;\n    }\n    return $roman;\n}", "    my($string);\n\
    \    my($current_numeral);", "    my(@roman) = ();\n    my($numeral, @numeral);",
  "    my $roman_numerals = do {\n        open(my $fh, '<', int2roman($number)) or\
    \ return;\n        local $/ = undef;\n        <$fh>;\n    };", '    my $roman
    = int_to_roman($number);', "    my (@result) = ('');", "    my($numeral) = ('');\n\
    \    while ($number >= 1000) {\n        $number -= 1000;\n        $numeral .=\
    \ 'm';\n    }\n    while ($number >= 100) {\n        $number -= 100;\n       \
    \ $numeral .= 'c';\n    }\n    while ($number >= 10) {\n        $number -= 10;\n\
    \        $numeral .= 'l';\n    }\n    while ($number >= 1) {\n        $number\
    \ -= 1;\n        $numeral .= 'x';\n    }\n    return $numeral;\n}", "    if (!\
    \ defined $number) {\n\tdie \"Invalid number provided\";\n    } elsif ($number\
    \ <= 0) {\n\tdie \"Invalid number provided\";\n    } elsif ($number > 1000) {\n\
    \tdie \"Invalid number provided\";\n    }", "    if ($number < 1 || $number >\
    \ 1000) {\n\tdie \"Invalid number $number\";\n    }\n    my @romans = (\"M\",\n\
    \t\t   \"CM\",\n\t\t   \"D\",\n\t\t   \"CD\",\n\t\t   \"C\",\n\t\t   \"XC\",\n\
    \t\t   \"L\",\n\t\t   \"XL\",\n\t\t   \"X\",\n\t\t   \"IX\",\n\t\t   \"V\",\n\t\
    \t   \"IV\",\n\t\t   \"I\");", "    my($roman, $roman_length) = int_to_roman($number);\n\
    \    my($mini_roman) = \"\";\n    while($roman =~ /(.{1})/g) {\n        $mini_roman\
    \ .= $1;\n    }\n    return $mini_roman;\n}", '    my($roman, $numeral);', '    my($i,
    $roman, $roman_string, $i, $number_digits) = @_;', "    my($digit, $roman, $remainder);\n\
    \    my($roman_string, $remainder_string);", "    my($roman, $remainder, $numeral);\n\
    \    my(@result) = (\"\");\n    foreach $numeral (reverse (10 .. $number)) {\n\
    \        $roman = int_to_roman($numeral);\n        $remainder = $number % $numeral;\n\
    \        push (@result, $roman);\n        $number = $remainder;\n    }\n    return\
    \ (join \"\", @result);\n}", "    # Return empty string if argument not between\
    \ 1 and 1000\n    return '' unless $number > 0 && $number <= 1000;", '    my($roman);',
  "    my($num_string, $numeral);\n    my($i, $f, $c, $k);", '    my($roman);', " \
    \   my $roman = \"\";\n    my $max_roman = 10001;\n    my $min_roman = 1;", '    my
    $roman = $number->roman;', "    return undef if $number < 1 || $number > 1000;\n\
    \    my($roman, $number);\n    my $num_roman = '';\n    my $num_roman_ord = ord('A')\
    \ - ord('0');\n    my $num_roman_len = length($num_roman);\n    my $num_to_roman\
    \ = substr($num_roman, 0, $num_roman_len-1);\n    my $num = $number + 1;\n   \
    \ my $roman_num = 0;\n    my $roman_len = 0;\n    while ($roman_num < $num_roman_len)\
    \ {\n        $roman_num += ($num_roman eq '' ? ($num_roman eq '0' ? $num + $roman_num\
    \ : $roman_num + $num) : $num_roman_ord) % ($num_roman eq '' ? ($num_roman eq\
    \ '0' ? $num + $roman_num : $roman_num + $num) : $num_roman_ord);\n        $roman_num++;\n\
    \        $roman_len++;\n        my $char = $num_to_roman eq '' ? ($num_to_roman\
    \ eq '0' ? $num + $roman_num : $roman_num + $num) : $num_to_roman;\n        $num_to_roman\
    \ = substr($num_roman, 0, $num_roman_len - $roman_len) . $char;\n    }\n    return\
    \ $roman;\n}", '    my(@alphabet) = ("i", "x", "c", "m", "b", "l", "x");', " \
    \   my $roman = undef;\n    my $temp = 0;\n    my $base = 1;", "    my($roman,\
    \ $roman_counter, $roman_length, $roman_numeral);\n    my($ii, $jj);", "    my(@roman)\
    \ = (\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\");\n    my(@results);\n    push @results, $number if $number\
    \ < 1;\n    while (1) {\n        push @results, $roman[$number % 10] if $number\
    \ % 10 < 4;\n        push @results, $roman[$number % 10] if $number % 10 < 9;\n\
    \        push @results, $roman[$number % 10] if $number % 100 < 4;\n        push\
    \ @results, $roman[$number % 10] if $number % 100 < 9;\n        push @results,\
    \ $roman[$number % 100] if $number % 1000 < 4;\n        push @results, $roman[$number\
    \ % 100] if $number % 1000 < 9;\n        push @results, $roman[$number % 100]\
    \ if $number % 1000 > 4;\n        push @results, $roman[$number % 100] if $number\
    \ % 1000 > 9;\n        $number /= 10;\n    }\n    return join \"\", map { @results[$_]\
    \ } 0 .. $#roman;\n}", "    my @roman;\n    my @roman_numerals;", "    my $ret\
    \ = '';\n    my $i = 0;\n    while ($number >= 1000 && $i < 6) {\n        $number\
    \ -= 1000;\n        $ret .= 'M';\n        $i++;\n    }\n    $i = 0;\n    while\
    \ ($number >= 900) {\n        $number -= 900;\n        $ret .= 'CM';\n       \
    \ $i++;\n    }\n    $i = 0;\n    while ($number >= 500) {\n        $number -=\
    \ 500;\n        $ret .= 'D';\n        $i++;\n    }\n    $i = 0;\n    while ($number\
    \ >= 400) {\n        $number -= 400;\n        $ret .= 'CD';\n        $i++;\n \
    \   }\n    $i = 0;\n    while ($number >= 100) {\n        $number -= 100;\n  \
    \      $ret .= 'C';\n        $i++;\n    }\n    $i = 0;\n    while ($number >=\
    \ 90) {\n        $number -= 90;\n        $ret .= 'XC';\n        $i++;\n    }\n\
    \    $i = 0;\n    while ($number >= 50) {\n        $number -= 50;\n        $ret\
    \ .= 'L';\n        $i++;\n    }\n    $i = 0;\n    while ($number >= 40) {\n  \
    \      $number -= 40;\n        $ret .= 'XL';\n        $i++;\n    }\n    $i = 0;\n\
    \    while ($number >= 10) {\n        $number -= 10;\n        $ret .= 'X';\n \
    \       $i++;\n    }\n    $i = 0;\n    while ($number >= 9) {\n        $number\
    \ -= 9;\n        $ret .= 'IX';\n        $i++;\n    }\n    $i = 0;\n    while ($number\
    \ >= 5) {\n        $number -= 5;\n        $ret .= 'V';\n        $i++;\n    }\n\
    \    $i = 0;\n    while ($number >= 4) {\n        $number -= 4;\n        $ret\
    \ .= 'IV';\n        $i++;\n    }\n    $i = 0;\n    while ($number >= 1) {\n  \
    \      $number -= 1;\n        $ret .= 'I';\n        $i++;\n    }\n    $ret .=\
    \ $i;\n    return $ret;\n}", '    my(@roman);', "    my($roman, $tens, $ones);\n\
    \    my($i) = 0;\n    my $roman = '';\n    my $tens = 0;\n    my $ones = 0;\n\
    \    while($i < (length($number)) - 1) {\n        if ($number eq \"0\") {\n  \
    \          $roman .= \"M\";\n        } elsif ($number eq \"1\") {\n          \
    \  $roman .= \"D\";\n        } elsif ($number eq \"5\") {\n            $roman\
    \ .= \"C\";\n        } elsif ($number eq \"10\") {\n            $roman .= \"L\"\
    ;\n        } elsif ($number eq \"50\") {\n            $roman .= \"X\";\n     \
    \   } elsif ($number eq \"100\") {\n            $roman .= \"V\";\n        } else\
    \ {\n            die \"Unexpected value $number\";\n        }", "    my($numstr)\
    \ = \"\";\n    # Figure out how many positions we're going to be prepending the\
    \ string with.\n    $numstr = $number % 100; # How many positions to prepend.\n\
    \    $number -= $numstr; # How many positions to remove from the number.\n   \
    \ $numstr = $numstr * 10; # How many times the number should be repeated after\
    \ prepending.\n    $number -= $numstr; # How many positions to remove from the\
    \ number.\n    \n    foreach my $i (0 .. $numstr) {\n        $numstr = $numstr\
    \ . int2roman($number % 10);\n        $number -= $numstr;\n    }\n    return lc($numstr);\n\
    }", "    my $result = \"\";\n    my $numeral = \"IVXLCDM\";\n    my $numeral_size\
    \ = @$numeral;", "    my(@roman) = ();\n    my $int_val = $number;", "    my(@roman_number);\n\
    \    my $i = 1;\n    while ($i <= $number) {\n        push (@roman_number, \"\
    x\"x($i));\n        $i++;\n    }\n    return join('', @roman_number);\n}", " \
    \   if ($number < 1) {\n        return \"!$number!\";\n    }\n    elsif ($number\
    \ == 1) {\n        return \"$1\";\n    }\n    elsif ($number < 3) {\n        return\
    \ \"$number $rom[$number - 1]\";\n    }\n    elsif ($number < 6) {\n        return\
    \ \"$rom[$number - 3]x$rom[$number - 2]\";\n    }\n    elsif ($number < 9) {\n\
    \        return \"$rom[$number - 5]c$rom[$number - 4]x$rom[$number - 3]\";\n \
    \   }\n    elsif ($number < 12) {\n        return \"$rom[$number - 7]x$rom[$number\
    \ - 6]l$rom[$number - 5]\";\n    }\n    elsif ($number < 16) {\n        return\
    \ \"$rom[$number - 9]v$rom[$number - 8]x$rom[$number - 7]l$rom[$number - 6]\"\
    ;\n    }\n    elsif ($number < 19) {\n        return \"$rom[$number - 11]d$rom[$number\
    \ - 10]x$rom[$number - 9]c$rom[$number - 8]l$rom[$number - 7]\";\n    }\n    elsif\
    \ ($number < 21) {\n        return \"$rom[$number - 13]e$rom[$number - 12]x$rom[$number\
    \ - 11]l$rom[$number - 10]\";\n    }\n    elsif ($number < 24) {\n        return\
    \ \"$rom[$number - 15]e$rom[$number - 14]x$rom[$number - 13]l$rom[$number - 12]c$rom[$number\
    \ - 11]\";\n    }\n    elsif ($number < 27) {\n        return \"$rom[$number -\
    \ 17]e$rom[$number - 16]x$rom[$number - 15]l$rom[$number - 14]c$rom[$number -\
    \ 13]x$rom[$number - 12]\";\n    }\n    elsif ($number < 30) {\n        return\
    \ \"$rom[$number - 19]e$rom[$number - 18]x$rom[$number - 17]l$rom[$number - 16]c$rom[$number\
    \ - 15]x$rom[$number - 14]\";\n    }\n    elsif ($number < 33) {\n        return\
    \ \"$rom[$number - 21]e$rom[$number - 20]x$rom[$number - 19]l$rom[$number - 18]c$rom[$number ",
  "    $number = abs($number);\n    my $roman = '';", "    return unless $number =~\
    \ /^\\s*[-+]?[0-9]+\\s*$/;\n    $number =~ s/^([-+]?)(\\d+)$/$1+$2/;\n    my @roman\
    \ = (\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"\
    XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    );\n    my $str\
    \ = $roman[$number];\n    $str =~ s/^([M])/$1./g;\n    $str =~ s/^([^M])$/$1/;\n\
    \    $str =~ s/^([^X]+)/$1./g;\n    $str =~ s/^([X])([^I]+)$/$1.$2./g;\n    return\
    \ $str;\n}", "    my(@result) = (\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"\
    ,\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\
    \",\"\",\"\");\n    my($i,$j,$k,$n,$x,$roman,$ch);", '    my($ret);', '    my(@roman_numerals);',
  "    my $numeral = \"MCMXCIV\";\n    $numeral .= \"DCLXVI\";\n    $numeral .= \"\
    MCCCXLIV\";\n    $numeral .= \"MCCCLXII\";\n    $numeral .= \"MCCDLXXV\";\n  \
    \  $numeral .= \"MCCDLXXX\";\n    $numeral .= \"MCCCLXXV\";\n    $numeral .= \"\
    MCCCLXXX\";\n    $numeral .= \"MCCLXXVI\";\n    $numeral .= \"MCCLXXXV\";\n  \
    \  $numeral .= \"MCCCLXVI\";\n    $numeral .= \"MCCCLXXI\";\n    $numeral .= \"\
    MCCCLXXX\";\n    $numeral .= \"MCCDLVII\";\n    $numeral .= \"MCCDLLXX\";\n  \
    \  $numeral .= \"MCCDLXXX\";\n    $numeral .= \"MCCDLLVI\";\n    $numeral .= \"\
    MCCDLLIX\";\n    $numeral .= \"MCCDLLXI\";\n    $numeral .= \"MCCDLXXX\";\n  \
    \  $numeral .= \"MCCDLVII\";\n    $numeral .= \"MCCDLLXX\";\n    $numeral .= \"\
    MCCDLXXX\";\n    $numeral .= \"MCCDLLVI\";\n    $numeral .= \"MCCDLLIX\";\n  \
    \  $numeral .= \"MCCDLLXI\";\n    $numeral .= \"MCCDLXXX\";\n    $numeral .= \"\
    MCCDLVII\";\n    $numeral .= \"MCCDLLXX\";\n    $numeral .= \"MCCDLXXX\";\n  \
    \  $numeral .= \"MCCDLLVI\";\n    $numeral .= \"MCCDLLIX\";\n    $numeral .= \"\
    MCCDLLXI\";\n    $numeral .= \"MCCDLXXX\";\n    $numeral .= \"MCCLXXVI\";\n  \
    \  $numeral .= \"MCCLXXXV\";\n    $numeral .= \"MCCLXVI\";\n    $numeral .= \"\
    MCCLXXI\";\n    $numeral .= \"MCCLXXX\";\n    $numeral .= \"MCCLXVI\";\n    $numeral\
    \ .= \"MCCLXXI\";\n    $numeral .= \"MCCLXXX\";\n    $numeral .= \"MCCLXVI\";\n\
    \    $numeral .= \"MCCLXXI\";\n    $numeral .= \"MCCLXXX\";\n", "    return undef\
    \ unless $number =~ /^\\d+$/;\n    $number = abs($number);\n    my($thousands,\
    \ $hundreds, $tens, $ones) = (0, 0, 0, 0);\n    if ($number >= 1000) {\n     \
    \   $thousands = int($number / 1000);\n        $number    %= 1000;\n    }\n  \
    \  if ($number >= 100) {\n        $hundreds = int($number / 100);\n        $number\
    \    %= 100;\n    }\n    my $n = $number;\n    while ($n >= 10) {\n        $tens\
    \ += int($n / 10);\n        $n     %= 10;\n    }\n    my $roman = '';\n    while\
    \ ($n >= 1) {\n        $ones += int($n / 1);\n        $n     %= 1;\n        $roman\
    \ .= _roman_digit_to_char($ones);\n    }\n    $roman .= _roman_digit_to_char($thousands);\n\
    \    $roman .= _roman_digit_to_char($hundreds);\n    $roman .= _roman_digit_to_char($tens);\n\
    \    return lc($roman);\n}", "    my %roman_map = (\n        1000  => 'M',\n \
    \       9000  => 'CM',\n        5000  => 'D',\n        4000  => 'CD',\n      \
    \  1000  => 'C',\n        500   => 'XC',\n        400   => 'L',\n        100 \
    \  => 'XL',\n        90    => 'X',\n        50    => 'IX',\n        40    => 'V',\n\
    \        10    => 'IV',\n        9     => 'I',\n    );\n    return $roman_map{$number}\
    \ if exists $roman_map{$number};\n    my ($numeral) = roman($number);\n    return\
    \ $numeral if exists $roman_map{$numeral};\n    return;\n}", "    my $roman =\
    \ '';", "    die \"Argument must be an integer between 1 and 1000\" unless $number\
    \ > 0 && $number < 1000;\n    my $roman = \"\";\n    my $base = 1;", "    my(@roman)\
    \ = (\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\");\n    my(@roman_number)\
    \ = (\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"\
    );\n    my(@roman_number_to_char) = (\"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\");\n    my(@last_roman_char);", "    my($roman,\
    \ $digits);\n    my($last_digit);\n    my($carry);", "    my($string) = '';\n\
    \    my($roman) = '';\n    my($num, $i) = (0, 0);\n    while ($number > 0) {\n\
    \        $roman .= substr($roman_chars,$num*10-$i-1,1);\n        $num = ($num\
    \ == 1) ? 0 : $num - 1;\n        $i = ($num == 0) ? 1 : ($i == 2) ? 4 : $i+1;\n\
    \    }\n    if ($roman eq '') {\n        warn(\"Can't convert $number in to mini\
    \ roman\\n\");\n        $string = $number;\n    } else {\n        $string .= $roman;\n\
    \    }\n    return $string;\n}", "    # Convert to an array with a zero-index\
    \ for easy indexing.\n    my(@roman_numbers) = map { $_ + 0 } 0..90;", "    my\
    \ ($num, $i) = ($number, 0);\n    my @roman;", "    die \"bad number $number\"\
    \ unless $number <= 1000;\n    $number *= 2;\n    my $roman = \"\";\n    my $count\
    \ = 1;\n    while (1) {\n        my $next_number = $number / 10;\n        $roman\
    \ .= (char_to_roman($next_number));\n        $number -= $next_number * 10;\n \
    \       $count++;\n        return $roman unless $count == 4;\n        $roman =\
    \ \"$roman$char_to_roman($number)\";\n        $number *= 10;\n    }\n}", "   \
    \ my($roman_num, $roman, $mini);\n    my($roman_letter, $letter, $digit_count,\
    \ $number);", '    my($roman);', '    return undef if !defined $number;', '    my($rom);',
  "    my $roman_number = 0;\n    my $numeral = $roman_number;\n    my $numeral_array\
    \ = \"IVXLCDM\";\n    my $roman = 0;\n    my $length = 0;\n    my $new_roman =\
    \ 0;", "    my(@romans);\n    my $digits = $number % 10;\n    my $result = ($digits\
    \ == 1 ? 'm' : 'm');\n    while ($number >= 1000) {\n        ($number, $digits)\
    \ = split '.', $number;\n        my $tmp = $digits % 10;\n        $result .= ($tmp\
    \ == 1 ? 'c' : 'c');\n    }\n    $result .= ($digits == 1 ? 'i' : 'i');\n    push\
    \ (@romans, $result);\n    return @romans;\n}", "    my(@roman) = ();\n    my\
    \ $roman_letter;\n    my $denominator = 1;\n    my $remainder = 0;", "    my(@roman_numbers)\
    \ = qw(m l c d);\n    my(@romatized_numbers);\n    my(@mini_roman_numbers);",
  "    my($i, $numeral, $romatic_string);\n    $romatic_string = \"\";\n    \n   \
    \ # If the integer is less than 1000, just return the integer.\n    if ($number\
    \ <= 999) {\n        $numeral = int2roman($number);\n        return $numeral;\n\
    \    }", "    my @roman = ();\n    my $numeral;\n    for (my $count = 0; $count\
    \ < $number; $count++) {\n        $numeral .= $roman[$count];\n    }\n    return\
    \ lc($numeral);\n}", "    my @roman;\n    my $prev;\n    my $str = \"\";\n   \
    \ my $str = \"\";\n    my $num_iter = ceil($number / 1000);\n    my $last_num_iter\
    \ = $num_iter;\n    my $num_div;\n    my $num_mod_iter;\n    my $num_mod_div;\n\
    \    my $prev_num_iter;\n    my $first_digit = 1;\n    my $last_digit;\n    my\
    \ $first_num_iter = 1;\n    my $prev_num_mod_iter = 1;\n    my $prev_num_mod_div\
    \ = 0;\n    my $prev_last_num_iter = 1;\n    my $last_num_iter = 1;\n    my $roman_index\
    \ = 1;\n    my $roman_index2 = 1;\n    my $first_mod_iter = 1;\n    my $last_mod_iter\
    \ = 1;\n    my $first_mod_div = 1;\n    my $last_mod_div = 1;\n    my $first_mod_div2\
    \ = 1;\n    my $last_mod_div2 = 1;\n    my $first_mod_div3 = 1;\n    my $last_mod_div3\
    \ = 1;\n    my $first_mod_div4 = 1;\n    my $last_mod_div4 = 1;\n    my $first_mod_div5\
    \ = 1;\n    my $last_mod_div5 = 1;\n    my $first_mod_div6 = 1;\n    my $last_mod_div6\
    \ = 1;\n    my $first_mod_div7 = 1;\n    my $last_mod_div7 = 1;\n    my $first_mod_div8\
    \ = 1;\n    my $last_mod_div8 = 1;\n    my $first_mod_div9 = 1;\n    my $last_mod_div9\
    \ = 1;\n    my $first_mod_div10 = 1;\n    my $last_mod_div10 = 1;\n    my $first_mod_div11\
    \ = 1;\n    my $last_mod_div11 = 1;\n    my $first_mod_div12 = 1;\n    my $last_mod_div12\
    \ = 1;\n    my $first_mod_div13 = 1;\n    my $last_mod_div13 = 1;\n    my $first_mod_div14\
    \ = 1;\n    my $last_mod_div14 = 1;\n    my $first_mod_div15 = 1;\n    my $last_mod_div15\
    \ = 1;\n    my $first_mod_div16 = 1;\n    my $last_mod_div16 = 1;\n    my $first_mod_div17\
    \ = 1;\n    my $last_mod_div17 = 1;\n    my $first_mod_div18 = 1;\n    my $last_mod_div18\
    \ = 1;\n    my $first_mod_div19 = 1;\n    my $last_mod_div19 = 1;\n    my $first_mod_div20\
    \ = 1;\n    my $last_mod_div20 = 1;\n    my $first_mod_div21 = 1;\n    my $last_mod_div21\
    \ = 1;\n    my $first_mod_div22 = 1;\n    my $last_mod_div22 = 1;\n    my $first_mod_div23\
    \ = 1;\n    my $last_mod_div23 = 1;\n    ", "    my $roman = '';", "    return\
    \ $number == 1 ? $number : 'i' unless $number >= 1 && $number <= 3999; # 1 is\
    \ not commonly used in romans\n    my @romans = (\"I\", \"IV\", \"V\", \"IX\"\
    , \"X\");\n    my $roman = \"\";\n    while ($number >= 1000) {\n        $roman\
    \ .= $romans[-1]; # Append last roman until number is < 1000\n        $number\
    \ -= 1000;\n    }\n    $roman .= $romans[-1] if $number < 1000;\n    return $roman;\n\
    }", "    my $int_string = $number+'';\n    my @int_chars = split(//, $int_string);\n\
    \    my $roman_numeral = int_to_roman($int_chars)+'';\n    $roman_numeral =~ s/^0+//;\n\
    \    $roman_numeral =~ s/^0+//;\n    $roman_numeral =~ s/^0+//;\n    return lc($roman_numeral);\n\
    }", "    my $roman = '';\n    while (1 < ($number / 1000)) {\n        $roman .=\
    \ int_to_mini_roman($number % 1000).'x';\n        $number = $number / 1000;\n\
    \    }\n    if ($number == 1) {\n        $roman = $roman.int_to_roman($number);\n\
    \    } else {\n        $roman .= int_to_mini_roman($number);\n    }\n    return\
    \ lc($roman);\n}", "    my($letters, $numerals, $remainder);\n    my($i, $j, @string);\n\
    \    my($tmp, $tmp2);\n    my(@rom);\n    my(@roman);", '    return unless $number
    >= 1 && $number <= 1000;', "    my($roman, $rest) = (0, 0);\n    my($base) = ('M',\
    \ 'D', 'C', 'L', 'X', 'V', 'I');\n    my $base_index = scalar keys %$base;\n \
    \   while ($number >= 0) {\n        my $value = $number % $base_index;\n     \
    \   $roman .= $base->[$value];\n        $number -= $value;\n        $rest = $number\
    \ % 10;\n        $number  = int($number / 10);\n    }\n    $roman = ($rest > 0)\n\
    \            ? substr($roman, 0, 1) . \"$rest$base->[0]\"\n            : $roman;\n\
    \    return lc($roman);\n}", "    my $mini_roman = \"\";\n    for(my $i = 1; $i\
    \ < $number; ++$i) {\n        my $mult = roman($i);\n        $mini_roman .= $mult;\n\
    \    }\n    $mini_roman =~ tr/MCMXCIIV/MLXXXIV/;\n    $mini_roman =~ tr/X/X/;\n\
    \    $mini_roman =~ tr/I/I/;\n    return lc($mini_roman);\n}", "    my(@roman)\
    \ = ();\n    my($numeral, $numeral_string, $i);\n    my $int_string = $number;\n\
    \    $int_string =~ s/^-?\\d+$//;\n    $int_string =~ tr/1-9/A-C/;", "    my(@roman)\
    \ = ();\n    if ($number == 0) {\n\treturn '0';\n    } elsif ($number == 1) {\n\
    \treturn 'i';\n    } elsif ($number <= 3999) {\n\tmy $i = 0;\n\tmy $str = \"\"\
    ;\n\twhile ($i < $number) {\n\t    my $remainder = $number % 10;\n\t    $str .=\
    \ $mini_roman[$remainder];\n\t    $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman,\
    \ $str);\n    } elsif ($number <= 4999) {\n\tmy $i = 1;\n\tmy $str = \"\";\n\t\
    while ($i < $number) {\n\t    my $remainder = $number % 10;\n\t    $str .= $mini_roman[$remainder];\n\
    \t    $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman, $str);\n    } elsif ($number\
    \ <= 9999) {\n\tmy $i = 2;\n\tmy $str = \"\";\n\twhile ($i < $number) {\n\t  \
    \  my $remainder = $number % 10;\n\t    $str .= $mini_roman[$remainder];\n\t \
    \   $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman, $str);\n    } elsif ($number\
    \ <= 99999) {\n\tmy $i = 3;\n\tmy $str = \"\";\n\twhile ($i < $number) {\n\t \
    \   my $remainder = $number % 10;\n\t    $str .= $mini_roman[$remainder];\n\t\
    \    $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman, $str);\n    } elsif ($number\
    \ <= 999999) {\n\tmy $i = 4;\n\tmy $str = \"\";\n\twhile ($i < $number) {\n\t\
    \    my $remainder = $number % 10;\n\t    $str .= $mini_roman[$remainder];\n\t\
    \    $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman, $str);\n    } elsif ($number\
    \ <= 9999999) {\n\tmy $i = 5;\n\tmy $str = \"\";\n\twhile ($i < $number) {\n\t\
    \    my $remainder = $number % 10;\n\t    $str .= $mini_roman[$remainder];\n\t\
    \    $i ++;\n\t    $number /= 10;\n\t}\n\tpush(@roman, $str);\n    } elsif ($number\
    \ <= 999999999) {\n\tmy $i = 6;\n\tmy $str = \"\";\n\twhile ($i < $number) {\n\
    \t    my $remain", "    my $roman = '';\n    if ($number >= 0) {\n        $roman\
    \ .= \"I\";\n        if ($number >= 100) { $roman .= \"V\"; }\n        if ($number\
    \ >= 10) { $roman .= \"X\"; }\n        if ($number >= 5) { $roman .= \"L\"; }\n\
    \        if ($number >= 1) { $roman .= \"C\"; }\n        if ($number >= 0.25)\
    \ { $roman .= \"D\"; }\n        if ($number >= 0.01) { $roman .= \"M\"; }\n  \
    \  }\n    else {\n        $roman .= \"M\";\n        if ($number >= 100) { $roman\
    \ .= \"C\"; }\n        if ($number >= 10) { $roman .= \"L\"; }\n        if ($number\
    \ >= 5) { $roman .= \"X\"; }\n        if ($number >= 1) { $roman .= \"V\"; }\n\
    \        if ($number >= 0.25) { $roman .= \"D\"; }\n        if ($number >= 0.01)\
    \ { $roman .= \"I\"; }\n    }\n    $roman;\n}", "    my $roman = \"\";\n    my\
    \ $roman_counter = 1;\n    my $decimal_point = 0;", "    my $num_str = int2str($number);\n\
    \    my $roman = \"\";\n    my $num;", "    return undef if $number < 1 || $number\
    \ > 1000;\n    my $roman = \"\";\n    my $digit = 0;\n    my $last_digit = 0;\n\
    \    my $length = length($number);\n    my @digits = split(//, $number);\n   \
    \ for (@digits) {\n        $digit += $_;\n        $roman .= substr($roman ? \"\
    $last_digit$roman\" : $last_digit, -1);\n        $last_digit = $_;\n    }\n  \
    \  return $roman;\n}", '    my $num = $number + 1;', "    if ($number < 0) {\n\
    \        $number += 1000;\n        $number *= -1;\n    }\n    my @roman = ();\n\
    \    my $num = 0;\n    my $roman = \"\";\n    my $cur = 0;", "    my @numerals\
    \ = (\"x\",\"c\",\"l\",\"i\",\"v\",\"x\");\n    if ($number < 1) {\n        return\
    \ (\"?\");\n    }\n    elsif ($number < 10) {\n        return (\"$1\");\n    }\n\
    \    elsif ($number < 100) {\n        return (\"$1 $numerals[0]\");\n    }\n \
    \   elsif ($number < 1000) {\n        my $string = $number;\n        foreach my\
    \ $i (1..(length($string)/2)) {\n            my $first = (substr($string, $i*2,\
    \ 2) =~ /10/) ? \"X\" : $numerals[(substr($string, $i*2, 2)-1)];\n           \
    \ $string = \"$first $string\";\n        }\n        return (\"$string\");\n  \
    \  }\n    else {\n        return (\"?\");\n    }\n}", "    $number += 1;\n   \
    \ my $mini_roman = \"\";\n    for(my $i = 0; $i < $number; $i++) {\n        my\
    \ $remainder = $number % 10;\n        $mini_roman .= $remainder < 4 ? \"l\" :\
    \ \"c\";\n        $number -= $remainder;\n    }\n    return $mini_roman;\n}",
  "    my $roman = 0;\n    while (1) {\n        my $n = ($number % 1000) + 1;\n  \
    \      $roman .= $roman_str[$n] if $n < @$roman_str;\n        if ($number < 1000)\
    \ {\n            return $roman;\n        }\n        $number /= 1000;\n    }\n}",
  "    my($string, $roman);\n    \n    # Sanity check: make sure number is less than\
    \ 1000.\n    if ($number <= 1000) {\n        return $number;\n    }", "    my\
    \ %alphabet = (\"i\" => 1, \"v\" => 5, \"x\" => 10, \"l\" => 50);\n    my $roman\
    \ = \"\";\n    my $numeral;\n    my $divisor;", "    if ($number < 1 || $number\
    \ > 1000) {\n        $self->_error('int_to_mini_roman() called with invalid number\
    \ for its second parameter');\n        return;\n    }\n    my(@roman);\n    my\
    \ $roman_digit;\n    my $i;\n    my $roman_digits;\n    my $n_roman_digits;\n\
    \    my $j;\n    my $last_roman_digit;\n    my $last_roman_digit_index;\n    my\
    \ $last_roman_digit_length;\n    my $n;\n    my $n_digits;\n    my $last_digit;\n\
    \    my $last_digit_index;\n    my $last_digit_length;\n    my $d;\n    my $temp;\n\
    \    my @roman_num_array;\n    my @roman_num_array_reverse;\n    $roman[0] = 'M';\n\
    \    $roman[1] = 'CM';\n    $roman[2] = 'D';\n    $roman[3] = 'CD';\n    $roman[4]\
    \ = 'C';\n    $roman[5] = 'XC';\n    $roman[6] = 'L';\n    $roman[7] = 'XL';\n\
    \    $roman[8] = 'X';\n    $roman[9] = 'IX';\n    $roman[10] = 'V';\n    $roman[11]\
    \ = 'IV';\n    $roman[12] = 'I';\n    $roman[13] = 'I';\n    $roman[14] = 'I';\n\
    \    $roman[15] = 'I';\n    $roman[16] = 'I';\n    $roman[17] = 'I';\n    $roman[18]\
    \ = 'I';\n    $roman[19] = 'I';\n    $roman[20] = 'I';\n    $roman[21] = 'V';\n\
    \    $roman[22] = 'IV';\n    $roman[23] = 'V';\n    $roman[24] = 'V';\n    $roman[25]\
    \ = 'V';\n    $roman[26] = 'V';\n    $roman[27] = 'V';\n    $roman[28] = 'V';\n\
    \    $roman[29] = 'V';\n    $roman[30] = 'V';\n    $roman[31] = 'V';\n    $roman[32]\
    \ = 'I';\n    $roman[33] = 'I';\n    $roman[34] = 'I';\n    $roman[35] = 'I';\n\
    \    $roman[36] = 'I';\n    $roman[37] = 'I';\n    $roman[38] = 'I';\n    $roman[39]\
    \ = 'I';\n    $roman[40] = 'I';\n    $", "    my($roman, $output);\n    $roman\
    \ = $number\n        if $number < 1000;", "    # Romans use different numbers\
    \ for different letters (and sometimes different\n    # orderings), and so for\
    \ efficiency we store it in a hash.\n    my $roman_hash = {\n        1 => \"i\"\
    ,\n        5 => \"vi\",\n        9 => \"viii\",\n        40 => \"vv\",\n     \
    \   50 => \"vvv\",\n        100 => \"vvvv\",\n        1000 => \"vvvvv\"\n    };\n\
    \    return $roman_hash->{$number}\n        if exists $roman_hash->{$number};\n\
    \    # It won't be long, so just convert it to a string.\n    my $roman = $number;\n\
    \    for my $i (1..9) {\n        $roman .= $i if $number % $i == 0;\n    }\n \
    \   return $roman;\n}", "    $number ||= 0;\n    my $roman = '';", '    $number
    += 1;', "    my $roman = '';\n    my @numerals = qw(m c d l x vi ix vix ixx ixcx\
    \ cvi cvi dvi dvix dvix\n                       lcx lc lxx lxc ixc cvi cvi dvi\
    \ dvix dvix\n                       c x vi ix vix ixx ixcx cvi cvi dvi dvix dvix\n\
    \                       lc lxx lxc ixc cvi cvi dvi dvix dvix\n               \
    \        c c vi ix vix ixx ixcx cvi cvi dvi dvix dvix\n                      \
    \ lc lxx lxc ixc cvi cvi dvi dvix dvix\n                       ii ix iv ivx ivcx\
    \ ivc\n                       ixi ixx ixcx ixcc\n                       vi ix\
    \ vix ixx ixcx cvi cvi dvi dvix dvix\n                       vi vi vi vi vi vi\
    \ vi vi vi vi vi vi vi vi\n                       ii ix iv ivx ivcx ivc\n    \
    \                   ixi ixx ixcx ixcc\n                       vi ix vix ixx ixcx\
    \ cvi cvi dvi dvix dvix\n                       vi vi vi vi vi vi vi vi vi vi\
    \ vi vi vi vi\n                       ii ix iv ivx ivcx ivc\n                \
    \       ixi ixx ixcx ixcc\n                       vi ix vix ixx ixcx cvi cvi dvi\
    \ dvix dvix\n                       vi vi vi vi vi vi vi vi vi vi vi vi vi\n \
    \                      ii ix iv ivx ivcx ivc\n                       ixi ixx ixcx\
    \ ixcc\n                       vi ix vix ixx ixcx cvi cvi dvi dvix dvix\n    \
    \                   vi vi vi vi vi vi vi vi vi vi vi vi vi vi\n              \
    \         ii ", '    my($roman, $base);', "    my($roman, $base);\n    if ($number\
    \ < 1) {\n        return;\n    }\n    my $roman = 0;\n    my $base = 1;\n    while\
    \ (0 < $number) {\n        $roman += ($number % $base);\n        $number -= $base;\n\
    \        $base *= 10;\n    }\n    if (0 == $number) {\n        return \"$roman\"\
    ;\n    }\n    return \"$roman$base\";\n}", "    my($roman, $temp, $remainder);\n\
    \    my @romans = (\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\"\
    , \"X\", \"IX\", \"V\", \"IV\", \"I\");\n    my $length = ($number % 100) + 1;\n\
    \    $number -= $length * (100 / $length);", "    my($result);\n    my $roman\
    \ = $number % 510;\n    my $remainder = $number - $roman;\n    if ($remainder\
    \ >= 1000) {\n        $result = $roman . int_to_mini_roman($remainder);\n    }\
    \ else {\n        $result = $roman . int_to_mini_roman(1000 - $remainder);\n \
    \   }\n    return lc($result);\n}", "    my ($str);\n    my %map = (\n       \
    \ 1 => 'i', 2 => 'ii', 3 => 'iii',\n        4 => 'iv', 5 => 'v', 6 => 'vi',\n\
    \        7 => 'vii', 8 => 'viii', 9 => 'ix',\n        10 => 'x', 11 => 'xi', 12\
    \ => 'xii',\n        13 => 'xiii', 14 => 'xiv', 15 => 'xv',\n        16 => 'xvi',\
    \ 17 => 'xvii', 18 => 'xviii',\n        19 => 'xx', 20 => 'xxi', 21 => 'xxii',\n\
    \        22 => 'xxiii', 23 => 'xxiv', 24 => 'xxv',\n        25 => 'xxvi', 26 =>\
    \ 'xxvii', 27 => 'xxviii',\n        28 => 'xxx'\n    );\n    for my $v (1 .. $number)\
    \ {\n        $str .= $map{$v};\n    }\n    $str =~ s/\\b[a-z]+\\b/\\b/;\n    $str;\n\
    }", "    my(@strings);\n    my($prev_num, $curr_rest, $rest);\n    my($i);\n \
    \   my($roman);", "    my %lookup = reverse %ROMAN_LOOKUP;\n    my $result = '';\n\
    \    while (1) {\n        if ($number < 1 || $number > 1000) {\n            return\
    \ $result unless $number;\n            return $number if $number =~ /^0$/;\n \
    \           return $number->sprintf(\"%03d\", $number);\n        }\n        my\
    \ $remainder = $number % 1000;\n        $number -= $remainder;\n        $result\
    \ .= $lookup{$remainder}\n    }\n}", "    my %roman = ();\n    my $roman_string;\n\
    \    my $i;", "    my(@numerals) = ();\n    my($result) = '';\n    foreach my\
    \ $n (reverse (split //, $number)) {\n        push(@numerals, $n <= 9 ? '' : \"\
    $_$_\");\n    }\n    foreach my $n (@numerals) {\n        my $nn = substr($n,\
    \ 0, 1);\n        $n =~ s/^([$nn])/$1/g;\n        $result .= substr($n, 0, 1);\n\
    \    }\n    return $result;\n}", "    my $roman = \"\";\n    my $i = 1;\n    my\
    \ $tmp;\n    while($i < $number) {\n        $tmp = substr($roman, -1);\n     \
    \   $roman .= substr(&roman_to_int($roman, 1),0,1) if $tmp =~ /[a-z]/;\n     \
    \   $roman .= $tmp if $tmp !~ /[a-z]/;\n        $i++;\n    }\n    return lc($roman);\n\
    }", "    my($roman, $mini_roman);\n    my(@letters);\n    my($letter, $roman_letter);",
  "    my $mini_roman = \"\";\n    my $numeral_map = \"McDxXLiIoO\";\n    my $numeral_array_length\
    \ = length($numeral_map);\n    my $roman = int2roman($number);\n    my @roman_array\
    \ = split('', $roman);\n    for my $index (0 .. $#roman_array) {\n        $mini_roman\
    \ .= $numeral_map->[$index] if $index <= $numeral_array_length;\n    }\n    return\
    \ lc($mini_roman);\n}", "    return unless $number =~ /^\\d+$/;\n    # Mini-romans\
    \ are handy in some situations, but also very, very annoying\n    # to handle\
    \ by hand in code. Perl provides us with them.\n    # So, here's how they do it:\n\
    \    # 1. Build a string containing the digits, in order. We'll use that\n   \
    \ #    as the key to a hash of our already computed values.  This is\n    #  \
    \  really fast since we only have to process one digit at a time.\n    my $digits\
    \ = '';\n    while (1) {\n        my $d = $number % 10;\n        $number -= $d;\n\
    \        $digits .= $d;\n        unless ($number < 0) {\n            last if ($digits\
    \ !~ /[1-9]/);\n            die \"Invalid number: '$number'\"\n              \
    \  if ($number < 0);\n            return $digits;\n        }\n    }\n    # 2.\
    \ Look up the value of the hash for the current digits.\n    my $value = $roman_number_hash{$digits}\n\
    \        || die(\"Invalid number: '$number'\\n\");\n    # 3. Return the value\
    \ of the hash key.\n    return $value;\n}", "    if ($number <= 0) {\n       \
    \ return \"0\";\n    } elsif ($number <= 20) {\n        return $number . \"x\"\
    ;\n    } elsif ($number <= 40) {\n        return $number . \"l\";\n    } elsif\
    \ ($number <= 60) {\n        return $number . \"c\";\n    } elsif ($number <=\
    \ 100) {\n        return $number . \"d\";\n    } elsif ($number <= 200) {\n  \
    \      return $number . \"cm\";\n    } elsif ($number <= 400) {\n        return\
    \ $number . \"cd\";\n    } elsif ($number <= 600) {\n        return $number .\
    \ \"xc\";\n    } elsif ($number <= 1000) {\n        return $number . \"l\";\n\
    \    } else {\n        return \"error\";\n    }\n}", "    return $number if $number\
    \ < 1 || $number > 1000;\n    my($s, $m);\n    if ($number >= 1000){\n       \
    \ $s = \"mcm\";\n        $m = $number - 1000;\n    } elsif ($number >= 900){\n\
    \        $s = \"cdm\";\n        $m = $number - 900;\n    } elsif ($number >= 500){\n\
    \        $s = \"xcm\";\n        $m = $number - 500;\n    } elsif ($number >= 400){\n\
    \        $s = \"ixc\";\n        $m = $number - 400;\n    } elsif ($number >= 100){\n\
    \        $s = \"cm\";\n        $m = $number - 100;\n    } elsif ($number >= 50){\n\
    \        $s = \"lxc\";\n        $m = $number - 50;\n    } elsif ($number >= 40){\n\
    \        $s = \"xlc\";\n        $m = $number - 40;\n    } elsif ($number >= 10){\n\
    \        $s = \"xc\";\n        $m = $number - 10;\n    } elsif ($number >= 5){\n\
    \        $s = \"ix\";\n        $m = $number - 5;\n    } elsif ($number >= 1){\n\
    \        $s = \"x\";\n        $m = $number - 1;\n    } else {\n        $s = \"\
    i\";\n        $m = $number;\n    }\n    return ($s . $m);\n}", "    my($numstr,\
    \ $remainder, $roman);\n    my($num_str) = sprintf(\"%0${number}d\", $number);\n\
    \    if ($number < 1 || $number > 1000) {\n\treturn undef;\n    }\n    for ($roman\
    \ = 1, $remainder = $number - $roman, 1; $remainder >= 10; $remainder *= 10, $roman\
    \ += 1) {\n\t$roman = $remainder % 10;\n\t$remainder /= 10;\n\t$numstr = $num_str\
    \ || \"I\";\n\t$numstr .= $roman;\n    }\n    return lc($numstr);\n}", "    my\
    \ $roman = \"\";\n    while ($number > 0) {\n        $roman .= chr( (($number\
    \ % 1000) * 400) + ($number % 100) );\n        $number -= ($number % 1000);\n\
    \    }\n    return lc($roman);\n}", "    my $roman_numeral = \"\";\n    my $num_str\
    \ = format_number($number);\n    my @roman_chars;\n    my $i = 0;\n    while (!empty($num_str))\
    \ {\n        if ($num_str =~ /^([a-zA-Z]+)(\\d*)/) {\n            push(@roman_chars,\
    \ $1);\n            push(@roman_chars, $2);\n        }\n        $num_str =~ s/^([a-zA-Z]+)(\\\
    d*)/$1/;\n        $i++;\n    }\n    $i = 0;\n    while (!empty($roman_chars[$i]))\
    \ {\n        $roman_numeral .= substr($roman_chars[$i], 0, 1) . substr($roman_chars[$i],\
    \ 1);\n        $i++;\n    }\n    $roman_numeral =~ s/^([a-zA-Z]+)(\\d*)/$1/;\n\
    \    $roman_numeral =~ tr/[a-z]/[A-Z]/;\n    $roman_numeral =~ tr/[0-9]/[IVXLCDM]/;\n\
    \    $roman_numeral =~ tr/[ILD]/[IVXLCDM]/;\n    return $roman_numeral;\n}", " \
    \   $number =~ tr/IVXC/MVC/;\n    my @chars;\n    for my $i (1..$number) {\n \
    \       push @chars, ${'mini_roman_letters'}[$i];\n    }\n    return join(\"\"\
    , map {chop(\"\")} @chars);\n}", '    my($roman, $output, $prefix) = ();', '    my
    $mini = "";', '    my($num, $remainder, $roman, $temp);', "    my $num_int = abs($number);\n\
    \    my $roman = '';", "    my @chars = (\"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n    my @romans\
    \ = (\"MM\", \"CMC\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\");\n    my @numerals = (\"I\", \"II\", \"III\", \"IV\",\
    \ \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\");\n\
    \    my @result = ();", "    return unless $number > 1 && $number < 1000;\n  \
    \  my @roman;\n    my $i = 0;\n    while ($number >= $bases[$i]) {\n        push\
    \ @roman, $chars[$i];\n        $number -= $bases[$i];\n        $i++;\n    }\n\
    \    push @roman, $chars[$i];\n    return join(\"\", map { $roman[$_ - 1] } 0\
    \ .. $#roman);\n}", "    my($num, $i) = (0, 0);\n    my(@result);", "    my $roman;\n\
    \    my @digits = (0..9);\n    my @letters = ('a' .. 'z');\n    while (@digits\
    \ > 4) {\n        my $i = shift @digits;\n        if ($number == 0) {\n      \
    \      $roman .= 'zero';\n        }\n        elsif ($number == 1) {\n        \
    \    $roman .= $letters[$i];\n        }\n        elsif ($number >= 2) {\n    \
    \        my $new_digit = $number % 10;\n            $number /= 10;\n         \
    \   my $new_letter = substr($letters[$i], 0, 1) . 'x';\n            $roman .=\
    \ $new_letter.$new_digit;\n        }\n        elsif ($number >= 1) {\n       \
    \     $roman .= $letters[$i];\n        }\n        elsif ($number > 0) {\n    \
    \        $roman .= $letters[$i];\n        }\n    }\n    push (@digits, 0);\n \
    \   push (@letters, 0);\n    my $roman = \"${letters[@letters]}${digits[@digits]}\"\
    ;\n    chomp $roman;\n    return lc($roman);\n}", '    my($roman);', "    my(@roman)\
    \ = ();\n    my($i = 0); # index\n    my($roman_repeats) = 1; # number of repeats\n\
    \    my($roman_digit) = 0; # digit\n    my($roman_mask) = 0; # mask\n    my($roman_digits)\
    \ = undef; # digits array", "    $number = abs($number);\n    my $roman = substr(\
    \ $roman || '',\n\t\t       $number % 1000 ,\n\t\t       1,\n\t\t       '');\n\
    \    $roman .= substr( $roman || '',\n\t\t      $number % 1000 / 10 % 10 ,\n\t\
    \t      1,\n\t\t      '');\n    $roman .= substr( $roman || '',\n\t\t      $number\
    \ / 10 % 10 ,\n\t\t      1,\n\t\t      '');\n    $roman .= substr( $roman || '',\n\
    \t\t      $number / 100 % 10 ,\n\t\t      1,\n\t\t      '');\n    $roman .= substr(\
    \ $roman || '',\n\t\t      $number / 1000 % 10 ,\n\t\t      1,\n\t\t      '');\n\
    \    return $roman;\n}", "    my $roman;\n    if ($number == 1) {\n        $roman\
    \ = 'x';\n    } else {\n        my @roman;\n        my $i = 1;\n        while\
    \ (1) {\n            my $tmp = $number % 10;\n            $roman[$i] = $roman[$i\
    \ - 1] if $tmp;\n            last if $i == 10 and $number == $tmp;\n         \
    \   $i++;\n        }\n        $roman = join('', @roman);\n    }\n    return lc\
    \ $roman;\n}", '    $number += 0;', '    my(@digits, @roman);', '    my @digits;',
  "    my @numerals = (\"M\",  \"CM\", \"D\", \"CD\", \"C\", \"XC\",\n           \
    \         \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n    my @tens =\
    \ (\"\", \"\", \"\", \"T\", \"X\");\n    my $num_string = \"\";", "    # validate\
    \ args\n    die \"Invalid number: < 1\" unless $number >= 1;\n    die \"Invalid\
    \ number: > 999\" if $number > 1000;", "    my $str = '';\n    my $count = $number\
    \ % 10;\n    my $roman;", "    $number -= 1;\n    $number -= 1;\n    $number -=\
    \ 1;\n    my $result = '';", "    die \"Must be a positive integer\" unless $number\
    \ =~ /^\\d+$/;\n    my($roman) = $number =~ /(?:^|\\s)(M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})|I{0,3})(M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})|I{0,3})(M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})|I{0,3})/g;\n\
    \    return $roman =~ s/M{0,4}//g unless $roman =~ /^M{0,4}/ or $number =~ /^\\\
    d+$/;\n    return $roman =~ s/M{0,4}//g;\n}", "    my $roman = '';", "    my $roman\
    \ = \"\";\n    my %roman_table = (\"I\" => \"1\", \"V\" => \"5\", \"X\" => \"\
    10\", \"L\" => \"50\", \"C\" => \"100\", \"D\" => \"500\", \"M\" => \"1000\");\n\
    \    while ($number >= 100) {\n        $roman .= \"M\";\n        $number -= 100;\n\
    \    }\n    $roman .= $roman_table{$_} for reverse sort {$a <=> $b} keys %roman_table;\n\
    \    return $roman;\n}\n</code>\n<|/ a |>\n<| a tags=roman-numerals,perl |>\n\
    You can do it in one line:\n<code>\n$ perl -MPOSIX=strftime -E 'say strftime \"\
    %I\", 4'\nI\n$ perl -MPOSIX=strftime -E 'say strftime \"%I\", 13'\nXL\n$ perl\
    \ -MPOSIX=strftime -E 'say strftime \"%I\", 23'\nXXVII\n$ perl -MPOSIX=strftime\
    \ -E 'say strftime \"%I\", 60'\nXXI\n</code>\nThis works as long as your locale\
    \ doesn't use non-roman numerals.\n<|/ a dscore=4 |>\n<| a |>\nThis is very close\
    \ to what I was looking for, without reinventing the wheel.  Just wanted to see\
    \ if it would work for everyone.\n<code>\nuse strict;\nuse warnings;", "    my(@numerals);\n\
    \    my(@numeral_strings);\n    my($current_numeral);\n    my($current_numeral_string);",
  "    if ($number < 0) {\n        die \"Negative number passed to int_to_mini_roman:\
    \ $number\";\n    }\n    if ($number == 0) {\n        return \"0\";\n    }\n \
    \   my(@roman) = ();\n    my(@digits) = ();\n    my($numeral);\n    my($remainder);\n\
    \    my($last_digit);\n    my($digit);\n    my($roman);", '    my $roman_numeral
    = "";', "    my(@roman) = ();\n    my(@remainder) = ();", "    return unless $number\
    \ =~ /^\\d+$/;\n    return unless $number =~ /[IVXLCDM]+$/;", '    my($roman,
    $suffix);', "    my $mini_roman = uc($number);\n    $mini_roman =~ tr/cmf/cm/;\n\
    \    $mini_roman =~ tr/inx/x/;\n    $mini_roman =~ tr/ix/x/;\n    $mini_roman\
    \ =~ tr/iv/x/;\n    $mini_roman =~ tr/lm/m/;\n    $mini_roman =~ tr/dmf/dm/;\n\
    \    $mini_roman =~ tr/mdt/d/;\n    $mini_roman =~ tr/cmc/cm/;\n    $mini_roman\
    \ =~ tr/dmc/d/;\n    $mini_roman =~ tr/mdc/d/;\n    $mini_roman =~ tr/dc/d/;\n\
    \    $mini_roman =~ tr/cm/cm/;\n    return $mini_roman;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a dscore=2 |>\n<code>", "    # Convert integer to Roman numeral\n   \
    \ my @roman = ();\n    my $roman_string = '';", "    my($roman_str);\n    my($roman_dict)\
    \ = &get_roman_dict(0);\n    foreach my $num (@_) {\n        if($num < 1 || $num\
    \ > 1000) {\n            carp \"Error: $num must be 1 <= num <= 1000\";\n    \
    \        next;\n        }\n        if($roman_dict) {\n            my $roman_str\
    \ = $roman_dict->{$num};\n            push(@$roman_str, $num);\n            $roman_str\
    \ = join(\"\", @$roman_str);\n            push(@$roman_str, 0);\n            $roman_str\
    \ =~ s/$num$//;\n        }\n        else {\n            $roman_str = $roman_dict->{$num}\
    \ = $num;\n        }\n    }\n    return $roman_str;\n}", '    my($roman, $mini);',
  '    $number = abs($number);', '    my($roman_string, $i, $roman_string_len);',
  "    my $roman = '';\n    my $number = int($number);\n    my $roman_numbers = ('M'\
    \ => 1000, 'CM' => 900, 'D' => 500, 'CD' => 400,\n                         'C'\
    \ => 100, 'XC' => 90, 'L' => 50, 'XL' => 40,\n                         'X' =>\
    \ 10, 'IX' => 9, 'V' => 5, 'IV' => 4, 'I' => 1);", "    my(@roman_nums);\n   \
    \ my($i,$num);\n    my($alphabet,$roman);\n    my(@mini_roman);", "    my @roman;\n\
    \    my $roman = \"MCMXCIV\";\n    my $i=1;\n    my $a=0;\n    my $num=$number;\n\
    \    while($num > 0) {\n        my $remainder = $num % $roman;\n        $roman\
    \ = $roman . $roman;\n        $num = $num - $remainder;\n        $roman = substr($roman,\
    \ 0, 1) . $roman;\n        $i++;\n    }\n    return $roman;\n}", "    return \"\
    \" if $number < 1 || $number > 1000;\n    my $roman = \"\";\n    my $remainder\
    \ = $number % 1000;\n    my $i = 1;\n    my $digit = $number % 10;\n    my $new_i\
    \ = $i;\n    my $new_digit = $digit;\n    while ($remainder >= i*10) {\n     \
    \   $i += 1;\n        $digit *= 10;\n        $remainder -= i*10;\n        $new_i\
    \ += 1;\n        $new_digit *= 10;\n        $remainder -= i*10;\n    }\n    $roman\
    \ .= \"$new_i $new_digit\";\n    $number /= 1000;\n    until ($number == 0) {\n\
    \        my $remainder = $number % 10;\n        my $new_i = $i;\n        my $new_digit\
    \ = $digit;\n        while ($remainder >= i*10) {\n            $i += 1;\n    \
    \        $digit *= 10;\n            $remainder -= i*10;\n            $new_i +=\
    \ 1;\n            $new_digit *= 10;\n            $remainder -= i*10;\n       \
    \ }\n        $roman .= \"$new_i $new_digit\";\n        $number /= 10;\n    }\n\
    \    $roman .= $digit;\n    $roman = lc($roman);\n    return $roman;\n}", "  \
    \  my($alphabet) = @_;\n    $alphabet = \"a\" . $alphabet;\n    $alphabet = \"\
    b\" . $alphabet;\n    $alphabet = \"c\" . $alphabet;\n    $alphabet = \"d\" .\
    \ $alphabet;\n    $alphabet = \"e\" . $alphabet;\n    $alphabet = \"f\" . $alphabet;\n\
    \    $alphabet = \"g\" . $alphabet;\n    $alphabet = \"h\" . $alphabet;\n    $alphabet\
    \ = \"i\" . $alphabet;\n    $alphabet = \"j\" . $alphabet;\n    $alphabet = \"\
    k\" . $alphabet;\n    $alphabet = \"l\" . $alphabet;\n    $alphabet = \"m\" .\
    \ $alphabet;\n    $alphabet = \"n\" . $alphabet;\n    $alphabet = \"o\" . $alphabet;\n\
    \    $alphabet = \"p\" . $alphabet;\n    $alphabet = \"q\" . $alphabet;\n    $alphabet\
    \ = \"r\" . $alphabet;\n    $alphabet = \"s\" . $alphabet;\n    $alphabet = \"\
    t\" . $alphabet;\n    $alphabet = \"u\" . $alphabet;\n    $alphabet = \"v\" .\
    \ $alphabet;\n    $alphabet = \"w\" . $alphabet;\n    $alphabet = \"x\" . $alphabet;\n\
    \    $alphabet = \"y\" . $alphabet;\n    $alphabet = \"z\" . $alphabet;\n    $alphabet\
    \ = \"0\" . $alphabet;\n    $alphabet = \"1\" . $alphabet;\n    $alphabet = \"\
    2\" . $alphabet;\n    $alphabet = \"3\" . $alphabet;\n    $alphabet = \"4\" .\
    \ $alphabet;\n    $alphabet = \"5\" . $alphabet;\n    $alphabet = \"6\" . $alphabet;\n\
    \    $alphabet = \"7\" . $alphabet;\n    $alphabet = \"8\" . $alphabet;\n    $alphabet\
    \ = \"9\" . $alphabet;\n    my($alphabet2) = @_;\n    $alphabet = \"a\" . $alphabet2;\n\
    \    $alphabet = \"b\" . $alphabet2;\n    $alphabet = \"c\" . $alphabet2;\n  \
    \  $alphabet = \"d\" . $alphabet2;\n    $alphabet = \"e\" . $alphabet2;\n    $alphabet\
    \ = \"f\" . $alphabet2;\n    $alphabet = \"g\" . $alphabet2;\n    $alphabet =\
    \ \"h\" . $alphabet2;\n    $alphabet = \"i\" . $alphabet2;\n    $alphabet = \"\
    j\" . $alphabet2;\n    $alphabet = \"k\" . $alphabet2;\n    $alphabet = \"l\"\
    \ . $alphabet2;\n    $alphabet = \"m\" . $alphabet2;\n    $alphabet = \"n\" .\
    \ $alphabet2;\n    $alphabet = \"o\" . $alphabet2;\n    $alphabet = \"p\" . $alphabet2;\n\
    \    $alphabet = \"q\" . $alphabet2;\n    $alphabet = \"r\" . $alphabet2;\n  \
    \  $alphabet = \"s\" . $alphabet2;\n    $alphabet = \"t\" ", "    return '' unless\
    \ $number =~ m/^\\d+$/;", "    my $roman = \"\";\n    while(1) {\n        my($digit,$decimal)\
    \ = div($number,10);\n        $roman .= &_mini_roman_digit($digit);\n        $number\
    \ -= $decimal;\n        last unless $number;\n        $roman .= &_mini_roman_digit($decimal);\n\
    \    }\n    return $roman;\n}", "    \n    # Make sure the number is between 1\
    \ and 999.\n    if (!($number >= 1 && $number <= 999)) {\n\tdie \"Number out of\
    \ range (should be between 1 and 999): $number\";\n    }\n    \n    # Flip to\
    \ positive if necessary.\n    if ($number < 0) {\n\t$number = -$number;\n\t$sign\
    \ = \"-\";\n    } else {\n\t$sign = \"\";\n    }\n    \n    # Initialize the array\
    \ to hold the Roman numeral.\n    $roman = \"\";\n    \n    # Flip the number\
    \ to the correct position, starting from thousands.\n    while (1) {\n\t$roman\
    \ = ($number % 1000) + ($roman ? \".\" : \"\") . $roman;\n\t$number = int($number\
    \ / 1000);\n\tlast if ($number == 0);\n    }\n    \n    # Add the final roman.\n\
    \    $roman = ($sign ? $sign : \"+\") . $roman;\n    $roman =~ tr/cmf/CD/;\n \
    \   $roman =~ tr/inx/IX/;\n    $roman =~ tr/tnt/TN/CB/;\n    $roman =~ tr/mnh/ML/;\n\
    \    $roman =~ tr/roh/MR/;\n    $roman =~ tr/kdh/KD/;\n    $roman =~ tr/rzd/RZ/;\n\
    \    $roman =~ tr/ljm/LJ/;\n    $roman =~ tr/qmh/MH/;\n    $roman =~ tr/cmh/CM/;\n\
    \    $roman =~ tr/hdh/HD/;\n    $roman =~ tr/tmh/TM/;\n    $roman =~ tr/dmh/DM/;\n\
    \    $roman =~ tr/jhm/JM/;\n    $roman =~ tr/blm/BL/;\n    $roman =~ tr/plm/PL/;\n\
    \    $roman =~ tr/cpc/CP/;\n    $roman =~ tr/spc/SP/;\n    $roman =~ tr/hmp/HM/;\n\
    \    $roman =~ tr/tmm/TM/;\n    $roman =~ tr/mmm/MM/;\n    $roman =~ tr/mmf/MMF/;\n\
    \    $roman =~ tr/mpm/MP/;\n    $roman =~ tr/fmp/FP/", "    my $roman = '';\n\
    \    # Special cases\n    if($number < 1)  {\n        $roman = 'i';\n    }\n \
    \   elsif($number < 3) {\n        $roman = 'ii';\n    }\n    elsif($number < 6)\
    \ {\n        $roman = 'iii';\n    }\n    elsif($number < 9) {\n        $roman\
    \ = 'iv';\n    }\n    elsif($number < 12) {\n        $roman = 'v';\n    }\n  \
    \  elsif($number < 15) {\n        $roman = 'vi';\n    }\n    elsif($number < 18)\
    \ {\n        $roman = 'vii';\n    }\n    elsif($number < 21) {\n        $roman\
    \ = 'viii';\n    }\n    elsif($number < 24) {\n        $roman = 'ix';\n    }\n\
    \    elsif($number < 27) {\n        $roman = 'x';\n    }\n    elsif($number <\
    \ 30) {\n        $roman = 'xi';\n    }\n    elsif($number < 33) {\n        $roman\
    \ = 'xii';\n    }\n    elsif($number < 36) {\n        $roman = 'xiii';\n    }\n\
    \    elsif($number < 39) {\n        $roman = 'xiv';\n    }\n    elsif($number\
    \ < 42) {\n        $roman = 'xv';\n    }\n    elsif($number < 45) {\n        $roman\
    \ = 'xv';\n    }\n    elsif($number < 48) {\n        $roman = 'xvi';\n    }\n\
    \    elsif($number < 51) {\n        $roman = 'xvii';\n    }\n    elsif($number\
    \ < 54) {\n        $roman = 'xviii';\n    }\n    elsif($number < 57) {\n     \
    \   $roman = 'xix';\n    }\n    elsif($number < 60) {\n        $roman = 'x';\n\
    \    }\n    elsif($number < 63) {\n        $roman = 'xi';\n    }\n    elsif($number\
    \ < 66) {\n        $roman = 'xii';\n    }\n    elsif($number < 69) {\n       \
    \ $roman = 'xiii';\n    }\n    elsif($number < 72) {\n        $roman = 'xiv';\n\
    \    }\n    elsif($number < 75) {\n        $roman = 'xv';\n    }\n    elsif($number\
    \ < 78) {\n        $roman = 'xv';\n    }\n    elsif", "    my($roman);\n    my($temp);",
  '    my(@roman_array);', "    my $mini_roman = '';", "    my @romans = ( \"M\",\
    \ \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"\
    IV\", \"I\" );\n    # Romans cannot be preceded by a zero\n    my @mini_romans\
    \ = ();\n    my $i = 0;\n    while ($i < @romans and $number >= $romans[$i]) {\
    \ \n        $mini_romans[$i] = $romans[$i];\n        $i++;\n    }\n    $number\
    \ = $number - $romans[$i];\n    $i = 0;\n    while (1) {\n        if ($number\
    \ >= 100) { $number = $number - 100; $i++; }\n        elsif ($number >= 90) {\
    \ $number = $number - 9; $i++; }\n        elsif ($number >= 80) { $number = $number\
    \ - 8; $i++; }\n        elsif ($number >= 70) { $number = $number - 7; $i++; }\n\
    \        elsif ($number >= 60) { $number = $number - 6; $i++; }\n        elsif\
    \ ($number >= 50) { $number = $number - 5; $i++; }\n        elsif ($number >=\
    \ 40) { $number = $number - 4; $i++; }\n        elsif ($number >= 30) { $number\
    \ = $number - 3; $i++; }\n        elsif ($number >= 20) { $number = $number -\
    \ 2; $i++; }\n        elsif ($number >= 10) { $number = $number - 1; $i++; }\n\
    \        elsif ($number >= 1) {  $mini_romans[$i] = $mini_romans[$i].($number\
    \ % 10); $number = 0; }\n        else { $mini_romans[$i] = $mini_romans[$i].\"\
    0\"; }\n        last;\n    }\n    return $mini_romans[@mini_romans-1];\n}", " \
    \   my $roman;\n    my $numerals = \"III\";\n    for (my $i = 0; $i <= $number;\
    \ $i++) {\n        $roman .= $numerals[$number - $i];\n    }\n    return lc($roman);\n\
    }", "    my($str);\n    my(@roman);\n    my($int);", "    my $numeral = \"MCMXCIV\"\
    ;\n    if ($number < 0 || $number > 3999) {\n\treturn $number;\n    }\n    if\
    \ ($number < 1000) {\n\treturn $numeral->[$number - 1];\n    }\n    my @roman;\n\
    \    for (my $i = 0; $i < ($number / 1000); $i++) {\n\tmy $d = ($number / 1000)\
    \ - $i;\n\tpush @roman, int_to_mini_roman($d);\n    }\n    if ($number / 1000\
    \ < 1000) {\n\tpush @roman, int_to_mini_roman($number / 1000);\n    }\n    $roman[$_]\n\
    \tfor 1 .. $#numeral;\n    return join \"\", map { $numeral->[$_] } @roman;\n}",
  "    my $roman = '';\n    while ($number >= 1000) {\n        $roman .= int_to_mini_roman($number\
    \ / 1000).\"M\";\n        $number %= 1000;\n    }\n    $roman .= int_to_mini_roman($number);\n\
    \    $roman =~ s/^M$//;\n    return lc($roman);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Please add an explanation to your code.\n<|/ c |>\n<| a tags=perl |>\n<code>",
  "    my($roman, $result) = ('','');\n    my($num, $i) = ('','');\n    my(@roman)\
    \ = ('','');\n    # find out how many digits are in the given number\n    my $num_digits\
    \ = ($number < 10) ? 1 : 0;\n    while($number > 0){\n        $i = ($number %\
    \ 10);\n        $number /= 10;\n        $num += $i;\n    }\n    # populate an\
    \ array with the numbers 0 through n-1 and their roman\n    # equivalent\n   \
    \ for ($num) {\n        push(@roman, $romans[$i]);\n    }\n    # reverse the order\
    \ of roman\n    @roman = reverse @roman;\n    # capitalize the roman equivalent\n\
    \    foreach (@roman) {\n        $result .= $_ . ' ';\n    }\n    # remove the\
    \ space if there was a number before it\n    $result = $result =~ s/^\\s+//;\n\
    \    # trim off the space after the number\n    $result = $result =~ s/\\s+$//;\n\
    \    # return result in a lowercase\n    $result = lc($result);\n    return $result;\n\
    }", "    my $roman_numeral = \"\";\n    $roman_numeral .= $_ for (1 .. $number);\n\
    \    $roman_numeral =~ s/(.{3})/$1./g;\n    $roman_numeral =~ s/(.{1})/$1./g;\n\
    \    return lc($roman_numeral);\n}", "    my(@result) = (\"i\",\"ii\",\"iii\"\
    ,\"iv\",\"v\",\"vi\",\"vii\",\"viii\",\"ix\");\n    # Special cases\n    if ($number\
    \ == 10) return $result[0];\n    if ($number == 9) return $result[1];\n    if\
    \ ($number == 8) return $result[2];\n    if ($number == 7) return $result[3];\n\
    \    if ($number == 6) return $result[4];\n    if ($number == 5) return $result[5];\n\
    \    if ($number == 4) return $result[6];\n    if ($number == 3) return $result[7];\n\
    \    if ($number == 2) {\n        return $result[5].$result[6];\n    }\n    if\
    \ ($number == 1) {\n        return $result[5];\n    }\n    # Fall through\n  \
    \  $number -= 1;\n    my $last_digit_roman = 0;\n    my $last_digit_mini = 0;\n\
    \    for (my $i=0;$i<@result;$i++) {\n        my $current_digit_roman = $result[$i];\n\
    \        my $current_digit_mini = $result[$i];\n        my $digit_remainder =\
    \ substr($number,$i,1);\n        if ($last_digit_roman == 0) {\n            $current_digit_roman\
    \ = 0;\n        }\n        if ($last_digit_mini == 0) {\n            $current_digit_mini\
    \ = 0;\n        }\n        if ($digit_remainder == 1) {\n            $current_digit_roman\
    \ += 10;\n            $current_digit_mini -= 1;\n        }\n        if ($digit_remainder\
    \ == 2) {\n            $current_digit_roman += 5;\n            $current_digit_mini\
    \ -= 1;\n        }\n        if ($digit_remainder == 3) {\n            $current_digit_roman\
    \ += 1;\n            $current_digit_mini -= 1;\n        }\n        if ($digit_remainder\
    \ == 4) {\n            $current_digit_roman += 1;\n            $current_digit_mini\
    \ -= 1;\n        }\n        if ($digit_remainder == 5) {\n            $current_digit_roman\
    \ += 4;\n            $current_digit_mini -= 1;\n        }\n        if ($digit_remainder\
    \ == 6) {\n            $current_digit_roman += 3;\n            $current_digit_mini\
    \ -= 1;\n        }\n        if ($digit_remainder == 7) {\n            $current_digit_roman\
    \ += 2;\n            $current_digit_mini -= 1;\n        }\n        if ($digit_remainder\
    \ == 8) {\n            $current_digit_roman += 1;\n            $current_digit_mini\
    \ -= 1;\n        }\n        if ($digit_remainder == 9) {\n            $current_digit_roman\
    \ += 0;\n            $current_digit_mini -= 1;\n        }\n        if ($current_digit_roman)\
    \ {\n            $last_digit_roman = $current_digit_roman;\n        }\n      \
    \  if ($current_digit_mini) {\n            $", "    my $roman = &_roman_helper($number);\n\
    \    return $roman->[1] if $roman->[0] eq 'M';\n    return $roman->[0];\n}", " \
    \   \n    # Handle special cases.\n    return $number == 1 ? \"i\" :\n       \
    \    $number == 2 ? \"ii\" :\n           $number == 3 ? \"iii\" :\n          \
    \ $number == 4 ? \"iv\" :\n           $number == 5 ? \"v\" :\n           $number\
    \ == 6 ? \"vi\" :\n           $number == 7 ? \"vii\" :\n           $number ==\
    \ 8 ? \"ix\" :\n           $number == 9 ? \"ix\" :\n           $number == 10 ?\
    \ \"x\" :\n           $number == 11 ? \"x\" :\n           $number == 12 ? \"xx\"\
    \ :\n           $number == 13 ? \"xxx\" :\n           $number == 14 ? \"xxx\"\
    \ :\n           $number == 15 || $number == 16 ? \"xx\" :\n           $number\
    \ == 17 || $number == 18 ? \"xxx\" :\n           $number == 19 || $number == 20\
    \ ? \"xxx\" :\n           $number == 21 && $number == 30 && $number == 40 || $number\
    \ == 60 || $number == 80 ? \"xix\" :\n           $number == 31 && $number == 40\
    \ && $number == 50 || $number == 60 && $number == 80 ? \"xix\" :\n           $number\
    \ == 41 && $number == 50 && $number == 60 ? \"xix\" :\n           $number == 51\
    \ && $number == 60 ? \"xix\" :\n           $number == 61 && $number == 80 ? \"\
    xix\" :\n           $number == 71 && $number == 80 ? \"xix\" :\n           $number\
    \ == 81 && $number == 100 ? \"xix\" :\n           $number == 91 && $number ==\
    \ 100 ? \"xix\" :\n           $number == 101 && $number == 100 ? \"xix\" :\n \
    \          $number == 150 ? \"vii\" :\n           $number == 160 ? \"vii\" :\n\
    \           $number == 170 ? \"vii\" :\n           $number == 180 ? \"viii\" :\n\
    \           $number == 190 ? \"viii\" :\n           $number == 200 ? \"vi\" :\n\
    \           $number == 210 ? \"vi\" :\n           $number == 220 ? \"vi\" :\n\
    \           $number == 230 ? \"vi\" :\n           $number == 240 ? \"vi\" :\n\
    \           $number == 250 ? \"vi\" :\n           $number == 260 ? \"", "    my\
    \ $num = $number;\n    my($n1, $n2, $n3, $n4, $n5, $n6, $n7, $n8);\n    my($i,\
    \ $j, $temp);", "    $number //= 1;\n    my @digits = ();\n    my @strings = ();\n\
    \    while (1) {\n        push @digits, int rand 10;\n        push @strings, 'x'\
    \ x int(@digits);\n        unless ($number % 10) {\n            push @digits,\
    \ int($number/10);\n            push @strings, '' x (10-@digits);\n          \
    \  return join '', @strings;\n        }\n        push @digits, int($number/10);\n\
    \        push @strings, ($digits[0] + $digits[2] . 'i') x (10-@digits);\n    \
    \    $number %= 10;\n    }\n}", "    if ($number < 0) {\n        return \"no $number\"\
    ;\n    }\n    if ($number < 1000) {\n        return $number == 0 ? \"\" : &int_to_mini_roman($number\
    \ - 1)\n    }\n    my $mini_roman = \"\";\n    my $base = 1;\n    while ($number\
    \ >= $base) {\n        $mini_roman .= $base;\n        $number -= $base;\n    \
    \    $base *= 10;\n    }\n    $mini_roman .= $number;\n    return $mini_roman;\n\
    }", "    my $roman = \"\";\n    for(my $i = $number; $i >= 1; $i--) {\n      \
    \  my $n = $i;\n        $roman .= $roman ? \" ${roman}{$n}\" : $n++;\n    }\n\
    \    return lc $roman;\n}", "    my($i, $numerals, $numerals_as_string);\n   \
    \ if ($number < 1) {\n\treturn \"0\";\n    }\n    # convert number into array\
    \ of individual numerals\n    my($base) = Math::BigInt->new($number);\n    # return\
    \ an empty string if we don't have a base number\n    return \"\" if !defined\
    \ $base;\n    # initialize array that holds numerals as strings\n    $numerals\
    \ = [\"\"];\n    # loop through each numeral from right to left\n    for ($i =\
    \ $base->{sign}->size() - 1; $i >= 0; $i--) {\n\t# store numerals in array as\
    \ strings\n\t$numerals[$i] = $base->{sign}->[$i];\n\t# get next numeral in sequence\n\
    \t$base = $base->divide($base->{sign}->[$i]);\n    }\n    # return result as a\
    \ string\n    $numerals_as_string = join(\"\", @numerals);\n    # lower case result\n\
    \    return lc($numerals_as_string);\n}", "    my(@roman);\n    push @roman, \"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\";\n    if\
    \ ($number < 100) {\n        push @roman, \"I\", \"II\", \"III\", \"IV\", \"V\"\
    , \"VI\", \"VII\", \"VIII\", \"IX\";\n    }\n    while ($number >= 100) {\n  \
    \      push @roman, \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"\
    DCCC\", \"CM\";\n        $number -= 100;\n    }\n    while ($number >= 1000) {\n\
    \        push @roman, \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\",\
    \ \"LXXX\", \"XC\";\n        $number -= 1000;\n    }\n    while ($number >= 900)\
    \ {\n        push @roman, \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"\
    , \"VIII\", \"IX\";\n        $number -= 900;\n    }\n    while ($number >= 500)\
    \ {\n        push @roman, \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMM\", \"MMM\",\
    \ \"MMM\", \"MMM\";\n        $number -= 500;\n    }\n    while ($number >= 400)\
    \ {\n        push @roman, \"K\", \"KK\", \"KKK\", \"KKK\", \"KKK\", \"KKK\", \"\
    KKK\", \"KKK\";\n        $number -= 400;\n    }\n    while ($number >= 100) {\n\
    \        push @roman, \"L\", \"LL\", \"LLL\", \"LLLL\", \"LL\", \"LL\", \"LL\"\
    , \"LL\";\n        $number -= 100;\n    }\n    while ($number >= 90) {\n     \
    \   push @roman, \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\"\
    , \"XC\";\n        $number -= 90;\n    }\n    while ($number >= 50) {\n      \
    \  push @roman, \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\"\
    , \"CM\";\n        $number -= 50;\n    }\n    while ($number >= 40) {\n      \
    \  push @roman, \"L\", \"LL\", \"LLL\", \"LLLL\", \"LL\", \"LL\", \"LL\", \"LL\"\
    ;\n        $number -= 40;\n    }\n    while ($number >= 10) {\n        push @roman,\
    \ \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\";\n\
    \        $number -= 10;\n    }\n    while ($number >= 9) {\n        push "]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
