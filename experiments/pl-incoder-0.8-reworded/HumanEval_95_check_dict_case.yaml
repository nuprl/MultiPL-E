name: HumanEval_95_check_dict_case
language: pl
prompt: "# Given a hash, return 1 if all keys are strings in lower \n# case or all\
  \ keys are strings in upper case, else return .\n# The function should return  is\
  \ the given hash is empty.\n# Examples:\n# >>> check_dict_case({\"a\" => \"apple\"\
  , \"b\" => \"banana\"})\n# 1\n# >>> check_dict_case({\"a\" => \"apple\", \"A\" =>\
  \ \"banana\", \"B\" => \"banana\"})\n# \"\"\n# >>> check_dict_case({\"a\" => \"\
  apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# \"\"\n# >>> check_dict_case({\"\
  Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# \"\"\n# >>>\
  \ check_dict_case({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# 1\nsub check_dict_case\
  \ {\n    my($dict) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_dict_case;\n\
  \        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"b\" => \"banana\"\
  }),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"\
  p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}),\"\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"\
  p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}),\"\")) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"\
  Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}),\"\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"\
  STATE\" => \"NC\", \"ZIP\" => \"12345\"}),1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->({\"fruit\" => \"\
  Orange\", \"taste\" => \"Sweet\"}),1)) {\n        print \"ok!\" }else{\n       \
  \ exit 1;\n        }\n        if(eq_deeply($candidate->({}),\"\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return 1 if !scalar(keys %$dict);\n    for (my $key = sort keys\
    \ %$dict) {\n        if ($dict->{$key} !~ /^[a-z]*$/i) {\n            return 1;\n\
    \        } elsif ($dict->{$key} !~ /^[A-Z]*$/i) {\n            return 1;\n   \
    \     }\n    }\n    return \"\";\n}", "    my $return = undef;\n    foreach my\
    \ $key (sort keys %$dict) {\n        my $value = $dict->{$key};\n        my $type\
    \ = ref($value); # 'SCALAR' or \"ARRAY\" or \"HASH\"\n        next if ($type eq\
    \ 'HASH' && keys %$value == 0);\n        next if ($type eq 'ARRAY' && @$value\
    \ == 0);\n        next if ($type eq 'SCALAR' && $value =~ /^[a-z0-9]+$/i);\n \
    \       $return = $1 if $type eq 'HASH' && keys %$value == 0;\n        $return\
    \ = $1 if $type eq 'ARRAY' && @$value == 0;\n        $return = $1 if $type eq\
    \ 'SCALAR' && $value =~ /^[a-z0-9]+$/i;\n    }\n    return $return;\n}", "   \
    \ return 1 unless %$dict;\n    my $ret = 0;\n    foreach my $key (sort keys %$dict)\
    \ {\n        if ($key =~ /^[A-Z]/) {\n            $ret = 1;\n            last;\n\
    \        }\n        elsif ($key =~ /^[a-z]/) {\n            $ret = 1;\n      \
    \      last;\n        }\n    }\n    return $ret;\n}", "    $dict = sort_dict_by_key(%$dict);\n\
    \    my($ret) = 0;\n    foreach my $key (keys(%$dict)) {\n        if (lc($key)\
    \ eq lc($key)) {\n            $ret = \" \";\n        }\n        else {\n     \
    \       $ret = $key;\n        }\n    }\n    $ret;\n}", "    return 1 if($dict->{\"\
    \"}); # Empty hash means all keys are lower-case\n    $dict->{\"\"} = 0 if(!$dict->{\"\
    \"});\n    foreach my $key (keys %$dict) {\n        return 1 if(!($key =~ /[a-z]/i));\n\
    \        return 1 if(!($key =~ /[A-Z]/i));\n    }\n    return \"\";\n}", "   \
    \ if (not defined $dict) {\n        return 0;\n    }\n    my($keys) = keys %$dict;\n\
    \    my($i, $k, $v);\n    foreach $k (@$keys) {\n        $v = $dict->{$k};\n \
    \       if (!defined $v) {\n            return 0;\n        }\n        if (ref($v)\
    \ eq \"ARRAY\") {\n            foreach $v (@$v) {\n                $v = check_dict_case($v);\n\
    \                if (!defined $v) {\n                    return 0;\n         \
    \       }\n            }\n        } elsif (ref($v) eq \"HASH\") {\n          \
    \  $v = check_dict_case($v);\n            if (!defined $v) {\n               \
    \ return 0;\n            }\n        } elsif (ref($v) eq \"SCALAR\") {\n      \
    \      foreach $v (@{$v}) {\n                $v = check_dict_case($v);\n     \
    \           if (!defined $v) {\n                    return 0;\n              \
    \  }\n            }\n        } else {\n            $v = check_dict_case($v);\n\
    \            if (!defined $v) {\n                return 0;\n            }\n  \
    \      }\n    }\n    return 1;\n}", "    my $result = 1;\n    if (%$dict) {\n\
    \        foreach my $key (sort keys %$dict) {\n            if ($key =~ /^[A-Z0-9_]+$/)\
    \ {\n                my $lower_key = lc($key);\n                if ($lower_key\
    \ eq $key) {\n                    $result = 0;\n                }\n          \
    \      elsif ($key eq $lower_key) {\n                    $result = 0;\n      \
    \          }\n                else {\n                    $result = 1;\n     \
    \           }\n            }\n            else {\n                $result = 1;\n\
    \            }\n        }\n    }\n    return $result;\n}", "    my $strcase;\n\
    \    my @keys = keys %$dict;\n    return 0 unless scalar(@keys);\n    my $case\
    \ = lc(lc($dict->{$keys[0]}));\n    for(my $i = 1; $i < scalar(@keys); $i++) {\n\
    \        if($keys[$i] eq $keys[$i - 1]) {\n            $strcase .= $case eq $case\
    \ ? \"\" : 1;\n        } else {\n            $strcase .= $case ne $case ? 1 :\
    \ 0;\n        }\n    }\n    return $strcase;\n}", "    my $value = shift;\n  \
    \  return undef if ( not defined $dict);\n    my $key;\n    foreach my $key (\
    \ keys %$dict ) {\n        return undef if ( $key eq \"@keys\" );\n        $value\
    \ = substr($value,0,1) if lc($key) ne $key;\n        $value = substr($value,1)\
    \ if uc($key) ne $key;\n    }\n    return 1;\n}", "    \n    my ($keys, $keys,\
    \ $case);\n    \n    # Initialize $case to a default value\n    ($case) = $dict->{Case}\
    \ if exists $dict->{Case};\n    \n    # If $case is set to upper, convert to lower\
    \ and then check if any key is case\n    # equivalent.\n    if($case eq \"UPPER\"\
    ) {\n        foreach $key (keys(%{$dict})) {\n            $dict->{$key} =~ tr/A-Z/a-z/;\n\
    \            if(!exists $keys->{$key}) {\n                return 1;\n        \
    \    }\n        }\n        return \"\";\n    }\n    \n    # If $case is set to\
    \ lower, check if any key is case equivalent.\n    if($case eq \"LOWER\") {\n\
    \        foreach $key (keys(%{$dict})) {\n            $dict->{$key} =~ tr/a-z/A-Z/;\n\
    \            if(!exists $keys->{$key}) {\n                return 1;\n        \
    \    }\n        }\n        return \"\";\n    }\n    \n    # If $case is not set\
    \ to any of upper, lower or both, return the empty string.\n    return \"\";\n\
    }", "    my ($case_dict) = @_;\n    \n    foreach my $key (keys %$case_dict) {\n\
    \        my $value_lower = lc($case_dict->{$key});\n        my $value_upper =\
    \ uc($case_dict->{$key});\n        \n        if ($dict->{$key} eq $value_lower\
    \ || $dict->{$key} eq $value_upper) {\n            return 1;\n        }\n    }\n\
    \    \n    return \"\";\n}", "    foreach my $key (sort keys %$dict) {\n     \
    \   my $value = $dict->{$key};\n        my $str1 = $key =~ tr/a-zA-Z//cd;\n  \
    \      my $str2 = $value =~ tr/a-zA-Z//cd;\n        return \"\" unless $str1 eq\
    \ $str2;\n    }\n    return 1;\n}", "    my $case = 0;\n    foreach my $key (keys\
    \ %$dict) {\n        if ($dict->{$key} =~ /[a-z]/i) {\n            $case++;\n\
    \        } elsif ($dict->{$key} =~ /[A-Z]/i) {\n            $case++;\n       \
    \ }\n    }\n    return ($case == 0 ? \"\" : \"1\");\n}", "    return 0 unless\
    \ %$dict;\n    my $str = \"\";\n    foreach my $key (sort keys %$dict) {\n   \
    \     my $value = $dict->{$key};\n        if ($key =~ /^[a-z]/) {\n          \
    \  $str .= $key;\n        }\n        if ($key =~ /^[A-Z]/) {\n            $str\
    \ .= $key;\n        }\n    }\n    return $str =~ /^$/;\n}", "    \n    my $result\
    \ = 1;\n    \n    my $count = 0;\n    \n    foreach my $key (sort keys %$dict)\
    \ {\n        \n        if ($dict->{$key} =~ m/^[a-z]/i) {\n            $count++;\n\
    \        } elsif ($dict->{$key} =~ m/^[A-Z]/i) {\n            $count++;\n    \
    \    } else {\n            return 1;\n        }\n    }\n    \n    if ($count ==\
    \ 0) {\n        $result = 0;\n    }\n    \n    return $result;\n}", "    return\
    \ 1 if (keys %$dict != keys %{map uc, keys %$dict});\n    return 0 unless (keys\
    \ %$dict == keys %{map lc, keys %$dict});\n    return unless (keys %$dict == sort\
    \ keys %{map uc, sort keys %$dict});\n    return unless (keys %$dict == sort keys\
    \ %{map lc, sort keys %$dict});\n    return 1;\n}", "    \n    foreach my $key\
    \ (keys(%$dict)) {\n        return 0 unless $key =~ /^[a-z]+$/i;\n        return\
    \ 1 unless $key =~ /^[A-Z]+$/i;\n    }\n    return \"\";\n}", "    my($case_flag);\n\
    \    my($result);", "    my %keys;\n    my $flag = 1;\n    \n    if (defined $dict)\
    \ {\n        foreach my $key (sort keys %$dict) {\n            if ($key =~ /^\\\
    Q$dict{$key}/ or $key =~ /^\\Q$dict{lc($key)}) {\n                $keys{$key}\
    \ = $dict{$key};\n            }\n            else {\n                $flag = 0;\n\
    \            }\n        }\n    }\n    return $flag;\n}", "    return undef if\
    \ !$dict;\n    my %case;\n    foreach my $key (sort keys %$dict) {\n        $case{$key}\
    \ = 1 if lc($key) eq lc($dict->{$key});\n        $case{$key} = 1 if uc($key) eq\
    \ uc($dict->{$key});\n    }\n    if (scalar keys %case) {\n        return \"\"\
    ;\n    } else {\n        return 1;\n    }\n}", "    my $case_status = \"\";\n\
    \    for my $key (sort keys %$dict) {\n        return $case_status if $case_status\
    \ ne 1;\n        if(lc($key) eq uc($key)) {\n            $case_status = 1;\n \
    \       } elsif(lc($key) ne $dict{$key}) {\n            $case_status = \"\";\n\
    \        }\n    }\n    return $case_status;\n}", "    \n    my $case = \"1\";\n\
    \    foreach my $key (sort keys %$dict) {\n        my $val = uc($dict->{$key});\n\
    \        next unless (defined $val);\n        \n        $val =~ s/^\\s+|\\s+$//g;\n\
    \        \n        if ($val eq $key) {\n            $case = \"\";\n        }\n\
    \        elsif ($val !~ /^[a-z0-9]+$/) {\n            $case = \"\";\n        }\n\
    \    }\n    \n    return $case;\n}\n1\n</code>\n<|/ a tags=perl,regex |>\n<| c\
    \ |>\nYour second solution does not work. `\"ab\" \"ab\"` will return `\"1\"`,\
    \ instead of `\"0\"`.\n<|/ c |>\n<| c |>\n: That's a very good point. I didn't\
    \ really consider that case. I've just edited the answer to correct the problem,\
    \ but the solution is still ugly as hell.\n<|/ c |>\n<| a tags=perl,regex |>\n\
    I agree with other answers and comments that you need to parse the input instead\
    \ of looking for specific patterns. But if you still want to go with regex, here\
    \ are some hints for you:", "    my $result = \"\";\n    foreach my $key (sort\
    \ keys %$dict) {\n        my $value = $dict->{$key};\n        my $is_case_sensitive\
    \ = lc($key) eq uc($key);\n        if ($is_case_sensitive) {\n            $result\
    \ = $is_case_sensitive? uc($value) : uc($value);\n        }\n    }\n    if ($result\
    \ == \"\") {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n\
    }", "    my(@case_keys) = ();\n    my($first) = scalar(keys(%$dict));", "    my($lower,\
    \ $upper) = (\"\", \"\");\n    for (keys %$dict) {\n        $lower .= lc($dict->{$_})\
    \ if /^[a-z]+$/;\n        $upper .= uc($dict->{$_}) if /^[A-Z]+$/;\n    }\n  \
    \  if ($lower eq \"\" and $upper eq \"\") {\n\treturn \"0\"\n    } elsif ($lower\
    \ eq \"\") {\n\treturn $upper\n    } elsif ($upper eq \"\") {\n\treturn $lower\n\
    \    } else {\n\treturn \"\"\n    }\n}", "    return 1 unless scalar keys %$dict;\
    \ \n    for (sort keys %$dict) {\n\treturn 1 unless $_ =~ /^[a-zA-Z]+$/i || $_\
    \ =~ /^[A-Z]+$/i;\n    }\n    return \"\";\n}", "    my @keys = keys %$dict;\n\
    \    my $ret = 0;", "    my $case = \"upper\";\n    if (keys %$dict == 1) {\n\
    \        if (ref($dict->{$dict->keys()[0]}) || defined($dict->{$dict->keys()[0]}))\
    \ {\n            if ($dict->{$dict->keys()[0]} =~ m{^[A-Z]+$}) {\n           \
    \     $case = \"lower\";\n            }\n        }\n    }\n    elsif (keys %$dict\
    \ == 0) {\n        $case = \"lower\";\n    }\n    return $case;\n}", "    my($case)\
    \ = @_ ? @_ : $case;\n    # print \"\\n check_dict_case :: $case \\n\";", "  \
    \  my $hash_case = check_hash_case($dict);\n    if ($hash_case eq 1) {\n     \
    \   my $key;\n        for (keys(%$dict)) {\n            $key = $dict->{$_};\n\
    \            if ($key =~ /^[a-z]+$/i) {\n                $dict->{$_} = \"true\"\
    ;\n            } else {\n                $dict->{$_} = \"false\";\n          \
    \  }\n        }\n        return 1;\n    } else {\n        return $hash_case;\n\
    \    }\n}", "    my $result = \"\";\n    foreach my $key (keys %$dict) {\n   \
    \     my $value = $dict->{$key};\n        if ((!defined($value)) || (length($value)\
    \ eq 0)) {\n            return $result;\n        }\n        elsif (is_string($key))\
    \ {\n            foreach my $l (split(' ', $key, -1)) {\n                if (!is_string($l))\
    \ {\n                    return $result;\n                }\n            }\n \
    \       }\n        else {\n            if (!is_string($value)) {\n           \
    \     return $result;\n            }\n        }\n    }\n    return $result;\n}",
  "    my $result;\n    foreach my $key (sort keys %$dict) {\n        my $value =\
    \ $dict->{$key};\n        if (!defined($value) || !ref($value)) {\n          \
    \  $result = 0;\n        }\n        else {\n            $value = lc($value);\n\
    \            $result = $result or $value eq uc($value);\n        }\n    }\n  \
    \  \n    return $result;\n}", "    my $case = 1;\n    foreach my $key (keys %$dict)\
    \ {\n        if ($dict->{$key} !~ /string/i) {\n            $case = \"\";\n  \
    \          last;\n        }\n    }\n    return $case;\n}", "    my $result;\n\
    \    for my $key (sort keys %$dict) {\n\tif (is_string($key)) {\n\t    $result\
    \ .= $key if (lc($key) eq lc($dict->{$key}));\n\t} else {\n\t    $result .= $key\
    \ if ($dict->{$key} eq $key);\n\t}\n    }\n    return $result;\n}", "    my $result\
    \ = 1;\n    my $case_flag;\n    my %temp_hash;\n    my @temp_arr;\n    \n    foreach\
    \ my $key (keys %$dict) {\n        my $temp_str = lc($key);\n        $temp_str\
    \ = uc($temp_str) if $temp_str =~ /[A-Z]/;\n        $temp_str = lc($temp_str)\
    \ if $temp_str =~ /[a-z]/;\n        $temp_hash{$temp_str} = $dict{$key};\n   \
    \ }\n    \n    for my $key (keys(%$dict)) {\n        $case_flag = lc($key) eq\
    \ $key ? 1 : 0; \n        if ($case_flag == 1) {\n            $case_flag = 0;\n\
    \            $temp_arr[0] = $key;\n            $temp_arr[1] = $temp_hash{$key};\n\
    \        }\n    }\n    \n    if (!$temp_arr[0] || !$temp_arr[1]) {\n        $case_flag\
    \ = \"\";\n        $result = \"\";\n    }\n    \n    return $case_flag;\n}", " \
    \   my $ret = check_list(keys(%$dict));\n    return 0 if $ret;\n    my $ret =\
    \ check_list(map { lc($_) => 1 } keys(%$dict));\n    return 0 if $ret;\n    return\
    \ \"\";\n}", "    \n    my ($case) = ($dict ? $dict->{CAMEL_CASE_TYPE} : 0);",
  "    my($lower);\n    my($upper);\n    my($first);\n    my($result);", "    my($result)\
    \ = 1;\n    \n    while(my ($key, $val) = each %$dict) {\n        if(is_string($key))\
    \ {\n            if($key eq $key) { $result = 0; }\n        }\n        else {\n\
    \            if($key eq $key) { $result = 0; }\n        }\n    }\n    \n    return\
    \ $result;\n}", "    if(!defined $dict){\n        carp(\"check_dict_case(): hash\
    \ must be given as first argument to function.\");\n        return 0;\n    }\n\
    \    foreach my $key (sort(keys(%$dict))){\n        if(!defined $dict->{$key}\
    \ || ref $dict->{$key} ne \"HASH\"){\n            return 0;\n        }\n     \
    \   my @keys = sort keys %{ $dict->{$key} };\n        if(@keys > 1){\n       \
    \     return 0;\n        }\n        if(@keys == 1 && $keys[0] =~ /^[A-Z0-9]+$/){\n\
    \            return 1;\n        }\n        else{\n            return \"\";\n \
    \       }\n    }\n    return 1;\n}", "    my($result) = 0;\n    \n    foreach\
    \ my $key (keys %$dict) {\n        my $value = $dict->{$key};\n        \n    \
    \    if (exists $case{$key}) {\n            my $case_value = $case{$key};\n  \
    \          if ($case_value ne $value) {\n                $result = 1;\n      \
    \      }\n        } elsif (defined $value) {\n            $result = 1;\n     \
    \   }\n    }", "    my($is_case_sensitive);\n    foreach my $key (keys %$dict){\n\
    \        my $value = $dict->{$key};\n        $is_case_sensitive = ($key =~ /[A-Z]/)\
    \ || ($key =~ /[a-z]/);\n        my $is_string = ($value =~ /[^\\d,]/ || $value\
    \ =~ /[\\[\\]]/ || $value =~ /[\\\"]/);\n        my $is_numeric = ($value =~ /[\\\
    d]/ || $value =~ /[\\+\\-]/ || $value =~ /[\\*]/ || $value =~ /[\\/\\/]/ || $value\
    \ =~ /[\\%]/ || $value =~ /[\\&]/ || $value =~ /[\\|]/);\n        my $is_list\
    \ = ($value =~ /[\\[\\]]/ || $value =~ /[\\\"]/);\n        my $is_dict = ($value\
    \ =~ /[\\[\\]]/ || $value =~ /[\\\"]/);\n        my $is_hash = ($value =~ /[\\\
    {\\}]/ || $value =~ /[\\[\\]]/);\n        my $is_scalar = ($is_string || $is_numeric\
    \ || $is_list || $is_dict || $is_hash);\n        if ($is_case_sensitive && !$is_scalar)\
    \ {\n            return 1;\n        }\n    }\n    return \"\";\n}", "    foreach\
    \ my $key (keys(%$dict)) {\n        if (exists($dict->{$key}) && $dict->{$key}\
    \ ne \"\") {\n            if (exists $dict->{$key} && lc($dict->{$key}) eq uc($dict->{$key}))\
    \ {\n                return \"\";\n            }\n            return 1;\n    \
    \    }\n    }\n    return 0;\n}", "    \n    my $is_all_strings_lower;\n    my\
    \ $is_all_strings_upper;\n    \n    my $key;\n    foreach $key (keys(%$dict))\
    \ {\n        my $value = $dict->{$key};\n        \n        if (ref $value eq 'HASH')\
    \ {\n            $is_all_strings_lower = check_dict_case($value) if $value->{LOWER};\n\
    \            $is_all_strings_upper = check_dict_case($value) if $value->{UPPER};\n\
    \        }\n        else {\n            $is_all_strings_lower = 1 if is_string($value)\
    \ && $value eq '' || $value eq 'true' || $value eq 'false';\n            $is_all_strings_upper\
    \ = 1 if is_string($value) && $value eq '' || $value eq 'true' || $value eq 'false';\n\
    \        }\n        \n        return 1 if ($is_all_strings_lower && $is_all_strings_upper);\n\
    \    }\n    \n    return '';\n}", "    my %hash = %$dict;\n    my @keys = keys\
    \ %hash;\n    my $lower = 1;\n    my $upper = 1;\n    my $case = 1;\n    foreach\
    \ my $key (@keys) {\n        my $value = $hash{$key};\n        if (defined $value)\
    \ {\n            if ($key =~ /^([A-Z][a-z])$/) {\n                $upper = $upper\
    \ * $1;\n            } elsif ($key =~ /^([a-z][A-Z])$/) {\n                $lower\
    \ = $lower * $1;\n            } else {\n                $case = $case * $key;\n\
    \            }\n        }\n    }\n    if ($lower + $upper + $case == 0) {\n  \
    \      return 1;\n    } else {\n        return $case;\n    }\n}", "    \n    my\
    \ $ret = 0;\n    \n    my $k;\n    foreach $k (keys %$dict) {\n        if ($dict->{$k}\
    \ eq $dict->{$k}) {\n            # If the key is the same as the value, that's\
    \ ok.\n        } else {\n            $ret++;\n        }\n    }", "    my $check\
    \ = 1;\n    foreach my $key (keys %$dict) {\n        if(!is_string($key) || ($key\
    \ =~ /^[A-Z]/i)) {\n            $check = 0;\n            last;\n        }\n  \
    \  }\n    return $check;\n}", "    my %case = qw(A a B b);\n    foreach my $key\
    \ (keys %$dict) {\n        return 1 if $case{$key} and !$dict->{$key} and !lc($key)\
    \ eq uc($key);\n    }\n    return 1;\n}", "    my $string = 0;\n    if (keys %$dict\
    \ == 0){\n        die \"Empty Hash\";\n    }", "    \n    if(keys %$dict == 0)\
    \ {\n        return 1;\n    }\n    \n    foreach my $key (sort keys %$dict) {\n\
    \        if(lc($key) eq lc($key)) {\n            return 1;\n        }\n      \
    \  if($key =~ m/[^a-z]/) {\n            return 1;\n        }\n        if($key\
    \ =~ m/[^A-Z]/) {\n            return 1;\n        }\n    }\n    return 0;\n}",
  "    \n    my($is_lower);\n    my($is_upper);\n    \n    my $str_keys_count = keys\
    \ %$dict;\n    \n    if ($str_keys_count > 0) {\n        foreach my $key (sort\
    \ keys %$dict) {\n            \n            # if the key has a non-alphanumeric\
    \ character, it must be \n            # a dictionary key\n            if ($key\
    \ =~ /^\\W/) {\n                return \"Dictionary keys can only contain alphanumeric\
    \ characters or underscores.\";\n            }\n            \n            # If\
    \ the key is lower case in the dictionary, then set \n            # the flag accordingly\n\
    \            if (lc($key) eq $key) {\n                $is_lower = 1;\n       \
    \     }\n            \n            # If the key is upper case in the dictionary,\
    \ then set \n            # the flag accordingly\n            if (uc($key) eq $key)\
    \ {\n                $is_upper = 1;\n            }\n            \n           \
    \ if ($is_lower == 1 && $is_upper == 0) {\n                return 1;\n       \
    \     } elsif ($is_lower == 0 && $is_upper == 1) {\n                return \"\"\
    ;\n            }\n        }\n        \n        return \"\";\n    }\n    else {\n\
    \        return 1;\n    }\n}", "    my($case);\n    foreach my $k (keys %$dict)\
    \ {\n\tnext if $k eq 'State' or $k eq 'City';\n\tnext if $k =~ /^\\d+$/ or $k\
    \ =~ /^[A-Z_]+$/;\n\t$case = \"\";\n\tif (lc($k) eq lc($k)) {\n\t    $case = \"\
    upper\";\n\t} else {\n\t    $case = \"lower\";\n\t}\n\tif ($case eq \"upper\"\
    ) {\n\t    $case .= \"d\";\n\t}\n\treturn \"case \" . $case . \": $k\";\n    }\n\
    \    return \"\";\n}", "    my $result = 1;\n    foreach my $key (sort(keys(%$dict)))\
    \ {\n        if ($dict->{$key} =~ /^[a-zA-z]+$/i) {\n        }\n        elsif\
    \ ($dict->{$key} =~ /^[A-Z]+$/i) {\n        }\n        else {\n            $result\
    \ = \"\";\n        }\n    }\n    return $result;\n}", "    my @keys = keys %$dict;\n\
    \    \n    foreach my $key (@keys) {\n\tnext if !defined($dict->{$key});\n   \
    \     \n\treturn 1 if lc($key) eq lc($dict->{$key});\n    }\n    \n    return\
    \ \"\";\n}", '    my $result;', "    my $ret = 1;\n    foreach my $key (keys %$dict)\
    \ {\n        my $val = uc($dict->{$key});\n        return \"\" if $val != $key\
    \ && $key !~ /^[A-Z]+$/;\n        $ret = 0;\n    }\n    return $ret;\n}", "  \
    \  $dict = {};\n    foreach my $key (keys %$dict) {\n        my $value = $dict->{$key};\n\
    \        if (is_string($value)) {\n            if (lc($key) == lc($value)) {\n\
    \            } else {\n                $dict->{$key} = \"\";\n            }\n\
    \        } else {\n            $dict->{$key} = 0;\n        }\n    }\n    return\
    \ 1 if !%$dict;\n    return \"\";\n}\n1;\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Your approach is better than mine because it's more robust. However, it can be\
    \ improved by making the hash key comparisons case-insensitive and by removing\
    \ the need to rebuild a new hash (`$dict = {};`).\n<|/ c |>\n<| c |>\nI thought\
    \ about that too, but I didn't think of the possibility of having two different\
    \ key names. Agreed?\n<|/ c |>\n<| c |>\nIf you're willing to trust your users,\
    \ you can just say that the keys are all lower-case or upper-case, and you can\
    \ assume that they're always in that case.\n<|/ c |>\n<| a tags=perl |>\nHere's\
    \ one possibility:\n<code>", "    my $check = 1;\n    foreach my $key (keys %$dict)\
    \ {\n        if(ref $dict->{$key} eq \"HASH\") {\n            $check = $check\
    \ and check_dict_case($dict->{$key});\n        } elsif(lc($key) eq lc($dict->{$key}))\
    \ {\n        } elsif(!lc($key) eq uc($dict->{$key})) {\n            $check = 0;\n\
    \        }\n    }\n    return $check;\n}", "    my(@return);\n    foreach my $key\
    \ (sort keys %$dict) {\n        if(exists $dict{$key} and $dict{$key} ne \"\"\
    ) {\n            if($key =~ /^[a-z]/i or $key =~ /^[A-Z]/i) {\n              \
    \  push(@return, $key);\n            } else {\n                push(@return, \"\
    \");\n            }\n        }\n    }\n    if(@return) {\n        return join(\"\
    \", @return);\n    } else {\n        return 1;\n    }\n}", "    my($result) =\
    \ \"\";\n    foreach my $key (keys(%$dict)) {\n        my $value = $dict->{$key};\n\
    \        if( !ref($value) || ref($value) eq \"HASH\" ) {\n            if ( is_lower_case_string($key)\
    \ ) {\n                $result = \"1\";\n                return $result;\n   \
    \         }\n            elsif ( is_upper_case_string($key) ) {\n            \
    \    $result = \"1\";\n                return $result;\n            }\n      \
    \  }\n    }\n    $result = \"1\";\n    return $result;\n}", "    my $result =\
    \ 1;\n    my @keys = keys(%$dict);\n    foreach my $key (@keys) {\n\tmy $value\
    \ = $dict->{$key};\n\tif ($value =~ /^[A-Z]+$/) {\n\t    if ($key =~ /^[a-z]+$/)\
    \ {\n\t\t$result = '';\n\t\tlast;\n\t    }\n\t}\n    }\n    return $result;\n}",
  "    my $ret = 0;\n    foreach my $k (keys %$dict) {\n        next if $k !~ /^[A-Z]+$/;\n\
    \        if (exists $dict->{$k}) {\n            my $str = $dict->{$k};\n     \
    \       $ret += $str !~ /^[A-Z]+$/;\n        }\n        else {\n            $ret\
    \ += 1;\n        }\n    }\n    return $ret;\n}", "    return 1 if keys %$dict\
    \ == 0;\n    for my $key (keys %$dict) {\n        return 1 if ($dict->{$key} eq\
    \ '' or lc($dict->{$key}) == $dict->{$key});\n    }\n    return 0;\n}", "    \n\
    \    if (scalar(@{$dict}) == 0) {\n        return \"\";\n    }", "    my @keys\
    \ = keys %$dict;\n    return 1 if @keys == 0 || @keys == scalar(@keys);\n    my\
    \ $firstkey = shift @keys;\n    my $firstkey_lower = lc($firstkey);\n    my $firstkey_upper\
    \ = uc($firstkey);\n    foreach my $key (@keys) {\n        my $value_lower = lc($dict->{$key});\n\
    \        my $value_upper = uc($dict->{$key});\n        return 1 if $value_lower\
    \ eq $firstkey_lower || $value_upper eq $firstkey_upper;\n    }\n    return \"\
    \";\n}\n</code>\n<|/ a tags=perl,hash |>\n<| a dscore=0 |>\nHere is another solution,\
    \ where you can give any hash variable and it will check all the keys and values.\n\
    <code>", "    my $return_val = 0;\n    foreach my $key ( keys %$dict ) {\n   \
    \     if( $dict->{$key} eq \"_\" ) {\n            $return_val = 0;\n        }\
    \ elsif( lc($dict->{$key}) eq lc($dict->{$key}) ) {\n            $return_val =\
    \ 0;\n        } elsif( !($dict->{$key} =~ /^[[:alpha:]]+$/) ) {\n            $return_val\
    \ = 0;\n        } elsif( !($dict->{$key} =~ /^[[:upper:]]+$/) ) {\n          \
    \  $return_val = 0;\n        } else {\n            $return_val = 1;\n        }\n\
    \    }\n    return $return_val;\n}", "    if (%$dict) {\n        my @keys = keys\
    \ %$dict;\n        if (@keys) {\n            my $lower = $keys[0];\n         \
    \   my $upper = uc($keys[0]);\n            for my $key (@keys) {\n           \
    \     $key =~ s/\\W/$lower/g;\n                $key =~ s/\\W/$upper/g;\n     \
    \           if ($key ne $lower) {\n                    return '';\n          \
    \      }\n            }\n        }\n        else {\n            return 1;\n  \
    \      }\n    }\n    else {\n        return 1;\n    }\n}", "    \n    foreach\
    \ my $key (keys %$dict) {\n        return 1 if $dict->{$key} !~ /[a-z]/;\n   \
    \     return 1 unless $dict->{$key} =~ /[a-z]/;\n    }\n    return \"\";\n}",
  "    my $result = 1;\n    my($key, $value);\n    foreach $key (sort(keys(%$dict)))\
    \ {\n        $value = $dict->{$key};\n        $result = $result if ref($value)\
    \ ne \"HASH\";\n        $result = $result if exists($dict->{$key}) && $dict->{$key}\
    \ =~ /^[a-z]/i;\n        $result = $result if exists($dict->{$key}) && $dict->{$key}\
    \ =~ /^[A-Z]/i;\n    }\n    return $result;\n}", "    my %keys = %$dict;\n   \
    \ my $string_keys = 0;\n    my $upper_string_keys = 0;\n    my $value_keys = 0;\n\
    \    my $upper_value_keys = 0;\n    foreach my $key (keys(%$dict)) {\n       \
    \ if ($key =~ /^[a-z]/i) {\n            $string_keys++;\n        } elsif ($key\
    \ =~ /^[A-Z]/i) {\n            $upper_string_keys++;\n        } else {\n     \
    \       $value_keys++;\n        }\n        if ($key =~ /[A-Z]$/i) {\n        \
    \    $upper_value_keys++;\n        }\n    }\n    return ($string_keys == $value_keys)\
    \ ? 0 : $string_keys == $upper_string_keys ? 1 : \"\";\n}", "    my ($key) = \"\
    \";\n    foreach my $k (keys %$dict) {\n        if (exists $dict->{$k}) {\n  \
    \          next unless ($dict->{$k}=~/^[Uu]\\+$/);\n            $key = lc $k;\n\
    \            last;\n        }\n    }\n    return $key;\n}", "    foreach my $key\
    \ (keys(%$dict)) {\n        my $value = $dict->{$key};\n        next if not exists\
    \ $string_keys{$key};\n        next if $value =~ /^[[:upper:]]+$/;\n        next\
    \ if $value =~ /^[[:lower:]]+$/;\n        my $message = &message(\n          \
    \      \"Bad case in hash: expected strings in lower case or upper case for key\
    \ \\\"$key\\\"\",\n                $dict, $key, $value);\n        return &fail(\n\
    \                $message,\n                $dict,\n                $key,\n  \
    \              $value,\n                1);\n    }\n    return 1;\n}", "    my\
    \ $check;\n    foreach my $key (sort(keys(%$dict))) {\n        if(not is_string($key))\
    \ \n        {\n            $check = 0;\n        }\n        else\n        {\n \
    \           $check = 1;\n        }\n    }\n    return $check;\n}", '    my(@strings);',
  '    my $found = 1;', "    if(!scalar(keys %$dict)) { return \"\"; }\n    my $lower\
    \ = uc(keys(%$dict));\n    my $upper = uc(keys(%$dict, lc => 1));\n    return\
    \ \"\" if scalar(@$lower != scalar(@$upper));\n    return \"\" if scalar(@$lower\
    \ == scalar(@$upper));\n    return 1 \n        if @$lower == 0;\n    return \"\
    \" if @$lower == 1;\n    return 1\n        if @$lower > 1;\n    return 0;\n}",
  "    my $result;\n    \n    if (keys %$dict == 0) {\n        $result = 1;\n    }\n\
    \    else {\n        my $uppercase_keys = 0;\n        my $lowercase_keys = 0;",
  "    if(scalar(keys(%$dict)) == 0){\n        return 1;\n    }\n    my $case = 1;\n\
    \    foreach my $key (keys(%$dict)){\n        if($key =~ /^[A-Z0-9]$/i){\n   \
    \         $case = 0;\n        }\n    }\n    return $case;\n}", "    my $result\
    \ = 1;\n    foreach my $key (sort keys %$dict) {\n        next if !is_string($key)\
    \ or $key eq \"nil\" or $key eq \"undef\";\n        next if !is_string($dict->{$key});\n\
    \        if ($key =~ /^[a-z]+$/) {\n            $result = 1;\n        }\n    \
    \    else {\n            $result = '';\n        }\n    }\n    return $result;\n\
    }", "    my $flag = 0;\n    \n    if (scalar keys %$dict == 0) {\n        return\
    \ $flag;\n    }\n    \n    foreach my $key (sort keys %$dict) {\n        if (ref($dict->{$key})\
    \ eq \"HASH\") {\n            my ($string1, $string2) = check_dict_case($dict->{$key});\n\
    \            $flag = $flag and $string1 eq $string2;\n        }\n        else\
    \ {\n            $flag = $flag and lc $dict->{$key} eq uc $dict->{$key};\n   \
    \     }\n    }\n    return $flag;\n}\n        ", "    my($strings_lower) = 0;\n\
    \    my($strings_upper) = 0;\n    \n    foreach my $key (keys(%$dict)) {\n   \
    \     if($dict->{$key} =~ /^[a-z]+$/i) {\n            $strings_lower += 1;\n \
    \       }\n        if($dict->{$key} =~ /^[A-Z]+$/i) {\n            $strings_upper\
    \ += 1;\n        }\n    }\n    \n    if($strings_lower == 0 && $strings_upper\
    \ == 0) {\n        return 1;\n    }\n    if($strings_lower != 0 && $strings_upper\
    \ != 0) {\n        return \"\";\n    }\n    return 1;\n}", "    my(@keys, @values);\n\
    \    # check if input is empty\n    return 1 unless keys %$dict;\n    \n    @keys\
    \ = keys %$dict; # get keys\n    # convert keys to lower case\n    foreach my\
    \ $key (@keys) { \n        push(@values, $dict->{$key}) if (lc($key) eq $key);\n\
    \    }\n    # return empty string if all keys are strings in lower case\n    #\
    \ return empty string if all keys are strings in upper case\n    return 1 if @values\
    \ == @keys;\n    # return 1 if there are any string in lower case and all \n \
    \   # keys are string in upper case\n    return 0 if (@values != @keys);\n   \
    \ \n    return \"\";\n}", "    my $flag = 1;\n    foreach my $key (sort keys %$dict)\
    \ {\n\tnext if $dict->{$key} !~ /^[a-z_]/;\n\tnext if $dict->{$key} !~ /^[A-Z_]/;\n\
    \t\n\treturn \"\" if $flag;\n\t\n\t$flag = 0;\n    }\n    return 1;\n}", "   \
    \ my @keys = keys %$dict;\n    my $ret = \"\";\n    \n    foreach my $key (@keys)\
    \ {\n        $ret .= $key if lc($key) eq lc($key);\n        $ret .= $key if uc($key)\
    \ eq uc($key);\n    }\n    \n    return $ret == \"\" ?  \"1\" : $ret;\n}", " \
    \   my $str = join(\"\",map{lc $dict->{$_}} keys %$dict);\n    return 1 if length($str)\
    \ == 0;\n    return $str =~ /^[[:upper:]]*$/i ? \"\" : \"1\";\n}", "    my $case\
    \ = 1;\n    my $str = \"\";", "    my $case_insensitive = 1;\n    my $is_first\
    \ = 1;\n    my $result;\n    my %temp_hash;", "    $dict->{HASH} ||= {};\n   \
    \ my($keys, $value) = each %$dict;\n    return 0 unless $keys;\n    return 1 if\
    \ $value =~ /string/i;\n    return 1 if $value =~ /string\\U/i;\n    return 1;\n\
    }", "    my $dict_size = scalar keys %$dict;\n    \n    if($dict_size != scalar\
    \ keys %{$dict->{UC}}) {\n        return 1;\n    } elsif($dict_size != scalar\
    \ keys %{$dict->{LC}}) {\n        return \"\";\n    }\n    \n    foreach(keys(%$dict))\
    \ {\n        if($dict->{$_} ne $dict->{UC}{$_} or $dict->{$_} ne $dict->{LC}{$_})\
    \ {\n            return \"\";\n        }\n    }\n    \n    return 1;\n}", "  \
    \  foreach my $key (sort keys %$dict) {\n        return 1 unless lc($key) eq uc($key);\n\
    \    }\n    return \"\";\n}", "    my $result;\n    \n    # check all keys are\
    \ strings\n    foreach my $key (keys %$dict) {\n        if (not ref $dict->{$key})\
    \ {\n            if (lc($dict->{$key}) || uc($dict->{$key})) {\n             \
    \   $result = 0;\n            }\n        }\n    }\n    \n    return $result;\n\
    }", "    my %case;\n    \n    foreach my $key (keys %$dict) {\n        $case{$key}\
    \ = uc $key if lc($key) eq lc($dict->{$key});\n    }\n    \n    return \"\" if\
    \ keys(%case);\n    return 1;\n}", "    return \"\" if %$dict == ();\n    my $count\
    \ = 0;\n    foreach my $key (keys %$dict) {\n        if (exists $dict->{$key}\
    \ && UNIVERSAL::isa($dict->{$key}, \"HASH\")) { # It's a hash.\n            my\
    \ $has_string_keys = check_dict_case($dict->{$key}); # Recursively check.\n  \
    \          $count += $has_string_keys ? 1 : 0;\n        } elsif (exists $dict->{$key}\
    \ && UNIVERSAL::isa($dict->{$key}, \"ARRAY\")) { # It's an array\n           \
    \ my $has_string_keys = check_dict_case($dict->{$key}); # Recursively check.\n\
    \            $count += $has_string_keys ? 1 : 0;\n        } else {\n         \
    \   if (lc($key) eq lc($dict->{$key})) {\n                $count += 1;\n     \
    \       }\n        }\n    }\n    return $count;\n}", '    return unless (%$dict);',
  "    my ($key, $val);\n    \n    for (sort {$a cmp $b} keys %$dict) {\n\t($key =\
    \ $dict->{$_}) =~ s/[\\d\\s]+$//;\n\t$val = $dict->{$_};\n\tif ($key =~ /^([a-z]|[A-Z])$/\
    \ && $val =~ /^([a-z]|[A-Z])$/) {\n\t    next;\n\t}\n\treturn \"All keys must\
    \ be in lower case or all keys must be in upper case\";\n    }", "    $dict{tolower($dict)}\
    \ ||= $dict{uc($dict)};\n}\n</code>\n<|/ a tags=perl |>\n<| a |>\n<code>", '    my
    $ret = "";', "    \n    foreach my $key ( keys %$dict ) {\n        return 1 if\
    \ !is_string($key) || \n               !is_string($dict->{$key}->[0]) \n     \
    \        || lc($key) ne lc($dict->{$key}->[0]);\n    }\n    \n    return \"\"\
    ;\n}", "    return 1 unless keys %$dict || keys %$dict == keys keys %$dict;\n\
    \    return \"\" if keys %$dict == (keys %$dict+1); \n    my $strs = map { $_\
    \ eq $dict->{$_} ? 1 : 0} keys %$dict;\n    return 1 unless $strs == (scalar @$strs);\n\
    \    return 0;\n}", "    return 1 if $dict == {} || keys %{$dict} == 0;\n    foreach\
    \ my $key (keys %{$dict}) {\n        return 1 if $key !~ /^\\w+$/;\n        return\
    \ 1 if $key !~ /^\\w$/;\n        return 1;\n    }\n    return 0;\n}", "    \n\
    \    my $str = join(\"\", map { $_->[0] } grep { $dict->{$_} == 1 } keys %$dict);\n\
    \    return $str ? 1 : \"\";\n}", "    my($result);\n    foreach my $key (sort\
    \ keys %$dict) {\n        my $value = $dict->{$key};\n        $result .= $value\
    \ if lc($key) eq lc($value);\n    }\n    return $result ? \"\" : \"1\";\n}", " \
    \   my $result = 1;\n    foreach my $key ( keys %$dict ) {\n        return $result\
    \ if lc($key) eq lc($key);\n        $result = \"\";\n    }\n    return $result;\n\
    }", "    my %case_change = (\n        'A' => 'a',\n        'a' => 'a',\n     \
    \   'B' => 'b',\n        'b' => 'b',\n        'C' => 'c',\n        'c' => 'c',\n\
    \        'D' => 'd',\n        'd' => 'd',\n        'E' => 'e',\n        'e' =>\
    \ 'e',\n        'F' => 'f',\n        'f' => 'f',\n        'G' => 'g',\n      \
    \  'g' => 'g',\n        'H' => 'h',\n        'h' => 'h',\n        'I' => 'i',\n\
    \        'i' => 'i',\n        'J' => 'j',\n        'j' => 'j',\n        'K' =>\
    \ 'k',\n        'k' => 'k',\n        'L' => 'l',\n        'l' => 'l',\n      \
    \  'M' => 'm',\n        'm' => 'm',\n        'N' => 'n',\n        'n' => 'n',\n\
    \        'O' => 'o',\n        'o' => 'o',\n        'P' => 'p',\n        'p' =>\
    \ 'p',\n        'Q' => 'q',\n        'q' => 'q',\n        'R' => 'r',\n      \
    \  'r' => 'r',\n        'S' => 's',\n        's' => 's',\n        'T' => 't',\n\
    \        't' => 't',\n        'U' => 'u',\n        'u' => 'u',\n        'V' =>\
    \ 'v',\n        'v' => 'v',\n        'W' => 'w',\n        'w' => 'w',\n      \
    \  'X' => 'x',\n        'x' => 'x',\n        'Y' => 'y',\n        'y' => 'y',\n\
    \        'Z' => 'z',\n        'z' => 'z',\n        'a' => 'A', # change to uppercase\n\
    \        'A' => 'A',\n        'b' => 'B',\n        'B' => 'B',\n        'c' =>\
    \ 'C',\n        'C' => 'C',\n        'd' => 'D',\n        'D' => 'D',\n      \
    \  'e' => 'E',\n        'E' => 'E',\n        'f' => 'F',\n        'F' => 'F',\n\
    \        'g' => 'G',\n        'G' => 'G',\n        'h' => 'H',\n        'H' =>\
    \ 'H',\n        'i' => 'I',\n        'I' => 'I',\n        'j' => 'J',\n      \
    \  'J' => 'J',\n        'k' => 'K',\n        'K' => 'K',\n        'l' => 'L',\n\
    \        'L' => 'L',\n        'm' => 'M',\n        'M' => 'M',\n        'n' =>\
    \ 'N',\n        'N' => 'N',\n        'o' => 'O',\n        'O' => 'O',\n      \
    \  'p' => 'P',\n        'P' => 'P',\n        'q' => 'Q',\n        'Q' => 'Q',\n\
    \        'r' => 'R',\n        'R' => 'R',\n        's' => 'S',\n        'S' =>\
    \ 'S',\n        't", "    $dict   ||= {};\n    my $result = 1;\n    my $key;\n\
    \    foreach $key ( sort keys %$dict ) {\n        if( not is_string($key) or \n\
    \            not is_string($dict->{$key})) {\n            $result = 0;\n     \
    \   }\n    }\n    return $result;\n}", "    my($check_all) = $dict->{_check_all};\n\
    \    \n    if(not defined $check_all) {\n        $check_all = \"_all\";\n    }\n\
    \    elsif($check_all eq \"_all\") {\n        $check_all = 1;\n    }\n    \n \
    \   foreach my $key (keys(%$dict)) {\n        if($key eq $check_all) {\n     \
    \       next;\n        }\n        else {\n            if(!is_string($key)) {\n\
    \                $dict->{$key} = \"$key\";\n            }\n        }\n    }",
  '    my($return) = "";', "    return $dict->{\"0\"} if !defined($dict->{\"0\"});\n\
    \    foreach my $key (sort keys %$dict) {\n        my $string_key;\n        if\
    \ ($key =~ /^([A-Z_])/) {\n            $string_key = $1;\n        }\n        elsif\
    \ ($key =~ /^([a-z0-9])/) {\n            $string_key = $1;\n        }\n      \
    \  elsif ($key =~ /^([0-9])/) {\n            $string_key = $1;\n        }\n  \
    \      else {\n            $string_key = \"0\";\n        }\n        return $string_key\
    \ if $string_key =~ /^[a-z]+$/i;\n        return $string_key if $string_key =~\
    \ /^[A-Z]+$/i;\n    }\n    return \"\";\n}", "    my @keys = keys %$dict;\n  \
    \  return $keys[0] =~ /^[a-z]+$/ if $keys[0] =~ /^[a-z]+$/;\n    return $keys[0]\
    \ =~ /^[A-Z]+$/ if $keys[0] =~ /^[A-Z]+$/;\n    return 1;\n}", "    foreach my\
    \ $key ( sort keys %$dict ) {\n        if( $dict->{$key} eq \"null\" || \n   \
    \         $dict->{$key} eq \"Undef\" || \n            $dict->{$key} eq \"false\"\
    \ || \n            $dict->{$key} eq \"false\" || \n            $dict->{$key} eq\
    \ \"0\" ||\n            $dict->{$key} eq \"0.0\" || \n            $dict->{$key}\
    \ eq \"0.0\" ||\n            $dict->{$key} eq \"[]\" ) {\n            return 1;\n\
    \        }\n    }\n    return \"\";\n}", "    foreach my $key (keys %$dict) {\n\
    \        my $value = $dict->{$key};\n        return 1 if lc($value) eq lc($key)\
    \ && $value ne \"\";\n    }\n    return \"\";\n}", "    my $result = \"\";\n \
    \   foreach my $key (keys %$dict) {\n        my $value = $dict->{$key};\n    \
    \    if ( ! $value || $value eq \"{}\" || $value eq \"[]\" ) {\n            return\
    \ $result;\n        }\n        foreach my $str (split(//, $value)) {\n       \
    \     $result = 1 if ($str =~ /^[a-z]/i); \n            $result = 1 if ($str =~\
    \ /^[A-Z]/i);\n            return $result;\n        }\n    }\n    return $result;\n\
    }", "    my $case_result;\n    my $keys_str = keys %$dict;\n    my @keys = sort\
    \ keys %$dict;\n    $keys_str = join(\", \", @keys);\n    foreach my $key (@keys)\
    \ {\n        my $lower_key = uc($key);\n        $case_result = $case_result &&\
    \ ($lower_key =~ /^[A-Z]+$/);\n    }\n    $case_result = $case_result || (@keys\
    \ == 0);\n    return $case_result;\n}", "    if(keys %$dict == 0){\n        return\
    \ \"\";\n    }\n    my $case = check_dict_case_internal($dict);\n    return $case;\n\
    }", "    my $result = 0;\n    for (keys(%$dict)) {\n        my $k = $dict->{$_};\n\
    \        if (ref($k) eq 'HASH') {\n            my $ret = check_dict_case($k);\n\
    \            $result = $result || $ret;\n        }\n        else\n        {\n\
    \            if (lc($k) eq lc($dict->{$_}))\n            {\n                $result\
    \ = 1;\n            }\n        }\n    }\n    return $result;\n}", "    foreach\
    \ my $k (keys %$dict) {\n        if(not is_string($k) || not is_string($dict->{$k}))\
    \ {\n            return 0;\n        }\n    }\n    return 1;\n}", '    my $check
    = "";', "    \n    if (scalar(@$dict) == 0){\n        return 0;\n    }\n    my\
    \ $str = \"\";\n    foreach my $keys (keys(%$dict)){\n        my $value = $dict->{$keys};\n\
    \        if ($value eq \"NA\"){\n            return 0;\n        }\n        if\
    \ (is_string($value)){\n            $str .= uc($value) . \"/\";\n        }\n \
    \   }\n    if (length($str) == 0){\n        return 0;\n    }\n    return 1;\n}",
  "    my($hash) = $dict->();\n    return \"\" unless defined $hash;\n    my @keys\
    \ = $hash->keys;\n    my $flag = \"\";", "    if(!$dict) { return 0; }\n    my\
    \ $check = \"\";\n    for my $key (keys %$dict) {\n        if(lc($key) eq lc($key))\
    \ {\n            $check = \"1\";\n            last;\n        }\n    }\n    return\
    \ $check;\n}", "    my @keys = keys %{$dict};\n    my $case = check_case(@keys);\n\
    \    return $case if $case == 0;\n    my $result = $case == 1 ? 1 :0;\n    foreach\
    \ my $key (@keys) {\n        if ($case) {\n            $result = 1 if $key eq\
    \ lc($key);\n        } else {\n            $result = 1 if $key eq uc($key);\n\
    \        }\n    }\n    return $result;\n}", '    my $key = "";', "    my %check;\n\
    \    \n    foreach my $key (sort keys %$dict) {\n        if($key =~ /^[A-Z]/i)\
    \ {\n            $check{\"$key\"} = 1;\n        } elsif ($key =~ /^[a-z]/i) {\n\
    \            $check{\"$key\"} = 0;\n        } else {\n            return 1;\n\
    \        }\n    }\n    \n    foreach my $key (sort keys %check) {\n        if(!defined($check{$key}))\
    \ {\n            return 1;\n        }\n    }\n    \n    return \"\";\n}", "  \
    \  my @keys;\n    my @vals;\n    foreach my $key (sort keys %$dict) {\n      \
    \  push @keys, $key;\n        push @vals, $dict->{$key};\n    }\n    my $flag\
    \ = 1;\n    foreach my $key (sort keys %$dict) {\n        my @val = split /[A-z]/,\
    \ $dict->{$key};\n        if (@val > 1) {\n            $flag = 0;\n          \
    \  last;\n        }\n    }\n    return $flag;\n}", "    return 1 if @$dict ==\
    \ 0;\n    foreach my $key (keys %$dict) {\n\treturn 1 if $key =~ /^[a-z]+$/i or\
    \ $key =~ /^[A-Z]+$/i;\n    }\n    return \"\";\n}", "    my $case = shift(@$dict);\n\
    \    foreach my $key (sort keys %$dict) {\n        my $value = $dict->{$key};\n\
    \        $case = check_case_value($key, $value, $case);\n        if ($case eq\
    \ '1') {\n            return 1;\n        }\n    }\n    return \"\";\n}", "   \
    \ return 0 if !defined $dict;\n    my $result = \"\";\n    foreach my $key (sort\
    \ keys %$dict) {\n        return 0 if $key !~ /^[A-z0-9]+$/i;\n        return\
    \ 1 if $key =~ /^[a-z]+$/i;\n        return $result if $result ne \"\";\n    }\n\
    \    return 1;\n}", "    my $lower = 1;\n    my $upper = 1;\n    for (sort keys\
    \ %$dict) {\n        my $key = lc($_);\n        $lower = 1 if ($key !~ /^[a-z_]+$/i);\n\
    \        $upper = 1 if ($key !~ /^[A-z]+$/i);\n    }\n    if ($lower == 1 && $upper\
    \ == 1) {\n        return 1;\n    }\n    else {\n        return \"\";\n    }\n\
    }", "    return 1 if (keys %$dict == 0);\n    my $all_string = 1;\n    my $all_lower_string\
    \ = 1;\n    my $all_upper_string = 1;\n    foreach (keys %$dict) {\n        return\
    \ 1 if ($dict->{$_} ne $dict->{$_}->{lc});\n        if ($dict->{$_} =~ /^[a-z]+$/)\
    \ {\n            $all_lower_string = 0;\n        } else {\n            $all_upper_string\
    \ = 0;\n        }\n    }\n    1 if ($all_lower_string && $all_upper_string);\n\
    \    return \"\";\n}", "    my $str_count = ();\n    my $uppercase = 0;\n    foreach\
    \ my $key (keys %$dict){\n        my $value = $dict->{$key};\n        if ($key\
    \ eq 'ALLCAPS' || $key eq 'ALLCASE_KEY'){\n            $str_count = check_str_in_dict($value,\
    \ $str_count);\n        } elsif (substr($key, 0, 1) eq '_'){\n            $str_count\
    \ = check_str_in_dict($value, $str_count);\n        } elsif (is_numeric($key)){\n\
    \            $str_count = check_str_in_dict($value, $str_count);\n        } elsif\
    \ (substr($key, 0, 1) eq '$'){\n            $str_count = check_str_in_dict($value,\
    \ $str_count);\n        } elsif (is_numeric($value)){\n            $str_count\
    \ = check_str_in_dict($value, $str_count);\n        } elsif ($value =~ m/[^A-Za-z]/){\n\
    \            $str_count = check_str_in_dict($value, $str_count);\n        } elsif\
    \ ($value =~ m/[^A-Z]/){\n            $str_count = check_str_in_dict($value, $str_count);\n\
    \        } elsif ($value =~ m/[A-Z]/){\n            $uppercase = 1;\n        }\
    \ elsif ($key eq 'ALLCAPS' || $key eq 'ALLCASE_KEY'){\n            $str_count\
    \ = check_str_in_dict($value, $str_count);\n        } elsif ($value =~ m/[^A-Za-z]/){\n\
    \            $str_count = check_str_in_dict($value, $str_count);\n        } elsif\
    \ ($value =~ m/[^A-Z]/){\n            $str_count = check_str_in_dict($value, $str_count);\n\
    \        } elsif ($value =~ m/[A-Z]/){\n            $uppercase = 1;\n        }\n\
    \    }\n    return ($str_count == 0 and $uppercase == 1);\n}", "    my($result)\
    \ =\n        grep {\n            if( exists($dict->{$_}) ){\n                if(\
    \ lc($dict->{$_}) eq lc($_) ) {\n                    $dict->{$_};\n          \
    \      }\n                else {\n                    $result;\n             \
    \   };\n            }\n            else {\n                $result;\n        \
    \    };\n        } keys %{$dict};\n    return $result;\n}", "    foreach my $key\
    \ (sort keys %$dict) {\n        if(!is_string($key)) {\n            return 0;\n\
    \        }\n        elsif(!is_string($dict->{$key})) {\n            return 0;\n\
    \        }\n    }\n    return 1;\n}", "    return $dict->{_} unless $dict->{_};\n\
    \    my $cased = $dict->{_};\n    my $found;\n    foreach my $key (sort keys %$cased)\
    \ {\n        my $value = $cased->{$key};\n        $found = $1 if ($key =~ /^[a-z]+$/i)\
    \ || ($key =~ /^[A-Z]+$/i);\n    }\n    return $found;\n}", "    my $result =\
    \ '';\n    \n    foreach my $key (sort keys %$dict) {\n        next unless (defined\
    \ $key && $key =~ /^[A-Z]+$/);\n        \n        if ($key =~ /^[a-z]+$/i) {\n\
    \            $result++;\n        }\n        elsif ($key =~ /^[A-Z]+$/i) {\n  \
    \          $result++;\n        }\n    }\n    \n    return $result;\n}", "    my\
    \ @string_keys = keys %$dict;\n    my $str_len = scalar @string_keys;\n    \n\
    \    return $str_len == 0 ||\n    ($str_len == 1 && $string_keys[0] =~ /^[AaBbCc]$/i)\
    \ ? \"\" :\n    ($str_len == 1 && $string_keys[0] =~ /^[A-Z]$/i) ? 1 : \n    ($str_len\
    \ == 1 && $string_keys[0] =~ /^[a-z]$/i) ? \"\" :\n    ($str_len == 2 && ($string_keys[0]\
    \ =~ /^[AaBbCc]$/i && $string_keys[1] =~ /^[A-Z]$/i)) ? \"\" :\n    ($str_len\
    \ == 2 && ($string_keys[0] =~ /^[A-Z]$/i && $string_keys[1] =~ /^[a-z]$/i)) ?\
    \ \"\" :\n    ($str_len == 2 && ($string_keys[0] =~ /^[a-z]$/i && $string_keys[1]\
    \ =~ /^[AaBbCc]$/i)) ? \"\" :\n    ($str_len == 2 && ($string_keys[0] =~ /^[AaBbCc]$/i\
    \ && $string_keys[1] =~ /^[A-Z]$/i) && ($string_keys[1] =~ /^[a-z]$/i)) ? \"\"\
    \ :\n    ($str_len == 2 && ($string_keys[0] =~ /^[a-z]$/i && $string_keys[1] =~\
    \ /^[AaBbCc]$/i) && ($string_keys[1] =~ /^[A-Z]$/i)) ? \"\" :\n    ($str_len ==\
    \ 2 && ($string_keys[0] =~ /^[AaBbCc]$/i && $string_keys[1] =~ /^[A-Z]$/i) &&\
    \ ($string_keys[1] =~ /^[AaBbCc]$/i)) ? \"\" :\n    ($str_len == 2 && ($string_keys[0]\
    \ =~ /^[A-Z]$/i && $string_keys[1] =~ /^[a-z]$/i) && ($string_keys[1] =~ /^[AaBbCc]$/i))\
    \ ? \"\" :\n    ($str_len == 2 && ($string_keys[0] =~ /^[a-z]$/i && $string_keys[1]\
    \ =~ /^[A-Z]$/i) && ($string_keys[1] =~ /^[A-Z]$/i)) ? \"\" :\n    ($str_len ==\
    \ 2 && ($string_keys[0] =~ /^[A-Z]$/i && $string_keys[1] =~ /^[a-z]$/i) && ($string_keys[1]\
    \ =~ /^[a-z]", "    my($result) = 0;\n    my($temp);\n    foreach $temp (keys\
    \ %$dict) {\n        ($temp =~ /^([A-Z]|[a-z])+$/)\n            or $result =~\
    \ /^$temp$/\n            or $result =~ /^$temp\\|$/\n            or $result++;\n\
    \    }\n    return $result;\n}\n    ", "    my %hash = %$dict;\n    for my $key\
    \ (sort keys %hash) {\n        return 0 if $key !~ /^[A-Z]+$/;\n        return\
    \ 0 if ($key !~ /^[a-z]+$/i); \n    }\n    return 1;\n}", "    my $ret = -1;\n\
    \    my $str = lc($dict->{'a'});\n    if ($str =~ /^[a-z]*$/) {\n        $ret\
    \ = 1;\n    }\n    elsif ($str =~ /^[A-Z]*$/) {\n        $ret = \"\";\n    }\n\
    \    return $ret;\n}", "    my $case_ok = 1;\n    foreach my $key (sort keys %$dict)\
    \ {\n        return $case_ok if lc($key) eq lc($dict->{$key});\n        return\
    \ $case_ok if $key ne $dict->{$key};\n    }\n    return $case_ok;\n}", "    my\
    \ $result;\n    foreach my $key (keys %$dict) {\n        $result = 1;\n      \
    \  if ( ref($dict->{$key}) ) {\n            if ( $dict->{$key} eq \"\" && $dict->{$key}->[0]\
    \ eq \"\" ) {\n                $result = 0;\n            }\n            elsif\
    \ ( $dict->{$key} eq \"\" || $dict->{$key}->[0] eq \"\" || $dict->{$key}->[0]\
    \ eq \"null\" ) {\n                $result = 0;\n            }\n            else\
    \ {\n                $result = 1;\n            }\n        }\n        else {\n\
    \            $result = 1;\n        }\n        return $result;\n    }\n    return\
    \ $result;\n}", "    my $case = '';\n    foreach my $key (keys %$dict) {\n   \
    \     if (not is_numeric($key)) {\n            $case = uc($key);\n           \
    \ last if ($case eq uc($key));\n        }\n    }\n    return 1 if ($case ne '');\n\
    \    return '';\n}", "    my $flag = 0;\n    \n    return $flag if scalar(keys\
    \ %$dict) == 0;\n    \n    foreach my $key (sort keys %$dict) {\n        if ($key\
    \ eq lc($key)) {\n            $flag++;\n            next;\n        }\n       \
    \ if ($key eq uc($key)) {\n            $flag++;\n            next;\n        }\n\
    \        $flag++;\n    }\n    return $flag;\n}", "    return 1;\n}", "    foreach\
    \ my $key (keys %$dict) {\n        my $value = $dict->{$key};\n        next if\
    \ !defined($value) || !defined($key) || !defined($value) || !defined($key);\n\
    \        my $type = ref($value);\n        if ($type =~ /HASH/) {\n           \
    \ # recurse in if $value is a hash\n            check_dict_case($value);\n   \
    \     } elsif ($type =~ /ARRAY/) {\n            # recurse in if $value is an array\n\
    \            foreach my $value ($value) {\n                check_dict_case($value);\n\
    \            }\n        } elsif ($type =~ /I/) {\n            my $isUpper = lc($key)\
    \ eq uc($key);\n            if ($isUpper) {\n                $value = uc($value);\n\
    \            } else {\n                $value = lc($value);\n            }\n \
    \       }\n        return 1 if $value == $key;\n    }\n    return \"\";\n}", " \
    \   my $lower = lc($dict->{$_}) for keys(%$dict);\n    $lower = uc($lower) for\
    \ keys(%$dict);\n    return 1 if $lower == uc($lower);\n    return \"\";\n}",
  "    my(@keys, $key, $value);\n    \n    if (is_array($dict) && scalar @$dict >\
    \ 0) {\n        foreach $key (keys(%$dict)) {\n            $value = $dict->{$key};\n\
    \            if (not is_string($value)) {\n                push(@keys, $key);\n\
    \            }\n        }\n        if (scalar @keys == 0) {\n            return\
    \ 1;\n        } elsif (scalar @keys > 1) {\n            foreach (@keys) {\n  \
    \              $value = $dict->{$_};\n                if (is_string($value)) {\n\
    \                    return \"\";\n                }\n            }\n        }\
    \ else {\n            $key = $keys->[0];\n            $value = $dict->{$key};\n\
    \            if (is_string($value)) {\n                return \"\";\n        \
    \    }\n        }\n    } else {\n        return \"\";\n    }\n    return 0;\n}",
  "    my($result) = $dict->{ALL} ? 0 : \"\";\n    foreach my $key (sort keys %$dict)\
    \ {\n        return $result if $key eq \"ALL\";\n        if (exists $dict->{uc($key)})\
    \ {\n            $result = 1;\n            last;\n        }\n    }\n    return\
    \ $result;\n}", "    my $check_all = 1;\n    my %lower_case_keys = ();\n    my\
    \ %upper_case_keys = ();\n    foreach my $key (sort keys %$dict) {\n        my\
    \ $value = $dict->{$key};\n        my $value_lower = $value;\n        $value_lower\
    \ =~ tr/[a-z]/[A-Z]/;\n        my $value_upper = $value;\n        $value_upper\
    \ =~ tr/[A-Z]/[a-z]/;\n        if($check_all) {\n            if($value_lower ne\
    \ $value) {\n                $check_all = 0;\n            }\n        }\n     \
    \   elsif($value_lower ne $value_upper) {\n            $check_all = 0;\n     \
    \   }\n    }\n    return $check_all;\n}\n</code>\n<|/ a tags=perl,sorting,hash\
    \ |>\n<| c |>\nI appreciate you taking the time to review my code.  I have only\
    \ been working with perl for a few months so I'm still learning as I go.  I still\
    \ don't understand what I'm doing with your sort block.  Could you explain it\
    \ in your answer, and maybe the purpose of the '<=>' sign?\n<|/ c |>\n<| c |>\n\
    I've added a clarification to my answer.\n<|/ c |>\n<| c |>\nThank you for the\
    \ clarification, that really helps me understand what <=> means.\n<|/ c |>\n<|\
    \ c |>\nI don't like that your original `is_lower` doesn't use strict and warnings.\
    \ It's possible that you've already used them, but you never know. Using `eq`\
    \ and `ne` instead of `=~` might save you from surprises. Also, why did you set\
    \ `$value_lower` and `$value_upper` to `$value`?\n<|/ c |>\n<| c |>\nAh, good\
    \ call. I thought I had tried that, but I guess I didn't because it didn't work.\
    \ I'll add those in now. Thanks.\n<|/ c |>\n<| a tags=perl,sorting,hash dscore=0\
    \ |>\nThe easiest way to do this is to simply test if every value in the hash\
    \ is lower-case.  If you think that the hash keys are the only things that vary\
    \ then this is simple:\n<code>\nif (grep { lc } keys %hash) {\n    ... # All values\
    \ must be lower-case\n} else {\n    ... # Some values might be lower-case\n}\n\
    </code>\nThe grep part will return all the values which have lower-case equivalents\
    \ in your hash.\nThe lc function will convert the value to lower case, so the\
    \ grep will only be true for values that actually are all lower-", "    my $keys;\n\
    \    for (keys %$dict) {\n\tmy $value = $dict->{$_};\n\tmy $case_string = lc($value);\n\
    \tif ($case_string ne $value) {\n\t    if ($case_string eq uc($value)) {\n\t\t\
    return \"\";\n\t    } elsif ($key eq uc($value)) {\n\t\treturn \"\";\n\t    }\
    \ else {\n\t\treturn 1;\n\t    }\n\t} elsif ($case_string ne \"\") {\n\t    return\
    \ 1;\n\t}\n    }\n    return 1;\n}", "    my $check = 0;\n    \n    foreach my\
    \ $key (sort(keys(%$dict))) {\n        return $check if (is_string($key) && is_string($dict->{$key}));\n\
    \        return $check if (is_string($key) && is_string($dict->{$key})\n     \
    \   && lc($key) eq lc($dict->{$key}));\n        $check = 1;\n    }\n    return\
    \ $check;\n}", "    my $case_ok = 1;\n    foreach my $key (sort keys %$dict) {\n\
    \        if($dict->{$key} ne $key && $dict->{$key} !~ /^[A-Z]$/) {\n         \
    \   $case_ok = 0;\n            last;\n        }\n    }\n    return $case_ok;\n\
    }", '    my $case = 0;', "    my $key;\n    for (keys(%$dict)) {\n\t$key = $_;\n\
    \tnext unless $dict{$key} =~ /^(\\S+)$/i;\n\t$key = lcfirst($key);\n\t$dict{$key}\
    \ = $dict{$key} =~ /^(\\S+)$/i;\n    }\n    return $dict;\n}", "    my $case_sense\
    \ = 1;\n    foreach my $key (keys %$dict) {\n\tif ($dict->{$key} =~ /^[[:upper:]]$/)\
    \ {\n\t    $case_sense = 0;\n\t    last;\n\t}\n    }\n    return $case_sense;\n\
    }", "    my $hash_cnt = scalar (keys %$dict);\n    my $case = $hash_cnt < 1 ?\
    \ \"empty\" : \"not empty\";\n    if ($hash_cnt < 1) {\n        warn \"check_dict_case()\
    \ called with an empty hash.\" . \n             \"\\n\\n\";\n        return 1;\n\
    \    } elsif (scalar keys %$dict == 0) {\n        warn \"check_dict_case() called\
    \ with a hash with only keys \".\n             \"with value '' or undef as the\
    \ value.\\n\\n\";\n        return 1;\n    } elsif (scalar keys %$dict == 1 &&\n\
    \        (keys %$dict) eq (values %$dict)\n    ) {\n        warn \"check_dict_case()\
    \ called with a hash with only one key.\" .\n             \"\\n\\n\";\n      \
    \  return 1;\n    } elsif (scalar keys %$dict > 1) {\n        warn \"check_dict_case()\
    \ called with a hash containing multiple \".\n             \"keys.  Perhaps you\
    \ meant to use check_dict_case()?\\n\\n\";\n        return 1;\n    } elsif (scalar\
    \ keys %$dict == 1 &&\n        (keys %$dict) eq (keys %$dict)\n    ) {\n     \
    \   warn \"check_dict_case() called with a hash with only one key.\" .\n     \
    \        \"\\n\\n\";\n        return 1;\n    }\n    return 0;\n}", "    # Turn\
    \ any non-strings to string\n    foreach my $key ( keys %{$dict} ) {\n       \
    \ if(not is_string $dict->{$key}) {\n            $dict->{$key} = $dict->{$key}\
    \ . \"\";\n        }\n    }\n    \n    my($key) = $dict->FIRSTKEY();\n    return\
    \ 1 if( $key && $dict->{$key} !~ /[A-Z]/);\n    my($key) = $dict->FIRSTKEY();\n\
    \    return 1 if( $key && $dict->{$key} !~ /[a-z]/);\n    return \"\";\n}", " \
    \   my(@keys,@values);\n    my($i,$key,$value);\n    foreach $key (keys(%$dict))\
    \ {\n\tpush(@keys,$key);\n    }\n    foreach $key (keys(%$dict)) {\n\tpush(@values,$dict->{$key});\n\
    \    }\n    foreach $key (@keys) {\n\tif ($key =~ /^[A-Z]+$/) {\n\t    # check\
    \ if value is in lower case\n\t    foreach $value (@values) {\n\t\tif ($value\
    \ =~ /^[a-z]+$/) {\n\t\t    # value is in lower case\n\t\t    next;\n\t\t}\n\t\
    \    }\n\t} else {\n\t    # check if value is in upper case\n\t    foreach $value\
    \ (@values) {\n\t\tif ($value =~ /^[A-Z]+$/) {\n\t\t    # value is in upper case\n\
    \t\t    next;\n\t\t}\n\t    }\n\t}\n\treturn \"\";\n    }\n    return 1;\n}",
  "    if(!defined $dict) {\n        0;\n    } else {\n        foreach(keys(%$dict))\
    \ {\n            my $key = $_;\n            if($key =~ /^[a-z]/) {\n         \
    \       return 1;\n            } elsif($key =~ /^[A-Z]/) {\n                return\
    \ 1;\n            } else {\n                return \"\";\n            }\n    \
    \    }\n    }\n    return 0;\n}", "    if(!ref($dict)) {\n        return 0;\n\
    \    }\n    \n    my $ret = 0;\n    \n    foreach my $key (keys(%$dict)) {\n \
    \       if(!is_string($key)) {\n            $ret = 0;\n            last;\n   \
    \     }\n        if(is_string($key) && $key =~ /^[a-z]$/i) {\n            $ret\
    \ = 0;\n            last;\n        }\n        if(is_string($key) && $key =~ /^[A-Z]$/i)\
    \ {\n            $ret = 0;\n            last;\n        }\n    }\n    \n    return\
    \ $ret;\n}", '    my $result = "";', "    my $case = 0;\n    foreach my $k (keys\
    \ %$dict) {\n        if ($k =~ /^[A-Z]+$/) {\n            $case++;\n        }\
    \ elsif ($k =~ /^[a-z]+$/) {\n            $case--;\n        }\n    }\n    return\
    \ $case;\n}", "    my $return = 0;\n    while(my ($key, $val) = each(%$dict))\
    \ {\n\treturn $return if ! is_string($key) || ! is_string($val);\n\t$return +=\
    \ 0 if ($key =~ /^[A-Z]/i || $val =~ /^[A-Z]/i);\n\t$return += 0 if ($key =~ /^[a-z]/i\
    \ || $val =~ /^[a-z]/i);\n\t$return += 0 if ($key =~ /^[0-9]/i || $val =~ /^[0-9]/i);\n\
    \t$return += 0 if ($key =~ /^_/i);\n\t$return += 0 if ($val =~ /^_/i);\n    }\n\
    \    return $return;\n}", "    my @keys = keys %$dict;\n    my $case = \"\";\n\
    \    foreach my $k (@keys) {\n        if (lc($k) eq lc($k)) {\n            $case\
    \ = \"1\";\n            last;\n        }\n    }\n    return $case;\n}", "    if(!defined\
    \ $dict) {\n        return 0;\n    }\n    foreach my $key (sort keys %$dict) {\n\
    \        if(!defined($dict->{$key}) || ref($dict->{$key}) ne \"HASH\") {\n   \
    \         return 0;\n        }\n        if(lc($key) ne lc($dict->{$key})) {\n\
    \            return 0;\n        }\n    }\n    return 1;\n}", "    return 1 unless\
    \ (!$dict);\n    foreach my $key (sort keys %$dict) {\n        return 1 unless\
    \ (ref $dict->{$key} eq 'HASH');\n        return 1 unless ($dict->{$key} ne 'HASH');\n\
    \        my $value = $dict->{$key};\n        return 1 unless (ref $value eq 'HASH');\n\
    \        return 1 unless ($value ne 'HASH');\n        return 1 unless (check_dict_case($value));\n\
    \    }\n    return 1;\n}", "    return 1 unless keys %$dict;\n    my $case_ok\
    \ = ();\n    foreach my $key (keys(%$dict)) {\n        my $value = $dict->{$key};\n\
    \        if ($value =~ /^[a-z]/i) {\n            push @$case_ok, $key;\n     \
    \   } elsif ($value =~ /^[A-Z]/i) {\n            push @$case_ok, $key;\n     \
    \   } else {\n            push @$case_ok, $key;\n        }\n    }\n    return\
    \ @$case_ok;\n}", "    # check for all keys are in lower case\n    if(keys %$dict\
    \ == keys map uc, keys %$dict){\n        return \"\";\n    }\n    # check for\
    \ all keys are in upper case\n    if(keys %$dict == keys map lc, keys %$dict){\n\
    \        return \"\";\n    }\n    # check for all keys are in both upper and lower\
    \ case\n    if(keys %$dict == keys map {lc,uc}, keys %$dict){\n        return\
    \ \"\";\n    }\n    return 1;\n}", "    foreach my $key (sort keys %$dict) {\n\
    \        return $key if is_string($key) && is_string($dict->{$key});\n    }\n\
    \    return \"\";\n}", "    my @case = map { lc($_) => 1, uc($_) => 1, } keys\
    \ %$dict;\n    return  !@case and !keys %$dict;\n}", "    my $ret = scalar(keys\
    \ %$dict);\n    return $ret == 0 ? 1 : 0;\n}", "    my %lower = map { $_ => 1\
    \ } keys %$dict;\n    my %upper = map { $_ => 1 } keys %$dict;\n    \n    return\
    \ 1 if ! keys %lower;\n    return 1 if ! keys %upper;\n    return 1 if keys %$dict\
    \ == keys %lower == keys %upper;\n    return 0;\n}", "    my %lower_case_keys\
    \ = map { lc($_) => 1 } keys %$dict;\n    my %upper_case_keys = map { uc($_) =>\
    \ 1 } keys %$dict;\n    return 0 unless keys %$lower_case_keys == keys %$upper_case_keys;\n\
    \    return \"\";\n}", "    my $key_hash = {};\n    my $flag = 0;\n    my $keys;\n\
    \    foreach my $key (sort keys %$dict) {\n        $keys++;\n        $key_hash->{$key}\
    \ = $dict->{$key};\n        $flag = 1 if ($key =~ /^([a-zA-Z])/);\n        $flag\
    \ = 1 if ($key =~ /^([0-9])/);\n    }\n    return $flag if ($keys eq 0);\n   \
    \ my $case;\n    my $result;\n    if ($flags & $FLAG_FORCE_LOWER) {\n        $case\
    \ = lc($flags);\n        $result = (lc($key_hash) eq lc($dict));\n    }\n    else\
    \ {\n        $case = uc($flags);\n        $result = (uc($key_hash) eq uc($dict));\n\
    \    }\n    return $result;\n}", "    my %check;\n    \n    # Convert all keys\
    \ to lower case to eliminate case differences\n    foreach my $key (keys %$dict)\
    \ {\n        $check{$key} = lc $dict->{$key};\n    }\n    \n    # Check that all\
    \ keys are either uppercase or lowercase\n    foreach my $key (keys %$dict) {\n\
    \        \n        if(exists $check{$key} && $dict->{$key} ne $check{$key}) {\n\
    \            return 0;\n        }\n    }\n    \n    return 1;\n}", "    \n   \
    \ # Check for case where all keys are strings in lower case\n    foreach my $key\
    \ (keys %$dict) {\n        return 1 if $dict->{$key} eq lc($dict->{$key});\n \
    \   }\n    \n    # Check for case where all keys are strings in upper case\n \
    \   foreach my $key (keys %$dict) {\n        return 1 if $dict->{$key} eq uc($dict->{$key});\n\
    \    }", "    if(!$dict){\n        return 0;\n    }\n    foreach my $key (keys\
    \ %$dict){\n        if(!is_string($key)){\n            return 0;\n        }\n\
    \        if(!is_string($dict->{$key})){\n            return 0;\n        }\n  \
    \  }\n    return 1;\n}", "    my $hash_is_empty;\n    foreach my $key (sort keys\
    \ %$dict) {\n        if($dict->{$key} =~ /^[a-z]/i || \n           $dict->{$key}\
    \ =~ /^[A-Z]/i) {\n            $hash_is_empty = 0;\n        }\n    }\n    return\
    \ $hash_is_empty;\n}", "    my @keys = keys %$dict;\n    for my $k (@keys) {\n\
    \treturn 1 if $k =~ /^[A-Z]+$/i;\n\treturn 1 if $k =~ /^[a-z]+$/i;\n\treturn 1\
    \ if $k =~ /^[0-9.]+$/;\n    }\n    return \"\";\n}", "    \n    my($key,$value);\n\
    \    \n    for $key (keys %$dict)\n    {\n        if ($dict->{$key} =~ m/^[A-Za-z]+$/)\n\
    \        {\n            $value = $dict->{$key};\n        }\n        else\n   \
    \     {\n            $value = $dict->{$key};\n            $value =~ tr/[A-Z]/[a-z]/;\n\
    \        }\n        \n        \n        if ($value ne $dict->{$key})\n       \
    \ {\n            push(@errors,\"Expected string in all caps, got $value instead\"\
    );\n        }\n    }\n    return @errors;\n}", "    my @keys = keys %$dict;\n\
    \    return 1 if @keys == 0;\n    my @keys = sort @keys;\n    for (my $i = 0;\
    \ $i < @keys; $i++) {\n        my $key = substr($keys[$i], 0, 1);\n        if\
    \ ($key !~ /[A-Z]/) {\n            return 1;\n        }\n    }\n    return \"\"\
    ;\n}", "    return 1 if !defined($dict) || !%$dict;\n    my $res = 1;\n    foreach\
    \ my $key (keys(%$dict)) {\n        my $value = $dict->{$key};\n        my $ok\
    \ = lc $key eq lc $value;\n        $res += $ok ? 0 : 1;\n    }\n    return $res;\n\
    }", "    return 1 if !%$dict;\n    for my $key (sort keys %$dict) {\n        return\
    \ 1 if $dict->{$key} !~ /^[a-z]$|^[A-Z]/i;\n    }\n    return 0;\n}", "    return\
    \ 0 if !%$dict;\n    \n    my $key;\n    my $case;", "    my(@keys) = keys %$dict;\n\
    \    my(@val) = values %$dict;\n    my($ret);", "    \n    # If the hash was empty,\
    \ there is no need to check keys\n    return 1 if scalar(keys %$dict);\n    \n\
    \    my $keylist = keys(%$dict);\n    for my $key (keys %$dict) {\n        # Check\
    \ that all keys appear in lower case\n        return 1 if $key !~ m/^[0-9_]+$/i;\n\
    \        # Check that all keys appear in upper case\n        return 1 if ($key\
    \ !~ m/\\p{Upper}$/i);\n    }\n    # All keys are strings in lower case or all\
    \ keys are strings in upper case\n    return \"\";\n}", "    my $result = 1;\n\
    \    \n    # Convert all keys to upper case\n    foreach my $key (keys %$dict)\
    \ {\n        if (ref($dict->{$key}) && $dict->{$key} !~ /^\\$/) {\n          \
    \  $dict->{$key} = $dict->{$key}{lc => \"$dict->{$key}\"};\n        }\n    }\n\
    \    \n    # Return 0 if all keys are in upper case or 1 if all keys are in lower\
    \ case\n    $result = 0 unless keys %$dict == keys %{$dict->{lc => \"$dict\"}};\n\
    \    return $result;\n}", "    if(!defined $dict){\n        return \"\";\n   \
    \ }\n    \n    my($key, $value);\n    \n    # Count all keys in lower case\n \
    \   my $lcase_keys = 0;\n    while(my ($key, $value) = each %$dict){\n       \
    \ if(!defined $key || $key !~ /[a-z]/){\n            $lcase_keys++;\n        }\n\
    \    }\n    \n    # Count all keys in upper case\n    my $ucase_keys = 0;\n  \
    \  while(my ($key, $value) = each %$dict){\n        if(!defined $key || $key !~\
    \ /[A-Z]/){\n            $ucase_keys++;\n        }\n    }\n    \n    # Return\
    \ 1 if both counts are equal, 0 otherwise\n    return ($lcase_keys == $ucase_keys)\
    \ ? 1 : 0;\n}", '    my($return);', "    my $check = 1;\n    my $str = \"\";\n\
    \    \n    foreach my $k (keys %$dict) {\n        if ($k eq \"STATE\" or $k eq\
    \ \"ZIP\") {\n            next;\n        }\n        $str .= $k;\n        $check\
    \ = $check and is_lower($str);\n        $check = $check and is_upper($str);\n\
    \    }\n    return $check;\n}\n</code>\nNow you have two functions which can help\
    \ you check both cases of your keys. Now let's combine them to write a function\
    \ to check any case of your keys -- this will allow you to pass your hash to that\
    \ function and get back a single 0 or 1 depending on whether all keys are present\
    \ or not.\n<code>", "    return 1 unless keys %$dict || keys %$dict == 0;\n  \
    \  foreach my $key ( keys %$dict ) {\n        return 1 if ( lc $key eq lc $key\
    \ ) || \n                    ( uc $key eq uc $key );\n    }\n    return 0;\n}",
  "    my $cased = $dict->{Cased};\n    my $keys = $dict->{Keys};\n    my $is_string\
    \ = 0;\n    foreach my $key (keys %$dict) {\n        my $value = $dict->{$key};\n\
    \        if ($value eq \"\") {\n            $is_string = 0;\n        }\n     \
    \   elsif ($key eq \"\") {\n            $is_string = 1;\n        }\n        elsif\
    \ ($key eq $key) {\n            $is_string = 1;\n        }\n        elsif ($key\
    \ =~ m/\\W/) {\n            $is_string = 1;\n        }\n        elsif ($value\
    \ =~ m/\\W/) {\n            $is_string = 1;\n        }\n        elsif ($value\
    \ =~ m/[A-Z]/) {\n            $is_string = 1;\n        }\n        else {\n   \
    \         $is_string = 0;\n        }\n    }\n    if ($is_string && $cased eq \"\
    lower\") {\n        $is_string = 0;\n    }\n    if ($is_string && $cased eq \"\
    upper\") {\n        $is_string = 0;\n    }\n    return $is_string;\n}", "    my($case)\
    \ = 1;\n    \n    foreach my $key (keys %$dict) {\n        if (! exists $dict->{$key}\
    \ or $dict->{$key} eq \"\") {\n            $case = 1;\n            last;\n   \
    \     }\n        elsif ($dict->{$key} !~ /^(UPPER|LOWER)$/) {\n            $case\
    \ = 0;\n            last;\n        }\n    }\n    return $case;\n}", "    foreach\
    \ my $key (keys %$dict) {\n        return 1 if $key !~ /^[A-Z]$/;\n    }\n   \
    \ return \"\";\n}", "    my($result);\n    foreach my $key ( keys %$dict ) {\n\
    \        if (is_int($key)) {\n            if ( $key =~ /^\\d+$/ ) {\n        \
    \        $key = $key;\n            }\n            else {\n                $result\
    \ = $key;\n            }\n        }\n        else {\n            $result = $key;\n\
    \        }\n    }\n    return ($result);\n}", "    for (keys %$dict) {\n     \
    \   my $key = keys[0];\n        if ($key eq \"-\") {\n            return 1;\n\
    \        }\n        if (lc($key) eq lc($keys[0])) {\n            return \"\";\n\
    \        }\n    }\n    return 1;\n}\n</code>\n<|/ a tags=perl,hashmap dscore=1\
    \ |>\n<| c |>\nThank you for this.  It actually helped me understand how perl\
    \ handles hashes.  I used your check_dict_case function (slightly modified) and\
    \ then realized I could just call lc on the key.  My function was a little different\
    \ that what was described above, but you gave me the inspiration for my own solution.\n\
    <|/ c |>\n<| c |>\nI didn't think so. That's why I thought you didn't understand\
    \ it, and why I gave the code snippet, not the description. :-) In Perl, you can\
    \ always call `lc()` on the key. That does a case-insensitive comparison on the\
    \ key and returns it unchanged.\n<|/ c |>\n<| a dscore=1 |>\nMy guess is that\
    \ you'd like to remove duplicate hashes with the same hash keys, but different\
    \ values. For example:\n<code>\nmy %hash = (\n    a => 1,\n    a => 2,\n    b\
    \ => 1,\n    c => 1,\n);", "    \n    if ( $dict->can(\"keys\") ) {\n        return\
    \ 1 if map { lcfirst } $dict->keys == keys map { ucfirst } keys %$dict;\n    \
    \    return 1 if map { ucfirst } $dict->keys == keys map { lcfirst } keys %$dict;\n\
    \    }\n    \n    return 0;\n}", "    # Return 1 if all keys are strings in lower\
    \ case\n    # or all keys are strings in upper case\n    return 1 if scalar(grep(/[a-z]/,\
    \ keys(%$dict))) == scalar(grep(/[A-Z]/, keys(%$dict)));\n    return \"\";\n}",
  "    if (scalar (keys %$dict) eq 0) { return \"\"; }\n    my($cased_key) = uc(lc(keys\
    \ %$dict));\n    if ($cased_key eq lc(keys %$dict)) {\n        my($lower_case_key)\
    \ = $cased_key;\n        my($upper_case_key) = $cased_key;\n    }\n    else {\n\
    \        my($lower_case_key) = $cased_key;\n        my($upper_case_key) = $cased_key;\n\
    \        my($upper_case_key) = uc($lower_case_key);\n    }\n    \n    foreach\
    \ my $key (keys %$dict) {\n        if (lc($key) ne $lower_case_key) {\n      \
    \      return 0;\n        }\n        if (uc($key) ne $upper_case_key) {\n    \
    \        return 0;\n        }\n    }\n    return 1;\n}", "    my $ret = 0;\n \
    \   foreach my $key (sort keys %$dict) {\n        my $value = $dict->{$key};\n\
    \        $ret = ( $key =~ /^[a-z][a-z]$/ ) ? 1 : 0;\n        $ret = ( $key =~\
    \ /^[A-Z][a-z]$/ ) ? 1 : 0;\n        $ret = ( $key =~ /^[A-Z][A-Z]$/ ) ? 1 : 0;\n\
    \        $ret = ( $key =~ /^[a-z][A-Z]$/ ) ? 1 : 0;\n    }\n    return $ret;\n\
    }", "    my %seen = ();\n    foreach my $key (keys %$dict) {\n\tif (exists $seen{$key})\
    \ {\n\t    return 1 if $seen{$key} !~ /[A-Z]/;\n\t}\n\telse {\n\t    $seen{$key}\
    \ = lc($key);\n\t}\n    }\n    return $seen{''};\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
