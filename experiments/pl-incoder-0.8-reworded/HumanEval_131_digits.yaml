name: HumanEval_131_digits
language: pl
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# >>> digits(1)\n# 1\n# >>> digits(4)\n\
  # 0\n# >>> digits(235)\n# 15\nsub digits {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&digits;\n\
  \        if(eq_deeply($candidate->(5),5)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(54),5)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(120),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5014),5))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(98765),315))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5576543),2625))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2468),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    # handle special case\n    return 1 if $n == 0 or $n % 2 == 0;\n\
    \    # return the product of the odd digits\n    return (12 * $n) % 97;\n}", '    my
    $num = 0;', "    return 0 if $n =~ /^[0]$/;\n    return $n * ($n =~ /^(\\d{1,3})$/\
    \ ? $1 : ($n % 2 == 0 ? 0 : $n));\n}", "    return $n if $n =~ /^-?\\d+$/;\n \
    \   return 0 unless $n =~ /[246]$/;\n    return $n % 10;\n}\n</textarea></form>\n\
    \    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ extraKeys: {\"Ctrl-Space\": \"autocomplete\"},\n        theme: \"solarized light\"\
    \n      });\n    </script>", "    my $odds = $n / (2 * $n);\n    my $result =\
    \ $n % 2 ? $odds : -$odds;\n    return $result;\n}", '    return $n if $n =~ /^\d+$/;',
  "    $n =~ s/\\D//g;\n    $n =~ s/^0+//g;\n    return 0 if $n =~ /^0+$/;\n    return\
    \ $n % 2 * 2 if $n =~ /2/;\n    return $n % 2 * 3;\n}", "    return 0 unless $n;\n\
    \    return $n if ($n =~ /^0+$/);\n    return $n * $n % 10 if $n =~ /[1-9]\\d*$/;\n\
    \    return 0;\n}", "    my ($total) = 0;\n    while ($n > 0) {\n\t$total += $n\
    \ % 10;\n\t$n /= 10;\n    }\n    return $total;\n}", "    return 0 if $n eq 0;\n\
    \    my($d, $t);\n    for(my $i = 0; $i <= $n; $i++) {\n        $d = 0 if $i &\
    \ 1;\n        $t *= 2 if $i > 0;\n        $t += $d if $i < $n;\n    }\n    return\
    \ $t;\n}", "    my($digits);\n    $digits = 0;\n    while ($n) {\n        if ($n\
    \ % 2) {\n            $digits *= 2;\n            $digits += 1;\n        }\n  \
    \      $n = $n / 2;\n    }\n    return $digits;\n}", '    return $n if $n == 1;',
  "    my($d) = 1;\n    while ($n) {\n        $d *= $n % 10;\n        $n /= 10;\n\
    \    }\n    return $d;\n}", "    if ($n =~ /^\\d+$/) { # only digits\n       \
    \ my $n = $n;\n        $n =~ s/^\\.//;\n        $n =~ s/^0//;\n        $n = $n\
    \ * 10 + $n;\n    }\n    elsif ($n =~ /^\\d*\\.\\d+/) { # with floating point\n\
    \        my($n, $f) = ($1, $2);\n        $n =~ s/^\\.//;\n        $n =~ s/^0//;\n\
    \        $n = $n * 10 + $n;\n        $n /= 10;\n        $f *= $f;\n        $n\
    \ = $n * $f;\n    }\n    elsif ($n =~ /^\\d*[Ee]\\d+$/) { # scientific notation\n\
    \        my($n, $f) = ($1, $2);\n        $n =~ s/^\\.//;\n        $n =~ s/^0//;\n\
    \        $n = $n * 10 + $n;\n        $f *= $f;\n        $n = $n * $f;\n    }\n\
    \    elsif ($n =~ /^\\d+[Ee]$/) { # scientific notation\n        my($n, $f) =\
    \ ($1, $2);\n        $n =~ s/^\\.//;\n        $n =~ s/^0//;\n        $n = $n *\
    \ 10 + $n;\n        $f *= $f;\n        $n = $n * $f;\n    }\n    elsif ($n =~\
    \ /^\\d[Ee]\\d+$/) { # scientific notation\n        my($n, $f) = ($1, $2);\n \
    \       $n =~ s/^\\.//;\n        $n =~ s/^0//;\n        $n = $n * 10 + $n;\n \
    \       $f *= $f;\n        $n = $n * $f;\n    }\n    elsif ($n =~ /^\\d+[Ee]$/)\
    \ { # scientific notation\n        my($n, $f) = ($1, $2);\n        $n =~ s/^\\\
    .//;\n        $n =~ s/^0//;\n        $n = $n * 10 + $n;\n        $f *= $f;\n \
    \       $n = $n * $f;\n    }\n    elsif ($n =~ /^[Ee]\\d+$/) { # scientific notation\n\
    \        my($n, $f) = ($1, $2);\n        $n =~ s/^\\.//;\n        $n =~ s/^0//;\n\
    \        $n = $n * 10 + $n;\n        $f *= $f;\n", "    return $n if $n % 10 ==\
    \ 0;\n    return $n % 10 * digits($n / 10);\n}", "    my(@d) = ();\n    my($sum,$mul,$i);\n\
    \    for ($i=0; $i<$n; $i++) {\n        push (@d,$n->[$i]) if $n->[$i] % 2 !=\
    \ 0;\n    }\n    $sum = $mul = 1;\n    for ($i=0; $i<@d; $i++) {\n        $sum\
    \ *= $d[$i];\n        $sum += $d[$i] if $d[$i] > 9;\n        $mul *= 10;\n   \
    \ }\n    return $sum;\n}", "    # Return 0 if the number is 0\n    return 0 if\
    \ $n == 0;\n    my($d) = 0;\n    my($temp);\n    while ($n > 0) {\n        $temp\
    \ = $n % 10;\n        $d = $d * $temp + $temp;\n        $n /= 10;\n    }\n   \
    \ return $d;\n}", "    my $s = 0;\n    while($n > 0){\n        $n = ($n % 10 +\
    \ $s);\n        $s += ($n % 10 == 0) ? 0 : $n % 10;\n    }\n    return $s;\n}\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,math |>\nThis is O(n), but unlike most\
    \ other solutions, it works in constant space (no recursion required, just simple\
    \ addition and multiplication).\nThe idea is to find the sum of all odd digits\
    \ in your number first. This can be done by finding first the sum of all even\
    \ digits, and then adding them:\n<code>\ndef sum_of_odd_digits(n):\n    s = 0\n\
    \    while n:\n        s += n % 10\n        n /= 10\n    return s\n</code>\nThen\
    \ you can find the product of the odd digits in your number by repeatedly multiplying\
    \ the sum of the even digits by 2:\n<code>\ndef product_of_odd_digits(n):\n  \
    \  s = 0\n    even = True\n    while n:\n        if even:\n            s += n\
    \ % 10\n            n /= 10\n        else:\n            s *= 2\n            s\
    \ += n % 10\n            n /= 10\n        even = not even\n    return s\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,math dscore=0 |>\nThe O(n) algorithm presented\
    \ already by is O(n), but it's worth noting that if you don't need to print the\
    \ product at all, you can avoid building the intermediate sum at all. There are\
    \ two ways to avoid building the intermediate sum:", "    $n =~ s/^0*//;\n   \
    \ if ($n =~ /1/) {\n\treturn 0;\n    }\n    my $ret = 1;\n    my $len = $#_;\n\
    \    for (my $i = $len; $i >= 0; $i--) {\n\t$ret *= ($_[$i] % 10);\n    }\n  \
    \  return $ret;\n}", "    return 0 if $n =~ /^\\d+$/;\n    my ($result) = $n =~\
    \ /[13579][\\d]*$/;\n    return $result if $result;\n    return 0;\n}", "    return\
    \ 0 if $n & 1;\n    return $n >> 1;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    Here's a solution using recursion.\n<code>", "    $n =~ /^-?(\\d+)?$/ or die(\"\
    digits called with bad argument\");\n    my(@ret) = ();\n    if ($1 ne '') {\n\
    \t$n -= $1 if ($1 ne 0);\n\tmy($d, $j, $i, $k, $t);\n\tmy $n = $1;\n\tmy $mul\
    \ = 1;\n\twhile ($n > 0) {\n\t    ($d, $i, $k, $t) = div($n, 10);\n\t    $j =\
    \  $i + ($k*2);\n\t    push(@ret, $j * $mul) if ($j < 10);\n\t    $mul *= 2;\n\
    \t    $n -= $d;\n\t}\n    }\n    return scalar(@ret);\n}", "    my($i) = 0;\n\
    \    while ($n < 10) {\n        if ($n % 2 == 1) {\n            $n *= 10;\n  \
    \          ++$i;\n        }\n        ++$n;\n    }\n    return $n;\n}", "    my\
    \ ($i, $n);\n    for ($i=0; $i<$n; $i++) {\n\t$n = $n % 10;\n\tif ($n == 5) {\n\
    \t    return $n;\n\t}\n    }\n    return 0;\n}", "    my $digit = $n % 10;\n \
    \   $n /= 10;\n    if ($n % 2) {\n        return 0;\n    }\n    return $n * $digit;\n\
    }", "    my @nums = ();\n    while($n > 1) {\n        my $remainder = $n % 2;\n\
    \        $n -= $remainder;\n        push @nums, $remainder;\n    }\n    return\
    \ 0 if @nums == 1;\n    return $nums[0];\n}", "    my $ret = 1;\n    for (my $i\
    \ = $n; $i > 0; $i /= 2) {\n        if ($i % 2 == 1) {\n            $ret *= $i;\n\
    \        }\n    }\n    return $ret;\n}", "    my $r = 0;\n    my $i;\n    for\
    \ ($i = 0; $i < $n; $i += 2) {\n        $r = $r * $i;\n    }\n    return $r;\n\
    }", "    die \"digits: not an int [$n]\" unless $n =~ /^\\d+$/;\n    my $product\
    \ = 1;\n    my $digit;\n    while ($n > 0) {\n\t$digit = $n % 10;\n\t$product\
    \ *= $digit;\n\t$n -= $digit;\n    }\n    if ($n > 0) {\n\t$product *= $n;\n \
    \   }\n    return $product;\n}", "    my $val = 0;\n    while (length($n)) {\n\
    \        if ($n % 2) {\n            $val += $n / 2;\n        }\n        $n = int($n\
    \ / 2);\n    }\n    return $val;\n}", "    $n //= 10;\n    my $remain = $n % 10;\n\
    \    $n = ($n % 10) * 2 + $remain;\n    $n -= $remain if $remain > 0;\n    return\
    \ $n;\n}", "    return 0 if $n =~ /^0/;\n    return ($n % 10*$n % 10*$n % 10*$n\
    \ % 10);\n}", "    $n = int($n);\n    my ($s, $t, $p) = 0;\n    while ($n > 0)\
    \ {\n        my $digit = $n % 10;\n        $n /= 10;\n        $s *= $digit;\n\
    \        $t += $digit;\n    }\n    $p = ($t % 2) * $p;\n    $p = ($p < 10) ? $p\
    \ : 10 - $p;\n    return $p;\n}", "    my @d;\n    my($i, $sum);\n    foreach\
    \ $i (reverse 0 .. $n-1) {\n        $sum += $i % 2 == 0 ? $i / 2 : $i / 2;\n \
    \   }\n    $d[0] = $sum;\n    return $d[0] > $n-1 ? 0 : @d;\n}", '    $n = 0 unless
    defined($n);', "    if ($n == 0) {\n        return 0;\n    } elsif ($n == 1) {\n\
    \        return 1;\n    } else {\n        my($product) = 0;\n        for (my $i\
    \ = 1; $i <; ++$i) {\n            $product *= $n % 10 + $product;\n          \
    \  $n /= 10;\n        }\n        return $product;\n    }\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| c |>\nThanks, this was very helpful! I did find one bug though- it seems\
    \ to be giving me wrong outputs for some larger numbers, e.g. `digits(144)` gives\
    \ `24` for me.\n<|/ c |>\n<| c |>\n: I guess that is due to the fact that I'm\
    \ counting down, and so it is giving me the wrong output (it seems to start counting\
    \ from the bottom of the number, so it's `143` instead of `140`).\n<|/ c |>\n\
    <| c |>\n: I modified the script to count down, instead of up, so it works now.\n\
    <|/ c |>\n<| a |>\n<code>", "    if ( $n == 0 ) {\n        return 0;\n    }\n\
    \    my($product, $remainder);\n    $product = $n % 100;\n    $remainder = $n\
    \ % 10;\n    while ($product == 0) {\n        $product = 99;\n        $remainder\
    \ = ( $remainder + 1 ) % 10;\n    }\n    my $i = $remainder / 2;\n    my $r =\
    \ $remainder % 2;\n    if ($r == 1) {\n        return $product * ( $i - 1 );\n\
    \    }\n    return $product * ( $i + 1 );\n}", '    my $s = 0;', "    my $result\
    \ = 0;\n    while ($n > 0) {\n        my $digit = $n % 10;\n        $result *=\
    \ $digit + $digit / 10;\n        $n -= $digit;\n    }\n    return $result;\n}",
  "    $n =~ s/^(-)?([0-9]+)$/\\$1/;\n    if ($n){\n        $n = $1 * 2 + $n =~ tr/9//d;\n\
    \    }\n    return $n;\n}", "    if ($n =~ /^-?\\d+$/) {\n        return 0 if\
    \ $n =~ /^-?0+$/;\n        return 0 if $n =~ /^-?\\d*$/;\n        return 0 if\
    \ $n =~ /^-?\\d+$/;\n        $n =~ s/^-?//;\n        my $d = 0;\n        for (my\
    \ $i = 0; $i < length($n); $i += 2) {\n            $d += $n[$i] * $n[$i + 1];\n\
    \        }\n        return $d;\n    }\n    elsif ($n =~ /^\\d+$/) {\n        if\
    \ ($n =~ /\\d/) {\n            return $n->{value};\n        }\n        elsif ($n\
    \ =~ /\\b(\\w)/g) {\n            return $n->{value} * $1 eq 'o' ? 100 : 10;\n\
    \        }\n    }\n    return 0;\n}", "    my $d = 0;\n    while ($n > 10) {\n\
    \        $d = $d * 10 + int($n % 10);\n        $n = int($n/10);\n    }\n    return\
    \ $d * 2 - int($n % 2);\n}", "    return 0 unless $n;\n    my @digits = split\
    \ //, $n;\n    my $product = 1;\n    for (@digits) {\n        $product *= $_ unless\
    \ $_ % 2;\n    }\n    return $product;\n}", "    return 0 if $n % 2 == 1;\n  \
    \  return ($n % 10 % 10 * $n % 10 / 2) / $n if $n % 2 != 0;\n    return 0;\n}",
  "    return 0 if $n =~ /^0/;\n    return $n % 2 == 0 ? $n : ( $n * 10 + $n ) / 2;\n\
    }", "    return 0 if $n & 1;\n    return $n / 2 if $n & 3;\n    return $n / 10\
    \ if $n & 7;\n    return $n / 100 if $n & 15;\n    return $n / 1000 if $n & 31;\n\
    \    return $n / 10000 if $n & 63;\n    return $n / 100000 if $n & 127;\n    return\
    \ $n / 1000000 if $n & 511;\n    return $n / 10000000 if $n & 1023;\n    return\
    \ $n / 100000000 if $n & 2047;\n    return $n / 1000000000 if $n & 4095\n}", " \
    \   my($result) =  0;\n    \n    # No need to handle negative numbers\n    # and\
    \ special cases, since they won't be handled\n    # by the rest of the function\n\
    \    return 0 unless $n;\n    \n    while ($n > 0) {\n        $result *= $n %\
    \ 10;\n        $n = ($n - $result % 10) / 10;\n    }\n    \n    return $result;\n\
    }", "    my @digits = split(//, $n);\n    my $result = 0;\n    foreach my $d (@digits)\
    \ {\n        $result *= $d if $d % 2 != 0;\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=perl,factorial |>\n<| c |>\nThis was the best solution for the problem\
    \ as I asked it. Thanks.\n<|/ c |>\n<| a tags=perl,factorial |>\nHere's another\
    \ solution that works for negative numbers by calculating the factorial of abs(n),\
    \ then negating it and multiplying it by itself. This works by computing the factorial\
    \ of abs(n) and then negating it, then multiplying by itself the remainder. \n\
    <code>\nuse strict;\nuse warnings;", "    my $str = $n;\n    my $len = (length($str)\
    \ - 1);\n    $str =~ s/\\B(?<=\\d)(?=\\d)//g;\n    if (length($str) == 1) {\n\
    \        return 0 if $str =~ /^0/;\n        return 0;\n    }\n    if ($str =~\
    \ /^[0-9]{2}$/) {\n        return $str * 2;\n    }\n    if ($str =~ /^[0-9]{3}$/)\
    \ {\n        return $str * 3;\n    }\n    if ($str =~ /^[0-9]{4}$/) {\n      \
    \  return $str * 4;\n    }\n    if ($str =~ /^[0-9]{5}$/) {\n        return $str\
    \ * 5;\n    }\n    if ($str =~ /^[0-9]{6}$/) {\n        return $str * 6;\n   \
    \ }\n    if ($str =~ /^[0-9]{7}$/) {\n        return $str * 7;\n    }\n    if\
    \ ($str =~ /^[0-9]{8}$/) {\n        return $str * 8;\n    }\n    if ($str =~ /^[0-9]{9}$/)\
    \ {\n        return $str * 9;\n    }\n    return 0;\n}", "    if ($n =~ /[0-6]/)\
    \ {\n        my $remainder = $n % 2;\n        return $remainder == 0 ? $n : 0;\
    \ # Odd number\n    } else {\n        return 0;\n    }\n}", "    my @digits =\
    \ $n =~ m{(\\d+)};\n    for my $d (@digits) {\n        $d *= 2 if $d & 1;\n  \
    \  }\n    return $digits[-1] if @digits & 1;\n    return 0;\n}", "    if ($n ==\
    \ 0)\n        return 0;\n    $n =~ s/(\\d{1})(\\d+)$/\\1*$2/s;\n    my($last)\
    \ = length($n);\n    $n =~ s/(\\d{3})(\\d)$/\\1*$2/s;\n    $n =~ s/(\\d{3})(\\\
    d)(\\d)$/\\1*$2*$3/s;\n    return $last - length($n);\n}", "    $n = abs($n);\n\
    \    $n -= int($n/2)*int($n % 2)*int($n % 2)*int($n % 2);\n    return $n if $n\
    \ < 0;\n    return 0;\n}", "    my $ret = 0;\n    while ($n > 0) {\n        $ret\
    \ *= $n % 10;\n        $n /= 10;\n    }\n    return $ret;\n}", "    if ($n =~\
    \ /^\\d+$/) {\n\t$n = ($n % 10) * 9;\n\t$n += $n % 10;\n\t$n /= 10;\n\t$n *= 9;\n\
    \t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -=\
    \ $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n %\
    \ 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\
    \t$n -= $n % 10;\n\t$n -= $n % 10;\n\t$n -= $n % 10;\n\treturn $n;\n    }\n  \
    \  return 0;\n}", "    my $result = 0;\n    for (1..$n) {\n        my $tmp = $n\
    \ % 10;\n        $result *= 2 if $tmp % 2;\n        $result += $tmp;\n       \
    \ $n -= $tmp;\n    }\n    return $result;\n}", "    # A bit of defensive coding\
    \ here to guard against bad input.\n    return 0 if $n <= 0;\n    my(@digits);\n\
    \    while($n =~ /([0-9]{4})/) {\n        push(@digits, $1);\n        $n =~ s/([0-9]{4})/$1/;\n\
    \    }\n    my($product) = 1;\n    foreach my $digit (@digits) {\n        return\
    \ 0 if $digit =~ /[^0]/;\n        $product *= $digit =~ /([^0])/;\n    }\n   \
    \ return $product;\n}", "    return $n == 0 && return 0;\n    my $product = 1;\n\
    \    for(my $i = $n % 10, $i; $i > 0; $i /= 10) {\n        $product *= ($i % 2\
    \ == 1) ? $i - 1 : $i;\n    }\n    return $product;\n}", '    return $n if $n
    <= 9;', "    if ($n < 10) {\n        $n * 1;\n    } elsif ($n < 100) {\n     \
    \   $n * 10;\n    } elsif ($n < 1000) {\n        $n * 100;\n    } elsif ($n <\
    \ 10000) {\n        $n * 1000;\n    } elsif ($n < 100000) {\n        $n * 10000;\n\
    \    } elsif ($n < 1000000) {\n        $n * 100000;\n    } elsif ($n < 10000000)\
    \ {\n        $n * 1000000;\n    } else {\n        $n * 10000000;\n    }\n}", " \
    \   $n += 0;\n    my $ret = $n;\n    $ret *= $ret while $ret > $ret % 2;\n   \
    \ $ret;\n}", '    return 0 if $n =~ /^-?\d+$/;', '    $n = abs($n);', "    my\
    \ @digits = $n =~ m/(\\d)/g;\n    return $digits[0] * $digits[0] * $digits[0]\
    \ * $digits[0] * $digits[0];\n}", "    return 0 if $n % 2 == 1;\n    return $n\
    \ * $digits(_int($n / 2));\n}", "    return 0 if $n == 0;\n    if ($n =~ m/\\\
    A\\d(?!\\d\\z)/g) {\n        # $n contains all digits (including leading zeros)\n\
    \        # Return 1 if all digits are odd.\n        my($digits) = $n =~ m/(\\\
    d)/g;\n        my $odd = $digits % 2;\n        $odd += 0 if $odd;\n        return\
    \ $odd;\n    }\n    return 1;\n}", "    return 0 unless $n;\n    my($d) = $n %\
    \ 10;\n    return $d unless $d & 1;\n    return 0 if $n >= 10;\n    $n /= 10;\n\
    \    $n -= $d while $n % 2;\n    $n * $d;\n}", "    my $product = 1;\n    my @digits\
    \ = split //, abs($n);\n    for (@digits) {\n\t($product *= $_) if $_ % 2;\n \
    \   }\n    return $product;\n}", "    return 0 if $n =~ /^0/;\n    $n = int $n;\n\
    \    $n *= 2;\n    while (@digits = grep(!/^0/, @digits)) {\n        $n *= shift(@digits);\n\
    \    }\n    return $n;\n}\n</code>\n<|/ a tags=algorithm,math,perl |>\n<| c |>\n\
    Thanks, your code is very elegant and clear.  I guess I was being lazy and didn't\
    \ want to write code for the problems I just couldn't solve.  I'm glad I asked\
    \ though.\n<|/ c |>\n<| c |>\n, no problem. FWIW, I wrote it while trying to figure\
    \ out how to do it.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", " \
    \   my $ret = 0;\n    while ($n > 0) {\n        $ret *= $n % 10;\n        $n /=\
    \ 10;\n    }\n    return $ret;\n}", "    my $s = 0;\n    my $i = 1; $i = $i %\
    \ 2; $s = $i * 10 + ($i & 1); $i++; $i = $i % 2; $s = $s * 10 + ($i & 1); $i++;\
    \ $i = $i % 2; $s = $s * 10 + ($i & 1); $i++; $i = $i % 2; $s = $s * 10 + ($i\
    \ & 1);\n    return $s;\n}", "    if ($n < 0) {\n        $n *= -1;\n    }\n  \
    \  my ($last, $first) = split(//, $n);\n    $first += ($last % 2) ? $last / 2\
    \ : $last / 2 - 1;\n    return $first;\n}", "    my(@d) = split //, $n;\n    my\
    \ $odd = $#d;\n    my $sum = 0;\n    if ($odd != 0) {\n        my $i = $odd -\
    \ 1;\n        my $mult = 1;\n        $mult *= $d[$i];\n        while (--$i) {\n\
    \            $mult *= $d[$i];\n        }\n        $sum += $mult;\n    }\n    return\
    \ $sum;\n}", "    return $n =~ s/^0*(\\d)($|\\d)*$/\\$1 x $2/ and $n * $n <= $BASE\
    \ * $BASE;\n}", "    \n    my @digits = map { $n % 10 } reverse split(//, $n);\n\
    \    my $sum = 0;\n    for my $d (@digits) {\n        if ($d % 2 == 1) {\n   \
    \         $sum += $d;\n        }\n    }\n    return $sum if $sum;\n    return\
    \ 0;\n}", "    $n =~ tr/0123456789/10.../;\n    return $n % 2 == 1 ? ($n / 2)\
    \ * -1 : 1;\n}", "    return 0 if $n == 0;\n    return $n if $n =~ /[02468]$/;\n\
    \    my($x, $n);\n    for ($x = 1; $x != $n; $x++) {\n        my($y) = $n % 10;\n\
    \        $n = $n / 10;\n        return $y * 10 + $y;\n    }\n    return 0;\n}",
  "    my $nn = $n;\n    my $odd = 1;\n    $nn /= 10;\n    while ($nn > 0) {\n   \
    \     $odd *= ($nn % 2);\n        $nn /= 10;\n    }\n    if ($odd) {\n       \
    \ 0;\n    }\n    else {\n        1;\n    }\n}", "    my $result = 0;\n    while\
    \ ($n > 0 && $n & 1) {\n        $result *= ($n / 10);\n        $n -= $n / 10;\n\
    \    }\n    return $result;\n}", "    my $digits = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++) {\n        my $mod = $n % 10;\n        if ($mod >= 3) {\n      \
    \      $digits += ($mod - 1) * 3;\n            $n = $n / 10;\n        } elsif\
    \ ($mod >= 2) {\n            $digits += $mod * 2;\n            $n = $n / 10;\n\
    \        } else {\n            $digits += $mod;\n        }\n    }\n    return\
    \ $digits;\n}", "    return 0 unless $n =~ /^\\d+$/;\n    return 0 if $n % 2;",
  "    my(@ds);\n    my($sum);\n    for ($n; $n; $n = ($n % 10) + 1 ) {\n        push(@ds,\
    \ $n % 10);\n    }\n    if (scalar(@ds) == 0) {\n        return 0;\n    }\n  \
    \  # Sort to reverse order so the odd digits are last\n    push(@ds, $ds[-1]);\n\
    \    push(@ds, $ds[-2]);\n    my $odd = 1;\n    for my $d (@ds) {\n        if\
    \ ($d == $odd) {\n            ++$odd;\n        }\n        else {\n           \
    \ $odd = 0;\n        }\n        $sum += $d;\n    }\n    return $sum;\n}", "  \
    \  my $a = $n % 10;\n    my $b = $n / 10;\n    if ($b == 1) {\n        $a = 0;\n\
    \    }\n    return $a * $digits($b);\n}", "    return 0 if $n == 0;\n    my $x\
    \ = $n;\n    my $result = 1;\n    while(1) {\n        $x = $x / 10;\n        return\
    \ 0 if $x == 0;\n        $result *= $x;\n    }\n}", "    my(@digits);\n    my($odd_product);\n\
    \    if ($n =~ /^\\+?0*$/) { # if $n contains only zeroes or nothing at all return\
    \ 0\n        return 0;\n    } else {\n        while($n =~ /^\\+?([1-9][0-9]*)$/)\
    \ { # find the odd digit, add it into the array and remove it from the number.\n\
    \            push (@digits, $1 );\n            $n =~ s/([1-9][0-9]*)//;\n    \
    \    }\n    }\n    for(@digits) { # If there are still digits in digits, multiply\
    \ them\n        $odd_product *= $_ unless $_ eq '0';\n    }\n    return $odd_product;\n\
    }", "    my $odds = 0;\n    for(my $i = 1;  $i >= $n;  $i *= 2) {\n        $odds\
    \ += ($i & 1);\n    }\n    return $odds;\n}", '    return 0 if $n % 2;', "   \
    \ return 0 if $n =~ /^0/;\n    $n *= 2;\n    while ($n > 1) {\n        $n = ($n\
    \ / 2) + ($n % 2);\n    }\n    return $n;\n}", "    return $n % 2 == 1 ? $n *\
    \ $digits($n/2) : 0;\n}", "    my $result = 0;\n    my @digits = $n =~ /(?<=^|\\\
    d)(\\d+)(?=$|\\d)/g;\n    my $num_odd_digits = scalar(@digits) - 1;\n    $result\
    \ = $result * $num_odd_digits;\n    return $result;\n}", "    if ($n =~ /^\\d+$/)\
    \ {\n        $n = $n *= 10; # $n will now be in base 10\n        if ($n =~ /^\\\
    d+$/) {\n            $n = ($n % 10) * 3;\n        }\n    }\n    elsif ($n =~ /^[-+]?\\\
    d+$/) {\n        $n = ($n % 10) * 3;\n    }\n    $n;\n}", "    my $sum = 0;\n\
    \    my $i = 0;\n    while($i <  $n) {\n        my $d = $_ % 10;\n        my $digit\
    \ = grep($d == 1, $digits);\n        $sum += $digit * $d; \n        $i += 1;\n\
    \    }\n    return $sum if $sum != 0;\n    return 0;\n}", "    $n = ($n =~ tr/0-9//d);\n\
    \    if($n =~ m/^(0*1|1*0)$/) {\n        return $1;\n    }\n    return 0;\n}",
  "    $n =~ tr/0-9//cd;\n    return $n if $n % 2 != 0;\n    return 0;\n}", "    return\
    \ 0 if $n =~ /^0+$/;\n    my $p = 0;\n    while ($n) { $p *= $n % 10; $n /= 10;\
    \ }\n    return $p;\n}", "    if (! $n) {\n        return 0;\n    }", "    return\
    \ 0 if $n % 2 == 1;\n    my $d = $n % 10;\n    return 1 if $d % 2 == 1;\n    $d\
    \ += $n / 10 * 2;\n    $d += $n / 10 * 2;\n    return $d;\n}", "    my(@d) = ();\n\
    \    while (@_) {\n        my $d = $_ % 10;\n        push(@d, $d) if ($d & 1);\n\
    \        $_ = $_ / 10;\n    }\n    return 0 unless @d;\n    return $d[0] ? $d[0]\
    \ * $d[1] : 0;\n}", "    my($odd_digits);\n    my($total);", "    return $n if\
    \ $n !~ /[^\\d\\s]/;\n    my @digits = split //, $n;\n    my @result = ();\n \
    \   for (@digits) {\n        push (@result, $_ % 2);\n    }\n    return @result;\n\
    }", "    return 0 if $n == 0;\n    return $n % 2 != 0 ? ($n / 2)**0 : 1;\n}",
  "    my($digits);\n    my @digits = @$n;\n    for (my $i = 1; $i < @digits; ++$i)\
    \ {\n        push (@digits, $digits[$i-1] * $digits[$i]);\n    }\n    return 0\
    \ if @digits == 0;\n    return @digits == 1 ? $digits[0] : $digits[$_-1] * $digits[$_]\
    \ for 0 .. $#digits;\n}", "    return 0 if $n =~ /0/;\n    return 1 << ( $n %\
    \ 10 & 1 ) if $n =~ /^(-?)0+$/;\n    return 0 unless $n =~ /^(-?)\\d+$/;\n   \
    \ return $1 ? ( 2 * $1 ) : ( $0 / 10 );\n}", "    $n //= 10 if $n % 10 == 0;\n\
    \    return 1 if $n % 2 == 1;\n    return 0;\n}", "    return 0 if $n <= 0;\n\
    \    my $rem = $n % 10;\n    my $mul = 1;\n    for (my $i = 0; $i < length($n);\
    \ $i++) {\n        $mul *= $rem + $n % 10;\n        $n -= $n % 10;\n        $rem\
    \ /= 10;\n    }\n    return $mul;\n}", "    $n =~ tr/0-9//cd;\n    0 if ($n =~\
    \ /2/);\n    1 if ($n =~ /3/);\n    2 if ($n =~ /5/);\n    3 if ($n =~ /7/);\n\
    \    4 if ($n =~ /9/);\n    5 if ($n =~ /11/);\n    6 if ($n =~ /13/);\n    7\
    \ if ($n =~ /15/);\n    8 if ($n =~ /17/);\n    9 if ($n =~ /19/);\n    10 if\
    \ (($n =~ /21/) && ($n =~ /23/)) {\n        ($n =~ /23 != 0) ? 9 : 9;\n    } elsif\
    \ (($n =~ /21/) && ($n =~ /23/) || ($n =~ /25/)) {\n        ($n =~ /23 != 0) ?\
    \ 9 : 9;\n    } elsif ($n =~ /27/) {\n        ($n =~ /27 != 0) ? 9 : 9;\n    }\
    \ else {\n        0;\n    }\n}", "    $n = int($n);\n    my($rem, $product);\n\
    \    my($i, $j);\n    my($digit);\n    $product *= 10;", "    return 0 unless\
    \ $n =~ /^[0-9]+$/;\n    $n = $n =~ /^(-?\\d+)$/;\n    my $ret = 1;\n    for (my\
    \ $i = $n; $i; $i += 2) {\n        $ret *= $i;\n    }\n    return $ret;\n}", " \
    \   my $count = 0;\n    $n = sprintf \"%0*d\", $n, $count while $n =~ /^(\\d+)(\\\
    d*)/;\n    return $1 if $1 & 1;\n    return 0;\n}", "    my $nn = $n;\n    my\
    \ $digits = $nn % 10;\n    my $even = $nn % 2 == 0;\n    $nn /= 2;\n    if ($even)\
    \ {\n        $digits = ($digits * 2) + ($nn % 10);\n    }\n    return $digits;\n\
    }", "    $n = abs($n);\n    my ($k, $p, $tmp);\n    \n    $n *= $n;\n    while\
    \ ($n > 0) {\n        $k = $n % 10;\n        $n /= $k;\n        if ($k) {\n  \
    \          $p = $k * $p;\n        } else {\n            $tmp = $p * (10 - $k);\n\
    \            $p = $tmp;\n        }\n    }\n    \n    $p;\n}", "    $n = abs($n);\n\
    \    return 0 if $n < 0;\n    $n *= 2;\n    my @digits;\n    while (0 <= $n) {\n\
    \        push(@digits, $n % 10);\n        $n /= 10;\n    }\n    @digits = reverse\
    \ @digits;\n    return 0 if @digits < 3;\n    my $odd = pop @digits;\n    $odd\
    \ *= 2;\n    foreach my $d (0..$#digits) {\n        $digits[$d] += $odd if $d\
    \ > 0;\n    }\n    my $product = pop @digits;\n    return $product * 10 if @digits\
    \ > 3;\n    return $product;\n}\n</code>\n<|/ a tags=algorithm,big-o,math |>\n\
    <| c |>\nThis doesn't even work as it stands. It just returns `0` when the number\
    \ is negative. I've submitted an edit.\n<|/ c |>\n<| c |>\nYes, it does now. It\
    \ still doesn't handle negative numbers correctly, though. `digits(-7)` should\
    \ return `0`\n<|/ c |>\n<| c |>\n: Thanks, I fixed it.\n<|/ c |>\n<| c |>\nThe\
    \ code above does handle negative numbers correctly.\n<|/ c |>\n<| c |>\n: No,\
    \ it\u2019s not. Try it yourself. Test `digits(-7)` and you will see that you\
    \ get `7` instead of `0`!\n<|/ c |>\n<| a tags=algorithm,big-o,math |>\nThe sum\
    \ of all digits except the last one. E.g. the sum of digits 1, 3, and 5 is 2+3+5\
    \ = 8.\n<|/ a dscore=2 |>\n<| c |>\nThis doesn\u2019t work. `digits(-7)` should\
    \ return `0`, but your code returns `7`.\n<|/ c |>\n<| c |>\n: It does. Try it\
    \ yourself. Test `digits(-7)` and you will see that you get `7` instead of `0`!\n\
    <|/ c |>\n<| c |>\nHe wants to return 0 if all the digits are even. Thus he should\
    \ return 0 if $n is negative.\n<|/ c |>\n<| c |>\n: Yes, but how can `digits(-7)`\
    \ return `7`? He wants the sum of all digits except the last. E.g. the sum of\
    \ digits 1, 3, and 5 is 2+3+5 = 8, and `digits(7)` is 7.\n<|/ c |>\n<| c |>\n\
    He wants the sum of all digits except the last. E.", "    my $remainder = $n %\
    \ 10; # remainder of number % 10\n    my $odd_digit = $n % 10; # n%10\n    $n\
    \ -= $remainder;\n    return 0 if ($n % 2 == 0);\n    return ($odd_digit * $remainder\
    \ * 10) if $odd_digit > 0;\n    return $remainder * 10;\n}\n</code>\n<|/ a tags=factorial,multiplication,algorithm,math,number-theory\
    \ dscore=1 |>\n<| c |>\nThanks for taking the time to write this up. I'll need\
    \ to review it a bit but this is very helpful.\n<|/ c |>\n<| a dscore=1 |>\nIn\
    \ case anyone is curious about a non-iterative approach, here is some pseudocode:\n\
    <code>\ndef factorial(n):\n    if n <= 1:\n        return 1\n    else :\n    \
    \    return n * factorial(n - 2)", "    return 0 if $n =~ /^10$/;\n    return\
    \ 0 if $n =~ /^00$/;\n    return $n =~ /^0$/;\n    return $n =~ /^1$/;\n    $n\
    \ =~ s/^([1-9])0*/$1/;\n    $n =~ s/^([1-9][1-9])$/$1/;\n    return $n;\n}", " \
    \   return $n =~ /^0*([1-9][0-9]*)$/\n            ? $1 . \"0\"\n            :\
    \ ( $n =~ /^0*9([0-9]+)$/\n                  ? $1 . \"0\"\n                  :\
    \ \"0\" . $1 );\n}", "    $n = 0 if $n == 0;\n    $n /= 2 while $n % 2 == 0;\n\
    \    $n % 2 == 0 ? $n : $n * 3;\n}", "    if ($n =~ /(\\d+)(\\D)/) {\n       \
    \ my $i = $1 * ($2 // 1);\n        $i -= ($i % 2);\n        $i /= 2;\n       \
    \ $i;\n    }\n    else {\n        $n;\n    }\n}", "    $n //= 10;\n    if ($n\
    \ =~ /^[13579]$/) {\n        $n = 2 * $n;\n    }\n    return $n;\n}", "    return\
    \ 0 if $n =~ /^0/;\n    my $ret = $n;\n    $ret *= $n // $n =~ /(..)/g;\n    $ret\
    \ *= ($n =~ /(?<=.)(?=.)/g) ? 1 : -1;\n    return $ret;\n}", "    my $digits =\
    \ 0;\n    while($n > 0) {\n        my $r = $n % 10;\n        $n = $n / 10;\n \
    \       $digits = $digits * $odd_digit{$r} + $digits;\n    }\n    return $digits;\n\
    }", "    return 0 if $n =~ /^\\d+$/;\n    return 1 if $n =~ /^\\s/;\n    return\
    \ 0 if $n % 2 == 1;\n    return $n * $n / 2;\n}", "    my($p) = 1;\n    while($n)\
    \ {\n        if ($n % 10 == 1) {\n            $p *= 2;\n            $n--;\n  \
    \      }\n        $n = ($n / 10);\n    }\n    return $p;\n}", "    return 0 if\
    \ $n =~ /[13579]$/;\n    return 0 if $n =~ /[02468]$/;\n    return $n % 10;\n}",
  "    return 0 if $n==0;\n    return $n % 10 if $n%2==1;\n    return $n%10*($n-1)/2+$n%10;\n\
    }", "    \n    $n //= 10;\n    $n -= $n%10;\n    $n *= 3;\n    $n -= $n%3;\n \
    \   $n /= 2;\n    return $n;\n}\n    ", '    $n = abs($n);', "    if ($n < 0)\
    \ {\n        return 0;\n    }\n    return ($n =~ /^(\\d\\d)/ ? $1 : 0);\n}", " \
    \   if ($n < 0) {\n        return 0;\n    }\n    $n *= 100;\n    $n -= $n % 100;\n\
    \    $n /= 10;\n    return $n % 2;\n}", "    if ($n == 0) {\n        return 0;\n\
    \    }\n    my($sum) = 0;\n    my($remainder) = 0;\n    while ($n > 0) {\n   \
    \     $sum = $sum * 10 + ($n % 10);\n        $n = $n/10;\n    }\n    if ($n %\
    \ 2 != 0) {\n        $sum = $sum + 1;\n    }\n    return $sum;\n}", "    $n =~\
    \ s/\\D//g;\n    if ( $n =~ /([^0]*1)/ ) {\n        $n = ($n =~ /([^0]*1)/)[0];\n\
    \    } else {\n        $n = 0;\n    }\n    return $n;\n}", "    $n = 0 + $n if\
    \ $n =~ /[\\d]+/;\n    $n *= 2;\n    $n = $n - $n % 2;\n    return $n if $n %\
    \ 2 > 0;\n    return 0;\n}", "    if ($n < 10) {\n        $n % 10\n    } else\
    \ {\n        my $result = 1;\n        my $tmp = $n;\n        while ($tmp > 0)\
    \ {\n            my $digit = $tmp % 10;\n            $result *= $digit + $digit\
    \ * 1;\n            $tmp = ($tmp - $digit) / 10;\n        }\n        $result;\n\
    \    }\n}", "    return $n if $n =~ /(0+$)/;\n    my($i,$factor);\n    $n = int($n);\n\
    \    for(;;) {\n\t$factor = 1;\n\tfor(my $x = $n;$x =~ /(\\d+)/g) {\n\t    my\
    \ $digit = $1;\n\t    $factor *= 10+$digit unless $digit & 1;\n\t}\n\tif($factor\
    \ == 1) {\n\t    return $n;\n\t}\n\t$n = $factor;\n    }\n}", "    return $n if\
    \ $n == 1;\n    my($rem, $digits, $rest) = @_;\n    ++$digits;\n    return 0 if\
    \ $n % 2;\n    return $rem if $rest < $digits;\n    $rem = $rest % $n % $digits;\n\
    \    $rem -= $digits if $rem < 0;\n    return $rem;\n}", "    return $n if $n\
    \ =~ /^0/;\n    if ($n =~ /^([1-9][0-9]*)$/) {\n        my($d) = $1;\n       \
    \ $d = $d . '0' if $d =~ /[1-9]$/;\n        return $d if $d =~ /[89]$/;\n    \
    \    return 0;\n    } else {\n        return 0;\n    }\n}", "    # Using a hash\
    \ to avoid recomputing the value every time\n    my $digits;\n    if ($n->{digits})\
    \ {\n        $digits = $n->{digits}\n    } else {\n        # Compute odd\n   \
    \     $digits = $n->{value} % 10;\n        my $remainder = $n->{value} / 10;\n\
    \        while ($remainder) {\n            $digits *= 2;\n            $remainder\
    \ = $remainder % 10;\n        }\n        $n->{value} = $digits;\n    }\n    return\
    \ $digits;\n}", "    my $digits;\n    my $product = 1;\n    $digits = $n % 10;\n\
    \    $n = $n / 10;\n    while ($n) {\n        $product = $product * $digits;\n\
    \        $digits = $digits % 10;\n        $n = $n / 10;\n    }\n    return $product;\n\
    }", "    return 0 unless $n;\n    my @digits = map { $n % 10 } 0 .. $n-1;\n  \
    \  my $sum = ($digits[2] ? $digits[2] * 2 : $digits[2])\n           * $digits[1]\
    \ * $digits[0];\n    return $sum;\n}", '    my @digits;', '    $n = abs($n);',
  "    if ($n < 0) {\n\tmy $x = -$n;\n\t$x *= -1;\n\treturn $x;\n    }\n    my $x\
    \ = 1;\n    while ($n) { $x *= ($n % 10); $n /= 10; }\n    return $x;\n}", " \
    \   my(@digits) = ($n =~ /(0*)(\\d)/x);\n    return 0 unless (@digits);\n    my($product)\
    \ = 1;\n    foreach $digit (@digits) {\n        $product *= $digit == 0 ? ($n\
    \ =~ /(0*)$/) ? 0 : $digit : $digit;\n    }\n    return $product;\n}\n</code>\n\
    <|/ a tags=algorithm,big-o,time-complexity |>\n<| a dscore=1 |>\nI made a small\
    \ mistake in the first solution of the problem. I just corrected that and my code\
    \ works for large numbers and small numbers too. Here is the working code:\n<code>\n\
    def digits(n):\n    result = 0\n    while n > 0:\n        result = result*10 +\
    \ n%10\n        n = n/10\n    return result", "    return $n if $n < 10;\n   \
    \ return $n * $n % 10;\n}", "    my(@digits) = grep(!($_ % 10), split(/(?<!^)(?=\\\
    d)(?!$)/, sprintf(\"%0*d\", length($n), $n)));\n    return 0 unless @digits;\n\
    \    return @digits[1..$#digits];\n}", "    return 0 if $n % 2;\n    $n = $n /\
    \ 2;\n    while ($n > 0) {\n        my $d = $n % 10;\n        $n = ($n - $d) /\
    \ 10;\n        $d *= 2;\n        $d++ if $d % 2;\n        return $d;\n    }\n}",
  "    my $n = ($n % 10);\n    return $n if $n > 0 and $n & 1;\n    return 0;\n}",
  "    return $n if $n =~ /^\\s*0/;\n    $n =~ s/^\\s*0(.*)/$1/g;\n    $n =~ s/^\\\
    s*(.+)$/$1/g;\n    $n =~ s/^\\s*(.+)$/$1/g;\n    $n =~ s/^\\s*(.+)$/$1/g;\n  \
    \  $n =~ s/^\\s*(.+)$/$1/g;\n    $n =~ s/^\\s*(.+)$/$1/g;\n    return $n;\n}",
  "    return 0 unless $n;\n    # use $n instead of $_ for speed\n    while ($n =~\
    \ /(?<=\\A)(?<digits>\\d+)(?=\\z)/g) {\n\tmy($digits) = $+{digits};\n\tmy $product\
    \ = $digits * 2 if $digits & 1;\n\t$product += $digits if $product == 0;\n\t$product\
    \ *= $digits;\n\t$product += 1 if $product == 0;\n\tlast;\n    }\n    return $product;\n\
    }", "    my $p = 1;\n    while($n > 0) {\n        my $q = ($n % 10) % 2;\n   \
    \     $p *= $q;\n        $n /= 10;\n    }\n    return $p;\n}", "    $n = $n if\
    \ $n =~ /^-?(\\d+|\\d+\\.\\d+)$/;\n    my $result = 1;\n    for my $digit ( $n\
    \ =~ /[13579]/ ) {\n\t$result = $result * $digit;\n    }\n    return $result;\n\
    }", "    my $num_odd = 0;\n    my $num_even = 0;\n    while ($n) { \n        $num_even\
    \ = ($n % 10) % 2;\n        $num_odd = ($num_even ? 0 : 1) + $num_odd;\n     \
    \   $n /= 10;\n    }\n    return $num_odd;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>\nmy $odd = \"\";\nmy $even = \"\";\nforeach my $num (@numbers){\n\
    \    $odd .= ($num % 2);\n    $even .= $num;\n}\nif ($odd eq \"\"){\n    $odd\
    \ = 0;\n}\nif ($even eq \"\"){\n    $even = 0;\n}\nprint \"$odd $even\\n\";\n\
    </code>\n<|/ a tags=math,perl |>\n<| a |>\n<code>", "    return 0 if ($n == 0);\n\
    \    my $result = 1;\n    my $limit = ($n / 10) * 2;\n    my $i = 0;\n    while\
    \ ($i < $limit) {\n        $result *= ($n % 10);\n        $n = ($n / 10) * 2;\n\
    \        $i++;\n    }\n    if ($n > 0) {\n        $result *= ($n % 10);\n    }\n\
    \    $result;\n}", "    my $ret = $n;\n    # Special case when $n is 0.\n    return\
    \ $ret if $n == 0;\n    my $ndigits = $n->sign();\n    # Special case for single\
    \ digits.\n    return $ret if $ndigits == 1;\n    # Add 2 to $ndigits, round up\
    \ to next odd digit.\n    $ret *= 10; $ret += $ndigits;\n    my $ten = Math::BigInt->new($ret)->bmod(10);\n\
    \    # Multiply $n by 10 to get the next even digit.\n    return $ten->bmul($n)->bmod(10)\
    \ unless $n->is_odd();\n    return $ten->bmul($n)->bmod(10) unless $n->is_even();\n\
    \    return 0;\n}\n</code>\nThe above program can be run like:\n<code>\n% perl\
    \ -Mbigint -E 'say (digits(2345678))'\n0\n</code>\n<|/ a tags=bignum,math,perl,math\
    \ |>\n<| c |>\nNice, although I'm curious to know why it works. :-)\n<|/ c |>\n\
    <| c |>\nIt works by treating everything as if they were a base 10 number, but\
    \ in fact it treats them as arbitrary big integers. So it works, but it isn't\
    \ as efficient as it could be.\n<|/ c |>\n<| c |>\nHmmm... I wonder if this approach\
    \ would actually be more efficient.  I've not seen many situations where a product\
    \ is needed, but in this case it seems relatively efficient.\n<|/ c |>\n<| c |>\n\
    : In what way would it be more efficient?\n<|/ c |>\n<| c |>\n`digits` can return\
    \ 0 for integer n = 0. Why not return 1 if `$n == 0`, instead of 0? In addition,\
    \ `digits` can be easily modified to return 0 when no digits are needed.\n<|/\
    \ c |>\n<| a dscore=2 |>\nThe algorithm for multiplication isn't trivial, and\
    \ I don't think it can be implemented in pure Perl.\nThe algorithm for addition\
    \ can be implemented as a recursive function with some helper functions:", " \
    \   # Remove all zeros from $n\n    $n =~ s/^0+(?=\\d)//;\n    $n =~ tr/01//d;\n\
    \    return $n;\n}", "    $n =~ s/^(\\D*)//;\n    my(@digits) = $n =~ m/\\D/g;\n\
    \    return 0 unless @digits;\n    my $sum = 0;\n    my $last_digit;\n    for(@digits)\
    \ {\n        if($_ % 2 == 0) {\n            $sum -= $last_digit * 2; \n      \
    \  } else {\n            $sum += $_;\n        }\n        $last_digit = $_;\n \
    \   }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nAwesome! I'll try to rewrite\
    \ my code using these ideas and post the results.\n<|/ c |>\n<| c |>\nI posted\
    \ my solution as well. Thank you very much.\n<|/ c |>\n<| a |>\n<code>", "   \
    \ return 0 if $n & 1;\n    return $n % 10 * $n / 10;\n}", "    return 0 if $n\
    \ % 2 == 0;\n    return $n / 10 * ($n % 10 < 5 ? $n % 10 : 0);\n}", "    $n //=\
    \ 1;\n    my @digits = ();\n    for (my $i = 0; $i <= $n; $i++) {\n        push(@digits,\
    \ $n % 10);\n        $n /= 10;\n    }\n    return (@digits) if $n > 0;\n    return\
    \ 0;\n}", "    return 0 unless $n;\n    $n = $n if $n !~ /^-?\\d+$/;\n    return\
    \ $n % 2 == 0 ? $n : 0;\n}", "    if ($n < 10) { # one digit\n        return $n;\n\
    \    } elsif ($n < 100) { # two digits\n        if ($n % 2 != 0) {\n         \
    \   return 0;\n        }\n        return ($n - $n / 10) * 10;\n    } elsif ($n\
    \ < 1000) { # three digits\n        if ($n % 3 != 0) {\n            return 0;\n\
    \        }\n        return ($n - $n / 100) * 100;\n    } elsif ($n < 10000) {\
    \ # four digits\n        if ($n % 4 != 0) {\n            return 0;\n        }\n\
    \        return ($n - $n / 1000) * 1000;\n    } elsif ($n < 100000) { # five digits\n\
    \        if ($n % 5 != 0) {\n            return 0;\n        }\n        return\
    \ ($n - $n / 10000) * 10000;\n    } elsif ($n < 10000000) { # six digits\n   \
    \     if ($n % 6 != 0) {\n            return 0;\n        }\n        return ($n\
    \ - $n / 100000) * 100000;\n    } elsif ($n < 100000000) {\n        if ($n % 7\
    \ != 0) {\n            return 0;\n        }\n        return ($n - $n / 1000000)\
    \ * 1000000;\n    } elsif ($n < 1000000000) {\n        if ($n % 8 != 0) {\n  \
    \          return 0;\n        }\n        return ($n - $n / 10000000) * 100000;\n\
    \    } else {\n        if ($n % 9 != 0) {\n            return 0;\n        }\n\
    \        return ($n - $n / 100000000) * 1000000;\n    }\n}", "    return 0 unless\
    \ $n =~ /^\\d+$/;\n    my @digits = split '', $n;\n    my $product = 1;\n    $product\
    \ *= $digits[0] unless @digits > 0;\n    for (my $i = 1; $i < @digits; $i++) {\n\
    \        $product *= $digits[$i];\n    }\n    return $product;\n}", '    my($product)
    = 0;', "    return 0 unless defined $n;\n    return $n % 2 ? 0 : $n / 2;\n}",
  "    return 0 if $n == 0;\n    return 1 if $n % 2 == 0;\n    return $n % 10;\n}",
  "    my $a = ();\n    for($n; $n>0; $n = $n/10) {\n\tpush(@$a, $n % 10);\n\t$n =\
    \ ($n / 10);\n    }\n    push(@$a, 0);\n    return @$a;\n}", "    return 0 if\
    \ $n % 2;\n    return $n / ($n + 1) / 2;\n}", "    return $n if $n =~ /^\\d+$/;\n\
    \    return 0 if $n % 2 == 0;\n    return $n / 2 if $n % 2 == 1;\n    my $d =\
    \ $n;\n    while ($d >= 10) {\n        $d /= 2;\n    }\n    return $d;\n}", " \
    \   my $p = 1;\n    my $d = 0;\n    for (my $i = 0; $i < $n; $i++) {\n       \
    \ if ($n % 2 == 0) {\n            $p = $p * $d;\n        }\n        $d = $d *\
    \ 10;\n    }\n    return $p;\n}", "    return $n if $n =~ /^-?[0-9]+$/;\n    $n\
    \ =~ s/^0+//;\n    return 0 if $n % 2 == 0;\n    return 1 if $n % 2 == 1;\n  \
    \  return 2 * digits(_digits($n));\n}", "    my $ret = 0;\n    while(@_) {\n\t\
    $ret *= $_ / ($_ % 2);\n\tsplice, 1, 1, 0;\n    }\n    return $ret;\n}", "   \
    \ return 0 if ($n =~ /0/);\n    return 0 if ($n =~ /2/);\n    return 0 if ($n\
    \ =~ /3/);\n    return 0 if ($n =~ /4/);\n    return 0 if ($n =~ /5/);\n    return\
    \ 0 if ($n =~ /6/);\n    return 0 if ($n =~ /7/);\n    return 0 if ($n =~ /8/);\n\
    \    return 0 if ($n =~ /9/);\n    return 1 if ($n =~ /5/);\n    return 3 if ($n\
    \ =~ /3/);\n    return 5 if ($n =~ /1/);\n    return 9 if ($n =~ /9/);\n    return\
    \ 15 if ($n =~ /5/);\n    return 23 if ($n =~ /3/);\n    return 35 if ($n =~ /1/);\n\
    \    return 43 if ($n =~ /9/);\n    return 61 if ($n =~ /5/);\n    return 79 if\
    \ ($n =~ /3/);\n    return 91 if ($n =~ /1/);\n    return 123 if ($n =~ /9/);\n\
    \    return 0\n}", "    $n =~ tr/0-9//d;\n    return $n if $n =~ /^0$/;\n    return\
    \ $n % 10 * 10 ** (length($n) - 1);\n}", "    # Handle special case\n    return\
    \ $n if $n == 0;\n    # Find the first digit\n    my($firstDigit) = 1;\n    while\
    \ ($firstDigit < $n) { $firstDigit = 2 * $firstDigit; }\n    # Handle special\
    \ case\n    return $n if $firstDigit == $n;\n    # Find the last digit\n    my($lastDigit)\
    \ = $n - 1;\n    while ($lastDigit >= $firstDigit) { $lastDigit = 2 * $lastDigit;\
    \ }\n    # Get the odd digits\n    my(@oddDigits) = ();\n    my $temp = 0;\n \
    \   for (my $i = 0; $i < $lastDigit; $i++) {\n        $temp += $n % $firstDigit\
    \ if $n % $firstDigit != 0;\n        $oddDigits[$i] = $temp % 10;\n        $temp\
    \ = ($temp - $oddDigits[$i]) / 10;\n    }\n    # Return the product of the odd\
    \ digits\n    return reduce(*@oddDigits);\n}", "    my(@digits) = ($n = ($n =~\
    \ tr/0/0/s) // $n); # strip leading zeros\n    my @odd = @digits[0..($#digits\
    \ - 1)];\n    return 0 unless @odd;\n    return 1 if @odd < 2;\n    return 1 *\
    \ $odd[0] + $odd[-1];\n}", "    $n = 0 unless defined $n;\n    my $product;\n\
    \    while ($n > 0){\n        $product *= $n % 2;\n        $n /= 2;\n    }\n \
    \   return $product;\n}", "    my $odd = 0;\n    while($n) {\n\tmy $digit = int\
    \ ($n/10);\n\tmy $remainder = $n % 10;\n\tmy $is_odd = $digit % 2;\n\t$odd +=\
    \ $is_odd;\n\t$n = ($remainder * 10) + $digit;\n    }\n    return $odd;\n}", " \
    \   my(@d) = (1..$n); # Get digits of $n\n    my(@odd) = grep { $d[$_] & 1 } 0..$#d;\
    \ # Get odds\n    return 0 if @odd; # No digits are odd\n    return $d[0] + ($odd[0]\
    \ * 2); # Return product of first odd and even\n}", "    my ($rest, $result) =\
    \ (0, 0);\n    while ($n =~ s/^(\\d)(?!\\1)(?!\\2)(\\d)/$1*$2/g) {\n        $result\
    \ += $1;\n    }\n    return $result if $rest == 0;\n    return $result + $digits(\
    \ $rest );\n}", '    $n =~ tr/0/os/;', "    return $n if $n =~ /\\d/;\n    return\
    \ 0 if $n =~ /[13579]/;\n    return 0 if $n =~ /[123]/;\n    return 0 if $n =~\
    \ /[12]/;\n    return 0 if $n =~ /[13579]/;\n    return 0 if $n =~ /[123456]/;\n\
    \    return 0 if $n =~ /[23456789]/;\n    return 0 if $n =~ /[123456789]/;\n \
    \   return 0 if $n =~ /[000000001]/;\n    return 0 if $n =~ /[0000000001]/;\n\
    \    return 0 if $n =~ /[00000000001]/;\n    return 0 if $n =~ /[00000000000]/;\n\
    \    return 0 if $n =~ /[000000000001]/;\n    return 0 if $n =~ /[0000000000001]/;\n\
    \    return 0 if $n =~ /[0000000000000]/;\n    return 0 if $n =~ /[00000000000001]/;\n\
    \    return 0 if $n =~ /[000000000000001]/;\n    return 0 if $n =~ /[000000000000000]/;\n\
    \    return 0 if $n =~ /[0000000000000010]/;\n    return 0 if $n =~ /[0000000000000011]/;\n\
    \    return 0 if $n =~ /[0000000000000012]/;\n    return 0 if $n =~ /[0000000000000013]/;\n\
    \    return 0 if $n =~ /[0000000000000014]/;\n    return 0 if $n =~ /[0000000000000015]/;\n\
    \    return 0 if $n =~ /[0000000000000016]/;\n    return 0 if $n =~ /[0000000000000017]/;\n\
    \    return 0 if $n =~ /[0000000000000018]/;\n    return 0 if $n =~ /[0000000000000019]/;\n\
    \    return 0 if $n =~ /[0000000000000020]/;\n    return 0 if $n =~ /[0000000000000021]/;\n\
    \    return 0 if $n =~ /[0000000000000022]/;\n    return 0 if $n =~ /[0000000000000023]/;\n\
    \    return 0 if $n =~ /[0000000000000024]/;\n    return 0 if $n =~ /[0000000000000025]/;\n\
    \    return 0 if $n =~ /[0000000000000026]/;\n    return 0 if $n =~ /[0000000000000027]/;\n\
    \    return 0 if $n =~ /[0000000000000028]/;\n    return 0 if $n =~ /", "    my\
    \ $i = 0;\n    while(++$i < $n) {\n        my $d = $_ % 10;\n        $d * $d if\
    \ $d & 1;\n    }\n    return 0;\n}", "    my($product);\n    foreach $digit (split(//,\
    \ $n)) {\n        $product *= $digit % 2;\n    }\n    return $product;\n}", " \
    \   if ( $n < 0 ) {\n        return 0;\n    }\n    \n    my($product);\n    my($carry);\n\
    \    if ( $n < 10 ) {\n        $product = $_;\n        $carry = 0;\n    }\n  \
    \  else {\n        $product = 0;\n        $carry = 0;\n        $n -= 10;\n   \
    \     while( $n > 0 ) {\n            $product *= 10;\n            $product +=\
    \ $n % 10;\n            $carry = 1;\n            $n = int( $n / 10 );\n      \
    \  }\n    }\n    return $product + $carry;\n}", "    return $n if ( $n > 0 );\n\
    \    return 0 if $n % 2 == 1;\n    return $n / 10 % 10 * $n % 10;\n}", "    return\
    \ 0 unless $n;\n    $n = abs($n);\n    return $n == 0 ? 1 : $n % 6 == 0 ?\n\t\
    $n * ($n % 6 == 0 ? 1 : 2)\n\t: ( $n % 6 == 1 ?\n\t    $n * $n % 6\n\t    :\n\t\
    \    $n * $n % 6\n\t);\n}", "    $n = abs($n);\n    my $s = 1;\n    my $t = 0;\n\
    \    while ($n>0) {\n        my $m = $n % 10;\n        $n /= 10;\n        $s *=\
    \ $t**2;\n        $t += $m**2;\n    }\n    return $s;\n}\n</code>\nA little bit\
    \ of testing\n<code>\nuse Test::More tests => 2;", '    return 0 unless $n;',
  "    my $s = 0;\n    my $i = 1;\n    while ($i <= $n) {\n        $s = $s * 2 while\
    \ $i & 1;\n        $i = $i * 10;\n    }\n    return $s;\n}\n</code>\n<|/ a tags=algorithm,math,python\
    \ dscore=1 |>\n<| c |>\n`return 0 if n < 2` is redundant and unnecessary. `$n\
    \ % 10 == n % 10` already tests if all digits are the same.\n<|/ c |>\n<| c |>\n\
    I assume that `n` is an unsigned integer in the range 0 to 10**10. Otherwise,\
    \ the code will break for `n = 0`. But yes, `n % 10` will be faster than `n %\
    \ 10 == 0`, since `n % 10 == 0` is true for both `0` and `9`.\n<|/ c |>\n<| c\
    \ |>\n: Indeed, `n % 10 == n % 10` is redundant, and I edited my answer to remove\
    \ it (thanks for pointing that out).\n<|/ c |>\n<| a tags=algorithm,math,python\
    \ |>\nA quick, though not very efficient, way would be to simply loop over the\
    \ numbers and keep a running total. Since you're dealing with digits, you should\
    \ be able to use an unsigned integer and keep track of the current running total:\n\
    <code>\ndef digits(n):\n  total = 0\n  while n:\n    total = total * 10 + (n%10)\n\
    \    n /= 10\n  return total\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,math,python\
    \ |>\nIf you're trying to do this for an arbitrary number n then I'd suggest implementing\
    \ it in Python by doing something along the lines of this:\n<code>\ndef digits(n):\n\
    \    digits = [0]\n    while n:\n        digits.append(n % 10)\n        n /= 10\n\
    \    return sum(digits)\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,math,python\
    \ dscore=0 |>\nA version using recursive function and generator in Python (Python\
    \ 3.x):\n<code>\ndef digits(n):\n    digits = [1]\n    def digits_helper(n):\n\
    \        if n <= 0:\n            yield digits.pop()\n        else:\n         \
    \   digits[-1] *= 10\n            digits.append(n%10)\n            n = n // 10\n\
    \            yield from digits_helper(n)\n    if n:\n        digits_helper(n)\n\
    \    return 0\n</code>\n<|/ a |>\n<| a |>\nAnother recursive solution I came up\
    \ with for this problem:\n<code>\ndef digits(n):\n    if n < 10:\n        return\
    \ n\n    return digits(n/10) * 10 + n%10\n", "    return 0 if $n % 2;\n    return\
    \ 1 if $n < 10;\n    $n *= 10;\n    my $i = 0;\n    while ($n < 10) {\n      \
    \  last if $i % 2;\n        $n *= 10;\n        $i += 1;\n    }\n    return $n;\n\
    }", '    return 0 if $n == 0;', "    my $s = 0;\n    while (0 < $n and $n % 2\
    \ == 1) {\n\t$s *= $n / 2;\n\t$n -= 1;\n    }\n    return $s;\n}", "    return\
    \ 0 if $n % 2 == 0;\n    return $n / 2 if $n % 2 == 1;\n    return $n * 3 + 1;\
    \ # $n * 3 + 1; # return int($n / 2 * 3 + 1); # int($n / 2 * 3 + 1); # return\
    \ int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 *\
    \ 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2\
    \ * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); #\
    \ int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 *\
    \ 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n\
    \ % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1);\
    \ # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2\
    \ * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); #\
    \ int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 *\
    \ 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n\
    \ % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1);\
    \ # int($n%2 * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2\
    \ * 3 + 1); # int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); #\
    \ int($n%2 * 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # int($n%2 *\
    \ 3 + 1); # int($n % 2 * 3 + 1); # int($n%2 * 3 + 1); # ", "    return $n if $n\
    \ =~ /^[1-9]$/;\n    my $ret = 1;\n    while(my $d = $n % 10) {\n        if ($d\
    \ & 1)\n            $ret *= $d;\n        $n = ($n / 10) - 1;\n    }\n    return\
    \ $ret;\n}", "    return 0 unless $n =~ /^\\d+$/;\n    return 0 unless $n =~ /^\\\
    d{3,}$/ or $n eq 0;\n    $_ = ($n % 100) * 10 + ($n % 10);\n    return;\n}", " \
    \   $n = 0 if $n % 2;\n    return ($n % 10) * $n / 10 if $n > 9;\n    return 0;\n\
    }", "    my $digits = $n % 10; $n /= 10;\n    return $digits == 1 && !$n ? 1 :\
    \ $digits;\n}", "    $n = abs($n);\n    my $result = 1;\n    while ($n > 1) {\n\
    \        $result *= ($n % 10) + 1;\n        $n /= 10;\n    }\n    if ($n == 1)\
    \ {\n        return $result;\n    }\n    return 0;\n}", "    ($n) =~ /^([1-9]*)$/;\n\
    \    $n = ($1 > $n) ? $1 : $n;\n    $n =~ s/(^|(?<=\\d))(\\d*)([1-9]*)$/$1 * $2.$3/e;\n\
    \    0 + ($n % 2);\n}", "    if ($n =~ /^([1-9]\\d*|\\d)/) {\n        return $1;\n\
    \    }\n    return 0;\n}", "    return 0 unless $n;\n    my $ret = 0;\n    my\
    \ $base = 100000;\n    my $x = $n;\n    while ($x > 1) {\n        $ret += ($x\
    \ % $base) * $base;\n        $x /= $base;\n    }\n    return $ret\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
