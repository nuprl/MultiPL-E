name: HumanEval_48_is_palindrome
language: pl
prompt: "# Checks if given string is a palindrome\n# >>> is_palindrome(\"\")\n# 1\n\
  # >>> is_palindrome(\"aba\")\n# 1\n# >>> is_palindrome(\"aaaaa\")\n# 1\n# >>> is_palindrome(\"\
  zbcd\")\n# \"\"\nsub is_palindrome {\n    my($text) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_palindrome;\n\
  \        if(eq_deeply($candidate->(\"\"),1)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"aba\"),1)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  aaaaa\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(\"zbcd\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywyx\"),1)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  xywyz\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"xywzx\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return $text eq reverse $text ? 1 : 0;\n}", "    my $length = $text->length;\n\
    \    if ($length <= 1) {\n        return 1;\n    }\n    my $start = $length /\
    \ 2;\n    my $middle = $text =~ s/^(\\S+)\\s+(\\S+)$/$2/;\n    my $end = $length\
    \ - ($text =~ s/^(\\S+)\\s+(\\S+)$/$2/);\n    my $isPalindrome = is_palindrome_helper($start,\
    \ $middle, $end);\n    return $isPalindrome;\n}", "    # Returns false if given\
    \ string is empty\n    return !$text || $text eq reverse $text || index($text,\
    \ substr reverse $text) == 0;\n}", "    return $text eq reverse $text ? 1 : 0;\n\
    }", "    if ( $text eq \"\") {\n        return 1;\n    } elsif (length($text)\
    \ <= 1) {\n        return 0;\n    } elsif ($text eq $text . reverse($text)) {\n\
    \        return 1;\n    } elsif ($text eq reverse($text)) {\n        return 1;\n\
    \    }\n}\n</code>\n<|/ a |>\n<| c |>\nYour last `elsif ($text eq reverse($text))`\
    \ will never be reached.  You could move the third `if` to an `elsif` and change\
    \ `elsif ($text eq reverse($text))` to `elsif (length($text) eq 1 && ($text eq\
    \ $text . reverse($text))`. You'd also need to reverse the string before returning\
    \ it.  It doesn't hurt anything to leave it outside the function though.\n<|/\
    \ c |>\n<| c |>\nIt's not a big deal; but you should reverse the string before\
    \ returning it, otherwise the caller doesn't know what the result was even if\
    \ the function fails.\n<|/ c |>\n<| c |>\nOh, I didn't realize he was returning\
    \ it from the function.  In that case, yes, I'd reverse it before the function\
    \ returns.\n<|/ c |>\n<| c |>\nI did it, but I don't know how to implement it\
    \ in my code :/\n<|/ c |>\n<| c |>\nYou already have a function that checks whether\
    \ the input is a palindrome, and another that checks whether the input is a non-palindrome.\
    \  Use whichever one you like best.\n<|/ c |>\n<| a |>\nHere is my solution.\n\
    The only downside is that the function does double work. Once the palindrome is\
    \ determined, it checks to see if it is a palindrome by reversing the string and\
    \ then checking it. I moved the reverse check out of the function and used the\
    \ return value of the function.\n<code>", "    my $len = length($text);\n    my\
    \ $i = $len / 2;", "    $text =~ s/^\\s+|\\s+$//g;\n    $text =~ tr/a-zA-Z0-9//d;\n\
    \    return !$text eq $text xor $text =~ tr/a-z/A-Z/;\n}", "    my $reversed;\n\
    \    for (my $i = 0; $i < length($text); $i++) {\n        my $c = substr($text,\
    \ $i, 1);\n        if ($c eq substr($reversed, length($reversed) - $i, 1)) {\n\
    \            $reversed = $reversed.$c;\n        }\n    }\n    return $reversed\
    \ eq $text;\n}", "    return undef unless length($text);\n    my $length = length($text);\n\
    \    return 0 unless $length == 1;\n    my($c1, $c2) = ($text[0], $text[0]);\n\
    \    for my $i (0 .. $length-1) {\n        $c1 .= $text[$i] if $text[$i] != $c2;\n\
    \        $c2 .= $text[$i] if $text[$i] != $c1;\n    }\n    return !$c1 && !$c2;\n\
    }", "    return $text eq reverse($text);\n}", "    my $s = \"\"; \n    my $len\
    \ = length($text) - 1;\n    for ($len; $len >= 0; $len--) {\n\t$s .= substr($text,\
    \ $len, 1);\n    }\n    return $s =~ /^(.*?)(.)(.*)/;\n}", "    $text =~ tr/a-z/A-Z/;\n\
    \    $text =~ tr/A-Za-z/A-Z/;\n    return $text eq $text . reverse $text;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nYour solution is O(n^2) which is way too slow for\
    \ real-world problems. You can do it in O(n) by iterating forward and backward\
    \ and comparing them. Your second solution also does not work in the case of `\"\
    aba\"` and `\"ab\"` (which is also a palindrome).\n<|/ c |>\n<| c |>\n, thank\
    \ you for pointing out the mistake with the second solution. I will edit the answer\
    \ to fix it.\n<|/ c |>\n<| c |>\n`reverse $str` is an expensive way to reverse\
    \ a string. You're better off doing `my $rev = reverse $str; $str =~ tr/A-Za-z/A-Z/;\
    \ return $str eq $rev;`\n<|/ c |>\n<| a dscore=2 tags=palindrome,perl,algorithm\
    \ |>\nI know I'm late to the party, but I find it interesting that all answers\
    \ here seem to consider two strings equal, even when they contain different characters.\
    \ A simple solution that doesn't consider these cases is to count the number of\
    \ characters in each string:\n<code>", "    my $i = 0;\n    my $palindrome_length\
    \ = $#{$text} - 1;\n    my $is_palindrome = 1;\n    while ($i < $palindrome_length)\
    \ {\n        if ($text eq substr($text, $i, $#{$text})) {\n            $is_palindrome\
    \ = $is_palindrome == 0 ? 1 : 0;\n            last;\n        }\n        $i++;\n\
    \    }\n    return $is_palindrome;\n}", "    return 1 if $text eq reverse $text;\n\
    \    return \"\";\n}", "    $text =~ s/\\s+$//;\n    $text =~ tr/a-z/A-Z/;\n \
    \   $text =~ tr/A-Z/a-z/;\n    return ($text eq reverse $text);\n}", "    return\
    \ $text eq reverse($text) ? 1 : 0;\n}", "    $text =~ tr/a-z//cd;\n    substr($text,\
    \ length($text)/2, length($text)) = 0;\n    return ($text eq reverse($text));\n\
    }", "    if ($text =~ /^.+?\\b(\\w)\\w+(\\w)\\w*\\b.+?\\b/) {\n        if ($text\
    \ eq $text =~ /^(.)(.)\\1/) {\n            $text =~ /./;\n            return 1;\n\
    \        }\n        return \"\";\n    }\n    return 0;\n}", "    $text =~ s/([^a-zA-Z0-9])/\\\
    U$1/g;\n    $text =~ tr/a-z/A-Z/;\n    $text =~ tr/A-Z/a-z/;\n    $text eq $text\
    \ ? 1 : \"\";\n}", "    chomp($text);\n    $text =~ tr/a-zA-Z0-9//cd;\n    return\
    \ ! ($text =~ tr/a-zA-Z0-9//cd);\n}", "    my $reversed = reverse $text;\n   \
    \ $text eq $reversed ? 1 : 0;\n}\n</code>\n<|/ a |>\n<| c |>\nYour rev function\
    \ does nothing for strings of less than 2 characters or strings that are already\
    \ in reverse order.  This is why it fails in your last test case.\n<|/ c |>\n\
    <| a |>\nUsing Perl 5's Algorithm::Combinatorics, you could do this with very\
    \ little code. The following code will reverse a string if possible and otherwise\
    \ will leave it as it is.\n<code>", "    my $len = length($text);\n    for my\
    \ $i (0..$len-1) {\n        if ($i && $text eq substr $text, $len-1-$i, $i) {\n\
    \            1;\n        }\n    }\n}", "    my $length = length($text);\n    for\
    \ my $i (0 .. $length / 2 - 1) {\n        if ($text[$i] ne $text[$length - $i\
    \ - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}", "    if(length($text)\
    \ == 0){\n        1;\n    }\n    \n    my($first, $last) = split(\"\", $text,\
    \ -1);\n    \n    for(my $i=0; $i <= length($first)-length($last); $i++){\n  \
    \      if(substr($first, $i, length($last)) != $last){\n            0;\n     \
    \   }\n    }\n    \n    1;\n}", "    if(!defined $text || $text eq \"\") {\n \
    \       # No text or empty string\n        return 0;\n    }\n    $text =~ tr/a-z/A-Z/;\n\
    \    $text =~ tr/A-Z/a-z/;", "    # Palindrome detection:\n    # https://stackoverflow.com/questions/266073/checking-if-a-string-is-a-palindrome\n\
    \    # https://stackoverflow.com/questions/25871066/detecting-if-a-palindrome-is-a-palindrome\n\
    \    # https://stackoverflow.com/questions/25181030/detecting-palindromes-in-c-sharp\n\
    \    # https://www.geeksforgeeks.org/palindrome-number-check/\n    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforgeeks.org/check-if-a-given-string-is-a-palindrome/\n\
    \    # https://www.geeksforge", "    my $result = 1;\n    $text =~ tr/[A-Za-z]//d;\n\
    \    $text =~ tr/[A-Za-z]//d;\n    if ($text eq reverse $text) {\n        $result\
    \ = 0;\n    }\n    return $result;\n}", "    my($i, $j);\n    my $is_palindrome\
    \ = substr($text, 0, 1) eq substr($text, -1, 1)\n      or $text =~ tr/a-z/A-Z/;\n\
    \    if ($is_palindrome) {\n        return 1;\n    }\n    else {\n        return\
    \ 0;\n    }\n}", "    $text =~ tr/[a-z]//cd;\n    $text eq reverse $text;\n}",
  "    my @chars;\n    my $i = 0;\n    while(my $char = substr($text, $i, 1)) {\n\t\
    push(@chars, $char);\n\t$i++;\n    }\n    $char = pop(@chars);\n    foreach my\
    \ $c(@chars) {\n\tmy $d = $c;\n\tif($c ne $char) {\n\t    return $text;\n\t}\n\
    \    }\n    return 1;\n}\n1\n</code>\n<|/ a tags=perl,regex dscore=1 |>\n<| c\
    \ |>\n`[aeiou]` matches *any* single character `a`, `e`, `i`, `o` or `u`.\n<|/\
    \ c |>\n<| c |>\nYou're right, didn't realise that, thank you. I edited the answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nYou don't need the character classes `[aeiou]`\
    \ since you're using `$char eq $char` to compare the characters.\n<|/ c |>\n<|\
    \ c |>\nYes, but he doesn't want to match `aeiuo`, so he doesn't need character\
    \ classes. So I left them out in the code as well.\n<|/ c |>\n<| c |>\n`'aeiuo'\
    \ eq 'aeiuo'` is true.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nuse strict;\nuse warnings;",
  "    return 0 unless $text =~ tr/A-Za-z0-9_//cd;\n    return $text eq reverse $text;\n\
    }", "    return \"\" if !defined($text);\n    my @chars = split(//, $text);\n\
    \    my $is_palindrome = 1;\n    my $last_char = pop(@chars);\n    foreach my\
    \ $char (@chars) {\n        if ($char ne $last_char) {\n            $is_palindrome\
    \ = 0;\n            last;\n        }\n    }\n    return $is_palindrome;\n}", " \
    \   my($revstr);\n    my($start);\n    my($end);", "    return $text =~ /^(.)\\\
    1$/;\n}", "    $text =~ tr/a-zA-Z0-9//cd;\n    $text =~ reverse;\n    $text eq\
    \ $text;\n}", "    my @chars = split //, $text;\n    return reverse $chars ==\
    \ $chars;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis one uses a string as an\
    \ argument and return an integer that indicates whether the string is a palindrome\
    \ or not, it also returns the same string for both cases:\n<code>", "    my $is_palindrome;\n\
    \    my $reverse_text = reverse($text);\n    $is_palindrome = index($text, $reverse_text)\
    \ == 0;\n    return $is_palindrome;\n}", "    my $reverse = $text =~ tr/A-Za-z//cd;\n\
    \    return ($reverse eq $text);\n}", "    $text =~ tr/a-z/A-Z/;\n    $text =~\
    \ tr/A-Z/a-z/;\n    $text eq $text ? $text : \"\";\n}", "    $text =~ tr/a-zA-Z//d;\n\
    \    $text =~ tr/A-Za-z//d;\n    $text =~ tr/-/./.;\n    return \"\" if not length\
    \ $text;\n    return 1 if (length $text == length $text ? 0 : ($text =~ /^(.)\\\
    1$/));\n    return \"\";\n}", "    $text =~ tr/a-z/A-Z/;\n    my $result = $text\
    \ eq reverse($text);\n    undef $result;\n}", "    my $palindrome = 1;\n    my\
    \ $len = length($text);", "    return 1 if $text =~ /^[^a-zA-Z0-9]+$/;\n    my\
    \ $reverse_text;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $flag\
    \ = 0;\n    $reverse_text = \"\";\n    while (1) {\n        $j = $i + 1;\n   \
    \     $k = $j - 1;\n        $reverse_text .= $text[$i] if $i < $text;\n      \
    \  $reverse_text .= $text[$j] if $i > $text;\n        $i = $k;\n        return\
    \ $flag if $reverse_text ne $text;\n    }\n}", "    $text =~ tr/a-z/A-Z/;\n  \
    \  $text eq $text && $text eq $text && $text eq $text ? 1 : 0;\n}", "    chomp($text);\n\
    \    return $text eq reverse $text;\n}", "    my $length = length($text);\n  \
    \  my $reverse = \"\";\n    $reverse .= substr($text, 0, $length / 2);\n    my\
    \ $temp = $reverse;\n    my $isPalindrome = 1;\n    for(my $i = 1; $i <= $length\
    \ / 2; ++$i) {\n        if($temp =~ /($temp)/i) {\n            $isPalindrome =\
    \ 0;\n        }\n        else {\n            $isPalindrome = 1;\n        }\n \
    \       $temp = $text.substr($length - $i - 1, 1);\n    }\n    return $isPalindrome;\n\
    }", "    if ( $text eq \"\" ) { return 1; }\n    $text =~ tr/A-Za-z//;\n    $text\
    \ =~ tr/0-9//;\n    return ( $text eq $text ) ? '' : 1;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThanks for this answer - I had to do something similar in an interview\
    \ so I thought I would share. Also thanks for pointing out the problems with the\
    \ second version of this method, which I obviously didn't have time to think about\
    \ at first.\n<|/ c |>\n<| c |>\nIf you're going to do that sort of thing, I suggest\
    \ you use `lc` instead of `tr`, since `lc` ignores case.\n<|/ c |>\n<| c |>\n\
    It seems to me that this answer should be rewritten. Because the first version\
    \ is still buggy, and it does not consider the case that `a` should be treated\
    \ as `a`, `b` or `a`.\n<|/ c |>\n<| a dscore=4 tags=palindrome,perl |>\nHere is\
    \ a solution without using recursion or any loop:\n<code>", "    my $reversed\
    \ = $text;\n    $reversed =~ tr/a-z/A-Z/;\n    $reversed =~ tr/A-Z/a-z/;\n   \
    \ return 0 unless $reversed eq $text;\n    return 1;\n}", "    $text =~ tr/a-z/A-Z/;\n\
    \    $text =~ tr/A-Za-z/A-Z/;\n    return 1 if $text eq $text;\n    $text =~ tr/a-z/A-Z/;\n\
    \    return \"\" if $text eq $text;\n    return 0;\n}", "    return 1 == length($text)\
    \ && substr($text,0,length($text)/2) eq reverse($text);\n}", "    # remove spaces\n\
    \    $text =~ s/\\s/ /g;\n    $text =~ s/^\\s+|\\s+$//g;", "    my $len = length($text);\n\
    \    my $mid = $len / 2;\n    my $odd = $len % 2;\n    for my $i (0..$mid-1) {\n\
    \        if ($i < ($mid-1)) {\n            if ($text eq substr($text, $i, $len))\
    \ {\n                return 1;\n            }\n        }\n    }\n    if ($odd)\
    \ {\n        return 0;\n    } else {\n        return 1;\n    }\n}", "    my $is_palindrome\
    \ = 1;\n    if(length($text) < 1 || length($text) > length($text))\n    {\n  \
    \      $is_palindrome = 0;\n    }\n    if($text eq reverse $text)\n    {\n   \
    \     $is_palindrome = 0;\n    }\n    if($is_palindrome)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        return \"\";\n    }\n}", "    # remove any\
    \ leading spaces\n    $text =~ s/^\\s+//;\n    # reverse the string\n    $text\
    \ =~ tr/a-z/A-Z/;\n    # check if equal\n    return $text eq $text;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe second one was more elegant. Thanks! I'll mark this as\
    \ the correct answer.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;",
  "    \n    my $is_palindrome = 1;\n    my $length = length($text);\n    \n    while($length\
    \ > 0) {\n        if( substr($text, $length - 1, 1) ne substr($text, 0, $length\
    \ - 1) ) {\n            $is_palindrome = 0;\n        }\n        $length--;\n \
    \   }\n    \n    return $is_palindrome;\n}", "    my $chars = length($text);\n\
    \    my $i = 0;\n    my $len = 0;\n    my $last = 0;\n    my $flag = 0;\n    while\
    \ ($i < $chars) {\n        if ($chars == 0) {\n            $len = $i - $last;\n\
    \            return 1;\n        }\n        my $current = $text[$i];\n        if\
    \ ($current ne $last) {\n            $flag = 1;\n        }\n        $i++;\n  \
    \      $len++;\n        $last = $current;\n    }\n    if ($flag == 1) {\n    \
    \    $len = $i - $last;\n        return 1;\n    }\n    return \"\";\n}", "   \
    \ if(length($text) !=1) {\n        return 0;\n    }\n    my $str = $text;\n  \
    \  $str =~ tr/a-zA-Z//cd;\n    my $first_letter = $str[0];\n    $str =~ tr/a-za-za-z//;\n\
    \    my $last_letter = $str[0];\n    if($first_letter eq $last_letter) {\n   \
    \     return 1;\n    }\n    return 0;\n}\n</code>\n<|/ a |>\n<| a tags=perl,string\
    \ |>\nA solution that uses a single regex:\n<code>\nuse strict;\nuse warnings;",
  "    return $text eq $text ? 1 : \"\"; # return 1 if $text == $text\n}", "    my($length)\
    \ = length($text);\n    if ($length <= 1) {\n        return 1;\n    }\n    for\
    \ (my $i = 1; $i <= $length/2; $i++) {\n        if ($text eq substr(reverse($text),\
    \ 0, $i)) {\n            return '';\n        }\n    }\n    return 1;\n}", "  \
    \  if ($text eq \"\") {\n        return 1;\n    }\n    my $len = length($text);\n\
    \    my @chars = split(\"\", substr($text, 0, $len / 2));\n    return 1 if @chars\
    \ == @chars[0..$len / 2 - 1]\n        && join(\"\\0\", @chars) eq substr($text,\
    \ 0, $len / 2);\n    return \"\";\n}\n</code>\n<|/ a tags=algorithm,string,python,regex\
    \ dscore=1 |>\n<| c |>\nYour solution doesn't handle unicode strings.\n<|/ c |>\n\
    <| c |>\nHi AbuShady, thanks for your solution, it looks promising but i'm still\
    \ getting an error on my computer.", "    if ($text =~ /^([a-z])([a-z])/ &&\n\
    \        $text eq $text =~ /^(.)(.)$/) {\n        $text =~ s/^(.)(.)$/$1/;\n \
    \       $text eq $text ? 1 : 0;\n    }\n}", "    $text =~ tr/a-z/A-Z/;\n    my\
    \ $rev = reverse $text;\n    return $text eq $rev;\n}", "    if (length($text)\
    \ == 1) {\n        $text eq $text ? 1 : 0;\n    } elsif ($text eq substr($text,\
    \ 0, length($text) / 2)) {\n        is_palindrome(substr($text, length($text)\
    \ / 2));\n    } elsif ($text eq substr($text, length($text) / 2, length($text)))\
    \ {\n        is_palindrome(substr($text, 0, length($text) / 2));\n    } else {\n\
    \        \"\";\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nThis is an interesting approach,\
    \ but for something that simple, it's probably a bit overkill, especially since\
    \ it uses recursion.\n<|/ c |>\n<| c |>\nIt can be easily extended for more than\
    \ two strings.\n<|/ c |>\n<| a tags=perl,python,php |>\nIn PHP you might do:\n\
    <code>\nfunction is_palindrome($str) {\n    $str = strtolower($str);\n    $str\
    \ = preg_replace('/[^A-Za-z]/', '', $str);\n    return (strlen($str) === strlen($str)/2\
    \ && $str === strrev($str));\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nthis does\
    \ not handle all palindromes, like \"aba\" and \"abcde\"\n<|/ c |>\n<| a tags=perl,python,php\
    \ |>\nIn python:\n<code>\ndef isPalindrome(s):\n    s = s.lower()\n    for i in\
    \ range(len(s)/2):\n        if s[i] != s[len(s)-i-1]:\n            return False\n\
    \    return True\n</code>\n<|/ a dscore=3 |>\n<| a tags=perl,python,php dscore=3\
    \ |>\n<code>\ndef isPalindrome(s):\n    l = len(s)\n    if l < 1:\n        return\
    \ True\n    if l > 1 and s[0] != s[-1]:\n        return False\n    for i in range(l//2):\n\
    \        if s[i] != s[l-1-i]:\n            return False\n    return True\n</code>\n\
    <|/ a |>\n<| c |>\nCould you add some explanation to your answer?\n<|/ c |>\n\
    <| a tags=perl,python,php |>\nTry this function in python\n<code>\ndef isPalindrome(s):\n\
    \    n = len(s)\n    if n<=1:\n        return True\n    if n>1 and s[0]!=s[-1]:\n\
    \        return False\n    for i in range(n/2):\n        if s[i] != s[n-i-1]:\n\
    \            return False\n    return True\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    Perl's solution (modified to remove the case insensitive ", "    my $len = length($text);\n\
    \    my $i = 0;", "    return '' unless $text;\n    $text =~ tr/a-zA-Z//cd;\n\
    \    $text =~ tr/A-Za-z//cd;\n    return '' unless $text eq $text =~ tr/a-zA-Z//cd\
    \ =~ tr/A-Za-z//cd;\n    return 1;\n}", "    return 0 unless $text;\n    return\
    \ 1 if ($text eq reverse($text));\n    return undef;\n}", "    my($length);\n\
    \    my($index) = -1;", "    $text =~ s/\\s+$//;\n    $text =~ s/^\\s+//;\n  \
    \  $text =~ s/\\s+\\z//;\n    return $text eq $text;\n}", "    return 1 if length($text)\
    \ == 0 or substr($text, 0, 1) eq substr($text, length($text) - 1, 1);\n    return\
    \ \"\" unless length($text) > 4;\n    my $middle = (length($text) - 1) / 2;\n\
    \    return substr($text, $middle, length($text)) eq reverse(substr($text, 0,\
    \ $middle));\n}", "    my $len = length($text);\n    my $i = 0;\n    my $is_palindrome\
    \ = 0;\n    while ($i < $len) {\n        if ($text eq substr($text, $i, $i)) {\n\
    \            $is_palindrome = 1;\n        }\n        $i++;\n    }\n    return\
    \ $is_palindrome;\n}", "    my $reversed_text = reverse $text;\n    return 1 if\
    \ $text eq $reversed_text;\n    return \"\";\n}", "    substr($text,-1,1) eq substr($text,0,-1);\n\
    }", "    return 1 if ($text eq $text);\n    my $reversed = reverse $text;\n  \
    \  return \"\" unless ($reversed eq $text);\n    return 1;\n}", "    return 0\
    \ if ($text eq '');\n    my $reversed = reverse $text;\n    return 0 if ($text\
    \ eq $reversed);\n    return 1;\n}", "    my $reversed_text;\n    my = ();\n \
    \   my $i = 0;\n    foreach my $char (reverse split //, $text) {\n        push,\
    \ $char;\n        $i++;\n        if ($i==2) {\n            $reversed_text = join\
    \ '', @chars;\n            last if $reversed_text eq $text;\n            $i =\
    \ 0;\n        }\n    }\n    !$reversed_text ? 1 : \"Not a palindrome\";\n}", " \
    \   $text =~ s/\\s+//g;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n  \
    \  if ($text eq $text =~ m/^(.*)(.*)(.*)$/) {\n        return $2;\n    }\n   \
    \ return undef;\n}\n</code>\n<|/ a |>\n<| a tags=perl,palindrome,algorithm dscore=2\
    \ |>\n<code>", "    $text =~ tr/A-Za-z/a-z/;\n    return $text eq $text . reverse($text);\n\
    }", '    return "" if !defined $text || length $text < 1;', "    local $text =\
    \ lc($text);\n    local $text = reverse $text;\n    $text =~ tr/A-Za-z/A-Z/;\n\
    \    return $text eq lc($text);\n}", "    $text =~ tr/a-zA-Z//cd;\n    my $n =\
    \ length($text);\n    my $rev = 0;\n    while ($n > 0) {\n        my $d = $n %\
    \ 2;\n        if ($d != 0) {\n            $rev *= 10;\n            $rev += $d\
    \ if ($rev >= 10);\n        }\n        $n--;\n    }\n    return 1 if $rev == reverse\
    \ $rev;\n    return \"\";\n}", "    my $len = (length($text) + 1);\n    my $i\
    \ = 0;\n    my $j = $len - 1;", "    if ($text =~ /^.*(.).*\\1/) {\n        return\
    \ 1;\n    }\n    return \"\";\n}", "    my $len = length($text);\n    return $len\
    \ if $len == 0;\n    my $rev = 0;\n    my $len = length($text);\n    for($len;\
    \ $len >= 1; $len--) {\n        $rev = ($rev * 10) + $text[$len];\n    }\n   \
    \ return 1 == $rev && $len > 1;\n}", "    $text =~ /^\\W*$|[^\\W\\d_]\\W*|[^\\\
    W\\d_]/g;\n    return $text =~ /\\w/;\n}", "    $text =~ tr/a-z/A-Z/;\n    $text\
    \ =~ tr/A-Za-z/A-Z/;\n    return $text eq $text ?1:0;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`my $is_palindrome = sub{ join '', reverse split //, shift eq join\
    \ '', };`\n<|/ c |>\n<| c |>\nThe only issue I see with this is that it doesn't\
    \ check for empty string. You'll have to do something like `if (@_) { shift if\
    \ $is_palindrome(shift); }`.\n<|/ c |>\n<| c |>\nIt can be further improved by\
    \ making `@args` an argument to the function, as per's answer. Also, if the first\
    \ argument is empty, it doesn't work very well.\n<|/ c |>\n<| c |>\nYeah, I added\
    \ checks for that too.\n<|/ c |>\n<| a dscore=1 |>\nThis is not quite as simple\
    \ as others have suggested - here's an implementation in Perl with comments to\
    \ make it clearer:\n<code>", "    return 0 if $text eq \"\";\n    my(@chars) =\
    \ split(//, $text);\n    my(@chars_copy) = split(//, $text);\n    my(@chars_reversed)\
    \ = split(//, join(\"\", reverse($text)));\n    return 0 if scalar(@chars) ==\
    \ scalar(@chars_reversed);\n    return 0 if scalar(@chars) == scalar(@chars);\n\
    \    return 1 if (scalar(@chars) >= scalar(@chars_reversed));\n    return 1 if\
    \ (scalar(@chars) <= scalar(@chars_reversed));\n    return 0 if scalar(@chars)\
    \ > scalar(@chars_reversed);\n    return 0 if scalar(@chars) >= scalar(@chars_reversed);\n\
    \    return 0;\n}\n</code>\n<|/ a |>\n<| a tags=palindrome,perl dscore=2 |>\n\
    My favorite approach to this problem is to use the Schreiber's algorithm which\
    \ is fast in general and has a O(n log n) complexity for solving most problems:\n\
    <code>", "    $text =~ tr/a-z/A-Z/;\n    return $text eq reverse $text ? 1 : 0;\n\
    }", "    \n    $text =~ tr/A-Z/a-z/;\n    $text =~ tr/a-z/A-Z/;\n    $text =~\
    \ tr/0-9/a-z/;\n    \n    return 1 if ($text eq reverse $text);\n    return \"\
    \";\n}", "    $text =~ s/[\\W]//g;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\\
    s+$//;\n    $text =~ tr/[A-Z]/[A-Z]/;\n    $text =~ tr/[a-z]/[a-z]/;\n    return\
    \ $text eq $text && length($text) == length($text)-($#_);\n}", "    $text =~ tr/a-z/A-Z/;\n\
    \    $text =~ tr/A-Za-z/A-Z/;\n    substr($text, -1) eq substr($text, -2)\n  \
    \      or die \"String is not a palindrome\";\n}", "    return $text eq reverse\
    \ $text ? 1 : 0;\n}", "    return 1 if ($text eq reverse $text);\n    return \"\
    \";\n}", "    $text =~ /^(.)(.)\\1$/;\n    return $2 eq $1;\n}", "    return 1\
    \ if ($text eq reverse $text);\n    return \"\";\n}", "    return 1 if $text eq\
    \ $text =~ tr/[A-Za-z]/;\n    my $reverse = $text =~ tr/[A-Za-z]/;\n    return\
    \ 1 unless length $text == length $reverse;\n    for (my $i = 0; $i <= length($text)/2;\
    \ $i++)\n    {\n        if ($reverse[$i] ne $text[$i])\n        {\n          \
    \  return 0;\n        }\n    }\n    return 1;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\n<code>\nuse strict;\nuse warnings;\nuse feature qw(say);", '    my($length);',
  "    return $text eq reverse $text;\n}", "    $text =~ s/[^a-z]//g;\n    $text =~\
    \ tr/a-zA-Z//cd;\n    $text eq $text ? 1 : 0;\n}", "    return (length($text)\
    \ <> 1 ? 1 : length($text) == length($text =~ tr/a-z//cd)) ? $text : \"\";\n}",
  '    my $len = length($text);', "    return 1 if $text eq reverse($text);\n    return\
    \ \"\";\n}", "    return 1 if ($text eq reverse($text));\n    return \"\";\n}",
  "    my $result = 0;\n    my @chars = split(//, $text);\n    my $reverse_length\
    \ = @chars;\n    for my $index ($reverse 0.. $reverse_length-1) {\n        next\
    \ if $chars[$index] == $chars[$index + 1];\n        $result++;\n    }\n    return\
    \ $result ? '' : 1;\n}\n</code>\n<|/ a tags=reverse,perl,string dscore=4 |>\n\
    <| c |>\n`split` is probably a bad choice here (though it probably won't matter\
    \ here). It will make a copy of the array before it splits it, which is a waste\
    \ of time and space when you can just iterate over the array and compare each\
    \ character. `reverse 'abc'` is more efficient.\n<|/ c |>\n<| c |>\nYou are right.\
    \ My solution was to match the OP's original approach, i.e. using regular expressions,\
    \ while yours is more straightforward and efficient indeed.\n<|/ c |>\n<| c |>\n\
    `split` will make a copy (unless you specify that it's an empty string). But you\
    \ are right that it's more efficient to use `reverse`. Thanks for the tip.\n<|/\
    \ c |>\n<| c |>\n`split` will make a copy unless you specify that it is an empty\
    \ string.\n<|/ c |>\n<| c |>\nYes, but it will make a copy of the array. `'abc'`\
    \ contains 4 characters, and `split` will make a copy of that string. `reverse`\
    \ will make a copy of an array. And `split` is probably more efficient in this\
    \ case than `reverse`.\n<|/ c |>\n<| a tags=reverse,perl,string dscore=3 |>\n\
    If you're looking for something that runs very quickly and doesn't use more memory\
    \ than what it needs to store the reversed string then you should just use the\
    \ following subroutine that uses no memory at all and just returns the reversed\
    \ string.\n<code>", "    if($text =~ /^\\s*$/) {\n        return 1;\n    }\n \
    \   my $len = length($text);\n    if($len == 0 || $len == 1) {\n        return\
    \ 0;\n    }\n    my $i = 0;\n    my $j = $len - 1;\n    while(1) {\n        if($text[$i]\
    \ ne $text[$j]) {\n            return 0;\n        }\n        $i++;\n        $j--;\n\
    \        if($j == 0) {\n            return 1;\n        }\n    }\n}", "    return\
    \ 1 if $text eq reverse $text;\n    return '';\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nIf performance is a concern, this version will run much slower and consume\
    \ more memory than the accepted answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "    $text =~ tr/A-Za-z//cd;\n    $text eq reverse $text ? $text : \"\";\n}", " \
    \   my $len = length($text);\n    for (my $i = 0; $i < $len; $i++) {\n\tmy $tmp\
    \ = substr($text, $i, 1);\n\tif ($tmp ne substr($text, -$i, 1)) {\n\t    return\
    \ \"\";\n\t}\n    }\n    return 1;\n}", "    my @chars = split(//, $text);\n \
    \   my $i = 0;\n    my $last = 0;\n    for (@chars) {\n        my $c = ($i + $last)\
    \ % scalar(@chars);\n        if ($chars[$c] != $chars[$i + 1]) {\n           \
    \ return \"\";\n        }\n        $last = $i;\n        $i = $c+1;\n    }\n  \
    \  return 1;\n}", "    return 1 if ($text eq reverse($text));\n    return \"\"\
    ;\n}", "    # if the text length is less than 2 then return 1 or 0\n    if (length($text)\
    \ < 2) {\n        return 1;\n    }\n    \n    $text =~ tr/a-zA-Z//cd;\n    $text\
    \ =~ reverse $text;\n    \n    # if the text is a palindrome then return 1 or\
    \ 0\n    return ($text eq $text) ? 1 : 0;\n}", "    $text =~ s/^\\s+//;\n    $text\
    \ =~ s/\\s+$//;\n    $text =~ tr/aA/ zZ/;\n    return (index($text,$text[0]) ==\
    \ 0);\n}", "    # Find a reverse string using the reverse function\n    $text\
    \ =~ s/(\\w)//g;\n    my $reverse = reverse $text;\n    # Compare two strings\
    \ using the eq function\n    return ($text eq $reverse) ? 1 : 0;\n}", "    $text\
    \ =~ tr/a-z/A-Z/;\n    my $rev = $text =~ tr/A-Z/a-z/;\n    return $rev == $text;\n\
    }", "    return substr($text,0,length($text)) == substr(reverse($text),0,length($text));\n\
    }", "    $text =~ tr/A-Za-z//cd;\n    return 1 if ($text eq $text);\n    return\
    \ \"\" if ($text =~ m/^.*(.)[^a-z]*$/);\n    return \"\";\n}", "    if ($text\
    \ =~ /^.?([a-z])?$/ix) {\n        $text =~ s/^.//;\n        $text =~ s/$//;\n\
    \        return ($text eq $text);\n    }\n    $text =~ s/^.//;\n    $text =~ s/$//;\n\
    \    return ($text eq $text);\n}", "    $text =~ tr/a-z/A-Z/;\n    $text =~ tr/A-Za-z/A-ZA-Z/;\n\
    \    $text =~ s/(.*)/$1/ if $text !~ /^$/;\n    $text eq $text ? 1 : 0;\n}", " \
    \   $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    $text =~ tr/a-z/A-Z/;\n\
    \    $text =~ s/^([^a-z]*\\z)/$1|/;\n    $text =~ s/\\z/\\|/;\n    $text =~ s/|([^|]*)$/$1|/;\n\
    \    $text =~ s/\\|([^|]*)\\z/$1/;\n    my @tokens = split('\\|', $text);\n  \
    \  for (my $i = 0; $i < scalar(@tokens); $i++) {\n        my $l = length($tokens[$i]);\n\
    \        if ($l != $l - 1) {\n            return 1;\n        }\n    }\n    return\
    \ \"\";\n}", "    if(length($text) < 2) {\n        return 1;\n    }", "    return\
    \ 1 if ($text eq reverse $text);\n    return 0;\n}\n</code>\n<|/ a |>\n<| a tags=regex,perl,string\
    \ |>\nPerl has a function called reverse that reverses a string. \n<code>\nuse\
    \ strict;\nuse warnings;", "    \n    my $reverse = reverse $text;\n    \n   \
    \ if ($reverse eq $text) {\n       return 1;\n    }\n    \n    return \"\";\n}",
  "    my $length = 0;\n    $text =~ tr/A-Za-z//cd;\n    my $reversed_text = reverse($text);\n\
    \    return $reversed_text eq $text ? 1 : 0;\n}", "    chomp($text);\n    $text\
    \ =~ s/\\A\\s+|\\s+\\z//g;\n    $text =~ tr/A-Z/a-z/;\n    $text =~ tr/a-z/A-Z/;\n\
    \    return $text eq $text =~ m/^[a-z]*$/i;\n}", "    return $text eq reverse\
    \ $text;\n}", "    return 1 if ($text eq '');\n    my @chars = split(//, $text);\n\
    \    my $is_palindrome = 0;\n    for (my $i = 0; $i < scalar @chars-1; $i++) {\n\
    \        if ($chars[$i] ne $chars[$i+1]) {\n            $is_palindrome = 1;\n\
    \            last;\n        }\n    }\n    return $is_palindrome ? $text : '';\n\
    }\n</code>\n<|/ a tags=perl,string-comparison |>\n<| a dscore=0 |>\nHere's one\
    \ way to do it:\n<code>\nuse strict;\nuse warnings;", "    my $len = length($text);\n\
    \    if ($len eq 0) {\n        return 1;\n    }\n    my $left = 0;\n    my $right\
    \ = $len-1;\n    while ($left < $right) {\n        my $tmp = $text[$left];\n \
    \       $text[$left] = $text[$right];\n        $text[$right] = $tmp;\n       \
    \ $left++;\n        $right--;\n    }\n    my $ans = 1;\n    my $i = 0;\n    while\
    \ ($i < $len) {\n        if ($text[$i] ne $text[$len-$i]) {\n            $ans\
    \ = 0;\n        }\n        $i++;\n    }\n    return $ans;\n}", "    my $text_length\
    \ = length($text);\n    my $i = 0;\n    my $is_palindrome = 1;", "    my $start\
    \ = 0;\n    $start++ while $text =~ /^\\W?$start\\W/s;\n    my $last = $start\
    \ + $text =~ /\\W+$start\\W/s;\n    $text =~ s/^($start)//s;\n    my $is_palindrome\
    \ = ($text eq $text);\n    if ($is_palindrome) {\n        $text =~ s/^($last)\\\
    W/$1/s;\n    } else {\n        $text =~ s/^($start)\\W/$1/s;\n    }\n    $text\
    \ =~ s/\\W+$//s;\n    return $is_palindrome;\n}", "    if (defined $text && $text\
    \ =~ /^[\\x00-\\xFF]*$/ && length($text) == length($text)/2) {\n        return\
    \ 1;\n    }\n    return '';\n}", "    $text =~ tr/a-z/A-Z/;\n    $text =~ tr/A-Z/a-z/;\n\
    \    if ($text eq $text == reverse $text) {\n        return 1;\n    }\n    return\
    \ \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe second method will give you\
    \ a false negative on \"a\" because it will fail to remove the characters in order.\n\
    <|/ c |>\n<| c |>\nyeah thanks for pointing out that! I updated my answer to fix\
    \ it.\n<|/ c |>\n<| c |>\nThe first method will also fail to find the string `abba`.\n\
    <|/ c |>\n<| c |>\nI tested it with all the possible cases and it works correctly.\
    \ It doesn't matter whether the characters are in order or not.\n<|/ c |>\n<|\
    \ c |>\nIt will also give a false positive for `abba`.\n<|/ c |>\n<| a |>\nOne\
    \ liner:\n<code>\nperl -le 'print for reverse grep { /^\\w/ } split //;' < filename\n\
    </code>\n<|/ a dscore=0 tags=perl |>\n<| a tags=perl |>\nI find this a more readable\
    \ solution, since it avoids the need to iterate through the string twice.\n<code>",
  "    $text =~ tr/a-z/A-Z/;\n    $text =~ tr/A-Z/a-z/;\n    $text eq $text ? 1 :\
    \ \"\"\n}", "    if (scalar(@$text) > 2) {\n\t$text =~ s/^\\s+|\\s+$//g;\n   \
    \ }\n    my $result = scalar ( $text =~ /(?<!\\A)\\Q$text\\E(?!\\z)/ );\n    return\
    \ $result;\n}", "    if(length($text) != length($text)/2) {\n        $_ = 1;\n\
    \    }\n    if ($text eq reverse $text) {\n        return 1;\n    }\n    return\
    \ \"\";\n}", '    my($left, $right) = (0, 0);', "    if ($text =~ /^\\Q$text\\\
    E$/) {\n        $text =~ s/(.)\\Q$text\\E(?=.*\\Q$text\\E)/$1/;\n        $text\
    \ eq $text && \"1\";\n    }\n    return \"\";\n}", "    my $reverse = reverse\
    \ $text;\n    return 1 == length($reverse) && $text eq $reverse;\n}", '    return
    length($text) if (length($text) == 0);', "    if (length($text) == 0) {\n    \
    \    return 1;\n    }\n    my $s = $text;\n    my $len = length($text);\n    my\
    \ @chars = ();\n    for (my $i = 0; $i <= $len; $i++) {\n        push(@chars,\
    \ substr($s, $i, 1));\n    }\n    if (@chars == $chars[@chars - 1]) {\n      \
    \  return 1;\n    }\n    return 0;\n}", "    if(length($text)==0){\n        return\
    \ 1;\n    }\n    my $length = length($text);\n    my $start = 1;\n    my $end\
    \ = $length;\n    while ($start <= $end) {\n        if ($text eq substr($text,\
    \ $start, $end - $start)) {\n            return 1;\n        }\n        $start++;\n\
    \    }\n    return '';\n}", "    my $len = $#text + 1;\n    my $flag = 0;\n  \
    \  my $i = 0;", "    return unless $text && length $text == length;\n    my $len\
    \ = length($text);\n    return 1 if $text eq reverse $text;\n    return \"\";\n\
    }", "    return '' unless defined $text;\n    return $text eq reverse $text;\n\
    }", "    if(length($text) < 2) {\n        return 1;\n    }\n    my $first_char\
    \ = substr($text, 0, 1);\n    my $last_char = substr($text, -1);\n    for(my $i\
    \ = 0; $i < length($text)/2; ++$i) {\n        if($first_char ne substr($text,\
    \ $i, 1)) {\n            return \"\";\n        }\n        if($last_char ne substr($text,\
    \ $i-1, 1)) {\n            return \"\";\n        }\n    }\n    return 1;\n}",
  "    my ($length);\n    # Remove all non letter and punctuation chars\n    $text\
    \ =~ s/[^a-zA-Z0-9_]/_/g;", "    $text =~ tr/a-z/A-Z/;\n    if($text eq reverse\
    \ $text) {\n        return 1;\n    } else {\n        return \"\";\n    }\n}",
  "    if (defined $text && length($text) > 0){\n        $text =~ s/^\\s+|\\s+$//g;\n\
    \        if ($text eq $text[-1]){\n            return 1;\n        }\n    }\n \
    \   return \"\";\n}", "    return 1 if ($text eq lc($text));\n    for ($text,\
    \ $revtext) =\n        ($text, reverse(substr($text, 0, length($text))))\n   \
    \ {\n        return 1 if ($text ne $revtext);\n    }\n    return \"\";\n}", " \
    \   $text =~ tr/a-zA-Z0-9//cd;\n    my $reversed_text = $text;\n    $reversed_text\
    \ =~ tr/a-zA-Z0-9//cd;\n    return 1 if ($text eq $reversed_text);\n    \"\"\n\
    }", "    my $result = 0;\n    my $tmp;\n    my $start = 0;\n    my $stop = $#{$text}\
    \ - 1;\n    $result = 1;\n    while ($start < $stop) {\n        $tmp = $text->[$start];\n\
    \        if ($tmp ne $text->[$stop]) {\n            $result = \"\";\n        }\n\
    \        $start++;\n        $stop--;\n    }\n    return $result;\n}", "    my($len,\
    \ $rev_text);\n    if ($text !~ /^[a-zA-Z]+$/) {\n        die \"Bad input: $text\"\
    ;\n    }\n    $rev_text = reverse $text;\n    $len = $#{$text} - 1;\n    die \"\
    Too short string!\" if $len < 0;\n    return 0 if $text eq $rev_text;\n    $rev_text\
    \ =~ tr/a-zA-Z//d;\n    return 1 if $text eq $rev_text;\n    die \"Not a palindrome!\"\
    ;\n}", "    return '' unless $text;", "    return 1 if $text eq $text / 2;\n \
    \   return $text if !length($text) || $text eq reverse($text);\n    return;\n}",
  "    my $len = length($text);\n    my $reverse = 0;", "    if(length($text) == 0){\n\
    \        1;\n    }\n    my $len = length($text);\n    my $rev = reverse $text;\n\
    \    return 0 if $text eq $rev;\n    return 1;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThe original question asked for a solution that \"does not use\
    \ any builtin libraries\".  Here's one that doesn't, though it does use perl's\
    \ core libraries and doesn't use any built-ins.  It also doesn't use any regexes.\n\
    <code>", "    my $length = length($text);\n    my $i = 0;\n    my $flag = 0;\n\
    \    my $is_palindrome = 0;", "    return $text eq reverse $text ? 1 : 0;\n}",
  "    $text =~ tr/a-zA-Z0-9//d;\n    $text =~ tr/a-zA-Z0-9//d;\n    $text =~ tr/a-zA-Z0-9//d;\n\
    \    if (length($text) == (length($text)/2)) {\n        return 1;\n    }\n   \
    \ elsif (length($text) == 0) {\n        return 1;\n    }\n    else {\n       \
    \ return \"\";\n    }\n}", "    my $i;\n    my $l = length $text;\n    for ($i\
    \ = $l - 1; $i >= 0; $i--) {\n        if ($text eq substr(reverse $text, $i, 1))\
    \ {\n            return 1;\n        }\n    }\n    return \"\";\n}\n</code>\n<|/\
    \ a tags=perl,string |>\n<| c |>\nThis is also the easiest way I have found to\
    \ solve it for me, even though I haven't seen it used in any books online.  I'm\
    \ wondering if there is a better way to do this\n<|/ c |>\n<| c |>\nThanks. I\
    \ added one possible improvement - `return 0 if length($text) <=1;` at the end\
    \ of `is_palindrome`.\n<|/ c |>\n<| a tags=perl,string |>\n<code>\nuse strict;",
  "    return 1 if length $text == 0 or $text eq reverse $text;\n    return \"\";\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe Perl idiom `'a' eq reverse 'a'` fails\
    \ if the string contains characters that are not letters, such as non-printable\
    \ characters. `use bytes` fixes that. `use charnames` also fixes that.\n<|/ c\
    \ |>\n<| c |>\nThe `'a' eq reverse 'a'` idiom also fails if your string contains\
    \ Unicode characters, such as Chinese, Cyrillic, Japanese, and so on.  `use bytes`\
    \ fixes that.\n<|/ c |>\n<| a dscore=5 tags=perl,string,palindrome |>\nI know\
    \ this is a very old post, but I thought I would post my solution.\nI used recursion\
    \ to solve this problem. There are some flaws with this solution, but the main\
    \ reason that this is inefficient is that every substring you create is compared\
    \ with every other substring. With an input string of length n, it takes n^2 comparisons\
    \ to find out if it's a palindrome. I think the other flaws would be the fact\
    \ that it doesn't handle non-alphabetic characters, or non-english characters\
    \ like chinese characters. This code only works for english letters.\n<code>",
  "    $text =~ tr/a-zA-Z0-9//cd;\n    $text =~ tr/-_//cd;\n    $text =~ tr/-/@/;\n\
    \    return $text eq $text ? 1 : 0;\n}", "    my $length = length($text);\n  \
    \  return 1 if $length == 0;\n    return 1 if $text eq reverse $text;\n    return\
    \ \"\";\n}\n</code>\n<|/ a dscore=1 tags=algorithm,ruby,python |>\n<| c |>\nThis\
    \ is not correct. `reverse` does not return anything if the string length already\
    \ is odd. Also, I don't think this code returns the correct answer for `\"z\"\
    ` and `\"aba\"`. Try it.\n<|/ c |>\n<| c |>\n, `reverse` will return the reversed\
    \ string if the string is odd.\n<|/ c |>\n<| c |>\n: Thanks for pointing out my\
    \ mistakes, I have corrected the code.\n<|/ c |>\n<| c |>\n`return 1 if $length\
    \ == 0;` should be `return 1 if $length == 1;`\n<|/ c |>\n<| c |>\n, `return 1`\
    \ will be executed if the string length is `1` but `return \"\" ` will be executed\
    \ if the string length is `0` so return `\"\"` is correct.\n<|/ c |>\n<| a dscore=1\
    \ |>\nRuby Code :\n<code>\ndef is_palindrome?(str)\n  return str.length < 2 ?\
    \ true : str == str.chars.reverse.join\nend", "    if(length($text) <= 1) {\n\
    \        return 0;\n    }", "    my $len = length($text);\n    return if ($len\
    \ == 0);\n    my $revrev = \"\";\n    for (my $i = 0; $i <= $len / 2; $i++) {\n\
    \        $revrev = substr($text, $len - $i * 2, 2) . substr($revrev, 0, 1) . $revrev;\n\
    \    }\n    return 1 == $revrev && $text eq reverse($revrev);\n}", "    if ($text\
    \ =~ /[a-zA-Z]+/) {\n        my($revtext) = $text =~ /([a-zA-Z]+)/;\n        return\
    \ 0 if ($text eq $revtext);\n        return 0 if ($revtext =~ /[a-zA-Z]+/);\n\
    \        return 0 if ($revtext eq \"\");\n        return 0 if ($revtext =~ /^[a-zA-Z]+$/);\n\
    \        return 0 if ($revtext =~ /^[a-zA-Z]+$/);\n    }\n    return 1;\n}", " \
    \   $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n\
    \    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text\
    \ =~ tr/A-Za-z/A-Za-z_/;\n    $text =~ tr/A-Za-z/A-Za-z_/;\n    $text ", "   \
    \ if ( $text =~ /^[A-Za-z]+$/ ) {\n        $text =~ tr/A-Za-z//d;\n        return\
    \ $text eq $text ? 1 : \"\";\n    }\n    return 1;\n}\n</code>\n<|/ a tags=perl,regex\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\nuse strict;\nuse warnings;\nuse feature\
    \ 'say';", "    return 1 if ($text eq '');\n    my $start = length $text;\n  \
    \  my $len = 0;\n    for (my $i = $start; $i < $start; $i++) {\n        $len =\
    \ $len - 1 if ($text[$i] eq $text[$i-1]);\n    }\n    $len += 1;\n    $text =~\
    \ tr/A-Za-z//cd;\n    return \"\" if ($text ne $text);\n    return 1 if (length($text)\
    \ eq $len);\n    return 0;\n}", "    if ($text eq \"\") {\n        return 1;\n\
    \    }\n    my $left = $text;\n    my $right = $text;\n    my $palindrome = 1;\n\
    \    while (length($left)) {\n        $right = substr($left,-1,1);\n        my\
    \ $temp = substr($right,-1,1);\n        $palindrome = $palindrome && ($temp eq\
    \ $left);\n        $left = $right;\n    }\n    return $palindrome ? 1 : 0;\n}",
  "    my($reverse) = 0;\n    my @chars;\n    my @char;\n    for (my $i=0; $i<length($text);\
    \ $i++) {\n        push(@chars, substr($text, $i, 1));\n    }\n    for (my $i=0;\
    \ $i<length(@chars); $i++) {\n        @char = reverse(@chars[$i]);\n        push(@chars,\
    \ @char);\n    }\n    my $is_palindrome = 1;\n    for (my $i=0; $i<length(@chars);\
    \ $i++) {\n        if ($chars[$i] ne $chars[$i-1]) {\n            $is_palindrome\
    \ = 0;\n        }\n    }\n    return $is_palindrome;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a |>\n<code>\nfunction is_palindrome($str)\n{\n    $str=~ s/\\D//g;",
  "    if (length($text) <= 1) { return 1 };\n    my $i = 0;\n    while ($i < length($text))\
    \ {\n        if ($text eq substr($text, $i, $i)) { \n            $i++;\n     \
    \   }\n        else {\n            $text = substr($text, 0, $i);\n           \
    \ return 0;\n        }\n    }\n    return 1;\n}", "    return if $text eq \"\"\
    ;\n    # Make it a regexp since we'll be using it to test if the string\n    #\
    \ is a palindrome.\n    $text =~ /^(\\W*)$/;\n    # Remove non-word chars.\n \
    \   $text =~ s/\\W//g;\n    # Empty string is a palindrome.\n    return 1 if $text\
    \ eq \"\";", "    $text =~ /^(.)\\1\\1$/;\n    return $1 eq $text;\n}\n</code>\n\
    It works with strings containing only a-z, A-Z, 0-9 and space characters, but\
    \ will fail if you want to test other kinds of character sequences.\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\n<code>\nmy $is_palindrome = sub {\n  my $str = shift;\n\
    \  $str =~ s/./\\&$str/;\n  $str =~ /^\\&\\&$/;\n  $str =~ /^($str)/;\n};\n</code>\n\
    <|/ a tags=perl,string,algorithm |>\n<| c |>\nThe Perl regex engine optimizes\
    \ them into one big regex. No need to do the substitution twice!\n<|/ c |>\n<|\
    \ c |>\nI think you mean `\\&$str`.\n<|/ c |>\n<| c |>\n, thanks. I've edited\
    \ the answer accordingly.\n<|/ c |>\n<| a tags=perl,string,algorithm dscore=3\
    \ |>\nHere's a pretty short one:\n<code>", "    my $len = length($text);\n   \
    \ my $flag = 0;\n    $flag = 1 if ($text eq reverse $text);\n    return $flag;\n\
    }", "    return $text eq $text[-@$text] ?\n        \"1\" : \"\";\n}", "    my($len)\
    \ = length($text);\n    my($flag) = 1;", "    my $reversed_text = \"\";\n    $text\
    \ =~ s/(.)\\1*$/$1/;\n    return ($text eq $reversed_text);\n}", "    return ''\
    \ unless $text;\n    my $length = $text =~ tr/a-z/A-Z/;\n    return 0 if ($length\
    \ < 1);\n    my $palindrome;\n    my $start = 0;\n    my $end = length - 1;\n\
    \    while ($start < $end) {\n        if ($text eq substr($text, $start, $end\
    \ - $start + 1)) {\n            $palindrome++;\n        }\n        $start++;\n\
    \        $end--;\n    }\n    return $palindrome;\n}", "    return 1 if length($text)\
    \ % 2 == 0;\n    my $first_half = substr($text, 0, length($text)/2);\n    my $second_half\
    \ = substr($text, length($text)/2, length($text));\n    return 1 if $first_half\
    \ eq $second_half;\n    return \"\";\n}", '    my $reversed_text = reverse $text;',
  "    if ($text eq '') {\n        return 1;\n    }\n    my($i, $j, $len);\n    for\
    \ ($i = 0, $len = $#{$text}; $i < $len; $i++) {\n        $j = $len-1;\n      \
    \  if ($text[$i] eq $text[$j]) {\n            $j--;\n        }\n        if ($text[$i]\
    \ eq '') {\n            my $lt = $j;\n            while ($text[$lt] ne \"\") {\n\
    \                $lt--;\n            }\n            substr($text, $j+1, 0, \"\"\
    );\n        }\n    }\n    return $text eq reverse $text;\n}", "    $text =~ tr/a-z/A-Z/;\n\
    \    my $reversed = reverse $text;\n    return 0 if ($text eq $reversed);\n  \
    \  return 1;\n}", "    chomp $text;\n    my $len = length($text);\n    for my\
    \ $i (0.. $len/2) {\n        return \"\" unless $text[$i] eq $text[$len-1-i];\n\
    \    }\n    return 1;\n}", "    return $text eq reverse $text ? 1 : 0;\n}", '    return
    1 if ($text eq "" || $text eq " ");', "    my($char);\n    my($reversed_char);\n\
    \    my($flag);\n    \n    foreach $char (split(//,$text)) {\n        # Find chars\
    \ in the same position in reverse\n        if($char eq $reversed_char) {\n   \
    \         $flag++;\n        }\n    }\n    \n    # Return true if flag is same\
    \ as the string length\n    return $flag == length($text);\n}", "    return $text\
    \ eq reverse $text ? 1 : 0;\n}\n</code>\n<|/ a tags=perl,function dscore=1 |>\n\
    <| a dscore=1 |>\nAs you mentioned in your question, you can check the following\
    \ solution:\n<code>", "    my $rev_text = reverse $text;\n    return 0 if $text\
    \ eq $rev_text;\n    return 1;\n}", "    return $text if length $text < 2;\n \
    \   return 1 if $text eq reverse($text);\n    return \"\";\n}", "    my $len =\
    \ length($text);\n    my $half = $len / 2;\n    for my $i (0 .. $half) {\n   \
    \     if ($text eq substr $text, -$i, $i) {\n            return 1;\n        }\n\
    \    }\n    return \"\";\n}\n</code>\n<|/ a tags=perl,palindrome |>\n<| a dscore=0\
    \ |>\nHere's a very simple and straightforward approach that works no matter how\
    \ long the string is:\n<code>", "    return '' unless length($text);\n    $text\
    \ =~ s/^\\s+//; # remove whitespace at start of string\n    $text =~ s/\\s+$//;\
    \ # remove whitespace at end of string\n    my $reverse = $text;\n    $reverse\
    \ =~ tr/[a-z]/[A-Z]/;\n    return '' if $text eq $reverse;\n    return 1;\n}",
  "    chomp($text);\n    return $text eq reverse $text;\n}", "    my $is_palindrome\
    \ = 1;\n    # First and last character must be the same\n    my @characters =\
    \ split(\"\", lc(\"$text\"));\n    my $first_character = $characters[0];\n   \
    \ my $last_character = $characters[-1];\n    return $is_palindrome if $first_character\
    \ eq $last_character;", "    my $text = $text =~ tr/a-zA-Z//cd;\n    $text =~\
    \ s/^..$//;\n    $text eq $text ? 1 : '';\n}", "    return 0 unless defined $text;\n\
    \    return $text =~ tr/[A-Z]/a-z/;\n}", "    if(length($text) <> 0 ){\n     \
    \   $text =~ /^(.)\\1\\1$/;\n    }\n    $text eq reverse($text);\n}", "    return\
    \ 1 if $text eq reverse($text);\n    return \"\";\n}", "    my $rev_text = reverse($text);\n\
    \    return $text eq $rev_text ? 1 : 0;\n}", "    my $reverse = \"\";\n    $text\
    \ =~ tr/a-zA-Z//d;\n    my $i = $#text - 1;\n    while($i >= 0){\n        $reverse\
    \ = $text.$reverse if $text[$i] != $text[$i+1];\n        $i--;\n    }\n    return\
    \ $reverse;\n}", "    $text =~ tr/a-zA-Z//cd;\n    my $revtext = reverse($text);\n\
    \    return 1 if $revtext eq $text;\n    return '';\n}", "    my $length = $#{$text}\
    \ - 1;\n    return $text =~ /^(?:(.)(?!\\1$))*$/ ? 1 : 0;\n}\n</code>\n<|/ a tags=perl,string,palindrome\
    \ |>\n<| c |>\nThe `grep` call should be `grep { is_palindrome($_) }`\n<|/ c |>\n\
    <| c |>\n`is_palindrome(\"abcba\")` returns \"1\" instead of \"0\".  That may\
    \ or may not be what the OP wants, but it's worth mentioning.\n<|/ c |>\n<| c\
    \ |>\n: you're right.  I didn't know that about the `grep` function.  Thanks.\n\
    <|/ c |>\n<| c |>\n, You might want to add `return 0 if !defined $text;` as the\
    \ first line of is_palindrome. Otherwise it will return \"1\" for empty strings.\n\
    <|/ c |>\n<| a dscore=5 |>\nA simple regex approach:\n<code>\nmy $string = \"\
    Hello World\";"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
