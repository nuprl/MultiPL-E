name: HumanEval_34_unique
language: pl
prompt: "# Return sorted unique elements in an array\n# >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n\
  \        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9,\
  \ 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @r;\n    map { push @r, $_ } (sort {$a <=> $b} keys %$l);\n\
    \    return @r;\n}", '    my %seen;', "    my(@d);\n    for (@$l) {\n        if\
    \ (not exists $d[$_]) {\n            push @d, $_;\n        }\n    }\n    return\
    \ sort @d;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI realize the original question\
    \ was about arrays, not hash's, but this code snippet may still be useful for\
    \ someone looking for a hash-based solution.  It also has the advantage that it's\
    \ very fast; it makes use of a much faster hash function than the uniq subroutine\
    \ in the List::Util module. =)\n<|/ c |>\n<| c |>\nActually, List::Util::uniq\
    \ uses List::MoreUtils::uniq for arrays, and it's much faster than the code above.\n\
    <|/ c |>\n<| a dscore=1 |>\nJust use the uniq perl function from List::MoreUtils.\n\
    <code>\nuse List::MoreUtils qw(uniq);\nmy = qw(a a a b c c a b c d e f a e f);\n\
    my = uniq(@arr);\n</code>\n<|/ a tags=arrays,perl |>\n<| a tags=arrays,perl |>\n\
    Try this:\n<code>", "    my $l = scalar(@$l);\n    my @t = ();\n    my $h = {};\n\
    \    for($i = 0; $i < $l; $i++) {\n        my $v = $l->[$i];\n        $h->{$v}++;\n\
    \        $t[$i] .= \"$v\" unless $h->{$v};\n    }\n    return @t;\n}", "    $l\
    \ =~ s/^\\s+//g;\n    $l =~ s/\\s+$//g;\n    $l =~ s/^\\s+//g;\n    $l =~ s/\\\
    s+$//g;\n    my(@u) = grep { !$seen{$_}++ } @_;\n    return @u;\n}", '    my(@m);',
  "    my(@s);\n    my $first = 1;\n    my $last = @$l - 1;\n    while ($first <=\
    \ $last) {\n        my $middle = $first + int(($last - $first)/2);\n        if\
    \ ($l->[$middle] == $l->[$first]) {\n            $s[$middle] = $l->[$first];\n\
    \            $first = $middle + 1;\n        } else {\n            if ($l->[$middle]\
    \ >= $l->[$last]) {\n                $s[$middle] = $l->[$last];\n            \
    \    $last = $middle - 1;\n            } else {\n                $s[$middle] =\
    \ $l->[$middle];\n            }\n        }\n    }\n    return @s;\n}", "    my\
    \ $sorted = sort {$a <=> $b};\n    return sort {!$a++} keys %$sorted;\n}", '    my
    @l;', "    my @u = ();\n    my $u = -1;\n    while(@$l) {\n        my $e = $l->[0];\n\
    \        my $u = ($e == $u) ? 0 : ++$u;\n        push(@u, $e);\n        shift\
    \ @$l;\n    }\n    return @u;\n}", "    $l = scalar(@$l) unless ref($l);\n   \
    \ @$l != sort { $a <=> $b } map { $_->[0] } grep(!$_->[1],\n\tmap { [$_, $l->[0]]\
    \ } keys %$l;\n}", "    my($r) = @$l;\n    my %seen;\n    $seen{$_} = 1 while\
    \ @$r and !$seen{$r->[0]}++;\n    return sort keys %seen;\n}", "    my %seen;\n\
    \    my @res;", "    my($h);\n    my($key, $value);\n    \n    if (@_ == 1) {\n\
    \        foreach $key (keys(%{$l->{_a}}))\n        {\n            next unless\
    \ defined $l->{_a}{$key};\n            $h->{$key} = $l->{_a}{$key};\n        }\n\
    \    }\n    else {\n        foreach $key (keys(%{$l->{_a}}))\n        {\n    \
    \        $value = $l->{_a}{$key};\n            $h->{$key} = $value;\n        }\n\
    \    }", "    my $hash = map {$_ => 1} @$l;\n    my(@u) = grep !$hash->{$_}, @$l;\n\
    \    return @u;\n}", "    my @result;\n    my $uniq;\n    my $uniq_seen;", " \
    \   my @seen;\n    $seen[-1]++;\n    $seen[$_]++ foreach grep !$seen[$_],@$l;\n\
    \    return grep !$seen[$_],@$l;\n}", "    my(@u);\n    foreach my $item (@$l)\
    \ {\n        push @u, grep !$seen{$_}++, @$l;\n    }\n    return @u;\n}", "  \
    \  my @u;\n    my $first = 1;\n    foreach my $value (@$l) {\n        if (!$first\
    \ && $value eq $first) {\n            next;\n        }\n        $first = 0;\n\
    \        push (@u, $value);\n    }\n    return @u;\n}", '    my %seen;', "   \
    \ my(@a) = sort @_;\n    my %seen;\n    @a = grep !$seen{$_}++, @a;\n    return\
    \ @a;\n}", "    my(@r) = ( );\n    while ( @$l ) {\n        my($v) = shift @$l;\n\
    \        my($c) = 0;\n        foreach $r (@r) {\n            next unless $v ==\
    \ $r;\n            $c++;\n        }\n        push @r, $v;\n    }\n    return @r;\n\
    }", "    my $prev;\n    my @unique;\n    for (@$l) {\n        if ($prev ne $_)\
    \ {\n            push(@unique, $_);\n            $prev = $_;\n        }\n    }\n\
    \    return @unique;\n}", "    my $result = ();\n    push @$result, while $l->[$#l];\n\
    \    @$result = sort @_;\n    @$result;\n}", "    my %seen;\n    $seen{$_}++ for@$l;\n\
    \    sort keys %seen;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>", '    my
    @t = @$l;', "    my($cnt,$rev) = (0,0);\n    foreach $i (@$l) {\n        $rev\
    \ = $rev*3 + $i;\n        $cnt = $cnt*3 + ($rev == $cnt ? 0 : $rev);\n    }\n\
    \    $rev = 0;\n    foreach $i (@$l) {\n        $rev += $i*3 + $cnt++;\n    }\n\
    \    $rev/=3;\n    return @$l[0..($_=@$l).$rev];\n}", "    my @u;\n    for(my\
    \ $i = 0; $i < $#$l; $i++) {\n        my $v = $l->[$i];\n        for(my $j = 0;\
    \ $j < $#$l; $j++) {\n            next if($j == $i);\n            next if(($l->[$j])\
    \ cmp ($l->[$i]) eq 0);\n            push @u, $v;\n            last;\n       \
    \ }\n    }\n    return @u;\n}", "    my %seen;\n    $seen{$_}++ for @$l;\n   \
    \ return sort grep !$seen{$_}++, keys %seen;\n}", '    my $ua = ();', "    my\
    \ $tmp = [];\n    my $j = 0;\n    for(my $i = 0; $i < @$l; $i++) {\n        push(@$tmp,\
    \ $l->[$i]);\n        if(++$j == 1) {\n            push(@$l, @$tmp);\n       \
    \ }\n    }\n    return @$l;\n}", "    my $s = Sort::Sort::ascending(ref($l));\n\
    \    $s = sub {\n        $a->[0] <=> $b->[0]\n    }\n    unless defined $s;\n\
    \    $l->[$s]\n}", "    my @r;\n    my $i = 0;\n    \n    # Copy array if array\
    \ is passed\n    if (ref($l) eq 'ARRAY') {\n\tforeach my $e (@$l) {\n\t    next\
    \ unless $i++ < $#r;\n\t    $r[$i-1] = $e unless $e->is_num;\n\t}\n    }\n   \
    \ # Return array if scalar passed\n    else {\n\treturn @$l unless $l->is_num;\n\
    \    }\n    \n    return @r;\n}", "    my $ua = $l ? @$l : ();\n    foreach my\
    \ $u (@$ua) {\n        next if defined $u && !defined $u->[0] && $u->[0] ne ''\
    \ && $u->[0] =~ /^\\s+$/;\n        push @$u, @$l;\n    }\n    @$l = @$ua;\n}",
  '    my $h = { };', "    my %seen;\n    return grep(!exists $seen{$_}++,@$l);\n}",
  "    my %seen;\n    $seen{$_}++ for @$l;\n    return grep !$seen{$_}++, @$l;\n}",
  "    my @u;\n    grep { !$u{$_} } @$l;\n}", "    return sort(unique(sort($l)));\n\
    }", "    my %seen;\n    map { $seen{$_}++ } @$l;\n    grep { !$seen{$_}++ } @$l;\n\
    }", "    my $i = 0;\n    my @s = ();\n    while(@$l > 0) {\n        push @s, $l->[0]\n\
    \          if (++$i == @$l);\n        @$l = (@$l)[2..$#l];\n    }\n    return\
    \ @s;\n}", "    return sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n}", "  \
    \  my @l = @$l;\n    my @c = ();\n    foreach my $x (@l) {\n        push(@c, $x);\n\
    \    }\n    sort { $a <=> $b } @c;\n}", "    # remove all duplicates using hash\n\
    \    my %seen;\n    grep !$seen{$_}++, @$l;\n}", "    my $c = undef;\n    my @u;\n\
    \    while (@_) {\n\tmy $x = pop(@_);\n\tif ($c && $x != $c) {\n\t    push(@u,\
    \ $c);\n\t}\n\t$c = $x;\n    }\n    return @u;\n}", '    my(@unique);', "    $l\
    \ =~ m{(.*?)(?:\\z|)}igs;\n    $l =~ m{^(?:\\d+|[a-zA-Z]+)}igs;\n    return sort\
    \ {$a <=> $b} keys %{ $l };\n}", "    my $ua = { };\n    my($i, $j, $k);", '    my
    %unique;', "    my(@a, $x, $y, @b, @c, $v);\n    @a = sort {$b <=> $a};\n    $a[0]\
    \ = 0;\n    for ($i = 1;  $i < @a;  ++$i) {\n        $x = ($a[$i] <= $a[$i - 1])\
    \ ? $a[$i] : $a[$i - 1];\n        $y = $a[$i - 1];\n        last if $a[$i] - $x\
    \ < $a[$i - 2];\n        @b = ($x == $y) ? @a : $x;\n        @c = grep { $_ ne\
    \ $a[$i - 2] };\n        @a = grep { $_ ne $a[$i - 1] } @b;\n        $a[$i] =\
    \ @c;\n    }\n    return @a;\n}\n</code>\n(I haven't bothered to sort a copy of\
    \ the input array.)\n<|/ a dscore=1 |>\n<| c |>\nI tried to sort the array with\
    \ your code in my script but i get this error : Use of uninitialized value $i\
    \ in concatenation (.) or string at ..../script.pl line 129, <IN> line 15.\n<|/\
    \ c |>\n<| c |>\nI changed this line : $x = $a[$i] <= $a[$i - 1] ? $a[$i] : $a[$i\
    \ - 1]; and it worked but i get the error  Use of uninitialized value $i in concatenation\
    \ (.) or string at script.pl line 129, <IN> line 15.\n<|/ c |>\n<| c |>\nI see\
    \ now that i didn't sorted the array so i got this error Use of uninitialized\
    \ value $i in concatenation (.) or string at script.pl line 129, <IN> line 15.\n\
    <|/ c |>\n<| c |>\nI changed it like this : my(@a, $x, $y, @b, @c, $v); = sort\
    \ {$b <=> $a}; $a[0] = 0; for ($i = 1;  $i < @a;  ++$i) { = $a[$i] <= $a[$i -\
    \ 1] ? $a[$i] : $a[$i - 1]; last if $a[$i] - $x < $a[$i - 2]; = grep { $_ ne $a[$i\
    \ - 2] }; = grep { $_ ne $a[$i - 1] } @b; $a[$i] = @c; but i still get the same\
    \ error Use of uninitialized value $i in concatenation (.) or string at script.pl\
    \ line 129, <IN> line 15.\n<|/ c |>\n<| c |>\nI've added the sort code, I didn't\
    \ think to ", "    my($hash);\n    my($hash_cnt);\n    my(@uniq_hash);\n    my($i);\n\
    \    my($unique_found);\n    my($j);\n    my($hash_ref);\n    my($hash_ref_ref);\n\
    \    my(@hash_cnt);", "    my @ret;\n    my $prev = undef;\n    my %seen;\n  \
    \  foreach my $el (@$l) {\n        if (!defined $prev || $prev ne $el) {\n   \
    \         $seen{$el} = 1;\n            push(@ret, $el);\n            $prev = $el;\n\
    \        }\n    }\n    return @ret;\n}", "    $l =~ s/^\\s*\\@uninitialized$//\
    \ if $l =~ /^@uninitialized/;\n    my($first, $last, $first2, $last2, $j, $i);\n\
    \    while($l =~ m/@uninitialized/) {\n        s/^\\s+//;\n        s/\\s+\\@uninitialized\\\
    z//;\n        $first = $1;\n        s/^\\s*//;\n        $last = $1;\n        $first2\
    \ = $first;\n        $last2 = $last;\n        $l = $1;\n    }", "    my($i);\n\
    \    my @a;\n    my $j;\n    $j = 0;\n    for ($i = 0; $i < $#{$l}; $i++) {\n\
    \        $a[$j] = $l->[$i];\n        $j++;\n    } \n    return sort @a;\n}", " \
    \   my @r;\n    my %seen;\n    foreach my $elt (@$l) {\n        if (!defined $seen{$elt})\
    \ {\n            $seen{$elt} = 1;\n            push(@r, $elt);\n        }\n  \
    \  }\n    return @r;\n}", "    my @result = ();\n    my %seen = ();\n    foreach\
    \ (@$l) {\n        if (defined $seen{$_}) {\n            $seen{$_}++;\n      \
    \  } else {\n            push @result, $_;\n            $seen{$_} = 1;\n     \
    \   }\n    }\n    return @result;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c\
    \ |>\nThank you. This was helpful.\n<|/ c |>\n<| a tags=perl,arrays |>\nYou can\
    \ use the sort function like so:\n<code>\nmy = qw(1 2 4 3 1 5 6 2);\nmy = sort\
    \ {$a <=> $b};\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `$a` and\
    \ `$b` are scalars, not arrays, and so compare the elements of the array `@b`\
    \ one by one. I think you want `map $_->[0] <=> $_, map @$_, sort {@$b} `\n<|/\
    \ c |>\n<| a |>\nAs of Perl 5.20 we can use a hash slice:\n<code>\nuse v5.20;\n\
    my = qw(1 2 4 3 1 5 6 2);\nmy %unique_hash =;\nmy = sort { $unique_hash{$a} <=>\
    \ $unique_hash{$b} } keys %unique_hash;\n</code>\nIf you have the keys in another\
    \ array you can use this instead:\n<code>\nmy = qw(1 2 4 3 1 5 6 2);\nmy = qw(5\
    \ 3 2 1 4 6 9 0);\nmy %unique_hash =;\nmy = sort { $unique_hash{$_} <=> $unique_hash{$b}\
    \ } keys %unique_hash;\n</code>\nThis makes the code more readable, less error\
    \ prone and easier to maintain.\n<|/ a tags=perl,arrays dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nuse 5.010;\nmy = qw(1 2 4 3 1 5 6 2);\nmy $unique_hash = {};\nmy\
    \ $unique;\nwhile (@array) {\n   my $key = shift;\n   $unique_hash->{$key}++;\n\
    \   $unique ||= $key;\n}", "    my @h;\n    $l[0] = 0 unless ($l[0]);\n    @h\
    \ = @$l;\n    foreach (@h) {\n        my $x = $_;\n        my $j;\n        for\
    \ (my $i = $#h; $i >= 0; $i--) {\n            $h[$i] =~ s/^$x//;\n           \
    \ if ($h[$i] ne $x) {\n                $h[$i] = $x;\n            }\n        }\n\
    \    }\n    return @h;\n}", "    my @a = sort { $a <=> $b } @$l;\n    push @$l,\
    \ $a[@a];\n    delete $a[0];\n    return @a;\n}", "    my(@u) = ();\n    my($u,\
    \ $u2);\n    my(@u2) = ();\n    my($i, $j, $n1);\n    my($u3);\n    my($u4);\n\
    \    foreach $l (@$l) {\n\t$u = $l->[0];\n\tif (exists($u2)) {\n\t    $u2 = $u2->[0];\n\
    \t    if ($u2 ne $u) {\n\t\tif ($u2 eq $u3) {\n\t\t    push(@u, splice(@u2, 1));\n\
    \t\t    push(@u2, $u);\n\t\t} else {\n\t\t    push(@u2, $u);\n\t\t}\n\t    }\n\
    \t} else {\n\t    $u2 = $u3;\n\t    $u3 = $u;\n\t    push(@u2, $u);\n\t}\n   \
    \ }\n    $u3 = $u3;\n    push(@u, $u3);\n    foreach $u4 (@u) {\n\tpush(@u, $u4);\n\
    \    }\n    return wantarray ? @u : $u[0];\n}", "    my @ret = ();\n    for (my\
    \ $i = 0; $i < $#l; ++$i) {\n        $ret[$i] = $l[$i];\n    }\n    $#ret = $#l\
    \ if @ret < $#l;\n    return @ret;\n}", "    my $hash = {};\n    my $count = scalar\
    \ @$l;", "    my @seen;\n    for(@$l) {\n\tfor(my $i = 0; $i < @seen && $seen[$i]\
    \ <= $l[$i]; $i++) {\n\t    push @seen, $l[$i];\n\t}\n    }\n    return @seen;\n\
    }", "    my($hash) = Hash::Ordered->new;\n    \n    my @elements;\n    \n    for\
    \ my $e (@$l) {\n        push @elements, $e unless $hash->{$e};\n        $hash->{$e}++;\n\
    \    }\n    return @elements;\n}", "    my $u = ();\n    \n    foreach my $element\
    \ (@$l) {\n        if (!$u->{$element}) {\n            $u->{$element} = 1;\n \
    \           push(@$u, $element);\n        }\n    }\n    \n    return @$u;\n}",
  "    my %seen;\n    my $u;\n    my @u;\n    while($l->[0]) {\n        $u = $l->[0];\n\
    \        delete $seen{$u};\n        push @u, @{$l->[1]};\n    }\n    return @u;\n\
    }", "    my @sorted = sort { $a <=> $b } @_;\n    @sorted = grep { !$seen{$_}++\
    \ } @sorted;\n    return @sorted;\n}", "    my @a = ();\n    my $i;\n    foreach\
    \ my $item (@$l) {\n        if ($i && *$i{NAME} == $item->{NAME}) {\n        \
    \    push @a, $item;\n        }\n        elsif ($i) {\n            push @a, *$i;\n\
    \        }\n        else {\n            $i = {};\n            push @a, $i;\n \
    \       }\n        $i->{NAME} = $item->{NAME};\n    }\n    return @a;\n}", " \
    \   my $c = uniq(@$l);\n    @$l = grep !$c->[$_], 0..$#$c;\n    return wantarray\
    \ ? (@$l, $c) : @$l;\n}", "    my(@u) = (@{$l}) ? grep {!$h{$_}++} @{$l} : ();\n\
    \    wantarray ? @u : \\@u;\n}", "    my @u = ();\n    foreach my $x (@_) {\n\
    \        push @u, grep $_ ne $x, @$l;\n    }\n    return @u;\n}", "    sort {$a\
    \ <=> $b} uniq @$l;\n}", "    my @a;\n    for my $i (0..$#$l) {\n        push\
    \ @a, $l->[$i] unless $seen{$l->[$i]}++;\n    }\n    return @a;\n}", "    my $sorted\
    \ = sort { $a <=> $b } @$l;\n    my @result;\n    my $size = @$sorted;\n    my\
    \ $j = 0;\n    foreach my $i (0 .. $size - 1) {\n        next if $j == $i;\n \
    \       push @result, $sorted->[$j++];\n    }\n    return @result;\n}", "    my\
    \ @l = @$l;\n    my @u;\n    \n    my %seen;\n    $seen{$_} = 1 foreach (@l);\n\
    \    \n    $seen{$_} = 1 foreach grep (!exists $seen{$_} && defined $_, $seen);",
  "    return sort uniq($l);\n}", "    my @u;\n    foreach (@$l) {\n        if (!$seen[$_])\
    \ {\n            $seen[$_] = 1;\n            push @u, $_;\n        }\n    }\n\
    \    return @u;\n}", "    my %seen;\n    grep !$seen{$_}++, sort $l;\n}", "  \
    \  my %seen;\n    my @uniq;\n    my $k;", "    my %seen;\n    my @res;\n    foreach\
    \ my $x (@$l) {\n\tnext if $seen{$x}++;\n\tpush(@res, $a);\n    }\n    return\
    \ @res;\n}", "    sort { $a <=> $b } @$l;\n}", "    my %seen;\n    @$l =\n   \
    \     map { !exists $seen{$_} ? $_ : $seen{$_}++ } sort @$l;\n    @$l = sort {$a\
    \ <=> $b} keys %seen;\n    return @$l;\n}", "    my @res;\n    my $cnt = 0;\n\
    \    foreach my $x (@$l) {\n        $cnt++ if $res[$cnt-1] && $x != $res[$cnt-1];\n\
    \        push @res, $x;\n    }\n    @res;\n}", "    my(@a) = sort @$l;\n    my\
    \ @ret;\n    while(@a) {\n        my $x = shift @a;\n        unless(grep {$_ eq\
    \ $x} @ret) {\n            push @ret, $x;\n        }\n    }\n    return @ret;\n\
    }", "    my @u = ();\n    my $u;\n    while ($l) {\n        my $n = $l->[0];\n\
    \        foreach $u (@u) {\n            if ($n->[0] <= $u->[0]) {\n          \
    \      last;\n            }\n        }\n        push(@u, $n);\n        shift @$l;\n\
    \    }\n    return @u;\n}", '    my %seen;', "    my(@u);\n    my $u;\n    my\
    \ $i = 0;", "    my @t;\n    for my $x (@$l) {\n\tpush @t, $x unless $t{$x};\n\
    \    }\n    return @t;\n}", '    my %seen;', "    my %h;\n    my(@n);\n    foreach\
    \ my $v (@$l) {\n        if (!defined $h{$v}) {\n            push(@n, $v);\n \
    \           $h{$v}++;\n        }\n    }\n    return @n;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=3 tags=perl,sorting,unique |>\nIf your input is in a file (or you\
    \ can slurp it) then use sort:\n<code>\nsort -u -t@ -k 2,2 file\n</code>\nIf it\
    \ isn't a file (or you can't) then build a hash with the unique IDs as keys and\
    \ count the entries as values:\n<code>", "    my %seen = ();\n    my(@l);\n  \
    \  foreach(@$l) {\n        if (not exists $seen{$_}) {\n            push(@l, $_);\n\
    \            $seen{$_} = 1;\n        }\n    }\n    return @l;\n}", "    my $u;\n\
    \    my $uc;\n    my $k;\n    my $len;\n    my $i;\n    my $j;\n    my $l;", " \
    \   my %seen;\n    my @sorted = grep !$seen{$_}++, sort { $a <=> $b } @$l;\n \
    \   return @sorted;\n}", "    my $len = @$l;\n    my @result;\n    \n    for my\
    \ $i (0 .. $len-1) {\n        for my $j ($i+1 .. $len-1) {\n            if ($l->[$i]\
    \ eq $l->[$j]) {\n                next;\n            }\n            push @result,\
    \ $l->[$i];\n        }\n    }\n    \n    return @result;\n}", "    $l = sort {$a\
    \ <=> $b} @$l;\n    return uniq @$l;\n}", "    my %seen;\n    return grep { !$seen{$_}++\
    \ } @$l;\n}", "    my @r;\n    $l = sort { $a <=> $b } @$l;\n    for (my $i =\
    \ 0; $i < $#l; $i++) {\n        my $v = $l[$i];\n        for (my $j = $i + 1;\
    \ $j < $#l; $j++) {\n            if ($l[$j] eq $v) {\n                splice,\
    \ $$l[$i], $j - $i, 1;\n                splice, $$l[$j - 1], 2, 1;\n         \
    \       splice, $$l[$i], $#l - 1 - $i, 1;\n                splice, $$l[$#l - 1],\
    \ 2, 1;\n                $j--;\n            }\n        }\n        push @r, $v;\n\
    \    }\n    return @r;\n}", "    return sort grep { !defined $seen{$_} or !$seen{$_}\
    \ ++ } @$l;\n}\n</code>\nIf you have an array of arrays then you'll need to flatten\
    \ it first using map {@$_} @$arr before calling unique:\n<code>", "    my @ret\
    \ = ();\n    my %seen;\n    for (my $i=0; $i<@$l; $i++) {\n        my $x = $l->[$i];\n\
    \        if (!exists $seen{$x}) {\n            push(@ret, $x);\n            $seen{$x}\
    \ = 1;\n        }\n    }\n    return @ret;\n}", "    my @ret;\n    my $seen;\n\
    \    for (my $i = 0; $i < @$l; $i++) {\n        if ($seen++) {\n            push\
    \ @ret, splice @$l, $i, 1;\n        }\n    }\n    return @ret;\n}", "    my($uc)\
    \ = unicore($l);\n    if (defined $uc) {\n        return sort $uc;\n    }\n  \
    \  return $l;\n}", "    my(@seen, $key, $value);\n    $seen = [];\n    $seen{$_}++\
    \ foreach $l; $l = grep !$seen{$_}++, @$l;\n    return @$l;\n}", "    my %seen\
    \ = ();\n    my $len = scalar @$l;\n    for (my $i = 0; $i < $len; $i++) {\n \
    \       my $val = $l->[$i];\n        next if $seen{$val};\n        $seen{$val}\
    \ = 1;\n        push (@$l, $val);\n    }\n    return $l;\n}", "    my @ret = ();\n\
    \    $_ = $l->[0] if @$l == 0;\n    push @ret, $_ unless $seen{$_}++;\n    foreach\
    \ my $u (@$l) {\n        unless ($seen{$u}++) {\n            push @ret, $u;\n\
    \        }\n    }\n    return @ret;\n}", "    my $sorted = sort { $a <=> $b };\n\
    \    my $uniques = sort { $a <=> $b };\n    return @$uniques;\n}", "    my @a;\n\
    \    my $i = 0;\n    while($i < @$l) {\n        my $x = $l->[$i];\n        next\
    \ if $a->[$i] == $x;\n        $i++;\n        push @a, $x;\n    }\n    return @a;\n\
    }", "    my @a = sort {$a <=> $b} @_;\n    my @b = ();\n    foreach (@a) {\n \
    \       my $val = $_;\n        $b[$val] = 1;\n    }\n    return map $_, $_ for\
    \ (keys %b);\n}", "    sort { $a <=> $b } uniq(@$l);\n}", "    my $u = ();\n \
    \   local @$l;\n    while(my($x) = each @$l) {\n        if(!grep{$x eq $_} @$u)\
    \ {\n            $u -> push($x);\n        }\n    }\n    return @$u;\n}", "   \
    \ my %seen;\n    return sort grep !($seen{$_}++), @$l;\n}", "    sort {$a<=>$b}\
    \ @$l;\n}", "    $l = sort @$l;\n    no warnings 'uninitialized';\n    my @unique;\n\
    \    my $i = 0;\n    while (@$l > $i) {\n        my $x = shift(@$l);\n       \
    \ if (!defined $unique[$x]) {\n            $unique[$x] = 1;\n            push(@unique,\
    \ $x);\n            $i++;\n        }\n    }\n    return @unique;\n}", '    my($i,
    $l);', "    my $result = ();\n    my %seen;\n    foreach (@$l) {\n        if (!$seen{$_})\
    \ {\n            $seen{$_}++;\n            push(@$result, $_);\n        }\n  \
    \  }\n    return @$result;\n}", "    my @unique = ();\n    my $prev;", "    my(@result)\
    \ = (@$l);\n    my($uniq_num);\n    my($new_num);", "    my @u;\n    foreach my\
    \ $x (@$l) {\n        push (@u, grep {! $seen{$_}++} @$l);\n    }\n    @u;\n}",
  "    my $n = @$l;\n    my %h;\n    my $j;\n    for (my $i = 0; $i < $n; $i++) {\n\
    \        ++$h{ $l->[$i] };\n    }\n    $j = -1;\n    my @x;\n    while (@h) {\n\
    \        $j = $j + 1 while (++$j > 0 && $h{ $l->[$j] } > $h{ $l->[$i] });\n  \
    \      push(@x, $l->[$j]);\n        delete $h{ $l->[$j] };\n    }\n    return\
    \ @x;\n}", "    my @h;\n    my @u;\n    \n    while(@h) {\n        my $x = shift\
    \ @h;\n        push(@u, $x);\n        if(grep $_ eq $x, @h) {\n            shift;\n\
    \            next;\n        }\n        push(@h, $x);\n    }\n    return @u;\n}",
  "    my @a = ();\n    my $uniq = 0;\n    foreach my $x (@$l) {\n        if (!$uniq)\
    \ {\n            push (@a, $x);\n            $uniq = 1;\n        } elsif ($x ne\
    \ $a[-1]) {\n            push (@a, $x);\n        }\n    }\n    return @a;\n}",
  "    my %seen;\n    sort { $seen{$a} <=> $seen{$b} } @$l;\n    return sort grep\
    \ ! $seen{$_}++, @$l;\n}", "    my $lc = scalar;\n    my $u = [];\n    my $uc\
    \ = scalar;\n    for (my $i = 0; $i < $lc; $i++) {\n        if ($l[$i] eq $u[$i]\
    \ || $u[$i] eq $l[$i]) {\n            $u[$i] = '\\0';\n        } else {\n    \
    \        push @$u, $l[$i];\n        }\n    }\n    return @$u;\n}", '    my %seen;',
  "    my @seen = ();\n    my @ret = ();\n    while (@$l) {\n        my $x = shift\
    \ @$l;\n        if ($seen{$x}) {\n            push @ret, $x;\n        } else {\n\
    \            $seen{$x}++;\n            push @ret, @$l;\n        }\n    }\n   \
    \ return @ret;\n}", "    my($u) = (0);\n    foreach my $x (@$l) {\n        ++$u\
    \ if ($x != $u);\n    }\n    return @$l;\n}", "    my($u, $i, $c);\n    while\
    \ (@_ > 1) {\n        ($i = shift) unless $i;\n        ($u = shift unless $u);\n\
    \        ++$c if !$u && $l->[$i] eq $u;\n    }\n    return $l->[0] if !$c;\n \
    \   return @$l;\n}", "    my %seen;\n    $seen{$_}++ for @$l;\n    return grep\
    \ !$seen{$_}++, @$l;\n}", "    sort { $a <=> $b } @$l;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| c |>\nThis is exactly the kind of thing I was looking for when I found\
    \ this question. Nicely done.\n<|/ c |>\n<| a dscore=2 |>\nYou can use Set::Tiny\n\
    <code>\nuse strict;\nuse warnings;", "    my %seen;\n    my @unique;\n    foreach\
    \ my $x (@$l) {\n        if (!defined $seen{$x}) {\n            push(@unique,\
    \ $x);\n            $seen{$x} = 1;\n        }\n    }\n    return @unique;\n}",
  "    my $uniq = @$l;\n    my $last;\n    for my $i (0..$#$l-1) {\n        last if\
    \ $uniq > 1;\n        $last = $l->[$i];\n        $uniq++;\n        for my $j ($i+1;\
    \ $j < @$l; $j++) {\n            if ($l->[$j] != $last) {\n                $uniq++;\n\
    \                last if $uniq > 1;\n                $l->[$i] = $l->[$j];\n  \
    \          }\n        }\n    }\n    return @$l;\n}", "    my @unique;\n    my\
    \ $u;\n    for (@$l) {\n        if ($u++ == 1) {\n            push @unique, $_;\n\
    \            next;\n        }\n        elsif ($_ eq $unique[$u - 1])\n       \
    \ {\n            push @unique, $_;\n        }\n    }\n    return @unique;\n}",
  '    return sort { !$seen{$a}++} @$l if ref($l);', "    my @u = ();\n    my $u;\n\
    \    foreach $u (sort {$a <=> $b} @$l) {\n\tpush @u, $u if $u != $_;\n    }\n\
    \    return @u;\n}", "    my %seen;\n    $seen{$_}++ for @$l;\n    map {delete\
    \ $seen{$_}} keys %seen;\n}", "    my $s = $l;\n    my $seen;\n    foreach my\
    \ $i (0 .. $#$l) {\n        my $j;\n        for (my $k = ++$i; $k; $k += 2) {\n\
    \            $j = $l[$k] if !defined $seen[$j];\n            next if !defined\
    \ $seen[$j] && $seen[$j] == $i;\n            $seen[$j] = $i;\n        }\n    }\n\
    \    return @$s;\n}", "    my $result = [];\n    \n    foreach (@$l) {\n     \
    \   push @$result, $_ if !exists($seen{$_}++);\n    }\n    \n    return @$result;\n\
    }", "    my %seen;\n    map { $seen{$_}++ } grep { !$seen{$_}++ } @$l;\n    return\
    \ grep { $seen{$_} == 1 } @$l;\n}", '    my %seen;', "    my($r); # $r is new\
    \ array\n    while (@$l > 0) {\n        my $c = shift @$l;\n        $r->[$c] ||=\
    \ $c;\n        push(@$l, $c);\n    }\n    return @$r;\n}", "    my $uniq = scalar(@$l);\n\
    \    my(@ret) = ();\n    for(my $i = 0 ; $i < $uniq ; $i++) {\n        push(@ret,\
    \ $l->[$i]) unless $ret[$i] == $l->[$i];\n    }\n    @ret;\n}", "    local $_\
    \ = @$l;\n    sort { $a <=> $b } @$l;\n    grep !($_ - $_), @$l;\n}", "    my\
    \ %seen;\n    $seen{$_}++ for\n        grep !$seen{$_}++,\n            sort @$l;\n\
    \    return sort @$l;\n}", "    sort { $a <=> $b } @$l;\n}", '    my %seen;',
  "    my @t = ();\n    my($i, $u, $num, $num2);\n    for($i = 0; $i < @$l; $i++)\
    \ {\n        my $n = $l->[$i];\n        if(defined $n) {\n            $l->[$i]\
    \ = undef;\n            push @t, $n;\n        }\n    }\n    $u = 0;\n    for(my\
    \ $i = 0; $i < @t; $i++) {\n        $num = $t[$i];\n        if(defined $num) {\n\
    \            $num2 = $u;\n            while($num == $t[$i + $num2]) {\n      \
    \          $num2++;\n                if($num2 == @t) {\n                    $u++;\n\
    \                    $num2 = $u;\n                }\n            }\n         \
    \   if($i != $i + $num2 - 1) {\n                my $v = $t[$i + $num2];\n    \
    \            $t[$i + $num2] = $t[$i];\n                $t[$i] = $v;\n        \
    \    }\n        }\n    }\n    return @t;\n}", "    my $uc = {};\n    foreach my\
    \ $e (@{$l}) {\n        $uc{$e} = 1;\n    }\n    return sort keys %uc;\n}", " \
    \   my($na, @ns);\n    foreach $na (@$l) {\n        push @ns, $na if $ns && !grep($na\
    \ eq $_, $ns);\n    }\n    return @ns;\n}", "    my @u;\n    my $u;\n    foreach\
    \ my $i (0 .. $#l) {\n        next if $u and $l[$i] eq $u->[0];\n        push\
    \ @u, $l[$i];\n    }\n    return @u;\n}", "    return sort {\n        $a <=> $b\n\
    \    } grep {\n        ! grep $_ eq $_, $l\n    } @$l;\n}", "    my @u = ();\n\
    \    my $u;\n    my $i;", "    sort { $a <=> $b } @$l;\n}", "    my @s = ();\n\
    \    my(@uniq);", "    my(@u, $u, $d);\n    my $prev;\n    for (my $i = 0; $i\
    \ < @$l; $i++) {\n        $u[$i] = $l->[$i];\n        $u[$i] =~ s/^-//;\n    \
    \    if ($u[$i] eq $prev) {\n            $d[$i] = 1;\n        } else {\n     \
    \       $d[$i] = 0;\n        }\n        $prev = $l->[$i];\n    }\n    for (my\
    \ $i = 0; $i < @$l; $i++) {\n        if ($d[$i]) {\n            delete $l->[$i];\n\
    \            $i--;\n        }\n    }\n    @$l = @u;\n}", "    my @h = ();\n  \
    \  my $len = scalar @$l;\n    for (my $i = 0; $i < $len; $i++) {\n        if (!$h->{$l->[$i]})\
    \ {\n            $h->{$l->[$i]} = 1;\n        }\n    }\n    return sort keys %h;\n\
    }", "    my $a;\n    my $c = $l->[0];\n    for (my $i = 1; $i < @$l; ++$i) {\n\
    \        if ($l->[$i] eq $c++) {\n            push @$a, $l->[$i];\n        }\n\
    \    }\n    return @$a;\n}", "    my %seen;\n    grep { ! $seen{$_}++ } @$l;\n\
    }", "    return sort { $a <=> $b } grep !$seen{$_}++,\n      grep { $seen{$_}++\
    \ } @$l;\n}", "    my @r;\n    for (my $i = 0; $i < @$l; $i++) {\n        $r[$i]\
    \ = $l->[$i];\n    }\n    my $u;\n    for ($i = 0; $i < @$r; $i++) {\n       \
    \ if (!defined $u || $u > $r[$i]) {\n            $u = $r[$i];\n        }\n   \
    \ }\n    return @$r;\n}", "    my $i = -1;\n    my @a;\n    foreach (@$l) {\n\t\
    $i++;\n\tpush @a, $i unless $a[$i] == $_;\n    }\n    return @a;\n}", "    my($h);\n\
    \    my $u;\n    push @$h, @$l;\n    while (($u = $h->[-1]) =~ /\\w/) {\n    \
    \    pop @$h;\n        unshift @$h, $u;\n    }\n    return @$l;\n}", "    my %uniq;\n\
    \    $uniq{$_}++ foreach @$l;\n    return sort keys %uniq;\n}", "    my %seen;\n\
    \    my @unique;\n    while (my $elem = shift @$l) {\n        if (!exists $seen{$elem})\
    \ {\n            push @unique, $elem;\n            $seen{$elem} = 1;\n       \
    \ }\n    }\n    return @unique;\n}", "    my @u = ();\n    foreach (@$l) {\n \
    \       $_ unless exists $seen{$_};\n        $seen{$_}++;\n    }\n    return @u;\n\
    }", "    my @u;\n    my($i, $j) = @_;\n    my $k = @_;\n    if (defined $k) {\n\
    \        $k = @_ ? $k : 0;\n        return undef unless @$l;\n    }\n    if ($k)\
    \ {\n        @u = (sort {$k <=> $a} grep !$u[$_], 0..$#$l);\n    } else {\n  \
    \      @u = (sort {$a <=> $b} grep !$u[$_], 0..$#$l);\n    }\n    return @u;\n\
    }", "    $l =~ s/^\\s*//;\n    $l =~ s/\\s*$//;\n    return sort @$l;\n}", " \
    \   my @u = ();\n    my $uv = undef;\n    for (@$l) {\n        next unless defined\
    \ $uv and $uv == $_;\n        $uv = $_;\n    }\n    if (defined $uv) {\n     \
    \   push @u, @$uv;\n    }\n    @u;\n}", "    my @u;\n    my %seen = ();\n    foreach\
    \ my $n (@$l) {\n        if (!defined $seen{$n}) {\n            push(@u, $n);\n\
    \            $seen{$n} = 1;\n        }\n    }\n    return @u;\n}", "    my %seen;\n\
    \    push @$l, undef for @$l unless exists $seen{$_};\n    return grep !$seen{$_}++,\
    \ @$l;\n}", "    my @ret = ();\n    push @ret, unless $_[0];", "    my $h = {};\n\
    \    my @a;\n    foreach my $x (@$l) {\n        if (!exists $h->{$x}) {\n    \
    \        push(@a, $x);\n            $h->{$x} = 1;\n        }\n    }\n    return\
    \ sort @a;\n}", '    my($i, $j, $hash);', "    my $s = $$l;\n    my @s = ();\n\
    \    foreach my $item (@$l) {\n        push(@s, $item) unless $seen{$item}++;\n\
    \    }\n    return @s;\n}", "    my $r = [];\n    my $h = {};\n    map { if (!$h->{$_})\
    \ { $r->[$_] = $l->[$_]; } } 0..$#$l;\n    return @$r;\n}", "    my %seen;\n \
    \   @$l =\n        map {\n            my $s = $_;\n            $seen{$s}++ unless\
    \ $seen{$s};\n            $s\n        }\n        sort {\n            $seen{$a}\
    \ <=> $seen{$b}\n        } @_;\n    return @$l;\n}", "    my @a = ();\n    my\
    \ %seen = ();\n    foreach (@$l) {\n        if (!defined($seen{$_})) {\n     \
    \       push @a, $_;\n            $seen{$_} = 1;\n        }\n    }\n    return\
    \ @a;\n}", "    my $uv = map {$_ unless grep $_ eq $_, @_};\n    @$l += @$uv;\n\
    \    return sort @_;\n}", "    my @u;\n    my $u;\n    my($k) = 0;\n    foreach\
    \ (@$l) {\n        $k++;\n        unless (defined $u or $k >= 2) {\n         \
    \   push (@u, $_) unless $u or $k >= 2;\n            $u = $_;\n            $k\
    \ = 0;\n        }\n        else {\n            push (@u, $u) if $u;\n        \
    \    $u = $_;\n        }\n    }\n    push (@u, $u) if $u;\n    @u;\n}", "    my\
    \ %seen;\n    @$l = grep !$seen{$_}++, @$l;\n    return @$l;\n}", "    my $u =\
    \ [];\n    while (my($key, $val) = each %$l) {\n        push @$u, $val unless\
    \ $u->[0] && $key != $u->[0];\n    }\n    return $u;\n}", "    grep !exists $seen{$_},\
    \ @$l;\n}", "    my %seen;\n    my @out;\n    $seen{$_} = 1 foreach(@$l);\n  \
    \  foreach my $elem (@$l) {\n        if(not exists $seen{$elem}) {\n         \
    \   push(@out, $elem);\n        }\n    }\n    return @out;\n}", "    my @result;\n\
    \    my $key;\n    my $seen;\n    for (my $i = 0; $i < $#{$l}; $i++) {\n     \
    \   $key = $l->[$i];\n        if (!$seen->{$key}) {\n            push @result,\
    \ $key;\n            $seen->{$key} = 1;\n        }\n    }\n    return @result;\n\
    }", "    return sort grep(!$seen{$_}++, @$l);\n}", "    my @seen;\n    foreach\
    \ my $x (@$l) {\n        my $hash = $x->{HASH};\n        my $dup = 0;\n      \
    \  foreach my $k (keys %$hash) {\n            my $cmp = $hash->{$k}{CMP};\n  \
    \          next if $cmp->($x, $x) != 0;\n            $dup = 1;\n            last;\n\
    \        }\n        if (!$dup) {\n            $seen[$#seen] =~ s/^(\\d+)\\z/$1/g;\n\
    \        }\n    }\n    return sort {$a <=> $b} keys %seen;\n}", "    return sort\
    \ {$l <=> $_} uniq @$l;\n}", "    my @ret = ();\n    my $last = undef;\n    foreach\
    \ my $x (@$l) {\n        if(!$last || $last->[0] ne $x->[0]) {\n            $last\
    \ = $x;\n            push(@ret, $x);\n        }\n    }\n    return @ret;\n}",
  "    my(@u) = ();\n    my(@s) = ();\n    while(@l) {\n        push(@s, shift(@l));\n\
    \        push(@u, shift(@s));\n    }\n    push(@u, @s);\n    join(', ', @u);\n\
    }", "    # Return sorted unique elements in an array\n    # >>> unique([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\n    # [0, 2, 3, 5, 9, 123]\n    my @s = sort { $a <=>\
    \ $b } @$l;\n    return @s;\n}", "    my $s = $l;\n    my $k = 1;\n    my $n =\
    \ scalar(@$s);\n    foreach my $k (@$s) {\n        next if $k == $k;\n       \
    \ last if $k > $n;\n        splice @$s, $k, 1;\n    }\n    return @$s;\n}\n</code>\n\
    <|/ a dscore=1 tags=sorting,perl |>\n<| c |>\n: Thanks. Fixed.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\nuse strict;\nuse warnings;", "    my(@r) = (1);\n    for\
    \ (my $i = 0; @$l > $i; ++$i) {\n        push(@r, $l->[$i]);\n        push(@r,\
    \ ($l->[$i]) x $l->[$i]);\n    }\n    sort {$a <=> $b} @r;\n}", "    $l = sort\
    \ @$l;\n    my %seen;\n    @$l = map { $seen{$_}++ ? $_ : () } @$l;\n    return\
    \ @$l;\n}", "    my @r;\n    my %seen;\n    foreach my $x (@$l) {\n        if\
    \ (!defined($seen{$x})) {\n            push(@r, $x);\n            $seen{$x} =\
    \ 1;\n        }\n    }\n    @r;\n}", "    my($n);\n    my @a;\n    my $flag =\
    \ 0;\n    my $last;\n    my(@a) = (@$l);", "    my @ret = ();\n    for my $x (sort\
    \ {$a <=> $b} @$l) {\n        if ($ret[$x]) {\n            push(@ret, splice(@$l,\
    \ $x, 1));\n        }\n    }\n    return @ret;\n}", "    return sort keys %{$l\
    \ ? {%{$l}} : ()};\n}", "    my($u);\n    do {\n        $u = $l->[-1];\n     \
    \   $l->[-1] = $l->[-2] if $l->[-2] ne $u;\n    } while ($l ne $u);\n    return\
    \ @$l;\n}", "    my $c = $l->[0];\n    my $u = 0;\n    while ($c->[$u++] eq $c->[$u++])\
    \ {}\n    splice, 2, 0, $u;\n    return $c;\n}", "    my %seen;\n    my @res;",
  "    my @ua = sort {$$a <=> $$b} @_;\n    my @ua = sort {$$a <=> $$b} @$ua;\n  \
    \  return @ua;\n}", "    my %seen;\n    my @r;", "    my @t;\n    for (my $i =\
    \ 0; $i < scalar @$l; $i++) {\n        $t[$i] = $l->[$i] if $l->[$i] ne $l->[$i-1];\n\
    \    }\n    return @t;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
