name: HumanEval_36_fizz_buzz
language: pl
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n\
  # 2\n# >>> fizz_buzz(79)\n# 3\nsub fizz_buzz {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fizz_buzz;\n\
  \        if(eq_deeply($candidate->(50),0)) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(78),2)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(79),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(200),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4000),192))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10000),639))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100000),8026))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(@fizz) = ();\n    my(@buzz) = ();\n    while ($n != 0) {\n \
    \       my $remainder = $n % 11;\n        my $remainder2 = $n % 13;\n        if\
    \ ($remainder == 0 || $remainder2 == 0) {\n            push (@fizz, $n);\n   \
    \     }\n        $n =~ s/^0*//;\n        $n =~ s/^0+$//;\n    }\n    foreach my\
    \ $i (@fizz) {\n        my $remainder = $i % 11;\n        my $remainder2 = $i\
    \ % 13;\n        if ($remainder == 0 || $remainder2 == 0) {\n            push\
    \ (@buzz, $i);\n        }\n    }\n    return scalar(@buzz);\n}", "    my($fb)\
    \ = ($n =~ /[13579]/ ? 0 : 1);\n    for (my $i = 0; $i < ( int ($n) / 3 ); $i++)\
    \ {\n\t$n = ( $n - ( ( 3 * $i ) * $fb ) );\n\t$n =~ tr/3338393731/3773737377/;\n\
    \t($fb == 1 ? $fb : ++$fb)\n    }\n    $fb;\n}", "    my $count = 0;\n    while\
    \ ($n =~ /(\\d+)\\s+(11|13)/g) {\n        my $num = $1;\n        $num =~ s/\\\
    s+//g;\n        if ($num == 7)\n        {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}", "    my(@c) = ('7', '8', '9', '10');\n    my(@n)\
    \ = ($n / 10);\n    my(@result) = (0);\n    my($found);\n    while ($n) {\n  \
    \      foreach $c (@c) {\n            if ($n % $c eq '0') {\n                ($found\
    \ += 1)\n            }\n        }\n        $n--;\n    }\n    return $found;\n}",
  "    my($i,$z,$counter);\n    $z  = $n % 11;\n    $i  = $n % 13;", "    my($num);\n\
    \    my $count=0;\n    while($n>0) {\n        $num = $n % 11;\n        $count++\
    \ if $num == 7;\n        $n = ($n / 11) - 1;\n    }\n    return $count;\n}", " \
    \   my(@m) = $n =~ m/^(\\d+)$/ ? $1 : $n =~ m/^(\\d+)\\.(\\d+)$/ ? $1 : ($n =~\
    \ m/^(\\d+)\\.(\\d+)\\.(\\d+)$/ ? $1 : 0);\n    my(@x) = (@m[10..19]);\n    if\
    \ (@x == 11 || @x == 13) {\n        return 0;\n    }\n    return scalar(@x) -\
    \ scalar(@x % 11);\n}", "    my $counter = 0;\n    $n = $n / 11;\n    while ($n)\
    \ {\n        $n %= 11;\n        if ($n == 7 && $counter < 2) {\n            $counter++;\n\
    \        }\n        $n = ($n+1) / 13;\n    }\n    return $counter;\n}", "    my($c);\n\
    \    my($z);\n    my($r);\n    my($i);\n    my($n);\n    my($t);", "    $n *=\
    \ 10 while $n > 0;\n    $n -= 7;\n    return $n / 11 if $n % 11 == 7;\n    return\
    \ $n / 13 if $n % 13 == 7;\n    return 0;\n}", "    my($i);\n    for ($i = $n;\
    \ $i > 0; $i--) {\n\tmy $c = $_ % 11;\n\tmy $b = $_ % 13;\n\treturn $i if ($c\
    \ == 7);\n\treturn $i if ($c == $b == 7);\n\treturn $i if ($c == $b == 11);\n\t\
    return $i;\n    }\n    return 0;\n}", '    my($fizz_count, $buzz_count);', " \
    \   return 0 if $n % 11 == 0 or $n % 13 == 0;\n    my($x, $y, $z) = (0, 1, 0);\n\
    \    while ($n) {\n        $x = $n % 10;\n        $y = $z % 10;\n        $z =\
    \ $x / 10;\n        $n--;\n        if ( $x % 10 == 7 ) {\n            $x += 13;\n\
    \            $z += 2;\n        }\n    }\n    return $z;\n}\n</code>\n<|/ a tags=perl,fizzbuzz\
    \ dscore=3 |>\n<| c |>\nYou have the best solution, though I would use `for my\
    \ $i ( 1 .. $n )` rather than `for my $i (0..$n-1)`\n<|/ c |>\n<| c |>\nI tested\
    \ this solution on a range of numbers from 1..100, it works with both and seems\
    \ to run faster than the accepted answer.\n<|/ c |>\n<| c |>\n, I'm curious which\
    \ test you are using, and which version of Perl you used (`perl` vs. `p`)?\n<|/\
    \ c |>\n<| c |>\n, `for my $i ( 1 .. $n )` works with both v5.16.2, and v5.18.2,\
    \ but on v5.26.1 it doesn't work.  I suspect that this is due to bugs introduced\
    \ in 5.26.\n<|/ c |>\n<| c |>\nIt appears that `for my $i ( 1 .. $n )` has problems\
    \ with large `n`s, since it takes a long time to execute for the large `n`s.\n\
    <|/ c |>\n<| a |>\nThe Perl version 5.26 has a bug which makes this code not work.\
    \  This is fixed in v5.26.1, so I tested it, and it works with both v5.16.2 and\
    \ v5.18.2.  I checked that the original code works with v5.16.2 and v5.18.2.\n\
    <code>", "    my $count = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        if\
    \ ($i % 11 == 0 || $i % 13 == 0) {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}", "    my $digit = 7;\n    my $count = 0;\n    \n    while\
    \ ($n > 0) {\n        if ($n =~ /^(11|13)$/ && $n % $digit == 0) {\n         \
    \   $count++;\n        }\n        $n--;\n    }\n    \n    return $count;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't return how many numbers in a\
    \ list are divisible by 7 or 11 or 13 (as requested in the question), it returns\
    \ how many numbers are divisible by 7 or 11, or 13.\n<|/ c |>\n<| c |>\n: I understand\
    \ it more like how to count how many numbers in a list are divisible by 7 or 11\
    \ or 13, and I showed you how to do that. I think it's more useful to let the\
    \ OP decide whether he wants to count those or count how many times a specific\
    \ digit appears in an even number of numbers in a list.\n<|/ c |>\n<| c |>\n:\
    \ I added a solution that counts how many times a specific digit appears in an\
    \ even number of numbers in a list.\n<|/ c |>\n<| c |>\nI edited the question.\
    \ Thanks again\n<|/ c |>\n<| c |>\nI'm still confused, because you accepted this\
    \ answer and not the other one. Did you decide which one to accept? And I guess\
    \ you didn't notice my last edit, but you know what I was trying to say.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIn Perl 5, you can use the modulo operator in regex\
    \ to check for divisibility:\n<code>", "    my $count = 0;\n    while($n < 100){\n\
    \        my $div = 11*($n % 11);\n        $count++ if $div == 13;\n        $n++;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a dscore=0 tags=fizzbuzz,perl |>\n\
    <| c |>\nJust as a note: This code is _not_ an efficient implementation.  See\
    \ my answer for a more efficient implementation.\n<|/ c |>\n<| c |>\n: That is\
    \ because you're incrementing `$n` in the loop, and `@n` is being reset to its\
    \ original value.  In your code, `$n` never changes.  But if you change it to\
    \ `my = ();`, then `$n` won't be reset to its original value.  See the answer\
    \ for an explanation.\n<|/ c |>\n<| c |>\n: See my updated answer to give you\
    \ an efficient algorithm.  I included an example of it.\n<|/ c |>\n<| c |>\n:\
    \ If you want me to explain it further, please let me know.  It's a bit tricky\
    \ to explain.  But if you want to check out my code, just let me know.\n<|/ c\
    \ |>\n<| c |>\nI rewrote my answer to give an efficient implementation.  Please\
    \ take a look.  Thanks.\n<|/ c |>\n<| a tags=fizzbuzz,perl |>\nThis is what I\
    \ have now:\n<code>", "    return 0 unless $n;\n    if ( $n % 11 == 0 ) {\n  \
    \      my $count = 0;\n        for my $n (1..$n) {\n            if ( $n % 13 ==\
    \ 0 ) {\n                $count++;\n            }\n            if ( $n % 11 ==\
    \ 0 ) {\n                $count++;\n            }\n        }\n        return $count;\n\
    \    }\n    else {\n        my $count = 0;\n        for my $n (1..$n) {\n    \
    \        if ( $n % 11 == 0 ) {\n                $count++;\n            }\n   \
    \     }\n        return $count;\n    }\n}", '    my($result);', "    if ($n !=\
    \ 1 && $n != 9) {\n        return(1);\n    }\n    if ($n == 9) {\n        return(11);\n\
    \    }\n    if ($n == 9) {\n        return(13);\n    }\n    return(0);\n}", " \
    \   return ($n % 11 == 0 || $n % 13 == 0) ? 0 : $n / 11 + $n / 13 + 1;\n}\n</code>\n\
    <|/ a tags=perl,fizzbuzz |>\n<| a |>\nUse a regex to extract the numbers in the\
    \ string:\n<code>\n$string = \"1 3 5 7 9 11 13 15\";\n$regex = '\\d+';", "   \
    \ my $counter = 0;\n    my @digits = split //, ('0'..'9');\n    foreach my $digit\
    \ (@digits) {\n        my $remainder = sprintf \"%05d\", $n / $digit;\n      \
    \  if ($remainder % 11 == 0 || $remainder % 13 == 0) {\n            $counter++;\n\
    \        }\n    }\n    return $counter;\n}", '    my($c);', "    $n % 11 == 0\
    \ or $n % 13 == 0 or ($n % 3 == 0 && $n % 5 == 0) ? $n : 0;\n}", "    my($i, $digit,\
    \ $multiple, $counter);\n    for ($i = $n; $i >= 0; $i -= 10) {\n        $digit\
    \ = $i % 10;\n        $multiple = 11 if $digit == 7;\n        $counter = ($multiple)\
    \ ? 1 : 0;\n        return $counter;\n    }\n    return 0;\n}", "    return 1\
    \ if $n =~ /7/ || $n =~ /9/ || $n =~ /11/ || $n =~ /13/;\n    return 0 if $n %\
    \ 11 == 0 || $n % 13 == 0;\n    return $n;\n}", "    if ($n < 0) {\n        $n\
    \ = -$n;\n        $sign ^= 1;\n    }\n    $n *= $digit;\n    my($z, $i, $j);\n\
    \    for ($i = 0, $j = ($n % 11 + 13) % 11, $z = 0; $j <= $j; $i++ ) {\n     \
    \   $z += $i if ($z == $n && $i != $j);\n    }\n    $z++;\n    return $z;\n}\n\
    </code>\n<|/ a tags=fizzbuzz,perl,while-loop,optimization |>\n<| c |>\nThat is\
    \ very clever. Can you explain the `&` before `&fizz_buzz`? Also, is there a way\
    \ to do this without having to use `if` statements?\n<|/ c |>\n<| c |>\nThe `&`\
    \ before the sub name makes it a subroutine call, as opposed to a normal function\
    \ call. Also, `if` statements are only a possibility if you are dealing with integers.\
    \ If you are dealing with arbitrary number you will have to have some form of\
    \ condition.\n<|/ c |>\n<| c |>\nOh, so it's just for subroutines. Thank you so\
    \ much!\n<|/ c |>\n<| c |>\nThis is not true.\n<|/ c |>\n<| c |>\nIt is true in\
    \ Perl's case, but in general Perl does not optimize subroutine calls.\n<|/ c\
    \ |>\n<| a dscore=1 tags=fizzbuzz,perl,while-loop,optimization |>\nYou don't need\
    \ to use an if statement, you can do all the calculations in the same while loop.\n\
    <code>\nwhile (my $number = <>) {\n    if ($number % 11 == 0) {\n        print\
    \ \"$number\\n\";\n    } elsif ($number % 13 == 0) {\n        print \"$number\\\
    n\";\n    } elsif ($number % 15 == 0) {\n        print \"$number\\n\";\n    }\
    \ else {\n        print \"FizzBuzz\\n\";\n    }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    But that wouldn't be buzz fizz for numbers divisible by 15\n<|/ c |>\n<| c |>\n\
    True, but you didn't specify that requirement. :P\n<|/ c |>\n<| c |>\nAh.  My\
    \ bad.  Updated to `print` FizzBuzz.  Thanks.\n<|/ c |>\n<| c |>\nThanks for the\
    \ answer! Is there a way to do this without the `if` statement?\n<|/ c |>\n<|\
    \ c |>\nYes, there is. See the other answers.\n", "    return 0 if not $n;\n \
    \   return 1 if ($n % 11 == 13);\n    return 1 if ($n % 13 == 11);\n    my @nums\
    \ = split //, $n;\n    for (@nums) {\n        next if $_ % 11 == 13;\n       \
    \ next if $_ % 13 == 11;\n        return 0 if $_ % 7 == 0;\n        return 1;\n\
    \    }\n    return 1;\n}", "    my($result) = 0;\n    my($remainder);\n    while\
    \ ($n > 0) {\n        $remainder = $n % 11;\n        $n = $n / 11;\n        if\
    \ ($remainder == 7 && $n == 0) {\n            $result++;\n        }\n        if\
    \ ($remainder == 7 && $n != 0) {\n            $result++;\n        }\n    }\n \
    \   return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,fizzbuzz,ruby\
    \ |>\n<code>\ndef fizz_buzz(n)\n  result = 0\n  n % 11 == 0 ? n : fizz_buzz(n\
    \ / 11)\n  n % 13 == 0 ? n : fizz_buzz(n / 13)\n  result += 1\n  result\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=math,fizzbuzz,ruby |>\nIn Ruby:\n\
    <code>\ndef fizz_buzz(n)\n  (n % 11 == 0 ? n : fizz_buzz(n / 11)) + (n % 13 ==\
    \ 0 ? n : fizz_buzz(n / 13))\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef fizz_buzz(number)\n\
    \  (number % 11 == 0 ? number : fizz_buzz(number/11)) + (number % 13 == 0 ? number\
    \ : fizz_buzz(number/13))\nend\n</code>\n<|/ a tags=math,fizzbuzz,ruby dscore=0\
    \ |>\n<| a tags=math,fizzbuzz,ruby dscore=0 |>\n<code>\ndef fizz_buzz(n)\n  n\
    \ += 11\n  while n > 13 do\n    n -= 13\n    puts 'FizzBuzz'\n  end\n  n\nend",
  "    my(@result) = (0,0);\n    for ($n .. 9) {\n        if ($n % 11 == 0) {\n  \
    \          push(@result,3);\n        } elsif ($n % 13 == 0) {\n            push(@result,2);\n\
    \        } else {\n            push(@result,1);\n        }\n    }\n    return\
    \ scalar(@result);\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis was an interesting\
    \ one!\nI got it working with only a couple loops but the speed was about 2x slower\
    \ than the other answers posted here:\n<code>\nuse strict;\nuse warnings;", " \
    \   my($nstr) = @_;\n    my($fz) = @_;\n    my($z);\n    my($fzcnt);\n    my($zcnt);\n\
    \    my($fzcnt2);\n    my($zcnt2);", "    return $n if $n == 0;\n    ($n % 11)\
    \ == 0 || ($n % 13) == 0 ? return 0 : 1;\n    my @n = split(//, $n);\n    my $count\
    \ = 0;\n    my $digit;\n    foreach my $v (@n) {\n        $digit += $v;\n    \
    \    $count += $v == $digit ? 1 : 0;\n    }\n    return $count;\n}", "    my(@result);\n\
    \    push(@result,0) if $n =~ /7$/;\n    push(@result,0) if $n =~ /11$/;\n   \
    \ push(@result,1) if $n =~ /13$/;\n    for (my $i = 0; $i < @result; $i++) {\n\
    \        my($count) = @result[$i];\n        if ($n % $count == 0) {\n        \
    \    $result[$i] = $count + 1;\n        } else {\n            $result[$i] = 0;\n\
    \        }\n    }\n    my $index = 0;\n    for (@result) {\n        if ($_ eq\
    \ 0) {\n            $index = 0;\n        }\n        if ($index == $n) {\n    \
    \        return $index;\n        }\n        $index++;\n    }\n    return;\n}",
  "    my $count = 0;\n    while (@_) {\n        $count++ if ( @$_ % 11 == 0 && @$_\
    \ % 13 == 0 );\n        shift;\n    }\n    return $count;\n}", "    return 0 unless\
    \ $n >= 0;\n    \n    my $count = 0;\n    for (my $i = $n; $i >= 1; $i /= 11)\
    \ {\n        for (my $j = $i; $j >= 13; $j /= 13) {\n            $count++;\n \
    \       }\n    }\n    return $count;\n}", "    if ($n < 0)\n    {\n\treturn 0;\n\
    \    }\n    elsif ($n % 11 == 0 && $n % 13 == 0)\n    {\n\treturn 1;\n    }\n\
    \    elsif ($n % 11 != 0)\n    {\n\treturn 0;\n    }\n    elsif ($n % 13 != 0)\n\
    \    {\n\treturn 2;\n    }\n    else\n    {\n\treturn 3;\n    }\n}", "    \n \
    \   for(my $i = 1; $i <= $n; $i++) {\n        if($i % 11 == 0 && $i % 13 == 0)\
    \ {\n            print $i, \"\\n\";\n            next;\n        }\n        elsif($i\
    \ % 11 == 0 && $i % 13 != 0) {\n            print $i, \"\\n\";\n            next;\n\
    \        }\n        elsif($i % 11 != 0 && $i % 13 == 0) {\n            print $i,\
    \ \"\\n\";\n            next;\n        }\n        elsif($i % 11 != 0 && $i % 13\
    \ != 0) {\n            print $i, \"\\n\";\n        }\n    }\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nIt should be `print $_, \"\\n\" unless $_ % 11;`\n<|/ c |>\n<|\
    \ a dscore=1 tags=perl,fizzbuzz |>\nAnother solution without an explicit loop:\n\
    <code>\nuse strict;\nuse warnings;", "    return 0 if $n < 10;\n    return 1 if\
    \ $n % 11 == 0;\n    return 2 if $n % 13 == 0;\n    return 0;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\n`return 1 if $n % 11 == 0;` looks more like a comment\n<|/ c\
    \ |>\n<| c |>\nIt does, but that code is a little confusing, so I've edited it\
    \ a little bit.\n<|/ c |>\n<| c |>\nYou mean `return 0 if $n < 10;` instead of\
    \ `return 0 if $n < 10;` ??\n<|/ c |>\n<| c |>\nThe comment `# Return the number\
    \ of times the digit 7 appears in integers less than n which are divisible by\
    \ 11 or 13.` suggests that it could be 11 or 13. I guess I assumed it was less\
    \ than 10. You're right that it could also be less than 10 and it could be less\
    \ than 100 or 1000, etc. I've edited my answer to reflect this.\n<|/ c |>\n<|\
    \ c |>\nI agree, it was a bit confusing, that's why i edited it.\n<|/ c |>\n<|\
    \ a tags=integer,perl dscore=2 |>\n<code>", "    my(@result) = (0);\n    for (my\
    \ $i = 0; $i < $n; $i++) {\n        my $digit = $i % 10;\n        $digit += $digit\
    \ == 7 ? (11 + $digit) : (13 + $digit);\n        push(@result, $digit);\n    }\n\
    \    return @result;\n}", "    $n =~ tr/7/7/;\n    ($n =~ tr/11/13/) > 1 ? ($n\
    \ = $n * 3) : $n;\n}\n</code>\n<|/ a tags=algorithm,perl,fizzbuzz |>\n<| a dscore=1\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    my($result) = -1;\n    my($fizzbuzz)\
    \ = map {$_ * 100} 1 .. $n;\n    foreach $num (@$fizzbuzz) {\n        if ($num\
    \ % 11 == 0 || $num % 13 == 0) {\n            $result = $result + 1;\n       \
    \ }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthanks\
    \ but the issue is this code is working but i want to know how to use fizzbuzz\
    \ method with out using loops\n<|/ c |>\n<| c |>\n: So you want to know how to\
    \ find whether a number can be divided by any number?\n<|/ c |>\n<| c |>\nyes\
    \ i want to know how to use fizzbuzz method without using loops\n<|/ c |>\n<|\
    \ c |>\n: It seems that you are trying to implement the FizzBuzz algorithm. As\
    \ mentioned, this is an example of the [tag:fizzbuzz] algorithm. I am not trying\
    \ to help you with the code you have posted, but to point out how you might use\
    \ that algorithm yourself in code.\n<|/ c |>\n<| a |>\nThe answer given is good,\
    \ but it's easy to miss one detail that you might want to be aware of: it's not\
    \ obvious that you have to generate all possible combinations.\nHere's an example\
    \ solution that generates a sorted list of all possible fizzbuzz numbers using\
    \ recursion (assuming that the input is limited to between 1 and 999). It also\
    \ returns the number of occurrences of each number.\n<code>\nuse strict;\nuse\
    \ warnings;", "    my($i, $j, $num);\n    \n    # Divide into two parts, where\
    \ one part has the even numbers and the other has odd numbers. \n    # The even\
    \ numbers will be in the even array.\n    my($even, @even);\n    $even = ($n =~\
    \ /([0-9]+)\\|([0-9]+)$/);\n    \n    # The odd numbers will be in the odd array.\n\
    \    my($odd, @odd);\n    $odd = ($n =~ /([0-9]+)\\|([0-9]+)$/);\n    \n    #\
    \ Loop through each of the even numbers and see if the 7 appears. If it does then\
    \ increment the count by 1.\n    foreach $i (@$even) {\n        if ($i =~ /7$/)\
    \ {\n            $num++;\n        }\n    }\n    \n    # Loop through each of the\
    \ odd numbers and see if the 7 appears. If it does then increment the count by\
    \ 1.\n    foreach $j (@$odd) {\n        if ($j =~ /7$/) {\n            $num++;\n\
    \        }\n    }\n    \n    # Return the count.\n    return $num;\n}", "    return\
    \ 0 if $n == 0;\n    return $n  == 11 ? 1 : ($n  == 13 ? 2 : ($n % 11 == 0 ? 1\
    \ : 0))\n}", "    my $count = 0;\n    while ($n =~ /(?<=[1-9])7(?=[1-9]|$)/g)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    my(@result) = (\"\"\
    );\n    my($count) = 0;", "    # Check for multiples of 11.\n    if ($n % 11 ==\
    \ 0) {\n        $n =~ s/^11+//;\n        ++$n;\n    }\n    # Check for multiples\
    \ of 13.\n    if ($n % 13 == 0) {\n        $n =~ s/^13+//;\n        $n++;\n  \
    \  }\n    return $n;\n}", "    my $cnt = 0;\n    while ($n != 0) {\n        $n\
    \ -= 11;\n        $cnt += $n == 7;\n        $n -= 13;\n        $cnt += $n == 7;\n\
    \    }\n    return $cnt;\n}\n</code>\n<|/ a dscore=3 tags=perl,math,fizzbuzz |>\n\
    <| c |>\nNicely formatted and concise implementation. I've never been a fan of\
    \ using an `if` statement to set a variable's value like that, but I like that\
    \ it returns the count of matches. I also like this implementation (it works well\
    \ for Perl), but the `if`-less version does not give the correct answer when `fizz_buzz`\
    \ isn't a multiple of 3, 6, or 9: it only returns 0. I suggest changing the `if`s\
    \ to `elsif`s, or add a conditional to the `while` loop: `while ($n != 0)`.\n\
    <|/ c |>\n<| c |>\n: Thanks. I fixed the bug, although I find it slightly unlikely\
    \ to occur in practice. :-)\n<|/ c |>\n<| c |>\nThanks guys, I ended up with this:\
    \ `sub fizz_buzz { my $n = shift; my $cnt = 0; while ($n != 0) { my $div = $n\
    \ % 11; $cnt += $div == 0 && $div == 13; $n -= $div * 3; $cnt += $div == 0 &&\
    \ $div == 13; $n -= $div * 6; $cnt += $div == 0 && $div == 13; $n -= $div * 9;\
    \ $cnt += $div == 0; $n -= $div * 11; $cnt += $div == 0; $n -= $div * 13; $cnt\
    \ += $div == 0; $n -= $div; $cnt++; } return $cnt; }`\n<|/ c |>\n<| a dscore=3\
    \ tags=perl,math,fizzbuzz |>\nHere is a much simpler and more readable version:\n\
    <code>", "    $n -= 1;\n    if ($n % 11 == 0 || $n % 13 == 0) {\n        return\
    \ $n;\n    }\n    my $count = 0;\n    my $remainder = 0;\n    my $i;\n    for\
    \ ($i = $n; $i >= 1; $i -= 1) {\n        if ($i % 11 == 0 && $i % 13 == 0) {\n\
    \            $count++;\n        } elsif ($i % 11 == 0) {\n            $remainder\
    \ += 11;\n        } elsif ($i % 13 == 0) {\n            $remainder += 13;\n  \
    \      } else {\n            $remainder += $i;\n        }\n    }\n    if ($remainder\
    \ > 0) {\n        $count += 1;\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI like how you used the modulo operator. Great idea!\n<|/ c |>\n<| c\
    \ |>\nI like your solution too, though your code is wrong, because `fizz_buzz(79)`\
    \ gives `0`.\n<|/ c |>\n<| c |>\nYes, that's why I said _It only works for numbers\
    \ divisible by 11_. It only counts numbers that are divisible by 11. `fizz_buzz(79)`\
    \ gives `2`.\n<|/ c |>\n<| c |>\nI see what you mean now. Thank you!\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's another way to do it:\n<code>", '    my($i);', "    my\
    \ $s = 0;\n    $n =~ s/^0*/1/g;\n    \n    my $t = $n % 11;\n    $s += $t if $t\
    \ < 9;\n    $n -= $t if $t > 9;\n    \n    $t = $n % 13;\n    $s += $t if $t <\
    \ 9;\n    $n -= $t if $t > 9;\n    \n    return $s;\n}", "    return 0 unless\
    \ $n;\n    return 1 if ($n & 1);\n    return 1 if ($n % 11 == 0 || $n % 13 ==\
    \ 0);\n    my $i = 0;\n    while ($n >= 13 && $i < 10) {\n        $i += 1;\n \
    \       $n -= 13;\n    }\n    return $i;\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ code looks like it gives the wrong answer for inputs such as (13,9,7,5,3,1).\
    \ It looks like it returns 0 for these inputs and 1 for other inputs.\n<|/ c |>\n\
    <| c |>\nYes, it does look like it gives the wrong answer for inputs such as (13,9,7,5,3,1).\
    \ The only way I can see that happening is if n is greater than or equal to 10.\
    \ I'll add a comment to the question to address this.\n<|/ c |>\n<| c |>\nThe\
    \ first line should be \n    my $n = (@_ == 1) ? $_[0] : $_[0] % 11;\n<|/ c |>\n\
    <| c |>\nI edited the code to fix it. Thanks.\n<|/ c |>\n<| c |>\nThe first line\
    \ should be:  my $n = (@_ == 1) ? $_[0] : $_[0] % 11;\n<|/ c |>\n<| a tags=perl\
    \ dscore=1 |>\nI hope this is what you are looking for:\n<code>\nuse strict;\n\
    use warnings;\nuse 5.010;", "    my(@numbers) = ($n // 100) * 10 + ($n // 10)\
    \ % 10;\n    foreach my $number (@numbers) {\n        if (($number % 11) == 0)\
    \ {\n            print \"0\";\n        } elsif (($number % 13) == 0) {\n     \
    \       print \"2\";\n        } else {\n            print \"3\";\n        }\n\
    \    }\n    return 1;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=fizzbuzz,perl\
    \ |>\n<code>", "    my $ret = 0;\n    while ($n >= 11) {\n        $ret += $n %\
    \ 11;\n        $n /= 11;\n    }\n    while ($n >= 13) {\n        $ret += $n %\
    \ 13;\n        $n /= 13;\n    }\n    $ret++;\n    return $ret;\n}", "    my $count\
    \ = 0;\n    while ($n) {\n        if ($n % 11 == 0 || $n % 13 == 0) {\n      \
    \      ++$count;\n        }\n        $n = $n / 11;\n    }\n    return $count;\n\
    }", "    $n += 1;\n    until (($n % 11) == 0 or $n % 13 == 0) {\n        $n =\
    \ ($n % 10) + 1;\n    }\n    return $n;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work, try it with e.g. `fizz_buzz(99)` - it returns `1`, when it\
    \ should return `0`. The conditions are wrong.\n<|/ c |>\n<| c |>\nThe conditions\
    \ are correct - the `until` loop terminates as soon as `$n` is `9` or `13` (or\
    \ something that evaluates to `9` or `13` when evaluated as a boolean expression).\n\
    <|/ c |>\n<| c |>\nAh yes. I misread the docs - I thought `until` meant \"loop\
    \ until some condition holds\". My bad.\n<|/ c |>\n<| c |>\nThis code is now incorrect.\
    \  In fact, it's still not correct.  It doesn't return the correct answer.  It\
    \ returns 0 for fizz buzz on 9 and 13, which is not correct.\n<|/ c |>\n<| c |>\n\
    It is not correct - it returns `0` for fizz buzz on 9 and 13.  It *does* return\
    \ 0 for fizz buzz on 50 (which isn't correct, either)\n<|/ c |>\n<| a |>\n<code>",
  "    my $count = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        if ($i !~ m/^(7|8)\\\
    |(9|10|11|12)$/) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", '    my($count_7);', "    return 0 if $n <= 10;\n    return 0 if $n % 11 ==\
    \ 0;\n    return 0 if $n % 13 == 0;\n    $n -= $n % 11;\n    return 0 if $n %\
    \ 7 == 0;\n    return 1 if $n % 7 == 1;\n    return 2;\n}", "    my $count = 1;\n\
    \    my @numbers = map {$_ % 11 == 0 || $_ % 13 == 0 ? $_ : 0} 1 .. $n;\n    foreach\
    \ my $num (@numbers) {\n        next if $num == 0;\n        $count += ($num %\
    \ 11 == 0 && $num % 13 == 0) ? 1 : 0;\n    }\n    return $count;\n}", "    \n\
    \    my $count = 0;\n    while ($n != 0) {\n        $n = $n / 11;\n        $count++;\n\
    \    }\n    \n    while ($n % 11 == 0 || $n % 13 == 0) {\n        $count++;\n\
    \        $n = $n / 11;\n    }\n    \n    return $count;\n}\n</code>\n<|/ a tags=math,ruby\
    \ |>\n<| c |>\nThank you so much! I'm still pretty new to programming and just\
    \ want to make sure I fully understand your answer. I think I understand most\
    \ of it, but why do you have a \"while\" statement inside an \"if\" statement?\
    \ Does that mean that if the first condition is met but the second isn't met then\
    \ it doesn't matter what happens to the rest?\n<|/ c |>\n<| c |>\nIf something\
    \ is false, then the loop will stop. `if` statements are used to control which\
    \ code is run when the condition is true. In the case of a `while` loop, the loop\
    \ will iterate until the condition is false. `if` statements are used to control\
    \ which code is run when the condition is true.\n<|/ c |>\n<| a |>\nRuby has built\
    \ in methods for division and modulus and will work fine for this case.\n<code>\n\
    def fizz_buzz(n)\n  if n % 11 == 0 || n % 13 == 0\n    n.to_s.scan(/7/).size\n\
    \  else\n    n.to_s.scan(/7/).size + 1\n  end\nend", "    my($count) = 0;\n  \
    \  my($i) = 0;", "    my($fizz_buzz);\n    my $fizzy_buzz;", "    my $count =\
    \ 0; # Initialize count to 0\n    for (my $i = 1; $i <= $n; ++$i) { # Loop through\
    \ all integers from 1 to n\n        if ($i % 11 == 0 or $i % 13 == 0) { # If the\
    \ integer is divisible by 11 or 13, count it\n            $count++; # Increment\
    \ count by 1\n        }\n    }\n    return $count; # Return the count\n}", " \
    \   $n =~ tr/7-9//d;\n    my $result = $n >= 11 ? $n+1 : $n;\n    return $result;\n\
    }", "    my(@result) = (0, 0);\n    for my $i (1..$n) {\n        if ($i % 11 ==\
    \ $i % 13) {\n            push(@result, 1);\n        }\n        elsif ($i % 11\
    \ == 0) {\n            push(@result, 2);\n        }\n        elsif ($i % 13 ==\
    \ 0) {\n            push(@result, 3);\n        }\n        else {\n           \
    \ push(@result, $i);\n        }\n    }\n    return scalar;\n}", "    return 0\
    \ unless $n =~ /^\\d+$/;\n    return 0 unless $n % 11 == 0 || $n % 13 == 0;\n\
    \    return 2 unless ($n % 10 == 7);\n    return 3 unless ($n % 10 == 9);\n  \
    \  return 4 unless ($n % 10 == 11);\n    return 5 unless ($n % 10 == 13);\n  \
    \  return 6;\n}\n</code>\n<|/ a tags=optimization,modulus,perl,fizzbuzz |>\n<|\
    \ a |>\n<code>", "    my $count = 0;\n    while (@ints < $n and @ints++ % 11 ==\
    \ 0 or @ints++ % 13 == 0) { $count++ }\n    return $count;\n}", "    $n += 0;\
    \  # make sure it gets passed as an integer\n    if ($n <= 0 || $n >= 100) { return\
    \ ''; }\n    return 1 if $n =~ /11$/;\n    return $n =~ /13$/;\n    return 0 if\
    \ $n % 11 == 0;\n    return 1 if $n % 13 == 0;\n    return 2;\n}", '    my($i)
    = 0;', "    my %hash;\n    my @digits = ();", "    return 0 unless $n;\n    ($n\
    \ % 11 == 0 && !($n % 13) == 0) ? 0 : $n % 13;\n}", "    my $cnt = 0;\n    while($n\
    \ < 100) {\n        $cnt += ($n & 1) and $n // 10;\n        $n += $n & 3 or -$n;\n\
    \        $cnt += $n // 11 and $n // 13;\n        $n += $n // 12 or $n // 13;\n\
    \    }\n    return $cnt;\n}", '    my $count = 0;', "    return 0 unless $n;\n\
    \    return $n if $n =~ /^-?\\d+$/;\n    return 0 if $n % 11 == 0 or ($n % 13\
    \ == 0 and $n / 13 == 1);\n    return $n % 11;\n}", '    my($digit);', "    return\
    \ $n if $n < 10;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n\
    \ / 11 + $n % 11;\n}", "    if ($n % 11 == 0 || $n % 13 == 0) {\n        return\
    \ 0;\n    }\n    return 1 if ($n <= 9);\n    my @nums = split //,$n;\n    for\
    \ (my $i = 0; $i < $#nums; $i++) {\n        if ($nums[$i] % 11 == 0 || $nums[$i]\
    \ % 13 == 0) {\n            $nums[$i] = 0;\n        } else {\n            $nums[$i]\
    \ = 1;\n        }\n    }\n    $n = join '',@nums;\n    return scalar(split //,\
    \ $n);\n}", '    return $n if $n > 0;', "    my(@digits) = grep(defined $_, split('',\
    \ $n));\n    my($ndigits, $ntimes, $firstdigit);", "    return undef if $n <=\
    \ 0;\n    return undef if $n % 11 == 0 && $n % 13 == 0;\n    my $count = 0;\n\
    \    while ($n % 11 != 0) {\n        $n /= 11;\n        $count++;\n    }\n   \
    \ while ($n % 13 != 0) {\n        $n /= 13;\n        $count++;\n    }\n    return\
    \ $count;\n}", "    $n =~ /\\b(11|13)\\b.*(\\b7\\b)/;\n    return length($2);\n\
    }", "    $n =~ tr/7/7/;\n    $n++ if $n =~ m/^(1|11|13)$/;\n    return $n\n}\n\
    </code>\n<|/ a dscore=2 tags=fizzbuzz,perl |>\n<| a dscore=2 |>\nThis should do\
    \ the trick:\n<code>\nuse strict;\nuse warnings;", "    my $count = 0;\n    for\
    \ my $i (0..$n-1) {\n        my($div) = $i % 11;\n        my($mod) = $i / 11;\n\
    \        if ($mod != 0 || $div != 7) {\n            ++$count;\n        }\n   \
    \ }\n    return $count;\n}", "    my(@return) = ();\n    for(my $i = 1; $i < $n;\
    \ $i++) {\n        if($i =~ m/^(11|13)/) {\n            push(@return, $i);\n \
    \       }\n        elsif ($i % 11 == 0) {\n            push(@return, $i);\n  \
    \      }\n        else {\n            push(@return, sprintf('%d', $i % 11));\n\
    \        }\n    }\n    return scalar(@return);\n}", "    return $n =~ tr/1111/11111/;\n\
    }", "    my $count = 0;\n    while ($n % 11 == 0 || $n % 13 == 0) {\n        $count++;\n\
    \        $n /= 11;\n    }\n    $count += $n % 7 == 0;\n    return $count;\n}",
  "    my $count = 1;\n    $n = $n =~ s/^0+/0/;\n    my @digits = split //, $n;\n\
    \    foreach (@digits) {\n        $count++ if $_ % 11 == 0 && $_ % 13 == 0;\n\
    \    }\n    return $count;\n}", "    return 0 if $n % 11 == 0;\n    return 0 if\
    \ $n % 13 == 0;\n    return $n % 7;\n}", "    $n =~ tr/13/1/;\n    $n =~ tr/11/1/;\n\
    \    return $n if $n % 11 == 0 && $n % 13 == 0;\n    $n =~ tr/7/1/;\n    return\
    \ $n if $n % 11 == 0 && $n % 13 == 0;\n    return 0;\n}", "    my $result = 0;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        my $num = $i;\n        if ($i\
    \ % 11 == 0 && $i % 13 == 0) {\n            $result ++;\n        }\n        if\
    \ ($i % 11 == 0) {\n            $result ++;\n        }\n        if ($i % 13 ==\
    \ 0) {\n            $result ++;\n        }\n        if ($num == 13) {\n      \
    \      $result ++;\n        }\n        if ($num == 11) {\n            $result\
    \ ++;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=if-statement,perl,while-loop\
    \ |>\n<| c |>\nThanks guys!  Now to try and figure out how I can add that to the\
    \ other functions I have.\n<|/ c |>\n<| a tags=if-statement,perl,while-loop |>\n\
    You can use the modulus operator % in combination with a loop. \n<code>\nwhile\
    \ ($num != 0) {\n    if ($num % 11 == 0 && $num % 13 == 0) {\n        print \"\
    Fizz Buzz\\n\";\n    }\n    if ($num % 11 == 0) {\n        print \"Fizz\\n\";\n\
    \    }\n    if ($num % 13 == 0) {\n        print \"Buzz\\n\";\n    }\n    if ($num\
    \ % 5 == 0) {\n        print \"Buzz\\n\";\n    }\n    print \"$num\\n\";\n   \
    \ $num--;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=if-statement,perl,while-loop\
    \ |>\nI understand that you want a way to determine if your number is a fizz buzz\
    \ number. \nHere's one way of doing it\n<code>", "    my($n) = ($n < 10) ? $n\
    \ : 10; # Make sure it's a whole number", "    my($fizz, $buzz, $count);\n   \
    \ $fizz = ++$fizz if $n =~ m/(?:[1-8]|9[12])/;\n    $buzz = ++$buzz if $n =~ m/(?:1|3|5|7|9)/;\n\
    \    $count = $fizz if $n =~ m/7$/;\n    $count = $buzz if $n =~ m/1|3|5|7|9$/;\n\
    \    return $count;\n}", "    $n += 0;\n    return 0 if $n =~ /^\\s*$/;\n    return\
    \ 0 if $n =~ /[\\[\\]]/;\n    my($digits) = $n =~ /\\d/g;\n    return 0 if $digits\
    \ < 13;\n    return 0 if $digits % 11;\n    return $digits % 13;\n}", "    my\
    \ ($divisible_by_11_and_13, $counter);\n    for (0 .. $n) {\n        $divisible_by_11_and_13\
    \ = ($_ % 11 == 0 or $_ % 13 == 0);\n        $counter++;\n        if ($divisible_by_11_and_13)\
    \ {\n            return $counter;\n        }\n    }\n    return 0;\n}", "    my($count,\
    \ $divider, $divider_mod);\n    my($min) = @_;\n    # Divide the number by 10\
    \ until it is less than or equal to n, then subtract 1 from it\n    do {\n   \
    \     $count = -1;\n        $min = $n / 10;\n        $n = $n % 10;\n        $divider\
    \ = $min;\n        $divider_mod = $min;\n        while ($divider_mod % 11 != 0\
    \ || $divider_mod % 13 != 0) {\n            $divider /= 10;\n            $divider_mod\
    \ /= 10;\n        }\n        $count += $n % 7;\n    } while ($count != 0 && $divider\
    \ != $min);\n    return $count;\n}", "    return 0 if $n % 11 == 0;\n    return\
    \ 0 if $n % 13 == 0;\n    return 2;\n}", "    my $n = defined($n) ? $n : 0;\n\
    \    my $fizz_buzz_num = 0;\n    \n    for(my $i = 1; $i <= $n; $i++) {\n    \
    \    $fizz_buzz_num += int(($i % 11) == 0);\n        $fizz_buzz_num += int(($i\
    \ % 13) == 0);\n    }\n    \n    return $fizz_buzz_num;\n}", "    my(@digits)\
    \ = ();\n    my(@count) = (0, 0);\n    my(@digits) = grep($n & 0x0F, 1 .. 0x3F);\n\
    \    foreach $digit (@digits) {\n        if ($digit == 0x07) {\n            $count[0]\
    \ += 1;\n        } else {\n            $count[1] += 1;\n        }\n    }\n   \
    \ return $count[0] <= $count[1] ? $count[0] : $count[1];\n}", "    my($i);\n \
    \   \n    $n = int($n);\n    $i = 0;\n    \n    while(1) {\n        my $m = $n\
    \ / 11;\n        if ($m == 0) {\n            $n = $n % 11;\n            $i++;\n\
    \        } elsif ($m == 1) {\n            $n = $n % 11;\n            $i++;\n \
    \       } elsif ($m == 2) {\n            $n = $n % 13;\n            $i++;\n  \
    \      } else {\n            $n = $n % 13;\n            $i++;\n        }\n   \
    \     last if ($n > 0);\n    }\n    return $i;\n}\n</code>\n<|/ a dscore=1 tags=integer,math,fizzbuzz,perl\
    \ |>\n<| a dscore=0 tags=integer,math,fizzbuzz,perl |>\n<code>", "    $n *= 1000;\
    \ # convert $n to a number\n    $n = 1 if $n % 11 != 0 or $n % 13 != 0; # return\
    \ 1 if n is divisible by 11 or 13\n    $n++ while ($n / 13) != 0 or $n % 13; #\
    \ increment $n by 1 when n is divisible by 13\n    return $n;\n}", "    return\
    \ 0 unless $n;\n    return 1 if ($n % 11 == 0 && $n % 13 == 0);\n    return 2\
    \ if ($n % 11 == 1);\n    return 3 if ($n % 13 == 1);\n    return 4;\n}", "  \
    \  my $count = 0;\n    while ($n >= 100 && $n <= 999) {\n        if ($n % 11 ==\
    \ 0) {\n            $count++;\n        }\n        if ($n % 13 == 0) {\n      \
    \      $count++;\n        }\n        $n /= 10;\n    }\n    return $count;\n}\n\
    </code>\n<|/ a tags=digit,perl,string,fizzbuzz,numbers |>\n<| a tags=digit,perl,string,fizzbuzz,numbers\
    \ |>\nHere is another way to do it using recursion. I've tried writing it in perl\
    \ and python, maybe I made some mistakes, but the idea is clear. \n<code>", " \
    \   my(@result) = ($n = 0);\n    $n = 1 if $n =~ /^\\d+$/;\n    my $count = 11;\n\
    \    if ($n % 11 == 0){\n        $count += 1;\n    }\n    if ($n % 13 == 0){\n\
    \        $count += 1;\n    }\n    if ($count <= $n) {\n        push(@result, $count);\n\
    \    }\n    return @result;\n}", "    my $count = 0;\n    while ($n =~ /7\\s/)\
    \ {\n        $count++;\n    }\n    return $count;\n}", '    my $i;', "    my(@c)\
    \ = ( \"11\", \"13\" ); # add more as needed\n    my $count = 0;\n    my $i;\n\
    \    for ($i = 1; $i <= $n; $i += 1000) {\n        my $j;\n        for ($j = 1;\
    \ $j <= 5; $j++) {\n            last if $i % ($c[$j-1] * 10) == 0;\n        }\n\
    \        $count++;\n    }\n    return $count;\n}", "    return $n if $n <= 0;\n\
    \    return $n if $n % 11 == 0;\n    return $n if $n % 13 == 0;\n    return $n\
    \ % 7;\n}", "    my($i, $j, $k, $m, $f, $v) = (0, 1);\n    for (;;) {\n      \
    \  if ($j > $n) {\n            ++$k;\n            $j = $n % $v;\n        }\n \
    \       elsif ($j == 0) {\n            ++$i;\n            $j = $n % $v;\n    \
    \    }\n        else {\n            $m = $j % $v;\n            if ($m == 0) {\n\
    \                ++$i;\n                ++$j;\n                $j = $n % $v;\n\
    \            }\n            else {\n                $f = $j % $v;\n          \
    \      if ($f == 0) {\n                    ++$i;\n                    ++$j;\n\
    \                    ++$k;\n                    $j = $n % $v;\n              \
    \  }\n                else {\n                    ++$i;\n                    ++$j;\n\
    \                    ++$k;\n                    ++$m;\n                    $j\
    \ = $n % $v;\n                }\n            }\n        }\n        last if $j\
    \ == $n;\n    }\n    return $i;\n}", "    \n    # Count how many times it appears\
    \ in integers less than n which are divisible by 11 or 13.\n    return 1 if $n\
    \ % 11 == 0;\n    return 1 if $n % 13 == 0;", "    return if ($n <= 0); # Don't\
    \ go beyond the end\n    return if ($n % 11 == 0 ||\n        $n % 13 == 0);  #\
    \ Don't go beyond the end\n    my @remainders = ($n % 11, $n % 13);  # Get the\
    \ remainders\n    return scalar(grep(/7/, @remainders));  # Return the number\
    \ of times 7 is in one of the remaining digits\n}", "    my(@count) = ('0','1','2','3','4','5','6','7');\n\
    \    my(@digits) = ('0','1','2','3','4','5','6','7','8','9');\n    my(@tens) =\
    \ ('1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80','81','82','83','84','85','86','87','88','89','90','91','92','93','94','95','96','97','98','99','100','101','102','103','104','105','106','107','108','109','110','111','112','113','114','115','116','117','118','119','120','121','122','123','124','125','126','127','128','129','130','131','132','133','134','135','136','137','138','139','140','141','142','143','144','145','146','147','148','149','150','151','152','153','154','155','156','157','158','159','160','161','162','163','164','165','166','167','168','169','170','171','172','173','174','175','176','177','178','179','180','181','182','183','184','185','186','187','188','189','190','191','192','193','194','195','196','197','198','199','200','201','202','203','204','205','206','207','208','209','210','211','212','213','214','215','216','217','218','219','220','221','222','223','224','225",
  "    return $n if $n <= 0;\n    $n % 11 == 0 ? ($n / 11 == 7 ? $n : 0)\n       \
    \            : $n % 13 == 0 ? ($n / 13 == 2 ? $n : 0)\n                   : $n;\n\
    }", "    my($counter);\n    for(my $num = $n; $num; $num--) {\n        if ($num\
    \ % 11 == 0 || $num % 13 == 0) {\n            $counter++;\n        }\n    }\n\
    \    return $counter;\n}", "    my(@result) = (0);\n    while ($n) {\n       \
    \ $n *= 9;\n        my($n) = $n / 10;\n        my($d) = int(($n + 1) / 11);\n\
    \        if ($d && $d % 11 == 0 || $d == 7) {\n            push(@result, $d);\n\
    \        }\n        $n /= 11;\n    }\n    join(\", \", @result);\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nA quick search of the CPAN gives the following\
    \ results:", "    my $num;\n    if ($n < 1) { $num = 0; }\n    elsif ($n <= 19)\
    \ {\n      $num = $n % 11;\n    }\n    elsif ($n <= 39) {\n      $num = $n % 13\
    \ - 11;\n    }\n    elsif ($n <= 49) {\n      $num = $n % 11 - 13;\n    }\n  \
    \  else {\n      $num = $n % 11 - 13;\n    }\n    return $num;\n}", "    my($result);\n\
    \    if ($n =~ /^\\+?\\d+$/) {\n        my $count = 0;\n        $n =~ /11|13/;\n\
    \        while ($n =~ /11|13/) {\n            $count++;\n            $n =~ /11|13/;\n\
    \        }\n        $result = ($count == 0) ? 0 : $count;\n    }\n    else {\n\
    \        $result = -1;\n    }\n    return $result;\n}", "    my $ret = 0;\n  \
    \  my $count_div = 11;\n    my $count_mod;", '    my($c);', "    my($digit) =\
    \ 0;\n    my($retval) = 0;\n    while (0 < $n) {\n        $digit = ($n % 10);\n\
    \        if ($digit == 7) {\n            $retval++;\n        }\n        if ($digit\
    \ == 11 || $digit == 13) {\n            $retval += 3;\n        }\n        $n =\
    \ ($n / 10);\n    }\n    return $retval;\n}", "    for(my $i=0; $i<$n; $i++) {\n\
    \        if ($i % 11 == 0 || $i % 13 == 0) {\n            last if ($i / 11 ==\
    \ $i / 13);\n        }\n        print \"$i\\n\";\n    }\n    return 0;\n}\n</code>\n\
    <|/ a tags=perl |>\n<| c |>\nI thought the question was for a single digit count.\
    \ But the question asks for the number of times _both_ digits 7 appear in the\
    \ input. Your solution will correctly find fizz_buzz(78), but not fizz_buzz(78).\n\
    <|/ c |>\n<| c |>\nI changed my answer according to my comments.\n<|/ c |>\n<|\
    \ c |>\nThis still doesn't work. It doesn't work for `fizz_buzz(78)` and it also\
    \ doesn't work for `fizz_buzz(79)`.\n<|/ c |>\n<| c |>\nI changed my answer according\
    \ to my comments.\n<|/ c |>\n<| c |>\nI changed my answer according to my comments.\n\
    <|/ c |>\n<| a dscore=0 |>\nIn case you do not want the solution with the modulus\
    \ (%) operator and do not want to rely on any module installed, just use a hash:\n\
    <code>\nmy $n = 50;\nmy = ( 1 .. $n );\nmy;\nfor my $digit ( ) {\n    if ( $digit\
    \ == 7 ) {\n        if ( ! $count{ $digit } ) {\n            $count{ $digit }\
    \ = 1;\n        }\n        else {\n            $count{ $digit }++;\n        }\n\
    \    }\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis is essentially the solution\
    \ I went with. It doesn't work for `fizz_buzz(78)`, though.\n<|/ c |>\n<| a tags=perl\
    \ dscore=0 |>\nI realise that this is a fairly old thread but here is another\
    \ solution:\n<code>", "    return 0 unless $n;\n    if ($n % 11 == 0 && $n % 13\
    \ == 0) {\n        $n =~ tr/1113//d;\n        return ($n == 1 ? \"1\" : $n);\n\
    \    }\n    elsif ($n % 11 == 0) {\n        $n =~ tr/11//d;\n        return ($n\
    \ == 1 ? \"1\" : $n);\n    }\n    elsif ($n % 13 == 0) {\n        $n =~ tr/13//d;\n\
    \        return ($n == 1 ? \"1\" : $n);\n    }\n    elsif ($n % 7 == 0) {\n  \
    \      $n =~ tr/7//d;\n        return ($n == 1 ? \"1\" : $n);\n    }\n    return\
    \ $n;\n}", "    if ($n == 0) {\n        $_[0] = 0;\n    }\n    elsif ($n < 0)\
    \ {\n        fizz_buzz(-$n);\n    }\n    elsif ($n >= 100) {\n        fizz_buzz($n\
    \ / 100);\n    }\n    elsif ($n % 11 == 0 || $n % 13 == 0) {\n        $_[0] +=\
    \ 1;\n    }\n    return $_[0];\n}\n</code>\n<|/ a tags=algorithm,fizzbuzz,perl\
    \ dscore=2 |>\n<| a dscore=2 tags=algorithm,fizzbuzz,perl |>\n<code>", "    $n\
    \ = $n % 10;\n    if( $n =~ /^1\\d$/ ) { return(0) }\n    elsif( $n =~ /^1\\d\\\
    d$/ ) { return(2) }\n    elsif( $n =~ /^1\\d\\d\\d\\d$/ ) { return(3) }\n    elsif(\
    \ $n =~ /^11\\d$/ ) { return(1) }\n    elsif( $n =~ /^11\\d\\d$/ ) { return(4)\
    \ }\n    elsif( $n =~ /^11\\d\\d\\d\\d$/ ) { return(5) }\n    elsif( $n =~ /^13\\\
    d$/ ) { return(6) }\n    elsif( $n =~ /^13\\d\\d$/ ) { return(7) }\n    elsif(\
    \ $n =~ /^13\\d\\d\\d\\d$/ ) { return(8) }\n    elsif( $n =~ /^14\\d$/ ) { return(9)\
    \ }\n    elsif( $n =~ /^14\\d\\d$/ ) { return(10) }\n    elsif( $n =~ /^14\\d\\\
    d\\d\\d$/ ) { return(11) }\n    elsif( $n =~ /^15\\d$/ ) { return(12) }\n    elsif(\
    \ $n =~ /^15\\d\\d$/ ) { return(13) }\n    elsif( $n =~ /^15\\d\\d\\d\\d$/ ) {\
    \ return(14) }\n    elsif( $n =~ /^16\\d$/ ) { return(15) }\n    elsif( $n =~\
    \ /^16\\d\\d$/ ) { return(16) }\n    elsif( $n =~ /^16\\d\\d\\d\\d$/ ) { return(17)\
    \ }\n    elsif( $n =~ /^17\\d$/ ) { return(18) }\n    elsif( $n =~ /^17\\d\\d$/\
    \ ) { return(19) }\n    elsif( $n =~ /^17\\d\\d\\d\\d$/ ) { return(20) }\n   \
    \ elsif( $n =~ /^18\\d$/ ) { return(21) }\n    elsif( $n =~ /^18\\d\\d$/ ) { return(22)\
    \ }\n    elsif( $n =~ /^18\\d\\d\\d\\d$/ ) { return(23) }\n    elsif( $n =~ /^19\\\
    d$/ ) { return(24) }\n    elsif", "    return 0 unless $n;\n    return $n if $n\
    \ =~ /^7/;", "    my($i, $divisible, $nfizz, $nbuzz);\n    my($one, $two, $three,\
    \ $four, $five, $six, $seven, $eight, $nine, $ten, $eleven, $twelve, $thirteen,\
    \ $fourteen, $fifteen);\n    my($nfizzbuzz, $nfifthbuzz, $nffifthbuzz, $nsixbuzz,\
    \ $nsevenbuzz, $neightbuzz, $ntenbuzz, $nelevenbuzz, $ntwelvebuzz, $nthreebuzz,\
    \ $nfourteenbuzz, $nfifteenbuzz, $nsixteenbuzz, $nseventeenbuzz, $neighteenbuzz,\
    \ $ntwentybuzz, $nthirtybuzz, $nfourtybuzz, $nfiftybuzz, $nsixtybuzz, $nseventybuzz,\
    \ $neighttybuzz, $nninetybuzz);\n    my($nfizzbuzz, $nfifthbuzz, $nffifthbuzz,\
    \ $nsixbuzz, $nsevenbuzz, $neightbuzz, $ntenbuzz, $nelevenbuzz, $ntwelvebuzz,\
    \ $nthreebuzz, $nfourteenbuzz, $nfifteenbuzz, $nsixteenbuzz, $nseventeenbuzz,\
    \ $neighteenbuzz, $ntwentybuzz, $nthirtybuzz, $nfourtybuzz, $nfiftybuzz, $nsixtybuzz,\
    \ $nseventybuzz, $neighttybuzz, $nninetybuzz);\n    my($nfizzbuzz, $nfifthbuzz,\
    \ $nffifthbuzz, $nsixbuzz, $nsevenbuzz, $neightbuzz, $ntenbuzz, $nelevenbuzz,\
    \ $ntwelvebuzz, $nthreebuzz, $nfourteenbuzz, $nfifteenbuzz, $nsixteenbuzz, $nseventeenbuzz,\
    \ $neighteenbuzz, $ntwentybuzz, $nthirtybuzz, $nfourtybuzz, $nfiftybuzz, $nsixtybuzz,\
    \ $nseventybuzz, $neighttybuzz, $ntenbuzzbuzz, $nelevenbuzzbuzz, $ntwelvebuzzbuzz,\
    \ $nthreebuzzbu", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        if ($i % 11 == 0 && $i % 13 == 0) {\n            $count++;\n        }\n\
    \        if ($i % 11 == 0 && $i % 13 != 0) {\n            $count += 3;\n     \
    \   }\n        if ($i % 13 == 0 && $i % 11 != 0) {\n            $count += 2;\n\
    \        }\n        if ($i % 11 != 0 && $i % 13 != 0) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}\n</code>\n<|/ a tags=math,algorithm,fizzbuzz,modulo,perl\
    \ |>\n<| a dscore=4 |>\nHere's my take on it. It's a little more math-y and less\
    \ Python-like, but hopefully it helps. I made it so you can pass in an array of\
    \ integers to test and the number of tests to run. Hopefully this is what you're\
    \ looking for, anyway. \n<code>", "    my(@numbers) = ();\n    for (my $i = 0;\
    \ $i < $n; $i++) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            push\
    \ @numbers, $i;\n        }\n    }\n    return scalar(@numbers);\n}", "    my $i\
    \ = 0;\n    while ($i <= 9) {\n        if ($n % 11 == $i || $n % 13 == $i) {\n\
    \            $i++;\n        }\n        $n /= 10;\n    }\n    return $i;\n}", " \
    \   my $x = $n;\n    my $count = 0;\n    do {\n        $x /= 11;\n        $x /=\
    \ 13;\n        $count++;\n    } while ($x != 0);\n    return $count;\n}", "  \
    \  return scalar(grep { ( ($n % 11) == 0 && ($n % 13) == 0) || ( ($n % 11) !=\
    \ 0 && ($n % 13) != 0) } 1 .. $n);\n}", "    my $count = 0;\n    while($n < $#_)\
    \ {\n        my $div = $_[$n] % 11;\n        if ($div == 0) {\n            $n++;\n\
    \        }\n        elsif ($div == 1 && $_[$n] == 7) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my(@z) = $n =~ /(?:^|[13579])(7)/ig;\n\
    \    return scalar;\n}\n</code>\n<|/ a dscore=0 tags=perl,fizzbuzz,modulus |>\n\
    <| a dscore=0 |>\nI wanted to give the Perl implementation to Rob William's answer\
    \ but I can't yet comment on his answer, so I have to make my own.  As Rob William\
    \ says, he is using regular expressions.  I wanted to give the exact answer he\
    \ gave in his comment.  (This would not be possible with his regex.)\nThe expression:\n\
    <code>\n(?:^|[13579])(7)\n</code>\nMatches either at the beginning of the string\
    \ or any string that is a multiple of 11, except for the number 7.  The group\
    \ (?:) does non-capturing grouping, but grouping is not needed.  So, the expression\
    \ is the same as:\n<code>\n(^|[13579])(7)\n</code>\nThe ^ is for beginning of\
    \ the string.  The [13579] means match any of the digits 1 or 3 or 5 or 7.  (The\
    \ | means OR, so this matches any digit or 3).  The (7) means match any digits\
    \ 7.  So that regex matches any string that is a multiple of 7.  So the expression\
    \ says \"match 7 at the beginning of the string or that is a multiple of 7\".\n\
    <|/ a tags=perl,fizzbuzz,modulus |>\n<| a dscore=0 |>\n<code>\n perl -lne 'print\
    \ $& if ($& == 7)'\n</code>\n<|/ a tags=perl,fizzbuzz,modulus |>\n<| c |>\nThis\
    \ code uses `-l` to make `print` a one-liner, and a code block where you used\
    \ `print` but didn't use `$&`.  That code is functionally identical to `perl -n\
    \ 'print if ($& == 7)'`, except that the one-liner prints `7`.  So this answer\
    \ is exactly the same as that code block.\n<|/ c |>\n<| a tags=perl,fizzbuzz,modulus\
    \ dscore=0 |>\nThis answer is different than others because it's an example of\
    \ something that you can do without regular expressions. I find it easier to read\
    \ and maintain than regular expressions.\n<code>", "    return 0 if $n % 11 ==\
    \ 0 or $n % 13 == 0;\n    my $count = 0;\n    for (1 .. $n) {\n        if ($_\
    \ % 11 == 0 and $_ % 13 == 0) {\n            $count++;\n        }\n    }\n   \
    \ return $count;\n}", "    my $count = 0;\n    if ($n =~ m!^(\\d+)(\\d*)$!) {\n\
    \tmy $n = ($1);\n\tmy $mod = ($2);\n\tif ($n % 11 == 0 && $n % 13 == 0) {\n\t\
    \    $count++;\n\t} else {\n\t    $n = $n % 11;\n\t}\n    }\n    return $count;\n\
    }", "    return $n++ if $n & 3 == 0 && ($n & 7 == 0 || $n & 13 == 0);\n    $n++;\n\
    \    return $n++ if $n & 3 == 0 && $n & 7 == 0;\n    $n++;\n    return $n++ if\
    \ $n & 3 == 0;\n    $n++;\n    return $n++ if $n & 3 == 0 && $n & 7 == 0 && $n\
    \ & 13 == 0;\n    $n++;\n    return $n++ if $n & 7 == 0;\n    $n++;\n    return\
    \ $n++ if $n & 7 == 0 && $n & 13 == 0;\n    $n++;\n    return $n++ if $n & 13\
    \ == 0;\n    return $n;\n}\n</code>\n<|/ a |>\n<| c |>\nThis answer is really\
    \ cool, thanks for sharing!\n<|/ c |>\n<| a tags=algorithm,recursion,fizzbuzz,c\
    \ |>\n<code>", "    my @digits = (\"7\", \"9\", \"11\", \"13\");\n    my $result\
    \ = 0;", "    if ($n <= 0) {\n        return 0;\n    } elsif ($n >= 100) {\n \
    \       return 6;\n    } elsif ($n >= 10) {\n        return 1;\n    } else {\n\
    \        my(@m) = split //, int($n / 11);\n        my(@n) = split //, int($n %\
    \ 11);\n        return @m + @n unless @m or @n;\n    }\n}", "    return 0 if $n\
    \ <= 1;\n    return 2 if $n <= 3;\n    return 3 if $n <= 9;\n    return 4 if $n\
    \ <= 15;\n    return 5 if $n <= 31;\n    return 6 if $n <= 63;\n    return 7 if\
    \ $n <= 127;\n    return 8 if $n <= 513;\n    return 9 if $n <= 1023;\n    return\
    \ 10 if $n <= 2047;\n    return 11 if $n <= 4095; # No special case for 512\n\
    \    return 13 if $n <= 8191; # No special case for 8192.\n    return 14 if $n\
    \ <= 16383; # No special case for 16384\n    return 15;\n}", "    my($num_times_7);\n\
    \    for(my $i = 0; $i < $n; $i++) {\n        if($i % 11 == 0 ||\n           \
    \ $i % 13 == 0) {\n            push (@results, \"$i\");\n        } else {\n  \
    \          if($i % 7 == 0) {\n                push (@results, \"$i\");\n     \
    \       }\n        }\n    }\n    return $num_times_7;\n}", "    if ( $n % 11 ==\
    \ 0 && $n % 13 == 0 ) {\n        return 0;\n    }\n    my($i);\n    if ( $n <\
    \ 13 ) {\n        $i = $n;\n    } else {\n        $i = $n % 11;\n    }\n    for\
    \ ( 1 .. 10 ) {\n        return $i if $i % 10 == 0;\n        $i /= 10;\n    }\n\
    \    return $n;\n}\n</code>\n<|/ a tags=fizzbuzz,perl |>\n<| a tags=fizzbuzz,perl\
    \ |>\nFor completeness, a more Perlish version of the original code using List::MoreUtils::any:\n\
    <code>\nuse strict;\nuse warnings;\nuse List::MoreUtils 'any';", "    my $count\
    \ = 0;\n    while ($n > 10) {\n        if ($n % 11 == 0 && $n % 13 == 0) {\n \
    \           $count++;\n        }\n        $n = $n / 10;\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=2 tags=perl,fizzbuzz |>\n<| c |>\nThe `while` loop is\
    \ totally useless. Just check the last digit and exit as soon as that digit is\
    \ a 3.\n<|/ c |>\n<| a |>\nHere is a recursive solution that returns the fizzbuzz\
    \ number in $n if possible, otherwise it returns a negative number indicating\
    \ an error. \n<code>", "    my $count = 0;\n    for (1 .. $n) {\n        my $digit\
    \ = int(($n % 10) % 11);\n        if ($digit == 7) {\n            ++$count;\n\
    \        }\n        $n /= 10;\n    }\n    return $count;\n}", "    my $fizz =\
    \ 0;\n    my $buzz = 0;\n    my $i = 1; # Loop variable for the number\n    while($i\
    \ < $n) {\n        if ($i % 11 == 0 && $i % 13 == 0) {\n            $fizz++;\n\
    \        }\n        elsif ($i % 11 == 0 || $i % 13 == 0) {\n            $buzz++;\n\
    \        }\n        $i++;\n    }\n    return $fizz + $buzz;\n}", "    return 0\
    \ if $n < 10;\n    return 1 if $n <= 19;\n    return 2 if $n <= 39;\n    return\
    \ 3 if $n <= 59;\n    return 4 if $n <= 79;\n    return 5 if $n <= 89;\n    return\
    \ 6 if $n <= 99;\n    return 7 if $n <= 199;\n    return 8 if $n <= 499;\n   \
    \ return 9 if $n <= 799;\n    return 10 if $n <= 1000;\n    return 11 if $n <=\
    \ 1400;\n    return 12 if $n <= 1900;\n    return 13 if $n <= 2300;\n    return\
    \ 14 if $n <= 2900;\n    return 15 if $n <= 3900;\n    return 16 if $n <= 4990;\n\
    \    return 17 if $n <= 7990;\n    return 18 if $n <= 11990;\n    return 19 if\
    \ $n <= 13990;\n    return 20 if $n <= 17990;\n    return 21 if $n <= 21990;\n\
    \    return 22 if $n <= 23990;\n    return 23 if $n <= 27900;\n    return 24 if\
    \ $n <= 29900;\n    return 25 if $n <= 39999;\n    return 26 if $n <= 49900;\n\
    \    return 27 if $n <= 79900;\n    return 28 if $n <= 999999;\n    return 29\
    \ if $n <= 199999;\n    return 30 if $n <= 2999999;\n    return 31 if $n <= 3999999;\n\
    \    return 32 if $n <= 4999999;\n    return 33 if $n <= 7999999;\n    return\
    \ 34 if $n <= 11999999;\n    return 35 if $n <= 13999999;\n    return 36 if $n\
    \ <= 17999999;\n    return 37 if $n <= 21999999;\n    return 38 if $n <= 25999999;\n\
    \    return 39 if $n <= 30000000; # FizzBuzz\n}", "    my $count = 0;\n    $n\
    \ = $n % 11;\n    return 1 if ($n < 13);\n    $n = $n % 7;\n    return 1 if ($n\
    \ < 5);\n    return $count;\n}", '    my($i);', "    return 0 unless $n;\n   \
    \ $n % 11 == 0 && $n % 13 == 0 ? 0 : 1 if ($n =~ /^\\d+$/);\n    my $count = 0;\n\
    \    while ($n-- > 0) {\n        if ($n =~ /^(11|13)$/) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    return unless $n > 1;\n    return\
    \ 1 unless $n =~ /^[13579][13579]*$/;", "    if ($n =~ /^[1-9][0-9]*$/) {\n  \
    \      if ($n =~ /3$/i) {\n            $n++;\n        }\n        if ($n =~ /7$/i)\
    \ {\n            $n++;\n        }\n        return $n;\n    }\n    return 0;\n}",
  "    my @a = ( $n % 11, $n % 13 );\n    my $count = () = ( grep { $_ == 1 } @a );\n\
    \    return $count;\n}", "    my $count = 0;\n    for (my $i = 0; $i <= $n; $i++)\
    \ {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            $count++;\n    \
    \    }\n    }\n    return $count;\n}", "    if ($n =~ /^\\d+$/) {\n        if\
    \ ($n % 11 == 0)    {$n = 0}\n        elsif ($n % 13 == 0)  {$n = 2}\n       \
    \ else {$n = 0}\n    }\n    return $n;\n}", "    return if $n <= 0;\n    return\
    \ 0 if $n & 1;\n    return 1 if $n & 2;\n    return 2 if $n & 4;\n    return 3\
    \ if $n & 8;\n    return 4 if $n & 16;\n    return 5 if $n & 32;\n    return 6\
    \ if $n & 64;\n    return 7 if $n & 128;\n}", "    my($n3);\n    my($digit) =\
    \ 11 if $n % 11 == 0;\n    my($digit) = 13 if $n % 13 == 0;\n    my $count = 0;",
  "    $n -= 1;\n    return $n if ($n <= 0);\n    my($remainder) = $n % 11;\n    $n\
    \ /= 11;\n    return $n if ($remainder == 7 && $n % 13 == 0);\n    my($remainder)\
    \ = $n % 13;\n    $n /= 13;\n    return $n if ($remainder == 7);\n    return $n;\n\
    }\n</code>\n<|/ a tags=perl,fizzbuzz dscore=3 |>\n<| c |>\nIf you don't want a\
    \ functional approach and just want to get an answer, why not just do `print \"\
    Fizz\" if $number % 3 == 0; print \"Buzz\" if $number % 5 == 0; print \"FizzBuzz\"\
    \ if $number % 3 == 0 && $number % 5 == 0;`?\n<|/ c |>\n<| c |>\nI honestly can't\
    \ tell which approach is better :) I was trying to be more verbose. I've updated\
    \ my post to include my \"pure\" solution.\n<|/ c |>\n<| c |>\nWell, one big advantage\
    \ of your functional approach is that it doesn't require any explicit looping.\
    \ :)\n<|/ c |>\n<| c |>\n: Yes, but it's only being called three times. So why\
    \ not just do that?\n<|/ c |>\n<| c |>\n: It's much more expressive and readable.\
    \ I don't know if that matters or not, but I do like your approach.\n<|/ c |>\n\
    <| a tags=perl,fizzbuzz |>\nA simple Perl solution would be to use a while loop\
    \ to go through the numbers, checking the modulo of each number with the numbers\
    \ of \"Fizz\" and \"Buzz\". I made an example below using integers, but the same\
    \ holds for floats and strings. \n<code>\nuse strict;\nuse warnings;\nuse feature\
    \ 'say';", "    return 1 unless $n;\n    my @primes = (11, 13, 17);", "    return\
    \ 0 if $n eq 'zero';\n    $n = $n - 5 if $n < 10;\n    $n % 11 == 0 && $n % 13\
    \ == 0 ? $n : 0;\n}", "    if ( $n % 11 eq 7 or $n % 13 eq 7 ) {\n        return\
    \ 0;\n    }\n    my $count;\n    foreach my $num ( 1 .. $n ) {\n        if ( $num\
    \ % 11 eq 7 and $num % 13 eq 7 ) {\n            ++$count;\n        }\n    }\n\
    \    return $count;\n}", "    return 0 unless defined $n;\n    my $count = 0;",
  "    return 1 if $n%11==$n%13 and $n!=11;\n    return 2 if $n%13==$n%11 and $n!=13;\n\
    \    return 3;\n}", "    my $fizz = 1 if $n % 11 == 0;\n    my $buzz = 1 if $n\
    \ % 13 == 0;\n    return $fizz + $buzz;\n}", "    if ($n <= 0) {\n        return\
    \ 0;\n    }\n    my $n = $n;\n    my $num_divisors = 0;\n    while ($n % 11 ==\
    \ 0 || $n % 13 == 0) {\n        $num_divisors += 1;\n        $n = ($n->next -\
    \ 1) // $n;\n    }\n    return $num_divisors;\n}", "    $n++ while $n < 100 &&\
    \ $n % 11 == 0 || $n % 13 == 0;\n    return $n;\n}", "    my $num_buzz = 0;\n\
    \    if ($n <= 1) {\n        return $num_buzz;\n    }", "    my @ans = ();\n \
    \   my($i);", "    my(@result) = (0);\n    for (my $i = 1; $i < $n; ++$i) {\n\
    \        my($result) = $i % 11 ? $i % 13 : 0;\n        push(@result, $result);\n\
    \    }\n    return @result;\n}", "    my $count = 0;\n    while ($n % 10 == 7\
    \ && $n % 11 == 0 && $n % 13 == 0) {\n        $count += 1;\n        $n /= 10;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like your\
    \ answer, but how does this compare to other answers?\n<|/ c |>\n<| c |>\nMy answer\
    \ is short and sweet and doesn't rely on any non-core functionality. I don't see\
    \ how it compares to other answers.\n<|/ c |>\n<| c |>\nMy answer was more compact\
    \ but more verbose than those in other answers. I just wondered which of these\
    \ other answers was better and why.\n<|/ c |>\n<| c |>\nAh I see. Well, I suppose\
    \ the short and sweet part isn't the biggest problem with the other answers. I\
    \ just thought that I was missing a neat way to do it in perl.\n<|/ c |>\n<| c\
    \ |>\nYes, you can do it in one line: `$count += ($n % 10 == 7 && $n % 11 == 0\
    \ && $n % 13 == 0) ? 1 : 0;` This is pretty readable and simple. It doesn't need\
    \ a while loop and is a single statement with no braces.\n<|/ c |>\n<| a tags=perl,fizzbuzz,numbers\
    \ |>\nI think this would do it:\n<code>\nuse strict;\nuse warnings;", "    my\
    \ $count = 0;\n    while ($n =~ /11|13/) {\n        $count++;\n        $n =~ s/11|13//;\n\
    \    }\n    $count;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this may answer\
    \ the question, code only answers are not useful on SO.  Please explain why your\
    \ answer is correct.\n<|/ c |>\n<| c |>\nThis is an answer to the question.  It\
    \ explains how to do what they wanted.  They were asking about how to solve the\
    \ problem.  They gave their solution.  They gave their code.  They asked for a\
    \ review.  This is all they needed.\n<|/ c |>\n<| c |>\nI added some explanation.\
    \  I hope it's clearer now.  Thanks for bringing that up.\n<|/ c |>\n<| c |>\n\
    Thanks for the explanation, this does solve the problem and is a much more efficient\
    \ method.\n<|/ c |>\n<| c |>\nThank you for improving the code.\n<|/ c |>\n<|\
    \ a |>\n<code>", '    my($remainder);', "    my(@nums) = ($n =~ /\\d{7}/g);\n\
    \    my(@nums_divisible_by_11_or_13 = ());\n    foreach my $num (@nums) {\n  \
    \      my $is_divisible_by_11_or_13 = ($num % 11 == 0) || ($num % 13 == 0);\n\
    \        push(@nums_divisible_by_11_or_13, $is_divisible_by_11_or_13);\n    }\n\
    \    return scalar(keys %nums_divisible_by_11_or_13);\n}", '    my $s = 0;', " \
    \   my(@result) = (0);\n    my($fizz_count = 1);\n    my($buzz_count = 1);\n \
    \   for (my $i = 1; $i < $n; $i++) {\n        if ($i % 11 == 0) {\n          \
    \  $buzz_count++;\n        } elsif ($i % 13 == 0) {\n            $fizz_count++;\n\
    \        } elsif ($i % 7 == 0) {\n            $buzz_count++;\n            $fizz_count++;\n\
    \        } else {\n            $buzz_count = 1;\n        }\n        push(@result,\
    \ \"$fizz_count\");\n        push(@result, \"$buzz_count\");\n    }\n    return\
    \ @result;\n}", "    my $count = 0;\n    my $remainder = 0;\n    while($remainder\
    \ != $n && ($n % 11) == 0){ # n is divisible by 11\n        $count++;\n      \
    \  $n = int($n/11);\n    }\n    while($remainder != $n && ($n % 13) == 0){ # n\
    \ is divisible by 13\n        $count++;\n        $n = int($n/13);\n    }\n   \
    \ return $count;\n}", "    return 1 if ($n == 0) or $n % 11 == 0;\n    return\
    \ 1 if ($n == 0) or $n % 13 == 0;\n    return 0 if ($n == 1);\n    return $fizz_buzz($_)\
    \ for ($n-1..$n);\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,fizzbuzz dscore=2\
    \ |>\nThis is not as concise as a solution in the accepted answer, but here is\
    \ an approach that does not require the use of the fizzbuzz method or any other\
    \ external methods:\n<code>\ndef fizzbuzz(n)\n  (1..n).map {|n| n % 3 == 0 ? \"\
    Fizz\" : n % 5 == 0 ? \"Buzz\" : \"#{n}\"}.join(\", \")\nend\n</code>\nThis simply\
    \ maps every number from 1 to n to either \"Fizz\", \"Buzz\", or \"n\", and then\
    \ joins them with a comma, e.g. for fizzbuzz(25) it would return \"1, 2, Fizz,\
    \ 4, Buzz\". You can easily adapt this to your needs.\n<|/ a |>\n<| a tags=ruby,fizzbuzz\
    \ |>\nI like how you gave a general solution to FizzBuzz and tried to generalize\
    \ it for the specific case of numbers that don't divide by three or five. Here's\
    \ a more general solution which generalizes the idea of FizzBuzz:\n<code>\ndef\
    \ fizzbuzz(n)\n  num = (1..n).map {|n| n % 3 == 0 ? 'Fizz' : n % 5 == 0 ? 'Buzz'\
    \ : n}\n  num.join(',')\nend\n</code>\nThe above solution generalizes the idea\
    \ of FizzBuzz, even though the code does some redundant calculations to get the\
    \ fizz and/or buzz strings. This can be modified to generalize the idea of FizzBuzz\
    \ and get the fizz string only if the number can be divided by three:\n<code>\n\
    def fizzbuzz(n)\n  num = (1..n).map {|n| n % 3 == 0 ? 'Fizz' : n}\n  num.join(',')\
    \ if num.grep(/Fizz|Buzz/).size > 0\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,fizzbuzz\
    \ |>\nHere is a simple solution that uses the fizzbuzz method described in the\
    \ accepted answer:\n<code>\ndef fizzbuzz(n)\n  n = 3*(n-1).div(5)\n  return if\
    \ n.zero?\n  n ", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        if ($i % 11 == 0 || $i % 13 == 0) {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}\n</code>\nI hope it helps you understanding the\
    \ problem.\n<|/ a dscore=1 |>\n<| c |>\nThanks, this is very helpful.  I should\
    \ have explained what I am looking for in the question.  What I am trying to do\
    \ is find the number of times the digit 7 appears before the digit 8 which equals\
    \ the integer less than 8 which can be divisible by 11 or 13.  So, if I pass \"\
    78\" it should return 2.  I added comments to my question to clarify what I am\
    \ looking for in more detail.\n<|/ c |>\n<| c |>\n: OK, that's not hard to do.\
    \ One moment...\n<|/ c |>\n<| c |>\n: So you want the number of times 7 is repeated\
    \ before 8, not the number of times 7 is divisible by 11 or 13 before 8?\n<|/\
    \ c |>\n<| c |>\nyes, that is correct, I want the number of times 7 is repeated\
    \ before 8.  It can either be divisible by 11 or 13, but never both.\n<|/ c |>\n\
    <| c |>\n: I've edited my answer to reflect that and also include a solution that\
    \ does the same thing but only checks divisibility by 11 or 13.\n<|/ c |>\n<|\
    \ a |>\n<code>\nmy $n = \"78\";\nmy=grep { (int($n) % 11 !=0 || int($n) % 13 !=\
    \ 0) } split //, $n;\nprint scalar(@arr).\"\\n\";\n</code>\n<|/ a tags=integer,perl,fizzbuzz\
    \ dscore=1 |>\n<| c |>\nWhile this does answer the question, I'm afraid this is\
    \ hardly an improvement over `fizzbuzz(n)`. What is your way of counting numbers\
    \ that are divisible by 11 or 13?\n<|/ c |>\n<| c |>\nI agree with you.  I just\
    \ wanted to show that if his original question was more complex, then the solution\
    \ was a lot simpler than mine.\n<|/ c |>\n<| a tags=integer,perl,fizzbuzz dscore=0\
    \ |>\nTry something like this:\n<code>", "    $n =~ tr/7/7/;\n    if ( $n % 11\
    \ == 0 || $n % 13 == 0 ) {\n        return $n;\n    }\n    return undef;\n}\n\
    </code>\n<|/ a tags=perl,regex |>\n<| c |>\n`tr/7/7/` does not match `7` in the\
    \ digit group `11` or `13`.\n<|/ c |>\n<| c |>\nOh, well it doesn't. Sorry about\
    \ that. Fixed it.\n<|/ c |>\n<| a |>\n<code>\nuse List::MoreUtils qw( grep );",
  "    my $count = 0;\n    \n    # Count how many multiples of 11 are in integer $n.\n\
    \    my $multiple = 0;\n    while ($n > 0 && $multiple != 0) {\n        $multiple++;\n\
    \        $n = ($n % 11);\n    }\n    \n    # Count how many multiples of 13 are\
    \ in integer $n.\n    my $multiple_13 = 0;\n    while ($n > 0 && $multiple_13\
    \ != 0) {\n        $multiple_13++;\n        $n = ($n % 13);\n    }", "    if (\
    \ $n != 0 ) {\n        my $count;\n        if ( $n % 11 == 0 ) {\n           \
    \ $count = 0;\n        }\n        elsif ( $n % 13 == 0 ) {\n            $count\
    \ = 2;\n        }\n        else {\n            $count = 1;\n        }\n      \
    \  $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17\
    \ or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or\
    \ $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or\
    \ $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11\
    \ or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5\
    \ or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11\
    \ or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5\
    \ or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11\
    \ or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5\
    \ or $n%7 or $n%9 or $n%11 or $n%13 or $n%17 or $n%5 or $n%7 or $n%9 or $n%11\
    \ or $n%13 or $", "    my($cnt);\n    if ($n =~ m/^(\\d+)$/) {\n        $cnt =\
    \ $1;\n    }\n    elsif ($n =~ m/^(\\d+)-(\\d+)$/) {\n        $cnt = $1 - $2;\n\
    \    }\n    return $cnt;\n}", "    my $count = ($n / 11) + ($n / 13);\n    return\
    \ $count;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\"the only problem is that\
    \ you're not actually using recursion\" - Actually, he's not using recursion at\
    \ all.  He's using nested `for` loops.  See my answer.\n<|/ c |>\n<| c |>\nHe's\
    \ using recursion to solve a more complex problem, and also nested loops for an\
    \ even simpler problem.\n<|/ c |>\n<| a tags=perl |>\nThe problem is your function\
    \ doesn't return any value.  You set $count to 1 on every call, so it will return\
    \ that value (which happens to be the count you want, except it is 1 more than\
    \ what you want).  You need to actually return the count.  \nAlso, you should\
    \ probably make $n a parameter.  It will be easier to work with if you give the\
    \ function a name which says what it does rather than what it returns.  Something\
    \ like fizz_count($n).\nHere's a revised version of your code which does return\
    \ what you want:\n<code>", '    my($z) = ($n =~ /11|13/);', "    my @digits =\
    \ split(//, \"$n\");\n    my $remainder;", "    if ($n =~ /^-?\\d+$/) {\n    \
    \    if ($n =~ /^(11|13)$/) {\n            $n =~ s/^(11|13)$/1/g;\n        }\n\
    \        my $s = $n % 11;\n        $s = 0 if $s eq 0;\n        $s = $n + $s;\n\
    \        return $s;\n    }\n    return;\n}", '    my $count = 0;', "    my $count\
    \ = 0;\n    my $divisor = 11;\n    my $remainder = $n % $divisor;\n    my $quotient\
    \ = floor($n / $divisor);\n    if ($remainder == 0) {\n        if ($quotient ==\
    \ 1) {\n            $count++;\n        }\n    } elsif ($remainder == 1) {\n  \
    \      $count++;\n    }\n    foreach (grep { $_ ne 7 } 0..11) {\n        $count++\
    \ if ($_ <= $quotient && $_ <= $divisor);\n    }\n    $count;\n}", "    if ($n\
    \ <= 0) {\n        $n = 1;\n    }", '    my($i);', "    my(@digits) = qw(1 2 3\
    \ 4 5 6 7 8 9);\n    my(@buzzes) = qw(1 2 3 4 5 6 7 8 9 10 11 12);\n    my($i,\
    \ $j, @result);\n    \n    for ($i = 0; $n >= 0 && $i <= $#digits; $i++) {\n\t\
    $n = $n % $digits[$i];\n    }\n    for ($i = 0; $n >= 0 && $i <= $#digits; $i++)\
    \ {\n\t$n = $n % $digits[$i];\n\t$n = $n * $buzzes[$i];\n\t$n /= $buzzes[$i];\n\
    \tif ($n < 11) {\n\t    $result[$i] = $n;\n\t}\n    }\n    return @result;\n}",
  "    my ($remainder, $mod11, $mod13) = @_;\n    $n = $n - 1;\n    if ($n < 13) {\n\
    \        $mod11 = 0 if $n <= 11;\n        $mod13 = 0 if $n >= 51;\n        return\
    \ 0 if $mod11;\n        return 0 if $mod13;\n        return 0;\n    }\n    if\
    \ ($n % 13 == 0) {\n        return 1 if $n % 11 == 0;\n    }\n    $mod11 = 0 if\
    \ $n % 11 == 0;\n    $mod13 = 0 if $n >= 51;\n    return 0 if $mod11;\n    return\
    \ 0 if $mod13;\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat is the difference\
    \ between `my($n) = @_; $n = $n - 1;` and `my($n) = @_; $n = $n - 1;`? The second\
    \ one seems much more readable to me.\n<|/ c |>\n<| c |>\nThe difference is the\
    \ second one changes the value of $n without actually changing the argument and\
    \ does not change the arguments passed to that subroutine. Compare `sub foo {\
    \ my($n) = @_; $n = $n - 1; }` and `sub foo { my($n) = @_; $n = $n - 1; }`.\n\
    <|/ c |>\n<| a dscore=2 tags=perl,function |>\nI like using subroutines for this\
    \ sort of thing.  I find that a lot of people forget that subroutines can take\
    \ an argument.  Subroutines are just functions, but they can take a parameter.\
    \  \n<code>", "    return ($n / 11 == $n % 11 ? 0 : ($n / 13 == $n % 13 ? 2 :\
    \ 1));\n}\n</code>\n<|/ a |>\n<| a tags=if-statement,perl dscore=2 |>\n<code>\n\
    if($n % 11 == 0 || $n % 13 == 0) {...}\n</code>\n<|/ a |>\n<| c |>\nThanks, I\
    \ added a comment in the code snippet you provided. Can you please check that?\n\
    <|/ c |>\n<| a tags=if-statement,perl |>\n<code>\nif ($n % 11 == 0 || $n % 13\
    \ == 0) {\n...\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, I added a comment\
    \ in the code snippet you provided. Can you please check that?\n<|/ c |>\n<| c\
    \ |>\nThat's fine. Thank you for that solution. :)\n<|/ c |>\n<| c |>\nGlad to\
    \ help. If my solution helped you, please mark it as accepted by clicking the\
    \ checkmark to the left of the answer.\n<|/ c |>\n<| a dscore=1 |>\nI like to\
    \ use MooseX::Moose for this.\n<code>\nuse strict;\nuse warnings;\nuse MooseX::Moose;",
  "    my(@fizz, $buzz);\n    my $nn = int($n / 10);\n    $n = int($n % 10);\n   \
    \ push (@fizz, $nn) if $nn < 3;\n    push (@buzz, $nn) if $nn > 3 && $nn < 7;\n\
    \    push (@fizz, $nn) if $nn > 7 && $nn < 11;\n    $n = $n % 10;\n    push (@fizz,\
    \ $nn) if $nn < 3;\n    push (@buzz, $nn) if $nn > 3 && $nn < 7;\n    push (@fizz,\
    \ $nn) if $nn > 7 && $nn < 11;\n    $n = $n % 10;\n    push (@fizz, $nn) if $nn\
    \ < 3;\n    push (@buzz, $nn) if $nn > 3 && $nn < 7;\n    push (@fizz, $nn) if\
    \ $nn > 7 && $nn < 11;\n    $n = $n % 10;\n    push (@fizz, $nn) if $nn < 3;\n\
    \    push (@buzz, $nn) if $nn > 3 && $nn < 7;\n    push (@fizz, $nn) if $nn >\
    \ 7 && $nn < 11;\n    $n = $n % 10;\n    push (@fizz, $nn) if $nn < 3;\n    push\
    \ (@buzz, $nn) if $nn > 3 && $nn < 7;\n    push (@fizz, $nn) if $nn > 7 && $nn\
    \ < 11;\n    $n = $n % 10;\n    push (@fizz, $nn) if $nn < 3;\n    push (@buzz,\
    \ $nn) if $nn > 3 && $nn < 7;\n    push (@fizz, $nn) if $nn > 7 && $nn < 11;\n\
    \    $n = $n % 10;\n    push (@fizz, $nn) if $nn < 3;\n    push (@buzz, $nn) if\
    \ $nn > 3 && $nn < 7;\n    push (@fizz, $nn) if $nn > 7 && $nn < 11;\n    $n =\
    \ $n % 10;\n    push (@fizz, $nn) if $nn < 3;\n    push (@buzz, $nn) if $nn >\
    \ 3 && $nn < 7;\n    push (@fizz, $nn) if $nn > 7 && $nn < 11;\n    $n = $n %\
    \ 10;\n    push (@fizz, $nn) if $nn < 3;\n    push (@buzz, $", "    my $count\
    \ = 0;\n    if ($n <= 0) {\n        return $count;\n    }\n    $n = $n % 11;\n\
    \    $n = $n % 13;\n    return $count;\n}\n</code>\nThe subroutine is quite simple.\
    \ It just computes $n mod 11 and $n mod 13 and returns the number of times either\
    \ happens. If either happens then the remainder is discarded.\n<|/ a dscore=1\
    \ |>\n<| c |>\nHi Martin, thanks for your response. I had a feeling that I should\
    \ use modulo arithmetic, but am not too familiar with it yet (I'm still learning).\
    \ Your code does exactly what I was looking for though, thank you.\n<|/ c |>\n\
    <| c |>\nThe modulo operator is very handy. If you want to know how many times\
    \ a certain bit of binary appears in an integer, you can simply do something like\
    \ `my $bit = 2 ^ 5; my $count = sprintf('%010b', $n & $bit)` which would print\
    \ `00000000000000000000000000000010`. This is useful for binary manipulation,\
    \ e.g. determining if a number is odd or even.\n<|/ c |>\n<| a |>\nFor fun, here's\
    \ a version that uses loops and an array.\n<code>", "    my @counts;\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        my $x = $i;\n        $x += ($x % 3 ==\
    \ 0 ? 0 : 1);\n        $x += ($x % 5 == 0 ? 0 : 1);\n        $x += ($x % 7 ==\
    \ 0 ? 0 : 1);\n        $counts[$x]++;\n    }\n    my $i = 0;\n    my @fizz_buzz;\n\
    \    while (@counts > 0) {\n        if (@counts == 1) {\n            push @fizz_buzz,\
    \ $i;\n        }\n        if (@counts == 3) {\n            push @fizz_buzz, $i,\
    \ $i, $i;\n        }\n        if (@counts == 5) {\n            push @fizz_buzz,\
    \ $i, $i, $i, $i;\n        }\n        splice(@counts, 0, 1);\n        $i++;\n\
    \    }\n    return scalar(@fizz_buzz);\n}", "    my $i = 1;\n    while($i <= $n)\
    \ {\n        if($i % 11 == 0 && $i % 13 == 0) {\n            $i++;\n        }\
    \ elsif($i % 11 == 0) {\n            $i++;\n        } elsif($i % 13 == 0) {\n\
    \            $i++;\n        } else {\n            ++$i;\n        }\n    }\n  \
    \  return $i;\n}\n</code>\n<|/ a |>\n<| c |>\nI should point out, however, that\
    \ this is still an inefficient way to do this.  It does have some advantages,\
    \ but it's also a lot of extra work.  For instance, it's less efficient to iterate\
    \ over every digit in the number; a much more efficient way to do this is to simply\
    \ divide by 11 and 13 until you get a remainder of 0.\n<|/ c |>\n<| a |>\n<code>",
  "    $n =~ s/^0*//;\n    $n =~ s/^([1-9][1-9])/$1|$1/ if $n =~ /([1-9][1-9])/;\n\
    \    my $count = 0;\n    while( ($n++ % 11) != 0 or $n++ % 13 != 0) {\n      \
    \  $count++;\n    }\n    return $count;\n}", "    my $s = 0;\n    for (my $i =\
    \ 0; $i < $n; $i++) {\n        $s = ($i % 11 == 0) ? ($i % 13 == 0) ? $i + 1 :\
    \ $i + 1 : ($i % 13 == 0) ? $i + 2 : $i + 3;\n    }\n    return $s;\n}\n</code>\n\
    <|/ a dscore=3 tags=fizzbuzz,loops,perl |>\n<| c |>\nThe ternary operator is not\
    \ needed, and will slow things down.\n<|/ c |>\n<| c |>\nAgreed, but I've been\
    \ taught to do it that way because it's readable and short, and it saves one line!\n\
    <|/ c |>\n<| c |>\n, `( $i % 11 == 0 ) == ( $i % 13 == 0 ) ? $i + 1 : $i + 1`\
    \ saves you three lines by eliminating the ternary operator. `( $i % 11 == 0 )\
    \ == ( $i % 13 == 0 ) ? $i + 2 : 3` saves you one. Your example was only two lines\
    \ long, but that doesn't mean that your code is shorter than it.\n<|/ c |>\n<|\
    \ c |>\n: If you think your code is too long, maybe your algorithm needs rethinking.\
    \ Maybe you should use `List::Util` for it.\n<|/ c |>\n<| c |>\nThis code doesn't\
    \ actually do fizzbuzz. Try it with the numbers 1-100 and you'll see the numbers\
    \ go into fizzbuzz.\n<|/ c |>\n<| a tags=fizzbuzz,loops,perl |>\nHere's one approach,\
    \ using map to rewrite each number using an if/else statement.\n<code>", "   \
    \ # $n >= 1 and $n % 11 == 0 and $n % 13 == 0 \n    return 0 if ($n < 1 or $n\
    \ % 11 == 0 and $n % 13 == 0);\n    # $n % 11 != 0 and $n % 13 != 0 \n    return\
    \ 1 if ($n % 11 != 0 or $n % 13 != 0);\n}", "    my(@list) = ();\n    my($counter)\
    \ = 0;\n    my($digit);\n    foreach $digit (1 .. 9) {\n        if ($n & $digit)\
    \ {\n            $counter += 1;\n        }\n    }\n    foreach $digit (10 .. 21)\
    \ {\n        if ($n & $digit) {\n            $counter += 1;\n        }\n    }\n\
    \    foreach $digit (22 .. 3) {\n        if ($n & $digit) {\n            $counter\
    \ += 1;\n        }\n    }\n    if ($counter >= 3) {\n        $counter = 0;\n \
    \   }\n    if ($counter >= 2) {\n        $counter = 1;\n    }\n    if ($counter\
    \ == 0) {\n        return 0;\n    }\n    if ($counter == 1) {\n        return\
    \ 1;\n    }\n    if ($counter == 2) {\n        return 2;\n    }\n}\n</code>\n\
    <|/ a tags=fizzbuzz,perl |>\n<| c |>\nYeah, this is similar to my solution, but\
    \ the `my` is unnecessary and also the counter variable is reused without being\
    \ reset. The `return` is also unnecessary, because `return` returns from a function\n\
    <|/ c |>\n<| a |>\n<code>\nperl -lne 'if ($F[0] eq \"\") { print \"$_\\n\"; $F[0]\
    \ = $_; } else { if ($F[0] eq \"Fizz\") {print $F[0] \"Fizz\";} else {print $F[0]\
    \ \"Buzz\"; } print \"$_\\n\"; $F[0] = \"\"; }' < fizzbuzz.txt\n</code>\n<|/ a\
    \ dscore=4 tags=fizzbuzz,perl |>\n<| a |>\nHere's an implementation using just\
    \ map:\n<code>\nuse Data::Dumper;", '    my $counter = 0;', "    return 0 unless\
    \ $n;\n    return 2 unless $n & 1;\n    return 3 unless $n & 2;\n    return 4\
    \ unless $n & 4;\n    return 5 unless $n & 8;\n    return 6 unless $n & 16;\n\
    \    return 7 unless $n & 32;\n    return 8 unless $n & 64;\n    return 9 unless\
    \ $n & 128;\n    return 10;\n}", "    my $remainder;\n    my $i = 0;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
