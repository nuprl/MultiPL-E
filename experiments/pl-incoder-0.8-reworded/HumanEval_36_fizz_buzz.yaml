name: HumanEval_36_fizz_buzz
language: pl
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n\
  # 2\n# >>> fizz_buzz(79)\n# 3\nsub fizz_buzz {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fizz_buzz;\n\
  \        if(eq_deeply($candidate->(50),0)) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(78),2)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(79),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(200),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4000),192))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10000),639))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100000),8026))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $count = 0;\n    while ($n >= 11) {\n        $count += $n =~\
    \ /11|13/;\n        $n -= 11;\n    }\n    $count;\n}", "    return 0 unless $n\
    \ > 0;\n    return 0 if ($n % 11 <= 1);", "    my $count = 0;\n    while (my $i\
    \ = $n) { # loop through integers less than $n\n        if ($i % 11 == 0 && $i\
    \ % 13 == 0) { # if integer is divisible by 11 and 13\n            ++$count;\n\
    \        }\n        elsif ($i % 11 == 0) { # if integer is divisible by 11\n \
    \           ++$count;\n        }\n        elsif ($i % 13 == 0) { # if integer\
    \ is divisible by 13\n            ++$count;\n        }\n        elsif ($i % 7\
    \ == 0) { # if integer is divisible by 7\n            ++$count;\n        }\n \
    \       elsif ($i % 5 == 0) { # if integer is divisible by 5\n            ++$count;\n\
    \        }\n        elsif ($i % 3 == 0) { # if integer is divisible by 3\n   \
    \         ++$count;\n        }\n        elsif ($i % 2 == 0) { # if integer is\
    \ divisible by 2\n            ++$count;\n        }\n        elsif ($i % 1 == 0)\
    \ { # if integer is divisible by 1\n            ++$count;\n        }\n       \
    \ elsif ($i == 0) { # if integer is 0\n            ++$count;\n        }\n    \
    \    else { # if integer is not divisible by 1, 2, 3, 4 or 5 and it is not divisible\
    \ by 11 or 13\n            ++$count;\n        }\n    }\n    return $count;\n}\n\
    </code>\nFor some reason my guts tells me that I should use grep, but I can't\
    \ figure out how to use grep to solve this problem.\n<|/ q dscore=0 tags=recursion,fizzbuzz,grep,perl\
    \ |>\n<| c |>\nPlease show your efforts. What is the problem with that?\n<|/ c\
    \ |>\n<| c |>\nApart from using a `while` loop, you can use `map`, `grep` or `grep!`\
    \ which are powerful enough to solve this problem. `grep` returns an array and\
    \ `map` processes a list. `grep!` processes a list and returns true/false. Just\
    \ google `perl grep` and try writing some code.\n<|/ c |>\n<| c |>\nI edited my\
    \ question to show the code I have written so far. Thank you for the tips.\n<|/\
    \ c |>\n<| a |>\nThis can be done easily by using map and grep.\n<code>\nmy $fizzbuzz\
    \ = map {\n    my $value = $_ % 3 == 0 ? \"Fizz\" : \"\";\n    $value .= $_ %\
    \ 5 == 0 ? \"Buzz\" : \"\";\n    $value .= $_ % ", "    return 1 if ($n % 11 ==\
    \ 0 || $n % 13 == 0);\n    return 0 if ($n % 11 != 0 || $n % 13 != 0);\n    my($c)\
    \ = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($i % 11 == 0 && $i\
    \ % 13 == 0) {\n            $c++;\n        }\n        if ($i % 11 != 0 || $i %\
    \ 13 != 0) {\n            $c++;\n        }\n    }\n    return $c;\n}", "    my($i)\
    \ = 0;\n    for(; $i <= $n; $i++) {\n        my $is_divisible_by_11 = !($i % 11\
    \ == 0);\n        my $is_divisible_by_13 = !($i % 13 == 0);\n        if( $is_divisible_by_11\
    \ || $is_divisible_by_13) {\n            last if $is_divisible_by_11;\n      \
    \      last if $is_divisible_by_13;\n        }\n        elsif($i % 11 == 0 &&\
    \ $i % 13 == 0) {\n            $i += 1;\n        }\n        else {\n         \
    \   $i += 1;\n        }\n    }\n    return $i;\n}", '    my $count = 0;', "  \
    \  return 0 unless $n =~ /^\\d+$/;\n    my $count = 0;\n    for my $i (1 .. $n)\
    \ { # start from 1 to n\n        if ($i % 11 == 0 && $i % 13 == 0) { # the number\
    \ is a multiple of 11 and 13\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a tags=fizzbuzz,perl,algorithm dscore=0 |>\n<| c |>\n\
    Thanks so much for the answer. It works wonderfully and it is short and sweet.\
    \ I'm going to study it and try to understand it better so I can apply it to other\
    \ problems in the future.\n<|/ c |>\n<| a dscore=0 |>\nI believe there is a more\
    \ straightforward way to accomplish this goal. The trick is to convert all integers\
    \ into the appropriate fizz-buzz numbers, like this:\n<code>\n1 -> 1\n2 -> 2\n\
    3 -> 3\n4 -> 4\n5 -> fizz\n6 -> buzz\n</code>\nThis way you don't have to write\
    \ a for loop to go through the numbers, just print out all the fizz buzz numbers.\n\
    Here's a Perl one-liner:\n<code>\nperl -e 'print join \"\\n\", map \"$_\" => sub\
    \ {\n  my $number = shift;\n  if ($number % 3 == 0 || $number % 5 == 0) {\n  \
    \  return \"fizzbuzz\";\n  } else {\n    return $number;\n  }\n} (0..100)'\n</code>\n\
    Or, in its more readable form with comments:\n<code>", "    if ($n < 10 && $n\
    \ % 11 == 0 || $n < 10 && $n % 13 == 0) {\n        return 0;\n    }\n    return\
    \ 1 + fizz_buzz(10 * $n + $n / 10);\n}", "    my($ret);\n    for (1 .. $n) {\n\
    \        if ($_ & 7) { $ret++; }\n        if ($_ & 13) { $ret++; }\n        if\
    \ ($_ & 11) { $ret++; }\n        if ($_ & 15) { $ret++; }\n    }\n    return $ret;\n\
    }", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($i\
    \ % 11 == 0 && ($i % 13) == 0) {\n            $count++;\n        }\n        else\
    \ {\n            if ($i % 7 == 0) {\n                $count++;\n            }\n\
    \            else {\n                last;\n            }\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    foreach my $n (@_) {\n     \
    \   if ( ($n & 7) == 7 ) {\n            $count++;\n        }\n        if ( ($n\
    \ & 1) == 1 ) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    $n += 0;\n    $n += 1;\n    $n += 0;\n    $n += 2;\n    $n += 1;\n  \
    \  $n += 0;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n    $n += 0;\n    $n +=\
    \ 4;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n    $n += 0;\n    $n += 5;\n \
    \   $n += 4;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n    $n += 0;\n    $n +=\
    \ 6;\n    $n += 5;\n    $n += 4;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n \
    \   $n += 0;\n    $n += 7;\n    $n += 6;\n    $n += 5;\n    $n += 4;\n    $n +=\
    \ 3;\n    $n += 2;\n    $n += 1;\n    $n += 0;\n    $n += 8;\n    $n += 7;\n \
    \   $n += 6;\n    $n += 5;\n    $n += 4;\n    $n += 3;\n    $n += 2;\n    $n +=\
    \ 1;\n    $n += 0;\n    $n += 9;\n    $n += 8;\n    $n += 7;\n    $n += 6;\n \
    \   $n += 5;\n    $n += 4;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n    $n +=\
    \ 0;\n    $n += 10;\n    $n += 9;\n    $n += 8;\n    $n += 7;\n    $n += 6;\n\
    \    $n += 5;\n    $n += 4;\n    $n += 3;\n    $n += 2;\n    $n += 1;\n    $n\
    \ += 0;\n    $n += 11;\n    $n += 10;\n    $n += 9;\n    $n += 8;\n    $n += 7;\n\
    \    $n += 6;\n    $n += 5;\n    $n += 4;\n    $n += 3;\n    $n += 2;\n    $n\
    \ += 1;\n    $n += 0;\n    $n += 12;\n    $n += 11;\n    $n += 10;\n    $n +=\
    \ 9;\n    $n += 8;\n    $n += 7;\n    $n += 6;\n    $n += 5;\n    $n += 4;\n \
    \   $n += 3;\n    $n += 2;\n    $n += 1;\n    $n += 0;\n    return $n;\n}", " \
    \   \n    if ($n < 0) {\n\tmy $min = -($n);\n\t$n = abs($n);\n\treturn if $n <\
    \ 1;\n\treturn 1 if $min % 11 == 0 and $min % 13 == 0;\n\treturn 2 if $min % 11\
    \ == 0;\n\treturn 3 if $min % 13 == 0;\n    }\n    \n    return 0 if $n % 11 ==\
    \ 0 and $n % 13 == 0;\n    return 2 if $n % 11 == 0;\n    return 3 if $n % 13\
    \ == 0;\n    \n    return 1;\n}", "    return $n if $n % 11 == 0 || $n % 13 ==\
    \ 0;\n    return $n if $n =~ /7/;\n    return $n if $n =~ /5/;\n    return $n\
    \ if $n =~ /3/;\n    return $n if $n =~ /1/;\n    return $n if $n =~ /9/;\n  \
    \  return $n if $n =~ /4/;\n    return $n if $n =~ /2/;\n    return $n if $n =~\
    \ /6/;\n    return $n if $n =~ /8/;\n    return $n if $n =~ /0/;\n    return 0;\n\
    }\n</cell>\n<cell>", "    my $s = $n =~ /\\d+/; # number of digits in $n\n   \
    \ my $p = ($s % 11) + 13;\n    return $p if $p < $n;\n    return $n - $s if $n\
    \ > $s;\n    return 0;\n}\n</code>\nThe code is a lot more simple and probably\
    \ faster than your approach.\n<|/ a tags=fizzbuzz,perl |>\n<| a |>\nTry this\n\
    <code>\nuse strict;\nuse warnings;", "    if ($n =~ m/^[0-9]{7}$/) {\n       \
    \ return 0 if ($n % 11 == 0 || $n % 13 == 0);\n        return 2 if ($n % 11 ==\
    \ 1 && $n % 13 == 0);\n        return 3 if ($n % 11 == 2 && $n % 13 == 0);\n \
    \       return 1 if ($n % 11 == 3 && $n % 13 == 1);\n        return 0 if ($n %\
    \ 11 == 0 && $n % 13 == 1);\n    }\n    elsif ($n =~ m/^[0-9]{6}$/) {\n      \
    \  return 0 if ($n % 11 == 0 || $n % 13 == 0);\n        return 1 if ($n % 11 ==\
    \ 1 && $n % 13 == 0);\n        return 2 if ($n % 11 == 2 && $n % 13 == 0);\n \
    \       return 3 if ($n % 11 == 3 && $n % 13 == 1);\n        return 4 if ($n %\
    \ 11 == 4 && $n % 13 == 0);\n        return 5 if ($n % 11 == 5 && $n % 13 == 1);\n\
    \        return 6 if ($n % 11 == 6 && $n % 13 == 0);\n    }\n    elsif ($n =~\
    \ m/^[0-9]{5}$/) {\n        return 0 if ($n % 11 == 0 || $n % 13 == 0);\n    \
    \    return 1 if ($n % 11 == 1 && $n % 13 == 0);\n        return 2 if ($n % 11\
    \ == 2 && $n % 13 == 0);\n        return 3 if ($n % 11 == 3 && $n % 13 == 1);\n\
    \        return 4 if ($n % 11 == 4 && $n % 13 == 0);\n        return 5 if ($n\
    \ % 11 == 5 && $n % 13 == 1);\n        return 6 if ($n % 11 == 6 && $n % 13 ==\
    \ 0);\n    }\n    elsif ($n =~ m/^[0-9]{4}$/) {\n        return 0 if ($n % 11\
    \ == 0 || $n % 13 == 0);\n        return 1 if ($n % 11 == 1 && $n % 13 == 0);\n\
    \        return 2 if ($n % 11 == 2 && $n % 13 == 0);\n        return 3 if ($n\
    \ % 11 == 3 && $n % 13 == 1);\n        return 4 if ($n % 11 == 4 && $n % 13 ==\
    \ 0);\n        return 5 if ($n % 11 == 5 && $n % 13 == 1);\n        return 6 if\
    \ ($n % 11 == 6 && $n % 13 == 0);\n    }\n    elsif ($n =~ m/^[0-9]{3}$/) {\n\
    \        return 0 if ($n % 11 == 0 || $n % 13 == 0);\n        return 1 if ($n\
    \ % 11 == 1 && $n % 13 == 0);\n        return 2 if ($n % 11 == 2 && $n % 13 ==\
    \ 0);\n        return 3 if ($n % 11 == 3 && $n % 13 == 1);\n        return 4 if\
    \ ($", "    # count how many times digit 7 appears in integers less than n\n \
    \   return 2 if $n % 11 == 0 && $n % 13 == 0;\n    # count how many times digit\
    \ 7 appears in integers less than n which are divisible by 11\n    return 3 if\
    \ $n % 11 == 0;\n    # count how many times digit 7 appears in integers less than\
    \ n which are divisible by 13\n    return 4 if $n % 13 == 0;\n    # return 0 since\
    \ n is not divisible by 11 or 13\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This answer doesn't work if you want to return the number of times the digit 7\
    \ appears in a list of numbers that are divisible by 11 and 13 (i.e. if the numbers\
    \ are divisible by 11 and 13, then the number of times 7 is in the list should\
    \ be the same)\n<|/ c |>\n<| a dscore=1 |>\n<code>\nmy $n = 7;\nmy $result = do\
    \ {\n    my %counts = map { $_ => 0 } 1 .. 9;\n    grep { $_ & 1 } 1 .. $n;\n\
    };\n</code>\n<|/ a tags=perl |>\n<| a |>\nHere's a solution that uses eval to\
    \ generate the list of numbers (I assume that your number is a variable).\n<code>\n\
    my $numbers = [2,3,5,8,12,7,11,13,14,18,9,16,10,19,17];\nmy $search = 7;", '    my
    $c = 0;', "    my $count = 0;\n    $n -= $_ for my $k ((11..$n), (13..$n)) {\n\
    \        unless ($k == 7 && $n % $k) {\n            $count++;\n        }\n   \
    \ }\n    $count;\n}", "    my($div) = ($n % 11 == 0 || $n % 13 == 0 ? 11 : 13);\n\
    \    my($num) = $n / $div;\n    my($rem) = $n % $div;", "    $n += 0;\n    \n\
    \    if ($n <= 1) {\n        return $n;\n    }\n    \n    return $n <= 13\n  \
    \      ? 0\n        : 1 \n            ? 1 \n            : 2 \n               \
    \ ? 3\n                : 5 \n                    ? 6\n                    : 8\n\
    \                        ? 9\n                        : 10\n                 \
    \           ? 11\n                            : fizz_buzz($n - 1);\n}", "    if\
    \ ($n =~ /^\\d+$/ && $n % 11 == 0 && $n % 13 == 0) {\n        return 0;\n    }\n\
    \    return $n // 15 if $n =~ /^\\d+$/;\n}", "    my($count) = @_;\n    my($result);",
  "    return 0 if $n <= 1;\n    return $n % 11 + $n % 13;\n}", "    $n =~ s/(\\d)7/$1+1/eg;\n\
    \    my $num = sprintf(\"%0*d\", length($n), $n);\n    my $i;\n    my $count =\
    \ 1;", "    my($fb, $i);\n    my $i = 0;\n    while ($n =~ /(\\d{3,7})/g) {\n\
    \        if ($1 =~ m/^(11|13)$/) {\n            $i++;\n        } else {\n    \
    \        $i++;\n            $fb = ($fb || 0) + ($1 =~ m/^(7|8)$/);\n        }\n\
    \    }\n    return $i;\n}", "    return 0 if $n % 11 == 0;\n    return 0 if $n\
    \ % 13 == 0;\n    return 1 if $n % 11 == 0;\n    return 1 if $n % 13 == 0;\n \
    \   return 2 if $n % 11 == 0;\n    return 2 if $n % 13 == 0;\n    return 3 if\
    \ $n % 11 == 0;\n    return 3 if $n % 13 == 0;\n    return 4 if $n % 11 == 0;\n\
    \    return 4 if $n % 13 == 0;\n    return 5 if $n % 11 == 0;\n    return 5 if\
    \ $n % 13 == 0;\n    return 6 if $n % 11 == 0;\n    return 6 if $n % 13 == 0;\n\
    \    return 7 if $n % 11 == 0;\n    return 7 if $n % 13 == 0;\n}", '    return
    0 unless $n;', "    return 0 if $n <= 3;\n    return 1 if $n % 11 == 0;\n    return\
    \ 1 if $n % 13 == 0;\n    \n    # FizzBuzz is easy in Perl\n    return 2 if $n\
    \ % 3 == 0 and $n % 5 == 0;\n    return 3 if $n % 3 == 0;\n    return 5 if $n\
    \ % 5 == 0;\n}", "    my($z);\n    if ($n % 11 == 0) {\n        $z = 0;\n    }\
    \ elsif ($n % 13 == 0) {\n        $z = 1;\n    } else {\n        $z = 2;\n   \
    \ }\n    $n =~ s/\\A(\\d)\\B/$z$1/e;\n    return $n;\n}", "    $n =~ tr/0/7/;\n\
    \    $n =~ tr/13/11/;\n    $n =~ tr/11/7/;\n    $n =~ tr/7/1/;\n    $n =~ tr/1/0/;\n\
    \    $n =~ tr/5/4/;\n    $n =~ tr/4/3/;\n    $n =~ tr/3/2/;\n    $n =~ tr/2/1/;\n\
    \    $n =~ tr/4/5/;\n    return $n;\n}\n</code>\n<|/ a dscore=3 tags=math,algorithm\
    \ |>\n<| a |>\nFizzBuzz is a very simple problem, it is quite easy to solve with\
    \ simple code. I will post the code for the FizzBuzz problem in Python, but it\
    \ is easy to translate the code into any language.\nHere is the code:\n<code>\n\
    def fizzbuzz(n):\n    if n%15 == 0:\n        return \"FizzBuzz\"\n    elif n%5\
    \ == 0:\n        return \"Fizz\"\n    elif n%3 == 0:\n        return \"Buzz\"\n\
    \    else:\n        return n\n</code>\n<|/ a tags=math,algorithm dscore=3 |>\n\
    <| a tags=math,algorithm |>\nThe solution of is pretty clear and concise, but\
    \ this doesn't need any complex math at all. \nFor this kind of problem, we could\
    \ simplify the problem down to a few checks, like we know that 5 can be divided\
    \ by both 3 or 5, 3 can be divided by both 3 or 5 and 5 can be divided by both\
    \ 3 or 5. Then, we could just do this:\n<code>\ndef fizzbuzz(number):\n    digits\
    \ = [number % 3, number % 5, number % 3, number % 5]\n    return 'FizzBuzz' if\
    \ any(map(lambda x: x == 0, digits)) else 'Fizz' if any(map(lambda x: x == 0,\
    \ digits[:2])) else 'Buzz' if any(map(lambda x: x == 0, digits[:4])) else 'No\
    \ FizzBuzz here'\n</code>\n<|/ a dscore=3 |>\n<| a tags=math,algorithm |>\nHere\
    \ is one solution in Python:\n<code>\ndef fizzbuzz(n):\n    if n % 15 == 0:\n\
    \        return 'FizzBuzz'\n    elif n % 5 == 0:\n        return 'Fizz'\n    elif\
    \ n % 3 == 0:\n        return 'Buzz'\n    else:\n        return n\n</code>\n<|/\
    \ a dscore=3 |>\n<| a dscore=2 |>\nHere is an example with Python.\n<code>\ndef\
    \ fizzbuzz(number):\n    digits = [number % 3, number % 5, number % 3, number\
    \ % 5]\n    bu", "    return 0 if $n <= 0;\n    my($divisible);\n    my $counter\
    \ = 0;\n    for(my $i = 1; $i <= $n; $i++) {\n        $divisible += ($i & 1 ?\
    \ '11' : '13');\n        $counter += $i & 7;\n    }\n    return $counter;\n}",
  "    return $n if $n >= 100 and ($n % 11) == 0 and ($n % 13) == 0;\n    $n *= 2;\n\
    \    $n += 0 if $n % 5 == 0;\n    return $n if $n % 7 == 0;\n    $n += 1;\n  \
    \  return $n;\n}", "    $n =~ tr/7/7/;\n    return $n if $n =~ m/^[02468]$/;\n\
    \    return $n if $n =~ m/^[02467]$/;\n    return $n if $n =~ m/^[0246]$/;\n \
    \   return $n if $n =~ m/^[0245]$/;\n    return $n if $n =~ m/^[0244]$/;\n   \
    \ return $n if $n =~ m/^[0243]$/;\n    return $n if $n =~ m/^[0242]$/;\n    return\
    \ $n if $n =~ m/^[0241]$/;\n    return $n if $n =~ m/^[0240]$/;\n    return $n\
    \ if $n =~ m/^[0244]$/;\n    return $n if $n =~ m/^[0242]$/;\n    return $n if\
    \ $n =~ m/^[0243]$/;\n    return $n if $n =~ m/^[0241]$/;\n    return $n if $n\
    \ =~ m/^[0240]$/;\n    return $n if $n =~ m/^[0245]$/;\n    return $n if $n =~\
    \ m/^[0243]$/;\n    return $n if $n =~ m/^[0245]$/;\n    return $n if $n =~ m/^[0246]$/;\n\
    \    return $n if $n =~ m/^[0247]$/;\n    return $n if $n =~ m/^[0246]$/;\n  \
    \  return $n if $n =~ m/^[0245]$/;\n    return $n if $n =~ m/^[0244]$/;\n    return\
    \ $n if $n =~ m/^[0242]$/;\n    return $n if $n =~ m/^[0243]$/;\n    return $n\
    \ if $n =~ m/^[0241]$/;\n    return $n if $n =~ m/^[0240]$/;\n    return $n if\
    \ $n =~ m/^[0245]$/;\n    return $n if $n =~ m/^[0245]$/;\n    return $n if $n\
    \ =~ m/^[0243]$/;\n    return $n if $n =~ m/^[0243]$/;\n    return $n if $n =~\
    \ m/^[0242]$/;\n    return $n if ", '    my($n) = ($n <= 99 ? $n : 99);', "  \
    \  my $count;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($i % 11 == 0\
    \ || $i % 13 == 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my($z, $count);\n    $z = q($n);\n    $count = 0;\n    while (0 <= $z)\
    \ {\n\tif ($z % 11 == 0) { $count++; }\n\telsif ($z % 13 == 0) { $count++; }\n\
    \telse { $count++; $z--; }\n    }\n    return $count;\n}", '    my $digit;', '    my($counter);',
  "    my($cx);\n    my($fizz_count);\n    my($fizz);\n    my($buzz);\n    my($i);",
  "    my(@digits) = ( 10, 7, 3, 9, 6, 5, 8 );\n    my(@count) = (0, 0);\n    while\
    \ ($n >= 10) {\n        my $digit = $n % 10;\n        $count[0] += $digits[-1]\
    \ if $digit == @digits;\n        $n = ($n - $digits[$digit]) / $digits[$digit];\n\
    \        $count[0] += 1 if $n % 11 == 0;\n        $count[0] += 1 if $n % 13 ==\
    \ 0;\n        $count[0] += 1 if $digit == 7;\n        splice, @digits, 0, 1;\n\
    \    }\n    return $count[0];\n}", "    my @digits = map { sprintf(\"%03d\", $_)\
    \ } 1..10;\n    my @fizz  = grep { $_ & 0b00000001 } @digits;\n    my @buzz  =\
    \ grep { $_ & 0b00000010 } @digits;\n    my @fizz_buzz = grep { $_ & 0b00000100\
    \ } @digits;\n    my(@result) = grep { $_ & 0b00001000 } @digits;\n    return\
    \ scalar(@fizz) + scalar(@buzz) + scalar(@fizz_buzz) + scalar @result;\n}", " \
    \   if ($n >= 0 && $n <= 100) {\n        $n = ($n % 11);\n        if ($n > 0)\
    \ {\n            $n++;\n        }\n        $n = ($n % 13);\n        if ($n > 0)\
    \ {\n            $n++;\n        }\n        return $n;\n    }\n    return 0;\n}",
  "    my $count = 0;\n    for (my $i = $n; $i > 1; $i--) {\n        my($remainder,\
    \ $mod10) = div($i, 10);\n        if ($mod10 == 7 && $i >= 11) {\n           \
    \ $count++;\n        }\n        if ($mod10 == 13 && $i >= 11) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my $count = 0;\n    if ( $n <\
    \ 0 ) {\n        $n = -$n;\n    }\n    while ( ( $n % 11 != 0 ) && ( $n % 13 !=\
    \ 0 ) ) {\n        $count++;\n        $n /= 11;\n    }\n    return $count;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=performance,perl,fizzbuzz |>\nYou could\
    \ use the range operator to solve this:\n<code>", "    my(@result) = ();\n   \
    \ if ($n % 11 == 0 && $n % 13 == 0) {\n        push(@result, \"FizzBuzz\");\n\
    \    }\n    if ($n % 11 == 0) {\n        push(@result, \"Fizz\");\n    }\n   \
    \ if ($n % 13 == 0) {\n        push(@result, \"Buzz\");\n    }\n    if (@result)\
    \ {\n        $result[$#result] = $n;\n    }\n    return scalar(@result);\n}\n\
    </code>\n<|/ a tags=arrays,perl,fizzbuzz,algorithm |>\n<| c |>\nI like the fact\
    \ that Perl is able to do array manipulation with $#result. I just changed your\
    \ code slightly to accomplish the same thing. Thanks!\n<|/ c |>\n<| a |>\nFor\
    \ this particular problem, I believe the fastest way is by using the modulo operator:\n\
    <code>", "    my(@a) = ();\n    my($c);\n    my($i);\n    \n    for ($i = 0; $i\
    \ <= $n; $i++) {\n        if ($i =~ m/[13579]$/) {\n            push(@a, $i);\n\
    \        }\n    }\n    for ($i = 0; $i < @a; $i++) {\n        $c = $a[$i];\n \
    \       if ($c =~ m/7$/) {\n            push(@a, $c);\n        }\n    }\n    $c\
    \ = scalar(@a);\n    return $c;\n}", "    my $nn = $n / 11;\n    my $nnn = $nn\
    \ / 13;\n    my $nnnnn = $nnn / 15;\n    my $nnnnnnn = $nnnnn / 17;\n    my $nnnnnnnnn\
    \ = $nnnnnnn / 19;\n    my $nnnnnnnnnnn = $nnnnnnnnn / 21;\n    my $nnnnnnnnnnnnn\
    \ = $nnnnnnnnnnn / 23;\n    my $nnnnnnnnnnnnnnn = $nnnnnnnnnnnnn / 25;\n    return\
    \ $nnnnnnnnnnnnnnn;\n}", "    my(@digits) = split(//, $n);\n    my($count) = grep\
    \ { $_ ne 7 and $_ ne 13 } @digits;\n    return $count;\n}\n</code>\n<|/ a tags=perl,fizzbuzz,recursion\
    \ |>\n<| a tags=perl,fizzbuzz,recursion dscore=0 |>\nHere is a solution that is\
    \ much simpler than the others posted here, which is based on the idea that 0\
    \ is the smallest number that can be divided by 11 or 13 (mod 11 and mod 13),\
    \ so just add 2 to all numbers, except those that are multiples of 11, and add\
    \ 3 to all numbers that are multiples of 13. Since these are powers of 3, that\
    \ simplifies to:\n<code>", "    my($retVal);\n    if ($n <= 0) {\n        $retVal\
    \ = 0;\n    }\n    else {\n        for (my $i = 1; $i <= $n; $i++) {\n       \
    \     if ($i =~ m/\\b(11|13)\\b/) {\n                $retVal++;\n            }\n\
    \        }\n    }\n    return $retVal;\n}\n</code>\n<|/ a |>\n<| c |>\nYou should\
    \ use $i < $n instead of $i <= $n.\n<|/ c |>\n<| c |>\n: Thanks, I missed that.\
    \  I've added an explanation.\n<|/ c |>\n<| a tags=fizzbuzz,perl |>\nA recursive\
    \ solution, no regex:\n<code>", "    my $count = 0;\n    for my $i (@ints) {\n\
    \        if ($i % 11 == 0 && $i % 13 == 0) {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}", "    return 0 if ($n <= 0);\n    my($fizz_counter)\
    \ = 0;\n    my($buzz_counter) = 0;\n    my($remainder) = ($n % 11);\n    $fizz_counter++\
    \ if ($remainder == 7);\n    my($remainder) = ($n % 13);\n    $buzz_counter++\
    \ if ($remainder == 7);\n    return ($fizz_counter + $buzz_counter);\n}", '    my(@ints)
    = ();', "    return 0 if $n%11 == 7;\n    return 2 if $n%13 == 7;\n    return\
    \ 3;\n}", '    my $count = 0;', "    my(@digits);\n    my($i);", "    my $count\
    \ = 0;\n    while ($n != 0) {\n        $count += $n % 11;\n        $n /= 11;\n\
    \        $count += $n % 13;\n        $n /= 13;\n    }\n    return $count;\n}",
  "    my ($x, $y, $z) = @_;\n    return 0 if $n > 13;\n    $x .= 0 if $n > 7 and\
    \ $x < 7;\n    $y .= 0 if $n > 7 and $x < 13;\n    $z .= 0 if $n > 7 and $x <\
    \ 23;\n    $x .= 0 if $n > 7 and $x < 33;\n    $y .= 0 if $n > 7 and $x < 43;\n\
    \    $z .= 0 if $n > 7 and $x < 53;\n    return 1 + fizz_buzz(10 + $n) if $n %\
    \ 10 == 7;\n    return 1 + fizz_buzz(10 + $n) if $n % 10 == 3;\n    return 1 +\
    \ fizz_buzz(10 + $n) if $n % 10 == 11;\n    return 1 + fizz_buzz(10 + $n);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nuse strict;\nuse warnings;\n\
    my $n = 48;\nmy $k = 0;\nwhile($n != 0){\n    if($n % 10 == 1){\n        print\
    \ \"1\";\n        $k++;\n    }elsif($n % 10 == 3){\n        print \"11\";\n  \
    \      $k++;\n    }elsif($n % 10 == 5){\n        print \"101\";\n        $k++;\n\
    \    }elsif($n % 10 == 7){\n        print \"111\";\n        $k++;\n    }elsif($n\
    \ % 10 == 9){\n        print \"0\";\n        $k++;\n    }elsif($n % 10 == 11){\n\
    \        print \"1\";\n        $k++;\n    }elsif($n % 10 == 12){\n        print\
    \ \"11\";\n        $k++;\n    }elsif($n % 10 == 13){\n        print \"101\";\n\
    \        $k++;\n    }else{\n        print \"0\";\n        $k++;\n    }\n    $n\
    \ = $n/10;\n}\nprint \"$k\\n\";\n</code>\n<|/ a tags=perl,fizzbuzz |>\n<| a dscore=0\
    \ tags=perl,fizzbuzz |>\n<code>\nuse strict;\nuse warnings;", "    if ($n >= 100)\
    \ {\n        $n -= 100;\n        return $n / 11;\n    } elsif ($n >= 11) {\n \
    \       $n -= 11;\n        return $n * 3 + 1;\n    } else {\n        return $n\
    \ % 11;\n    }\n}", "    # Initialize variables\n    my @digits = (\"1\", \"2\"\
    , \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"\
    13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\",\
    \ \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\"\
    , \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\"\
    , \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\");\n    my $digit\
    \ = $digits[$n-1];\n    my $i = 0;\n    my $buzz = 0;\n    \n    for (; $i < $n;\
    \ $i++) {\n        if ($i % 11 == 0 && $i % 13 == 0) {\n            $buzz += 1;\n\
    \        }\n        elsif ($i % 11 == 0) {\n            $buzz += 1;\n        }\n\
    \        elsif ($i % 13 == 0) {\n            $buzz += 1;\n        }\n    }\n \
    \   return $buzz;\n}\n</cell>\n<text>\nThe first line of the function checks if\
    \ the argument is a number, and if it is, creates a variable $n which holds the\
    \ argument. It then initializes the digit variables (@digits). Then, for each\
    \ number $i from 0 to $n inclusive, three checks are made:", "    my($fizzbuzz);\n\
    \    my($fb, $fb2, $fb3);\n    my($fizz, $fizzbuzz2, $fizzbuzz3, $fizzbuzz4, $fizzbuzz5,\
    \ $fizzbuzz6, $fizzbuzz7, $fizzbuzz8);\n    my($fizzbuzz9, $fizzbuzz10, $fizzbuzz11,\
    \ $fizzbuzz12, $fizzbuzz13, $fizzbuzz14);\n    my($fizzbuzz15, $fizzbuzz16, $fizzbuzz17,\
    \ $fizzbuzz18, $fizzbuzz19, $fizzbuzz20);\n    my($fizzbuzz21, $fizzbuzz22, $fizzbuzz23,\
    \ $fizzbuzz24, $fizzbuzz25, $fizzbuzz26, $fizzbuzz27, $fizzbuzz28, $fizzbuzz29,\
    \ $fizzbuzz30);\n    my($fizzbuzz31, $fizzbuzz32, $fizzbuzz33, $fizzbuzz34, $fizzbuzz35,\
    \ $fizzbuzz36, $fizzbuzz37, $fizzbuzz38, $fizzbuzz39, $fizzbuzz40);\n    my($fizzbuzz41,\
    \ $fizzbuzz42, $fizzbuzz43, $fizzbuzz44, $fizzbuzz45, $fizzbuzz46, $fizzbuzz47,\
    \ $fizzbuzz48, $fizzbuzz49, $fizzbuzz50);\n    my($fizzbuzz51, $fizzbuzz52, $fizzbuzz53,\
    \ $fizzbuzz54, $fizzbuzz55, $fizzbuzz56, $fizzbuzz57, $fizzbuzz58, $fizzbuzz59,\
    \ $fizzbuzz60);\n    my($fizzbuzz61, $fizzbuzz62, $fizzbuzz63, $fizzbuzz64, $fizzbuzz65,\
    \ $fizzbuzz66, $fizzbuzz67, $fizzbuzz68, $fizzbuzz69, $fizzbuzz70);\n    my($fizzbuzz71,\
    \ $fizzbuzz72, $fizzbuzz73, $fizzbuzz74, $fizzbuzz75, $fizz", "    my(@result)\
    \ = (0);\n    my($i, $j, $divisible, $counter);\n    my($digit) = ('0', '1', '2',\
    \ '3', '4', '5', '6', '7', '8', '9');\n    $n = 10 if $n < 10;\n    while($n >=\
    \ 10) {\n        $divisible = 0;\n        $counter = 0;\n        foreach $i (\
    \ 0..9 ) {\n            $divisible += ($n % $i) ? 1 : 0;\n        }\n        $counter\
    \ += $divisible == 7 ? 1 : 0;\n        $result[$counter] += 1;\n        $n -=\
    \ $divisible == 7 ? $i : 10;\n    }\n    return @result;\n}", "    return 0 if\
    \ ($n < 0);\n    $n += 0;\n    if ($n < 10) {\n        return $n;\n    }\n   \
    \ if ($n <= 13) {\n        return 1 if ($n % 11 == 0);\n        return 2 if ($n\
    \ % 13 == 0);\n        return 0;\n    }\n    return $n;\n}", "    \n    my @count;",
  "    return ($n->to_i / 11) * 3 + ($n->to_i / 13) * 3;\n}", "    my($count, $remainder,\
    \ $dividend) = (0,0, $n);\n    for ($count = 1; $count <= 100; $count++) {\n \
    \       $remainder = $n % 11;\n        $dividend   = $n % 13;\n        if ($count\
    \ != $dividend) {\n            if ($count == $remainder) {\n                $count++;\n\
    \            }\n        }\n        $n = $dividend;\n    }\n    return $count;\n\
    }", "    return scalar(grep { $_ % 11 == 0 } @{[ $n / 11 ]});\n}\n</code>\nBut\
    \ I would still use an external module such as Moose::Util::TypeConstraints.\n\
    <|/ a tags=perl |>\n<| c |>\n`[ ]` is more readable than `@{ ... }`.\n<|/ c |>\n\
    <| c |>\nI actually like the `[ ]`.  I thought I should show what I was thinking,\
    \ but I didn't realize it was so readable.\n<|/ c |>\n<| a tags=perl |>\n<code>\n\
    use strict;\nuse warnings;\nuse 5.010;\nuse Data::Dumper;", "    my $count = 0;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        my $x = $i;\n        if ($x %\
    \ 11 == 0 || $x % 13 == 0) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", '    my $counter = 0;', "    $n += 0;\n    my $count = 0;", " \
    \   my $count = 0;\n    foreach my $i (0 .. $n) {\n        if ($i =~ /^(11|13)$/)\
    \ {\n            $count += $i =~ /7/;\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a tags=perl |>\n<| c |>\nThanks Jonathan. Unfortunately the assignment\
    \ was designed to be done with only the code I have listed.\n<|/ c |>\n<| c |>\n\
    - It may be worth saying that this exercise isn't even nearly as complicated as\
    \ it might seem.\n<|/ c |>\n<| c |>\n- It also isn't very efficient, since it\
    \ has to repeatedly loop over all numbers. It's also not guaranteed to work when\
    \ n is `0` (and you didn't check for that).\n<|/ c |>\n<| c |>\n- You're right,\
    \ it's not the most efficient way of doing things. But it was the closest thing\
    \ I could think of without changing too much of your original code. I'm not sure\
    \ how to do this more efficiently without changing the code too much. And I already\
    \ mentioned that it's not a good idea to test `if $i =~ /7/` in the loop, as that\
    \ would slow it down quite a bit.\n<|/ c |>\n<| c |>\n- Also, I noticed that `fizz_buzz`\
    \ doesn't actually return the count, it just prints it. I fixed that up too.\n\
    <|/ c |>\n<| a |>\nA simple way of doing this without using loops or recursion\
    \ is by checking for each number whether it divides evenly into 7 or not.  If\
    \ it does, you add one to $count - which means you increment $count by 1 if even\
    \ - and otherwise you don't.\n<code>\nuse strict;\nuse warnings;", "    my $remainder;\n\
    \    return $remainder if ($n =~ /^(-?\\d+)$/);\n    return $n if ($n % 11 ==\
    \ $n % 13);\n    $remainder = $n % 11;\n    if ($remainder == 7)\n\t{ $remainder\
    \ = 0; }\n    $n -= $remainder;\n    return $n + ($remainder ? 1 : 0);\n}", " \
    \   my $remainder = $n % 11;\n    $remainder += 1 if ($n % 13 == 7);\n    return\
    \ ($remainder ? $remainder : 0);\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ explaining your approach. You are right, I was misled by some other code elsewhere\
    \ in the program that was also using divisible by 11 or 13 so I thought this would\
    \ count them as divisible by 11 and 13 independently. Now I see that it is all\
    \ about the divisible by 11 or 13 - which is why it never showed up in my original\
    \ code sample.\n<|/ c |>\n<| a tags=algorithm,perl dscore=0 |>\nThe most obvious\
    \ solution is to use modulus division and test for 7, then count the ones remaining.\n\
    <code>", '    my $count;', "    if ($n =~ /^\\d+$/) {\n        $n =~ tr/7/7/;\n\
    \        if ($n =~ /11|13$/) {\n            return 0;\n        }\n        return\
    \ $n / 11;\n    }\n    return 0;\n}", "    my($n) = $n =~ m/^(-?\\d+)$/;\n   \
    \ if ($n =~ m/^(11|13)$/) {\n        return ($n - 1);\n    }\n    $n % 11 == 0\
    \ ? 0 : ($n % 13 == 0 ? 1 : 2);\n}", "    my(@digits) = ('', '7', '8', '9', '10',\
    \ '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24',\
    \ '25', '26', '27', '28', '29', '30', '31');\n    foreach $d (@digits) {\n   \
    \     my $mod = $n % $d;\n        if ($mod >= 0 && $mod <= 15) { $n++ }\n    \
    \    elsif ($mod > 15 && $mod <= 23) { $n++ }\n        elsif ($mod > 23 && $mod\
    \ <= 31) { $n++ }\n        elsif ($mod > 31) { $n++ }\n    }\n    return $n;\n\
    }", "    my(@counts);\n    $counts[0] = 0;\n    my($i, $digit, $temp);\n    for(my\
    \ $i = 0; $i < $n; $i++) {\n        $digit = $i % 10;\n        if ($digit == 7)\
    \ {\n            $temp = $i;\n            $counts[$temp]++;\n        }\n    }\n\
    \    for(my $i = 1; $i <= $#counts; $i++) {\n        if ($counts[$i] != 0) {\n\
    \            return $counts[$i];\n        }\n    }\n    return 0;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nNice use of `map` here since we already know the array\
    \ size, thanks for mentioning that.\n<|/ c |>\n<| a dscore=1 tags=perl |>\nUse\
    \ a hash instead of a list:\n<code>\nuse strict;\nuse warnings;", "    my($count)\
    \ = 0; \n    while (@_) {\n        my $x = shift;\n        if ($x % 11 == 0 ||\
    \ $x % 13 == 0) {\n            $count++;\n        }\n        else {\n        \
    \    next;\n        }\n    }\n    return $count;\n}", "    $n =~ s/^\\s*//;\n\
    \    $n =~ s/\\s*$//;\n    my(@digits) = split '', $n;\n    my(@times_seven) =\
    \ grep {$_ % 7 == 0 } @digits;\n    my $result = $#times_seven + 1;\n    return\
    \ $result;\n}", "    my(@array) = ($n =~ m/([13579]?)/g);\n    my(@array) = (@array\
    \ < 7 ? @array : @array[0..2]);\n    my($count) = 0;\n    my($fizzBuzz) = undef;",
  "    $n =~ tr/7-9//cd;\n    $n =~ tr/11-1//cd;\n    return $n =~ /11/?1:$n =~ /13/?2:0;\n\
    }", "    my($count) = @_;\n    $n = $n =~ s/^\\+\\k*//;\n    $n = $n =~ s/^-\\\
    k*//;\n    my $divisor = 11;\n    $divisor += $n % $divisor;\n    my $divisor\
    \ = 13;\n    $divisor += $n % $divisor;\n    return $count += ($n % $divisor ==\
    \ 7) ? 1 : 0;\n}", "    my($div) = ($n % 11);\n    my($ndiv) = ($n % 13);\n  \
    \  my($div_count);\n    if ($ndiv == 0 && $div == 0) {\n        $div_count = 0;\n\
    \    } else {\n        if ($div == 0 or $div == 11) {\n            $div_count\
    \ += 1;\n        }\n        if ($ndiv == 0 or $ndiv == 13) {\n            $div_count\
    \ += 1;\n        }\n    }\n    return $div_count;\n}\n</code>\n<|/ a tags=algorithm,ruby,c\
    \ |>\n<| c |>\nThanks for this - it works well. However, can you explain the algorithm\
    \ you've used here? I don't understand what the modulus operator does exactly.\n\
    <|/ c |>\n<| c |>\nIt modulus returns the remainder of a division by the argument\
    \ `%`. The remainder of `7/11 = 0` and `13/11 = 2`. The remainder of `14/11 =\
    \ 1` and `22/11 = 0`. The remainder of `73/11 = 3` and `13/11 = 2`. The remainder\
    \ of `143/11 = 3` and `22/11 = 1`. The remainder of `78/11 = 2` and `13/11 = 1`.\
    \ Etc. It is a bit mathematical, so it might help to think of it as `if $ndiv\
    \ == 0 or $ndiv == 13 or $div == 0 or $div == 11`\n<|/ c |>\n<| c |>\nThanks for\
    \ the explanation\n<|/ c |>\n<| a |>\nYou can try this:\n<code>\ndef fizz_buzz(n)\n\
    \  count = n.div(11).to_i * 10 + n.div(13).to_i\n  return count < 100 ? count.to_s.rjust(2,\
    \ '0') : 'FizzBuzz'\nend\n</code>\n<|/ a tags=algorithm,ruby,c dscore=2 |>\n<|\
    \ a tags=algorithm,ruby,c |>\nHere's the Ruby version:\n<code>\ndef fizz_buzz(n)\n\
    \  return 'FizzBuzz' if (n.to_s.scan(/11|13|14|22|73/).count > 0)\n  return 'Fizz'\
    \ if (n.to_s.scan(/11|13|22/).count > 0)\n  return 'Buzz' if (n.to_s.scan(/11|22/).count\
    \ > 0)\n  return n\nend", "    my(@result) = ();\n    for (my $i = 1; $i < $n;\
    \ $i++) {\n        if ($i % 11 == 0 && $i % 13 == 0) {\n            push(@result,\
    \ \"$i\");\n        } else {\n            push(@result, $i);\n        }\n    }\n\
    \    return scalar(@result);\n}\n</code>\nThis is not the best way to solve this\
    \ problem, but it works for me, since this is just a small bit of code that I\
    \ will be using in multiple places.\n<|/ a dscore=2 tags=perl,arrays |>\n<| c\
    \ |>\nWhat a beautiful solution! I have already marked another answer as correct,\
    \ but I am going to accept yours. You did give me some new perspective and I learned\
    \ something about perl in the process. Thank you for sharing this!\n<|/ c |>\n\
    <| a tags=perl,arrays |>\n<code>", "    $n =~ tr/7/7/;\n    my $count;\n    while\
    \ ($n < 100 && $n >= 10) {\n        $count++ if $n % 11 == 0;\n        $count++\
    \ if $n % 13 == 0;\n        $n /= 10;\n    }\n    return $count unless $count;\n\
    \    return $count;\n}", "    my $count = 0;\n    for(my $x = 1; $x <= $n; $x\
    \ += 11 or $x += 13) {\n        if($n % $x == 0) {\n            $count++;\n  \
    \      }\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nperl\
    \ -le '\n  printf \"%d\\n\", \n    map { \n      my $a = $_ % 11;\n      my $b\
    \ = $_ % 13;\n      $a ? $a : ( $b ? $b : 0 );\n    }\n  ;\n'\n</code>\n<|/ a\
    \ tags=perl dscore=1 |>\n<| c |>\nThanks so much, now I understand the logic behind\
    \ the answer. Just to be clear for beginners, I understand this code as it is\
    \ counting the number of digits from 0 to 20 in a list of numbers between 0 and\
    \ 200. Then, the map function is returning the count of how many times each digit\
    \ occurs (i.e. a count of 2 for the number 8, a count of 3 for the number 7 and\
    \ so on). The printf part just prints out the counts of each. Is my understanding\
    \ correct?\n<|/ c |>\n<| c |>\nYes, your understanding is correct. `map` applies\
    \ a block that returns a single value per element. `printf` prints a value by\
    \ interpreting its number of arguments.\n<|/ c |>\n<| c |>\nThanks so much for\
    \ the explanation\n<|/ c |>\n<| a tags=perl |>\n<code>\nmy $count=0;", "    my\
    \ (@digits);\n    push (@digits, 0) if ($n % 10 == 0);\n    push (@digits, 1)\
    \ if ($n % 10 == 1);\n    push (@digits, 2) if ($n % 10 == 2);\n    push (@digits,\
    \ 3) if ($n % 10 == 3);\n    push (@digits, 4) if ($n % 10 == 4);\n    push (@digits,\
    \ 5) if ($n % 10 == 5);\n    push (@digits, 6) if ($n % 10 == 6);\n    push (@digits,\
    \ 7) if ($n % 10 == 7);", '    my(@result) = (0);', "    return 0 if $n < 10;\n\
    \    return 0 if $n < 100;\n    return 0 if $n < 1000;\n    return 0 if $n < 10000;\n\
    \    return 0 if $n < 100000;\n    return 0 if $n < 1000000;\n    return 0 if\
    \ $n < 10000000;\n    return 0 if $n < 100000000;\n    return 0 if $n < 1000000000;\n\
    \    return 0 if $n < 10000000000;\n    return 0 if $n < 100000000000;\n    return\
    \ 0 if $n < 1000000000000;\n    return 0 if $n < 10000000000000;\n    return 0\
    \ if $n < 100000000000000;\n    return 0 if $n < 1000000000000000;\n    return\
    \ 0 if $n < 10000000000000000;\n    return 0 if $n < 10000000000000000;\n    return\
    \ 0 if $n < 1000000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 10000000000000000;\n    return\
    \ 0 if $n < 10000000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $n < 100000000000000;\n    return 0 if $n < 100000000000000;\n    return\
    \ 0 if $", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n      \
    \  my $is_divisible_by_11 = $i =~ /11$/;\n        my $is_divisible_by_13 = $i\
    \ =~ /13$/;\n        if ($is_divisible_by_11 || $is_divisible_by_13) {\n     \
    \       $count += $is_divisible_by_11 ? 1 : 0;\n            $count += $is_divisible_by_13\
    \ ? 1 : 0;\n        }\n    }\n    return $count;\n}", "    if ($n <= 0) {\n  \
    \      return 0;\n    }\n    my ($factor, $sum) = @{ $n % 11 ? {\n        0 =>\
    \ 0,\n        1 => 1,\n        2 => 2,\n        3 => 3,\n        4 => 4,\n   \
    \     5 => 5,\n        6 => 6,\n        7 => 7\n    } : $n % 13 ? {\n        0\
    \ => 0,\n        1 => 3,\n        2 => 6,\n        3 => 9\n    } : {\n       \
    \ 0 => 0,\n        1 => 0,\n        2 => 0,\n        3 => 0,\n        4 => 0,\n\
    \        5 => 0,\n        6 => 0,\n        7 => 0\n    }};\n    return ($sum +\
    \ $factor);\n}", "    my $count = 0;\n    while ( (($n%11) == 0) || (($n%13) ==\
    \ 0)) {\n        ++$count;\n        $n = $n%11;\n    }\n    return $count;\n}",
  "    my $result = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        $result++ if\
    \ ($i % 11 == 0 || $i % 13 == 0);\n    }\n    return $result;\n}\n</code>\nThis\
    \ code will run in under a second for large values of n, so I hope that's enough\
    \ for you.\n<|/ a tags=math,fizzbuzz |>\n<| c |>\nThe number 100 is not divisible\
    \ by both 11 and 13, so your code will not output \"100 Fizz\" in the output.\n\
    <|/ c |>\n<| c |>\nThat's true; that's what I get for typing this answer while\
    \ sleeping.  I'll update it.  Thanks.\n<|/ c |>\n<| a tags=math,fizzbuzz |>\n\
    <code>\npublic class FizzBuzz {", "    return 0 if $n % 11 == $n % 13;\n    return\
    \ 1 if ($n <= 8);\n    return 2 if ($n <= 9);\n    return 3 if ($n <= 15);\n \
    \   return 4 if ($n <= 19);\n    return 5 if $n <= 23;\n    return 6 if $n <=\
    \ 27;\n    return 7 if $n <= 31;\n    return 8 if $n <= 37;\n    return 9 if $n\
    \ <= 41;\n    return 10 if $n <= 47;\n    return 11 if $n <= 53;\n    return 12\
    \ if $n <= 59;\n    return 13 if $n <= 61;\n}", "    return 0 unless $n =~ /^\\\
    d+$/;\n    my $count = 0;\n    for(my $i = 1; $i <= $n; $i++) {\n        my $num\
    \ = $i;\n        if($num % 11 == 0) {\n            $count++;\n        }\n    \
    \    if($num % 13 == 0) {\n            $count++;\n        }\n        if($num %\
    \ 7 == 0) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "    my $count = 0;\n    $count += 0 while $n >= 11;\n    $count += 0 while $n >=\
    \ 13;\n    return $count;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n: Your code\
    \ is not correct.  It returns `0` for non-factors of `n` but `1`.  If you fix\
    \ the bug I pointed out then it works fine.\n<|/ c |>\n<| c |>\n: thank you for\
    \ pointing that out and also for the corrections. I have corrected my answer,\
    \ and will remove my downvote if you correct your comment.\n<|/ c |>\n<| c |>\n\
    : Your second `while` clause will never return `0` so your first one will never\
    \ work either.  Try it out with the values I gave you and you will see.  Also,\
    \ you can't just downvote someone who isn't asking a good question.  That isn't\
    \ fair.\n<|/ c |>\n<| c |>\n: thank you for the correction.  I guess I wasn't\
    \ paying attention.  I fixed my answer.\n<|/ c |>\n<| c |>\n: I rolled back your\
    \ edit because your edit broke my answer.  If you edit your answer then I will\
    \ be able to downvote your answer and my corrected answer will not make sense.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can do it with regex substitutions, e.g.:\n<code>\n\
    use strict;\nuse warnings;", "    $n =~ tr/123456789/789/;\n    $n = 0;\n    foreach\
    \ (split(//, $n)) {\n        next unless $_ % 11 == 0 && $_ % 13 == 0;\n     \
    \   $n++;\n    }\n    return $n;\n}", "    my($fizz, $buzz) = (0,0);\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        my($digit) = ($_ % 11);\n        my($remainder)\
    \ = $_ % 13;\n        if ($digit == 7) {\n            $fizz++;\n        } elsif\
    \ ($digit == 11 or $digit == 13) {\n            $buzz++;\n        }\n    }\n \
    \   return ($fizz * $buzz);\n}", "    \n    my $i = 1;\n    while ( (($n % 11)\
    \ == 0) || (($n % 13) == 0)) {\n        $i++;\n        $n /= 10;\n    }\n    return\
    \ $i;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,string,perl,number-theory,math\
    \ |>\n<| a |>\nHere's a straightforward way to solve the problem without using\
    \ any regex:\n<code>\nuse 5.010;\nuse warnings;\nuse strict;\nuse Math::NumberTheory;",
  "    my @digits = (\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"\
    , \"9\");\n    my $sum = 0;\n    while ($n >= 0) {\n        if ($n % 11 == 0 &&\
    \ $n % 13 == 0) {\n            $sum += 3;\n        } elsif ($n % 11 == 0) {\n\
    \            $sum += 1;\n        } elsif ($n % 13 == 0) {\n            $sum +=\
    \ 1;\n        }\n        $n = ($n - $n % 10) / 10;\n    }\n    return $sum;\n}",
  '    my $count = 0;', "    return 0 unless $n;\n    return 0 if $n % 11;\n    return\
    \ 0 if $n % 13;\n    return 2 if $n % 7;\n    return 3 if $n % 5;\n    return\
    \ 1 if $n % 3;\n    return 4;\n}", "    my(@result) = (0);\n    for(my $i = 1;\
    \ $i <= $n; $i++) {\n        if($i % 11 == 0 && $i % 13 == 0) {\n            push(@result,\
    \ \"$i\");\n        }\n        if($i % 11 == 0 && $i % 13 != 0) {\n          \
    \  push(@result, \"$i\");\n        }\n        if($i % 11 != 0 && $i % 13 == 0)\
    \ {\n            push(@result, \"$i\");\n        }\n        if($i % 11 != 0 &&\
    \ $i % 13 != 0) {\n            push(@result, \"$i\");\n        }\n    }\n    return\
    \ scalar(@result);\n}", '    my($counter) = 0;', '    my($count) =;', "    my(@numbers)\
    \ = grep { $_ % 11 == 0 || $_ % 13 == 0 } 1 .. $n;\n    my($count=0) = 0;\n  \
    \  foreach(@numbers) {\n        if($_ % 11 == 0 || $_ % 13 == 0) {\n         \
    \   $count += 1;\n        }\n    }\n    return $count;\n}\n</code>\nThe reason\
    \ for putting the conditional operator in parentheses is so that it will only\
    \ be executed if the previous conditional evaluates to true.\n<|/ a dscore=2 tags=performance,optimization,perl,if-statement\
    \ |>\n<| c |>\nThe downside of splitting up the conditions is that you'll have\
    \ to evaluate them multiple times.  So it's better to leave them as separate conditionals.\n\
    <|/ c |>\n<| c |>\n: No, it's better to leave them as separate conditionals, but\
    \ to move the `||` out of the conditional.\n<|/ c |>\n<| c |>\n: As long as `&&`\
    \ works as expected. `($_ % 11 == 0 && $_ % 13 == 0)` is more readable than `($_\
    \ % 11 == 0) || ($_ % 13 == 0)`, but is less clear to someone who doesn't know\
    \ Perl.\n<|/ c |>\n<| c |>\nI agree with you that `&&` is clear to someone who\
    \ knows Perl.  But `||` is not.  I'd use `&&` in this case, but I see your point\
    \ and will change the code accordingly.\n<|/ c |>\n<| c |>\n: Yes, I agree.  I\
    \ meant to say that splitting up the conditions is bad practice.  So I think it\
    \ is better to leave them as separate conditionals, but to move the `||` out of\
    \ the conditional.\n<|/ c |>\n<| a |>\nYou can combine several comparisons with\
    \ a single comparison:\n<code>", "    return 0 if $n < 10;\n    return 2 if $n\
    \ % 11 == 0;\n    return 3 if $n % 13 == 0;\n    return 1;\n}", "    my(@results);\n\
    \    # Initialize and fill the array\n    for($n; $n <= @{[ grep { ($_ % 11) ==\
    \ 0 || ($_ % 13) == 0 } 1 .. $n ]};\n    push(@results,0);\n    # Fill the array\
    \ with multiples of 11 and multiples of 13 while less than or equal to n.\n  \
    \  for($n; $n <= @{[ grep { ($_ % 11) == 0 && $_ % 13 != 0 && $_ % 2 != 0 } 1\
    \ .. $n ]};\n    push(@results,2);\n    # Fill the array with multiples of 13\
    \ and multiples of 11 while less than or equal to n.\n    for($n; $n <= @{[ grep\
    \ { ($_ % 13) == 0 && $_ % 11 != 0 && $_ % 2 != 0 } 1 .. $n ]};\n    push(@results,3);\n\
    \    # Fill the array with multiples of both 11 and 13 while less than or equal\
    \ to n.\n    for($n; $n <= @{[ grep { ($_ % 11) == 0 && $_ % 13 == 0 && $_ % 2\
    \ != 0 } 1 .. $n ]};\n    push(@results,4);\n    # Fill the array with multiples\
    \ of both 11 and 13 while greater than or equal to n.\n    for($n; $n <= @{[ grep\
    \ { ($_ % 11) == 0 && $_ % 13 == 0 && $_ % 2 == 0 } 1 .. $n ]};\n    push(@results,5);\n\
    \    # Fill the array with multiples of both 11 and 13 while greater than or equal\
    \ to n and divisible by 7.\n    for($n; $n <= @{[ grep { ($_ % 11) == 0 && $_\
    \ % 13 == 0 && $_ % 2 == 0 && $_ % 7 == 0 } 1 .. $n ]};\n    push(@results,6);\n\
    \    # Fill the array with multiples of both 11 and 13 while greater than or equal\
    \ to n and divisible by 7.\n    for($n; $n <= @{[ grep { ($_ % 11) == 0 && $_\
    \ % 13 == 0 && $_ % 2 == 0 && $_ % 7 ne 0 } 1 .. $n ]};\n    push(@results,7);\n\
    \    # Fill the array with multiples of both 11 and 13 while greater than or equal\
    \ to n and divisible by 7.\n    for($n; $n <= @{[ grep { ($_ % 11) == 0 && $_\
    \ % 13 == 0 && $_ % 2 == 0 && $_ % 7 ne 0 && $_ % 7 != 0 } 1 .. $n ]};\n    push(@results,8);",
  "    if ($n >= 10) {\n        if ($n % 11 == 0 or $n % 13 == 0) {\n            return\
    \ 0;\n        }\n    }\n    $n += $n % 10;\n    return 1 if ($n >= 100 and $n\
    \ <= 999);\n    $n -= 100 if $n >= 100;\n    return 2 if ($n >= 1000 and $n <=\
    \ 9999);\n    $n -= 1000 if ($n >= 1000 and $n <= 9999);\n    return 3 if ($n\
    \ >= 10000 and $n <= 99999);\n    $n -= 10000 if ($n >= 10000 and $n <= 99999);\n\
    \    return 4 if ($n >= 100000 and $n <= 999999);\n    $n -= 100000 if ($n >=\
    \ 100000 and $n <= 999999);\n    return 5 if ($n >= 1000000 and $n <= 9999999);\n\
    \    $n -= 1000000 if ($n >= 1000000 and $n <= 9999999);\n    return 6 if ($n\
    \ >= 10000000 and $n <= 99999999);\n    $n -= 10000000 if ($n >= 10000000 and\
    \ $n <= 99999999);\n    return 7 if ($n >= 100000000 and $n <= 999999999);\n \
    \   $n -= 100000000 if ($n >= 100000000 and $n <= 999999999);\n    return 8 if\
    \ ($n >= 1000000000 and $n <= 99999999999);\n    $n -= 1000000000 if ($n >= 1000000000\
    \ and $n <= 99999999999);\n    return 9 if ($n >= 1000000000000 and $n <= 999999999999);\n\
    \    $n -= 1000000000000 if ($n >= 1000000000000 and $n <= 999999999999);\n  \
    \  return 10 if ($n >= 100000000000000 and $n <= 99999999999999);\n    $n -= 100000000000000\
    \ if $n >= 100000000000000 and $n <= 99999999999999;\n    return 11 if ($n >=\
    \ 1000000000000000000 and $n <= 999999999999999999);\n    $n -= 1000000000000000000\
    \ if ($n >= 1000000000000000000 and $n <= 999999999999999999);\n    return 12\
    \ if ($n >= 100000000000000000000 and $n <= 999999999999999999);\n    $n -= 100000000000000000000\
    \ if $n >= 100000000000000000000 and $n <= 999999999999999999;\n    return 13;\n\
    }\n</code>\n<|/ a tags=perl,fizzbuzz,modulo,algorithm dscore=1 |>\n<| c |>\nIt's\
    \ interesting that a question like this hasn't been asked many times before! I\
    \ wonder how we might find the answers if we hadn't asked the question?\n<|/ c\
    \ |>\n", "    return 0 if $n < 3;\n    my $digits_over_11 = $n % 11;\n    my $digits_over_13\
    \ = $n % 13;\n    if ($digits_over_11 eq 7 and $digits_over_13 eq 7) {\n     \
    \   return 2;\n    } elsif ($digits_over_11 eq 7 and $digits_over_13 eq 3) {\n\
    \        return 1;\n    } else {\n        return 0;\n    }\n}\n</code>\n<|/ a\
    \ tags=modulus,perl |>\n<| c |>\nI think my teacher wants us to do everything\
    \ using if-else-if statements.\n<|/ c |>\n<| c |>\nI added a version using if-else\
    \ statements which should be easier to follow and understand than the one you\
    \ posted in the question.\n<|/ c |>\n<| c |>\n, that code is actually better than\
    \ the one in my answer, so I've removed it. I had no idea the question was this\
    \ poorly written.\n<|/ c |>\n<| c |>\nI understand why some people are against\
    \ this type of questions, but I think its better to learn the basics than just\
    \ copy and paste code and try to learn it from there. Its not as hard as you are\
    \ doing, and it shows that you are actually doing it on your own and actually\
    \ understanding it.\n<|/ c |>\n<| c |>\n: I would say that it's actually easier\
    \ to understand the if-else than it would be for me. That's the important distinction:\
    \ learning is worth more than just knowing the answer to this one.\n<|/ c |>\n\
    <| a |>\nThis is not an answer to the question as stated, but perhaps this is\
    \ an idea that would help to solve the problem.  \nThis question asks us to find\
    \ all the possible divisors of an integer, then loop through the possible divisors,\
    \ printing them all out.  \nA good way to get all possible divisors of an integer\
    \ is to use prime factorization, which can be done with the Diamond problem. \n\
    In fact, the problem solves it this way: ", "    return 0 unless $n;\n    my $cnt\
    \ = 0;\n    for my $d (0 .. $#$n) {\n        next if $d & 1;\n        my $div\
    \ = $n / 11;\n        $cnt += 0 if $n % $div == 7;\n    }\n    return $cnt;\n}",
  "    my $count = 0;\n    my $d = int($n % 10);\n    $d =~ tr/7/7/;\n    if ($d !=\
    \ 0) {\n        $count++;\n    }\n    while ($n =~ tr/7/7/) {\n        $count++;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", " \
    \   return 0 unless $n =~ /^\\d+$/;\n    my($count, $digit);\n    my($i); # loop\
    \ variable\n    for (; $i < $n; $i++) {\n        $digit = sprintf '%03d', $i;\n\
    \        next unless $i % 11 == 0 ||\n                    $i % 13 == 0;\n    \
    \    if ($digit == 73) { $count++; }\n    }\n    return $count;\n}", "    if ($n\
    \ =~ m/7/g) {\n\treturn 0;\n    }\n    elsif ($n % 11 == 0 && $n % 13 == 0) {\n\
    \treturn 2;\n    }\n    elsif ($n % 11 != 0) {\n\treturn 3;\n    }\n    elsif\
    \ ($n % 13 != 0) {\n\treturn 4;\n    }\n    else {\n\treturn 1;\n    }\n}", " \
    \   my($fizzbuzz) = 0;\n    while ($n >= 11 || $n >= 13) {\n        $fizzbuzz\
    \ += $n =~ m{^(11|13)$}oi;\n    }\n    return $fizzbuzz;\n}", "    return 0 if\
    \ ($n <= 0);\n    my($m, $i, $j, $result);", '    my(@result) = ();', "    my\
    \ $fizzbuzz_count;\n    if ($n < 0) {\n        $fizzbuzz_count = -1;\n    }\n\
    \    else {\n        $fizzbuzz_count = 0;\n    }", "    $n =~ s/^0+(?!\\d).*//s;\n\
    \    $n =~ tr/7/7/s;\n    return $n / 11 + ($n / 13 ? 1 : 0);\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nAm I missing something or this code is buggy? The third\
    \ fizz_buzz output is not correct and it should be 4.\n<|/ c |>\n<| a |>\nThe\
    \ other answers look good, but I thought I'd add my own:\n<code>\nmy $digit =\
    \ 7;\nmy $count = 1;", '    my($c);', "    my($i);\n    my $count = 0;\n    for(;\
    \ $n < $big_int; $n++) {\n\t$i .= $_;\n\tfor ($i; $i > 0; $i--) {\n\t    next\
    \ if $i % 11 == 0 || $i % 13 == 0;\n\t    $count++;\n\t}\n    }\n    return $count;\n\
    }", "    my($z) = $n % 11;\n    if ($z) {\n        return $z+1;\n    }\n    return\
    \ $n % 13;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat is not the answer. The\
    \ question is asking for Fizz Buzz algorithm. Fizz Buzz is a programming problem.\n\
    <|/ c |>\n<| c |>\nI agree with Jim. I'm not a fan of \"copy and paste ready solutions,\"\
    \ but in this case I find it really helpful. Plus I like that it's simple and\
    \ concise! I like that I don't need to worry about a particular way of solving\
    \ this problem (e.g., using recursion or not), because I'm always going to get\
    \ the same answer regardless of the way I solve it.\n<|/ c |>\n<| c |>\nI agree\
    \ with you too, I realize now that I didn't give an answer that exactly answered\
    \ the question but rather just gave him a way to do it that works. I guess I should\
    \ have said something about the benefits of copy/paste. Also, I don't see it as\
    \ a copy/paste solution, although it works :)\n<|/ c |>\n<| c |>\nThe benefit\
    \ is actually that it doesn't need copy/paste or refactoring. The second time\
    \ the algorithm is run it returns the answer to the first run. Thus it works.\n\
    <|/ c |>\n<| c |>\nYeah, I like it. Not sure why I didn't think of that. Thanks!\n\
    <|/ c |>\n<| a tags=algorithm,math,fizzbuzz,c++ |>\nThis is the solution I came\
    \ up with. It has both an algorithm and a solution in C++:\n<code>\n// fizzbuzz.cpp\
    \ - Find FizzBuzz in an int\n//\n// Written by Ben Krooker\n// http://benkrooker.com\n\
    // http://benkrooker.com/blog/2009/11/fizzbuzz-in-c-using-recursion/\n//\n// Adapted\
    \ from https://www.geeksforgeeks.org/fizzbuzz-set-2-using-recursion-programming/",
  "    my $count = 0; # Initialize count to zero\n    $n += 0 while ($n % 11);\n \
    \   $n += 0 while ($n % 13);\n    return $count;\n}", "    my $count = 0;\n  \
    \  while ($n =~ /11|13/) {\n        $count++;\n        $n =~ s/(11|13)//;\n  \
    \  }\n    return $count;\n}", "    my $count = 0;\n    for (my $i = 1; $i <= $n;\
    \ $i++) {\n        $count++ if $i % 11 == $i % 13;\n    }\n    return $count;\n\
    }", '    my $count = 0;', "    my $count = 0;\n    for (my $i = 0; $i < $n; $i++)\
    \ {\n        $count++ while ($i =~ /7$/);\n        $count++ while ($i =~ /11$/);\n\
    \        $count++ while ($i =~ /13$/);\n    }\n    return $count;\n}", "    my\
    \ $count = 0;\n    if ( $n < 10 ) {\n        $count += $n // 10 if $n % 10;\n\
    \    }\n    elsif ( $n < 100 ) {\n        $count += ($n % 10) + fizz_buzz($n //\
    \ 100);\n    }\n    elsif ( $n < 1000 ) {\n        $count += ($n % 100) + fizz_buzz($n\
    \ // 1000);\n    }\n    elsif ( $n < 10000 ) {\n        $count += ($n % 1000)\
    \ + fizz_buzz($n // 10000);\n    }\n    elsif ( $n < 100000 ) {\n        $count\
    \ += ($n % 10000) + fizz_buzz($n // 100000);\n    }\n    elsif ( $n < 1000000\
    \ ) {\n        $count += ($n % 100000) + fizz_buzz($n // 1000000);\n    }\n  \
    \  elsif ( $n < 10000000 ) {\n        $count += ($n % 100000) + fizz_buzz($n //\
    \ 10000000);\n    }\n    elsif ( $n < 100000000 ) {\n        $count += ($n % 100000)\
    \ + fizz_buzz($n // 100000000);\n    }\n    elsif ( $n < 1000000000 ) {\n    \
    \    $count += ($n % 100000) + fizz_buzz($n // 1000000000);\n    }\n    elsif\
    \ ( $n < 10000000000 ) {\n        $count += ($n % 100000) + fizz_buzz($n // 10000000000);\n\
    \    }\n    elsif ( $n < 100000000000 ) {\n        $count += ($n % 100000) + fizz_buzz($n\
    \ // 100000000000);\n    }\n    elsif ( $n < 1000000000000 ) {\n        $count\
    \ += ($n % 100000) + fizz_buzz($n // 1000000000000);\n    }\n    elsif ( $n <\
    \ 10000000000000 ) {\n        $count += ($n % 100000) + fizz_buzz($n // 10000000000000);\n\
    \    }\n    elsif ( $n < 100000000000000 ) {\n        $count += ($n % 100000)\
    \ + fizz_buzz($n // 100000000000000);\n    }\n    elsif ( $n < 1000000000000000\
    \ ) {\n        $count += ($n % 100000) + fizz_buzz($n // 1000000000000000);\n\
    \    }\n    elsif ( $n < 10000000000000000 ) {\n        $count += ($n % 100000)\
    \ + fizz_buzz($n // 10000000000000000);\n    }\n    ", "    return if $n > 11;\n\
    \    return if $n % 11 == 0 || ($n % 13 == 0 && $n != 13);\n    my $count = 0;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        if ($i % 11 == 0 || $i % 13 ==\
    \ 0) {\n            $count++;\n        }\n    }\n    return $count;\n}", "   \
    \ my $count = 0;\n    while (my $d = $n / 11) {\n        $count += $d if ($d %\
    \ 11 == 7);\n        $n /= 11;\n    }\n    return $count;\n}", "    my($sum);\n\
    \    my($digit);\n    my($counts);", "    \n    my $count = 0;\n    \n    while($n\
    \ =~ m/\\b7\\b/) {\n        $count++;\n        $n =~ s/\\b7\\b/1/g;\n    }\n \
    \   return $count;\n}", "    my($fz) = 79;\n    my($fb) = 0;\n    my($z);\n  \
    \  $n =~ tr/7/7/;\n    foreach $z (1, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79) {\n        if ($n eq $z) {\n            $fb++;\n\
    \            last;\n        }\n    }\n    return $fb;\n}", "    \n    # Find the\
    \ numbers divisible by 11 and 13\n    my($i, $j, $divisible_by_11, $divisible_by_13);\n\
    \    for ($i = $n; $i > 0; $i -= 10) {\n        ($divisible_by_11, $divisible_by_13)\
    \ = (($i % 11) == 0), ($i % 13);\n        if ($divisible_by_11 || $divisible_by_13)\
    \ {\n            last;\n        }\n    }\n    \n    # Count the number of digits\
    \ 7 in the integers less than n\n    my(@numbers);\n    for (; $n > 0; $n -= 10)\
    \ {\n        push (@numbers, $n / 10);\n    }\n    my($count);\n    foreach $number\
    \ (@numbers) {\n        $count = 0;\n        for (; $number > 0; $number /= 10)\
    \ {\n            if ($number == 7) {\n                $count++;\n            }\n\
    \        }\n    }\n    \n    return $count;\n}\n</code>\n<|/ a dscore=1 tags=fizzbuzz,perl\
    \ |>\n<| a tags=fizzbuzz,perl |>\n<code>", "    my $count = 0;\n    my $div =\
    \ 11;\n    my $ndiv = $n / $div;\n    my $remainder = $n % $div;", "    return\
    \ 0 unless $n =~ /^\\d+$/;\n    my($i, $j, $digit, $index);\n    $index = 0;\n\
    \    while(1) {\n        $digit = $n / 11;\n        $n = $n % 11;\n        $i\
    \ .= $digit == 7 ? \"1\" :\n            $digit == 5 ? \"11\" :\n            $digit\
    \ == 4 ? \"111\" :\n            $digit == 3 ? \"1111\" :\n            $digit ==\
    \ 2 ? \"11111\" :\n            $digit == 1 ? \"111111\" :\n            $digit;\n\
    \        $j = $j % 13; # No need to check for divisors below 10\n        $index++;\n\
    \        if($j==0) {\n            return $index;\n        }\n    }\n}", '    my($i,$j);',
  '    my($counter);', "    my($ret);\n    if ( $n =~ /\\b7\\b/ ) {\n        $ret\
    \ = 0;\n    }\n    else {\n        $ret = 1 + $fizz_buzz( ($n % 11) / 13);\n \
    \   }\n    return $ret;\n}\n</code>\n<|/ a tags=recursion,perl,fizzbuzz |>\n<|\
    \ c |>\nYou know, I hadn't thought of that. I guess I still have some more reading\
    \ to do on recursion.\n<|/ c |>\n<| a |>\nYou might want to check out \"Algorithms\
    \ and Data Structures\" by Robert Sedgewick and Kevin Wayne (published by O'Reilly),\
    \ chapter 11. Fibonacci sequence and FizzBuzz algorithm - it's a great reference\
    \ for learning about recursion.\n<|/ a tags=recursion,perl,fizzbuzz dscore=1 |>\n\
    <| a |>\nHere's an excerpt from my \"The Algorithms and Data Structures\" book,\
    \ chapter 11 (the Fizz Buzz algorithm):\nFizz Buzz Recursion\nThe FizzBuzz algorithm\
    \ is simple, but very useful to see what kind of recursion\ncan be written with\
    \ it. Consider this recursive function that counts the number of Fizz Buzz\nnumbers\
    \ starting with $n. We have one special case in our recursive algorithm\nwhen\
    \ the number is divisible by 3, and we print the number as a Fizz Buzz number\n\
    instead of printing the number as a number.\n<code>", "    my $f=0;\n    for(my\
    \ $i = 1; $i <= $n; ++$i) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n   \
    \         $f++;\n        }\n    }\n    return $f;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=perl,recursion dscore=1 |>\nIf you're going to use Perl, don't\
    \ use regexes, just use regex.  That way you can avoid looping over the numbers\
    \ you've already seen. \nAlso, you can test whether a number is divisible by 3\
    \ or 5 using modulus.\n<|/ a |>\n<| a tags=perl,recursion |>\nThis may help\n\
    <code>\nuse strict;\nuse warnings;", "    my($num) = 0;\n    for(my $i = 0; $i\
    \ < $n; $i += 11) {\n        $num += $i if $i / 11 == 0 || $i / 13 == 0;\n   \
    \ }\n    return $num;\n}\n</code>\nIt also demonstrates that there is no need\
    \ to call our function from inside another function. Since our function takes\
    \ only one argument, it can use the $n variable from the outer scope without having\
    \ to pass it into the function.\n<code>\nmy $n; # Initialize our $n variable to\
    \ 0.\n$n = fizz_buzz(78);\nprint \"$_\\n\" for qw/0 2 3 4 5 6 7 8 9/ for 1..$n;\n\
    </code>\n<|/ a tags=perl,fizzbuzz |>\n<| a |>\nTry something like this - \n<code>\n\
    use strict;\nuse warnings;", "    my $counter = 0;\n    for($count = 0; $count\
    \ < $n; $count++) {\n        if ($n >= ($count * 11 + 13)) {\n            $counter++;\n\
    \        }\n    }\n    return $counter;\n}", "    my $c = $n % 11;\n    my $d\
    \ = $n % 13;\n    return $c if $c > 0;\n    return $d if $d > 0;\n    return $n\n\
    }", '    my $i;', "    $n =~ tr/7/07;\n    return $n / 11 or $n / 13;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThe last line is wrong.  Try:  `sub fizz_buzz {\n\
    \    my($n) = @_;\n    $n =~ tr/7/07;\n    return $n / 11 or $n / 13;\n}\nprint\
    \ fizz_buzz(78); # => 2`\n<|/ c |>\n<| c |>\nYou are right that my code example\
    \ was incorrect.  I corrected it.\n<|/ c |>\n<| a dscore=4 |>\nUse this code.\
    \ It will return how many times number 7 appears in fizzbuzz sequence.\n<code>",
  "    return 1 if $n <= 9;\n    return 2 if $n <= 99;\n    return 3 if $n <= 999\
    \ & $n % 11 == 0;\n    return 4 if $n <= 999 & $n % 13 == 0;\n    return 5 if\
    \ ($n % 11 == 0 && ($n % 13 == 0 || $n / 13 == 0)) ? 1 : 0;\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThanks, I like how succinct it is! I wonder why it's so\
    \ difficult to find a solution on SO.\n<|/ c |>\n<| c |>\nBy the way, I'm sorry\
    \ I didn't make it clear enough in my question. I meant that I can't use if/else,\
    \ but I'm looking for some sort of recursive solution.\n<|/ c |>\n<| c |>\nThe\
    \ only way you could do this recursively would be to loop through every number\
    \ and count how many times `7` occurs in it.\n<|/ c |>\n<| c |>\nRight, I understand\
    \ the looping part now. Thanks for the explanation.\n<|/ c |>\n<| a tags=perl,math,fizzbuzz,algorithm\
    \ |>\nThe trick is to break the problem down into a finite number of steps and\
    \ then use conditionals to control which step to go to. The conditionals here\
    \ are all \"OR\" conditionals because it is assumed that the first step will always\
    \ be executed if the first condition is true and likewise with the next two steps.\
    \ \n<code>\nuse strict;\nuse warnings;", "    my($n2);\n    my(@n3);\n    my(@n4);\n\
    \    my(@n5);\n    my(@n7);\n    my(@n9);\n    my(@n13);\n    my(@n7);\n    my(@n7);\n\
    \    my($i);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n\
    \    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@n8);\n    my(@", "    if($n\
    \ <= 100) {\n        if($n % 11 == 0){\n            my $result = $n / 11;\n  \
    \          if($result != 0){\n                return $result;\n            }\n\
    \        }\n        elsif($n % 13 == 0){\n            my $result = $n / 13;\n\
    \            if($result != 0){\n                return $result;\n            }\n\
    \        }\n        return $n if $n > 100;\n    }\n    return -1;\n}", "    my\
    \ $count = 0;\n    $n = ~/^(?:(^|\\s)(\\d)(7(\\d)|\\d))$/ or $count++;\n    $count\
    \ = 1 + $count*$n{11};\n    $count = 1 + $count*$n{13};\n    $count;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nIf it's allowed to use regular expressions,\
    \ then the solution becomes as simple as\n<code>\n$str =~ /^7(\\d)$/\n</code>\n\
    It would also work to test for divisibility by other primes:\n<code>\n$str =~\
    \ /^7(\\d)$/i\n</code>\nI believe this will work in Perl 5.10 or later, but I\
    \ haven't tested.\n<|/ a tags=regex,perl |>\n<| a dscore=1 tags=regex,perl |>\n\
    Just for fun you can also count how many times 7 appears in a string:\n<code>\n\
    my $s = '7898';\nmy $count = $s =~ s/7//g;\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work as it returns 1 instead of 2. It actually counts the number of `7`s, but\
    \ not the 7s themselves.\n<|/ c |>\n<| a tags=regex,perl |>\nI suggest to rewrite\
    \ your regex so that it can check for digits after 7 character (instead of only\
    \ 7).\n<code>\nif ( $string =~ /7(\\d\\d)/ ) { \n  my $count = $1 // 0;\n  ...\
    \ \n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nYou can use a lookahead assertion:\n\
    <code>\n$str =~ /^(?=7\\d)7$/ ? \"Found\" : \"Not Found\";\n</code>\nThe lookahead\
    \ checks for 7 and any digit, and if found, matches 7 and any digit.\n<|/ a tags=regex,perl\
    \ |>\n<| c |>\nLookahead assertions are only available since Perl 5.10; prior\
    \ to that you have to check the return value of `$str =~ /^(?=7\\d)7$/`.\n<|/\
    \ c |>\n<| a dscore=1 tags=regex,perl |>\nI came up with this, it may not be the\
    \ most elegant solution, but is working:\n<code>", "    # Initialize a variable\
    \ to count the matches. Initialize to -1 to start with.\n    my($matches) = -1;\n\
    \    \n    # Loop over the integers in n and test the modulo.\n    for (1..$n)\
    \ {\n        my $test = $_ % 11;\n        $matches += ($test == 7);\n    }\n \
    \   \n    # Return the count of matches.\n    return $matches;\n}\n</code>\nIn\
    \ general, though, you should try to avoid a lot of if statements and switches\
    \ in favor of more concise and readable code.\n<|/ a tags=perl,modular |>\n<|\
    \ c |>\n+1 for not just giving OP their solution, but explaining how it works.\n\
    <|/ c |>\n<| c |>\n: Thanks. I added some explanation. Hope it helps.\n<|/ c |>\n\
    <| c |>\nThanks for your solution. However I cannot use loops, as I cannot use\
    \ loops in my assignment. I know your solution works, but my teacher wants us\
    \ to avoid loops.\n<|/ c |>\n<| a tags=perl,modular |>\nThe answer that you are\
    \ looking for is a recursive function - a function that calls itself. To do this\
    \ you pass the function the current number and the current number of matches that\
    \ have been found. The function can then check if the current number was divisible\
    \ by 11 or 13 and if so adds 1 to $matches and then calls itself with the next\
    \ number.\n<code>", '    my($count);', "    my(@list) = ();\n    my($counter)\
    \ = 0;", '    my($ret);', "    my $count = 0;\n    while($n > 7) {\n        $count++;\n\
    \        $n = $n - 11;\n    }\n    while($n > 1) {\n        $count++;\n      \
    \  $n = $n - 13;\n    }\n    $count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nI prefer this solution:\n<code>", '    my ($first_half, $second_half);',
  "    my @num = map { $_ % 11 ? $_ : '13' } @nums;\n    my $result = grep { $_ eq\
    \ '7' } @num;\n    $result ? @num : undef;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThank you for your answer! But I want the result as I mentioned in my\
    \ question (the fizz buzz result)\n<|/ c |>\n<| c |>\nOk, I didn't see the fizz\
    \ buzz part, I thought it was about finding the first digit in a given number,\
    \ so my solution does solve it\n<|/ c |>\n<| c |>\nI updated my answer with a\
    \ new solution that fits your requirements.\n<|/ c |>\n<| a tags=fizzbuzz,perl\
    \ |>\n<code>", "    # Only look at multiples of 3 or 5.\n    return $n if $n %\
    \ 5 == 0 || $n % 3 == 0;\n    # Look at multiples of 3 or 5 and only look for\
    \ multiples of 7.\n    return 0 if $n % 5 == 0 && $n % 3 == 0 && $n % 7 == 0;\n\
    \    # Look for multiples of 3 or 5 and only look for multiples of 7.\n    return\
    \ 0 if $n % 5 == 0 && $n % 3 == 0 && $n % 7 != 0;\n    # Look for multiples of\
    \ 5 only.\n    return 0 if $n % 5 == 0;\n}", "    my $count = $n / 11;\n    $count\
    \ += $n / 13;\n    return $count;\n}\n</code>\nThe same can be done using regex:\n\
    <code>", "    my(@result) = (0);\n    $n = $n + (10 * $n);\n    while ($n) {\n\
    \        my $div = 11 - $n % 11;\n        my $mod = $n % 10;", '    return 0 if
    $n <= 1;', "    my(@result) = ();\n    for(my $i = 1; $i <= $n; $i++) {\n    \
    \    if($i =~ m/^(11|13)$/ && $i % 11 eq 0) {\n            push(@result, $i);\n\
    \        }\n    }\n    return scalar(@result);\n}", "    if ($n < 11 || $n < 13)\
    \ {\n        return 0;\n    } elsif ($n % 11 == 0) {\n        return 1;\n    }\
    \ elsif ($n % 13 == 0) {\n        return 2;\n    } else {\n        return 3;\n\
    \    }\n}", "    my(@result) = ();\n    while ($n) {\n        $n = $n % 11;\n\
    \        push, $n % 13 ? $n : sprintf \"%3d\", $n;\n        $n = $n / 13;\n  \
    \  }\n    return scalar(@result);\n}", "    my $count = 0;\n    for (1 .. $n)\
    \ {\n        $count += ($_ % 11) == 0 || $_ % 13 == 0 ? 1 : 0;\n    }\n    return\
    \ $count;\n}", "    my $count = @_ == 2 ? $n->[0] eq $n->[1] ? 1 : 2 : 3;\n  \
    \  \n    for (my $i = 0; $i <= $count; $i++) {\n        my($divisible_by_11or13)\
    \ = ('11' eq $n->[$i] || '13' eq $n->[$i]);\n        \n        next if $divisible_by_11or13;\n\
    \        \n        if ($divisible_by_11or13 && $n->[$i] =~ /7/) {\n          \
    \  $n->[$i] = 0;\n            $n->[$i] += $i;\n        }\n        \n        next\
    \ if $n->[$i] !~ /7/;\n        \n        if ($n->[$i] =~ /5/) {\n            $n->[$i]\
    \ .= $i;\n        }\n        \n        next if $n->[$i] =~ /5/;\n        \n  \
    \      if ($n->[$i] =~ /4/) {\n            $n->[$i] .= $i;\n        }\n      \
    \  \n        next if $n->[$i] =~ /4/;\n        \n        if ($n->[$i] =~ /3/)\
    \ {\n            $n->[$i] .= $i;\n        }\n        \n        next if $n->[$i]\
    \ =~ /3/;\n        \n        if ($n->[$i] =~ /2/) {\n            $n->[$i] .= $i;\n\
    \        }\n        \n        next if $n->[$i] =~ /2/;\n        \n        if ($n->[$i]\
    \ =~ /1/) {\n            $n->[$i] .= $i;\n        }\n        \n        next if\
    \ $n->[$i] =~ /1/;\n    }\n    \n    return $count;\n}", '    my @num;', "   \
    \ my $remainder;\n    my $count = 0;", "    my $count = 0;\n    for my $num (1..$n)\
    \ {\n        return $count if $num % 11 == 0 || $num % 13 == 0;\n        $count++;\n\
    \    }\n    return $count;\n}", "    my($fizz, $buzz) = (0);\n    $fizz++ if ($n\
    \ % 11 == 0);\n    $buzz++ if ($n % 13 == 0);\n    return $buzz if $n > 1000;\n\
    \    return $fizz if $n < 1000;\n    return 0;\n}", "    my $cnt = 0;\n    while($n\
    \ >= 100) {\n        $cnt += $n =~ /\\b7\\b/;\n        $n /= 100;\n    }\n   \
    \ return $cnt;\n}", "    return 0 if $n <= 0;\n    my($i, $j, $k) = (0, 0);\n\
    \    my($ret, $max_num, $max_index, $max_remainder) = (0, 0);\n    while($n >\
    \ 10) {\n        $max_num = $n % 11;\n        $max_remainder = $n % 10;\n    \
    \    $ret += $max_num if $max_num == 7 or $max_num == $max_remainder == 7;\n \
    \       $n /= 10;\n    }\n    while($n > 1) {\n        $max_num = $n % 11;\n \
    \       $max_remainder = $n % 10;\n        $ret += $max_num if $max_num == 7 or\
    \ $max_num == $max_remainder == 7;\n        $n /= 10;\n        $j += 1;\n    }\n\
    \    return $ret;\n}", "    my $count = 0;\n    while ($n =~ /7\\d/ or $n =~ /11\\\
    d/) {\n        $count++;\n        $n =~ s/7/8/g;\n        $n =~ s/11/13/g;\n \
    \   }\n    return $count;\n}\n</code>\nI hope this helps.\n<|/ a dscore=1 tags=fizzbuzz,perl,regex\
    \ |>\n<| a dscore=1 |>\nA more idiomatic solution would be:\n<code>\nuse v5.14;\n\
    use strict;\nuse warnings;", "    my($a) = 0;\n    my($c) = 0;\n    for(my $i=0;\
    \ $i<$n; $i++) {\n        my $n = $n % 11;\n        my $n = $n % 13;", "    my\
    \ @digits = ( 7, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21 );\n    my @result = ();",
  "    my(@result) = ($n);\n    for ($n = 1; $n <= $#result; $n++) {\n        my $x\
    \ = $result[$n];\n        if ($x % 11 != 0) {\n            $result[$n] = 0;\n\
    \        }\n        elsif ($x % 13 != 0) {\n            $result[$n] = 1;\n   \
    \     }\n    }\n    return scalar(@result);\n}", "    my($fb_count) = 0;\n   \
    \ my(@fb_numbers) = (7,11,13);\n    for ($n -= 1, $n >= 0; $n -= 1) {\n      \
    \  ($fb_count += 1 if $fb_numbers[$n % 3] eq 7);\n    }\n    return $fb_count;\n\
    }", '    my(@results);', "    my @s = ();\n    my @v = ();\n    my $x;\n    my\
    \ $m;\n    my $n;", "    return 0 unless $n > 0 && $n <= 100;\n    my($i) = 0;\n\
    \    while(my $n = $n){\n        if($i % 11 == 0 || $i % 13 == 0) {\n        \
    \    $i++;\n        } else {\n            return $i;\n        }\n        $i++;\n\
    \    }\n    return $i;\n}", '    my $result = 0;', "    return 1 if ($n % 11 ==\
    \ $n % 13);\n    return 0 if ($n =~ /^(11|13)$/);\n    return 0 if ($n % 11 ==\
    \ 0);\n    return 2 if ($n % 13 == 0);\n}", "    my $count = 1 if $n =~ /\\d{7}/;\n\
    \    $count += 1 if $n =~ /\\d{6}/;\n    $count += 1 if $n =~ /\\d{5}/;\n    $count\
    \ += 1 if $n =~ /\\d{4}/;\n    $count += 1 if $n =~ /\\d{3}/;\n    $count += 1\
    \ if $n =~ /\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\\
    d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count\
    \ += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1\
    \ if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count\
    \ += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n\
    \    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n\
    \    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count +=\
    \ 1 if $n =~ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\\
    d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~\
    \ /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\\
    d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ /\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\/\\d{2}\\\
    /\\d{2}\\/\\d{2}\\/\\d{3}/;\n    $count += 1 if $n =~ ", "    my($result) = 0;\n\
    \    my($digit) = 0;\n    my($num_times_7) = 0;", "    my $s = \"\";\n    my $count\
    \ = $n;\n    while ($count != 0) {\n        my $remainder = $count % 11;\n   \
    \     if ($remainder == 0) {\n            my $digit = \"7\";\n            next\
    \ if $s == \"\";\n            $s .= \" $digit\";\n            $count -= $remainder;\n\
    \        }\n        my $digit = \"$remainder\";\n        $s .= \" $digit\";\n\
    \        $count -= $remainder;\n    }\n    return $s;\n}", '    my $count = 0;',
  "    my($result) = 0;\n    \n    while ($n > 0) {\n        my $tmp = $n % 11;\n\
    \        $result++;\n        $n /= 11;", "    my $counter = 0;\n    my $remainder\
    \ = 0;", "    my(@numbers);\n    for(my $n = 0; $n <= $n; $n++){\n        if($n\
    \ % 11 == 0 || $n % 13 == 0){\n            push @numbers, $n;\n        }\n   \
    \ }\n    return scalar(@numbers);\n}", "    return 1 if ($n == 0);\n    return\
    \ 1 if ($n % 11 == 0);\n    return 1 if ($n % 13 == 0);\n    return 0 if ($n %\
    \ 15 == 0);\n    return 1 if ($n % 17 == 0);\n    return 1 if ($n % 19 == 0);\n\
    \    return 1 if ($n % 23 == 0);\n    return 1 if ($n % 29 == 0);\n    return\
    \ 1 if ($n % 31 == 0);\n    return 1 if ($n % 37 == 0);\n    return 1 if ($n %\
    \ 41 == 0);\n    return 1 if ($n % 43 == 0);\n    return 1 if ($n % 47 == 0);\n\
    \    return 1 if ($n % 53 == 0);\n    return 1 if ($n % 59 == 0);\n    return\
    \ 1 if ($n % 61 == 0);\n    return 1 if ($n % 67 == 0);\n    return 1 if ($n %\
    \ 71 == 0);\n    return 1 if ($n % 73 == 0);\n    return 1 if ($n % 79 == 0);\n\
    \    return 1 if ($n % 83 == 0);\n    return 1 if ($n % 89 == 0);\n    return\
    \ 1 if ($n % 97 == 0);\n    return 0;\n}", "    my($i) = 0;\n    while ($n >=\
    \ 1000) {\n        $i ++;\n        $n = $n % 1000;\n    }\n    while($n > 1000)\
    \ {\n        $n = $n % 1000;\n        $i ++;\n    }\n    return $i;\n}", "   \
    \ my($digit) = @_;\n    $n =~ tr/7/7/;\n    $n =~ tr/13/13/;\n    $n =~ tr/11/11/;\n\
    \    return $n if $n % 11 == 0 || $n % 13 == 0;\n    $n =~ tr/7/7/;\n    $n =~\
    \ tr/13/13/;\n    $n =~ tr/11/11/;\n    return $n if $n % 11 == 0 || $n % 13 ==\
    \ 0;\n    $n =~ tr/7/7/;\n    $n =~ tr/13/13/;\n    $n =~ tr/11/11/;\n    return\
    \ $n if $n % 11 == 0 || $n % 13 == 0;\n    $n =~ tr/7/7/;\n    $n =~ tr/13/13/;\n\
    \    $n =~ tr/11/11/;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    $n\
    \ =~ tr/7/7/;\n    $n =~ tr/13/13/;\n    $n =~ tr/11/11/;\n    return $n if $n\
    \ % 11 == 0 || $n % 13 == 0;\n    $n =~ tr/7/7/;\n    $n =~ tr/13/13/;\n    $n\
    \ =~ tr/11/11/;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    $n =~ tr/7/7/;\n\
    \    $n =~ tr/13/13/;\n    $n =~ tr/11/11/;\n    return $n if $n % 11 == 0 ||\
    \ $n % 13 == 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n\
    \ if $n % 11 == 0 || $n % 13 == 0;\n    return $n if $n % 11 == 0 || $n % 13 ==\
    \ 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n if $n % 11\
    \ == 0 || $n % 13 == 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return\
    \ $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n if $n % 11 == 0 || $n % 13\
    \ == 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n if $n %\
    \ 11 == 0 || $n % 13 == 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n \
    \   return $n if $n % 11 == 0 || $n % 13 == 0;\n    return $n if $n % 11 == 0\
    \ || ", "    return $n if $n % 11 == 0 || $n % 13 == 0;\n    return 0 if $n %\
    \ 10 == 7;\n    $n -= $n % 10;\n    if ($n % 3 == 0) {\n        return 0 if $n\
    \ % 5 == 0;\n        $n -= 3;\n    }\n    return 0 if $n % 5 == 0;\n    return\
    \ $n;\n}\n</code>\n<|/ a tags=fizzbuzz,number-theory,math,algorithm,language-agnostic\
    \ |>\n<| c |>\nYour solution is very close to mine, but I believe it has a bug.\
    \ You should add `return 0 if $n % 5 == 0;` after `return $n if $n % 11 == 0 ||\
    \ $n % 13 == 0;`. The correction should also not affect the correctness of your\
    \ solution.\n<|/ c |>\n<| c |>\nThank you. Your solution works perfectly. I didn't\
    \ realize that `return 0 if $n % 11 == 0 || $n % 13 == 0;` was wrong. Although\
    \ I've tested this solution on multiple test cases, and it works perfectly.\n\
    <|/ c |>\n<| c |>\nOops, I didn't notice you corrected it. Thanks. I actually\
    \ tested it on multiple test cases and it works perfectly.\n<|/ c |>\n<| c |>\n\
    Ok, I will make your correction to the other answer. I will give a +1 to the correct\
    \ answer, though.\n<|/ c |>\n<| a |>\nYou can find the answer to your question\
    \ in the Wikipedia article on the fizz buzz problem:", '    my @digits = ("0",
    "1", "2", "3", "4", "5", "6", "7", "8", "9");', "    my $count = 0;\n    while($n\
    \ != 0) {\n        my $remainder = $n % 11;\n        unless($remainder == 7) {\n\
    \            $count++;\n        }\n        $n /= 11;\n    }\n    return $count;\n\
    }", "    my $n_prime = $n;\n    $n_prime -= 1 unless $n_prime =~ /7/;\n    return\
    \ 2 unless $n_prime > 1;", "    my $s = 0;\n    while ($n =~ /(?<!\\d)7/) {\n\
    \        $s += 1;\n        $n =~ s/(?<!\\d)7/0/g;\n    }\n    return $s;\n}\n\
    </code>\nAnd as mentioned in comments, I used negative lookbehind (?<!...) which\
    \ means the match cannot precede the match \\d.  This saves me from having to\
    \ change my regex's every time I needed to add or remove a digit from my test\
    \ data.  But it doesn't affect the speed as lookbehind can only have fixed width.\n\
    <|/ a |>\n<| c |>\n+1 thanks! This works for small test data, but not for large\
    \ ones. For example fizz_buzz(79) should return 3, not 2. See my original question\
    \ for the details. The solution with negative lookbehind is definitely the better\
    \ one, for larger test data. But my original solution works for both small and\
    \ large test data, and I think it's easier to read and understand for most people.\n\
    <|/ c |>\n<| c |>\n: I've added a second solution that will work with large test\
    \ data... but you mentioned in your original question that negative lookbehind\
    \ is undesirable for larger test data.  In that case, I'd definitely go with a\
    \ negative lookahead as well.\n<|/ c |>\n<| c |>\n: The first solution I proposed\
    \ would return 3 as the number 79 is divisible by either 11 or 13.  I see what\
    \ you mean about larger numbers, but it seems like you have the wrong answer for\
    \ that.  As for the second solution, I think it's better to have a regex that\
    \ does the entire test instead of just a single digit and it's better to return\
    \ the count rather than the number of times.\n<|/ c |>\n<| c |>\nI see the problem.\
    \ Yes you are right, my original solution for large numbers returned 2 instead\
    \ of 3 as my fault. I didn't test your solutions yet, but I must say they look\
    \ like they would work better than mine :)\n<|/ c |>\n<| c |>\n: Thanks.  I like\
    \ your second solution as it returns the count rather than the number of times\
    \ and is easy to read.  I've added an explanation to my answer as to why negative\
    \ lookbehind doesn't work.\n<|/ c |>\n<| a dscore=4 tags=regex,perl |>\nIf your\
    \ question is really just \"What is the best way to find how many times some sequence\
    \ of digits appears in some large number of integers?\", the answer depends on\
    \ what kind of numbers you are dealing with.  \nFor example, you might want to\
    \ count the digit sequences in numbers like 56789 or 456789.  Or maybe you only\
    \ want to count the digit sequence", "    return if ($n <= 0);\n    my($i, $j,\
    \ $n);\n    my($count);", '    my(@numbers);', '    my($i) = 0;']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
