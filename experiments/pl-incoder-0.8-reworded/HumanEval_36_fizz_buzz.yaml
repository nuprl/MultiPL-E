name: HumanEval_36_fizz_buzz
language: pl
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n\
  # 2\n# >>> fizz_buzz(79)\n# 3\nsub fizz_buzz {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fizz_buzz;\n\
  \        if(eq_deeply($candidate->(50),0)) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(78),2)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(79),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(200),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4000),192))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10000),639))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100000),8026))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($count) = 0;\n    while ($n >= 11 || $n >= 13) {\n        $count++;\n\
    \        $n -= 11;\n    }\n    while ($n > 7) {\n        $count++;\n        $n\
    \ -= 7;\n    }\n    return $count;\n}", "    my $result = 0;\n    while ($n !=\
    \ 0) {\n        if ($n >= 11 && $n % 11 == 0 && $n != 11) {\n            $result\
    \ ++;\n        }\n        if ($n >= 13 && $n % 13 == 0 && $n != 13) {\n      \
    \      $result ++;\n        }\n        $n /= 10;\n    }\n    return $result;\n\
    }", "    my $i = 1;\n    my $counter = 0;", "    my $i;\n    if ($n < 100) {\n\
    \        $i = 1;\n    }\n    elsif ($n >= 100 && $n % 10 == 1) {\n        $i =\
    \ 2;\n    }\n    elsif ($n >= 100 && $n % 10 == 2) {\n        $i = 3;\n    }\n\
    \    elsif ($n >= 100 && $n % 10 == 3) {\n        $i = 4;\n    }\n    elsif ($n\
    \ >= 100 && $n % 10 == 4) {\n        $i = 5;\n    }\n    elsif ($n >= 100 && $n\
    \ % 10 == 5) {\n        $i = 6;\n    }\n    elsif ($n >= 100 && $n % 10 == 6)\
    \ {\n        $i = 7;\n    }\n    elsif ($n >= 100 && $n % 10 == 7) {\n       \
    \ $i = 8;\n    }\n    elsif ($n >= 100 && $n % 10 == 8) {\n        $i = 9;\n \
    \   }\n    elsif ($n >= 100 && $n % 10 == 9) {\n        $i = 10;\n    }\n    elsif\
    \ ($n >= 100 && $n % 10 == 0) {\n        $i = 11;\n    }\n    elsif ($n >= 100\
    \ && $n % 10 == 1) {\n        $i = 13;\n    }\n    elsif ($n >= 100 && $n % 10\
    \ == 2) {\n        $i = 14;\n    }\n    elsif ($n >= 100 && $n % 10 == 3) {\n\
    \        $i = 15;\n    }\n    elsif ($n >= 100 && $n % 10 == 4) {\n        $i\
    \ = 16;\n    }\n    elsif ($n >= 100 && $n % 10 == 5) {\n        $i = 17;\n  \
    \  }\n    elsif ($n >= 100 && $n % 10 == 6) {\n        $i = 18;\n    }\n    elsif\
    \ ($n >= 100 && $n % 10 == 7) {\n        $i = 19;\n    }\n    elsif ($n >= 100\
    \ && $n % 10 == 8) {\n        $i = 20;\n    }\n    elsif ($n >= 100 && $n % 10\
    \ == 9) {\n        $i = 21;\n    }\n    elsif ($n >= 100 && $n % 10 == 0) {\n\
    \        $i = 22;\n    }\n    elsif ($n >= 100 && $n % 10 == 1) {\n        $i\
    \ = 23;\n    }\n    elsif ($n >= 100 && $n % 10 == 2) {\n        $i = 24;\n  \
    \  }\n    elsif ($n >= 100 && $n % 10 == 3) {\n        $i = 25;\n    }\n    elsif\
    \ ($n >= ", "    my(@fizzbuzz);\n    for(my $i = 1; $i <= $n; $i++) {\n      \
    \  if($i%11==0 && $i%13==0) {\n            push(@fizzbuzz, \"FizzBuzz\");\n  \
    \      }\n        elsif($i%11==0) {\n            push(@fizzbuzz, \"Fizz\");\n\
    \        }\n        elsif($i%13==0) {\n            push(@fizzbuzz, \"Buzz\");\n\
    \        }\n        else {\n            push(@fizzbuzz, $i);\n        }\n    }\n\
    \    return scalar(@fizzbuzz);\n}\n</code>\nNow the whole thing works and can\
    \ be called from the command line. Note that the output is different from the\
    \ Python output. Python outputs FizzBuzz for numbers divisible by both 11 and\
    \ 13. My program outputs only FizzBuzz for numbers divisible by 11, and Fizz for\
    \ numbers divisible by 13. The reason is simple: when $i is divisible by 11, $i\
    \ % 13 will be 0, and thus only the first two conditions are executed. In fact,\
    \ both conditions are identical since $i % 11 will be 0 when the number is not\
    \ divisible by 11, and 1 when the number is divisible by 11.\n<|/ a tags=python\
    \ |>\n<| c |>\nthank you so much, but can you explain to me the part where you\
    \ say `The reason is simple: when $i is divisible by 11, $i % 13 will be 0, and\
    \ thus only the first two conditions are executed.` ?\n<|/ c |>\n<| c |>\nSee\
    \ my edit to the answer. Also, `@fizzbuzz` can just be a single `fizzbuzz` string.\n\
    <|/ c |>\n<| c |>\nThanks. And how would you do the same thing but for non-prime\
    \ numbers ?\n<|/ c |>\n<| c |>\n`@numbers` in the first part can be a list of\
    \ non-prime numbers. If you want a solution for non-prime numbers, please ask\
    \ a new question.\n<|/ c |>\n<| c |>\nOk, so I have tried doing something like\
    \ this: ```sub fizzbuzz {\n my($n) = @_;\n my(@numbers);\n for(my $i = 1; $i <=\
    \ $n; $i++) {\n  if($i%11==0 && $i%13==0) {\n   push(@numbers, \"FizzBuzz\");\n\
    \  }\n  elsif($i%11==0) {\n   push(@numbers, \"Fizz\");\n  }\n  elsif", "    $n\
    \ += 0 if ($n =~ /^0$/);\n    return ($n % 11 == 0) ? 0 : (($n % 13) == 0) ? 1\
    \ : 2;\n}", "    my $count = 0;\n    my $last = $n;\n    while (1) {\n       \
    \ if ($n >= $last) {\n            $count += int(($n % $last) / 11);\n        \
    \    $n -= $count * 11;\n        } elsif ($n >= $last + 10) {\n            $count\
    \ += int(($n % $last + 10) / 13);\n            $n -= $count * 13;\n        } else\
    \ {\n            $count++;\n        }\n        $last = $n;\n        if ($n ==\
    \ 0) {\n            return $count;\n        }\n    }\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI guess, you are missing `elsif`. Also, what about `fizzbuzz(101)`?\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a recursive solution:\n<code>", "    return\
    \ 1 if ($n =~ /^\\d+$/ && $n =~ /^1$|11$/);\n    return 2 if ($n =~ /^\\d+$/ &&\
    \ $n =~ /^13$/);\n    return 3;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`return\
    \ 1 if ($n =~ /^\\d+$/ && $n =~ /^1$|11$/);` this is wrong, just `return 1 if\
    \ ($n =~ /^\\d+$/ && $n =~ /^1$/);` or `return 1 if ($n =~ /^\\d+$/ && $n =~ /^11$/);`\
    \ etc.\n<|/ c |>\n<| c |>\nHi thank you for the suggestion! I am just learning\
    \ Perl and still learning. I think I understand what you mean now though, thank\
    \ you!\n<|/ c |>\n<| c |>\nHi I changed this code to suit my code and it still\
    \ didn't work. I ran it through `perl -e 'fizz_buzz(78)'` and it returned `undef`.\
    \ Am I missing something? I also changed line 8 to `my($n) = @_;` from `$n` to\
    \ `@_`\n<|/ c |>\n<| c |>\nThat code works for me (it prints out the correct number\
    \ of fizz buzz). Did you run the exact code I wrote above?\n<|/ c |>\n<| c |>\n\
    Ahhhhh it works, sorry I didn't check your code before I posted my comment! Thank\
    \ you so much for your help!\n<|/ c |>\n<| a tags=perl,fizzbuzz |>\nYou only need\
    \ one line to produce the answer:\n<code>\n$ perl -E 'say for map { $_ eq 'Fizz'\
    \ ? 'FizzBuzz' : \"$Fizz$_\" } 1..100'\n1\n2\nFizz\n4\nBuzz\nFizzBuzz\n7\n8\n\
    Fizz\nBuzz\n11\nFizzBuzz\n13\n14\nFizzBuzz\n16\n17\nFizzBuzz\n19\nFizzBuzz\nBuzz\n\
    21\nFizzBuzz\n23\n24\nFizzBuzz\n26\n27\nFizzBuzz\n29\nFizzBuzz\nBuzz\n31\nFizzBuzz\n\
    33\nFizzBuzz\n35\n36\nF", "    my $counter = 0;\n    while ($n < 100) {\n    \
    \    $counter += int($n / 11);\n        $counter += int($n / 13);\n        $n--;\n\
    \    }\n    return $counter;\n}", "    if ($n =~ /^\\-?\\d+$/) {\n\tmy $count\
    \ = 0;\n\tfor (my $i = 1; $i <= $n; $i++) {\n\t    $count += ($i =~ m/^(11|13)$/i)\
    \ ? 1 : 0;\n\t}\n\treturn $count;\n    }\n    else {\n\treturn 0;\n    }\n}",
  "    my $i = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        if ($i mod 11 ==\
    \ 0 ||\n            $i mod 13 == 0) {\n            $i += 1;\n        }\n    }\n\
    \    return $i;\n}", "    my $result;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        last if ($i % 11 == 0 && $i % 13 == 0);\n        $result .= \"$i\";\n\
    \    }\n    return $result;\n}", "    my $count = 0;\n    while (@_) {\n     \
    \   my $v = shift;\n        if ($v & 7) {\n            $count++;\n        }\n\
    \        if ($v & 3) {\n            $count += 3;\n        }\n        if ($v &\
    \ 15) {\n            $count += 5;\n        }\n        if ($v & 31) {\n       \
    \     $count += 11;\n        }\n        if ($v & 61) {\n            $count +=\
    \ 13;\n        }\n    }\n    return $count;\n}\n</code>\nAnd finally the most\
    \ efficient version (but this is just an exercise, since I do not want to give\
    \ a full solution to you homework)\n<code>", "    my ($n, $n_div) = ($n, $n /\
    \ 11);\n    my ($n, $n_div) = ($n, $n / 13);\n    return 0 if $n <= 0;\n    \n\
    \    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($i % $n_div\
    \ == 0 and\n            $i % 11 == 0 and\n            $i % 13 == 0) {\n      \
    \      $count += 1;\n        }\n    }\n    return $count;\n}", "    if ($n % 11\
    \ == 0 && $n % 13 == 0) { 0 }\n    elsif ($n % 11 == 0)  { 1 }\n    elsif ($n\
    \ % 13 == 0) { 2 }\n    else                { 3 }\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nA recursive function would also work just as well as this one.\n<|/ c |>\n\
    <| c |>\nThis one is nice. But the thing is I don't want to use any if else. Is\
    \ there a way to do it without using any if else ?\n<|/ c |>\n<| c |>\nI didn't\
    \ want to use any if else because my code should run for all integers upto infinity.\n\
    <|/ c |>\n<| c |>\nThen you would need to make a recursive function. I'll post\
    \ some code for that in a sec.\n<|/ c |>\n<| a tags=perl |>\nOne other way to\
    \ do it is using regex like this:\n<code>\nmy $str = '123';", "    return $n if\
    \ $n =~ m/^\\d+$/;\n    return 0 if $n <= 4;\n    return 0 if $n % 11 == 0;\n\
    \    return 0 if $n % 13 == 0;\n    return $n;\n}", "    # FizzBuzz only needs\
    \ to find fizz and buzz, so we use a different variable for each case\n    my($fizz)\
    \ = (($n % 3) ==0) and 'Fizz' or '';\n    my($buzz) = (($n % 5) ==0) and 'Buzz'\
    \ or '';\n    $fizz . $buzz;\n}", "    my $count = 0;\n    while ($n =~ /(.)(7)(.)/o)\
    \ {\n\tmy $c = $2;\n\t$c eq '7' and $count++ or $count += $n =~ /(.)(9)(.)/o ?\
    \ 1 : $n =~ /(.)(3|5|7)(.)/o ? 2 : 3;\n    }\n    return $count;\n}", "    if\
    \ ($n <= 0) { return(0); }\n    if ($n <= 100) { return(0); }\n    return 2 if\
    \ ($n <= 25);\n    return 3 if ($n <= 50);\n    return 5 if ($n <= 100);\n   \
    \ return 7 if ($n <= 200);\n    return 9 if ($n <= 300);\n    return 11 if ($n\
    \ <= 400);\n    return 13 if ($n <= 500);\n    return 17 if ($n <= 700);\n   \
    \ return 19 if ($n <= 800);\n    return 21 if ($n <= 900);\n    return 23 if ($n\
    \ <= 1000);\n    return 37 if ($n <= 1100);\n    return 41 if ($n <= 1200);\n\
    \    return 53 if ($n <= 1300);\n    return 59 if ($n <= 1400);\n    return 69\
    \ if ($n <= 1500);\n    return 79 if ($n <= 1600);\n    return 89 if ($n <= 1700);\n\
    \    return 101 if ($n <= 1800);\n    return 123 if ($n <= 1900);\n    return\
    \ 147 if ($n <= 2000);\n    return 169 if ($n <= 2100);\n    return 191 if ($n\
    \ <= 2200);\n    return 223 if ($n <= 2300);\n    return 239 if ($n <= 2400);\n\
    \    return 251 if ($n <= 2500);\n    return 273 if ($n <= 2600);\n    return\
    \ 297 if ($n <= 2700);\n    return 311 if ($n <= 2800);\n    return 333 if ($n\
    \ <= 2900);\n    return 363 if ($n <= 3000);\n    return 389 if ($n <= 3100);\n\
    \    return 411 if ($n <= 3200);\n    return 439 if ($n <= 3300);\n    return\
    \ 461 if ($n <= 3400);\n    return 493 if ($n <= 3500);\n    return 523 if ($n\
    \ <= 3600);\n    return 553 if ($n <= 3700);\n    return 583 if ($n <= 3800);\n\
    \    return 603 if ($n <= 3900);\n    return 631 if ($n <= 4000);\n    return\
    \ 661 if ($n <= 4100);\n    return 693 if ($n <= 4200);\n    return 723 if ($n\
    \ <= 4300);\n    return 753 if ($n <= 4400);\n    return 783 if ($n <= 4500);\n\
    \    return 813 if ($n <= 4600);\n    return 841 if ($n <= 4700);\n    return\
    \ 873 if ($n <= ", "    my($fizz, $buzz);\n    my($i);\n    $fizz = 11 if $n %\
    \ 11;\n    $buzz = 13 if $n % 13;\n    $i = $n - $fizz - $buzz;\n    return $i;\n\
    }", "    my $counter = 0;\n    for($n; $n >= 1; $n -= 10) {\n        for($n; $n\
    \ >= 10; $n /= 10) {\n            ++$counter;\n        }\n    }\n    return $counter;\n\
    }", "    my $cnt = 0;\n    \n    while (1) {\n        next unless $n =~ m/\\A\\\
    d+/;\n        if ($n =~ m/7\\z/ or $n =~ m/11\\z/ or $n =~ m/13\\z/) {\n     \
    \       $cnt++;\n        }\n        $n++;\n    }\n    return $cnt;\n}", "    return\
    \ 0 unless $n % 11;\n    return 1 unless $n % 13;\n    return 2 unless $n % 17;\n\
    \    return 3 unless $n % 19;\n    return 4 unless $n % 23;\n    return 5 unless\
    \ $n % 29;\n    return 6 unless $n % 37;\n    return 7 unless $n % 45;\n    return\
    \ 8 unless $n % 53;\n    return 9 unless $n % 59;\n    return 10 unless $n % 67;\n\
    \    return 11 unless $n % 75;\n    return 12 unless $n % 83;\n}\n</code>\n<|/\
    \ a tags=math,algorithm,python,performance |>\n<| c |>\nHow would you optimize\
    \ this to return a single number in O(1)?\n<|/ c |>\n<| c |>\n: I don't know enough\
    \ about Python, but I'm guessing that you can simply do `return sum(1 if (n%11==0\
    \ and n%13==0) or (n%17==0 and n%19==0) or (n%23==0 and n%29==0) or (n%37==0 and\
    \ n%45==0) or (n%53==0 and n%59==0) or (n%67==0 and n%75==0) or (n%83==0 and n%99==0)\
    \ else 0 for n in xrange(100))`.\n<|/ c |>\n<| c |>\n: If you need only the first\
    \ number, why not just `return n%11`? Or am I missing something?\n<|/ c |>\n<|\
    \ c |>\n: I'm pretty sure this is O(n), as each of the `if` statements has a constant\
    \ number of operations per iteration. Also, if `n == 100`, then `(n%11==0 and\
    \ n%13==0)` is always true, so there is no need to check for that.\n<|/ c |>\n\
    <| c |>\n: Oh, I see, `11`... Yes, you're right, that's what `n % 11` does, so\
    \ I guess that should indeed be `n % 11 == 0`.\n<|/ c |>\n<| a |>\nHow about a\
    \ recursive one? Just count the number while dividing it by 11 or 13 and stop\
    \ at 1.\n<code>\ndef f(s):\n  if s <= 0: return s\n  if s % 11 == 0 and s % 13\
    \ == 0:\n    return f(s/13)+1\n  return f(s/11)+1", "    my($n) = ($_[0] < 10)\
    \ ? ($n < 11 ? $n : 7) : ($_[0] < 13 ? $n : 11);\n    if ($n % 11 == 0 || $n %\
    \ 13 == 0) {\n        return $n;\n    } else {\n        return 0;\n    }\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nI like the idea of returning a number from\
    \ fizzbuzz when it exists, but it would be nice to see an example in the code.\
    \  For what it's worth, this has also been my goto answer for a while now.\n<|/\
    \ c |>\n<| c |>\n+1 for giving an example of how the program can be made shorter\
    \ and more readable :)\n<|/ c |>\n<| c |>\nIt seems your function does not work\
    \ for negative numbers.\n<|/ c |>\n<| c |>\nGood point - I didn't think about\
    \ negative numbers when I wrote the original answer.  I've corrected the code.\
    \  Thanks.\n<|/ c |>\n<| a |>\nI did this once in Python which I called 'roulette'\
    \ (roulette wheel) but it's kind of funny as I couldn't remember what it was called\
    \ in English.\nThe idea is that you keep a running total of the values you have,\
    \ then you just check what value has appeared last.\nThis works out best if you\
    \ know how often each number will appear. Say you have only 10 possibilities for\
    \ each, then you would use something like:\n<code>\ndef roulette_wheel(n):\n \
    \   wheel = [0,0,0,0,0,1,0,1,0,0,0]\n    total = 0\n    for i in range(0,n):\n\
    \        total += wheel[i]\n        wheel[i] += 1\n        if total > 2:\n   \
    \         total -= 1\n            return i\n    return 0\n</code>\nThis would\
    \ give you the 'roulette' number which you could then use to map to a number in\
    \ a range, or just use an if statement to see if it was even or odd...\n<|/ a\
    \ tags=algorithm,fizzbuzz dscore=4 |>\n<| c |>\nAh yes this works well, but you\
    \ have to keep track of the value that appeared last, otherwise it will not work\
    \ correctly for negative numbers\n<|/ c |>\n<| c |>\nNice algorithm, but this\
    \ won't work for non-positive numbers (and I'm actually not 100% sure that it\
    \ works correctly for non-positive numbers)\n<|/ c |>\n<| a dscore=3 |>\nHere's\
    \ another possible approach, that might be a little easier to understand than\
    \ a bunch of if statements:\n<code>\ndef fizzbu", "    my $counter = 0;\n    while($n\
    \ < 1000){\n        if($n % 11 == 0){\n            $counter += 1;\n        }\n\
    \        if($n % 13 == 0){\n            $counter += 1;\n        }\n        $n\
    \ /= 11;\n        $n /= 13;\n    }\n    return $counter;\n}", "    $n += 1;\n\
    \    my $i = 0;\n    while ($n % 11 == 0 || $n % 13 == 0) {\n        $i++;\n \
    \       $n = $n/11;\n    }\n    return $i;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=1 |>\nA different approach might be to take advantage of the fact that\
    \ the digits are evenly spaced throughout the number. Instead of printing them\
    \ in order, simply keep track of the first digit that appears, then iterate through\
    \ until you reach the end and print the number:\n<code>", "    if ($n =~ /7/)\
    \ {\n        if ($n =~ /11/) {\n            return 0;\n        }\n        elsif\
    \ ($n =~ /13/) {\n            return 2;\n        }\n    }\n    return 1;\n}\n\
    </code>\nNow for something even more efficient, you can build a hash from fizz_buzz_digit()\
    \ to $n (modulo 11 and 13) and then just look that up in the hash instead of calling\
    \ fizz_buzz().\n<code>", "    if ($n =~ /^\\d+$/ && $n % 11 <= 5 && $n % 13 <=\
    \ 4) {\n        return 0;\n    }\n    if ($n =~ /^\\d+$/ && $n % 11 > 5 && $n\
    \ % 13 > 4) {\n        return 1;\n    }\n    \n    return 2;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nThe question is kind of vague, but perhaps the following\
    \ is helpful.\nThe basic idea is to create a list that contains all the integers\
    \ in the range (1-999) that are divisible by either 11 or 13.\n<code>\nmy $range_limit\
    \ = 1000;", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n     \
    \   my $div = $i / 11;\n        my $mod1 = $i % 11;\n        my $mod2 = $i % 13;\n\
    \        my $mod3 = $i % 17;\n        if ($div == 0 || $mod3 > 0 || ($mod1 < 5\
    \ && $mod2 == 0) || $mod3 > 0) {\n            $count++;\n        }\n    }\n  \
    \  return $count;\n}\n</code>\n<|/ a |>\n<| a tags=fizzbuzz,perl |>\n<code>",
  '    return 2 if ($n <= 11);', "    \n    return 0 \n\tif $n <= 0;\n    \n    my($i,\
    \ $j, $n, @a);\n    \n    for ($i = 0; $i <= $#$n; $i++) {\n        push(@a, $n->[$i]);\n\
    \    }\n    \n    for (@a) {\n        for (my $i = 0; $i <= $#$a; $i++) {\n  \
    \          my($d, $t) = @{$a->[$i]}[0,1];\n            if ($d == 7 && $t != 0)\
    \ {\n                $a->[$i][1]++;\n                next;\n            }\n  \
    \      }\n    }\n    \n    $a[0][1] = 1 if @a == 1;\n    \n    return @a;\n}",
  "    my($count) = 0;\n    for (1..$n) {\n        if ($_ % 11 == 0 || $_ % 13 ==\
    \ 0) {\n            $count++;\n        }\n    }\n    return $count;\n}\n</code>\n\
    <|/ a tags=fizzbuzz,perl |>\n<| a |>\n<code>\nuse List::MoreUtils 'uniq';", " \
    \   my $count = 0;\n    for (1..$n) {\n        if ($n % 11 == 0 && $n % 13 ==\
    \ 0) {\n            $count++;\n        }\n    }\n    return $count;\n}", '    my($result)
    = 0;', "    if ($n =~ /^\\d+$/) {\n        return 0 unless $n % 11 == 0 or $n\
    \ % 13 == 0;\n        return 1 unless $n % 11 == 0;\n        return 2 unless $n\
    \ % 13 == 0;\n        return 3 unless $n % 11 == 0;\n        return 4 unless $n\
    \ % 13 == 0;\n        return 5 unless $n % 11 == 0;\n        return 6 unless $n\
    \ % 13 == 0;\n        return 7 unless $n % 11 == 0;\n        return 8 unless $n\
    \ % 13 == 0;\n        return 9 unless $n % 11 == 0;\n        return 10 unless\
    \ $n % 13 == 0;\n        return 11;\n    }\n    return -1;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=perl,fizzbuzz |>\n<code>", "    my(@a) = map { ($_ *\
    \ 3) + ($_ & 1) } 1 .. $n;\n    my $count = 0;\n    foreach my $i (@a) {\n   \
    \     my $j = index($i, \"7\");\n        if ($j >= 0) {\n            $count++;\n\
    \            splice(@a, $j + 1, 0, \"\");\n        }\n    }\n    return $count;\n\
    }", "    $n % 11 == 0 || $n % 13 == 0 ? ($n % 12 == 0 ? 2 : 1) : 3;\n}", "   \
    \ my(@numbers) = split(/,/, $n);\n    my(@divisors) = split(/,/, $divisors);\n\
    \    my($counter) = 0;\n    foreach my $number (@numbers) {\n        $counter\
    \ += grep { $_ % $divisors[$_] } @divisors;\n    }\n    return $counter;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nIt's a nice solution, but I was actually\
    \ interested to see how it would perform compared with other solutions.\n<|/ c\
    \ |>\n<| a tags=fizzbuzz,algorithm,optimization,perl |>\nI like Marc's answer.\
    \ Here's my solution, with some minor changes to keep it running.\n<code>\nmy\
    \ $n = 5;\nmy $divisors = join \",\", map{$_*3} 1 .. $n+1;", "    my($result);\n\
    \    my($first);\n    \n    $n = $n + 1;\n    $first =\n    (\n        ($n =~\
    \ m/^1|^3|^5|^7|^9$|^11$|^13$/) ? $n : $n * 11 + 13\n    );\n    \n    $result\
    \ = $first % 11;\n    $result = $result + ($first % 13);\n    \n    return $result;\n\
    }", "    my $count = 0;\n    for ($n; $n >= 100; $n /= 10) {\n        $count +=\
    \ $n / 11;\n        $count += $n / 13;\n    }\n    return $count;\n}", "    my\
    \ $count = 0;\n    if ($n >= 0) {\n        if ($n % 11 == 0 && $n % 13 == 0) {\n\
    \            $count++;\n        }\n        if ($n % 11 == 0 && $n % 13 != 0) {\n\
    \            $count++;\n        }\n        if ($n % 11 != 0 && $n % 13 == 0) {\n\
    \            $count++;\n        }\n        if ($n % 11 != 0 && $n % 13 != 0) {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}", "    my($fb_count)\
    \ = 0;\n    for(my $i=0; $i <= $n; $i++) {\n        my($remainder) = ((($i) %\
    \ 11) ? (($i) % 13) : 0);\n        my($is_divisor = (($i) % 11) == ((($i) % 13));\n\
    \        if($remainder == 7) {\n            ($is_divisor) ? $fb_count++ : print(\"\
    $i\");\n        }\n    }\n    $fb_count;\n}", "    my $count = 0;\n    for(my\
    \ $i = 1; $i < $n; $i++){\n        if($i % 11 == 0 || $i % 13 == 0){\n       \
    \     $count++;\n        }\n    }\n    return $count;\n}", '    return 0 if $n
    % 11 eq 0 || $n % 13 eq 0;', "    my(@r) = ($n =~ m/7/g);\n    my($i);\n    my(@cash);\n\
    \    my(@counter);", "    $n -= 13;\n    $n = $n / 11;\n    if ($n % 11 == 0)\
    \ return $n;\n    $n -= ($n % 11);\n    return $n / 11;\n}", "    \n    return\
    \ 0 unless $n =~ /^\\d+$/;", "    return 0 unless $n > 0;\n    return 0 unless\
    \ $n =~ /[13579]$/;", "    return 0 unless $n =~ /^\\d+$/;\n    if ($n % 11 ==\
    \ 0 ||\n\t$n % 13 == 0) { \n\tmy $n = ($n % 11 == 0) ? $n / 11 : $n / 13;\n\t\
    return $n + ($n % 7 == 0);\n    }\n    return 0;\n}", '    my $sum = 0;', "  \
    \  return 0 if ($n <= 0);\n    my($num, $num1, $num2);\n    my(@digits);", " \
    \   $n = $n if $n =~ /^[13579]$/;\n    my $count = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++) {\n        if ($i % 11 == 0 or\n            ($i % 13 == 0 and $i\
    \ != 0)\n        ) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $digit = -1;\n    $n += 0;  # make sure $n is positive\n    while\
    \ ($n % 10 != 0) {\n        $digit += 1;\n        $n = int($n / 10);\n    }\n\
    \    if ($digit < 7 && $digit % 11 == 0 && $digit % 13 == 0) {\n        return\
    \ $digit;\n    }\n    return -1;\n}", "    my(@x) = (1..10);\n    my(@y) = (11..13);\n\
    \    my(@z) = (13..19);\n    my(@t) = (19..);\n    my(@z) = ($n % 1000 eq 0 ?\
    \ @z : @t);\n    my($k) = ($n % 11 eq 0 ? @y : @z);\n    my($v) = ($n % 13 eq\
    \ 0 ? @x : @z);\n    my($u) = ($n % 19 eq 0 ? @x : @z);\n    my($w) = ($n % 7\
    \ eq 0 ? @y : @z);\n    my($z) = ($n -7 +$k + $v + $u + $w + $n);\n    if ($z\
    \ <= $n) {\n        foreach my $i (@z) {\n            if ($i == 7 && $z == $n)\
    \ {\n                return 0;\n            }\n            if ($i == 7 && $z %\
    \ 11 == $n) {\n                return 1;\n            }\n        }\n        return\
    \ $z;\n    }\n    return;\n}\n</code>\n<|/ a tags=algorithm,fizzbuzz,perl dscore=1\
    \ |>\n<| a tags=algorithm,fizzbuzz,perl |>\n<code>", "    if ($n % 11 == 0 ||\
    \ $n % 13 == 0) {\n        return 0;\n    }\n    elsif ($n =~ m/7$/) {\n     \
    \   return 1;\n    }\n    elsif ($n =~ m/8$/) {\n        return 2;\n    }\n  \
    \  elsif ($n =~ m/9$/) {\n        return 3;\n    }\n    elsif ($n =~ m/10$/) {\n\
    \        return 4;\n    }\n    elsif ($n =~ m/11$/) {\n        return 5;\n   \
    \ }\n    elsif ($n =~ m/12$/) {\n        return 6;\n    }\n    elsif ($n =~ m/13$/)\
    \ {\n        return 7;\n    }\n}", '    return $n if $n =~ /^[13579]$/;', "  \
    \  my(@n) = split(//,$n);\n    return scalar(grep { ($_ % 11) == 0 && ($_ % 13)\
    \ == 0 } @n);\n}", '    my $count = 0;', "    my $digits = $n % 11;\n    $digits\
    \ += $n % 13;", "    return 0 unless defined $n;\n    $n =~ /\\b7\\b/i; # Match\
    \ 7 at the beginning of $n.\n    return $n if $n =~ /^[0-9]{1,2}/; # Match numbers\
    \ divisible by 11 or 13.\n    $n = $n - 4; # $n must be divisible by 11.\n   \
    \ return 0 if $n % 11 == 7;\n    $n = $n - 9; # $n must be divisible by 13.\n\
    \    return 0 if $n % 13 == 7;\n    $n;\n}", "    my $n1 = $n % 11;\n    $n1 -=\
    \ 3 if $n1 == 0;\n    return $n1;\n}", "    return 0 if $n <= 11;\n    return\
    \ 1 if $n % 11 == 7;\n    return 2;\n}\n</code>\nI haven't tested this code, but\
    \ I believe it should work. It uses return statements instead of prints and doesn't\
    \ use any print or printf.\n<|/ a tags=function,perl,return,for-loop |>\n<| a\
    \ tags=function,perl,return,for-loop |>\n<code>", "    if ( $n < $fizz_buzz_range\
    \ ) {\n        return 0;\n    }\n    my($counter) = 0;", '    my($cnt);', "  \
    \  my $i = 0;\n    while($i <  $n) {\n        if( $i / 11 == 0 || $i / 13 == 0)\
    \ {\n            if( $i % 11 == 0 || $i % 13 == 0) {\n                print \"\
    $i\\n\";\n            }\n            else {\n                print \"FizzBuzz\\\
    n\";\n            }\n        }\n        else {\n            if( $i % 11 == 0 )\
    \ {\n                print \"FizzBuzz\\n\";\n            }\n            else {\n\
    \                print \"$i\\n\";\n            }\n        }\n        $i++;\n \
    \   }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks Icarus, I appreciate the help. I\
    \ figured out the fizz_buzz algorithm, but am now having problems printing fizz\
    \ and buzz in addition to normal numbers 1-100. Would you mind taking a look at\
    \ my code and helping me figure out where I'm going wrong? Thanks again! :)\n\
    <|/ c |>\n<| c |>\n: You're welcome! I edited my answer to show you the fizz_buzz\
    \ algorithm.\n<|/ c |>\n<| a |>\n<code>", "    return 1 if $n <= 0;\n    return\
    \ 1 if $n <= 10;\n    return 1 if $n % 11 == 0;\n    return 1 if $n % 13 == 0;\n\
    \    return 1;\n}\n</code>\nHere's a test harness. I like these tests. All tests\
    \ are run to make sure that my code always works. I test these tests with a different\
    \ test harness so that I can test it at any time.\n<code>\nuse strict;\nuse warnings;\n\
    use Test::More;", '    my($num, $count);', '    my $count = 0;', "    return 0\
    \ unless $n;\n    my $remainder = $n % 11;\n    return $remainder < 13 ? 0 + 1\
    \ : $remainder;\n}", "    my(@result) = ();\n    if ($n % 11 == 0 && $n % 13 ==\
    \ 0) {\n        push(@result,0);\n    } elsif ($n % 11 == 0 || $n % 13 == 0) {\n\
    \        push(@result,1);\n    }\n    push(@result, $n % 11);\n    while (my ($k,\
    \ $v) = each %$_) {\n        if ($k % 11 == 0 || $k % 13 == 0) {\n           \
    \ push(@result, $k % 11);\n        }\n    }\n    my @answer = sort { $a <=> $b\
    \ } @result;\n    return scalar @answer;\n}\n</code>\n<|/ a dscore=0 tags=numbers,perl,fizzbuzz,algorithm\
    \ |>\n<| c |>\nThis doesn't produce the correct result. `fizz_buzz(10)` should\
    \ return `1`, but it returns `3`.\n<|/ c |>\n<| c |>\nI realize that now. Thanks.\n\
    <|/ c |>\n<| a |>\nThis question has been answered several times on SO, but I\
    \ didn't see one with a working code. So here is mine using recursion.\n<code>",
  "    my($count) = 0;\n    while(--$n) {\n        my $n = $_ % 11;\n        $count++\
    \ if $n == 7;\n        $_ = $n + ($_ / 11) * 13;\n    }\n    return $count;\n}",
  "    my @b = ();\n    push @b, $n =~ /\\b\\d+\\b/ ? 1 : $n =~ /\\b7\\b/\n      \
    \              ? ($n =~ /\\b11\\b/) ? 1 : 2\n                    : $n =~ /\\b13\\\
    b/\n                    ? ($n =~ /\\b11\\b/) ? 0 : 3\n                    : 0;\n\
    \    return @b;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code is a bit too long-winded\
    \ - I would suggest not using it at all and just using `if ($n =~ /\\b7\\b/)`\n\
    <|/ c |>\n<| a dscore=1 tags=regex,perl |>\nHere is my own solution to fizz buzz:\n\
    <code>", "    my $count = 0;\n    while ($n >= 10) {\n        $n -= 10;\n    \
    \    $count++;\n    }\n    if ($n >= 13) {\n        $n -= 13;\n        $count++;\n\
    \    }\n    return $count;\n}", "    return unless $n;\n    return 0 unless $n\
    \ % 11 == 0 || $n % 13 == 0;\n    return $n % 11 == 0 ? 0 : 11 + $n % 13 == 0\
    \ ? 0 : 13 + $n % 11 == 0 ? 1 : $n % 11 == 1 ? 2 : $n % 13 == 1 ? 3 : 0;\n}",
  "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n\tif ($i & 7) {\n\t\
    \    $count += 1;\n\t}\n\telsif ($i % 11 == 0 or $i % 13 == 0) {\n\t    $count\
    \ += 1;\n\t}\n    }\n    return $count;\n}", "    my $count = do {\n\tmy $num\
    \ = shift;\n\tmy $div = 11;\n\tmy $mod  = 13;", "    my($c) = 0;\n    while($n\
    \ > $c) {\n        my $i = $n % 11;\n        $c++ if $i;\n        $n = $n / 11;\n\
    \    }\n    return $c;\n}", "    my $n1 = $n;\n    my $z = 0;\n    for (;;) {\n\
    \        if ($n1 & 1 != 0) { $z += 1; }\n        if ($n1 & 2 != 0) { $z += 2;\
    \ }\n        if ($n1 & 4 != 0) { $z += 4; }\n        if ($n1 & 8 != 0) { $z +=\
    \ 8; }\n        if ($n1 & 16 != 0) { $z += 16; }\n        if ($n1 & 32 != 0) {\
    \ $z += 32; }\n        if ($n1 & 64 != 0) { $z += 64; }\n        if ($n1 & 128\
    \ != 0) { $z += 128; }\n        if ($n1 & 256 != 0) { $z += 256; }\n        $n1\
    \ >>= 1;\n        $n1 += $n;\n        return $z;\n    }\n}", "    my ($n, $divisor,\
    \ $div1, $div2) = ($n, 11, 13, 7);\n    my $ret = 0;\n    for (; $n >= $divisor;\
    \ $n--) {\n        if ($n % $div1 == $div1) {\n            $ret += 1;\n      \
    \  }\n        if ($n % $div2 == $div2) {\n            $ret += 1;\n        }\n\
    \    }\n    return $ret;\n}", "    return 0 if $n == 0;\n    return 0 if $n %\
    \ 11 == 0 && $n % 13 == 0;\n    return $n if $n <= 9;\n    return $n if ($n %\
    \ 7 == 0);\n    return $n / 11 if $n >= 50 && $n % 11 == 0;\n    return $n / 13\
    \ if $n >= 50 && $n % 13 == 0;\n    return $n / 7 if $n >= 50;\n    return 1;\n\
    }", "    if ($n =~ /\\b(11|13)\\b.*7\\b\\b.*/) {\n        return 2;\n    } elsif\
    \ ($n =~ /\\b(11|13)\\b\\b.*/) {\n        return 1;\n    } elsif ($n =~ /\\b7\\\
    b\\b.*/) {\n        return 0;\n    }\n    return 0;\n}", "    # Fizz buzz does\
    \ not count for multiples of 3.\n    my $fizzbuzz = 1 if $n % 3 == 0;\n    return\
    \ 0 if $n % 11 == $n || $n % 13 == $n;\n    return $fizzbuzz if $n % 7 == 0;\n\
    \    return;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "    return 0 if\
    \ $n <= 0;\n    return 0 if $n % 11 == 0 || $n % 13 == 0;\n    return 0 if $n\
    \ % 7 == 0;\n    return 1;\n}\n</code>\n<|/ a |>\n<| c |>\nThe function name `fizz_buzz`\
    \ is misleading, as it's not a \"fizz buzz\" fix, but simply a fizz buzz function.\n\
    <|/ c |>\n<| a tags=fizzbuzz,perl,string dscore=5 |>\nThis was my solution using\
    \ Perl's regular expressions. I wrote it for fun, so in order to explain it I\
    \ used a few comments.\n<code>", '    my $count = 0;', "    my $i = $n % 10;\n\
    \    return $i if $i < 3 && $i % 11 == 0;\n    return $i if $i < 3 && $i % 13\
    \ == 0;\n    return $i if $i < 5;\n    return $i if $i < 7;\n    return $i;\n}",
  "    my $count = 0;\n    while ($n =~ m/7/g) {\n        $count++;\n        $n =~\
    \ s/7//g;\n    }\n    return $count;\n}", '    my($j);', "    if($n < 10) {\n\
    \        return $n;\n    } elsif($n % 11 == 0 || ($n % 13 == 0)) {\n        return\
    \ $n // 10 + 1;\n    }\n    return $n // 10 + 1;\n}", "    my($i);\n    $n -=\
    \ 3;\n    $i .= 0;\n    while ($n > 0) {\n        if ($n % 11 == 0 && $n % 13\
    \ == 0) { $i += 3; $n -= 13; }\n        elsif ($n % 11 == 0) { $i += 3; $n -=\
    \ 11; }\n        elsif ($n % 13 == 0) { $i += 2; $n -= 13; }\n        else { \
    \ $i++; $n -= ($n % 11); };\n    };\n    return $i;\n}", "    my($count = 0);\n\
    \    for (my $i = 1; $i < $n; $i += 11) {\n        $count++ if ($i // 11 % 11\
    \ == 7);\n    }\n    for (my $i = 1; $i < $n; $i += 13) {\n        $count++ if\
    \ ($i // 13 % 13 == 7);\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=algorithm,math,fizzbuzz,perl,division dscore=0 |>\n<code>", '    return
    0 if($n eq 0);', "    my $count = 0;\n    if ($n % 11 == 0 || $n % 13 == 0) {\n\
    \        $count = $n + 1;\n    }\n    else {\n        for my $divisor (1..1000)\
    \ {\n            next if $n % $divisor == 0;\n            next unless $n % $divisor\
    \ == 0;\n            $count++;\n        }\n    }\n    return $count;\n}", "  \
    \  my($fizzbuzz_count, $fizzbuzz_sum);\n    my($fizzbuzz_sum);", '    my($result);',
  "    my $i;\n    my $cnt = 0;\n    for ($i = $n; $i > 0; $i /= 10) {\n        if\
    \ ($i && $i % 11 == 0 && $i % 13 == 0) {\n            $cnt++;\n        }\n   \
    \ }\n    return $cnt;\n}\n</code>\nAnd if you really want the code to be more\
    \ efficient and more readable, you can use a ternary operator instead of the if\
    \ statement and have it return $cnt if $i and $i % 11 == 0 and $i % 13 == 0 are\
    \ both true, otherwise $cnt will just be $i.\n<|/ a tags=perl,division,algorithm,fizzbuzz,modulo\
    \ |>\n<| c |>\nI like how this one works. It's a lot more efficient than the answer\
    \ I was working on. Thanks so much.\n<|/ c |>\n<| c |>\nI'm glad it was helpful!\
    \ As a side note, you could have also used the modulus operator in the `if` statement,\
    \ like `if ($i % 11 == 0 && $i % 13 == 0)`. That would have shortened the code\
    \ a bit, but it would require the parentheses, so it really depends on your needs.\
    \ I'm glad you found my answer helpful!\n<|/ c |>\n<| c |>\nIf you're going this\
    \ route, don't forget to use parentheses for `&&` and `,` so that your conditions\
    \ get evaluated correctly.\n<|/ c |>\n<| c |>\nThanks, I updated my answer to\
    \ include the parentheses.\n<|/ c |>\n<| c |>\nThe `$i / 10` will probably be\
    \ more efficient as long as you don't have any numbers greater than `2147483647`,\
    \ which is where Perl starts storing integers. This can cause problems if you\
    \ were to try to do the same operation with a number that has more than 64 digits.\
    \ For example, `perl -Mbignum -E 'say \"42\".to_num() / 10.to_num()'` gives you\
    \ `0`, but `perl -Mbignum -E 'say \"42\".to_num() / 10.to_num().to_num()'` gives\
    \ you `42`.\n<|/ c |>\n<| a tags=perl,division,algorithm,fizzbuzz,modulo dscore=1\
    \ |>\nThe way I did it in my project was to create an array containing only the\
    \ numbers from 1 to 100. Then I looped through each number and applied my algorithm.\
    \ \n<code>\nmy = (1..100);\nfor (my $x = 0; $x <; $x++) {\n    if ($arr[$x] %\
    \ 3 == 0 && $arr[$x] % 5 == 0) {\n        print \"FizzBuzz", '    $n *= 1;', " \
    \   my $count = 0;\n    for my $i (0 .. $n) {\n        if ($i % 11 == 0 || $i\
    \ % 13 == 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=2 tags=fizzbuzz,perl,algorithm |>\n<| c |>\nI suppose\
    \ you're right about \"premature optimization\". Sure, there's a lot of stuff\
    \ here, but it's unnecessary overhead compared to what the OP is currently doing.\
    \ I'd argue that any modern Perl programmer can easily recognize that his solution\
    \ is already O(n).\n<|/ c |>\n<| a |>\nYou can speed up this a little if you know\
    \ some Python.  To do this, first make sure you have Strawberry Perl installed.\
    \  Then:\n<code>\nperl -Mstrict -Mwarnings -lwe 'for (1 .. 10000) { say \"$_\\\
    n\"; $count++ for 1..9 } print \"$count\\n\";'\n</code>\nIf it doesn't print out\
    \ 10000 lines, it means you don't have 10000 lines in the for loop.  To speed\
    \ it up drastically, change it to say for 1..10000.  If it still doesn't work,\
    \ you probably need to install Perl 5.10.  \nThis still works on Strawberry Perl\
    \ 5.16.2 on Windows XP.  On Windows 7, it prints out 10000 lines.  In both cases,\
    \ it didn't print out \"0\" because I forgot about that one.\n<|/ a tags=fizzbuzz,perl,algorithm\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>\nuse strict;\nuse warnings;", '    my($nbuzz,
    $nbuzz2, $i);', "    my $ret = $n / 11;\n    $ret += $n % 11;\n    return $ret;\n\
    }\n</code>\n<|/ a tags=fizzbuzz,perl |>\n<| c |>\nThat's a very nice solution\
    \ (+1), but it only works for positive numbers. Try fizz_buzz(13); it returns\
    \ 2.\n<|/ c |>\n<| c |>\nThanks.  I didn't pay attention to the math.  I've updated\
    \ the solution to handle the case of negative numbers since it's an odd problem.\n\
    <|/ c |>\n<| c |>\nThis would not work if the test was to see if $n was divisible\
    \ by both 11 and 13, and would return 3 when $n=13. Try fizz_buzz(19).\n<|/ c\
    \ |>\n<| c |>\n, Thanks for the catch.  I fixed the bugs.  Hopefully they will\
    \ work out now\n<|/ c |>\n<| a tags=fizzbuzz,perl |>\nHere is another answer that\
    \ uses string comparisons (eq), so it will work for all positive numbers:\n<code>",
  "    return 0 unless $n =~ /^\\d+$/;\n    my($z, $b);\n    # Find how many multiples\
    \ of 11 there are and how many multiples of 13 there are. \n    my(@z, $b, @b,\
    \ @b, $c);\n    my($m, $t, $x, $d, $r, $s, $i, $j, $k, $m, $o, $m, $n, $m, $m,\
    \ $n, @m);\n    $b = $n / 11;\n    $n = $n % 11;\n    $x = $n / 13;\n    $n =\
    \ $n % 13;\n    # Keep looping until we find one whose number of multiples of\
    \ 11 is greater than the remainder. \n    while ($n >= 10) {\n        $m = $n\
    \ * 11;\n        $t += $m;\n        $b = $t / 11;\n        $t = $t % 11;\n   \
    \     push @z, $m;\n    }\n    # Keep looping until we find one whose number of\
    \ multiples of 13 is greater than the remainder.\n    while ($n >= 3) {\n    \
    \    $m = $n * 13;\n        $t += $m;\n        $b = $t / 13;\n        $t = $t\
    \ % 13;\n        push @z, $m;\n    }\n    # Loop until we find one which does\
    \ not divide evenly by 11 or 13. \n    for (my $n = 0; $n <= $b; $n++) {\n   \
    \     foreach $m (@z) {\n            $r += $m; \n            if ($r > $n) {\n\
    \                $s = 0;\n                $s = $r - $n if $n % 3 != 0\n      \
    \                  or ($n % 3 == 0 && $n != 0 && $r / $n == 1);\n            \
    \    $i = ($s + $r) % $n;\n                $j = $i + $n if $i < $n;\n        \
    \        $k = $j + $n if $j > $n;\n                if ($i != $n) {\n         \
    \           $o += $n;\n                    $o += $i;\n                    $o +=\
    \ $j;\n                    $o += $k;\n                }\n                $n =\
    \ $i;\n                $n = $j;\n                $n = $k;\n            }\n   \
    \     }\n    }\n    return $o;\n}\n</code>\nThe code above also supports fizz_buzz(21),\
    \ fizz_buzz(37), fizz_buzz(54), fizz_buzz(63).\n<|/ a tags=algorithm |>\n<| c\
    \ |>\nThis is great! Very compact and very efficient. Unfortunately, it's only\
    \ correct up to fizz_buzz(130). Good thing I started thinking about this ", " \
    \   my(@result) = (\"\");\n    if ($n =~ /\\b11\\b|^\\b13\\b/i) { push(@result,\"\
    $n 11\"); }\n    elsif ($n =~ /\\b10\\b|^\\b12\\b/i) { push(@result,\"$n 10\"\
    ); }\n    elsif ($n =~ /\\b9\\b|^\\b15\\b/i) { push(@result,\"$n 9\"); }\n   \
    \ elsif ($n =~ /\\b8\\b|^\\b14\\b/i) { push(@result,\"$n 8\"); }\n    elsif ($n\
    \ =~ /\\b7\\b|^\\b13\\b/i) { push(@result,\"$n 7\"); }\n    elsif ($n =~ /\\b6\\\
    b|^\\b12\\b/i) { push(@result,\"$n 6\"); }\n    elsif ($n =~ /\\b5\\b|^\\b15\\\
    b/i) { push(@result,\"$n 5\"); }\n    elsif ($n =~ /\\b4\\b|^\\b14\\b/i) { push(@result,\"\
    $n 4\"); }\n    elsif ($n =~ /\\b3\\b|^\\b13\\b/i) { push(@result,\"$n 3\"); }\n\
    \    elsif ($n =~ /\\b2\\b|^\\b12\\b/i) { push(@result,\"$n 2\"); }\n    elsif\
    \ ($n =~ /\\b1\\b|^\\b15\\b/i) { push(@result,\"$n 1\"); }\n    elsif ($n =~ /\\\
    b0\\b|^\\b14\\b/i) { push(@result,\"$n 0\"); }\n    return scalar(@result);\n}",
  "    if ( $n % 11 == 0 && $n % 13 == 0 ) {\n\treturn 0;\n    }\n    return 1 + fizz_buzz($n\
    \ % 11);\n}", "    my($fizzbuzz);\n    my($count);\n    # fizz_buzz returns \"\
    0\" if n is divisible by 11 or 13, and \"1\" for other multiples of 11 or 13.\n\
    \    $fizzbuzz = $n =~ /^(11|13)$/ ? \"1\" : \"0\";\n    $count = ($n % 10);\n\
    \    while ($count > 0) {\n        # Only add $fizzbuzz if $n is divisible by\
    \ 11, or 13 and $count is 0.\n        $fizzbuzz = $fizzbuzz . $fizzbuzz . $fizzbuzz\
    \ . $fizzbuzz . $fizzbuzz . $fizzbuzz . $fizzbuzz;\n        $count = ($n =~ /11$|^13$/\
    \ ? $count + 1 : $count - 1);\n    }\n    return $count;\n}", "    return 0 if\
    \ $n < 10;\n    return 2 if $n % 11 == 7;\n    return 3 if $n % 13 == 7;\n   \
    \ return 1;\n}", "    my(@result) = (0, 0);\n    while ($n) {\n        $n = _n_div($n,\
    \ 11);\n        $n = _n_div($n, 13);\n        push(@result, $n);\n    }\n    my\
    \ $result = $result[0];\n    $result += $result[1];\n    return $result;\n}",
  "    my $count = 0; \n    my $remainder = $n % 11;\n    $count += $remainder ==\
    \ 7 ? 1 : 0;\n    $remainder = $n % 13;\n    $count += $remainder == 7 ? 1 : 0;\n\
    \    return $count;\n}", "    return 0 unless $n =~ /^\\d+$/;\n    return 0 unless\
    \ $n % 11 == 0 || $n % 13 == 0;\n    return $n % 10 == 7 ? 2 : 3;\n}", "    my\
    \ @integers = map {$_ % 11 ? $_ : \"$_ x $n\"} 1 .. $n;\n    return grep { $_\
    \ eq '7 x 7 x 7' } @integers;\n}", "    my(@ret) = ();\n    push(@ret,0) if ($n<13);\n\
    \    push(@ret,1) if ($n<19);\n    push(@ret,2) if ($n<23);\n    push(@ret,3)\
    \ if ($n<29);\n    push(@ret,4) if ($n<37);\n    push(@ret,5) if ($n<43);\n  \
    \  push(@ret,6) if ($n<59);\n    push(@ret,7) if ($n<67);\n    push(@ret,8) if\
    \ ($n<83);\n    push(@ret,9) if ($n<99);\n    push(@ret,10) if ($n<111);\n   \
    \ push(@ret,11) if ($n<131);\n    push(@ret,12) if ($n<169);\n    push(@ret,13)\
    \ if ($n<191);\n    push(@ret,14) if ($n<233);\n    push(@ret,15) if ($n<289);\n\
    \    push(@ret,16) if ($n<363);\n    push(@ret,17) if ($n<419);\n    push(@ret,18)\
    \ if ($n<577);\n    push(@ret,19) if ($n<643);\n    push(@ret,20) if ($n<799);\n\
    \    push(@ret,21) if ($n<877);\n    push(@ret,22) if ($n<947);\n    push(@ret,23)\
    \ if ($n<1013);\n    push(@ret,24) if ($n<1159);\n    push(@ret,25) if ($n<1295);\n\
    \    push(@ret,26) if ($n<1439);\n    push(@ret,27) if ($n<1695);\n    push(@ret,28)\
    \ if ($n<1937);\n    push(@ret,29) if ($n<2209);\n    push(@ret,30) if ($n<2475);\n\
    \    push(@ret,31) if ($n<2827);\n    push(@ret,32) if ($n<3269);\n    push(@ret,33)\
    \ if ($n<3733);\n    push(@ret,34) if ($n<4269);\n    push(@ret,35) if ($n<4",
  "    if ($n < 0) {\n\tdie \"fizz_buzz called with negative number: $n\";\n    }\n\
    \    return 0 if $n % 11;\n    return 1 if $n % 13;\n    return 2 if $n % 17;\n\
    \    return 3 if $n % 23;\n    return 4 if $n % 29;\n    return 5 if $n % 35;\n\
    \    return 6 if $n % 39;\n    return 7 if $n % 41;\n    return 8 if $n % 43;\n\
    \    return 9 if $n % 45;\n    return 10 if $n % 51;\n    return 11 if $n % 57;\n\
    \    return 12 if $n % 63;\n    return 0;\n}", "    return if $n <= 0;\n    my(@digits)\
    \ = map { scalar reverse $_ % 10 } $n / 10;\n    my $count = 0; # Initialize count\
    \ to 0\n    foreach my $digit (@digits) {\n        next unless $digit == 7;\n\
    \        $count++; # Increment count since digit 7 was found\n    }\n    return\
    \ $count;\n}\n</code>\nThe key here is using the map function, which takes a block\
    \ and applies it to each element of the passed in array or list.  In this case,\
    \ our block is scalar reverse $_ % 10 and $_ / 10.  We are then returning an array\
    \ of digits.  What this is doing is reversing the number and then performing a\
    \ modulus and division operator on each digit.\n<|/ a dscore=1 |>\n<| c |>\nThank\
    \ you! I've actually never seen the map function before.\n<|/ c |>\n<| c |>\n\
    No problem :)  Glad I could help.\n<|/ c |>\n<| c |>\nThis solution doesn't work\
    \ properly, please see my answer below. Your solution will return 1 for the following\
    \ inputs: `fizz_buzz(15)` -> returns 1, `fizz_buzz(20)` -> returns 2, `fizz_buzz(24)`\
    \ -> returns 3. The OP asked specifically for the solution to return the number\
    \ of times '7' appears in integers less than n which are divisible by 11 or 13.\n\
    <|/ c |>\n<| c |>\nAh yes, I missed the part of the spec stating that the input\
    \ would have to be less than 10.  I've updated my answer accordingly.  Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=perl |>\nI believe this may be the\
    \ answer you're looking for:\n<code>", "    if ( $n < 10 ) {\n        return $n;\n\
    \    } elsif ( $n >= 100 && $n <= 999 ) {\n        return $n % 11 == 0 ? ( $n\
    \ % 13 == 0 ) ? 0 : 1 : 2 : $n % 13 == 0 ? 3 : 0;\n    } else {\n        return\
    \ $n % 11 == 0 ? ( $n % 13 == 0 ) ? 4 : 0 : $n % 13 == 0 ? 5 : 6;\n    }\n}",
  '    my $count = 0;', "    my($i);\n    my($j);\n    my($n);", "    my $count =\
    \ 0;\n    while ($n =~ /(^|\\s)7(\\s|$)/) {\n        $count += 1;\n    }\n   \
    \ return $count;\n}", "    my $fizz_buzz = 0;\n    $fizz_buzz += 0 while $n =~\
    \ m/7+$/;\n    $fizz_buzz += 1 while $n =~ m/7$/;\n    $fizz_buzz += 2 while $n\
    \ =~ m/7$/;\n    $fizz_buzz += 3 while $n =~ m/7$/;\n    $fizz_buzz += 4 while\
    \ $n =~ m/7$/;\n    $fizz_buzz += 5 while $n =~ m/7$/;\n    $fizz_buzz += 6 while\
    \ $n =~ m/7$/;\n    $fizz_buzz += 7 while $n =~ m/7$/;\n    $fizz_buzz += 8 while\
    \ $n =~ m/7$/;\n    $fizz_buzz += 9 while $n =~ m/7$/;\n    $fizz_buzz += 10 while\
    \ $n =~ m/7$/;\n    $fizz_buzz += 11 while $n =~ m/7$/;\n    $fizz_buzz += 12\
    \ while $n =~ m/7$/;\n    $fizz_buzz += 13 while $n =~ m/7$/;\n    return $fizz_buzz;\n\
    }", "    my($count) = 0;\n    if ($n <= 11) {\n        if ($n <= 7) {\n      \
    \      $count++;\n        } elsif ($n >= 8) {\n            $count++;\n       \
    \ }\n    } elsif ($n <= 13) {\n        if ($n <= 8) {\n            $count++;\n\
    \        } elsif ($n >= 9) {\n            $count++;\n        }\n    } else {\n\
    \        if ($n <= 15) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code assumes that you already know\
    \ how many numbers you are expecting. If you have a larger number of numbers,\
    \ you would probably want to put this in a loop, rather than a subroutine.\n<|/\
    \ c |>\n<| c |>\n, you're absolutely right, I forgot about that possibility. I\
    \ will update my answer shortly. Thank you!\n<|/ c |>\n<| c |>\n, I don't think\
    \ your code counts numbers divisible by 7. That's not what I understood from your\
    \ question.\n<|/ c |>\n<| c |>\n, my code counts divisible by 7. I used your examples\
    \ and my code to understand what you were asking for. It sounds like your understanding\
    \ is wrong, though.\n<|/ c |>\n<| c |>\nI'm sorry, I thought you were just counting\
    \ divisible by 7 in your example (I didn't read the code very carefully). I understand\
    \ now. Sorry for the confusion.\n<|/ c |>\n<| a dscore=3 tags=function,perl,modulus\
    \ |>\n<code>", "    my(@nums);\n    for(my $i=1;$i<=$n;$i++) {\n        if ($i%11==0\
    \ || $i%13==0) {\n            push(@nums,$i);\n        }\n    }\n    my $num_buzz\
    \ = 0;\n    for(my $i=0;$i<@nums;$i++) {\n        my $num = $nums[$i];\n     \
    \   if ($num == 7 && $nums[$i-1] == 7) {\n            $num_buzz++;\n        }\n\
    \        if ($num == 7 && $nums[$i-1] == 13) {\n            $num_buzz++;\n   \
    \     }\n        if ($num == 13 && $nums[$i-1] == 7) {\n            $num_buzz++;\n\
    \        }\n        if ($num == 13 && $nums[$i-1] == 13) {\n            $num_buzz++;\n\
    \        }\n    }\n    return $num_buzz;\n}", "    my(@result) = (0);\n    \n\
    \    # See if n is a multiple of 11.\n    if($n % 11 == 0) {\n        # n is divisible\
    \ by 11, so find out how many times digit 7 appears in the number less than n\
    \ which are divisible by 11\n        my(@result) = ();\n        \n        foreach\
    \ my $i (0 .. $n) {\n            my($remainder) = div($i, 11);\n            my($count)\
    \ = index($remainder, 7) + 1;\n            push(@result, $count);\n        }\n\
    \        \n        # Return the count of the digit 7.\n        return scalar(@result);\n\
    \    }\n    \n    # See if n is a multiple of 13.\n    if($n % 13 == 0) {\n  \
    \      # n is divisible by 13, so find out how many times digit 7 appears in the\
    \ number less than n which are divisible by 13\n        my(@result) = ();\n  \
    \      \n        foreach my $i (0 .. $n) {\n            my($remainder) = div($i,\
    \ 13);\n            my($count) = index($remainder, 7) + 1;\n            push(@result,\
    \ $count);\n        }\n        \n        # Return the count of the digit 7.\n\
    \        return scalar(@result);\n    }\n    \n    return 0;\n}", "    $n -= 1;\n\
    \    $n -= 2 if $n & 1;\n    $n % 11 == 0 && ($n % 13 == 0 || $n % 7 == 0)\n \
    \       or $n % 13 == 0 && ($n % 7 == 0 || $n % 11 == 0)\n        or $n % 7 ==\
    \ 0 && ($n % 11 == 0 || $n % 13 == 0);\n}", "    # Convert n to string for regex\
    \ matching.\n    my($nstr) = $n->as_string;", "    return 0 if ($n % 11);\n  \
    \  return 1 if ($n % 13);\n    return $n if ($n % 7);\n}", "    my $cnt = 0;\n\
    \    while ($n > 0) {\n        $cnt++ while ($n % 11 == 0 || $n % 13 == 0);\n\
    \        $n /= 10;\n    }\n    return $cnt;\n}", "    my $count = 0;\n    while\
    \ ($n >= 11) {\n        $count += $n >= 13;\n        $n = $n - $count * 13;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a tags=perl,fizzbuzz dscore=2 |>\n\
    <| c |>\n+1 for the most readable solution (even if you haven't explained it :-).\
    \ Just a tip: you can rewrite this as a single line `return $n >= 11 ? $n >= 13\
    \ : 0;`\n<|/ c |>\n<| c |>\nYes, this is much more readable. I'll update my answer.\
    \ Thanks.\n<|/ c |>\n<| c |>\nThanks a lot, I like your solution.\n<|/ c |>\n\
    <| c |>\nThanks for your solution and explanation.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", '    return if $n <= 0; # Handle negative numbers', "    my(@array) =\
    \ ();\n    for(my $i = 1; $i <= $n; $i++) {\n        if($i % 11 == 0 || $i % 13\
    \ == 0) {\n            push(@array, $i);\n        }\n    }\n    my $count = 1;\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n        if($array[$i] == 7) {\n       \
    \     $count++;\n        }\n    }\n    return $count;\n}\n</code>\n<|/ a tags=perl,count,fizzbuzz\
    \ |>\n<| c |>\nThanks a lot for the code. As you mentioned, I should avoid using\
    \ regex as much as possible. Thanks for the tip on using $n to count the number\
    \ of the digits from the array.\n<|/ c |>\n<| c |>\nJust for my own interest:\
    \ What is the purpose of the last line in the for loop: if($array[$i] == 7)? It\
    \ seems like you aren't doing anything with the value of $array[$i].\n<|/ c |>\n\
    <| c |>\nThe last line `if($array[$i] == 7)` stops the loop as soon as the value\
    \ 7 is encountered in the array. Without that line it would loop through all of\
    \ the values of the array and check whether the last value was 7 - so for numbers\
    \ containing 7 it would return the number of times that value 7 appeared.\n<|/\
    \ c |>\n<| c |>\nAh I see. That makes a lot of sense. I guess I was thinking that\
    \ it was doing something with the value at $i rather than the whole array. Thanks!\n\
    <|/ c |>\n<| a tags=perl,count,fizzbuzz |>\n<code>\nuse strict;\nuse warnings;",
  "    my($z) =  do {\n        my ($x, $w) = @_;\n        my $s = $x % 11;\n     \
    \   $x = $x / 11;\n        $x = $x % 13;\n        $x = $x / 13;\n        $x ^=\
    \ 1;\n        $x ^= $w;\n        $s ^= $x;\n        return $s;\n    };", "   \
    \ $n += 0;\n    $n -= 1;\n    my $n = $n / 11;\n    my $n = $n % 11;\n    my $n\
    \ = $n / 13;\n    my $n = $n % 13;\n    return $n;\n}", "    return 0 if ($n <=\
    \ 0);\n    return 0 if ($n % 11 <= 0 || $n % 13 <= 0);\n    my $count = 0;\n \
    \   $count++ if ($n % 11 == 0);\n    $count++ if ($n % 13 == 0);\n    $count;\n\
    }", '    return 0 unless $n;', '    return 1 if $n =~ /7$/;', "    $n % 11 ==\
    \ 0 && $n % 13 == 0 ? 0 : ++$n;\n}", '    my($i, $count);', "    my $n1;\n   \
    \ my $n2;\n    $n1 = $n % 11;\n    $n2 = $n % 13;\n    if ($n1 != 0) {\n     \
    \   if ($n1 == 7) {\n            return 0;\n        }\n        if ($n1 == 11 ||\
    \ $n1 == 13) {\n            return 1;\n        }\n    }\n    if ($n2 != 0) {\n\
    \        if ($n2 == 7) {\n            return 1;\n        }\n        if ($n2 ==\
    \ 11 || $n2 == 13) {\n            return 2;\n        }\n    }\n    if ($n1 ==\
    \ 7 || $n2 == 7) {\n        return 3;\n    }\n}", '    my($i);', '    my(@result);',
  "    my $result = 0;\n    while (--$n) {\n\t$result++ if (($n & 3) == 0);\n\t$result++\
    \ if (($n & 1) == 0);\n\t$result++ if (($n & 2) == 0);\n\t$result++ if (($n &\
    \ 7) == 0);\n\t$result++ if (($n & 5) == 0);\n\t$result++ if (($n & 3) == 0) if\
    \ (($n & 1) == 0);\n\t$result++ if (($n & 5) == 0) if (($n & 7) == 0);\n\t$result++\
    \ if (($n & 2) == 0) if (($n & 7) == 0);\n\t$result++ if (($n & 3) == 0) if (($n\
    \ & 5) == 0);\n\t$result++ if (($n & 3) == 0) if (($n & 1) == 0);\n\t$result++\
    \ if (($n & 5) == 0) if (($n & 3) == 0);\n\t$result++ if (($n & 2) == 0) if (($n\
    \ & 3) == 0);\n\t$result++ if (($n & 7) == 0) if (($n & 5) == 0);\n\t$result++\
    \ if (($n & 7) == 0) if (($n & 1) == 0);\n\t$result++ if (($n & 2) == 0) if (($n\
    \ & 5) == 0);\n\t$result++ if (($n & 3) == 0) if (($n & 1) == 0);\n\t$result++\
    \ if (($n & 5) == 0) if (($n & 3) == 0);\n\t$result++ if (($n & 3) == 0) if (($n\
    \ & 5) == 0);\n\t$result++ if (($n & 2) == 0) if (($n & 5) == 0);\n\t$result++\
    \ if (($n & 7) == 0) if (($n & 3) == 0);\n\t$result++ if (($n & 7) == 0) if (($n\
    \ & 5) == 0);\n\t$result++ if (($n & 2) == 0) if (($n & 3) == 0);\n\t$result++\
    \ if (($n & 1) == 0) if (($n & 5) == 0);\n\t$result++ if (($n & 1) == 0) if (($n\
    \ & 3) == 0);\n\t$result++ if (($n & 7) == 0) if (($n & 1) == 0);\n\t$result++\
    \ if (($n & 7) == 0) if (($n & 5) == 0);\n\t$result++ if (($n & 2) == 0) if (($n\
    \ & 1) == 0);\n\t$result++ if (($n & 1) == 0) if (($n & 3) == 0);\n\t$result++\
    \ if (($n & 5) == 0) if (($n & 1) == 0);\n\t$result++ if (($n & 5) == 0) if (($n\
    \ & 7) == 0);\n\t$result++ if (($n & 3", "    return 0 if $n <= 0;\n    return\
    \ $n if $n % 11 == 0 && $n % 13 == 0;\n    return $n % 10 == 0 ? 0 : $n % 10;\n\
    }\n</code>\nThis code takes advantage of the fact that you can return an arbitrary\
    \ number of items in Perl. In many cases, the return value of the subroutine is\
    \ automatically flattened into a single list. Here's another way to write it:\n\
    <code>", '    my(@digits);', "    return $n if $n % 11 == 0;\n    return $n if\
    \ $n % 13 == 0;\n    return $n if $n % 21 == 0;\n    return $n if $n % 31 == 0;\n\
    \    return $n if $n % 41 == 0;\n    return $n if $n % 51 == 0;\n    return $n\
    \ if $n % 61 == 0;\n    return $n if $n % 71 == 0;\n    return $n if $n % 81 ==\
    \ 0;\n    return $n if $n % 91 == 0;\n    return $n;\n}", "    return 0 unless\n\
    \        $n <= 100 && $n =~ /^\\d+$/;\n    $n % 11 == 0 &&\n    $n % 13 == 0 ?\
    \ 1 : 0;\n}", "    my $c = 1;\n    while (1) {\n        $c += ($n / 11) * 3;\n\
    \        $c += ($n % 11) * 2;\n        $n -= $c;\n        $c += ($n / 13) * 3;\n\
    \        $c += ($n % 13) * 2;\n        $n -= $c;\n        return $c if $n <= 0;\n\
    \        return $c if $n == 7;\n        $n++;\n    }\n}", "    # Count the number\
    \ of times $n appears in $n < 50 which are divisible by 11 or 13\n    my $count\
    \ = 0;\n    $n < 50 and $count++ while $n =~ /11|13/ and $n % 11 == 0 ||\n   \
    \         $n =~ /11|13/ and $n % 13 == 0;\n    return $count;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\n+1 but I'm curious about the benefit of using an array to store\
    \ the digits, especially since you never seem to be referencing the array in the\
    \ code. Is a lookup array faster than using regex patterns?\n<|/ c |>\n<| c |>\n\
    The regex pattern is faster than an array lookup because the regex engine has\
    \ to parse the regex each time the digit appears.\n<|/ c |>\n<| c |>\nThanks for\
    \ the great answer. I'm still trying to understand the use of the array though.\
    \ I think I understand that it's storing the digits, however, I don't understand\
    \ how it can go from one value to the next. Where is $n getting its value? How\
    \ does it go from 31 to 7? Would you mind explaining how the code is working so\
    \ that I could understand what's happening? I really appreciate it.\n<|/ c |>\n\
    <| c |>\n- It's getting its value from the argument `@_`. It's an array, because\
    \ that's how you pass arguments to subroutines. I'm also adding some comments\
    \ to the code so you can see what's going on.\n<|/ c |>\n<| c |>\nThanks again\
    \ for your help. I'm still a bit confused though. Why is the $n being stored in\
    \ an array? Why can't it just be passed straight through to the function and stored\
    \ in the variable $n like in the code above? The example above is from a website\
    \ and I'm not familiar with all of the syntax so I'm not really sure how the $n\
    \ variable is being passed through.\n<|/ c |>\n<| a tags=perl,regex dscore=0 |>\n\
    <code>", "    return 0 unless $n > 0;\n    return 0 unless $n =~ /^\\d+$/;\n \
    \   return 0 unless $n % 11 == 0 && $n % 13 == 0;\n    return 1 + $n if $n % 11\
    \ == 0;\n    return $n % 13;\n}", '    my $count;', "    my($count) = 0;\n   \
    \ my($isprime);\n    my($factor);", '    my($counter);', "    return $n % 11 +\
    \ $n % 13 if $n =~ /\\d/;\n    return 0;\n}\n</code>\n<|/ a tags=perl,fizzbuzz\
    \ |>\n<| c |>\nThanks for the edits. I haven't used perl in years.\n<|/ c |>\n\
    <| c |>\nI still prefer the old `for (my $i = 1; $i < 100; $i++){`\n<|/ c |>\n\
    <| a |>\nI think I would rewrite this as a recursive solution. I think it's cleaner\
    \ than the other answers. \n<code>", "    if ($n >= 11 || $n >= 13) {\n      \
    \  0;\n    } else {\n        my $count = 0;\n        if ($n % 11 == 0) {\n   \
    \         $count++;\n        }\n        if ($n % 13 == 0) {\n            $count\
    \ += 2;\n        }\n        return $count;\n    }\n}", "    $n = abs($n);\n  \
    \  my $count = 0;\n    for my $i ( 1 .. $n ) {\n        if ($i % 11 == 0 || $i\
    \ % 13 == 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nHere is my one-liner:\n<code>\nperl -E 'say for\
    \ grep { $_ % 11 != 0 || $_ % 13 != 0 } 1..100'\n</code>\n<|/ a tags=perl,regex\
    \ dscore=3 |>\n<| a dscore=3 |>\nI hate one-liners, but this might work:\n<code>\n\
    perl -E 'say for grep { ($_+0)%11 != 0 || ($_+0)%13 != 0 } 1..100'\n</code>\n\
    <|/ a tags=perl,regex |>\n<| c |>\nIt's a really nice way to add 0 to a number.\
    \ Very smart trick! However, I'd go with `my $n; say for $n=1 .. 100; say for\
    \ grep { $n++ % 11 == 0 or $n++ % 13 == 0 } 1..100`\n<|/ c |>\n<| c |>\n: I agree\
    \ that it would make sense in some cases, but in this particular case I think\
    \ the extra variable isn't a huge problem.\n<|/ c |>\n<| c |>\nYeah, it's a bit\
    \ of an edge case, I agree. It's good to know about tricks like this.\n<|/ c |>\n\
    <| c |>\nI see what you mean. Yes, it looks nicer, but I still prefer `my $n`,\
    \ myself. It may look like a tiny difference, but I think it's worth thinking\
    \ about.\n<|/ c |>\n<| a tags=perl,regex |>\nPerhaps I am missing something, but\
    \ can't you just use modulus operator (%)?\n<code>\nperl -nE 'print if ( ($_ +\
    \ 1) % 11 == 0 or $_ + 1) % 13 == 0 )'\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Well, actually it does. What do you expect `($_ + 1) % 11` to evaluate to? Hint:\
    \ it's `1`.\n<|/ c |>\n<| c |>\nSorry that I forgot to add parenthesis around\
    \ $_ + 1. I forgot it at first and thought it evaluated as a number.\n<|/ c |>\n\
    <| a |>\nIf you want a one-line program with no subroutines, here's another option:\n\
    <code>\nperl -nE 'say for grep { ($_", "    # Only return numbers that are divisible\
    \ by 11 or 13\n    if ($n % 11 == 0 || $n % 13 == 0) {\n        return 0;\n  \
    \  }\n    # Count the number of times the digit 7 appears in integers less than\
    \ n which are divisible by 11 and 13\n    my $count = 0;\n    for (my $i = 0;\
    \ $i < $n; $i++) {\n        my $remainder = $n % 10;\n        $remainder == 7\
    \ ? $count++ : ()\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=2 tags=perl,fizzbuzz\
    \ |>\n<| a dscore=2 tags=perl,fizzbuzz |>\nAnother option would be to use the\
    \ modulus operator to identify which number was entered, but instead of just returning\
    \ if an even number of digits is entered, you could also use a ternary operator\
    \ to return the appropriate string.\n<code>\nprint \"Enter a number: \";\nchomp(my\
    \ $input = <STDIN>);", "    my $count = 0;\n    $n += 0;\n    while($n > 0) {\n\
    \        my $m = $n % 11;\n        if ($m == 0) {\n            $n -= 11;\n   \
    \         $count++;\n        }\n        my $o = $n % 13;\n        if ($o == 0)\
    \ {\n            $n -= 13;\n            $count++;\n        }\n        $n = ($n\
    \ - $o) / 10;\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nI agree with using recursion instead of loops - this is much more intuitive\
    \ and understandable and will also help you with the exercise.\n<|/ c |>\n<| a\
    \ tags=fizzbuzz,perl |>\nMy solution is simple:\n<code>", "    $n =~ tr/137/7/;\n\
    \    return $n;\n}", "    if($n != 0) {\n        my ($k, $v) = (1, 1);\n     \
    \   while($n % $k) {\n            $k += $v;\n            $v += 2;\n        }\n\
    \        return $k - 1;\n    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nHere is the simplest code I could make for this problem.\n<code>\ndef fizz_buzz(n):\n\
    \    count=0\n    while(n>0):\n        if(n%3==0):\n            count+=1\n   \
    \     if(n%5==0):\n            count+=1\n        if(n%7==0):\n            count+=1\n\
    \        n=n-1\n    return count\n</code>\n<|/ a tags=python,fizzbuzz |>\n<| a\
    \ tags=python,fizzbuzz |>\nHere is the solution:\n<code>\ndef fizzbuzz(n):\n \
    \   count=0\n    while(n):\n        if n%3==0:\n            count+=1\n       \
    \ if n%5==0:\n            count+=1\n        if n%7==0:\n            count+=1\n\
    \        n=n-1\n    return count\n</code>\n<|/ a dscore=1 |>\n<| a tags=python,fizzbuzz\
    \ |>\nPython Code\n<code>\ndef fizzbuzz(n):\n    count=0\n    while n>0:\n   \
    \     if n%3==0:\n            count+=1\n        if n%5==0:\n            count+=1\n\
    \        if n%7==0:\n            count+=1\n        n=n-1\n    return count", " \
    \   my $count = 0;\n    if ($n % 11 == 0 ||\n        $n % 13 == 0) {\n       \
    \ $count += 0;\n    } elsif ($n % 11 == 1 ||\n              $n % 13 == 1) {\n\
    \        $count += 1;\n    } elsif ($n % 11 == 2 ||\n              $n % 13 ==\
    \ 2) {\n        $count += 2;\n    } elsif ($n % 11 == 3 ||\n              $n %\
    \ 13 == 3) {\n        $count += 3;\n    } elsif ($n % 11 == 4 ||\n           \
    \   $n % 13 == 4) {\n        $count += 4;\n    } elsif ($n % 11 == 5 ||\n    \
    \          $n % 13 == 5) {\n        $count += 5;\n    } elsif ($n % 11 == 6 ||\n\
    \              $n % 13 == 6) {\n        $count += 6;\n    } elsif ($n % 11 ==\
    \ 7 ||\n              $n % 13 == 7) {\n        $count += 7;\n    } elsif ($n %\
    \ 11 == 8 ||\n              $n % 13 == 8) {\n        $count += 8;\n    } elsif\
    \ ($n % 11 == 9 ||\n              $n % 13 == 9) {\n        $count += 9;\n    }\
    \ elsif ($n % 11 == 10 ||\n              $n % 13 == 10) {\n        $count += 10;\n\
    \    } else {\n        $count += 11;\n    }\n    return $count;\n}", "    my $count\
    \ = () = $n % 10 =~ /7/g;\n    return $count unless $n % 11 == 0 || $n % 13 ==\
    \ 0;\n    return $count + fizz_buzz(int($n/10)) if $n =~ /11|13/g;\n    return\
    \ $count + fizz_buzz(int($n/10));\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n: Oh,\
    \ well, what do you know. I was going to post an alternate answer... but, this\
    \ is much more elegant.\n<|/ c |>\n<| c |>\nI agree with. I'd probably use an\
    \ intermediate variable for the `11|13` part of the expression for clarity, but\
    \ otherwise this is a good answer.\n<|/ c |>\n<| a tags=regex,perl,fizzbuzz |>\n\
    <code>\nuse 5.10.0;", "    if($n =~ /^\\d+$/){\n        $n % 11 == 0 ? ( fizz_buzz($n/11)\
    \ ) : ( fizz_buzz($n/13) );\n    }\n    return 0;\n}", '    return 0 unless $n
    =~ /^\d+$/;', "    my(@numbers) = ();\n    while ($n =~ m/7/ || $n =~ m/8/ ||\
    \ $n =~ m/9/ || $n =~ m/10/ || $n =~ m/11/ || $n =~ m/12/) {\n        push(@numbers,\
    \ $n);\n    }\n    foreach my $number (@numbers) {\n        return 2 if $number\
    \ =~ m/7/;\n        return 3 if $number =~ m/8/;\n        return 4 if $number\
    \ =~ m/9/;\n        return 5 if $number =~ m/10/;\n        return 6 if $number\
    \ =~ m/11/;\n        return 7 if $number =~ m/12/;\n    }\n    return 0;\n}",
  "    my(@fizz_buzz);\n    foreach my $i (0 .. $n) {\n        if ($i % 11 == 0 or\n\
    \            $i % 13 == 0) {\n            push (@fizz_buzz, ++$i);\n        }\n\
    \    }\n    return @fizz_buzz;\n}\n</code>\n<|/ a |>\n<| c |>\nI think you meant\
    \ `return scalar`, not `return @fizz_buzz`.\n<|/ c |>\n<| c |>\nActually no. I\
    \ meant `return scalar`. I wanted to return an array, but forgot to add an `@`\
    \ prefix when returning.\n<|/ c |>\n<| a tags=fizzbuzz,perl |>\nHere's a short\
    \ example that shows the use of splice to generate a list of numbers:\n<code>\n\
    use strict;\nuse warnings;", "    $n = $n / 10;\n    return 0 unless $n % 11;\n\
    \    return 2 unless $n % 13;\n    return 1;\n}", "    my($n2) = ($n / 11) + int($n\
    \ / 13);\n    my @fizzbuzz = ();\n    my @numbers = ();\n    for ($n = 0; $n <\
    \ $n2; ++$n) {\n        if ($n % 11 == 0 || $n % 13 == 0) {\n            push\
    \ @numbers, $n;\n        } else {\n            push @fizzbuzz, $n if $n % 7 ==\
    \ 0;\n        }\n    }\n    my $max = 0;\n    $max = 0 for @fizzbuzz;\n    for\
    \ my $number (@numbers) {\n        if ($number == 7) {\n            return $max;\n\
    \        }\n        $max++\n    }\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks, I haven't been able to find a solution that uses map in that way.\n<|/\
    \ c |>\n<| a tags=if-statement,perl |>\nHere's a little script that finds the\
    \ number in the range 1-100\nthat has the most digits that divide by 3 and 5\n\
    <code>", "    my $i = 0;\n    my $j = 0;\n    while ($i < $n) {\n        if ($i\
    \ & 1) {\n            $j++;\n        }\n        if ($j & 1) {\n            if\
    \ ($i & 1) {\n                $j++;\n            }\n            if ($i & 2) {\n\
    \                $j++;\n            }\n            if ($i & 4) {\n           \
    \     $j++;\n            }\n            if ($i & 8) {\n                $j++;\n\
    \            }\n            if ($i & 16) {\n                $j++;\n          \
    \  }\n            if ($i & 32) {\n                $j++;\n            }\n     \
    \       if ($i & 64) {\n                $j++;\n            }\n            if ($i\
    \ & 128) {\n                $j++;\n            }\n        }\n        if ($j &\
    \ 1) {\n            if ($i & 1) {\n                $j++;\n            }\n    \
    \        if ($i & 2) {\n                $j++;\n            }\n            if ($i\
    \ & 4) {\n                $j++;\n            }\n            if ($i & 8) {\n  \
    \              $j++;\n            }\n        }\n        if ($j & 2) {\n      \
    \      if ($i & 1) {\n                $j++;\n            }\n            if ($i\
    \ & 2) {\n                $j++;\n            }\n            if ($i & 4) {\n  \
    \              $j++;\n            }\n            if ($i & 8) {\n             \
    \   $j++;\n            }\n            if ($i & 16) {\n                $j++;\n\
    \            }\n            if ($i & 32) {\n                $j++;\n          \
    \  }\n            if ($i & 64) {\n                $j++;\n            }\n     \
    \       if ($i & 128) {\n                $j++;\n            }\n        }\n   \
    \     if ($j & 4) {\n            if ($i & 1) {\n                $j++;\n      \
    \      }\n            if ($i & 2) {\n                $j++;\n            }\n  \
    \          if ($i & 4) {\n                $j++;\n            }\n            if\
    \ ($i & 8) {\n                $j++;\n            }\n            if ($i & 16) {\n\
    \                $j++;\n            }\n            if ($i & 32) {\n          \
    \      $j++;\n            }\n            if ($i & 64) {\n                $j++;\n\
    \            }\n            if ($i & 128) {\n                $j++;\n         \
    \   }\n        }\n        if ($j & 8) {\n            if ($i & 1) {\n         \
    \       $j++;\n            }\n            if ($i & 2) {\n                $j++;\n\
    \            }\n            if ($i & 4) {\n                $j++;\n           \
    \ }\n            if ($i & 8) {\n                $j++;\n            }\n       \
    \     if ($i & 16) {\n                $j++;\n            }\n            if ($i\
    \ & 32) {\n                $j++;\n            }\n            if ($i & 64) {\n\
    \                $j++;\n            }\n            if ($i & 128) {", "    if ($n\
    \ =~ /^\\d+$/) {\n        $n += 0;  # coerce to string\n    }\n    my($cnt);\n\
    \    my $base = 1;\n    while ($n > 0) {\n        $cnt += $n % $base;\n      \
    \  $n /= $base;\n        $base *= 10;\n    }\n    return $cnt;\n}", "    my $count\
    \ = 0;\n    if ( $n <= 4 ) {\n        $count = $n\n    }\n    elsif ( $n <= 9\
    \ ) {\n        $count = 1;\n    }\n    else {\n        if ( $n % 11 == 0 || $n\
    \ % 13 == 0 ) {\n            $count += 1;\n        }\n    }\n    return $count;\n\
    }", "    $n = 1 if $n == 0;\n    return $n if $n % 11 == 0 || $n % 13 == 0;\n\
    \    my($a) = 0;\n    for(my $i = $n % 10; $i >= 0 && $a < 50; $i--) {\n     \
    \   $a++;\n    }\n    return $a + $n % 10;\n}", "    my($count) = @_ > 9 ? 4 :\
    \ 1;\n    return ($n % 11 ? $count : $count++);\n}", "    return 0 unless $n =~\
    \ /^-?\\d+$/;\n    my $fizz = 127;\n    my $buzz = 129;\n    $fizz++ while ($n\
    \ % $fizz) ne 0;\n    $buzz++ while ($n % $buzz) ne 0;\n    return $n if $fizz\
    \ == $buzz && $fizz == 13;\n    return $n if $fizz == $buzz && $fizz == 11 ||\
    \ $fizz == 13;\n    return $n if $buzz == $fizz && $buzz == 11 || $buzz == 13;\n\
    \    return $n;\n}", "    my($result);\n    while ($n > 0) {\n        # Skip this\
    \ number if it's divisible by 11 or 13.\n        if ($n % 11 == 0 || ($n % 13\
    \ == 0)) {\n            next;\n        }\n        # Add the digit 7 to this number\
    \ if it's divisible by both 11 and 13.\n        if ($n % 7 == 0) {\n         \
    \   $result += 3;\n        }\n        $n--;\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=fizzbuzz,algorithm,math,perl |>\n<| c |>\nI understand this solution\
    \ but I have no idea how it works. Could you please explain how this works?\n\
    <|/ c |>\n<| c |>\n: I added some comments. I hope it helps. Please let me know\
    \ if any part is unclear.\n<|/ c |>\n<| c |>\nThank you very much. I understand\
    \ it now.\n<|/ c |>\n<| c |>\nYou shouldn't use `while (<>)` in place of `while\
    \ (<STDIN>)`.  See [this question](https://stackoverflow.com/questions/16285606/why-is-using-while-with-system-out-more-dangerous-than-while-if-reading-a-file)\
    \ for the reason.\n<|/ c |>\n<| c |>\n: Thanks for the pointer. I was wondering\
    \ why my code was not working and I got a bit confused. :)\n<|/ c |>\n<| a |>\n\
    Perl's \"magic number\" features are a big advantage for this kind of thing, because\
    \ the code becomes more readable.\n<code>", "    return 0 if ($n <= 1);\n    my($fb_factors)\
    \ = @FB_factors;\n    my($fb_count) = (@FB_count - 1);\n    my($fb_increment)\
    \ = (@FB_increment - 1);\n    my($fb_mods) = @FB_mods;\n    my($fb_mods_count)\
    \ = (@FB_mods_count - 1);\n    my($fb_mods_increment) = (@FB_mods_increment -\
    \ 1);", "    return 1 if $n <= 0;\n    return 1 if $n % 11 == 0;\n    return 1\
    \ if $n % 13 == 0;\n    return $n / 11 + fizz_buzz($n / 13);\n}", "    return\
    \ if $n =~ /^\\d+$/;\n    return 0 unless $n % 11 == 0 || $n % 13 == 0;\n    my($count)\
    \ = 0;\n    for (my $i = 1; $i <= $n; $i += 10) {\n        if ($i % 11 == 0 ||\
    \ $i % 13 == 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    for ($n; $n >= 10; $n -= 10) {\n        if ($n %\
    \ 11 == 0 || $n % 13 == 0) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    if ($n <= 11 || $n <= 13) {\n        return 0;\n    }\n  \
    \  return 1 if ($n % 11 == 7);\n    return 1 if ($n % 13 == 7);\n    return 1;\n\
    }", "    $n =~ tr/0-9//;\n    return $n if $n % 11 == 0 && $n % 13 == 0;\n   \
    \ return $n % 11 + ($n % 13 == 0 ? 0 : 1);\n}", "    my $counter = 0;\n    while($n\
    \ >= 11) {\n\t$n -= 11;\n\t$counter++;\n    }\n    while($n >= 13) {\n\t$n -=\
    \ 13;\n\t$counter++;\n    }\n    return $counter;\n}", "    return 0 if ($n <=\
    \ 0) or $n % 11 == 0 or $n % 13 == 0;\n    return 2 if ($n % 11) == 0 and ($n\
    \ % 13 == 0);\n    return 3 if ($n % 11) == 0 and ($n % 13 != 0);\n    return\
    \ 5 if ($n % 11) != 0 and ($n % 13 == 0);\n    return 7 if ($n % 11) != 0 and\
    \ ($n % 13 != 0);\n}\n</code>\n<|/ a dscore=2 tags=fizzbuzz,perl,algorithm,subroutine,math\
    \ |>\n<| a tags=fizzbuzz,perl,algorithm,subroutine,math |>\n<code>", "    for(my\
    \ $i = 1; $i <=$n; ++$i) {\n        return $i%11 == $i % 13 ? $i : -$i;\n    }\n\
    \    return -$n;\n}", "    my %digits = map {$_=>1} 1 .. 9;\n    my $count = 0;",
  '    my(@digits);', "    return 0 if $n & 7;\n    $n &= ~7;\n    return $n / 11\
    \ + $n % 11;\n}", "    $n = 0 unless defined $n;\n    $n = 0 unless $n % 11 ==\
    \ 0;\n    $n = 0 unless $n % 13 == 0;\n    $n % 13 == 0 ?\n        $n = 0 unless\
    \ $n % 16 == 0 :\n        $n = 0 if $n % 15 == 0;\n    $n % 11 == 0 ?\n      \
    \  $n = 0 unless $n % 14 == 0 :\n        $n = 0 if $n % 13 == 0;\n    $n % 11\
    \ == 0 ?\n        $n = 0 unless $n % 12 == 0 :\n        $n = 0 if $n % 11 == 0;\n\
    \    return $n;\n}\n</code>\nThe same code refactored:\n<code>", "    my $counter\
    \ = 0;\n    for ($n; $n >= 0; $n -= 10) {\n        $counter += $n =~ /7/;\n  \
    \  }\n    return $counter;\n}", "    return 0 if $n % 11 == 0 and $n % 13 == 0;\n\
    \    return 2 if $n % 11 == 0 and $n % 13 != 0;\n    return 3 if $n % 11 != 0\
    \ and $n % 13 == 0;\n    return 4 if $n % 11 != 0 and $n % 13 != 0;\n    return;\n\
    }", "    if ($n < 100) {\n        return 0;\n    }\n    return 1 if ($n % 11 ==\
    \ 13);\n    return 1 if ($n % 13 == 11);\n    return 1 if ($n / 11 == 7);\n  \
    \  return 1 if ($n / 13 == 7);\n    return 2;\n}\n</code>\n<|/ a |>\n<| a tags=perl,fizzbuzz\
    \ |>\nI wrote this one and it works perfectly for me:\n<code>", "    $n =~ tr/7/7/;\n\
    \    return if $n <= 0;\n    return if $n % 11 == 0 || $n % 13 == 0;\n    return\
    \ $n / 11;\n}\n</code>\n<|/ a tags=perl,fizzbuzz |>\n<| c |>\nThanks Borodin &\
    \ Andy for the quick response. I will look at this shortly.\n<|/ c |>\n<| c |>\n\
    Thanks for the code Andy. I did run it and that works great! I have not used Perl\
    \ before, so I am not familiar with some of the modules. I like it!\n<|/ c |>\n\
    <| a |>\n<code>", '    return $n if $n =~ /^[13579][^7]*7[^7]7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7?7',
  "    my $count = 0;\n    for my $d (1..$n) {\n        if ( ($d % 11) == 0 ) {\n\
    \            $count++;\n        }\n        if ( ($d % 13) == 0 ) {\n         \
    \   $count++;\n        }\n        if ( ($d % 17) == 0 ) {\n            $count++;\n\
    \        }\n        if ( ($d % 31) == 0 ) {\n            $count++;\n        }\n\
    \        if ( ($d % 47) == 0 ) {\n            $count++;\n        }\n    }\n  \
    \  return $count;\n}", "    return 0 if (($n % 11) == 0);\n    return 0 if (($n\
    \ % 13) == 0);\n    return 0 if (($n // 11) % 11) == 0;\n    return 0 if (($n\
    \ // 13) % 13) == 0;\n    return 1;\n}", "    return 1 if $n =~ m/^(13|11)$/;\
    \ # no zeroes, no 11s\n    return $n if $n%11 == 0 or $n%13 == 0;\n    return\
    \ 0 if $n =~ m/^0$/; # no negative numbers\n    $n *= 3;\n    $n += 3;\n    return\
    \ $n%11 == 0 ? 1 : 2;\n}", "    my $count = 0;\n    for my $number (1..$n) {\n\
    \        next if $number % 11 == 0 || $number % 13 == 0;\n        if ($number\
    \ % 7 == 1) {\n            $count++;\n        }\n    }\n    return $count;\n}\n\
    </code>\n<|/ a tags=perl,algorithm |>\n<| a tags=perl,algorithm |>\nI love Python!\n\
    <code>\ndef fizz_buzz(n):\n    for x in range(1, n + 1):\n        if x % 11 ==\
    \ 0 or x % 13 == 0:\n            if x % 7 == 1:\n                return 1\n  \
    \  return 0\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for large\
    \ numbers. For example, fizz_buzz(10**9) returns 0, as expected (10**9 = 1e9).\n\
    <|/ c |>\n<| c |>\nThis doesn't work because you return from your function as\
    \ soon as you have found a fizz_buzz. Try returning after you have tested all\
    \ numbers.\n<|/ c |>\n<| c |>\nThe code as posted works. (In fact, `fizz_buzz(10**9)\
    \ == 0` on Python 2.7.4). Are you saying that my code fails for large numbers?\n\
    <|/ c |>\n<| c |>\nAh, indeed! It would return `1` for large numbers because of\
    \ how you use `return` in the conditional of the `if`. I've edited the answer\
    \ to fix it.\n<|/ c |>\n<| a dscore=2 tags=perl,algorithm |>\n<code>", "    my\
    \ $i = 0;\n    while($i <$n) {\n        if ( (($i % 11) == 0 && ($i % 13) == 0)\n\
    \            || (($i % 11) == 0 && (($i / 11) == ($i % 11))\n            && (($i\
    \ % 13) == 0 && (($i / 13) == ($i % 13))) ) {\n            ++$i;\n        }\n\
    \        else {\n            ++$i;\n        }\n    }\n    return $i;\n}\n</code>\n\
    <|/ a tags=fizzbuzz,raku |>\n<| a tags=fizzbuzz,raku |>\nHere is a solution based\
    \ on my previous answer:\n<code>", "    my(@digits) = ($n =~ tr/0-9//);\n    my($count,\
    \ $count_in) = (0);\n    my($remainder) = ($n =% 11);\n    my($remainder2) = ($n\
    \ =% 13);", "    my $count = 0;\n    for (my $i = 7; $i < $n; $i++) {\n      \
    \  if ($n % $i == 0 && $n // $i == $i) {\n            $count++;\n        }\n \
    \   }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nUsing Perl:\n\
    <code>", "    my $i = 1;\n    while($i > $n) {\n        my($divisible) = @_;\n\
    \        if($n =~ /\\b($divisible*7)\\b/) {\n            $i += $divisible * 3;\n\
    \        }\n        if($n =~ /\\b($divisible*11|13)\\b/) {\n            $i +=\
    \ $divisible * 3;\n        }\n        if($i > ($n / 3)) {\n            $i += $n\
    \ % 3;\n        }\n        $n++;\n    }\n    return $i;\n}", "    return 1 if\
    \ ($n =~ m/^\\d+$/);\n    my($remainder, $digit, $i);\n    \n    foreach $i ($n\
    \ % 11, $n % 13) {\n        if ($i !~ m/11|13$/) {\n            if ($i =~ m/7$/)\
    \ {\n                $digit = 7;\n            } else {\n                $digit\
    \ = $i;\n            }\n            last if $digit == 7;\n        }\n    }\n \
    \   return $digit if defined $digit;\n    return 0;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\n+1 for the nice solution. I wonder what would be the best approach\
    \ for solving this problem in Python?\n<|/ c |>\n<| a tags=math,algorithm |>\n\
    Here is my solution in Python 3:\n<code>\ndef fizz_buzz(n):\n    if n == 0:\n\
    \        return \"0\"\n    if n % 11 == 0 or n % 13 == 0:\n        return str(n)\n\
    \    if n % 7 == 0:\n        return \"7\"\n    else:\n        return fizz_buzz(n\
    \ // 7) * 3", "    return 0 if $n =~ /^0/;\n    $n =~ s/^0/0/g;\n    my $result\
    \ = $n =~ m/((11|13)(\\d){5})/;\n    return $result ? $1+$2 : 0; \n}", "    $n\
    \ =~ tr/13579x987/13579x987x/;\n    return ($n % 11 ? 1 : 0) + ($n % 13 ? 2 :\
    \ 0);\n}", "    my $count = 0;\n    while($n =~ /(\\b7\\b)|(\\b8\\b)|(\\b9\\b)|(\\\
    b10\\b)|(\\b11\\b)|(\\b12\\b)|(\\b13\\b)/g) {\n        $count++;\n        $n =~\
    \ s/(\\b7\\b)|(\\b8\\b)|(\\b9\\b)|(\\b10\\b)|(\\b11\\b)|(\\b12\\b)|(\\b13\\b)//g;\n\
    \    }\n    return $count;\n}", "    my $result = 0;\n    for my $i (0 .. $n)\
    \ {\n        my $d = $i % 11;\n        if ($d eq '0' or $d eq '7') {\n       \
    \     $result ++;\n        }\n        $result += (11 - $d);\n    }\n    $result;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI came up with something like this:\n<code>"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
