name: HumanEval_142_sum_squares
language: pl
prompt: "# \"\n# This function will take an array of integers. For all entries in\
  \ the array, the function shall square the integer entry if its index is a \n# multiple\
  \ of 3 and will cube the integer entry if its index is a multiple of 4 and not a\
  \ multiple of 3. The function will not \n# change the entries in the array whose\
  \ indexes are not a multiple of 3 or 4. The function shall then return the sum of\
  \ all entries. \n# Examples:\n# >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n\
  # [-1, -5, 2, -1, -5]\nsub sum_squares {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n\
  \        if(eq_deeply($candidate->([1, 2, 3]),6)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 9]),14)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 1, 1, 1, 1, 1, 1, 1, 1]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0]),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ -5, 2, -1, -5]),-126)) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([-56, -99, 1, 0, -2]),3030)) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ 0, 0, 0, 0, 0, 0, 0, -1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([-16, -9, -2, 36, 36, 26, -20, 25,\
  \ -40, 20, -4, 12, -26, 35, 37]),-14196)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, 17, -1, -15,\
  \ 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448)) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $sum;\n    for my $i (0 .. $#{$lst}) {\n        if ($i % 3 ==\
    \ 0) {\n            $sum += $lst->[$i] * $lst->[$i];\n        }\n        elsif\
    \ ($i % 4 == 0) {\n            $sum += $lst->[$i] * $lst->[$i] * $lst->[$i];\n\
    \        }\n        elsif ($i % 3 != 0 && $i % 4 != 0) {\n            $sum +=\
    \ $lst->[$i];\n        }\n    }\n    return $sum;\n}", "    my ($sum,$x,$tmp);\n\
    \    foreach $x (@$lst) {\n        if ($x % 3 == 0) {\n            $sum += $x\
    \ * $x;\n        }\n        if ($x % 4 == 0) {\n            $sum += $x * $x;\n\
    \        }\n        elsif ($x % 4 != 0) {\n            $sum += $x * $x;\n    \
    \    }\n    }\n    return $sum;\n}", "    my @sums;\n    my ($n, $m);\n    for\
    \ ($n = 0; $n < @$lst; $n++) {\n        $m = $n % 3;\n        if ($m == 0) {\n\
    \            $sums[$n] += $lst->[$n] * $lst->[$n];\n        } elsif ($m == 1)\
    \ {\n            $sums[$n] += $lst->[$n] * $lst->[$n] * $lst->[$n];\n        }\
    \ elsif ($m == 2) {\n            $sums[$n] += $lst->[$n] * $lst->[$n] * $lst->[$n]\
    \ * $lst->[$n];\n        }\n    }\n    return @sums;\n}", "    my ($res, $sum);\n\
    \    $sum = 0;\n    for my $i (0 .. @$lst - 1) {\n        if ($i % 3 == 0) {\n\
    \            $res += $lst->[$i] * $lst->[$i];\n        }\n        if ($i % 4 ==\
    \ 0) {\n            $res += $lst->[$i] * $lst->[$i];\n        }\n        else\
    \ {\n            $sum += $lst->[$i];\n        }\n    }\n    return $sum;\n}",
  "    my @new_lst;\n    for(@$lst){\n      if($_ & 3) {\n        $_ *= $_;\n    \
    \  }\n      else {\n        $_ *= $_;\n      }\n      push (@new_lst,$_);\n  \
    \  }\n    return @new_lst;\n}\n</code>\n<|/ a dscore=0 tags=perl,arrays |>\n<|\
    \ a tags=perl,arrays |>\nThis is what I was looking for:\n<code>", "    my @sum\
    \ = (0);\n    foreach my $num (@$lst){\n        if ($num % 3 == 0 && $num % 4\
    \ == 0) {\n            $num *= $num;\n            $sum[0] += $num;\n        }\
    \ elsif ($num % 3 == 0) {\n            $num *= $num;\n            $sum[0] += $num;\n\
    \        } elsif ($num % 4 == 0) {\n            $num *= $num;\n            $sum[0]\
    \ += $num;\n        } else {\n            $sum[0] += $num;\n        }\n    }\n\
    \    return $sum[0];\n}\n</code>\n<|/ a dscore=0 tags=perl |>\n<| c |>\nThis solution\
    \ works. Thank you very much. I now have more understanding of my question and\
    \ will try to apply your code.\n<|/ c |>\n<| c |>\nMy first thought was to sort\
    \ the list, then do an if statement to print out a negative number if the third\
    \ value of the list is negative, but I couldn't get it to work. I'll keep looking\
    \ into your solution and see if I can get it to work. Thanks again.\n<|/ c |>\n\
    <| c |>\nSure. Glad to help. And good luck with your coding project!\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is another way to do this using the map function in perl:\n\
    <code>", "    my($ret);\n    \n    for (@$lst) {\n        if ($_ % 3 == 0) {\n\
    \            $ret += $_ * $_;\n        }\n        elsif ($_ % 4 == 0) {\n    \
    \        $ret += $_ * $_ * $_;\n        }\n        else {\n            $ret +=\
    \ $_;\n        }\n    }\n    \n    return $ret;\n}", "    \n    my($sum) = 0;\n\
    \    \n    foreach $idx (@$lst) {\n        my $val = $idx;\n        if($idx %\
    \ 3 != 0) {\n            $val = $val * $val;\n        }\n        elsif($idx %\
    \ 4 != 0) {\n            $val = $val * $val;\n        }\n        $sum += $val;\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nI like your solution,\
    \ though it does have a problem: when passed a negative number it returns `0`,\
    \ when in fact it is negative. Perhaps add a `> 0` comparison to the end (`$sum\
    \ > 0`)?\n<|/ c |>\n<| c |>\n- Yes, thanks for pointing that out. I forgot that\
    \ since I wanted to write an answer that would work for both positive and negative\
    \ numbers. I will edit my answer to include a check for negative numbers too.\n\
    <|/ c |>\n<| a tags=perl,arrays |>\n<code>", "    my @sums;\n    my ($i, $val);\n\
    \    for ($i = 0; $i < @$lst; $i++) {\n        $val = $lst->[$i];\n        push\
    \ (@sums, $val) if $val % 3 == 0 || $val % 4 == 0;\n    }\n    $_ = $sums[0]+$sums[1]+$sums[2]+$sums[3]+$sums[4];\n\
    \    return $_;\n}", "    my(@result,@arr);\n    foreach $entry(@$lst) {\n   \
    \     push(@arr,$entry) if $entry%3;\n        push(@arr,$entry) if $entry%4;\n\
    \        push(@result,$entry) if $entry%3 && $entry%4;\n    }\n    foreach (@result)\
    \ {\n        push(@arr,$_);\n    }\n    foreach (@arr) {\n        my $val = $_;\n\
    \        $val = $val*$val if $val%3;\n        $val = $val*$val if $val%4;\n  \
    \      push(@result,$val);\n    }\n    return(@result);\n}", "    my(@res);\n\
    \    foreach my $i (@$lst) {\n        if ($i % 3 != 0) {\n            push(@res,\
    \ scalar $i*$i);\n        }\n        if ($i % 4 != 0) {\n            push(@res,\
    \ scalar $i*$i*$i);\n        }\n    }\n    return scalar @res;\n}", "    my;\n\
    \    my $index = 0;\n    while ($index < scalar(@$lst)) {\n        if ($index%3\
    \ == 0) {\n            push(@result, $index*$index);\n        }\n        elsif\
    \ ($index%4 == 0) {\n            push(@result, $index*$index);\n        }\n  \
    \      else {\n            push(@result, $lst->[$index]);\n        }\n       \
    \ $index++;\n    }\n    return $lst->[0] + $lst->[1] + $lst->[2];\n}", "    my\
    \ $sum = 0;\n    foreach my $i(@$lst) {\n        if ($i % 3 == 0) {\n        \
    \    $sum = $sum + $i*$i;\n        }\n        elsif ($i % 4 == 0) {\n        \
    \    $sum = $sum + $i*$i*$i;\n        }\n        else {\n            $sum = $sum\
    \ + $i;\n        }\n    }\n    return $sum;\n}\n</cell>\n<cell>\n%%writefile squares.pl",
  "    my @sum_array;\n    foreach (@$lst) {\n        if ($_ % 3 != 0) {\n       \
    \     push(@sum_array, $_ * $_);\n        }\n        if ($_ % 4 != 0) {\n    \
    \        push(@sum_array, $_ * $_ * $_);\n        }\n        else {\n        \
    \    push(@sum_array, $_);\n        }\n    }\n    return sum(@sum_array);\n}",
  "    my ($sum, $i, $j);\n    $sum = 0;\n    for ($i = 0; $i < @{$lst}; $i++) {\n\
    \        if ($i % 3 == 0) {\n            $sum += $lst->[$i] * $lst->[$i];\n  \
    \      } elsif ($i % 4 == 0) {\n            $sum += $lst->[$i] * $lst->[$i];\n\
    \        } else {\n            $sum += $lst->[$i];\n        }\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    \n    for (@$lst) {\n        my $v = $_;\n\
    \        \n        if ($v % 3 == 0) {\n            $v *= $v;\n            $sum\
    \ += $v;\n        }\n        \n        if ($v % 4 == 0) {\n            $v *= $v;\n\
    \            $sum += $v;\n        }\n    }\n    \n    return $sum;\n}\n</cell>\n\
    <cell>", "    my $sum = 0;\n    foreach my $num (@$lst) {\n        if ($num %\
    \ 3 == 0) {\n            $sum = $sum + $num * $num;\n        } elsif ($num % 4\
    \ == 0) {\n            $sum = $sum + $num * $num * $num;\n        } else {\n \
    \           $sum = $sum + $num;\n        }\n    }\n    return $sum;\n}", "   \
    \ my $sum = 0;\n    foreach my $i (0..$#lst) {\n        if ($i % 3 == 0) {\n \
    \           $sum += $lst[$i] * $lst[$i] * $lst[$i];\n        }\n        if ($i\
    \ % 4 == 0) {\n            $sum += $lst[$i] * $lst[$i] * $lst[$i] * $lst[$i];\n\
    \        }\n    }\n    return $sum;\n}", "    my $result;\n    for (@$lst) {\n\
    \        next if $_ & 4;\n        $result += $_ * $_;\n    }\n    return $result;\n\
    }", "    my (@sums) = ();\n    foreach my $element (@$lst) {\n        if($element\
    \ % 3 == 0) {\n            $element *= $element;\n        }\n        elsif ($element\
    \ % 4 == 0) {\n            $element *= $element;\n        }\n        push(@sums,\
    \ $element);\n    }\n    my $sum_of_entries = scalar(@sums);\n    return $sum_of_entries;\n\
    }", "    my $sum = 0;\n    for (0..$#$lst) {\n        $sum += $lst->[$_] * $lst->[$_]\
    \ if ($lst->[$_] % 3 == 0) or ($lst->[$_] % 4 == 0);\n    }\n    return $sum;\n\
    }", "    my($sum) = 0;\n    my($i);\n    for ($i = 0; $i <; $i++) {\n        if\
    \ ($lst[$i] % 3 == 0) {\n            $sum += $lst[$i] * $lst[$i];\n        }\n\
    \        elsif ($lst[$i] % 4 == 0) {\n            $sum += $lst[$i] * $lst[$i];\n\
    \        }\n        else {\n            $sum += $lst[$i];\n        }\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", " \
    \   \n    my;\n    \n    foreach my $i(@{$lst}) {\n        if ($i % 3 == 0) {\n\
    \            $i += $i * $i;\n        }\n        elsif ($i % 4 == 0) {\n      \
    \      $i += $i * $i;\n        }\n        push @{$sum}, $i;\n    }\n    \n   \
    \ return $sum;\n}", "    my $sum = 0;\n    foreach my $idx (0 .. $#lst) {\n  \
    \      next if $idx % 3 == 0;\n        next if $idx % 4 == 0;\n        $sum +=\
    \ $lst[$idx] * $lst[$idx];\n    }\n    return $sum;\n}", "    my @sum;\n    for(my\
    \ $i = 0; $i < @$lst; ++$i) {\n        push(@sum, ((($i % 3 == 0) and ($i % 4\
    \ == 0)) or (($i % 4 == 0))) ? $lst->[$i]*$lst->[$i]*$lst->[$i] : sqrt($lst->[$i])));\n\
    \    }\n    return @sum;\n}", "    my $sum = 0;\n    foreach (@$lst) {\n     \
    \   if (index($_) % 3 == 0 && index($_) % 4 == 0) {\n            $_ *= $_;\n \
    \           $sum += $_;\n        } else {\n            $sum += $_;\n        }\n\
    \    }\n    return $sum;\n}", "    my($ret);\n    for (@$lst) {\n        if ($_\
    \ % 3 == 0) {\n            $ret = $ret + $_ * $_;\n        }\n        if ($_ %\
    \ 4 == 0) {\n            $ret = $ret + $_ * $_;\n        }\n        if ($_ % 3\
    \ != 0 and $_ % 4 != 0) {\n            $ret = $ret + $_ * $_;\n        }\n   \
    \ }\n    return $ret;\n}", "    \n    return 0 unless @$lst;\n    \n    $lst =~\
    \ s/^\\s+//;\n    $lst =~ s/\\s+$//;\n    \n    my $sum = 0;\n    my $count =\
    \ 0;\n    my $index = 0;\n    \n    foreach my $i (@$lst) {\n        \n      \
    \  my $sq = $i;\n        $sq *= $i;\n        $sq /= 3;\n        $sq *= $i;\n \
    \       $sq /= 4;\n        \n        $sum += $sq;\n        $count++;\n       \
    \ \n        if ($index++ % 3 == 0) {\n            $sum += $sq;\n        }\n  \
    \      if ($index++ % 4 == 0) {\n            $sum += $sq;\n        }\n    }\n\
    \    \n    return $sum if $count;\n    return 0;\n}", "    my $sum = 0;\n    for\
    \ (@$lst) {\n        if ($_ % 3 == 0) {\n            $_ *= 2;\n        }\n   \
    \     else {\n            $_ *= 3;\n        }\n        $sum += $_;\n    }\n  \
    \  return $sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nUsing map and\
    \ grep\n<code>", "    return map { $lst[$_] * $lst[$_] } 0..@$lst-1 if @$lst >\
    \ 0;\n    return $lst[0];\n}", "    return grep { ($_ % 3 != 0 && $_ % 4 != 0)\
    \ } map { $_ * $_ } (@{$lst});\n}", "    my($sum);\n    foreach $idx (@$lst) {\n\
    \        if ($idx % 3 == 0) {\n            $sum += $idx ** 2;\n        }\n   \
    \     elsif ($idx % 4 == 0) {\n            $sum += $idx ** 3;\n        }\n   \
    \     else {\n            $sum += $idx;\n        }\n    }\n    return $sum;\n}",
  "    my $sum = 0;\n    for (my $i=0; $i<@$lst; $i++) {\n        next if ($lst->[$i]\
    \ % 3) == 0;\n        next if ($lst->[$i] % 4) == 0;\n        $sum += $lst->[$i]\
    \ * $lst->[$i];\n    }\n    return $sum;\n}", "    my $sum = 0;\n    foreach my\
    \ $index (0..$#{$lst}) {\n        if($index%3 != 0){\n            $sum += $lst->[$index]*$lst->[$index];\n\
    \        }\n        if($index%4 != 0){\n            $sum += $lst->[$index]*$lst->[$index]*$lst->[$index];\n\
    \        }\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for (@$lst) {\n\
    \        if ($_ & 3) {\n            $_ *= $_;\n        }\n        if ($_ & 4)\
    \ {\n            $_ *= $_;\n        }\n        $sum += $_;\n    }\n    return\
    \ $sum;\n}", "    my @new_lst;\n    for(my $idx = 0; $idx < @$lst; $idx++) {\n\
    \        if($idx % 3 == 0 || $idx % 4 == 0) {\n            push(@new_lst,$idx*$idx);\n\
    \        }\n        else {\n            push(@new_lst,$idx);\n        }\n    }\n\
    \    return $new_lst;\n}", "    my $sum_arr;\n    for (@$lst) {\n        if ($_\
    \ % 3 == 0) {\n            $sum_arr += $_ * $_;\n        }\n        if ($_ % 4\
    \ == 0) {\n            $sum_arr += $_ * $_ * $_;\n        }\n        if ($_ %\
    \ 3 != 0 || $_ % 4 != 0) {\n            $sum_arr += $_;\n        }\n    }\n  \
    \  $sum_arr;\n}", "    my $total = 0;\n    for my $index (0..$#lst) {\n      \
    \  if ($index / 3 == $index % 4) {\n            $lst[$index] .= $lst[$index];\n\
    \        } elsif ($index / 4 == $index % 3) {\n            $lst[$index] .= $lst[$index];\n\
    \        } else {\n            $total += $lst[$index];\n        }\n    }\n   \
    \ return $total;\n}", "    my @sum;\n    foreach my $l (@$lst) {\n        if ($l\
    \ % 3 == 0) {\n            push(@sum, ($l * $l));\n        }\n        if ($l %\
    \ 4 == 0) {\n            push(@sum, ($l * $l));\n        }\n    }\n    return\
    \ $sum[0];\n}", "    my @sum;\n    for (my $i=0; $i < @$lst; $i++) {\n       \
    \ if ($i % 3 == 0) {\n            push(@sum, $lst->[$i] * $lst->[$i]);\n     \
    \   }\n        elsif ($i % 4 == 0) {\n            push(@sum, $lst->[$i] * $lst->[$i]\
    \ * $lst->[$i]);\n        }\n        else {\n            push(@sum, $lst->[$i]);\n\
    \        }\n    }\n    return @sum;\n}\n</cell>\n<cell>\ndef sub_reverse_twice(lst):\n\
    \    \"\"\"\n    This function should take an array of integers and return the\
    \ same array, but in reverse order as given. \n    That is, for the array [1,\
    \ 2, 3], the function should return [3, 2, 1].\n    \n    >>> lst\n    [1, 2,\
    \ 3, 4]\n    >>> lst\n    [5, 4, 3, 2]\n    >>> lst\n    []\n    >>> lst\n   \
    \ [-1, -5, 2, -1, -5]\n    \"\"\"\n    lst = list(lst)\n    lst.reverse()\n  \
    \  return lst", "    my @return = ();\n    for my $index (0..($#lst + 1)) {\n\
    \        push(@return, \n            $index%3 ? $index*$index :\n            $index%4\
    \ ? $index*$index*$index :\n            $index + $index);\n    }\n    return @return;\n\
    }", "    return 0 if !@$lst;\n    my $sum;\n    foreach my $index ( 0 .. $#{$lst}\
    \ ) {\n        my $elem = $lst->[$index];\n        if ( $index == 0 ) {\n    \
    \        $sum = $elem;\n            next;\n        }\n        next if $index %\
    \ 3;\n        next if $index % 4;\n        $sum = $sum + $elem;\n    }\n    return\
    \ $sum;\n}", "    $sum = 0;\n    foreach $i (0..$#lst) {\n        if ($i%3 !=\
    \ 0) {\n            $sum += $lst[$i]*$lst[$i];\n        }\n        if ($i%4 !=\
    \ 0) {\n            $sum += $lst[$i]*$lst[$i]*$lst[$i];\n        }\n    }\n  \
    \  return $sum;\n}", "    my @result = ();\n    my($sum) = 0;\n    foreach my\
    \ $i(@$lst) {\n        if ($i % 3 == 0) {\n            $sum += $i;\n        }\n\
    \        elsif ($i % 4 == 0) {\n            $sum += $i;\n        }\n        elsif\
    \ ($i % 3 == 0 && $i % 4 == 0) {\n            $sum += $i;\n        }\n       \
    \ else {\n            push @result, $sum;\n            $sum = 0;\n        }\n\
    \    }\n    push @result, $sum;\n    return @result;\n}\n</code>\nI tried to show\
    \ that this function has the same functionality as the function posted in the\
    \ question.\n<|/ a tags=perl,arrays dscore=1 |>\n<| c |>\nI thought about this\
    \ question when I wrote my answer, and I agree with you. But I think it is more\
    \ useful to write an answer that explains how to solve the problem the OP mentions,\
    \ rather than to give the answer that does what the OP asked for and is a lot\
    \ more complex than the code that they already have.\n<|/ c |>\n<| c |>\n, I am\
    \ aware of that, thank you. However, I am not posting the answer because I thought\
    \ the explanation I provide in the answer would be enough to explain how to solve\
    \ the problem the OP mentions.\n<|/ c |>\n<| c |>\nHe wrote that he wants to sum\
    \ all the even numbers in his array. Your answer gives an explanation for how\
    \ to do it when there are an even number of items in the array. I think it would\
    \ be better if you wrote an explanation for how to do it when there are an odd\
    \ number of items in the array, and maybe explained that in your answer.\n<|/\
    \ c |>\n<| c |>\n, the function he posted in the question does what I just described.\
    \ `Sum the entries in a list where their indexes are a multiple of 3 and 4` What\
    \ more information are you looking for in the explanation I provide?\n<|/ c |>\n\
    <| c |>\nI mean, your function does what he said. He also says his function should\
    \ \"not change the entries in the array whose indexes are not a multiple of 3\
    \ or 4\". Your function leaves the array unchanged, so it's not what he asked\
    \ for. If I were to ask the OP what he asked for, I would say the function he\
    \ wrote should change the entries in the array whose indexes are not a multiple\
    \ of 3 or 4 if they are even. Your function leaves the array unchanged, so it's\
    \ not what he asked for.\n<|/ c |>\n<| a dscore=1 |>\nHere is an alternative solution:\n\
    <code>", "    my $sum = 0;\n    for (@$lst) {\n        if ($_ % 3 == 0) {\n  \
    \          $sum += $_;\n        } elsif ($_ % 4 == 0) {\n            $sum += $_\
    \ * 3;\n        } else {\n            $sum += $_ * 4;\n        }\n    }\n    return\
    \ $sum;\n}", "    my $total = 0;\n    for(my $i=0; $i < @$lst; $i++) {\n     \
    \   if ($i % 3 == 0) {\n            ($total * $lst->[$i]) + $lst->[$i];\n    \
    \    } elsif ($i % 4 == 0) {\n            $lst->[$i] * $lst->[$i];\n        }\
    \ elsif ($lst->[$i] % 3 == 0) {\n            $lst->[$i] * $lst->[$i];\n      \
    \  } elsif ($lst->[$i] % 4 == 0) {\n            $lst->[$i] * $lst->[$i];\n   \
    \     }\n    }\n    return $total;\n}", "    my;\n    my $sum_of_all = 0;\n  \
    \  foreach my $entry (@$lst){\n        if ($entry % 3 == 0 || $entry % 4 == 0){\n\
    \            $sum_of_all += $entry;\n        }\n        elsif ($entry % 3 != 0){\n\
    \            $sum_of_all += $entry * $entry;\n        }\n        elsif ($entry\
    \ % 4 != 0){\n            $sum_of_all += $entry * $entry;\n        }\n       \
    \ else {\n            push, $entry;\n        }\n    }\n    return $sum_of_all;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "    \n    foreach my\
    \ $i (@$lst) {\n        if ($i && (($i % 3) == 0 || ($i % 4) == 0)) {\n      \
    \      $lst[$i] = $i * $i;\n        }\n    }\n    \n    return $lst;\n}\n1\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not correct. Your function will return the sum of all\
    \ integers, not sum of all squares.\n<|/ c |>\n<| c |>\nHow so? The original question\
    \ says, \"The function shall then return the sum of all entries\" which includes\
    \ all entries.\n<|/ c |>\n<| c |>\nYou're right, I misinterpreted that part. I\
    \ thought that he wanted the sum of the squares.\n<|/ c |>\n<| c |>\nI actually\
    \ want the sum of the squares. I was just curious as to how this could be done\
    \ in perl. My original approach was a brute force solution that required O(N^2)\
    \ operations (i.e. N for loops and a nested for loop to do the squaring). Your\
    \ solution however only requires O(N). Again I appreciate the help.\n<|/ c |>\n\
    <| c |>\nThis is not correct. It returns the sum of all the squares, not of the\
    \ sum of the entries.\n<|/ c |>\n<| a dscore=1 |>\nUsing recursion:\n<code>",
  "    my $sum = 0;\n    for (@$lst) {\n        if (index($_, 'mod') == 0) {\n   \
    \         $sum = $sum + $_;\n        }\n        if (index($_, 'mod') == 1) {\n\
    \            $sum = $sum + $_ * $_;\n        }\n        if (index($_, 'mod') ==\
    \ 2) {\n            $sum = $sum + $_ * $_ * $_;\n        }\n        if (index($_,\
    \ 'mod') == 3) {\n            $sum = $sum + $_ * $_ * $_ * $_;\n        }\n  \
    \      if (index($_, 'mod') == 4) {\n            $sum = $sum + $_ * $_ * $_ *\
    \ $_ * $_;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=perl,perl-data-structures\
    \ |>\n<| a |>\n<code>", "    my $sum = 0;\n    foreach my $i (@$lst) {\n     \
    \   if ($i % 3 == 0) {\n            $sum = $sum + $i * $i;\n        }\n      \
    \  elsif ($i % 4 == 0) {\n            $sum = $sum + $i * $i;\n        }\n    \
    \    else {\n            $sum = $sum + $i;\n        }\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is an extremely inefficient way to squaring\
    \ a list. Perl has a built-in `map` function which will do this much faster: `map\
    \ {$_ * $_} @$lst`\n<|/ c |>\n<| a tags=perl |>\nA solution using map.\n<code>\n\
    my $sumOfSquares=sub { \n    my = map {$_*$_};\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=perl |>\nUsing a for loop:\n<code>", "    my @result;\n\
    \    for my $i(@$lst) {\n        my $square = $i % 3 == 0 ? $i * $i : $i;\n  \
    \      my $cube = $i % 4 == 0 ? $i * $i : $i;\n        if ($square != $cube) {\n\
    \            $lst[$i] = $square;\n        }\n    }\n    my $sum_of_all_elements\
    \ = $lst[0];\n    for my $i(1 .. @$lst) {\n        $sum_of_all_elements += $lst[$i];\n\
    \    }\n    return $sum_of_all_elements;\n}", '    my @sums;', "    my(@square_lst);\n\
    \    my(@cube_lst);\n    my(@sum_lst);\n    \n    foreach my $i (0 .. $#lst) {\n\
    \        chomp($i = $lst[$i]);\n        \n        if ($i && $i%3 == 0) {\n   \
    \         $square_lst .= \"$i^2\\n\";\n        } elsif ($i && $i%4 == 0) {\n \
    \           $cube_lst .= \"$i^3\\n\";\n        } else {\n            $sum_lst\
    \ .= \"$i\\n\";\n        }\n    }\n    \n    if ($#square_lst) {\n        $sum_lst\
    \ = $square_lst + $cube_lst;\n    }\n    \n    return $sum_lst;\n}", "    my $sum\
    \ = 0;\n    for my $i (0 .. $#lst) {\n        if ($i % 3 == 0) {\n           \
    \ $sum += $lst[$i] * $lst[$i];\n        } elsif ($i % 4 == 0) {\n            $sum\
    \ += $lst[$i] * $lst[$i] * $lst[$i];\n        }\n    }\n    return $sum;\n}",
  "    my @sum_of_squares; \n    for (my $i=0; $i < @$lst; $i++) {\n        if ($i\
    \ % 3 == 0) {\n            push(@sum_of_squares, @$lst[$i]*$lst[$i]);\n      \
    \  } elsif ($i % 4 == 0) {\n            push(@sum_of_squares, @$lst[$i]*$lst[$i]);\n\
    \        } else {\n            push(@sum_of_squares, @$lst[$i]);\n        }\n\
    \    }\n    return @sum_of_squares;\n}\n</code>\n<|/ a tags=perl,arrays,indexing\
    \ |>\n<| c |>\nThis doesn't work when the list contains all 0's as the first element.\
    \ For example, `@a = ([0,1,0,0],[0,1,0,0],[0,1,0,0])` returns `0` instead of `[0,0,0,0,0]`.\n\
    <|/ c |>\n<| c |>\nIt shouldn't. Try it with my code from above. `@a = [0,1,0,0];\
    \ print sum_squares(@a), \"\\n\"` gives me `0` as expected. `@a = [0,0,0]; print\
    \ sum_squares(@a), \"\\n\"` gives `[0,0,0,0,0]` as expected.\n<|/ c |>\n<| c |>\n\
    Hmm, that works for me as well, thanks for clarifying.\n<|/ c |>\n<| c |>\nI guess\
    \ `0 x 0 == 0` returns `[0]`?\n<|/ c |>\n<| c |>\n: Why shouldn't it? `0 x 0`\
    \ returns `[0]` even if the input is `[0, 0, 0]`.\n<|/ c |>\n<| a tags=perl,arrays,indexing\
    \ |>\nI suspect the problem is in the way you are invoking your subroutines. \
    \ What I suspect is happening is your array is being passed as a single scalar\
    \ to the subroutine instead of the array you want.  For example, you should be\
    \ doing something like:\n<code>\nmy $list = [ 1, 2, 3, 4 ];\nmy;\npush, sum_squares($list);\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nNo, passing the list like that won't work.\
    \ I think you need `@sum = sum_squares($list);`\n<|/ c |>\n<| a tags=perl,arrays,indexing\
    \ |>\n<code>", "    my @ans = ();\n    for(my $i=0;$i<=$#lst;$i++) {\n       \
    \ if($i && $lst[$i] % 3 != 0) {\n            $ans[$i] = $lst[$i] * $lst[$i];\n\
    \        }\n        elsif($i && $lst[$i] % 4 != 0) {\n            $ans[$i] = $lst[$i]\
    \ * $lst[$i];\n        }\n        else {\n            $ans[$i] = $lst[$i];\n \
    \       }\n    }\n    my $sum = $ans[0];\n    for(my $i=1;$i<$#ans;$i++) {\n \
    \       $sum += $ans[$i];\n    }\n    return $sum;\n}", '    my ($index, $sum,
    $temp);', "    my $sum = 0;\n    foreach my $i (0 .. $#$lst) {\n        my $j\
    \ = ($i % 3) * $i;\n        my $k = ($i % 4) * $i;\n        $sum += $lst[$i] unless\
    \ $j == $k;\n    }\n    return $sum;\n}", "    my @sums = ();\n    foreach my\
    \ $num (@$lst) {\n        if ($num % 3 == 0 || $num % 4 == 0 && $num != ($num\
    \ % 3)) {\n            push(@sums, $num * $num);\n        } elsif ($num % 4 !=\
    \ 0 && $num != ($num % 4)) {\n            push(@sums, $num * $num);\n        }\
    \ else {\n            push(@sums, $num);\n        }\n    }\n    return $sums[0];\n\
    }\n</cell>\n<text>\nExercise 8\nWrite a subroutine that takes an array of integers\
    \ as its argument. Print the sum of the squares of the entries of the array whose\
    \ indexes are multiples of 3 or\n4. To test your code, write a function that generates\
    \ an array of integers, using Perl\u2019s range function.", "    my (@res)=();\n\
    \    for my $idx (0 .. $#lst) {\n        push(@res, $lst[$idx] if ($idx % 3 ==\
    \ 0) && ($idx % 4 == 0));\n        push(@res, $lst[$idx] if ($idx % 3 == 0) &&\
    \ ($idx % 4 == 1));\n        push(@res, $lst[$idx] if ($idx % 3 == 0) && ($idx\
    \ % 4 == 2));\n        push(@res, $lst[$idx] if ($idx % 3 == 1) && ($idx % 4 ==\
    \ 0));\n        push(@res, $lst[$idx] if ($idx % 3 == 1) && ($idx % 4 == 1));\n\
    \        push(@res, $lst[$idx] if ($idx % 3 == 1) && ($idx % 4 == 2));\n     \
    \   push(@res, $lst[$idx] if ($idx % 3 == 2) && ($idx % 4 == 0));\n        push(@res,\
    \ $lst[$idx] if ($idx % 3 == 2) && ($idx % 4 == 1));\n        push(@res, $lst[$idx]\
    \ if ($idx % 3 == 2) && ($idx % 4 == 2));\n    }\n    return @res;\n}", "    return\
    \ $lst->[0] if $lst->[0];\n    my @sums = map { my $i = $_; $i*$i } 0..@{$lst}[0]-1;\n\
    \    @sums > 2 ? (@sums[0..2]+@sums[3..5] ) : @sums[0..2] \n}", "    my @sum_arr;\n\
    \    my @temp_arr;\n    my $sum = 0;\n    # Loop through each element\n    for\
    \ my $elem (@$lst) {\n        if ($elem % 3 == 0) {\n            $sum = $sum +\
    \ $elem**2;\n        }\n        else {\n            $sum = $sum + $elem**3;\n\
    \        }\n    }\n    $sum;\n}", "    return grep(/^(\\-?\\d+)$/, @$lst)\n  \
    \              ? map { $_ * $_ }\n                : [];\n}", "    my@lst = @$lst;\n\
    \    my $sum = 0;\n    foreach my $index (0 .. @lst-1 ) {\n        if ($index\
    \ % 3 == 0) {\n            $sum = $sum + $lst[$index] * $lst[$index] * $lst[$index];\n\
    \        } elsif ($index % 4 == 0 && $index % 3 != 0) {\n            $sum = $sum\
    \ + $lst[$index] * $lst[$index] * $lst[$index];\n        }\n    }\n    return\
    \ $sum;\n}", "    my @out;\n    foreach my $i (@$lst) {\n        if ($i%3 != 0)\
    \ {\n            $out[$i] = $i*$i;\n        }\n        elsif ($i%4 != 0) {\n \
    \           $out[$i] = $i*$i*$i;\n        }\n        else {\n            $out[$i]\
    \ = 0;\n        }\n    }\n    return $out[0];\n}", "    my @res;\n    my $sum\
    \ = 0;\n    foreach my $val (@{$lst}) {\n        if($val % 3 == 0) {\n       \
    \     $val = $val * $val;\n        }\n        elsif($val % 4 == 0) {\n       \
    \     $val = $val * $val;\n        }\n        else {\n            $sum += $val;\n\
    \        }\n        push(@res, $sum);\n    }\n    return $sum;\n}\n</code>\n<|/\
    \ a tags=perl,function,arrays,indexing |>\n<| a tags=perl,function,arrays,indexing\
    \ |>\n<code>", "    my $sum = 0;\n    foreach my $num (@$lst) {\n        if($num\
    \ % 3 == 0) {\n            $sum+=$num;\n        } elsif ($num % 4 == 0) {\n  \
    \          $sum+=$num;\n        } else {\n            $sum+=$num*$num;\n     \
    \   }\n    }\n    return $sum;\n}\n</code>\nAnd here are some test cases:\n<code>\n\
    use Test::More tests => 4;", "    my $s = 0;\n    my @result;", "    my(@square);\n\
    \    my(@cube);\n    foreach $i (0 .. $#lst) {\n        if ($i % 3 == 0) {\n \
    \           push(@square, $lst[$i] * $lst[$i]);\n        } elsif ($i % 4 == 0)\
    \ {\n            push(@cube, $lst[$i] * $lst[$i] * $lst[$i]);\n        } else\
    \ {\n            push(@square, $lst[$i]);\n        }\n    }\n    return @{square}\
    \ + @{cube};\n}", "    $lst = map {$_ ** 2 if $_ % 3 == 0; $_ ** 3 if $_ % 4 ==\
    \ 0; $_} @$lst;\n    my $sum = 0;\n    foreach (@$lst) { $sum += $_ }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n        if ($num\
    \ % 3 == 0) {\n            $sum = $sum + $num * $num;\n        }\n        elsif\
    \ ($num % 4 == 0) {\n            $sum = $sum + $num * $num;\n        }\n    }\n\
    \    return $sum;\n}\n</code>\nThe main problem with this is that you have to\
    \ iterate over the entire array and that makes it O(n) instead of O(n). You can\
    \ solve that by using the map function, but that would just make it O(n^2) instead\
    \ of O(n).\n<code>", "    my(@sum, $n) =;\n    my $i = 0;\n    while (@sum) {\n\
    \        my $n = $sum[$i];\n        my $ismultiple = ($i%4 == 0);\n        if\
    \ ($ismultiple) {\n            $n *= $n;\n        }\n        elsif ($i%3 == 0)\
    \ {\n            $n *= $n;\n        }\n        $sum[$i] = $n;\n        $i++;\n\
    \    }\n    $sum[0];\n}", "    my$total = 0;\n    foreach $idx (@$lst) {\n   \
    \     if ($idx % 3 == 0) {\n            $total *= $idx;\n        } elsif ($idx\
    \ % 4 == 0) {\n            $total *= $idx;\n        } else {\n            $total\
    \ += $idx;\n        }\n    }\n    return $total;\n}", "    my($sum) = 0;\n   \
    \ foreach my $i (@$lst) {\n        $sum += $i * $i; \n    }\n    return $sum;\n\
    }\n</code>\n<|/ q |>\n<| c |>\nYour sample input and expected output don't match\
    \ each other - `sum squared not multiple of 3` -> `sum not multiple of 3` and\
    \ `sum not multiple of 4`, but `sum not multiple of 3` -> `sum not multiple of\
    \ 4`.\n<|/ c |>\n<| c |>\nYeah sorry fixed it now.\n<|/ c |>\n<| c |>\nI updated\
    \ the question. It was just a typo.\n<|/ c |>\n<| c |>\nYou still have `sum` but\
    \ you said you wanted `sum_squared`, which is it?\n<|/ c |>\n<| c |>\nSorry my\
    \ bad. I fixed that now.\n<|/ c |>\n<| a dscore=2 |>\nHere's a brute force approach:\n\
    <code>", "    my(@sums) = ();\n    for (@$lst) { \n        if ($_ & 3) { \n  \
    \          $_ >> 3 | 3; \n        }\n        if ($_ & 4) { \n            $_ >>\
    \ 4 | 4; \n        }\n        push (@sums, $_);\n    }\n    return $sums;\n}",
  "    my @sum;\n    \n    for my $i (0 .. $#$lst) {\n        if ($i % 3 == 0) {\n\
    \            push(@sum, $lst[$i] * $lst[$i]);\n        }\n        elsif ($i %\
    \ 4 == 0) {\n            push(@sum, $lst[$i] * $lst[$i] * $lst[$i]);\n       \
    \ }\n        else {\n            push(@sum, $lst[$i]);\n        }\n    }\n   \
    \ \n    return $sum;\n}", "    my $sum = 0;\n    for (@$lst) {\n        my $entry\
    \ = $_;\n        if ($entry == -1) {\n            $entry = -4;\n        }\n  \
    \      if ($entry % 3 == 0) {\n            $entry *= $entry;\n        }\n    \
    \    if ($entry % 4 == 0) {\n            $entry *= $entry;\n        }\n      \
    \  $sum += $entry;\n    }\n    return $sum;\n}", '    my($sum) = 0;', "    $lst\
    \ = grep {defined $lst->[$_]} 0..$#lst;\n    $total = 0;\n    for my $idx (@$lst)\
    \ {\n        if ($idx % 3 == 0) {\n            $total = $total + $idx;\n     \
    \   }\n        elsif ($idx % 4 == 0) {\n            $total = $total + $idx;\n\
    \        }\n        else {\n            $total = $total + $idx * $idx;\n     \
    \   }\n    }\n    $total;\n}\n</code>\n<|/ a tags=perl dscore=1 |>\n<| a |>\n\
    <code>", "    my $sum = 0;\n    foreach my $i (0..$#{$lst}) {\n        if($i %\
    \ 3 == 0) {\n            $sum+=$lst->[$i]*$lst->[$i];\n        }elsif($i % 4 ==\
    \ 0 && $lst->[$i] % 4 != 0) {\n            $sum+=$lst->[$i]*$lst->[$i];\n    \
    \    }elsif($i % 3 != 0 && $lst->[$i] % 3 == 0) {\n            $sum+=$lst->[$i]*$lst->[$i];\n\
    \        }\n    }\n    return $sum;\n}", "    $lst = [$lst] unless ref $lst;\n\
    \    my @sums;\n    for my $i (0 .. @$lst - 1) {\n        if ($i % 3 == 0) {\n\
    \            $sums[$i] .= $lst->[$i] * $lst->[$i];\n        }\n        elsif ($i\
    \ % 4 == 0) {\n            $sums[$i] .= $lst->[$i] * $lst->[$i] * $lst->[$i];\n\
    \        }\n        else {\n            $sums[$i] += $lst->[$i];\n        }\n\
    \    }\n    return $sums[0];\n}\n</code>\n<|/ a |>\n<| c |>\nNice, thanks for\
    \ the additional comments.\n<|/ c |>\n<| c |>\n+1: This is the same answer as\
    \ mine, but with better formatting, comments, etc.\n<|/ c |>\n<| c |>\n: Thanks,\
    \ I've added the formatting, comments, and a link to the original post.\n<|/ c\
    \ |>\n<| c |>\n: Thanks. I figured it was worth mentioning, as I noticed a lot\
    \ of people are unfamiliar with the syntax of a `for` loop, or how to loop over\
    \ lists in Perl, and that's why I used a comment to give them some clarity.\n\
    <|/ c |>\n<| c |>\n: You're right, `perlcritic` complains about that `for` loop\
    \ too. Thanks for pointing that out too.\n<|/ c |>\n<| a tags=perl,arrays |>\n\
    Your code should look something like this:\n<code>", "    $lst == [] or return()\
    \ if scalar @$lst < 1;\n    my @res;\n    foreach my $i (@$lst) {\n        $i**2\
    \ unless (($i % 3) == 0 or $i % 4 == 0);\n        push(@res, $i)\n    }\n    $res[0]\
    \ if scalar @res == 0;\n    return sum(@res);\n}", "    my $total = 0;\n    for\
    \ (@$lst) {\n\t$total += $_ * $_;\n    }\n    return $total;\n}", "    my $total\
    \ = 0;\n    \n    foreach my $i (@$lst) {\n        if ($i & 3) {\n           \
    \ $total *= $i;\n        } elsif ($i & 4) {\n            $total *= $i;\n     \
    \   } else {\n            $total += $i;\n        }\n    }", "    my $sum_of_squares\
    \ = 0;\n    for (@$lst) {\n        if ($_ % 3 == 0) {\n            $_ *= $_;\n\
    \        }\n        elsif ($_ % 4 == 0) {\n            $_ *= $_;\n        }\n\
    \        else {\n            $sum_of_squares += $_;\n        }\n    }\n    return\
    \ $sum_of_squares;\n}", "    my ($i, $sum, $tmp);\n    $sum = 0;\n    foreach\
    \ $i (@$lst) {\n        $tmp = ($i & 1) ? $i * $i : $i * $i * $i;\n        $sum\
    \ += $tmp;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    my = grep { $_\
    \ !~ / 3 / and $_ !~ / 4 /};\n    foreach my $val (@lst) {\n        $sum += $val\
    \ * $val;\n    }\n    return $sum;\n}", "    my ($n);\n    my $sum = 0;\n    if\
    \ (@{$lst}) {\n        foreach $n (@{$lst}) {\n            $sum += ($n % 3) ?\
    \ ($n * $n) : ($n * $n * $n);\n        }\n    }\n    return $sum;\n}", "    my\
    \ $sum = 0;\n    for(my $i=0; $i<@$lst; $i++) {\n        $sum += $lst->[$i] if\
    \ $i % 3 == 0;\n        $sum += $lst->[$i] if $i % 4 == 0;\n    }\n    return\
    \ $sum;\n}", "    my $result = 0;\n    for my $i ( 0 .. @$lst ) {\n        if(\
    \ $i % 3 == 0 ) {\n            $result += $lst[$i] * $lst[$i] * $lst[$i];\n  \
    \      } elsif( $i % 4 == 0 ) {\n            $result += $lst[$i] * $lst[$i] *\
    \ $lst[$i] * $lst[$i];\n        } else {\n            $result += $lst[$i];\n \
    \       }\n    }\n    return $result;\n}", "    my $sum = 0;\n    for my $idx\
    \ (0 .. $#lst) {\n        if ($idx % 3 == 0) {\n            $sum += $lst[$idx]\
    \ * $lst[$idx];\n        } elsif ($idx % 4 == 0) {\n            $sum += $lst[$idx]\
    \ * $lst[$idx];\n        } else {\n            $sum += $lst[$idx];\n        }\n\
    \    }\n    return $sum;\n}", "    return @$lst if @$lst == 0;\n    my($sum) =\
    \ 0;\n    foreach my $i (@$lst) {\n        push (@$sum, $i*$i*$i) if $i%3 != 0;\n\
    \        push (@$sum, $i*$i*$i) if $i%4 != 0;\n    }\n    return $sum;\n}\n</code>\n\
    The program will then run\n<code>\n$ perl program.pl\n</code>\nand display the\
    \ result as desired", "    my ($sum) = 0;\n    foreach (@$lst) {\n        if ($i\
    \ % 3 == 0) {\n            $sum += $i * $i;\n        }\n        elsif ($i % 4\
    \ == 0) {\n            $sum += $i * $i;\n        }\n        elsif ($i % 4 != 0\
    \ && $i % 3 != 0) {\n            $sum += $i * $i;\n        }\n    }\n    return\
    \ $sum;\n}", "    my(@newlst);\n    my($sum, @indexes);\n    my($i);\n    \n \
    \   @indexes = grep { ($_ % 3) == 0 } @$lst;\n    if (@indexes) {\n        for\
    \ $i (@indexes) {\n            $sum += $lst[$i] * $lst[$i];\n        }\n    }\
    \ else {\n        $sum = 0;\n    }\n    \n    @newlst = @$lst;\n    for $i (@newlst)\
    \ {\n        $sum -= $lst[$i] if $i % 3 == 0;\n        $sum -= $lst[$i] if $i\
    \ % 4 == 0;\n        $sum += $lst[$i];\n    }\n    \n    return $sum;\n}", " \
    \   my($ret);\n    for my $i (0 .. $#$lst) {\n        if ($i % 3 == 0) {\n   \
    \         $ret += $lst[$i] * $lst[$i] * $lst[$i];\n        } elsif ($i % 4 ==\
    \ 0) {\n            $ret += $lst[$i] * $lst[$i] * $lst[$i] * $lst[$i];\n     \
    \   } else {\n            $ret += $lst[$i];\n        }\n    }\n    return $ret;\n\
    }", "    my @sum = 0;\n    foreach my $num (@$lst) {\n        push (@sum, (($num\
    \ % 4 == 0) ? $num ** 2 : (($num % 3 == 0) ? $num ** 3 : $num ** 4)));\n    }\n\
    \    return $sum[0];\n}\n</code>\nThis can be called in the following way:\n<code>\n\
    print sum(&square);\n</code>\n<|/ a |>\n<| c |>\n`&square -> ARRAY(0x1033d040)`\
    \ will break your code\n<|/ c |>\n<| c |>\n: No, `square` is not an array, but\
    \ a `CODE` object which can be used as such. Which is why I wrote `&square`.\n\
    <|/ c |>\n<| c |>\nYes, sorry, i see now\n<|/ c |>\n<| a |>\nPerl is really easy\n\
    <code>", "    my($sum);\n    foreach $x (@$lst) {\n        if (($x % 3 == 0) or\
    \ ($x % 4 == 0)) {\n            $sum += $x * $x;\n        } else {\n         \
    \   $sum += $x;\n        }\n    }\n    return $sum;\n}", "    my(@result) = ();\n\
    \    foreach $l (@$lst) {\n        if ($l % 3 == 0) {\n            $l = ($l *\
    \ $l);\n        } elsif ($l % 4 == 0) {\n            $l = ($l * $l);\n       \
    \ } else {\n            push (@result, $l);\n        }\n    }\n    return @result;\n\
    }", "    \n    my @new;\n    \n    for (@$lst) {\n        push(@new, $_ * $_)\
    \ if $_ % 3 == 0;\n        push(@new, $_ * $_) if $_ % 4 == 0;\n        push(@new,\
    \ 0) if $_ == 0;\n    }\n    return sum(@new);\n}", "    my $result = 0;\n   \
    \ for (@$lst) {\n        $result += $_ unless $_ % 3 == 0 || $_ % 4 == 0;\n  \
    \      $result *= $_ unless $_ % 3 == 0;\n        $result *= $_ unless $_ % 4\
    \ == 0;\n    }\n    return $result;\n}", "    $lst = $_[$_] for 0..@$lst;\n  \
    \  return 0 + $lst[$_] if @$lst > 0;\n    return 0;\n}", "    \n    my $sum =\
    \ 0;\n    \n    for my $val (@$lst) {\n        my $mod = $val % 3;\n        \n\
    \        if ($mod > 0) {\n            $sum += $val*$val;\n        }\n        elsif\
    \ ($mod == 0) {\n            $sum += $val*$val;\n        }\n        elsif ($mod\
    \ == 1) {\n            $sum += $val*$val*$val;\n        }\n    }\n    \n    return\
    \ $sum;\n}", "    my(@sum);\n    for my $i (0..$#$lst) {\n        if ($lst[$i]\
    \ % 3 == 0) {\n            push(@sum, $lst[$i] * $lst[$i]);\n        } elsif ($lst[$i]\
    \ % 4 == 0) {\n            push(@sum, $lst[$i] * $lst[$i]);\n        } else {\n\
    \            push(@sum, $lst[$i]);\n        }\n    }\n    return @sum;\n}", " \
    \   return 0 unless $lst && @$lst;\n    $lst += () if $lst[-1] < 0;\n    return\
    \ map { $_ * $_ } (@$lst) if grep { (($_ % 3) == 0 || $_ % 4) == 0 } (@$lst);\n\
    \    return $lst;\n}\n__END__", "    my @new_list;\n    my($i,$j);\n    foreach\
    \ $i (@$lst) {\n        foreach $j (@$lst) {\n            next unless $j > $i;\n\
    \            push(@new_list, \"$i*$i\") if $i % 3 == 0 && $i % 4 == 0 && !($i\
    \ % 3);\n            push(@new_list, \"$j*$j\") if $j % 3 == 0 && $j % 4 == 0\
    \ && !($j % 3);\n        }\n    }\n    my $sum;\n    foreach $i (@new_list) {\n\
    \        $sum += eval($i);\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=arrays,perl,hashmap\
    \ dscore=0 |>\n<| c |>\nThanks for the answer, but I am not looking for code.\
    \ I can solve this problem on my own. I am trying to understand the logic. I am\
    \ not trying to solve this problem because I am curious to know where I am going\
    \ wrong.\n<|/ c |>\n<| c |>\nYou are right - I did not understand the question\
    \ correctly. Edited my answer.\n<|/ c |>\n<| c |>\nThanks, for the answer. Although\
    \ I accepted other answer as accepted, your answer also worked.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere's a solution using Hash::MultiValue (a core module for Perl\
    \ v5.8+ and later):\n<code>\nuse strict;\nuse warnings;\nuse Hash::MultiValue;",
  "    my $sum = 0;\n    foreach my $i (0 .. $#lst) {\n        if ($i % 3 != 0) {\n\
    \            $sum -= $lst[$i];\n        }\n        elsif ($i % 4 != 0) {\n   \
    \         $sum += $lst[$i];\n        }\n        else {\n            $sum -= $lst[$i]\
    \ * $lst[$i];\n        }\n    }\n    return $sum;\n}", "    my @sum;\n    for\
    \ (my $i = 0; $i < @$lst; $i += 2) {\n        push (@sum, $lst[$i] * $lst[$i +\
    \ 1]);\n    }\n    return @sum;\n}\n</code>\n<|/ a tags=arrays,perl,function dscore=0\
    \ |>\n<| c |>\nI love this solution, but I think it would be better to `use List::MoreUtils\
    \ 'pairwise'` instead of the `for` loop.\n<|/ c |>\n<| c |>\nI'm going to go with\
    \ this solution. Seems very straightforward and easy to understand.\n<|/ c |>\n\
    <| c |>\nYour solution is not correct, since it returns the sum of all elements\
    \ not just their squares\n<|/ c |>\n<| c |>\n, why do you think it isn't correct?\
    \ The question was how to do this, so it is the most straightforward answer I\
    \ can think of.\n<|/ c |>\n<| c |>\nIt doesn't answer the question, it returns\
    \ the sum of squares of all elements, not just their squares\n<|/ c |>\n<| a dscore=0\
    \ tags=arrays,perl,function |>\n<code>", "    my $sum;\n    foreach my $i(0 ..\
    \ @$lst - 1) {\n        my $n = $i % 3;\n        $sum += $n ? $lst[$i] * $lst[$i]\
    \ : $lst[$i];\n    }\n    return $sum;\n}", '    my @lst = @$lst;', '    my($sum)
    = 0;', "    my @output;\n    my $sum = 0;", "    my($sum) = 0;\n    # Loop through\
    \ all entries in the array and square the integers if they are a multiple of 3\
    \ and cube the integers \n    # that are a multiple of 4 and not a multiple of\
    \ 3\n    for my $i (0 .. @{$lst}) {\n        $sum += $lst[$i] if $lst[$i] % 3\
    \ == 0 || $lst[$i] % 4 == 0;\n    }\n    return $sum;\n}", "    my $sum = 0;\n\
    \    map {\n        if ($_ & 3) { $sum *= $_ }\n        if ($_ & 4) { $sum *=\
    \ $_ }\n        $sum += $_ \n    } @$lst;\n    return $sum;\n}\nprint \"6th example\
    \ in the book: \";\nprint sum_squares([-1, -5, 2, -1, -5]), \"\\n\"; \nprint \"\
    7th example in the book: \";\nprint sum_squares([-1, -5, 2, -1, -5, -6, -7, -8]),\
    \ \"\\n\";\n</code>\nI tested it and it gave the expected result:\n<code>\n6th\
    \ example in the book: -56\n7th example in the book: -56\n</code>\n<|/ a tags=arrays,perl\
    \ dscore=0 |>\n<| a dscore=0 |>\nAnother way of doing it without foreach is using\
    \ map function. \n<code>", "    my $sum = 0;\n    for (@$lst) {\n        my $square\
    \ = *($lst + 1);\n        my $cube = *($lst + 2);\n        if ($lst % 3 == 0)\
    \ {\n            $sum -= $square;\n        } elsif ($lst % 4 == 0 && $lst != 4)\
    \ {\n            $sum -= $cube;\n        }\n        $lst += 1;\n    }\n    return\
    \ $sum;\n}", "    my ($i, $sum);\n    for($i = 0, $#{$lst}; $i < $#{$lst}; $i++)\
    \ {\n        if( $i % 3 == 0 ) {\n            $sum += $lst->[$i] * $lst->[$i];\n\
    \        }\n        elsif( $i % 4 == 0 ) {\n            $sum += $lst->[$i] * $lst->[$i]\
    \ * $lst->[$i];\n        }\n        else {\n            $sum += $lst->[$i];\n\
    \        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=arrays,perl |>\n<|\
    \ a tags=arrays,perl dscore=0 |>\nHere is an even shorter solution using map instead\
    \ of foreach:\n<code>", "    my $res = 0;\n    foreach my $i (0..$#$lst) {\n \
    \       if($i % 3 == 0) {\n            $res += $lst->[$i] * $lst->[$i];\n    \
    \    } elsif($i % 4 == 0) {\n            $res += $lst->[$i] * $lst->[$i] * $lst->[$i];\n\
    \        } else {\n            $res += $lst->[$i];\n        }\n    }\n    return\
    \ $res;\n}", "    my $total = 0;\n    for (my $n = 0; $n < @$lst; $n++) {\n  \
    \      if ($n % 3 == 0) {\n            $total += $lst->[$n] * $lst->[$n];\n  \
    \      } elsif ($n % 4 == 0) {\n            $total += $lst->[$n] * $lst->[$n]\
    \ * $lst->[$n];\n        } else {\n            $total += $lst->[$n];\n       \
    \ }\n    }\n    return $total;\n}", "    my($sum);\n    \n    for my $index (\
    \ 0 .. $#{$lst} )\n    {\n        next if $index%3 != 0;\n        $sum += $index**2;\n\
    \    }\n    \n    for my $index ( 0 .. $#{$lst} )\n    {\n        next if $index%4\
    \ != 0;\n        $sum *= $index;\n    }\n    \n    return $sum;\n}\n</cell>\n\
    <text>\nNow let's test our sum_squares function.", '    my($sum);', "    \n  \
    \  my @sums;\n    foreach my $i (0 .. $#lst) {\n        if($i % 3 == 0 && $i %\
    \ 4 != 0) {\n            $sums[$i] = $lst[$i] * $lst[$i];\n        }\n       \
    \ if($i % 4 == 0) {\n            $sums[$i] = $lst[$i] * $lst[$i];\n        }\n\
    \    }\n    $sums[$#sums] = $sums[$#sums] + $lst[$#sums];\n    return @sums;\n\
    }\n</code>\nNow we can use this subroutine to solve the problem:\n<code>", " \
    \   my $sum = 0;\n    foreach my $num (@$lst) {\n        $sum = $sum + $num if\
    \ $num % 3 == 0 || $num % 4 == 0;\n    }\n    return $sum;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\n\"The function will take an array of integers. For all entries\
    \ in the array, the function shall square the integer entry if its index is a\
    \ multiple of 3 and will cube the integer entry if its index is a multiple of\
    \ 4 and not a multiple of 3.\" This doesn't do that - it squares it if it is not\
    \ a multiple of 3 and cubes it if it is not a multiple of 4. You have inverted\
    \ that logic.\n<|/ c |>\n<| c |>\nThanks for the catch. I'll edit it.\n<|/ c |>\n\
    <| c |>\nSaying \"the function will not change the entries in the array whose\
    \ indexes are not a multiple of 3 or 4\" is not the same as \"the function will\
    \ not change the entries in the array whose indexes are not a multiple of 3 and\
    \ **AND** if it is a multiple of 4\". And why would it change the entries in the\
    \ array whose indexes are not a multiple of 3 or 4?\n<|/ c |>\n<| c |>\nI meant\
    \ not change if the index is multiple of 3 or 4 AND if the index isn't a multiple\
    \ of 3. It's a little confusing to read. Fixed now.\n<|/ c |>\n<| c |>\nOkay,\
    \ now it is much clearer what you are trying to achieve. Now I see that you missed\
    \ the word \"OR\" in your original answer. My bad. I'll edit my answer now.\n\
    <|/ c |>\n<| a |>\nThe code you show doesn't seem to attempt to do anything useful.\
    \ Here's a version that tries to do something:\n<code>", "    my($sum) = 0;\n\
    \    my(@lst) = @_;\n    for(@lst){\n        if($_ & 3){\n            $sum = $sum\
    \ + $_;\n        }\n        if($_ & 4){\n            $sum = $sum + $_;\n     \
    \   }\n    }\n    return $sum;\n}\nprint \"Sum of squares of all entries of lst\
    \ is $sum_squares(lst)\\n\"; ", "    my($sum) = 0;\n    foreach my $i (@$lst)\
    \ {\n        if ($i%3 == 0) {\n            $sum = $sum + $i*$i;\n        }\n \
    \       if ($i%4 == 0) {\n            $sum = $sum + $i*$i*$i;\n        }\n   \
    \     if ($i%3 != 0 && $i%4 != 0) {\n            $sum = $sum + $i;\n        }\n\
    \    }\n    return $sum;\n}", "    my $sum = 0;\n    foreach my $index (@$lst)\
    \ {\n        if($index % 3 == 0) {\n            $index *= $index;\n        } elsif\
    \ ($index % 4 == 0) {\n            $index *= $index;\n        } else {\n     \
    \       $sum += $index;\n        }\n    }\n    return $sum;\n}", "    my $sum\
    \ = 0;\n    foreach my $n (@$lst) {\n        my $x = $n =~ s/^\\s*//;\n      \
    \  $x =~ s/\\s*$//;\n        chomp $x;\n        if ($x % 3 == 0) {\n         \
    \   $sum = $sum + $n*$n;\n        }\n        elsif ($x % 4 == 0) {\n         \
    \   $sum = $sum + $n*$n*$n;\n        }\n    }\n    return $sum;\n}", '    my;',
  "    my $sum = 0;\n    for my $num (@$lst) {\n        next if $num % 3 != 0 or $num\
    \ % 4 != 0;\n        my $newnum = $num * $num;\n        push (@$lst, $newnum);\n\
    \        $sum += $newnum;\n    }\n    $sum;\n}", "    my $sum = 0;\n    foreach\
    \ my $i (@$lst){\n        $sum += $i * $i;\n    }\n    return $sum;\n}", "   \
    \ my $sum = 0;\n    foreach my $i (0 .. @$lst) {\n        if ($i % 3 == 0) {\n\
    \            $sum = $sum + $i ** 2;\n        }\n        elsif ($i % 4 == 0 &&\
    \ $i %3 != 0) {\n            $sum = $sum + $i ** 3;\n        }\n        else {\n\
    \            $sum = $sum + $i;\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you very much for your answer, but it doesn't\
    \ work. Could you please run your program and check if it works?\n<|/ c |>\n<|\
    \ c |>\nI tested your program and it is working. Let me know if you have any questions\
    \ about the program. It returns `11` for my example.\n<|/ c |>\n<| c |>\nI tested\
    \ your program and it is working. Let me know if you have any questions about\
    \ the program. It returns `11` for my example.\n<|/ c |>\n<| c |>\nIf you feel\
    \ an answer solved the problem, please mark it as 'accepted' by clicking the green\
    \ check mark. This helps keep the focus on older SO which still don't have answers.\n\
    <|/ c |>\n<| a |>\nI have another solution for you, which is much shorter:\n<code>",
  "    my $sum = 0;\n    foreach my $index (0 .. $#$lst) {\n        if($index % 3\
    \ == 0){\n            $sum += $index**2;\n        }elsif($index % 4 == 0){\n \
    \           $sum += $index**3;\n        }else{\n            $sum += $index;\n\
    \        }\n    }\n    return $sum;\n}", "    my $sum;\n    for my $i (0..@$lst\
    \ - 1) {\n        if ($i % 3 == 0) {\n            $sum = $sum + $lst[$i] * $lst[$i]\
    \ * $lst[$i];\n        } elsif ($i % 4 == 0) {\n            $sum = $sum + $lst[$i]\
    \ * $lst[$i] * $lst[$i] * $lst[$i];\n        } else {\n            $sum = $sum\
    \ + $lst[$i];\n        }\n    }\n    return $sum;\n}", "    return $lst if @$lst\
    \ == 0;\n    my($result) = 0;\n    my($i, $j, $temp, $total);\n    foreach $i\
    \ (@$lst) {\n        $total = 0;\n        $j = @$lst - 1;\n        while ($j >\
    \ 0) {\n            $temp = @$lst - $j;\n            $total += $i * $temp;\n \
    \           $j -= 2;\n        }\n        $result += $total;\n    }\n    return\
    \ $result;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\n\"The function shall then\
    \ return the sum of all entries.\"", "    my $sum = 0;\n    for (0..$#$lst) {\n\
    \        my $index = $_;\n        if ($index % 3 == 0) {\n            $sum = $sum\
    \ + $index * $index;\n        } elsif ($index % 4 == 0) {\n            $sum =\
    \ $sum + $index * $index;\n        } else {\n            $sum = $sum + $index;\n\
    \        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=arrays,perl,loops\
    \ |>\n<| a dscore=0 |>\nI assume that all elements in the array are positive,\
    \ and that all negative elements are set to zero.\n<code>", "    my $sum = 0;\n\
    \    for (@$lst) {\n        $sum += $_ * $_ if ($_ % 3 == 0 || $_ % 4 == 0);\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThe goal is to help people\
    \ learning Perl, so they don't have to struggle with it. As for your question,\
    \ I can tell you it is the best Perl book I have read and I don't believe it is\
    \ as bad as your book. I don't like your comment about not wanting to learn Perl,\
    \ because I do want to learn, I just can't do that with my own time constraints\
    \ :-) Thanks though.\n<|/ c |>\n<| c |>\n: My comment was a general opinion (it\
    \ was not meant as a critique of your book) and I apologize if that came across\
    \ unappreciative. I would not call it a critique, just an observation that I have\
    \ learned best by reading books. Anyway, I updated my answer to include a solution\
    \ to your problem. Does it help?\n<|/ c |>\n<| c |>\nThanks for the helpful answer.\
    \ I am going to study this and give it a shot.\n<|/ c |>\n<| a |>\nI used a combination\
    \ of List::Util and Data::Dumper to solve the problem. \n<code>\nuse strict;\n\
    use Data::Dumper;\nuse List::Util qw(sum);", "    my @out;\n    foreach (@$lst)\
    \ {\n        if ($_ % 3 == 0) {\n            push @out, $_ * $_;\n        } elsif\
    \ ($_ % 4 == 0) {\n            push @out, $_ * $_ * $_;\n        } else {\n  \
    \          push @out, $_;\n        }\n    }\n    return $out;\n}\n</code>\nThis\
    \ is not the best solution to the problem; however, it gets the job done.\n<|/\
    \ a tags=perl,arrays,sum,integer |>\n<| c |>\nThanks for your answer. Your code\
    \ seems to be very close to the solution I want, but it's giving me the wrong\
    \ result. Can you have a look again and let me know where I'm going wrong?\n<|/\
    \ c |>\n<| c |>\nThe issue is that you are only looking at all numbers divisible\
    \ by 3. What you really need is to get numbers that divide evenly by 3. A prime\
    \ example is `10`, which can be divided evenly by 2 and 3. `12` can be divided\
    \ evenly by 3 and 5. But `15` cannot. You can see a prime number by finding all\
    \ numbers that are not divisible by 3 and are a power of two. The number you are\
    \ looking for is `15` which can be divided evenly by 3, 5 and 7.\n<|/ c |>\n<|\
    \ c |>\nIn your example you have an array of integers, not numbers. The array\
    \ is full of negative integers. Those are numbers that divide evenly by 3. The\
    \ numbers are `1, 3, 9, 25, 125`, not `-5, 2, -1, -5`.\n<|/ c |>\n<| c |>\nSorry\
    \ I forgot to add the list as an array in the question. Your answer does work\
    \ with the array (it gave the correct answer). I just ran my original code and\
    \ it gave the wrong answer. Could it be the way I'm calling the subroutine? I'm\
    \ using the call like so: sum_squares (@list);\n<|/ c |>\n<| c |>\nI edited my\
    \ answer to include a solution that will work for an array of numbers. Let me\
    \ know if that works for you.\n<|/ c |>\n<| a dscore=0 tags=perl,arrays,sum,integer\
    \ |>\nHere's one that uses map and grep:\n<code>", "    my @lst_copy = ();\n \
    \   foreach my $elem (@$lst) {\n        if ($elem % 3 == 0) {\n            $elem\
    \ = $elem ** 2;\n        } elsif ($elem % 4 == 0) {\n            $elem = $elem\
    \ ** 3;\n        }\n        push @lst_copy, $elem;\n    }\n    return @lst_copy;\n\
    }", "    $lst = [grep { $_ % 3 == 0 || $_ % 4 == 0 } @$lst];\n    my $sum = 0;\n\
    \    for(@$lst){\n        my $x = $_;\n        $sum += $x ** 2;\n    }\n    return\
    \ $sum;\n}\n</code>\nI hope this helps.\n<|/ a dscore=2 |>\n<| c |>\nYes, I believe\
    \ it does help to write code in the correct and idiomatic way. Thank you for that\
    \ answer!\n<|/ c |>\n<| c |>\nI love the code snippets but I think this answer\
    \ could be improved a bit by explaining how it works. That way it can benefit\
    \ future readers who want to learn.\n<|/ c |>\n<| a dscore=0 |>\nHere is a simple\
    \ solution.\n<code>", "    my @sum;\n    for(@$lst){\n        my $square = $_\
    \ if $_ % 3 == 0;\n        push @sum, $square if $_ % 4 == 0;\n    }\n    return\
    \ sum(@sum);\n}\n</cell>\n<cell>", "    my $sum = 0;\n    for my $ele (0..$#$lst)\
    \ {\n        my $x = $lst->[$ele];\n        if ($x % 3 == 0) {\n            $sum\
    \ += $x * $x;\n        }\n        if ($x % 4 == 0) {\n            $sum += $x *\
    \ $x;\n        }\n        else {\n            $sum += $x;\n        }\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat is too much code.\
    \ Try to reduce the code to the necessary subroutines and functions.\n<|/ c |>\n\
    <| a dscore=0 tags=perl |>\nThe answer by is the simplest one. However, I would\
    \ like to share with you the approach to understand how it works:\n<code>\nmy\
    \ $a = sum_squares ([1,2,3,4]);", "    return 0 if @$lst < 2;\n    $lst =~ s/^(-?\\\
    d+)//g;\n    my = grep { ((@$_ % 3) == 0) || ((@$_ % 4) == 0) } @$lst;\n    return\
    \ if @rem != 0;\n    $lst =~ s/^(-?\\d+)//g;\n    my = grep { ((@$_ % 3) == 0)\
    \ || ((@$_ % 4) == 0) } @$lst;\n    my $ret = 0;\n    for my $i (@ret) {\n   \
    \     $ret += $i ** 2;\n    }\n    return $ret;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nYou might want to check this out, it explains how to do an elegant algorithm\
    \ for a few different types of array https://codereview.stackexchange.com/questions/57764/sum-of-square-array\n\
    <|/ c |>\n<| a |>\nI have written a Perl solution using Perl's grep() function.\
    \ Perl solutions have two parts. One is reading the input data into the array.\
    \ The other is calculating the sum.\nBelow is an example of reading the input\
    \ data into the array.\n<code>\nuse strict;\nuse warnings;", "    my $s = 0;\n\
    \    for my $i (0..$#lst) {\n        my $x = $lst[$i];\n        if ($i%3 != 0)\
    \ {\n            $s += $x*$x;\n        } elsif ($i%4 != 0) {\n            $s +=\
    \ $x*$x*$x;\n        } else {\n            $s += $x;\n        }\n    }\n    return\
    \ $s;\n}", "    my @result;\n    my $cnt;\n    \n    for ($cnt = 1, $cnt < @$lst,\
    \ $cnt++) {\n        push(@result, $lst->[$cnt] ** 2);\n    }\n    \n    for ($cnt\
    \ = 0, $cnt < @$lst, $cnt++) {\n        if ($lst->[$cnt] % 3 == 0 && $lst->[$cnt]\
    \ % 4 == 0) {\n            push(@result, $lst->[$cnt]);\n        }\n    }\n  \
    \  \n    return sum(@result);\n}\n</code>\nAs a bonus, you can also use map()\
    \ to do this in one line.\n<code>", '    my @result;', "    my $sum = 0;\n   \
    \ for (@$lst) {\n        if ( (($_ % 3) == 0) && ((!($_ % 4)) ) ) {\n        \
    \    $sum += $_ * $_;\n        }\n    }\n    return $sum;\n}", "    my $sum =\
    \ 0;\n    for my $elem (@$lst) {\n        if ($elem->[0] % 3 != 0) {\n       \
    \     $elem->[0] = $elem->[0] * $elem->[0];\n        }\n        if ($elem->[0]\
    \ % 4 != 0) {\n            $elem->[0] = $elem->[0] * $elem->[0];\n        }\n\
    \        $sum += $elem->[0];\n    }\n    return $sum;\n}", "    my(@square);\n\
    \    for(my $i = 0; $i < @$lst; ++$i) {\n        if($i % 3 == 0) {\n         \
    \   push(@square, $lst->[$i] * $lst->[$i]);\n        } else {\n            push(@square,\
    \ $lst->[$i] * $lst->[$i] * $lst->[$i]);\n        }\n    }\n    my $sum = 0;\n\
    \    for(my $i = 0; $i < @square; ++$i) {\n        $sum += $square[$i];\n    }\n\
    \    return $sum;\n}", "    my($i, $sum);\n    foreach $i (@$lst) {\n        if\
    \ ($i % 3 == 0) {\n            $sum = $sum + $i; \n        } elsif ($i % 4 ==\
    \ 0) {\n            $sum = $sum + $i*$i; \n        } else {\n            $sum\
    \ = $sum + $i*$i*$i;\n        }\n    }\n    return $sum;\n}", "    $lst =~ m@^(?:(?!(.*\\\
    (.*\\).*))(\\d+)@;\n    $lst =~ m@^(?:(?!(.*\\(.*\\).*))(?:\\d+)@;", "    my($sum)\
    \ = 0;\n    my($tmp) = 0;\n    my($mod) = 0;\n    my($cnt) = 0;\n    foreach my\
    \ $idx (@$lst) {\n        $mod += $idx;\n        $cnt += 1;\n        if ($mod\
    \ % 3 == 0) {\n            $tmp += $idx;\n        } elsif ($mod % 4 == 0) {\n\
    \            $tmp += $idx * $idx;\n        }\n    }\n    if ($cnt > 0) {\n   \
    \     $sum += $tmp;\n    }\n    return $sum;\n}", "    my $sum_of_entries = 0;\n\
    \    for (@$lst) {\n        $sum_of_entries += $_ ** 2 if $_ % 3 == 0;\n     \
    \   $sum_of_entries += $_ ** 3 if $_ % 4 == 0;\n    }\n    return $sum_of_entries;\n\
    }\n</code>\nThe above solution should do everything you asked for. Feel free to\
    \ ask for further clarifications if you get stuck.\n<|/ a tags=arrays,perl |>\n\
    <| c |>\n: Please remember to [accept](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ an answer if it solved your problem\n<|/ c |>\n<| c |>\nIt was accepted only\
    \ after I wrote this answer. It was rejected by my review team and I had to wait\
    \ for 24 hours till I could approve it. I don't see any point in rejecting it\
    \ even if it does solve the problem at hand. I will try and come up with some\
    \ explanation as to why this was rejected and will update the answer to explain\
    \ the same. Thanks for your help.\n<|/ c |>\n<| c |>\nSorry but this is not a\
    \ good answer at all! It's too complicated and unnecessarily obfuscated. There\
    \ are no comments in the code to explain what the code does or what it's doing\
    \ or why it is doing it, and it doesn't teach us anything new and we all know\
    \ that we don't know Perl either.\n<|/ c |>\n<| a |>\n<code>", "    my $s = 0;\n\
    \    \n    for my $i (0 .. @$lst - 1) {\n        if ($i % 3 != 0) {\n        \
    \    $s += $lst->[$i];\n        }\n        if ($i % 4 != 0) {\n            $s\
    \ += $lst->[$i] * $lst->[$i];\n        }\n    }\n    \n    return $s;\n}\n</cell>\n\
    <cell>", "    my $res = 0;\n    for my $i (@$lst) {\n        if ($i % 3 == 0)\
    \ {\n            $res = $res * $i;\n        } elsif ($i % 4 == 0) {\n        \
    \    $res = $res * $i;\n        } else {\n            $res = $res + $i;\n    \
    \    }\n    }\n    return $res;\n}", "    my(@sum_lst);\n    foreach my $i(@$lst)\
    \ {\n        if($i % 3 == 0) {\n            $sum_lst[$i] += $i;\n        } elsif\
    \ ($i % 4 == 0) {\n            $sum_lst[$i] += $i;\n        } else {\n       \
    \     $sum_lst[$i] += $i;\n        }\n    }\n    return @sum_lst;\n}", "    my($result)\
    \ = 0;\n    foreach my $num (@$lst) {\n        if($num % 3 != 0) {\n         \
    \   $result += $num * $num;\n        }\n        if($num % 4 != 0) {\n        \
    \    $result += $num * $num;\n        }\n    }\n    return $result;\n}", "   \
    \ my $sum = 0;\n    foreach my $i (@$lst) {\n        if($i % 3 == 0)\n       \
    \     $sum += $i * $i;\n        elsif($i % 4 == 0)\n            $sum += $i * $i\
    \ * $i;\n        else\n            $sum += $i;\n    }\n    return $sum;\n}", " \
    \   my $sum = 0;\n    \n    foreach my $i(@$lst) {\n        if ($i % 3 == 0) {\n\
    \            $sum = $sum + $i**2;\n        }\n        elsif ($i % 4 == 0) {\n\
    \            $sum = $sum + $i**3;\n        }\n        else {\n            $sum\
    \ = $sum + $i;\n        }\n    }\n    return $sum;\n}", "    my $result = 0;\n\
    \    foreach my $i (@$lst) {\n        if (($i % 3) == 0) {\n            $result\
    \ += $i ** 2;\n        }\n        else if (($i % 4) == 0) {\n            $result\
    \ += $i ** 3;\n        }\n    }\n    return $result;\n}", "    my($sum);\n   \
    \ foreach my $x (@$lst) {\n        $sum += $x if $x % 3 == 0 || $x % 4 == 0;\n\
    \    }\n    return $sum;\n}", "    my @sums;\n    for (@$lst) {\n        if ($_\
    \ & 3) {\n            push @sums, $_ * $_;\n        }\n        elsif ($_ & 4)\
    \ {\n            push @sums, $_ * $_ * $_;\n        }\n        else {\n      \
    \      push @sums, $_;\n        }\n    }\n    return $sums[0];\n}", "    my @sum;\n\
    \    for (my $i = 0; $i < @$lst; $i++) {\n        my $val = $lst->[$i];\n    \
    \    if ($i & 3) {\n            $val *= $val;\n        }\n        if ($i & 4)\
    \ {\n            $val *= $val;\n        }\n        $sum += $val;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    for my $index ( 0 .. $#$lst ) {\n        if\
    \ ($index % 3 == 0 || $index % 4 == 0) {\n            $lst[$index] .= '*';\n \
    \       }\n        else {\n            $lst[$index] =~ s/\\./\\*/g;\n        \
    \    $sum += $lst[$index];\n        }\n    }\n    return $sum;\n}", "    return\
    \ 0 if @$lst == 0;\n    my $x = 0;\n    my @res = ();\n    foreach my $num (@$lst)\
    \ {\n        $x += $num;\n        push (@res, $x) if $x % 3 == 0 || $x % 4 ==\
    \ 0;\n        $x = $x - $num if $x % 3 == 0 || $x % 4 == 0;\n    }\n    return\
    \ $res;\n}\n</code>\n<|/ a |>\n<| c |>\nIt would be better to put the comment\
    \ into the code sample. As it stands it doesn't show how to run the subroutine\
    \ and also isn't very readable. Also, `sub sum_squares { my $lst = shift; return\
    \ 0 if @$lst == 0; $sum = 0; for (my $num = 0; $num < @$lst; $num++) { $sum +=\
    \ $num; push @{ $res{$num} || () }, $sum if $num % 3 == 0 || $num % 4 == 0; }\
    \ return %res; }` would be more readable than your code.\n<|/ c |>\n<| c |>\n\
    thanks for the comments, i thought it would be helpful to show the whole code.\
    \ i will make that change to my answer.\n<|/ c |>\n<| c |>\nThanks again. Sorry\
    \ for the late reply, I'm currently away from a computer right now and didn't\
    \ get around to checking your answer. Your code is much more elegant and efficient\
    \ than mine. Thanks again!\n<|/ c |>\n<| a tags=perl,arrays,loops |>\n<code>",
  "    my($sum);\n    foreach $i(@$lst){\n        if((@$lst % 3) == 0){\n        \
    \    $sum = $sum + $i;\n        }\n        elsif ((@$lst % 4) == 0){\n       \
    \     $sum = $sum + $i;\n        }\n        else{\n            $sum = $sum * $i;\n\
    \        }\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=0 tags=perl,arrays\
    \ |>\n<| c |>\nI understand how to do that. My question is not so much how to\
    \ solve my problem but how to find ways to do it efficiently. My solution works\
    \ but is not efficient.\n<|/ c |>\n<| c |>\nWhat do you want to improve in the\
    \ efficiency of your code?\n<|/ c |>\n<| c |>\nI did not mean to say that the\
    \ solution I posted is not efficient. I am just wondering if there are different\
    \ ways to approach the problem (other than my own solution). The question was\
    \ more like how you might think about solving problems like that efficiently than\
    \ how to solve them.\n<|/ c |>\n<| c |>\nThe question is too broad and doesn't\
    \ have a specific answer. There are so many different ways to solve any problem.\
    \ There is no one way to do it. It always depends on the problem and your code's\
    \ readability and performance. Your own solution can be better, faster, shorter,\
    \ or more efficient. It also depends on your problem.\n<|/ c |>\n<| c |>\nI understand\
    \ that my question is too broad. I was just wondering if there are different ways\
    \ to approach the problem as I did in my solution.\n<|/ c |>\n<| a tags=perl,arrays\
    \ |>\nFor your particular problem, there are two things you need to do:", "  \
    \  my $sum = 0;\n    foreach (@$lst) {\n        if ($_ & (3 * $i)) {\n       \
    \     $sum = $sum + $_;\n        }\n        if ($_ & (4 * $i)) {\n           \
    \ $sum = $sum + $_;\n        }\n    }\n    return $sum;\n}\nprint \"Sum of squares\
    \ is: \", sum_squares([10, 20, 30, 40]), \"\\n\";", "    my $sum = 0;\n    for\
    \ (my $i = 0; $i < @$lst; ++$i) {\n        my $val = $lst->[$i];\n        if ($val\
    \ % 3 == 0 && $val % 4 != 0) {\n            $lst->[$i] = $val ** 2;\n        }\
    \ elsif ($val % 3 == 0) {\n            $lst->[$i] = $val * $val;\n        } else\
    \ {\n            $lst->[$i] = $val * $val;\n        }\n        $sum += $val;\n\
    \    }\n    return $sum;\n}", "    my($sum);\n    my $i = 0;\n    for (my $x=0;\
    \ $x<@$lst; $x++) {\n        if (($x % 3) == 0) {\n            $sum += $x*$x;\n\
    \        } else {\n            $sum += $x*$x*$x;\n        }\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nYou don't need to use map or\
    \ foreach, since you are not changing the elements in the array. Just for loop\
    \ will do. You can also use foreach loop but then you need to use $_ variable\
    \ to store the current element in the array. Also, I am suggesting to use \"my\"\
    \ variable when declaring the variable. \n<code>", "    my @sums;\n    my $j;\n\
    \    for(my $i=0; $i<@$lst; $i++) {\n        $j=$i%3 ? $lst[$i]*$lst[$i] : $lst[$i]*$lst[$i]*$lst[$i];\n\
    \        $j%4 ? $sums[$i]+=$j : $sums[$i]+=$j*$j;\n    }\n    return $sums[0];\n\
    }", "    my $sum = 0;\n    foreach my $num (@$lst) {\n        next if $num % 3;\n\
    \        next if $num % 4;\n        $sum += $num * $num;\n    }\n    return $sum;\n\
    }", "    my(@sums);\n    foreach my $num (@$lst) {\n        if($num % 3 == 0)\
    \ {\n            $sums[$num] += $num * $num;\n        } elsif ($num % 4 == 0)\
    \ {\n            $sums[$num] += $num * $num;\n        } elsif ($num % 3 != 0 &&\
    \ $num % 4 != 0) {\n            $sums[$num] += $num;\n        }\n    }\n    return\
    \ $sums[@$lst];\n}", "    my $result = 0.0;\n    for my $i (0..$#$lst) {\n   \
    \     if ($i % 3 == 0 ) {\n            $result += $lst[$i] * $lst[$i];\n     \
    \   } elsif ($i % 4 == 0) {\n            $result -= $lst[$i] * $lst[$i];\n   \
    \     }\n    }\n    return $result;\n}", "    my $sum = 0;\n    foreach my $el\
    \ (@$lst) {\n        if ($el % 3 == 0) {\n            $el = $el * $el;\n     \
    \   }\n        elsif ($el % 4 == 0) {\n            $el = $el * $el;\n        }\n\
    \        else {\n            $el = $el * $el;\n        }\n        $sum += $el;\n\
    \    }\n    return $sum;\n}\n</code>\nI used the subroutine to solve the problem\n\
    <code>\nuse strict;\nuse warnings;\nuse v5.10.1;", "    my %sums;\n    \n    #\
    \ initialize the sums hash\n    foreach my $i (0 .. $#{$lst}) {\n        if (!exists\
    \ $sums{$i}) {\n            $sums{$i} = 0;\n        }\n    }\n    \n    # calculate\
    \ the sum of squares\n    for (my $i = 0; $i < @{$lst}; $i++) {\n        if ($i\
    \ % 3 == 0) {\n            $sums{$i} = $sums{$i} + $lst[$i] * $lst[$i];\n    \
    \    }\n        if ($i % 4 == 0) {\n            $sums{$i} = $sums{$i} + $lst[$i]\
    \ * $lst[$i];\n        }\n    }\n    return $sums{42};\n}", "    my $sum = 0;\n\
    \    for (@_) {\n        if ($_ & 3) {\n            $_ *= $_ >> 1;\n        }\n\
    \        if ($_ & 4) {\n            $_ *= $_ >> 2;\n        }\n        push @$sum,\
    \ $_;\n    }\n    return $sum;\n}", '    my ($sum_1, $sum_2) = (0, 0);', "   \
    \ my($sum) = 0;\n    foreach my $n ( @$lst ) {\n        if ( $n % 3 == 0 && $n\
    \ % 4 == 0 ) {\n            $sum += $n;\n        } else {\n            $lst->[$n]\
    \ = $n * $n;\n        }\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for\
    \ (@$lst) {\n        if ($i % 3 == 0) {\n            $sum += $i ** 2;\n      \
    \  } elsif ($i % 4 == 0) {\n            $sum += $i ** 3;\n        } else {\n \
    \           $sum += $i;\n        }\n    }\n    return $sum;\n}", "    my $sum\
    \ = 0;\n    for my $i (0 .. $#lst) {\n        next if ($i % 3 == 0);\n       \
    \ next if ($i % 4 == 0);\n        $sum += $lst[$i] * $lst[$i];\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a dscore=0 tags=perl,arrays |>\n<| c |>\nThis was very\
    \ helpful. I was thinking of using for loops but I thought there might be a more\
    \ elegant way. Thank you\n<|/ c |>\n<| c |>\n: There are, and many others are\
    \ possible, but I suspect that the approach presented here will outperform many\
    \ other solutions.\n<|/ c |>\n<| a tags=perl,arrays |>\nMy solution is:\n<code>\n\
    use strict;\nuse warnings;", "    my $sum = 0;\n    my $size = @$lst;\n    \n\
    \    # iterating over each element\n    for my $i (0 .. $size - 1) {\n       \
    \ # checking if the current index is multiple of 3 and if so squaring the element\n\
    \        if ($i & 3) {\n            $sum += $lst[$i] * $lst[$i];\n        }\n\
    \        # checking if the current index is multiple of 4 and if so cube the element\n\
    \        if ($i & 4) {\n            $sum += $lst[$i] * $lst[$i] * $lst[$i];\n\
    \        }\n    }\n    return $sum;\n}", "    my@lst =  grep { $_ %4==0 or $_%4==3\
    \ ? $_ : ()} @$lst;\n    return map {$_**2} @lst;\n}", '    my @out;', '    my
    @sum_lst;', "    my $sum;\n    \n    foreach my $index (0..$#{$lst}) {\n     \
    \   if ($index % 3 == 0) {\n            $sum = $sum + $lst->[$index];\n      \
    \  }\n        elsif ($index % 4 == 0) {\n            $sum = $sum + $lst->[$index]\
    \ * $lst->[$index];\n        }\n        else {\n        }\n    }\n    return $sum;\n\
    }\nprint &sum_squares($lst), \"\\n\";", "    my $sum = 0;\n    foreach my $i (@$lst)\
    \ {\n        if ($i % 3 != 0) {\n            $sum = $sum + $i ** 2;\n        }\n\
    \        if ($i % 4 != 0) {\n            $sum = $sum + $i ** 3;\n        }\n \
    \   }\n    return $sum;\n}", "    my $sum = 0;\n    for(@$lst){\n        if($_\
    \ & 3 == 0){\n            $_*=2;\n        }\n        elsif($_ & 4 == 0){\n   \
    \         $_*=3;\n        }\n        else{\n            $sum+=$_;\n        }\n\
    \    }\n    return $sum;\n}\n</cell>\n<cell>\n@sum = sum_squares(@lst)\n</cell>\n\
    <cell>\n@sum\n</cell>\n<cell>\nsum(@lst)\n</cell>\n<text>\nExercise 5\nWrite a\
    \ function that takes a list of strings and returns the number of characters that\
    \ are not in all capital letters. \nThe function shall not change the list passed\
    \ into the function.\nExamples:\n>>> lst\n[\"M\", \"P\", \"A\"]\n>>> lst\n[\"\
    M\", \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\", \"P\", \"A\", \"A\"]\n>>> lst\n[\"\
    M\", \"P\", \"A\"]\n>>> lst\n[\"m\", \"p\", \"a\"]\n>>> lst\n[\"M\", \"P\", \"\
    A\"]\n>>> lst\n[\"M\", \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\", \"P\", \"A\", \"\
    A\"]\n>>> lst\n[]\n>>> lst\n[\"m\", \"p\", \"a\"]\n>>> lst\n[\"M\", \"P\", \"\
    A\"]\n>>> lst\n[\"m\", \"p\", \"a\"]\n>>> lst\n[\"M\", \"P\", \"A\"]\n>>> lst\n\
    [\"m\", \"p\", \"a\"]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[\"M\"\
    , \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\", \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\"\
    , \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\", \"P\", \"A\", \"A\"]\n>>> lst\n[\"M\"\
    , \"P\", \"A\"]\n>>> lst\n[\"m\", \"p\", \"a\"]\n>>> lst\n[\"M\", \"P\", \"A\"\
    ]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[\"M\", \"P\", \"A\"]\n>>>\
    \ lst\n[\"M\", \"P\", \"A\"]\n>>> lst\n[\"M\", \"P\", \"A\"]\n>>> lst\n[]\n>>>\
    \ lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>>\
    \ lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n>>> lst\n[]\n",
  "    my @res;\n    my($count,$i) = 0;\n    foreach my $x (@$lst) {\n        push(@res,\
    \ $x * $x);\n        $count += 1;\n        if ($count % 3 == 0 && $count % 4 ==\
    \ 0) {\n            $x += $x;\n            $count += 1;\n        }\n    }\n  \
    \  return @res;\n}", "    my $sum = 0;\n    for(@$lst){\n        if ($_ % 3 ==\
    \ 0){\n            $sum = $sum * $_;\n        }\n        elsif ($_ % 4 == 0){\n\
    \            $sum = $sum * $_;\n        }\n        else{\n            $sum = $sum\
    \ + $_;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "    my($sum) = 0;\n    for my $i (0 .. @$lst\
    \ -1) {\n        if ($i % 3 == 0) {\n            $sum += $lst[$i] * $lst[$i];\n\
    \        }\n        elsif ($i % 4 == 0) {\n            $sum += $lst[$i] * $lst[$i]\
    \ * $lst[$i];\n        }\n        else {\n            $sum += $lst[$i];\n    \
    \    }\n    }\n    return $sum;\n}", "    my $sum = 0;\n    foreach my $i (@$lst)\
    \ {\n        if ($i % 3 == 0) {\n            $i ** 2;\n        } elsif ($i % 4\
    \ == 0) {\n            $i ** 3;\n        } else {\n            $sum = $sum + $i;\n\
    \        }\n    }\n    $sum;\n}", "    my @sum;\n    for(@$lst){\n        if ($_\
    \ % 3 == 0){\n            $_ * $_;\n        }\n        elsif ($_ % 4 == 0){\n\
    \            $_ * $_ * $_;\n        }\n        else {\n            $_;\n     \
    \   }\n    }\n    my $sum = 0;\n    for(@sum){\n        $sum = $_ + $sum;\n  \
    \  }\n    return $sum;\n}\n</code>\n<|/ a dscore=1 tags=perl |>\n<| c |>\nNice\
    \ use of map and sum. Also - you could do `@sum += map {$_ * $_}` and save a line.\
    \ :)\n<|/ c |>\n<| a dscore=1 tags=perl |>\n<code>\nuse warnings;\nuse strict;",
  '    my @sums;', '    my @sum;', "    my $sum = 0;\n    my $mult = 1;\n    my $index\
    \ = 0;\n    while ($index++ < @{$lst}) {\n        if ($index % 3 == 0) {\n   \
    \         $sum = $sum + $lst[$index] * $mult;\n            $mult = $mult * 2;\n\
    \        }\n        if ($index % 4 == 0) {\n            $sum = $sum + $lst[$index]\
    \ * $mult;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nA quick refactor of your original function\n<code>", "    my(@sum)\
    \ = (0);\n    my($cnt);\n    foreach my $num (@$lst){\n        if($num % 3 ==\
    \ 0 && $num % 4 != 0) {\n            $sum[$cnt] += $num;\n        }elsif($num\
    \ % 3 == 0){\n            $sum[$cnt] += $num * $num;\n        }elsif($num % 4\
    \ == 0){\n            $sum[$cnt] += $num * $num * $num;\n        }else{\n    \
    \        $cnt++;\n        }\n    }\n    return @sum;\n}", "    my $sum = 0;\n\
    \    my $flag = 0;\n    my $flag2 = 0;\n    foreach my $x (@{$lst}){\n       \
    \ if($flag == 0){\n            if($x % 3 == 0){\n                $sum = $sum +\
    \ $x;\n            }\n            elsif($x % 4 == 0){\n                $sum =\
    \ $sum + $x;\n            }\n            $flag = 1;\n        }\n        elsif($flag2\
    \ == 0){\n            if($x % 3 == 0){\n                $sum = $sum + $x;\n  \
    \          }\n            elsif($x % 4 == 0){\n                $sum = $sum + $x;\n\
    \            }\n            $flag2 = 1;\n        }\n        else{\n          \
    \  if($x % 3 == 0){\n                $sum = $sum + $x;\n            }\n      \
    \      elsif($x % 4 == 0){\n                $sum = $sum + $x;\n            }\n\
    \            $flag = 0;\n            $flag2 = 0;\n        }\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ q |>\n<| c |>\nThis looks like a homework question. As\
    \ such I don't want to give a full answer, but a hint: use [`for`](http://perldoc.perl.org/functions/for.html)\
    \ to iterate over a list of your numbers. You can also use `if` statements to\
    \ determine if a certain number is divisible by 3.\n<|/ c |>\n<| c |>\nIt looks\
    \ like you have started writing a program that solves the problem but you are\
    \ stuck.  Please show what you have tried and explain how that did not work so\
    \ that we can help you understand what you are doing wrong.\n<|/ c |>\n<| c |>\n\
    This question appears to be off-topic because it shows zero effort.\n<|/ c |>\n\
    <| c |>\nI'm voting to close this question as off-topic because it shows zero\
    \ effort.\n<|/ c |>\n<| c |>\nHe has written a program. He has explained what\
    \ he wants to accomplish. He has described what he has already written. He has\
    \ asked if he can do this with less effort. He has demonstrated the effort he\
    \ has already done. He has shown his work and asked if he can do better. He has\
    \ shown his effort and the code he has written. He has asked for an answer. He\
    \ has shown his effort and the code he has written. He has not shown his work\
    \ and asked for help. He has not shown his effort and the code he has written.\
    \ H", "    my(@sum);\n    foreach my $index (0..$#$lst){\n        if($index%4\
    \ != 0){\n            $sum[$index] += $lst->[$index]*$lst->[$index];\n       \
    \ }else{\n            $sum[$index] += $lst->[$index];\n        }\n    }\n    return\
    \ $sum;\n}", "    my @sum;\n    for my $i (@$lst) { \n        if( $i % 3 == 0\
    \ ) { \n            push(@sum, $i*$i);\n        } elsif( $i % 4 == 0 ) { \n  \
    \          push(@sum, $i*$i*$i);\n        } elsif( $i % 3 != 0 ) { \n        \
    \    push(@sum, $i);\n        } elsif( $i % 4 != 0 ) { \n            push(@sum,\
    \ $i);\n        }\n    }\n    return @sum;\n}", "    my $sum = 0;\n    for (@$lst)\
    \ {\n        if ($_ % 3 == 0) {\n            $sum *= $_;\n        } elsif ($_\
    \ % 4 == 0) {\n            $sum *= $_;\n        } else {\n            $sum +=\
    \ $_;\n        }\n    }\n    return $sum;\n}", '    my ($i, $j, $sum);', "   \
    \ my @return = ();\n    my $i;", "    my(@arr);\n    if (@$lst < 0) {\n      \
    \  @$lst = (@$lst)[0]; \n    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
