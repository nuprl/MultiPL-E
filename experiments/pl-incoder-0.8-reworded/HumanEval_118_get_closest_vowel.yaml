name: HumanEval_118_get_closest_vowel
language: pl
prompt: "# You are given a word. Your task is to find the closest vowel that stands\
  \ between \n# two consonants from the right side of the word (case sensitive).\n\
  # Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\
  # find any vowel met the above condition. \n# You may assume that the given string\
  \ contains English letter only.\n# Example:\n# >>> get_closest_vowel(\"yogurt\"\
  )\n# \"u\"\n# >>> get_closest_vowel(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel(\"\
  quick\")\n# \"\"\n# >>> get_closest_vowel(\"ab\")\n# \"\"\nsub get_closest_vowel\
  \ {\n    my($word) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_closest_vowel;\n\
  \        if(eq_deeply($candidate->(\"yogurt\"),\"u\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"full\"\
  ),\"u\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  easy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(\"eAsy\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ali\"),\"\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  bad\"),\"a\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(\"most\"),\"o\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ab\"),\"\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  ba\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(\"quick\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"anime\"),\"i\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Asia\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(\"Above\"),\"o\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($left, $right) = reverse $word;\n    return $word if !$left\
    \ || !$right;", "    my $result = \"\";\n    my $idx = 0;\n    while ($idx < length($word))\
    \ {\n        my $char = $word[$idx];\n        if ($char eq \"a\") {\n        \
    \    my $temp_word = substr($word, 0, $idx+1);\n            if ($temp_word =~\
    \ /[aeiou]/) {\n                if (length($temp_word) >=2) {\n              \
    \      $result = $temp_word;\n                    last;\n                }\n \
    \           }\n        }\n        if ($char eq \"e\") {\n            my $temp_word\
    \ = substr($word, $idx+1, length($word));\n            if ($temp_word =~ /[aeiou]/)\
    \ {\n                if (length($temp_word) >=2) {\n                    $result\
    \ = $temp_word;\n                    last;\n                }\n            }\n\
    \        }\n        if ($char eq \"i\") {\n            my $temp_word = substr($word,\
    \ 0, $idx+1);\n            if ($temp_word =~ /[aeiou]/) {\n                if\
    \ (length($temp_word) >=2) {\n                    $result = $temp_word;\n    \
    \                last;\n                }\n            }\n        }\n        if\
    \ ($char eq \"o\") {\n            my $temp_word = substr($word, $idx+1, length($word));\n\
    \            if ($temp_word =~ /[aeiou]/) {\n                if (length($temp_word)\
    \ >=2) {\n                    $result = $temp_word;\n                    last;\n\
    \                }\n            }\n        }\n        if ($char eq \"u\") {\n\
    \            my $temp_word = substr($word, 0, $idx+1);\n            if ($temp_word\
    \ =~ /[aeiou]/) {\n                if (length($temp_word) >=2) {\n           \
    \         $result = $temp_word;\n                    last;\n                }\n\
    \            }\n        }\n        if ($char eq \"y\") {\n            my $temp_word\
    \ = substr($word, $idx+1, length($word));\n            if ($temp_word =~ /[aeiou]/)\
    \ {\n                if (length($temp_word) >=2) {\n                    $result\
    \ = $temp_word;\n                    last;\n                }\n            }\n\
    \        }\n        if ($char eq \"r\") {\n            my $temp_word = substr($word,\
    \ $idx+1, length($word));\n            if ($temp_word =~ /[aeiou]/) {\n      \
    \          if (length($temp_word) >=2) {\n                    $result = $temp_word;\n\
    \                    last;\n                }\n            }\n        }\n    \
    \    if ($char eq \"l\") {\n            my $temp_word = substr($word, $idx+1,\
    \ length($word));\n            if ($temp_word =~ /[aeiou]/) {\n              \
    \  if (length($temp_word) >=2) {\n                    $result = $", "    my $vowels\
    \ = qw[a e i o u];\n    my $pattern = qr/\\A[$vowels]*([A-Z])\\K([a-z])/;\n  \
    \  my(@matches) = grep {$word =~ $pattern} split //, $word;\n    return $matches[0]\
    \ if @matches;\n    return \"\";\n}\n</code>\nThe regex match is based on this\
    \ question.  It does require that your letters be in the correct case for the\
    \ vowels to be found.  You can use the /i flag if you want to be more explicit,\
    \ or you can just use the /i modifier in the regex if you know your input is all-lower\
    \ case.\nThe split turns the string into an array where every element is the individual\
    \ word that matches the pattern.\n<|/ a tags=perl,regex |>\n<| c |>\nI like the\
    \ `split` approach.  It is definitely cleaner that my own implementation.  However,\
    \ it is also a lot slower.  It seems to be about twice as fast.\n<|/ c |>\n<|\
    \ c |>\nI made a quick change to the regex so that it checks for any letter at\
    \ the beginning and at the end of the word for cases where that does not matter.\
    \  I also changed the `split` so that it would just `return @matches`.\n<|/ c\
    \ |>\n<| a tags=perl,regex |>\nHere's another approach.\n<code>", "    my $vowels\
    \ = \"AEIOUYaeiouy\";\n    my $vowels_pos = 0;\n    my $i = $#{$word};\n    my\
    \ $j = $#{$word} + 1;\n    my $vowel_found = 0;\n    my $previous_char = '';\n\
    \    \n    while ($vowel_found == 0 && $i < $j) {\n        $vowel_found = 1;\n\
    \        for my $v (split //, $vowels) {\n            if ($word[$i] eq $v) {\n\
    \                $vowels_pos++;\n                last if ($vowel_found == 1 &&\
    \ $vowels_pos >= 2);\n                $vowel_found = 0;\n            }\n     \
    \   }\n        $i++;\n    }\n    return if ($vowel_found == 0);\n    \n    $vowel_found\
    \ = 1;\n    for my $v (split //, $vowels) {\n        if ($word[$j] eq $v) {\n\
    \            $vowels_pos++;\n            last if ($vowel_found == 1 && $vowels_pos\
    \ >= 2);\n            $vowel_found = 0;\n        }\n    }\n    $j++;\n    \n \
    \   return $word[$j - 1];\n}", "    my $vowel = \"aeiou\";\n    my $start_con\
    \ = substr($word, 0, -1);\n    my $end_con = substr($word, -1);\n    return $vowel\
    \ unless substr($word, -1) =~ m/($start_con)($end_con)/i;\n    return $start_con;\n\
    }", "    my $vowel = \"\";\n    \n    foreach my $cons( $word->{consonants} )\
    \ {\n        my $distance = $cons - $word->{length};\n        \n        if( $distance\
    \ >= -1 && $distance < $word->{length} ) {\n            $vowel = $cons;\n    \
    \    }\n    }\n    \n    return $vowel;\n}\n</code>\n<|/ a tags=hash,perl,arrays\
    \ |>\n<| a dscore=1 |>\nThe first thing that comes to mind is to iterate through\
    \ the string, counting how many vowels there are, and then iterate through the\
    \ remaining character counting how many consonants there are and then iterate\
    \ through the remaining character counting how many vowels there are, until you\
    \ reach the first vowel you find that meets the condition.\n<code>", "    my $len\
    \ = (length($word) - 1);\n    for my $i (0..$len) {\n        if ($word =~ /[aeiou]$/)\
    \ {\n            return $i if $i + 1 < $len && $word =~ /[aeiou]$/;\n        }\n\
    \    }\n    return \"\";\n}\n</code>\n<|/ a dscore=2 tags=algorithm,regex,perl\
    \ |>\n<| a dscore=0 |>\nYou can find the vowels by a word like \"kowalski\" by\
    \ using the following Perl code\n<code>", "    $word =~ tr/AEIOUaeiou/AEIOUaeiou/;\n\
    \    my ($prev, $next);\n    for(my $i=0;$i<length($word)-1;$i++) {\n        if\
    \ ($word[$i] eq \"A\" ) { \n            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i)\
    \ { \n                $prev = $word[$i];\n            } else {\n             \
    \   $next = $word[$i];\n            }\n        }\n        if ($word[$i] eq \"\
    E\") {\n            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n   \
    \             $prev = $word[$i];\n            } else {\n                $next\
    \ = $word[$i];\n            }\n        }\n        if ($word[$i] eq \"I\") {\n\
    \            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n          \
    \      $prev = $word[$i];\n            } else {\n                $next = $word[$i];\n\
    \            }\n        }\n        if ($word[$i] eq \"O\") {\n            if ($word[$i+1]\
    \ =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n                $prev = $word[$i];\n \
    \           } else {\n                $next = $word[$i];\n            }\n    \
    \    }\n        if ($word[$i] eq \"U\") {\n            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i)\
    \ { \n                $prev = $word[$i];\n            } else {\n             \
    \   $next = $word[$i];\n            }\n        }\n        if ($word[$i] eq \"\
    a\") {\n            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n   \
    \             $prev = $word[$i];\n            } else {\n                $next\
    \ = $word[$i];\n            }\n        }\n        if ($word[$i] eq \"e\") {\n\
    \            if ($word[$i+1] =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n          \
    \      $prev = $word[$i];\n            } else {\n                $next = $word[$i];\n\
    \            }\n        }\n        if ($word[$i] eq \"i\") {\n            if ($word[$i+1]\
    \ =~ /[bcdfghjklmnpqrstvwxyz]{1}/i) { \n                $prev = $word[$i];\n \
    \           } else {\n                $next = $word[$i];\n            }", "  \
    \  my $vowel_position = 1;\n    my $consonant_position = 1;\n    my $vowel_found\
    \ = \"\";\n    my $consonant_found = \"\";\n    while($word =~ m|(.)\\1|g) {\n\
    \        my $letter = $1;\n        if ($letter eq \"a\") {\n            my $consonant_position\
    \ = $consonant_position + $vowel_position;\n            my $consonant_found =\
    \ $consonant_found || \"\";\n            if ($consonant_position <= $#{$consonants})\
    \ {\n                my $consonant = $consonants[$consonant_position];\n     \
    \           $consonant_found = $consonant_found . $consonant;\n              \
    \  push @vowels, $consonant;\n            }\n            $consonant_found = $consonant_found\
    \ || \"\";\n        }\n        $vowel_position++;\n    }\n    if ($vowel_found\
    \ ne \"\") {\n        $vowel_found = $vowel_found . $vowels[$vowel_position];\n\
    \    }\n    else {\n        $vowel_found = \"\";\n    }\n    return $vowel_found;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,perl,regex |>\nHere is a solution\
    \ without using regex:\n<code>\nuse strict;\nuse warnings;", "    return \"\"\
    \ if length($word) == 0;\n    my($length) = length($word);\n    \n    for (my\
    \ $i = 1; $i <= $length; $i++) {\n        my($c) = substr($word,$i-1,1);\n   \
    \     if ($c =~ m/[aeiou]/) {\n            return $c;\n        }\n    }\n    return\
    \ \"\";\n}", "    my $vowel = 'a';\n    my $start = 0;\n    my $end = length($word)\
    \ - 1;\n    while($start < $end){\n        if (substr($word,$start,1) eq $vowel){\n\
    \            $vowel = substr($word,$end,1);\n        }\n        $start++;\n  \
    \      $end--;\n    }\n    return $vowel;\n}\n</code>\n<|/ a dscore=0 tags=perl,algorithm\
    \ |>\n<| c |>\nWhy would you use regex over string functions?\n<|/ c |>\n<| c\
    \ |>\nAgreed, this is very inefficient.\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ It fails for `get_closest_vowel(\"x\")` which should return `\"\"`, but returns\
    \ `x`.\n<|/ c |>\n<| c |>\n`perl -MData::Dumper -wE 'say Dumper grep { /[aeiou]/i\
    \ } grep { !/[aeiou]/i } $_'` will show you why.\n<|/ c |>\n<| a tags=perl,algorithm\
    \ |>\n<code>\nperl -wnE '\n    $vowel = \"a\";\n    while ( /([aeiou])/ ) {\n\
    \        my $c = pop;\n        if ( $c eq $vowel ) {\n            $vowel = pop;\n\
    \        }\n        else {\n            $vowel = $c;\n        }\n    }\n    $vowel'\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=perl,algorithm |>\n<code>", " \
    \   my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my @consonants\
    \ = (\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\");\n\
    \    my $best_vowel;\n    my $best_dist;", "    my $result = '';\n    my $vowels\
    \ = \"aAeEiIoOuU\";\n    my $pos = 0;\n    while($pos < length($word)) {\n   \
    \     $pos = length($word);\n        $result = substr($word, $pos, 1);\n     \
    \   while($pos >0) {\n            $pos = $pos - 1;\n            last if substr($word,\
    \ $pos, 1) =~ /^$vowels/;\n        }\n        if($result =~ /[AEIOU]/) {\n   \
    \         return $result;\n        }\n    }\n}", "    my (@left_consonants,);\n\
    \    \n    # find left consonants\n    while ($word =~ /([bcdfghjklmnpqrstvwxyz])[^aeiou]*/g)\
    \ {\n        push, $1;\n    }\n    \n    # find right consonants\n    while ($word\
    \ =~ /([aeiou])[^bcdfghjklmnpqrstvwxyz]*/g) {\n        push, $1;\n    }\n    \n\
    \    # find the vowel\n    my $vowel = '';\n    for(my $i = 0; $i <; ++$i) {\n\
    \        my $c = $left_consonants[$i];\n        my $r = $right_consonants[$i];\n\
    \        if ($c eq $r) {\n            $vowel = $c;\n            last;\n      \
    \  }\n    }\n    \n    return $vowel ? $vowel : '';\n}", "    my $first_consonant_index\
    \ = $#{ $_[0] =~ /[b-df-hj-np-tv-yz]/ };\n    $first_consonant_index > -1 or return\
    \ \"\";\n    my $last_consonant_index = $#{ $_[0] =~ /[m-z]/ };\n    $last_consonant_index\
    \ > -1 or return \"\";\n    my $vowels_count = scalar(grep /[aeiouy]/ => $word);\n\
    \    my $first_vowel_index = $first_consonant_index - $vowels_count;\n    $first_vowel_index\
    \ > -1 or return \"\";\n    my $last_vowel_index = $last_consonant_index + $vowels_count;\n\
    \    $last_vowel_index > -1 or return \"\";\n    my $first_vowel = $_[0][$first_vowel_index];\n\
    \    my $last_vowel = $_[0][$last_vowel_index];\n    return $first_vowel if $first_vowel\
    \ =~ /[aeiouy]/ && $first_vowel != $last_vowel;\n    return $last_vowel if $first_vowel\
    \ =~ /[aeiouy]/ && $first_vowel != $last_vowel;\n    return \"\";\n}", "    my\
    \ $min_index = $#_;\n    $min_index ||= 0;\n    \n    my $cur_vowel = '';\n  \
    \  my $cur_vowel_index = -1;\n    my $prev_consonant_index = -1;\n    my $prev_consonant_letter\
    \ = '';\n    \n    for(my $index = 0; $index <= $min_index; $index++) {\n    \
    \    if($word[$index] eq ' ') {\n            $cur_vowel_index = $index;\n    \
    \        $cur_vowel = $word[$index];\n            last;\n        }\n        if($prev_consonant_index\
    \ eq -1) {\n            $prev_consonant_index = $index;\n            $prev_consonant_letter\
    \ = $word[$index];\n        } elsif($word[$index] eq $prev_consonant_letter) {\n\
    \            if($index > $prev_consonant_index and $index > $cur_vowel_index)\
    \ {\n                $cur_vowel_index = $index;\n                $cur_vowel =\
    \ $word[$index];\n            }\n        } else {\n            $prev_consonant_letter\
    \ = $word[$index];\n            $prev_consonant_index = $index;\n        }\n \
    \   }\n    return $cur_vowel;\n}", "    $word =~ tr/a-zA-Z//cd;\n    $word = \"\
    U\" unless $word =~ /^U$/;\n    my $vowels = join '',grep(m/[aeiou]/i, \"$word\"\
    , 1);\n    return $vowels;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n #!/usr/bin/perl\n\
    \    use strict;\n    use warnings;", "    $word =~ tr/a-zA-Z//cd;\n    if ( $word\
    \ =~ /[aeiou]/ ) {\n        my $vowel = substr( $word, $-[0], $-[0]);\n      \
    \  return $vowel;\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you for this solution!  I am a beginner and not sure what exactly you are doing\
    \ here:  `my($word) = @_;  \n    $word =~ tr/a-zA-Z//cd;`  Could you please explain\
    \ or point me to an explanation of how these lines of code work?  It makes sense\
    \ to me, but I am not sure exactly what it is doing.  Thank you!\n<|/ c |>\n<|\
    \ c |>\n: I added some explanation\n<|/ c |>\n<| a |>\nOne other way to do this\
    \ is by using regular expressions and the /e flag (eval).\n<code>\nuse strict;\n\
    use warnings;", "    my $vowels = join(\".\", qw( a e i o u y A E I O U Y ));\n\
    \    my $len = length($word);\n    $len > 0 and $word =~ /[AEIOUY]{$len}/ and\
    \ return $vowels{$1};\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nPlease\
    \ consider explaining the code you posted so other people can understand it as\
    \ well. As it stands, it would be very difficult for others to learn from it.\n\
    <|/ c |>\n<| c |>\nThanks for your feedback, I've added the explanation above.\n\
    <|/ c |>\n<| c |>\nThis is wrong: It will return 'U' for input \"ab\".\n<|/ c\
    \ |>\n<| c |>\nHi, thanks for pointing this out. I've modified the code now. Could\
    \ you pls give me your opinion?\n<|/ c |>\n<| c |>\nNice! I would have used `qw//`\
    \ for that vowel list, but I like your use of regex. I've learned something new\
    \ today. :-)\n<|/ c |>\n<| a tags=perl,regex |>\n<code>", "    my $vowels = \"\
    aeiou\";\n    \n    for (my $i = 0; $i <= length($word) - 2; $i++) {\n       \
    \ if ($word[$i] =~ m/$vowels/) {\n            my $start = $i;\n            my\
    \ $last  = $i - (length($word) - 2);\n            while ($last >= 0) {\n     \
    \           last if $word[$last] =~ m/$vowels/;\n                $last--;\n  \
    \          }\n            return $word[$start .. $last + 1];\n        }\n    }\n\
    \    return \"\";\n}", "    $word =~ /[aeiou]/i;\n    my $first;\n    my $last;\n\
    \    my $position = 0;\n    while(1) {\n        $first = $word[$position];\n \
    \       $last = $word[$position+1];\n        unless( $first eq $last ) {\n   \
    \         last;\n        }\n        $position += 2;\n    }\n    return $word[$position];\n\
    }", "    return unless $word;\n    my %vowels = ('a'=>'A', 'e'=>'E', 'i'=>'I',\
    \ 'o'=>'O', 'u'=>'U');\n    my $vowel;\n    my @consonants;\n    for(my $i=length($word)-1;$i>=0;$i--){\n\
    \        if($word[$i] eq 'a'){\n            $vowel = $vowels{'a'} if $vowels{'a'}++;\n\
    \        }\n        elsif($word[$i] eq 'e'){\n            $vowel = $vowels{'e'}\
    \ if $vowels{'e'}++;\n        }\n        elsif($word[$i] eq 'i'){\n          \
    \  $vowel = $vowels{'i'} if $vowels{'i'}++;\n        }\n        elsif($word[$i]\
    \ eq 'o'){\n            $vowel = $vowels{'o'} if $vowels{'o'}++;\n        }\n\
    \        elsif($word[$i] eq 'u'){\n            $vowel = $vowels{'u'} if $vowels{'u'}++;\n\
    \        }\n        else{\n            @consonants = split('', $word[$i]);\n \
    \           last;\n        }\n    }\n    return $vowel if($vowel);\n    return\
    \ '';\n}", "    return \"\";\n}", "    $word =~ s/[^A-Za-z]+//;\n    $vowels =\
    \ (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my $i;\n    my $result = \"\
    \";\n    for(my $i = 0; $i <= length($word) - 2; $i++) {\n        if( substr($word,\
    \ $i, 1) =~ /[aeiouy]/) {\n            $result = substr($word, $i, 1) if substr($word,\
    \ $i, 1) !~ /[aeiouy]$/ and substr($word, $i, 1) !~ /[aeiouy]$/;\n        }\n\
    \    }\n    return $result;\n}", "    return $word =~ /[AEIOUYaeiouy]{2}/gi ?\
    \ $1 : ($word =~ /[bcdfghjklmnpqrstvwxyz]{2}/gi ? $1 : ($word =~ /[AEIOUYaeiouy]{3,5}/gi\
    \ ? $1 : ($word =~ /[bcdfghjklmnpqrstvwxyz]{3,5}/gi ? $1 : \"u\"));\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nYou can do this by iterating through each character\
    \ in the string and using regular expressions to check if it contains two consonants.\n\
    <code>", "    my ($vowel) = qw(a e i o u);\n    my @vowels = qw(a e i o u);\n\
    \    my $pos = 0;\n    for my $i (reverse @vowels) {\n        if ($word =~ /^$vowel\\\
    Q$i\\E$/i) {\n            $pos = $i;\n            last;\n        }\n    }\n  \
    \  if ($pos == 0) {\n        return \"\";\n    }\n    return substr($word, $pos\
    \ + 1);\n}", "    my @consonants;\n    my @vowels;\n    foreach my $c (split //,\
    \ $word) {\n        push(@consonants, $c);\n    }\n    foreach my $v (split //,\
    \ $word) {\n        push(@vowels, $v) if $v eq \"a\" || $v eq \"e\" || $v eq \"\
    i\" || $v eq \"o\" || $v eq \"u\";\n    }", '    $word =~ tr/A-Z/a-z/;', "   \
    \ $word =~ s/[^a-zA-Z0-9]/_/g;\n    \n    my $leftmost_consonant_position = 0;\n\
    \    my $consonant_count = 0;\n    my $vowel_count = 0;", "    $word =~ s/([aeiouyAEIOUY])/\\\
    U$1/g;\n    $word =~ s/[bcdfghklmnpqrstvwxyzBCDFGHKLMPQRSTVWXYZ]/X/g;\n    $word\
    \ =~ s/^[a-z]/X/g;\n    $word =~ s/$/Y/g;\n    $word =~ s/[aeiouy]/[AEIOUY]/g;\n\
    \    $word =~ s/[bcdfghklmpqrstvwxyz]/X/g;\n    $word =~ s/^[bcdfghklmpqrstvwxyz]/X/g;\n\
    \    $word =~ s/$/Y/g;\n    $word =~ s/[aeiouy]/[AEIOUY]/g;\n    $word =~ s/[bcdfghklmpqrstvwxyz]/X/g;\n\
    \    $word =~ s/^[bcdfghklmpqrstvwxyz]/X/g;\n    $word =~ s/$/Y/g;\n    return\
    \ $word;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work for me. I\
    \ am running it in perlbrew (Perl v5.14.2) on OS X 10.11.6 and it produces `'uy'`.\
    \ When I run it on the online perl tester it works.\n<|/ c |>\n<| c |>\n, you're\
    \ right. Looks like I was missing some sort of \"special casing\" for the beginning\
    \ and ending of the string. I've added that to my answer. Thanks for letting me\
    \ know that it works now.\n<|/ c |>\n<| c |>\nI've updated my answer with two\
    \ solutions that use my original solution as well as a new solution that uses\
    \ `map` in the substitutions.\n<|/ c |>\n<| a tags=perl |>\n<code>\nuse strict;\n\
    use warnings;", "    $word =~ s/^([^aeiouy]+)(.)/$1$2/g;\n    my @vowel = qw/a\
    \ e i o u y/;\n    foreach my $letter (@vowel) {\n        my $len = length($word);\n\
    \        my $index = index($word, $letter);\n        $index += $letter - 1;\n\
    \        $len -= $index;\n        my $start = $index;\n        my $end = $index\
    \ + 1;\n        if($end - $start >= 2) {\n            return substr($word, $start,\
    \ $end - $start);\n        }\n    }\n    return '';\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nA version using regex and no loops:\n<code>", "    my(@consonants)\
    \ = qw(y e i o u y a); # consonants for quick searching\n    my($consonant) =\
    \ (length($word)) - 1;\n    my($closest_vowel) = undef;\n    my($current_vowel);",
  "    my($vowel) = \"\";\n    my @vowels = qw(a e i o u);\n    foreach my $i (reverse\
    \ 0 .. length($word)) {\n        my $v = substr($word, $i, 1);\n        next if\
    \ $v eq \"_\";\n        return $v if grep {$vowels[$_] eq $v} 0 .. @vowels - 1;\n\
    \    }\n    return \"\";\n}", "    my $len = length($word);\n    my $vowels =\
    \ \"aeiouAEIOU\";\n    my $prev_consonant = substr($word, 0, -1);\n    my $next_consonant\
    \ = substr($word, ($len-1));\n    my $closest_vowel = \"\";\n    foreach my $vowel\
    \ (split(//, $vowels)) {\n        if ($prev_consonant =~ /^$vowel$/) {\n     \
    \       my $current_vowel = substr($word, ($len-length($vowel)));\n          \
    \  if ($current_vowel =~ /^$vowel$/) {\n                $closest_vowel = $vowel;\n\
    \            }\n        }\n    }\n    return $closest_vowel;\n}\n</code>\n<|/\
    \ a tags=perl,regex |>\n<| c |>\nThe solution that I propose below is more general\
    \ because it is less code and more readable (more readable = more maintainable).\
    \ I prefer this solution to mine.\n<|/ c |>\n<| c |>\nYour solution is better,\
    \ but your code is too complicated for such a simple problem as yours. That's\
    \ why I prefer mine.\n<|/ c |>\n<| c |>\nWell, yes. That why I said \"more readable\
    \ (more maintainable)\" :) I agree, yours solution is easier to read, and yours\
    \ solution is more maintainable, but yours solution is more complicated. Thanks\
    \ anyway.\n<|/ c |>\n<| c |>\nYour code is more maintainable but more complicated\
    \ than mine. My code is more readable and more maintainable because I have extracted\
    \ the logic into a separate sub routine.\n<|/ c |>\n<| a dscore=3 tags=perl,regex\
    \ |>\nIn your case, it would be easier to use look-around assertions.\nYou can\
    \ try the following regex :\n<code>\n(?=[aeiou])(?=[^aeiou])\n</code>\nand replace\
    \ it by an empty string.\nThis regex will match a position where there are 2 characters\
    \ after the look-ahead assertion, but are not followed by an other character in\
    \ the list.\n<|/ a |>\n<| c |>\nNo, this does not work as intended. This regex\
    \ does not match the first vowel in a word. E.g. it matches `a`\n<|/ c |>\n<|\
    \ a tags=perl,regex |>\nThis one will match all vowels except the first:\n<code>\n\
    /^(a|e|i|o|u)[^aeiou]*/\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis will match\
    \ all vowels, except the first one\n<|/ c |>\n<| a dscore=3 ", "    \n    my $vowels_begin\
    \ = \"a\";\n    my $vowels_end = \"z\";\n    my $vowels_middle_1 = \"e\";\n  \
    \  my $vowels_middle_2 = \"i\";\n    my $vowels_middle_3 = \"o\";\n    my $vowels_middle_4\
    \ = \"u\";\n    my $vowels_middle_5 = \"A\";\n    my $vowels_middle_6 = \"E\"\
    ;\n    my $vowels_middle_7 = \"I\";\n    my $vowels_middle_8 = \"O\";\n    my\
    \ $vowels_middle_9 = \"U\";\n    \n    if($word =~ /a{2,}z{2,}e/i || $word =~\
    \ /a{2,}z{2,}i/i || $word =~ /a{2,}z{2,}o/i || $word =~ /a{2,}z{2,}u/i) {\n  \
    \      return $vowels_middle_1;\n    } else if($word =~ /a{2,}z{2,}e/i || $word\
    \ =~ /a{2,}z{2,}i/i || $word =~ /a{2,}z{2,}o/i || $word =~ /a{2,}z{2,}u/i) {\n\
    \        return $vowels_middle_2;\n    } else if($word =~ /a{2,}z{2,}e/i || $word\
    \ =~ /a{2,}z{2,}i/i || $word =~ /a{2,}z{2,}o/i || $word =~ /a{2,}z{2,}u/i) {\n\
    \        return $vowels_middle_3;\n    } else if($word =~ /a{2,}z{2,}e/i || $word\
    \ =~ /a{2,}z{2,}i/i || $word =~ /a{2,}z{2,}o/i || $word =~ /a{2,}z{2,}u/i) {\n\
    \        return $vowels_middle_4;\n    } else if($word =~ /a{2,}z{2,}e/i || $word\
    \ =~ /a{2,}z{2,}i/i || $word =~ /a{2,}z{2,}o/i || $word =~ /a{2,}z{2,}u/i) {\n\
    \        return $vowels_middle_5;\n    } else if($word =~ /a{2,}z{2,}e/i || $word\
    \ =~ /a{2,}z{2,}", "    chomp($word);\n    my $index = 0;\n    my $found = \"\"\
    ;\n    my @vowel_positions = ();\n    my @consonant_positions = ();\n    for(my\
    \ $i = 0; $i <= length($word) - 3; $i++){\n        my $consonant = substr($word,\
    \ $i, 1);\n        if($consonant =~ /^[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/){\n\
    \            push(@consonant_positions, $i);\n        }\n        my $vowel = substr($word,\
    \ $i, 1);\n        if($vowel =~ /^[aeiou]/){\n            push(@vowel_positions,\
    \ $i);\n        }\n    }\n    if(scalar(@consonant_positions) == 0){\n       \
    \ return \"\";\n    }\n    if(scalar(@vowel_positions) == 0){\n        return\
    \ \"\";\n    }\n    if($vowel_positions[0] > $consonant_positions[scalar(@consonant_positions)-1]){\n\
    \        my $tmp_consonant_position = $consonant_positions[0];\n        for(my\
    \ $i = 0; $i <= scalar(@consonant_positions); $i++){\n            my $tmp_consonant\
    \ = substr($word, $tmp_consonant_position, $i+1);\n            my $tmp_vowel =\
    \ substr($word, $tmp_consonant_position, $i);\n            if($tmp_vowel =~ /^[aeiou]/){\n\
    \                if($tmp_consonant =~ /^[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/){\n\
    \                    $found = $tmp_vowel;\n                    $index = $i;\n\
    \                }\n            }\n        }\n    }else{\n        my $tmp_consonant_position\
    \ = $consonant_positions[-1];\n        for(my $i = 0; $i <= scalar(@consonant_positions);\
    \ $i++){\n            my $tmp_consonant = substr($word, $tmp_consonant_position,\
    \ $i+1);\n            my $tmp_vowel = substr($word, $tmp_consonant_position, $i);\n\
    \            if($tmp_vowel =~ /^[aeiou]/){\n                if($tmp_consonant\
    \ =~ /^[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/){\n                    $found\
    \ = $tmp_vowel;\n                    $index = $i;\n                }\n       \
    \     }\n        }\n    }\n    return $found if $found ne \"\";\n    return \"\
    \";\n}", "    $word =~ s/^([a-zA-Z]+)/$1/i;\n    $word =~ tr/aeiouAEIOU/eiuOaeuA/i;\n\
    \    return $word eq \"a\" ? \"u\" : \"\";\n}", "    \n    my $len = length $word;\n\
    \    \n    for($len; $len >= 2; $len--) {\n        return \"\" unless $word[$len-1]\
    \ =~ /[AEIOUaeiou]/;\n    }\n    \n    return $word[$len-1];\n}", "    my $i =\
    \ 0;\n    my $letter = $word[$i];\n    my $found = 0;\n    while ($letter ne \"\
    a\" and $letter ne \"e\" and $letter ne \"i\" and $letter ne \"o\" and $letter\
    \ ne \"u\" and $letter ne \"y\" and $letter ne \"A\" and $letter ne \"E\" and\
    \ $letter ne \"I\" and $letter ne \"O\" and $letter ne \"U\" and $letter ne \"\
    Y\") {\n        if ($letter ne $word[$i + 1]) {\n            $i += 1;\n      \
    \      $letter = $word[$i];\n            $found = 0;\n        } else {\n     \
    \       $i++;\n            $found = 1;\n        }\n    }\n    return \"\" if $found\
    \ == 0;\n    $letter = $word[$i];\n    return $letter if $letter ne \"a\" and\
    \ $letter ne \"e\" and $letter ne \"i\" and $letter ne \"o\" and $letter ne \"\
    u\" and $letter ne \"y\" and $letter ne \"A\" and $letter ne \"E\" and $letter\
    \ ne \"I\" and $letter ne \"O\" and $letter ne \"U\" and $letter ne \"Y\";\n}",
  "    my @vowels;\n    my $i = 0;\n    foreach my $v (@vowels) {\n        if ($v\
    \ eq 'a') { push @vowels, $i; }\n        elsif ($v eq 'e') { push @vowels, $i;\
    \ }\n        elsif ($v eq 'i') { push @vowels, $i; }\n        elsif ($v eq 'o')\
    \ { push @vowels, $i; }\n        elsif ($v eq 'u') { push @vowels, $i; }\n   \
    \     elsif ($v eq 'A') { push @vowels, $i; }\n        elsif ($v eq 'E') { push\
    \ @vowels, $i; }\n        elsif ($v eq 'I') { push @vowels, $i; }\n        elsif\
    \ ($v eq 'O') { push @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels,\
    \ $i; }\n        elsif ($v eq 'I') { push @vowels, $i; }\n        elsif ($v eq\
    \ 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels, $i; }\n\
    \        elsif ($v eq 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') {\
    \ push @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels, $i; }\n     \
    \   elsif ($v eq 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') { push\
    \ @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels, $i; }\n        elsif\
    \ ($v eq 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels,\
    \ $i; }\n        elsif ($v eq 'U') { push @vowels, $i; }\n        elsif ($v eq\
    \ 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') { push @vowels, $i; }\n\
    \        elsif ($v eq 'U') { push @vowels, $i; }\n        elsif ($v eq 'U') {\
    \ push @vowels, $i; }\n        elsif ($v eq", "    \n    # return \"\" when we\
    \ don't meet the requirement of having vowels \n    # in the beginning and ending\n\
    \    if ($word =~ /^[aeiouAEIOU]$/) {\n        $word =~ s/^.+//;\n        $word\
    \ =~ s/.+$//;\n    }\n    \n    # replace vowels with \"*\" \n    $word =~ s/[AEIOUaeiou]/*/g;\n\
    \    \n    if ($word =~ /([BCDFGHJKLMNPQRSTVWXYZ])\\1([BCDFGHJKLMNPQRSTVWXYZ])/g)\
    \ {\n        my @vowels = ();\n        for my $v (@{$+{vowels}}) {\n         \
    \   push(@vowels, \"*\" . $v);\n        }\n        $word = join(\" \", @vowels);\n\
    \    }", "    my(@letters) = split //, $word;\n    my(@vowels) = ('a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U');\n    my(@new_letters) = ();\n    for(my\
    \ $i = 0; $i < scalar(@letters); $i++){\n        for(my $j = 0; $j < scalar(@vowels);\
    \ $j++){\n            if($letters[$i] eq $vowels[$j]){\n                push(@new_letters,\
    \ $letters[$i]);\n                last;\n            }\n        }\n    }\n   \
    \ return $new_letters[scalar(@new_letters)-1] if scalar(@new_letters) > 0;\n \
    \   return '';\n}\n</code>\n<|/ a tags=subroutine,perl,loops |>\n<| c |>\nThis\
    \ is an interesting approach.  One minor observation: In your example, you use\
    \ 'ab' as the string.  However, it does not work if the string is something like\
    \ 'babab' (ie. the letters are not in the right order).  If that is your scenario,\
    \ you might want to add some conditional logic to your `for` loop before you start\
    \ looping through the letters.  For example, you could compare the first letter\
    \ against the letter before and compare the second letter against the letter before\
    \ that and so on.  If none of those match your conditions, then you know your\
    \ search string is not in the right order.\n<|/ c |>\n<| c |>\n- Yes, this can\
    \ still be a problem, however it can be avoided by adding some conditional logic\
    \ which compares the letters.  However, a more efficient implementation would\
    \ use two nested loops - one to iterate through the letters and one to iterate\
    \ through the vowels.  The outer loop should terminate if the current letter is\
    \ equal to the letter before (or after, if the letters are in reverse order).\
    \  When the letters loop finishes, you need to compare the current letter with\
    \ the previous letter.  If you find your current letter is equal to the letter\
    \ before that, then you know your search string is not in order.\n<|/ c |>\n<|\
    \ c |>\n- This comment is incorrect.  In fact, using 'babab' as the test string\
    \ gives you the wrong answer.  It returns 'b' instead of 'a'.  I posted an answer\
    \ explaining why this is.\n<|/ c |>\n<| c |>\nThis should be the answer +1\n<|/\
    \ c |>\n<| c |>\n- thanks for pointing that out.  I fixed the answer.\n<|/ c |>\n\
    <| a tags=subroutine,perl,loops |>\nThe problem is that the program doesn't know\
    \ where the word ends.  That is, the word \"quick\" doesn't have a \"", "    my\
    \ $vowels = join \"\", (\"aeiouAEIOU\");\n    $vowels =~ s/([aeiouAEIOU])//g;\n\
    \    return $word =~ m/($vowels)([^aeiouAEIOU])/s ? $1 : \"\";\n}\n</code>\nI\
    \ find this approach easier to maintain because I can reuse my regexp instead\
    \ of repeating it in each function. I also don't have to worry about whether there\
    \ are any other vowels that come right before or after the one I'm looking for,\
    \ I can just remove the vowels from $vowels instead.\nAnd I should add that I\
    \ find this approach to be more elegant than your own.\n<|/ a |>\n<| c |>\nThank\
    \ you for the explanation! I understand now why my method was failing, though\
    \ I'm still not entirely sure I understand why yours does work. I'll have to study\
    \ up on how the `s///g` operator works a bit more. I'll give this a shot and see\
    \ how it works out. Thank you again for your help!\n<|/ c |>\n<| c |>\n`s///`\
    \ is a *substitution* operator. It operates on a regular expression match, which\
    \ I used (essentially) like `/(\\w)([aeiouAEIOU])/` (and I didn't need the `/s`\
    \ flag because I'm only looking for one match), but with the `g` modifier so I\
    \ can repeat the search globally.\n<|/ c |>\n<| c |>\n`$1` and `$2` are the *capturing\
    \ groups*, which I'm referring to in my comment.\n<|/ c |>\n<| c |>\nAhhhh...I\
    \ see. That makes much more sense. Thank you very much for the explanation!\n\
    <|/ c |>\n<| c |>\n: I was curious, so I tested it out. Here's a short demonstration:\
    \ http://ideone.com/ZVZMG6. My method failed at `ab` but mine passed at `abcdefghijklmnopqrstuvwxyz`\n\
    <|/ c |>\n<| a tags=perl,regex dscore=1 |>\nThis approach uses the following regex:\n\
    <code>\n(\\w)([aeiouAEIOU])\n</code>\nThis regex will match any letter after a\
    \ word character, and will capture the letter and the vowel in capture groups\
    \ 1 and 2.  We then just need to find the closest vowel in those groups.\n<code>\n\
    use strict;\nuse warnings;", "    return \"\" if !length($word) || !$word || $word\
    \ =~ /^[a-z]+$/i;\n    my $vowel_start = (length($word) - length($word) / 2) +\
    \ 1;\n    my $vowel_end = length($word) - 1;\n    my $first_consonant = substr($word,$vowel_start,1);\n\
    \    my $last_consonant = substr($word,$vowel_end,1);\n    my @consonants = split\
    \ //, $first_consonant;\n    my @vowels = split //, $last_consonant;\n    my $closest_vowel;\n\
    \    my $total_vowel_cons;\n    my $first_vowel_cons;\n    my $first_vowel_vowel;\n\
    \    my $total_vowel_vowels;\n    foreach my $vowel (@vowels) {\n        $total_vowel_vowels\
    \ += 1;\n        $total_vowel_cons += 1;\n    }\n    foreach my $consonant (@consonants)\
    \ {\n        $total_vowel_cons += 1;\n        $first_vowel_cons = $first_consonant\
    \ . $consonant;\n        foreach my $vowel (@vowels) {\n            if ($first_vowel_cons\
    \ =~ m/$vowel/i) {\n                $first_vowel_vowel = $vowel;\n           \
    \ }\n        }\n        $closest_vowel = $first_vowel_vowel if !$closest_vowel;\n\
    \    }\n    $closest_vowel if $closest_vowel;\n}", "    my $vowels = 'aeiou';\n\
    \    my $result = \"\";\n    $word =~ s/^([$vowels])|([$vowels]$)/$2/g;\n    my\
    \ $i = 0;\n    my $j = $#{$word} + 1;\n    while (1) {\n        if ($j > $#{$word})\
    \ {\n            $j = $#{$word};\n        }\n        if ($i == $j) {\n       \
    \     return \"\";\n        }\n        my $sub = $word[$i];\n        ++$i;\n \
    \       if ($sub =~ /^a$/i) {\n            return \"\";\n        }\n        if\
    \ ($sub =~ /^e$/i) {\n            $result = \"e\";\n        }\n        elsif ($sub\
    \ =~ /^i$/i) {\n            $result = \"i\";\n        }\n        elsif ($sub =~\
    \ /^o$/i) {\n            $result = \"o\";\n        }\n        elsif ($sub =~ /^u$/i)\
    \ {\n            $result = \"u\";\n        }\n        elsif ($sub =~ /^y$/i) {\n\
    \            $result = \"y\";\n        }\n        elsif ($sub =~ /^h$/i) {\n \
    \           $result = \"h\";\n        }\n        elsif ($sub =~ /^k$/i) {\n  \
    \          $result = \"k\";\n        }\n        elsif ($sub =~ /^l$/i) {\n   \
    \         $result = \"l\";\n        }\n        elsif ($sub =~ /^m$/i) {\n    \
    \        $result = \"m\";\n        }\n        elsif ($sub =~ /^n$/i) {\n     \
    \       $result = \"n\";\n        }\n        elsif ($sub =~ /^p$/i) {\n      \
    \      $result = \"p\";\n        }\n        elsif ($sub =~ /^q$/i) {\n       \
    \     $result = \"q\";\n        }\n        elsif ($sub =~ /^s$/i) {\n        \
    \    $result = \"s\";\n        }\n        elsif ($sub =~ /^t$/i) {\n         \
    \   $result = \"t\";\n        }\n        elsif ($sub =~ /^v$/i) {\n          \
    \  $result = \"v\";\n        }\n        elsif ($sub =~ /^w$/i) {\n           \
    \ $result = \"w\";\n        }\n        elsif ($sub =~ /^x$/i) {\n            $result\
    \ = \"x\";\n        }\n        elsif ($sub =~ /^z$/i) {\n            $result =\
    \ \"z\";\n        }\n        elsif ($sub =~ /^0$/i) {\n            $result = \"\
    0\";\n        }\n        elsi", "    my $closest_vowel = \"\";\n    my %vowels\
    \ = (\"a\" => \"u\",\"e\" => \"u\",\"i\" => \"u\",\"o\" => \"u\",\"u\" => \"u\"\
    ,\"y\" => \"i\");\n    my $vowel_count = 0;\n    my $consonant_count = 0;\n  \
    \  my $pos = 0;\n    foreach my $letter (split //, $word) {\n        if(exists\
    \ $vowels{$letter}) {\n            $vowel_count++;\n            next unless $vowels{$letter};\n\
    \        } elsif($letter eq \"z\") {\n            $pos = length($word) - 1;\n\
    \        } elsif($letter eq \"y\") {\n            $pos = 0;\n        }\n     \
    \   $consonant_count++;\n        if($consonant_count > $vowel_count) {\n     \
    \       if(($pos > 0) && ($pos <= length($word))) {\n                $closest_vowel\
    \ = $letter;\n            }\n            last if(($pos <= length($word)) && ($closest_vowel\
    \ eq \"\"));\n        }\n    }\n    return $closest_vowel;\n}", "    \n    my\
    \ @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\");\n    my $closest_vowel = $word;\n\
    \    my $current_vowel = 1;\n    \n    foreach my $consonant (@{[ $word, $word\
    \ =~ /[a-z]/i ]}){\n        if($consonant =~ /[a-z]/i) {\n            if($consonant\
    \ ne $closest_vowel){\n                $current_vowel++;\n                if($current_vowel\
    \ eq scalar @vowels){\n                    $closest_vowel = $consonant;\n    \
    \            }\n            }\n            else {\n                $current_vowel++;\n\
    \            }\n        }\n    }\n    return $closest_vowel;\n}", "    # split\
    \ the word into letters, get the reverse part and trim it\n    my(@letters) =\
    \ split //, $word;\n    my(@reverse) = reverse @letters;\n    \n    # find the\
    \ first consonant not followed by a vowel\n    my $i = 0;\n    my $c = 0;\n  \
    \  for my $l (@reverse) {\n        if ($l eq \"Z\" || ($l eq \"z\" && $i == 0))\
    \ {\n            $c++;\n        }\n        if ($l eq \"Y\" || ($l eq \"y\" &&\
    \ $i == 0)) {\n            $c++;\n        }\n        $i++;\n    }\n    $c++;\n\
    \    \n    # find first vowel after the first consonant not followed by a vowel\n\
    \    my $i = 0;\n    my $v = 0;\n    for my $l (@reverse) {\n        if ($l eq\
    \ \"Z\" || ($l eq \"z\" && $i == 0)) {\n            $v++;\n        }\n       \
    \ if ($l eq \"Y\" || ($l eq \"y\" && $i == 0)) {\n            $v++;\n        }\n\
    \        $i++;\n    }\n    $v++;\n    \n    # if the word's first or last consonant\
    \ is a vowel\n    if ($c > 0) {\n        # return the reverse of this vowel's\
    \ index from right side\n        my $reverse_index = $reverse -> [$v - 1];\n \
    \       my $letter = $reverse -> [$reverse_index];\n        return $letter;\n\
    \    }\n    \n    # if the word's first or last vowel is a consonant\n    if ($v\
    \ > 0) {\n        # return the reverse of this consonant's index from right side\n\
    \        my $reverse_index = $reverse -> [$c - 1];\n        my $letter = $reverse\
    \ -> [$reverse_index];\n        return $letter;\n    }\n    \n    # return the\
    \ empty string if the word has no vowels found between the \n    # first and the\
    \ last consonants\n    return \"\";\n}\n</cell>\n<cell>", "    my $vowel = substr($word,length($word)-length($word),1);\n\
    \    $vowel =~ m/^[aeiouAEIOU][aeiouAEIOU]+$/g;\n    return $vowel;\n}", "   \
    \ my $vowels = join \"\", (qw[a e i o u]);\n    my (@r) = reverse split(//, $word);\n\
    \    my $r = $r[0];\n    my $l = $r[-1];\n    if ($l =~ /[a-z]/) {\n        foreach\
    \ my $v (@vowels) {\n            my $index = $l =~ /$v/;\n            return $v\
    \ if ($index || $index == 0);\n        }\n    }\n    return;\n}", "    my;\n \
    \   for(my $i = length($word)-1; $i >= 0; $i--) {\n        push(@vowels, substr($word,\
    \ $i, 1));\n    }\n    for(my $i = scalar(@vowels)-1; $i >= 0; $i--) {\n     \
    \   if($vowels[$i] eq \"A\") {\n            if($i > 0) {\n                if($vowels[$i-1]\
    \ eq \"U\") {\n                    if($i < (scalar(@vowels)-1)) {\n          \
    \              if($vowels[$i+1] eq \"A\") {\n                            return\
    \ \"A\";\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return \"\";\n}", "    my @vowels = (\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my $length = $word->length();\n\
    \    my $vowel = undef;\n    for (my $index = 1; $index <= $length; $index++)\
    \ {\n        $vowel = $word->substr($index-2, 1)\n            if ($index <= $length\
    \ &&\n                $vowel eq $word->substr($index-2, 1) &&\n              \
    \  !$vowel &&\n                $vowels[-1] eq $word->substr($index-2, 1)\n   \
    \         );\n    }\n    return $vowel ? $vowel : \"\";\n}", "    my (@vowels_begin,\
    \ @vowels_end);\n    # vowel candidates begin: \n    push (@vowels_begin, 'a',\
    \ 'A');\n    # vowel candidates end:\n    push (@vowels_end, 'i', 'I');\n    #\
    \ vowels count:\n    my $vowels_count = (@vowels_end - @vowels_begin);", "   \
    \ \n    return \"\" if $word eq \"\";\n    \n    my(@vowels) = ($word[-1] eq 'u'\
    \ || $word[-1] eq 'y' || $word[-1] eq 'a' || $word[-1] eq 'o' || $word[-1] eq\
    \ 'i' || $word[-1] eq 'e' || $word[-1] eq 'a' || $word[-1] eq 'o' || $word[-1]\
    \ eq 'i' || $word[-1] eq 'e' || $word[-1] eq 'a' || $word[-1] eq 'y' || $word[-1]\
    \ eq 'u');\n    my(@vowels_at_beginning) = (\"a\",\"e\",\"i\",\"o\",\"u\");\n\
    \    my(@vowels_at_end) = (\"e\",\"i\",\"o\",\"u\");\n    \n    foreach my $idx\
    \ (0..$#word) {\n        my $letter = $word[$idx];\n        my $found = 0;\n \
    \       \n        foreach my $v (@vowels_at_beginning) {\n            if ($letter\
    \ eq $v) {\n                $found = 1;\n                last;\n            }\n\
    \        }\n        \n        if (!$found) {\n            foreach my $v (@vowels_at_end)\
    \ {\n                if ($letter eq $v) {\n                    $found = 1;\n \
    \                   last;\n                }\n            }\n        }\n     \
    \   \n        if ($found) {\n            if ($idx == ($#word - 1)) {\n       \
    \         return $letter;\n            }\n            elsif ($idx != 0) {\n  \
    \              return $word[$idx - 1];\n            }\n        }\n    }\n    \n\
    \    return \"\";\n}", "    my($vowel);\n    my($consonant) =\n    qr{\n     \
    \       ^ # Start\n            [^aeiou] # Consonant\n            [a-z] # Vowel\n\
    \            [^aeiou][a-z] # Consonant + Vowel\n        };", "    $word =~ tr/A-Z/a-z/;\n\
    \    my $vowel = qw(a e i o u);\n    my $found = 0;\n    my $closest_vowel = \"\
    \";\n    \n    for my $i (0 .. length($word)-2) {\n        my $j = $i+1;\n   \
    \     my $k = $j+1;\n        if ($vowel[$i] eq $word[$i] && $vowel[$j] eq $word[$j]\
    \ && $vowel[$k] eq $word[$k]) {\n            $found++;\n            $closest_vowel\
    \ = $vowel[$i];\n        }\n    }", "    my @vowels = (\"a\",\"e\",\"i\",\"o\"\
    ,\"u\",\"A\",\"E\",\"I\",\"O\",\"U\");\n    my $len = $#vowels;\n    \n    foreach\
    \ my $i (0..$len-1) {\n        my $offset = $len-$i;\n        \n        if (substr($word,$offset-1,1)\
    \ eq \"a\") {\n            return $vowels[$i];\n        }\n        elsif (substr($word,$offset-1,1)\
    \ eq \"e\") {\n            return $vowels[$i];\n        }\n        elsif (substr($word,$offset-1,1)\
    \ eq \"i\") {\n            return $vowels[$i];\n        }\n        elsif (substr($word,$offset-1,1)\
    \ eq \"o\") {\n            return $vowels[$i];\n        }\n        elsif (substr($word,$offset-1,1)\
    \ eq \"u\") {\n            return $vowels[$i];\n        }\n    }\n    \n    return\
    \ \"\";\n}", "    $word =~ tr/aeiouyAEIOUY/AY/;\n    $word =~ tr/bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ/BCDEFGHJKLMNPQRSTVWXYZ/;\n\
    \    my @vowels = (\"a\",\"e\",\"i\",\"o\",\"u\");\n    for my $i (0..$#vowels)\
    \ {\n        my $j = $i;\n        $word = $word->reverse;\n        my $word2 =\
    \ \"\";\n        my $a = substr($word,0,1);\n        my $c = substr($word,-1,1);\n\
    \        if ($word2 eq $word) {\n            return $vowels[$i];\n        }\n\
    \        if ($word2 eq \"a\" && ($a ne \"a\" || ($c eq \"a\" && $word2 ne \"a\"\
    ))) {\n            $j++;\n            last if ($word2 eq \"a\" && $a eq \"a\"\
    );\n            last if ($word2 eq \"a\" && $a eq \"a\" && $c eq \"a\");\n   \
    \     }\n        if ($word2 eq \"c\" && ($a eq \"c\" || $c eq \"c\")) {\n    \
    \        $j++;\n        }\n        if ($word2 eq \"e\" && ($a eq \"e\" || $c eq\
    \ \"e\")) {\n            $j++;\n        }\n        if ($word2 eq \"i\" && ($a\
    \ eq \"i\" || $c eq \"i\")) {\n            $j++;\n        }\n        if ($word2\
    \ eq \"o\" && ($a eq \"o\" || $c eq \"o\")) {\n            $j++;\n        }\n\
    \        if ($word2 eq \"u\" && ($a eq \"u\" || $c eq \"u\")) {\n            $j++;\n\
    \        }\n        if ($word2 eq \"y\" && ($a eq \"y\" || $c eq \"y\")) {\n \
    \           $j++;\n        }\n        if ($word2 eq \"Y\" && ($a eq \"Y\" || $c\
    \ eq \"Y\")) {\n            $j++;\n        }\n        if ($word2 eq \"b\" && ($a\
    \ eq \"b\" || $c eq \"b\")) {\n            $j++;\n        }\n        if ($word2\
    \ eq \"D\" && ($a eq \"d\" || $c eq \"d\")) {\n            $j++;\n        }\n\
    \        if ($word2 eq \"F\" && ($a eq \"f\" || $c eq \"f\")) {\n            $j++;\n\
    \        }\n        if ($word2 eq \"G\" && ($a eq", "    $word =~ tr/A-Z//cd;\n\
    \    my($closest) = undef;\n    $closest .= substr($word, -1, 1) unless $word\
    \ =~ /^[AEIOU]/i;\n    return $closest;\n}\n</code>\n<|/ a |>\n<| a tags=string,perl\
    \ dscore=0 |>\nYou can solve this problem using one regex. Here is a Perl program\
    \ that returns the closest vowel from a given word:\n<code>", "    \n    foreach\
    \ my $i ( 0 .. length($word) - 1 ) {\n        my $letter = substr($word, $i, 1);\n\
    \        my $vowel_pairs = qw(u e i o a uwa uw aw au ow auw awe auwe \n      \
    \                   y e ii oo aa uu aa au oa auu aau eu iuw iiu iu oiuw oiu iuwe\
    \ \n                         y u ya uu yu we awe auwe awe awe auwe awe awe auwe\
    \ awe awe awe auwe awe auwe \n                         uu aa eu oa iua auu uua\
    \ oau iuu aau uau oau uuu a u eu iu au uua ou oa au iuu uu auu oau uu au ua aa\
    \ eu oa iua auu uua oau iuu aau uau oau uuu o u euo ao iuo oa auo uoa uoa oao\
    \ auoo uoo auo uo oo oo\");\n        foreach my $pair ($vowel_pairs) {\n     \
    \       if ( $letter eq $pair ) {\n                return $pair;\n           \
    \ }\n        }\n    }\n    return \"\";\n}\n</cell>\n<cell>", "    my($consonant_end)\
    \ = $word[length($word)-1];\n    my($vowel_start) = $word[length($word)-1];\n\
    \    my($vowel_end);\n    my($consonant_start);\n    my($closest_vowel) = undef;\n\
    \    my($next_vowel) = undef;\n    my(@consonants_vowels);\n    foreach $consonant\
    \ (@{_}) {\n        $consonant_end =~ s/$consonant//;\n        foreach $vowel\
    \ (@{_}) {\n            $vowel_start =~ s/$vowel//;\n            $vowel_end =~\
    \ s/$vowel//;\n            if ($consonant_start <= $vowel_start && $vowel_end\
    \ >= $consonant_end) {\n                if (defined $closest_vowel) {\n      \
    \              if ($closest_vowel eq $vowel) {\n                        last;\n\
    \                    }\n                } else {\n                    $closest_vowel\
    \ = $vowel;\n                }\n            }\n        }\n    }\n    return $closest_vowel;\n\
    }", "    return \"\" if($word eq \"\"); # don't return empty string", "    $word\
    \ =~ tr/[aeiouAEIOU]/[AEIOU]/;\n    if ($word =~ /[aeiouAEIOU]/) { # only one\
    \ vowel left\n        my $vowel = substr($word, 0, -1);\n        # print \"vowel\
    \ $vowel\\n\";\n        return $vowel;\n    }\n    return \"\";\n}", "    $word\
    \ =~ tr/A-Z//cd;\n    foreach my $i (0..(length($word)-1)) {\n        if ($word\
    \ =~ m@^([aeiou])\\1@) {\n            $vowel = $1;\n            last;\n      \
    \  }\n    }\n    $vowel;\n}\n</code>\n<|/ a dscore=2 tags=perl,regex |>\n<| c\
    \ |>\nI don't think that's what he wanted. He wants the closest vowel, not all\
    \ of them.\n<|/ c |>\n<| c |>\n: It appears that way.  But I don't think that's\
    \ what the OP had in mind.  And his example was ambiguous anyway.\n<|/ c |>\n\
    <| a |>\n<code>", "    my $vowels = \"aeiouAEIOU\";\n    my $i = length($word);\n\
    \    my $closest_vowel = \"\";\n    for (my $j = $i - 1; $j >= 0; $j--) {\n  \
    \      if ($vowels =~ /$word[$j].*?\\Q$word[$j + 1]/) {\n            $closest_vowel\
    \ = $word[$j + 1];\n            last;\n        }\n    }\n    return $closest_vowel;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI did the same as you said. Worked for me. Thank\
    \ you sir.\n<|/ c |>\n<| a |>\nA more generic solution:\n<code>", "    $word =~\
    \ s/[^A-Za-z]//g;\n    $word =~ s/^[^a-z]//g;\n    $word =~ s/[^a-z]$//g;\n  \
    \  $vowel = \"u\" if ($word =~ m/[aeiouAEIOU]/i);\n    $vowel = \"A\" if ($word\
    \ =~ m/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/i);\n    $vowel = \"\" if\
    \ (!defined($vowel));\n    return $vowel;\n}", "    my $vowels_found = 0;\n  \
    \  my $consonants_found = 0;\n    my $i = length($word) - 1;\n    \n    # Get\
    \ the last vowel\n    my $last_vowel = substr($word, $i, 1);\n    \n    # Get\
    \ the first consonant\n    my $first_consonant = substr($word, 0, 1);\n    \n\
    \    # Get the second consonant\n    my $second_consonant = substr($word, 1, 1);\n\
    \    \n    # Get the first vowel before the second consonant\n    my $last_vowel_before\
    \ = substr($word, 0, $i - 1);\n    \n    # Get the first vowel after the second\
    \ consonant\n    my $last_vowel_after = substr($word, $i, 1);\n    \n    # If\
    \ the last vowel is either consonant or vowel\n    if($last_vowel eq 'c' or $last_vowel\
    \ eq 'v') {\n        \n        # Go to the last vowel before the second consonant\n\
    \        $i = $i - 1;\n        \n        # Get the vowel before the second consonant\n\
    \        my $vowel_before = substr($word, $i, 1);\n        \n        # Check if\
    \ the vowel before the second consonant is same as the second \n        # consonant.\
    \ If not, get the second consonant and check again. Repeat until \n        # you\
    \ find the second consonant.\n        while($vowel_before ne $second_consonant)\
    \ {\n            $i = $i - 1;\n            \n            # Get the vowel before\
    \ the second consonant\n            my $vowel_before = substr($word, $i, 1);\n\
    \        }\n        \n        # Check if the vowel before the second consonant\
    \ is same as the first consonant. \n        # If not, get the first consonant\
    \ and check again.\n        while($vowel_before ne $first_consonant) {\n     \
    \       $i = $i - 1;\n            \n            # Get the vowel before the second\
    \ consonant\n            my $vowel_before = substr($word, $i, 1);\n        }\n\
    \        \n        # If the last vowel is vowel, return the last vowel\n     \
    \   if($vowel_before eq 'v') {\n            return $last_vowel;\n        }\n \
    \       \n        # If the last vowel is consonant, get the last vowel before\
    \ the second consonant\n        elsif($vowel_before eq 'c') {\n            \n\
    \            # Go to the last vowel before the second consonant\n            $i\
    \ = $i - 1;\n            \n            # Get the vowel before the second consonant\n\
    \            my $vowel_before = substr($word, $i, 1);\n            \n        \
    \    # Check if the vowel before the second consonant is same as the second \n\
    \            # conson", "    my;\n    for (my $i = length($word); $i >= 0; $i--)\
    \ {\n        my $c = substr($word, $i, 1);\n        push(@vowels, $c) if $c eq\
    \ \"a\" || $c eq \"e\" || $c eq \"i\" || $c eq \"o\" || $c eq \"u\" || $c eq \"\
    y\";\n    }\n    if (scalar(@vowels)) {\n        return $vowels[lc($word) =~ tr/aeiouyaeiou/aeiou/r];\n\
    \    } else {\n        return \"\";\n    }\n}", "    my @vowels = qw(a e i o u);\n\
    \    my $first_consonant = substr($word,-1,1);\n    my $last_consonant = substr($word,0,1);\n\
    \    if ($first_consonant eq $last_consonant) {\n        return $vowels[0];\n\
    \    } elsif ($first_consonant ne 'c') {\n        return $vowels[0];\n    } else\
    \ {\n        return $vowels[1];\n    }\n}", "    my $str = $word;\n    $str =~\
    \ s/[AEIOUaeiou]+//ig;\n    if ($str =~ /[aeiou]/i) {\n        $str =~ s/^[aeiou]+//;\n\
    \        $str =~ s/[aeiou]+$//;\n        return $str;\n    }\n    return '';\n\
    }\n</code>\n<|/ a dscore=1 tags=perl,regex |>\n<| c |>\nThanks a lot for the answer.\n\
    <|/ c |>\n<| c |>\nPlease do not use `\\w` for matching letters, use `\\p{L}`\
    \ instead.\n<|/ c |>\n<| c |>\nOh, I didn't know that. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;\nuse 5.10.0;", " \
    \   my $vowl;\n    my $index = 0;\n    my $len  = length($word);\n    my $found\
    \ = 0;\n    while(!$found and $index < $len) {\n        $vowl = substr($word,\
    \ $index, 1);\n        if($vowl =~ /^[aeiouAEIOU]$/) {\n            $found = 1;\n\
    \        }\n        $index++;\n    }\n    return $vowl;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere is my solution (C++)\n<code>", "    my (@consonants,\
    \ @vowels, @ends);\n    push(@consonants, \"a\");\n    push(@consonants, \"e\"\
    );\n    push(@consonants, \"i\");\n    push(@consonants, \"o\");\n    push(@consonants,\
    \ \"u\");\n    push(@vowels, \"a\");\n    push(@vowels, \"e\");\n    push(@vowels,\
    \ \"i\");\n    push(@vowels, \"o\");\n    push(@vowels, \"u\");\n    push(@ends,\
    \ \"a\");\n    push(@ends, \"e\");\n    push(@ends, \"i\");\n    push(@ends, \"\
    o\");\n    push(@ends, \"u\");\n    return unless $word =~ /^[a-zA-Z]+$/;\n  \
    \  foreach my $con (@consonants) {\n        foreach my $vowel (@vowels) {\n  \
    \          foreach my $end (@ends) {\n                if ($word =~ /(?i:$con$vowel$end)/g)\
    \ {\n                    return $vowel;\n                }\n            }\n  \
    \      }\n    }\n    return \"\";\n}\n</cell>\n<text>\nQ. Write a program to find\
    \ and print all prime numbers till 100.\nHint: Use a prime number testing function\
    \ found on the internet. Here is a good one: ", '    my($index, $vowel, $consonant);',
  "    my@vowels =(\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\");\n\
    \    for (my $i=0; $i<(scalar(@vowels)-1); $i++) {\n        my($consonant,$vowel)=split(//,\
    \ $vowels[$i], 2);\n        if ($word =~ /$vowel/) {\n            my $index=$i+1;\n\
    \            while (@vowels[$index] && $vowels[$index][0]=~/[aeiou]/) {\n    \
    \            $index++;\n            }\n            if ($vowels[$index]) {\n  \
    \              return $vowels[$index];\n            }\n        }\n    }\n    return\
    \ '';\n}", "    $word =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    return $word if $word\
    \ =~ /^[aeiou]+$/;\n    return '';\n}\n</code>\n<|/ a dscore=1 tags=perl,algorithm\
    \ |>\n<| c |>\nThis is a great solution, thanks! I tested both solutions in Perl\
    \ and they both work great for me. Thanks a lot!\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "    my $vowel;\n    my $consonant_range = $word->[0] . ':' . $word->[-1];\n\
    \    $vowel = $word->[substr $consonant_range,-1];\n    return $vowel;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like that idea, but i think it only works if the\
    \ word is exactly one letter long\n<|/ c |>\n<| c |>\nYeah, I realize that now.\
    \ I'll probably edit my answer, but I think I'm going to go ahead and post it\
    \ anyways, because I'm curious what the best way to solve this problem would be.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis is my solution. It is not the most elegant solution\
    \ but it works:\n<code>\nuse strict;\nuse warnings;", "    return $word if $word\
    \ =~ /^[a-z]+$/i;\n    return undef if $word =~ /^[aeiouy]+$/;\n    my $vowel\
    \ = \"a\" if ($word =~ /[aeiouy]$/);\n    my $vowel_count = 0;\n    my $i = 0;\n\
    \    for my $consonant (split //, $word) {\n        $i++;\n        if ($consonant\
    \ eq $vowel) {\n            $vowel_count++;\n        }\n        if ($i == length($word)\
    \ - 1) {\n            last if ($vowel_count == 0);\n        }\n    }\n    return\
    \ undef if ($vowel_count == 0);\n    return $vowel;\n}", "    my $result = \"\"\
    ;\n    my $vowels = \"aeiouAEIOU\";\n    my $count = -1;\n    my $prevLetter =\
    \ \"\";\n    for my $i (0..$#{$word}) {\n        if ($i > 0) {\n            my\
    \ $letter = substr($word, $i, 1);\n            if ($prevLetter ne \"\") {\n  \
    \              if ($letter eq $prevLetter) {\n                    $count++;\n\
    \                }\n            }\n        }\n        $prevLetter = $letter;\n\
    \    }\n    if ($prevLetter ne \"\") {\n        if ($count < 1) {\n          \
    \  return \"\";\n        }\n        $result = $vowels[$count % length($vowels)];\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,perl\
    \ dscore=0 |>\n<code>", "    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"y\");\n    for (my $i = length($word) - 2; $i >= 0; $i -= 1) {\n        next\
    \ unless $word[$i] =~ /^[aeiouy]/i;\n        return $word[$i] if $word[$i] eq\
    \ $vowels[@vowels-1]\n    }\n    return \"\";\n}", "    return $word unless $word\
    \ =~ /[a-z]+/;\n    my(@vowels) = (\"a\" .. \"z\");\n    my(@consonants) = (\"\
    b\" .. \"z\");\n    my $result = \"\";\n    my $index = 0;\n    foreach my $consonant\
    \ (@consonants) {\n        my $position = $word[$index];\n        if ($consonant\
    \ eq \"z\") {\n            $index++;\n        }\n        if ($position eq $consonant)\
    \ {\n            $result .= $consonant;\n        } elsif ($position > $consonant)\
    \ {\n            $index++;\n        }\n        if ($index >= length($word)) {\n\
    \            break;\n        }\n    }\n    return $result;\n}", "    my($consonant);\n\
    \    my($vowel);\n    my(@vowels);\n    my($consonant2, $vowel2);\n    my($i,\
    \ $j, $length) = length($word);\n    my($dist);\n    my($vowel_distance);", '    my
    $vowels = "aeiou";', "    my @vowel = qw(u A E O I Y);\n    my ($min, $max) =\
    \ (0, 0);\n    foreach my $v (@vowel) {\n        ($min, $max) = ($min, $max) if\
    \ ($word =~ /^$v$/i);\n        ($min, $max) = ($max, $min) if ($word =~ /\\b$v\\\
    b/i) or \n                                    $word =~ /\\b$v\\b\\b.*\\b$v/i;\n\
    \    }\n    if ($max > 0) {\n        my $pos = length($word) - 1;\n        $pos\
    \ -= 1 if ($word[$pos] eq \"g\");\n        return $vowel[$min] if ($min < $pos);\n\
    \    }\n    return '';\n}\n</code>\n<|/ a dscore=1 tags=perl,regex |>\n<| a |>\n\
    The code can be written a bit more compactly than it was:\n<code>", "    $word\
    \ =~ tr/aeiouAEIOU//cd;\n    $word =~ tr/bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ//cd;\n\
    \    my $vowel = \"\";\n    if ($word =~ /[aeiou]/) {\n        return $vowel;\n\
    \    }\n    if ($word =~ /[bcdfghjklmnpqrstvwxyz]/) {\n        $vowel = $word;\n\
    \    }\n    return $vowel;\n}", "    my($idx) = @$word{0..$#word} - 1;\n    my($vowel)\
    \ = @$vowels{'a'..'z'};\n    my($idx2) = @$word{0..$#word} - 1;\n    my($consonant)\
    \ = @$consonants{'a'..'z'};\n    $vowel = substr($word, $idx, 1);\n    $consonant\
    \ = substr($word, $idx2, 1);\n    while(($idx >= 0) && ($idx2 < $#word) && ($consonant\
    \ = substr($word, $idx2, 1))) {\n        $idx2 = $idx2 - 1;\n        while(($idx\
    \ >= 0) && ($consonant = substr($word, $idx, 1))) {\n            ($idx == $idx2)\
    \ ? return $vowel : return \"\";\n            $idx = $idx - 1;\n        }\n  \
    \      $idx2 = $idx2 + 1;\n    }\n}\n</code>\n<|/ a tags=perl dscore=0 |>\n<|\
    \ c |>\nI tried to run this code, it says- `Use of uninitialized value $consonant\
    \ in concatenation (.) or string at solution.pl line 14, <STDIN> line 1.\nUse\
    \ of uninitialized value $vowel in concatenation (.) or string at solution.pl\
    \ line 15, <STDIN> line 1.` How do I initialize them ?\n<|/ c |>\n<| c |>\nYou\
    \ have to initialze them before you use them. `$consonant` and `$vowel` should\
    \ be set to `\"\"` and `\"\"` respectively.\n<|/ c |>\n<| c |>\nI've updated the\
    \ answer to show how it should be done.\n<|/ c |>\n<| a |>\nHere's another option.\
    \  Use a hash to track the count of consonants and vowels.  Keep track of the\
    \ current count and when you encounter a vowel, return the previous vowel you\
    \ saw.  Otherwise, if the count is > 0, return the most recent vowel you saw.\n\
    <code>\nuse strict;\nuse warnings;", "    my @vowels = ('a', 'e', 'i', 'o', 'u');\n\
    \    my @cons = (\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\");\n    my @cons_len = (2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3);\n    my @cons_idx = (0, 0, 0, 0, 0, 0, 0, 1, 1,\
    \ 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3);\n    my $i = 0;\n\
    \    foreach my $idx (0 .. $#cons) {\n        if ($cons_len[$idx] <= length($word)\
    \ - 1) {\n            my $cons_idx = $cons_idx[$idx];\n            $cons_idx++\
    \ if ($cons_idx == (@cons - 1));\n            $vowels[$cons_idx] eq 'a' or\n \
    \           $vowels[$cons_idx] eq 'e' or\n            $vowels[$cons_idx] eq 'i'\
    \ or\n            $vowels[$cons_idx] eq 'o' or\n            $vowels[$cons_idx]\
    \ eq 'u' or \n            $cons[$idx] eq 'l' or\n            $cons[$idx] eq 'y'\
    \ or\n            $cons[$idx] eq 's' or\n            $cons[$idx] eq 'z';\n   \
    \     }\n    }\n    $vowels[$i] || \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=algorithm,perl,python |>\n<code>\ndef vowels_in_reverse_order(word):\n\
    \    vowels = ['a','e','i','o','u']\n    for letter in reversed(word):\n     \
    \   if letter in vowels:\n            return letter\n    return ''\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef checkWord(word):\n    vowels\
    \ = ['a','e','i','o','u']\n    word = word[::-1]\n    for letter in word:\n  \
    \      if letter in vowels:\n            return letter\n    return ''\n</code>\n\
    <|/ a tags=algorithm,perl,python |>\n<| c |>\nPlease add some explanation to your\
    \ answer\n<|/ c |>\n<| a tags=algorithm,perl,python dscore=0 |>\n<code>\ndef checkWord(word):\n\
    \    vowels = ['a','e','i','o','u']\n    word = word[::-1]\n    i = 0\n    for\
    \ letter in word:\n        if letter in vowels:\n            i += 1 \n       \
    \ if i == len(vowels):\n            return ", "    my (@vowels, $min_index);\n\
    \    for my $i (0..length($word) - 1) {\n        next if $word[$i] eq 'a' || $word[$i]\
    \ eq 'e' || $word[$i] eq 'i' || $word[$i] eq 'o' || $word[$i] eq 'u';\n      \
    \  push @vowels, $word[$i] if $word[$i] eq 'a' || $word[$i] eq 'e' || $word[$i]\
    \ eq 'i' || $word[$i] eq 'o' || $word[$i] eq 'u';\n    }\n    for (my $i = 0;\
    \ $i < @vowels; $i++) {\n        my $min_index = $i;\n        for my $j ($i +\
    \ 1; $j < @vowels; $j++) {\n            last if $vowels[$i] > $vowels[$j];\n \
    \           $min_index = $j if $vowels[$i] == $vowels[$j] && $min_index < $i ||\
    \ $min_index == $i && $min_index < $j;\n        }\n        last if $min_index\
    \ == $i;\n        return $vowels[$i] if $min_index >= 0 and $min_index < @vowels;\n\
    \    }\n    return \"\";\n}", "    my $index = 0;\n    my $vowel_begin = \"a\"\
    ;\n    my $vowel_end = \"z\";\n    my $last_consonant = substr($word,$index,1);\n\
    \    while($index <= length($word) - 1) {\n        my $consonant = substr($word,$index,1);\n\
    \        if ($consonant eq $last_consonant) {\n            if ($last_consonant\
    \ eq $vowel_begin) {\n                $index++;\n                last if (substr($word,$index,1)\
    \ eq $vowel_end);\n            }\n            else {\n                $index++;\n\
    \                last if (substr($word,$index,1) eq $vowel_begin);\n         \
    \   }\n        }\n        $index++;\n        $last_consonant = $consonant;\n \
    \   }\n    return \"\";\n}", "    my($consonants) = qw(a e i o u);\n    my(@vowels)\
    \ = qw(a e i o u);\n    \n    my $vowel = 0;\n    \n    foreach my $consonant\
    \ (@$consonants) {\n        if (index($word, $consonant) > -1) {\n           \
    \ $vowel += 1;\n        }\n    }\n    \n    foreach my $vow (@vowels) {\n    \
    \    if (index($word, $vow) > -1) {\n            $vowel += 1;\n        }\n   \
    \ }\n    \n    if ($vowel == 0) {\n        return '';\n    }\n    \n    my $index\
    \ = 0;\n    \n    while (index($word, $vowels[$index]) < 0) {\n        $index++;\n\
    \    }\n    \n    my $vowel = substr($word, -$index, 1);\n    \n    return $vowel;\n\
    }", "    my $vowels = \"aeiouAEIOU\";\n    for my $i ( 0 .. length($word) - 1\
    \ ) {\n        my $letter = $word[$i];\n        for my $v ( 0 .. length($vowels)\
    \ - 1 ) {\n            if ( $letter eq substr( $vowels, $v, 1 ) ) {\n        \
    \        return $v;\n            }\n        }\n    }\n    return \"\";\n}", " \
    \   my $char = \"\";\n    my $vowels_end = $word=~s/[AEIOUaeiou]$//;\n    my $consonants\
    \ = $word=~s/[^bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]//g;\n    if($vowels_end\
    \ >= 1){\n        # loop through the word\n        my $vowels_begin = $word=~s/^[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]//g;\n\
    \        for my $c (split //, $consonants){\n            if($c == substr($word,$vowels_end,1)){\n\
    \                if($c eq \"y\"){\n                    $char = \"A\";\n      \
    \          } elsif($c eq \"o\"){\n                    $char = \"U\";\n       \
    \         } elsif($c eq \"e\"){\n                    $char = \"E\";\n        \
    \        } elsif($c eq \"i\"){\n                    $char = \"I\";\n         \
    \       } elsif($c eq \"a\"){\n                    $char = \"A\";\n          \
    \      } elsif($c eq \"u\"){\n                    $char = \"U\";\n           \
    \     }\n                $vowels_end = $vowels_end - 1;\n            }\n     \
    \   }\n    }\n    return $char;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>",
  "    \n    for (my $i = length($word) - 2 ; $i >= 0 ; $i--){\n        if ($word[$i]\
    \ eq \"A\"or\"$word[$i] eq \"E\"or\"$word[$i] eq \"I\"or\"$word[$i] eq \"O\"or\"\
    $word[$i] eq \"U\"or\"$word[$i] eq \"Y\"or\"$word[$i] eq \"a\" or\"$word[$i] eq\
    \ \"e\" or\"$word[$i] eq \"i\" or\"$word[$i] eq \"o\" or\"$word[$i] eq \"u\")\
    \ {\n            return \"$word[$i]\";\n        }\n    }\n    \n    return \"\"\
    ;\n}", "    my($vowel) = '';\n    my($consonants) = split('[^aeiou]', $word);\n\
    \    my(@results);", "    my $vowels = \"aeiouAEIOU\";\n    my $vowels_index =\
    \ index($vowels, $word[-1]);\n    my $vowels_length = length($vowels);\n    my\
    \ $last_consonant_index = index($word, -2, \"bcdfghjklmnpqrstvwxyz\");\n    my\
    \ $last_consonant_length = length($word[-2..$last_consonant_index]);\n    my $vowel_length\
    \ = length($word[$vowels_index..$vowels_length]);\n    my $vowel_start_pos = $vowels_index\
    \ + $vowel_length;\n    my $vowel_end_pos = $vowels_index - $vowel_length;\n \
    \   my $consonant_start_pos = $last_consonant_index + $last_consonant_length;\n\
    \    my $consonant_end_pos = $last_consonant_index - $last_consonant_length;\n\
    \    my $consonant_length = length($word[$consonant_start_pos..$consonant_end_pos]);\n\
    \    my $consonant_index = index($word, $word[$consonant_start_pos..$consonant_end_pos],\
    \ \"bcdfghjklmnpqrstvwxyz\");\n    my $vowel_position = $consonant_index - $consonant_length;\n\
    \    my $closest_vowel = $vowels[$vowel_position];\n    return $closest_vowel;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis code snippet is not correct. It will get wrong\
    \ vowels in the last consonant. Example: get_closest_vowel(\"ab\") returns \"\
    a\" instead of \"a\". Also, I don't think this algorithm is correct, as it returns\
    \ \"a\" instead of \"u\" for \"ab\". I'm guessing you forgot to account for the\
    \ last consonant?\n<|/ c |>\n<| c |>\nYou're right, thanks for the heads up. I\
    \ didn't take into account the last consonant because it's not needed. I corrected\
    \ my code now. Thanks.\n<|/ c |>\n<| a tags=perl,string |>\nIf you can use List::MoreUtils::any:\n\
    <code>", "    my();\n    $word =~ s/[[:upper:]]/-/g;\n    $word =~ s/([aeiouy])/$1-/g;\n\
    \    $word =~ s/-$//;\n    $word =~ s/-/|/;\n    $word =~ s/-$/|/;\n    my $start\
    \ = $word;\n    $start =~ s/^-|-|/;\n    $start =~ s/-$//;\n    $start =~ s/-|-/|/;\n\
    \    my $end = $word;\n    $end =~ s/^-|-|/;\n    $end =~ s/-$//;\n    $end =~\
    \ s/-|-/|/;\n    my ($vow) = grep{/^\\Q$start\\E$/i && /^\\Q$end\\E$/i}keys %Vowels;\n\
    \    return $vow || \"\";\n}\n</code>\n<|/ a dscore=3 tags=perl,string,regex,replace\
    \ |>\n<| c |>\nThe regexp for the vowel is wrong, it fails on \"U\" where it's\
    \ expecting \"u\".\n<|/ c |>\n<| c |>\nSure it fails, because you are using `/`\
    \ in the pattern, but you are actually using regex delimiters.\n<|/ c |>\n<| c\
    \ |>\nYou are right, I have updated my answer and tested it on a bunch of test\
    \ cases and it works.\n<|/ c |>\n<| c |>\n+1 for the effort. Unfortunately, this\
    \ doesn't work. I don't know why, because all I see is \"u\" as output.\n<|/ c\
    \ |>\n<| c |>\nThe code works now. Now I am curious what the test cases where\
    \ it fails.\n<|/ c |>\n<| a |>\nYou can try this - \n<code>", '    my $vowel =
    "AEIOUaeiouy";', "    my(@consonants) = qw(aah aei ao oa ou ow uw uu);\n    foreach\
    \ my $c (@consonants) {\n        if (substr($word, 0, -1) == $c) {\n         \
    \   return $c;\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=string,perl,regex,substring |>\nA simple non-regex solution:\n<code>\n\
    $word =~ m/(?<!\\A)(?=\\w)a(?!\\w)(?<!\\z)(?!\\z)\\b/i\n</code>\nThe idea is to\
    \ match a word boundary if and only if the word does not start with something\
    \ but ends with something else.  This is a little tricky because the look arounds\
    \ are anchored at the beginning and end of the string, not just before and after\
    \ a character.  We also use a negative look ahead (a negative look behind) to\
    \ ensure that there is only one a in the word.  Then, we use the \\w meta-character\
    \ to match any word character (including non-alpha characters).\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\nmy $str = \"abcc\";\nmy $consonants = qw ( a b\
    \ c d e f g h i j k l m n o p q r s t v w x y z );\nmy $vowels = qw ( a e i o\
    \ u );", "    my;\n    my($c1, $c2) = split(//, $word);\n    foreach my $i (0..@{$c1})\
    \ {\n        my($c3, $c4) = split(//, $c1[$i]);\n        if ($c3 =~ m/^[aeiouAEIOU]{2}$/\
    \ && $c4 =~ m/^[aeiouAEIOU]{2}$/) {\n            push, $i;\n        }\n    }\n\
    \    my $vowel = shift(@vowels);\n    last unless ($vowel);\n    return $vowel;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWow, I can't believe I didn't think of\
    \ that sooner. Thank you so much!\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndef vowels(word):\n\
    \    vowel = sorted([x for x in word if x in 'aeiouAEIOU'])\n    return vowel[0]\
    \ if vowel and vowel.index(vowel[-1]) + 1 == len(vowel) else ''\n</code>\n<|/\
    \ a tags=python |>\n<| c |>\nPlease don't post only code as answer, but also provide\
    \ an explanation what your code does and how it solves the problem of the question.\
    \ Answers with an explanation are usually more helpful and of better quality,\
    \ and are more likely to attract upvotes.\n<|/ c |>\n<| c |>\nThank you. I am\
    \ new to coding and I did not think of adding an explanation to my code, so I\
    \ thought I could leave it in a comment. Now that I understand that I can do that\
    \ I'll add it as an answer.\n<|/ c |>\n<| a dscore=0 |>\nUsing Regex:\n<code>\n\
    import re", "    $word =~ tr/a-zA-Z//cd;\n    my(@vowels) = (\n        \"a\",\n\
    \        \"e\",\n        \"i\",\n        \"o\",\n        \"u\",\n        \"y\"\
    ,\n        \"a\",\n        \"e\",\n        \"i\",\n        \"o\",\n        \"\
    u\",\n        \"y\"\n    );\n    my($closest_vowel);\n    $closest_vowel = undef;\n\
    \    my($i); # iterator\n    foreach $i (0 .. length($word) - 1) {\n        $closest_vowel\
    \ = $vowels[$i] if $word[$i] =~ /[aeiou]/;\n        if ($closest_vowel eq undef)\
    \ {\n            last;\n        }\n    }\n    return $closest_vowel;\n}", "  \
    \  my$vowels = \"aeiouAEIOU\";\n    my $vowel_pos = -1;\n    my $prev_vowel_pos\
    \ = -1;\n    my $prev_word = \"\";\n    for my $i (0 .. length($word) - 1) {\n\
    \        my $vowel_pos = index($vowels, $word[$i]);\n        if ($vowel_pos ==\
    \ -1) {\n            my $prev_word = substr($word, 0, $i);\n            my $prev_vowel_pos\
    \ = index($vowels, $prev_word);\n            if ($prev_vowel_pos == -1) {\n  \
    \              last;\n            }\n            else {\n                $vowel_pos\
    \ = $prev_vowel_pos;\n            }\n        }\n        if ($vowel_pos > $prev_vowel_pos)\
    \ {\n            $prev_vowel_pos = $vowel_pos;\n            $prev_word = $word;\n\
    \        }\n    }\n    if ($prev_vowel_pos > $vowel_pos) {\n        return \"\"\
    ;\n    }\n    my $first_vowel = substr($word, $vowel_pos + 1);\n    if (lc($first_vowel)\
    \ eq \"u\") {\n        return \"U\";\n    }\n    else {\n        return \"u\"\
    ;\n    }\n}", "    my @vowels = (\n        \"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"y\",\n        \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"\n    );\n    foreach\
    \ my $v (@vowels) {\n        if ($word=~m/[${v}][bdfhjklmnpqrstvwxyzBCDFHJKLMNPQRSTVWXYZ]{0,1}[${v}]/)\
    \ {\n            $_ = $v;\n            exit;\n        }\n    }\n    return \"\"\
    ;\n}", "    my (@vowel);\n    my $c = 0;\n    foreach my $v (@vowel) {\n     \
    \   $word = $word =~ s/$v/$c++/rse;\n    }\n    my $l = length($word);\n    foreach\
    \ my $i (0..$l-1) {\n        if ( $word[$i] eq 'a' ) {\n            $vowel[0]\
    \ = $word[$i];\n        }\n        if ($word[$i] eq 'e' ) {\n            $vowel[1]\
    \ = $word[$i];\n        }\n        if ($word[$i] eq 'i' ) {\n            $vowel[2]\
    \ = $word[$i];\n        }\n        if ($word[$i] eq 'o' ) {\n            $vowel[3]\
    \ = $word[$i];\n        }\n        if ($word[$i] eq 'u' ) {\n            $vowel[4]\
    \ = $word[$i];\n        }\n    }\n    return $vowel[0] if(@vowel);\n    return\
    \ '';\n}", "    my(@consonants) = qw/a e i o u y a/;\n    my(@vowels) = qw/a e\
    \ i o u/;\n    my(@vowels2) = qw/a e i o u/;\n    \n    foreach my $consonant\
    \ (@consonants) {\n        return \"\" if index($word, $consonant) != 0;\n   \
    \ }\n    \n    foreach my $vowel (@vowels) {\n        return \"\" if index($word,\
    \ $vowel) != 0;\n    }\n    \n    foreach my $vowel2 (@vowels2) {\n        return\
    \ \"\" if index($word, $vowel2) != 0;\n    }\n    \n    return \"\";\n}", "  \
    \  $word =~ tr/aeiouAEIOUaeiou/AEIOUaeiouAEIOU/i;\n    return if $word =~ /^./;\n\
    \    return $word =~ /^([aeiou])\\1([^aeiou]+)$/i ? $2 : \"?\";\n}", "    my $found_vowel\
    \ = \"\";\n    my $vowels = \"AEIOUaeiou\";\n    foreach my $v (split(//, $vowels))\
    \ {\n        my $len = length($word);\n        my $idx = 0;\n        while ($idx\
    \ < $len) {\n            my $w = $word[$idx];\n            if ($w eq $v) {\n \
    \               $found_vowel = $v;\n                last;\n            }\n   \
    \         $idx++;\n        }\n    }\n    return $found_vowel;\n}", "    my(@vowels)\
    \ = ('a','e','i','o','u');\n    my $len = length $word;\n    my(@vowels_start);\
    \ # vowels start position\n    my(@vowels_end);   # vowels end position\n    my($vowel);\n\
    \    my $i;\n    my $j = -1;\n    for ($i = 0; $i < $len; $i++) {\n        if\
    \ ( $word[$i] eq $vowels[$j] ) {\n            $j++;\n        }\n        else {\n\
    \            push (@vowels_start, $i);\n            push (@vowels_end, $i);\n\
    \            $j = -1;\n        }\n    }\n    my $min_vowel = -1;\n    my $min_dist\
    \ = 0;\n    my $min_dist_pos = -1;\n    for ($i = 0; $i < $len; $i++) {\n    \
    \    my $j = -1;\n        for ($j = 0; $j < $len; $j++) {\n            my $is_vowel\
    \ = ( $word[$i] eq $vowels[$j] );\n            if ( $j >= $vowels_start[$i] )\
    \ {\n                if ( $j < $vowels_end[$i] ) {\n                    if ( $is_vowel\
    \ ) {\n                        $min_dist = $i;\n                        $min_dist_pos\
    \ = $j;\n                        $min_vowel = $is_vowel ? $j : $i;\n         \
    \               last;\n                    }\n                }\n            }\n\
    \            $j++;\n        }\n    }\n    if ( $min_dist > -1 ) {\n        return\
    \ $word[$min_dist];\n    }\n    return \"\";\n}", "    return \"\" unless $word\
    \ =~ /^[A-Za-z]+$/;\n    return $word =~ /([^aeiouy]+)(?![aeiouy]([^aeiouy]+))/\
    \ ? $1 : \"\";\n}", "    $word =~ tr/a-zA-Z//;\n    my $count = 0;\n    my $vowel;\n\
    \    for my $i (0 .. length($word) - 1) {\n        my $c = substr($word, $i, 1);\n\
    \        last if $c !~ /[aeiou]/i;\n        $count += 1;\n        next unless\
    \ $c =~ /[aeiou]/i;\n        my $lpos = $i + 1;\n        for my $j ($i + 1 ..\
    \ length($word)) {\n            my $c2 = substr($word, $j, 1);\n            last\n\
    \                if $c2 !~ /[aeiou]/i;\n            my $rpos = $j - 1;\n     \
    \       my $d = distance($word[$i], $word[$lpos], $word[$rpos], $word[$i]);\n\
    \            if ($d < 0) {\n                $d = abs($d);\n                if\
    \ ($d < $count && $d > 1) {\n                    $count = $d;\n              \
    \      $vowel = $c;\n                }\n            }\n            $j--;\n   \
    \     }\n    }\n    $vowel ? $vowel : \"\";\n}", "    my($vowel_start);\n    my($vowel_end);\n\
    \    my($consonant_start);\n    my($consonant_end);\n    my($closest_vowel);",
  "    \n    my @vowels = qw(a e i o u);\n    my $vowel_found = 0;\n    my $vowel_index\
    \ = -1;\n    \n    my $first_consonant_index = 0;\n    for my $index (0..strlen($word)\
    \ - 1) {\n        $first_consonant_index = $index;\n        if ( $word[$index]\
    \ =~ /[AEIOU]/i ) {\n            $vowel_found = 1;\n            $vowel_index =\
    \ $index;\n            last;\n        }\n    }\n    \n    if ( !$vowel_found )\
    \ {\n        return \"\";\n    }\n    \n    for ( $vowel_index + 1; $vowel_index\
    \ < $first_consonant_index; $vowel_index++ ) {\n        if ( $word[$vowel_index]\
    \ =~ /[AEIOU]/i ) {\n            return $vowels[$vowel_index];\n        }\n  \
    \  }\n    return \"\";\n}", "    return undef if length($word) == 0;\n    my @vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my $i = 0;\n    while ($i\
    \ < length($word) && $word[$i] =~ /[aeiou]/) {\n        $i = $i + 1;\n    }\n\
    \    my $v1 = substr($word, $i - 1, 0, 1);\n    my $v2 = substr($word, $i, 1,\
    \ 1);\n    return undef if $v1 eq $v2;\n    return $vowels[$v1];\n}\n</code>\n\
    <|/ a tags=regex,perl |>\n<| c |>\nApart from that missing `'` for the subroutine\
    \ name and missing semicolons `$word[$i] =~ /[aeiou]/` is still missing a `'`.\
    \ I think that should be `$word[$i] =~ /[aeiou]'/`.\n<|/ c |>\n<| c |>\n: I edited\
    \ my answer. Thank you for pointing that out.\n<|/ c |>\n<| a tags=regex,perl\
    \ dscore=0 |>\n<code>\nuse strict;\nuse warnings;", "    my $vowels_re = qr{\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}\n\
    \        [aeiouyY]{2}\n        [aeiouyY]{2}\n        [aeiouyY]{2}", "    my($end)\
    \ = reverse $word;\n    my($vowel) = \"\";\n    my($index);\n    \n    for my\
    \ $index (0 .. length($end) - 1) {\n        chomp($vowel = $end[$index]);\n  \
    \      if ($vowel =~ /[aeiou]/ && $vowel eq $end[$index+1]) {\n            last\
    \ if ($index == 0);\n            return $vowel;\n        }\n    }\n    return\
    \ $vowel;\n}\n</cell>\n<text>\nQuestion 2.3: Create a function which will remove\
    \ all vowels from the given string and return only alphabetic characters.", " \
    \   \n    $word =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    my $vowel = $1;\n    \n   \
    \ my $consonant = \"[b-df-hj-np-tv-z]\";\n    my $consonant_start = reverse $consonant;\n\
    \    my $consonant_end = reverse $consonant.\"A\";\n    my $consonant_index =\
    \ 0;\n    my $vowel_index = 0;\n    \n    while ($consonant_index <= length($consonant_start)\
    \ and $vowel_index <= length($vowel)) {\n        if substr($consonant_start, $consonant_index,\
    \ 1) eq $vowel {\n            $consonant_index++;\n        }\n        else {\n\
    \            $vowel_index++;\n        }\n    }\n    \n    return \"\" unless $consonant_index\
    \ > length($consonant_start) and $vowel_index > length($vowel);\n    \n    return\
    \ substr($vowel, 0, $vowel_index);\n}\n</code>\n<|/ a tags=regex,perl,pattern-matching,substring\
    \ dscore=2 |>\n<| a tags=regex,perl,pattern-matching,substring |>\nThis approach\
    \ uses tr/// to reverse the word and scan it for vowels. At the end we just need\
    \ to reconstruct the original string.\n<code>", "    my($i, $vowel, $vowel_count);\n\
    \    my($last_consonant, $last_consonant_count);\n    my(@vowels) = (\"a\", \"\
    e\", \"i\", \"o\", \"u\");\n    my($first_consonant, $first_consonant_count);\n\
    \    my($consonants, $consonant_count);\n    $vowel_count = 0;\n    $vowel = \"\
    a\";\n    $last_consonant_count = 0;\n    foreach $first_consonant (split //,\
    \ $word) {\n        $first_consonant_count++;\n        if ($vowel =~ $first_consonant)\
    \ {\n            $vowel_count++;\n            $vowel = $first_consonant;\n   \
    \     }\n        if ($last_consonant_count < $first_consonant_count) {\n     \
    \       $last_consonant_count = $first_consonant_count;\n            $last_consonant\
    \ = $first_consonant;\n        }\n    }\n    foreach $consonants (split //, $word)\
    \ {\n        $consonant_count++;\n        if ($consonant_count >= $last_consonant_count)\
    \ {\n            return $vowel;\n        }\n        $vowel_count++;\n    }\n \
    \   return \"\";\n}\n</code>\n<|/ a tags=perl,substitution,regex |>\n<| a dscore=1\
    \ |>\nIn short, my answer uses Perl's /e modifier to evaluate the regex inside\
    \ the string without creating a subroutine and without using any loops. It is\
    \ designed to work with a string without newlines.\n<code>\nuse strict;\nuse warnings;",
  "    $word =~ tr/A-Z/a-z/;\n    my(@consonants);\n    $word =~ /[bcdfghjklmnpqrstvwxyz]/;\n\
    \    my($i, $prev, $dist);\n    for (my $i = 0; $i < length($word); $i++) {\n\
    \        my($consonant, $dist, $prev) = \"\";\n        if ($consonants[$i] ==\
    \ \"\") {\n            die \"Error: no vowels found in this word (string length\
    \ less than 3)!\" if length($word) < 3;\n            $consonants[$i] = $word[$i];\n\
    \        } elsif ($consonants[$i] != $word[$i]) {\n            $consonants[$i]\
    \ = $word[$i];\n        }\n        for (my $j = 0; $j < length($word); $j++) {\n\
    \            if ($j != $i) {\n                my $w = $word[$j];\n           \
    \     $w = $word[$j] if $w =~ /^[A-Z]$/i;\n                if ($consonants[$j]\
    \ == $consonants[$i]) {\n                    $dist++;\n                }\n   \
    \             if ($prev ne $consonants[$j] && $prev != \"\") {\n             \
    \       $dist = $dist + 1 if $dist < $prev;\n                }\n             \
    \   $prev = $dist;\n                $consonants[$j] = $word[$j];\n           \
    \ }\n        }\n    }\n    $prev = $dist;\n    for (my $i = length($word) - 2;\
    \ $i >= 0; $i--) {\n        if ($word[$i] eq $consonants[0] && $prev > $dist)\
    \ {\n            substr($word, $i, 1) = \"\";\n        } elsif ($word[$i] eq $consonants[1]\
    \ && $prev > $dist) {\n            substr($word, $i, 1) = \"\";\n        }\n \
    \       $prev = $dist;\n    }\n    $word = $word;\n    return $word if $word[0]\
    \ =~ /^[A-Z]/;\n    return \"\";\n}", "    my @vowel = qw(a e i o u);\n    for\
    \ (my $i = length($word) - 2; $i >= 0; $i--) {\n        return $word[$i] if $word[$i]\
    \ eq $vowel[0];\n    }\n    return \"\";\n}", "    $word =~ tr/A-Za-z//cd;\n \
    \   my $first;\n    my $second;\n    my $closest;\n    $first = $word;\n    $second\
    \ =~ s/$word//;\n    $closest = chr(ord($word) -33);\n    while (1) {\n      \
    \  last if $first eq $second;\n        if ($first eq $second) {\n            return\
    \ $closest;\n        }\n        if ($first =~ /[aeiou]/) {\n            if ($closest\
    \ eq chr(ord($first) - 3)) {\n                $closest = $word;\n            }\n\
    \            else {\n                $closest = $word;\n            }\n      \
    \  }\n        else {\n            if ($closest eq chr(ord($first) - 1)) {\n  \
    \              $closest = $word;\n            }\n            else {\n        \
    \        $closest = $word;\n            }\n        }\n        $first = $second;\n\
    \        $second =~ s/$word//;\n    }\n    return $closest;\n}", "    my @vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\");\n    my $vowel;\n    \n    for (my $i\
    \ = length($word) - 2; $i >= 0; $i--) {\n        if ($word[$i] =~ /[AEIOUaeiou]/)\
    \ {\n            $vowel = $word[$i];\n        }\n    }\n    \n    return $vowel\
    \ if $vowel && $vowel !~ /[^aeiou]/;\n    return '';\n}\n</code>\n<|/ a dscore=1\
    \ tags=perl,regex |>\n<| c |>\nNote that you shouldn't use `/aEiou/` as the pattern.\
    \ Perl regexes don't recognize a character class like that, it's just a pattern\
    \ that matches one of the letters aeiou. If you wanted to *match* one of the letters\
    \ aeiou, you would have used `/[aeiou]/`. `/aEiou/` means match \"a\", then match\
    \ \"E\", then match \"i\", then match \"o\", then match \"u\", then match \"E\"\
    , then match \"i\", then match \"o\", and match \"u\". That means \"aeiou\" will\
    \ be matched, too.\n<|/ c |>\n<| a tags=perl,regex |>\nFor this problem, it is\
    \ better to use a different regex expression and to match any letter in the range\
    \ a-z or A-Z at the end using ^ and $ as follows:\n<code>\nuse strict;\nuse warnings;\n\
    use feature 'say';", "    $word =~ tr/A-Za-z//;\n    $word =~ tr/aeiouy//;\n \
    \   $word =~ tr/aeiouAEIOUy//;\n    my $vowel = substr($word, length($word)-2,\
    \ 1);\n    my $consonant = substr($word, length($word)-1, 1);\n    my $result\
    \ = \"\";\n    if ($consonant ne \"y\") {\n        my $consonant_pos = $consonant\
    \ == \"z\" ? length($word)-2 : 0;\n        $result .= substr($word, $consonant_pos,\
    \ 1);\n    }\n    elsif ($consonant ne \"Z\") {\n        my $consonant_pos = $consonant\
    \ == \"z\" ? length($word)-2 : length($word)-1;\n        $result .= substr($word,\
    \ $consonant_pos, 1);\n    }\n    elsif ($consonant eq \"Z\") {\n        $result\
    \ .= substr($word, 1, 1);\n    }\n    else {\n        $result .= $word;\n    }\n\
    \    if ($vowel eq \"a\") {\n        $result .= \"A\";\n    }\n    elsif ($vowel\
    \ eq \"e\") {\n        $result .= \"E\";\n    }\n    elsif ($vowel eq \"i\") {\n\
    \        $result .= \"I\";\n    }\n    elsif ($vowel eq \"o\") {\n        $result\
    \ .= \"O\";\n    }\n    elsif ($vowel eq \"u\") {\n        $result .= \"U\";\n\
    \    }\n    return $result;\n}", "    my @vowels = qw(A E I O U); # Assume only\
    \ English letter here\n    my $result = '';\n    for (my $i = length($word) -\
    \ 2; $i >= 0; $i-=2) {\n        if ($word[$i] eq $vowels[0]) {\n            my\
    \ $start = $i;\n            for my $v (@vowels) {\n                $result .=\
    \ $v if ($word[$start] eq $v);\n                $start -= 1;\n            }\n\
    \        }\n    }\n    return $result if $result;\n    return '';\n}", "    \n\
    \    $word =~ tr/a-z/A-Z/;", "    $word =~ s/\\W//g;\n    my $first_vowel_after\
    \ = $word;\n    my $last_vowel_before = $word;\n    while (length($word)) {\n\
    \        my $vowel = substr($word, 0, 1);\n        next if $vowel eq '_';\n  \
    \      next if $vowel =~ m/[aeiouAEIOU]/i;\n        my $before_vowel_start = $word\
    \ =~ m/\\Q$vowel\\E[^\\Q$vowel\\E]*/;\n        my $after_vowel_end = $word =~\
    \ m/\\Q$vowel\\E[^\\Q$vowel\\E]*/;\n        if ($before_vowel_start >= $after_vowel_end)\
    \ {\n            $first_vowel_after = substr($word, 0, -length($word));\n    \
    \        last;\n        }\n        $last_vowel_before = substr($word, -length($word),\
    \ 1);\n    }\n    return $first_vowel_after;\n}", "    my $index = scalar(@{$word})\
    \ - 1;\n    while (index($word, $vowels[$index])) { $index--; }\n    return $vowels[$index];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYour solution is very good but it fails\
    \ for the question on spoj. Could you please have a look on that https://spoj.pl/problems/FAMOVA/\n\
    <|/ c |>\n<| c |>\nHi, thanks for noticing. On the other hand, the question states\
    \ \"Two vowels can be placed anywhere in a word except at the beginning, middle\
    \ or end of the word.\" So in your case, the solution must work even if the letters\
    \ are in the middle of the word. Maybe you need to rethink the logic of the solution\
    \ I provided and change it to your needs.\n<|/ c |>\n<| c |>\nI have edited my\
    \ solution to take care of the case you mentioned.\n<|/ c |>\n<| c |>\nHi, I tried\
    \ the new solution but it doesn't work for any test cases. Please have a look\
    \ at my solution: https://ideone.com/Qw9PbL\n<|/ c |>\n<| c |>\nYour code fails\
    \ on test case when \"pray\" is given. Because it can not find a vowel between\
    \ \"p\" and \"y\". That is why I added another condition to my code. Let me know\
    \ if it is ok for you.\n<|/ c |>\n<| a tags=perl,algorithm,string dscore=0 |>\n\
    <code>", "    \n    # Convert the word to lower case.\n    $word =~ tr/a-z/A-Z/;\n\
    \    \n    my = split //, $word;\n    \n    my $vowel_char;\n    my $closest_vowel;\n\
    \    my $closest_vowel_distance = 0;\n    \n    for (my $i = 0; $i <; $i++) {\n\
    \        # Check if we have found a vowel.\n        if ($vowel_char && $vowel_char\
    \ ne $vowels[$i]) {\n            # Check if the current distance is smaller.\n\
    \            if ($closest_vowel_distance < $i || $i < $closest_vowel_distance)\
    \ {\n                $closest_vowel = $vowels[$i];\n                $closest_vowel_distance\
    \ = $i;\n            }\n        }\n        \n        $vowel_char = $vowels[$i];\n\
    \    }\n    \n    return $closest_vowel;\n}", "    my @vowels = qw/a e i o u y/;\n\
    \    my $index = rindex($word,$word[-1]);\n    \n    foreach my $vowel (@vowels)\
    \ {\n        if ($index > 0 && $word =~ m/$vowel/) {\n            return $vowel;\n\
    \        }\n        $index--;\n    }\n    return;\n}", "    my($vowel_pos);\n\
    \    my $vowel_found = 0;\n    my $vowel_end = 0;\n    foreach $consonant (split\
    \ //, $word) {\n        if ($consonant eq \"a\" || $consonant eq \"e\" || $consonant\
    \ eq \"i\" || $consonant eq \"o\" || $consonant eq \"u\") {\n            $vowel_pos\
    \ = $consonant;\n            $vowel_found = 1;\n        }\n        if ($consonant\
    \ eq \"A\" || $consonant eq \"E\" || $consonant eq \"I\" || $consonant eq \"O\"\
    \ || $consonant eq \"U\") {\n            $vowel_pos = $consonant;\n          \
    \  $vowel_found = 1;\n        }\n        if ($vowel_found == 0 && $consonant ne\
    \ \"a\" && $consonant ne \"e\" && $consonant ne \"i\" && $consonant ne \"o\" &&\
    \ $consonant ne \"u\") {\n            my $len = $wordlen - $vowel_end;\n     \
    \       my $min_pos = ($len % 2) + 1;\n            if ($min_pos > $vowel_pos)\
    \ {\n                $vowel_pos = $consonant;\n            }\n            else\
    \ {\n                $vowel_end = $consonant;\n            }\n            $vowel_found\
    \ = 1;\n        }\n    }\n    return \"\" if !$vowel_found;\n    return $vowel_pos;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYou should mention that this will only work in\
    \ English.\n<|/ c |>\n<| c |>\nI believe this code is designed to work in a variety\
    \ of languages that have a similar alphabet. The code was originally written for\
    \ English and I thought it could be adapted to other languages by simply changing\
    \ vowels to other letters. I haven't tested it myself as I do not have another\
    \ language to test it in.\n<|/ c |>\n<| c |>\nHis code is actually pretty good\
    \ (although not optimal). You could probably make it a lot more efficient if you\
    \ use some form of lookahead or lookbehind assertion. Also, a couple of suggestions:\
    \ You don't have to call `length` every time through the loop. `my $len = $wordlen\
    \ - $vowel_end;` is enough (`length` is just `length` in Perl, like most other\
    \ functions).\n<|/ c |>\n<| c |>\nAgreed. I was just following his original code\
    \ as best as I could. Although I agree that it should have been written more efficiently\
    \ it does get the job done.\n", "    $word =~ s/([aeiou])/$1/g;\n    \n    my\
    \ $i = rindex($word, 'y');\n    if ($i > -1) {\n        if (substr($word, $i -\
    \ 1, 1) eq 'a') {\n            return $word[$i - 1];\n        }\n        else\
    \ {\n            return \"\";\n        }\n    }\n    $i = rindex($word, 'u');\n\
    \    if ($i > -1) {\n        if (substr($word, $i - 1, 1) eq 'a') {\n        \
    \    return $word[$i - 1];\n        }\n        else {\n            return \"\"\
    ;\n        }\n    }\n    $i = rindex($word, 'e');\n    if ($i > -1) {\n      \
    \  if (substr($word, $i - 1, 1) eq 'a') {\n            return $word[$i - 1];\n\
    \        }\n        else {\n            return \"\";\n        }\n    }\n    $i\
    \ = rindex($word, 'o');\n    if ($i > -1) {\n        if (substr($word, $i - 1,\
    \ 1) eq 'a') {\n            return $word[$i - 1];\n        }\n        else {\n\
    \            return \"\";\n        }\n    }\n    $i = rindex($word, 'i');\n  \
    \  if ($i > -1) {\n        if (substr($word, $i - 1, 1) eq 'a') {\n          \
    \  return $word[$i - 1];\n        }\n        else {\n            return \"\";\n\
    \        }\n    }\n    $i = rindex($word, 'a');\n    if ($i > -1) {\n        if\
    \ (substr($word, $i - 1, 1) eq 'a') {\n            return $word[$i - 1];\n   \
    \     }\n        else {\n            return \"\";\n        }\n    }\n    \n  \
    \  return \"\";\n}\n</cell>\n<cell>", '    my $vowel_found = "";', "    $word\
    \ =~ /^([a-zA-Z]+)/;\n    my @vowels = qw/a e i o u/ or qw/a e i o u/;\n    $vowels[$#vowels-1]\
    \ =~ /[aeiou]/g;\n    $vowels[$#vowels-1] =~ /[aeiou]$/g;\n    $word =~ /^([a-zA-Z]+)$/\
    \ or return $word;\n    my $wordlen = length($1);\n    my $max = $wordlen - 1;\n\
    \    for(my $i = 1; $i <= $max; $i++) {\n        if($word[$i] =~ /^$vowels[$i]/)\
    \ {\n            return $1;\n        }\n    }\n    return $word;\n}", "    my($index,\
    \ $distance);\n    \n    foreach $index (0..$#{$word}){\n        if ($word[$index]\
    \ eq \"a\"||$word[$index] eq \"e\"||$word[$index] eq \"i\"||$word[$index] eq \"\
    o\"||$word[$index] eq \"u\") {\n            $distance = $index;\n        }\n \
    \   }\n    \n    foreach $index (0..$#{$word}){\n        if ($word[$index] eq\
    \ \"a\"||$word[$index] eq \"e\"||$word[$index] eq \"i\"||$word[$index] eq \"o\"\
    ||$word[$index] eq \"u\") {\n            if ($distance>$index){\n            \
    \    $distance = $index;\n            }\n        }\n    }\n    \n    return $word[$distance];\n\
    }", "    my$pos = 0;\n    \n    # start from the right\n    while ($pos < length($word)\
    \ - 2) {\n        my $c = substr($word, $pos+1, 1);\n        my $consonant = substr($word,\
    \ $pos, 1);\n        \n        # vowel check\n        if ($c =~ /^[aeiouy]/i)\
    \ {\n            if ($c eq $consonant) {\n                return $c;\n       \
    \     } else {\n                my $left_consonant = substr($word, 0, $pos);\n\
    \                my $left_vowel = $word[$pos-1];\n                my $right_consonant\
    \ = substr($word, $pos+2, 1);\n                my $right_vowel = $word[$pos+1];\n\
    \                \n                # find out if the left vowel is closer to the\
    \ right consonant or \n                # to the left consonant \n            \
    \    my $left_dist = abs(length($left_consonant) - length($left_vowel));\n   \
    \             my $right_dist = abs(length($right_consonant) - length($right_vowel));\n\
    \                \n                if ($left_dist < $right_dist) {\n         \
    \           $pos = $pos - 1;\n                } else {\n                    $pos\
    \ = $pos + 1;\n                }\n            }\n        }\n        $pos = $pos\
    \ + 1;\n    }\n    return \"\";\n}", "    my $consonant_count = 1;\n    my $vowel_count\
    \ = 0;\n    my $closest_vowel = \"\";\n    my $vowel_found = 0;\n    \n    foreach\
    \ my $consonant (sort keys %consonant) {\n        # skip initial consonant\n \
    \       if($consonant_count) {\n            if($consonant_count == 2) {\n    \
    \            $vowel_found = 0;\n                foreach my $vowel (sort keys %vowel)\
    \ {\n                    if($word =~ /(?<=\\Q$consonant\\E)\\Q$vowel\\E/i) {\n\
    \                        $vowel_count++;\n                    }\n            \
    \    }\n                \n                if($vowel_count == 1) {\n          \
    \          $closest_vowel = $vowel;\n                    break;\n            \
    \    }\n            }\n            \n            $consonant_count++;\n       \
    \ } else {\n            # skip first consonant\n            if($word =~ /(?<=\\\
    Q$consonant\\E)\\Q$consonant\\E/i) {\n                $closest_vowel = $consonant;\n\
    \            }\n        }\n    }\n    \n    if($closest_vowel) {\n        return\
    \ $closest_vowel;\n    }\n    \n    return \"\";\n}", "    my $len = length($word);\n\
    \    my(@vowels_end);\n    for my $i (1..$len-1) {\n        push @vowels_end,\
    \ $word[$i] if $word[$i] =~ /^[aeiou]$/i;\n    }\n    my(@vowels_begin);\n   \
    \ for my $i (0..$len-1) {\n        push @vowels_begin, $word[$i] if $word[$i]\
    \ =~ /^[aeiou]$/i;\n    }\n    for my $i (0..$len-1) {\n        my $c = substr($word,\
    \ $i, 1);\n        for my $e (@vowels_end) {\n            next unless substr($word,\
    \ $i, 1) =~ /($e)\\z/i;\n            if ($c eq $e) {\n                return $e;\n\
    \            }\n        }\n        for my $e (@vowels_begin) {\n            next\
    \ unless substr($word, $i, 1) =~ /($e)\\z/i;\n            if ($c eq $e) {\n  \
    \              return $e;\n            }\n        }\n    }\n    return \"\";\n\
    }", "    my $vowel = \"aeiou\";\n    my @vowels = (\"a\", \"i\", \"u\", \"e\"\
    , \"o\", \"y\");\n    my $vowel_index;\n    my $vowel_min;\n    my $vowel_max;\n\
    \    my $index = rindex($word, $vowel);\n    if($index != -1) {\n        $vowel_min\
    \ = $index + 1;\n        $vowel_max = rindex($word, $vowel, $vowel_min);\n   \
    \ }\n    for($vowel_index = $vowel_min - 2; $vowel_index <= $vowel_max; ++$vowel_index)\
    \ {\n        my $vowel_index2 = $vowel_index + 2;\n        my $vowel_min2 = rindex($word,\
    \ $vowel, $vowel_index2);\n        my $vowel_max2 = rindex($word, $vowel, $vowel_index2\
    \ - 1);\n        if($vowel_min2 != -1) {\n            my $vowel_min2 = $vowel_min2\
    \ - 1;\n            my $vowel_max2 = $vowel_max2 + 1;\n            my $word2 =\
    \ substr($word, 0, $vowel_min2);\n            my $word3 = substr($word, $vowel_min2,\
    \ $vowel_max2);\n            my $word4 = substr($word, $vowel_max2, length($word));\n\
    \            if($vowel_index2 >= $vowel_min && $vowel_index2 <= $vowel_max) {\n\
    \                if($vowel_index2 > $vowel_max || $vowel_index2 >= length($word))\
    \ {\n                    return \"\";\n                }\n                my $vowel2\
    \ = substr($word, $vowel_index2, 1);\n                if($vowel_index == $vowel_index2)\
    \ {\n                    return $vowel2;\n                } elsif($word2 =~ m/$vowel2/i\
    \ || $word3 =~ m/$vowel2/i || $word4 =~ m/$vowel2/i) {\n                    return\
    \ $vowel2;\n                }\n            }\n        }\n    }\n    return \"\"\
    ;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    my $vowels =\
    \ qw(a e i o u);\n    my $vowels_count = scalar(@$vowels);\n    $word =~ tr/aeiouAEIOU/aAeEiIoOuU/;\n\
    \    my $vowel_pos = $-[0] - $vowels_count;\n    return $vowels[$vowel_pos] if\
    \ ($word =~ m/$vowels/);\n    return \"\";\n}\n</code>\n<|/ a tags=regex,perl\
    \ |>\n<| a tags=regex,perl |>\nMy solution:\n<code>\nmy $vowels = qw(a e i o u);",
  "    $word =~ s/\\b(\\w+)\\b/uc $1 =~ /[^a-z]/ ? \"\" : $1; \n    return $word;\
    \ \n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=algorithm,string,perl |>\n\
    <code>\nuse warnings;\nuse strict;", "    my($vowels) = qw(a e i o u);\n    my\
    \ $result = '';\n    my $len = length($word);\n    for (my $i=0; $i<$len; $i++)\
    \ {\n        my $s = substr($word, $i, 1);\n        if ($s =~ (/[aeiou]/i)) {\n\
    \            my $n = ($i+1);\n            for (my $j=-1; $j<$len; $j++) {\n  \
    \              if ($j==$i || $j==$n-1) {\n                    next;\n        \
    \        }\n                my $p = substr($word, $j, $1);\n                if\
    \ (grep($p =~ /[aeiou]/i, $vowels)) {\n                    $result = $p;\n   \
    \                 last;\n                }\n            }\n        }\n    }\n\
    \    return $result;\n}", "    my(@vowel) = (\n        \"a\", \n        \"e\"\
    , \n        \"i\", \n        \"o\", \n        \"u\", \n    );\n    my(@vowel_end)\
    \ = (\"e\", \"i\");\n    my $vowel_index;\n    my $vowel_end_index;\n    my @vowel_start_end;\n\
    \    foreach my $i(0..$#vowel) {\n        my $vowel_start = substr $word, 0, $i;\n\
    \        my $vowel_end = substr $word, $#vowel;\n        push(@vowel_start_end,\
    \ $vowel_start) if ($vowel_start ne $vowel_end);\n    }\n    $vowel_index = $vowel_start_end[$#vowel_start_end]\
    \ if (@vowel_start_end);\n    $vowel_end_index = $vowel_start_end[$#vowel_start_end]\n\
    \        if ($vowel_start_end[$#vowel_start_end]);\n    return $vowel[$vowel_index]\
    \ if ($vowel_index);\n    return $vowel_end[$vowel_end_index] if ($vowel_end_index);\n\
    \    return \"\";\n}", "    \n    $word =~ tr/a-zA-Z//cd;\n    my $first  = $word;\n\
    \    $first =~ tr/aeiou/AEIOU/;\n    my $last   = $word;\n    $last =~ tr/aeiou/AEIOU/;\n\
    \    my $firstVowel = $first;\n    $firstVowel =~ tr/aeiou/AEIOU/;\n    my $lastVowel\
    \ = $last;\n    $lastVowel =~ tr/aeiou/AEIOU/;", "    my $vowel = 'a';\n    my\
    \ $start = 0;\n    my $end;\n    foreach my $consonant (split('',$word)){\n  \
    \      if($consonant =~ /^[aeiouy]+$/i){\n            $end = $consonant;\n   \
    \     }\n        $start += length($consonant);\n    }\n    if($end > $start){\n\
    \        my $s = substr($word,$start,$end-start);\n        return $s =~ /([aeiouy])/i\
    \ ? $1 : 0;\n    }\n    return '';\n}", "    my(@vowels) = qw(u a e i o u);\n\
    \    my($result) =\"\";\n    \n    foreach my $i ($word) {\n        if ($i =~\
    \ /^[a-z]/i) {\n            my($j) = grep {lc $_ eq $i} @vowels;\n           \
    \ if ($j > -1) {\n                $result = \"$j\";\n            }\n        }\n\
    \    }\n    \n    return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=regex,perl,algorithm\
    \ dscore=2 |>\nThis is an interesting problem. A solution that doesn't involve\
    \ regular expressions might be more performant (since it does less work) and perhaps\
    \ easier to read:\n<code>", "    my $vowel = \"\";\n    \n    for (my $index =\
    \ $#{$word}; $index >= 0; $index--) {\n        my $c = substr($word, $index, 1);\n\
    \        my $n = index($consonants, $c) + 1;\n        \n        if ($n <= 0) {\n\
    \            return $vowel;\n        } elsif ($n == 1 && substr($word, $index,\
    \ 1) eq \"a\") {\n            $vowel = \"a\";\n        }\n        elsif ($n ==\
    \ 2 && substr($word, $index, 1) eq \"u\") {\n            $vowel = \"u\";\n   \
    \     }\n        elsif ($n == 1 && substr($word, $index, 1) eq \"y\") {\n    \
    \        $vowel = \"y\";\n        }\n        elsif ($n == 2 && substr($word, $index,\
    \ 1) eq \"r\") {\n            $vowel = \"r\";\n        }\n        elsif ($n ==\
    \ 1 && substr($word, $index, 1) eq \"o\") {\n            $vowel = \"o\";\n   \
    \     }\n        elsif ($n == 2 && substr($word, $index, 1) eq \"k\") {\n    \
    \        $vowel = \"k\";\n        }\n        elsif ($n == 1 && substr($word, $index,\
    \ 1) eq \"p\") {\n            $vowel = \"p\";\n        }\n        elsif ($n ==\
    \ 2 && substr($word, $index, 1) eq \"f\") {\n            $vowel = \"f\";\n   \
    \     }\n        elsif ($n == 1 && substr($word, $index, 1) eq \"l\") {\n    \
    \        $vowel = \"l\";\n        }\n        elsif ($n == 2 && substr($word, $index,\
    \ 1) eq \"m\") {\n            $vowel = \"m\";\n        }\n        elsif ($n ==\
    \ 1 && substr($word, $index, 1) eq \"t\") {\n            $vowel = \"t\";\n   \
    \     }\n        elsif ($n == 2 && substr($word, $index, 1) eq \"s\") {\n    \
    \        $vowel = \"s\";\n        }\n        elsif ($n == 1 && substr($word, $index,\
    \ 1) eq \"a\") {\n            $vowel = \"a\";\n        }\n        elsif ($n ==\
    \ 2 && substr($word, $index, 1) eq \"c\") {\n            $vowel = \"c\";\n   \
    \     }\n    }\n    return $vowel;\n}\n</code>\n<|/ a tags=performance,perl,string,algorithm\
    \ |>\n<| c |>\nI don't think this works correctly for non-English letters. If\
    \ you change \"yogurt\" to \"yogarnt\" it returns the empty string, while it should\
    \ return \"u\"\n<|/ c |>\n<| a dscore=0 |>\nI guess the simplest solution for\
    \ you is the following one:\n", "    my($l, $r) = (0, length($word) - 1);\n  \
    \  my($i, $j, $vowel, $found) = 0, 0, '', 0;\n    \n    while ($i <= $l && $j\
    \ <= $r) {\n        $vowel = $letters[$i];\n        if ($vowel eq $word[$j]) {\n\
    \            $vowel = $letters[$j];\n            $found = 1;\n            last;\n\
    \        }\n        if ($found == 0) {\n            if ($j > 0 && $word[$j-1]\
    \ eq $vowel) {\n                $found = 1;\n                last;\n         \
    \   }\n            if ($i > 0 && $word[$i-1] eq $vowel) {\n                $found\
    \ = 1;\n                last;\n            }\n        }\n        $i++;\n     \
    \   $j--;\n    }\n    if ($found == 0) {\n        return '';\n    } else {\n \
    \       return $vowel;\n    }\n}", '    my @vowels = ("a","e","i","o","u");',
  "    my(@vowel) = (\"a\",\"e\",\"i\",\"o\",\"u\");\n    my @left_con = grep(/[b-df-hj-np-tv-yz]/,split(//,$word));\n\
    \    my $con = pop(@left_con);\n    my $con2 = pop(@left_con);\n    $con2 = $con2\
    \ if $con2 ne $con;\n    for(@vowel) {\n        my $m = $word;\n        $m = substr($m,0,-length($con))\
    \ . $con;\n        my $n = $word;\n        $n = substr($n,0,-length($con2)) .\
    \ $con2;\n        my $l = $word;\n        $l = substr($l,0,-length($con)) . $con;\n\
    \        my $r = $word;\n        $r = substr($r,0,-length($con2)) . $con2;\n \
    \       if ($m eq $n && $m eq $l && $m eq $r){\n            return $_;\n     \
    \   }\n    }\n    return '';\n}", "    my($start);\n    my($end);\n    $start\
    \ = ($word =~ /[^aeiou]/) ? length($word) - 1 : 0;\n    $end = ($start > 0) ?\
    \ $start : length($word) - 1;\n    while($start > 0 && $end < length($word))\n\
    \    {\n        if(($word =~ /[aeiou]/ && substr($word, $end - 1, 1)=~m/[AEIOU]/i)\
    \ ||\n           ($word =~ /[aeiou]/ && substr($word, $end + 1, 1)=~m/[AEIOU]/i))\n\
    \        {\n            return $end + 1;\n        }\n        $start--;\n     \
    \   $end++;\n    }\n    return \"\";\n}", "    \n    my @vowels = qw(a e i o u);\n\
    \    my $consonant_start = 0;\n    my $consonant_end = 0;\n    my $vowel_start\
    \ = 0;\n    my $vowel_end = 0;", "    my($i, $j, $prev, $curr);\n    my @vowels\
    \ = qw/a e i o u/;\n    my @consonants = qw/b c d f g h j k l m n p q r s t v\
    \ w x y z/;\n    $word =~ s/^\\s+|\\s+$//g;\n    for(my $i = length($word); $i\
    \ -gt 0; $i--) {\n        $prev = $word[$i-1];\n        for(my $j = 0; $j < scalar(@vowels);\
    \ $j++) {\n            $curr = $word[$i];\n            if($prev eq $vowels[$j])\
    \ {\n                $word[$i-1] = $vowels[$j];\n                if($i -gt 0 &&\
    \ $word[$i] eq $consonants[$j]) {\n                    $word[$i] = 0;\n      \
    \          }\n            }\n        }\n    }\n    return $word;\n}\n</code>\n\
    <|/ a dscore=2 tags=perl,algorithm |>\n<| c |>\n: Did you try the second solution?\
    \ That is, with the addition of `($prev, $curr)` to the first for loop? I tested\
    \ it on `ab` and it worked.\n<|/ c |>\n<| c |>\nYes, but it seems to only work\
    \ on 'a' to 'z'\n<|/ c |>\n<| c |>\nI edited the code to include a more comprehensive\
    \ set of consonants that seems to work.\n<|/ c |>\n<| c |>\n: Oops, I just realized\
    \ that my second version was wrong. I'll fix that right now. Thanks.\n<|/ c |>\n\
    <| c |>\n: I added a version that should work with all cases. The last version\
    \ seems to only handle lowercase words.\n<|/ c |>\n<| a dscore=2 tags=perl,algorithm\
    \ |>\nHere's an O(n) solution which uses substring comparisons to find the \"\
    closest\" vowel:\n<code>", "    my $vowel;\n    foreach my $letter (split //,\
    \ $word) {\n        if ($letter eq \"a\" || $letter eq \"e\" || $letter eq \"\
    i\" || $letter eq \"o\" || $letter eq \"u\") {\n            $vowel = $letter;\n\
    \            last;\n        }\n    }\n    return $vowel;\n}", "    my $vowels\
    \ = 'aA';", "    my $first_vowel = substr($word,-2,1);\n    my $second_vowel =\
    \ substr($word,0,-1);\n    my $pos = index($word,$first_vowel) + 2;\n    return\
    \ substr($word,$pos,1) if $pos < length($word) - 2 && $second_vowel =~ /[aeiou]/i;\n\
    \    return \"\";\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis solution uses\
    \ only one regex\n<code>\nuse strict;\nuse warnings;", '    $word =~ s/\p{L}//g;',
  "    my $vowels = \"aeiouy\";\n    my $consonants = \"bcdfghjklmnpqrstvwxyz\";\n\
    \    my $pos;\n    my $i;\n    my $len = $#{$word} + 1;\n    my $start = 0;\n\
    \    my $found;\n    my $end = 0;\n    $found = 0;\n    my $closest;\n    for(my\
    \ $i = $#{$word}; $i >= 0; $i--) {\n        $pos = index($vowels, $word[$i], $start);\n\
    \        if($pos >= 0) {\n            $start = $pos + 1;\n            $found =\
    \ 1;\n            last;\n        } elsif($i == 0) {\n            $start = $pos;\n\
    \            $found = 1;\n            last;\n        } elsif($i == $len) {\n \
    \           $end = $pos;\n            $found = 1;\n            last;\n       \
    \ }\n    }\n    if(!$found) {\n        $closest = \"\";\n    } else {\n      \
    \  $closest = $word[$end];\n    }\n    return $closest;\n}", "    my @vowels =\
    \ qw(a e i o u);\n    my $vowel = undef;\n    $word = lc($word);", "    my(@vowels)\
    \ = qw(a e i o u);\n    my(@consonants) = qw(a e i o u);\n    my($found);\n  \
    \  foreach my $cons (@consonants) {\n        foreach my $vowel (@vowels) {\n \
    \           ($found || ($found = $word) =~ s/$vowel([aeiou])/$cons.$1/);\n   \
    \     }\n    }\n    return $found;\n}", "    my $vowel_count;\n    $vowel_count\
    \ = scalar(grep { lc($_) eq 'u' } split(//, $word));\n    $vowel_count += scalar(grep\
    \ { lc($_) eq 'i' } split(//, $word));\n    $vowel_count += scalar(grep { lc($_)\
    \ eq 'o' } split(//, $word));\n    $vowel_count += scalar(grep { lc($_) eq 'a'\
    \ } split(//, $word));\n    $vowel_count += scalar(grep { lc($_) eq 'e' } split(//,\
    \ $word));\n    $vowel_count += scalar(grep { lc($_) eq 'u' } split(//, $word));\n\
    \    return $vowel_count == 0 ? \"\" : $vowel_count == 4 ? uc($word) : \"\";\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for that and for the code. While I still\
    \ think that your solution is far better, I've learned something.\n<|/ c |>\n\
    <| a dscore=1 tags=string,perl,subroutine |>\n<code>", "    \n    # initialize\
    \ return string\n    my $ret = \"\";\n    \n    # initialize counters\n    my\
    \ $consonant_cnt = 0;\n    my $vowel_cnt = 0;\n    \n    # iterate through each\
    \ character in given string\n    for my $char (reverse $word) {\n        $consonant_cnt\
    \ += 1;\n        \n        # if the current character is consonant\n        if\
    \ ($char =~ /[bcdfghjklmnpqrstvwxyz]/) {\n            $vowel_cnt += 1;\n     \
    \   }\n    }\n    \n    # if there are consonants left, choose the one closest\
    \ to the leftmost consonant \n    # if the first or last character are vowels,\
    \ the one closest to the right most is always vowel\n    if ($consonant_cnt >\
    \ 0) {\n        $ret = substr($word, 0, $consonant_cnt - 1);\n        $ret .=\
    \ substr($word, $consonant_cnt - 1);\n    }\n    \n    # if the first or last\
    \ character are vowels, choose the one closest to the right most \n    # if the\
    \ last character is consonant, choose the one closest to the right most \n   \
    \ # if the last character is vowel and the consonant before it are vowels, choose\
    \ the right most vowel\n    # if the first character is consonant and last character\
    \ is vowel, choose the one closest to the left most vowel\n    if ($consonant_cnt\
    \ > 0 && $consonant_cnt > 1 && $vowel_cnt > 0 && $word[$consonant_cnt - 1] =~\
    \ /[aeiou]/) {\n        $ret = substr($word, 0, $consonant_cnt - 1);\n       \
    \ $ret .= substr($word, $consonant_cnt - 1);\n    }\n    \n    # if the first\
    \ and last character are vowels and there are any consonants left, choose the\
    \ one closest to the right most \n    # if the second character is consonant,\
    \ choose the one closest to the left most vowel\n    # if the first and last character\
    \ are vowels and there are no consonants left, choose the one closest to the left\
    \ most\n    if ($consonant_cnt > 0 && $vowel_cnt > 0 && $consonant_cnt > 1 &&\
    \ $vowel_cnt > 1 && $word[$consonant_cnt - 2] =~ /[aeiou]/) {\n        $ret =\
    \ substr($word, 0, $consonant_cnt - 1);\n        $ret .= substr($word, $consonant_cnt\
    \ - 1);\n    }\n    \n    # if the last and first character are vowels, choose\
    \ the one closest to the left most\n    # if the last and second character are\
    \ consonants, choose the one closest to the left most vowel\n    # ", '    my($closest_vowel)
    = "";', "    my $vowel_count = 0;\n    my $consonant_count = 0;\n    my $vowel_prev\
    \ = '';\n    my $consonant_prev = '';\n    for (my $i = 0; $i < length($word);\
    \ $i++) {\n        my $current_char = substr($word, $i, 1);\n        if ($current_char\
    \ eq \"A\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"a\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"E\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"e\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"I\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"i\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"O\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"o\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"U\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"u\") {\n            $vowel_count++;\n        }\n        if ($current_char\
    \ eq \"U\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"u\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"I\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"i\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"O\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"o\") {\n            $consonant_count++;\n        }\n        if ($current_char\
    \ eq \"a\") {\n            $vowel_prev = $current_char;\n        }\n        if\
    \ ($current_char eq \"A\") {\n            $vowel_prev = $current_char;\n     \
    \   }\n        if ($current_char eq \"e\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"E\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"i\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"I\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"o\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"O\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"u\") {\n            $vowel_prev = $current_char;\n\
    \        }\n        if ($current_char eq \"u\") {\n            $con", '    return
    "" if $word eq "" || $word =~ /[^a-zA-Z]/;', "    my ($i,$vowels);\n    $vowels\
    \ = (\"a\",\"e\",\"i\",\"o\",\"u\");\n    $word =~ s/^([AEIOUaeiou])/$1/g;\n \
    \   for ($i = 0; $i < $#{$vowels}; $i++) {\n        if ($word =~ /($vowels[$i])/g)\
    \ {\n            my $result = $i;\n            while (++$result && $result < $#{$vowels})\
    \ {\n                $result++ if $vowels[$result] eq $word[$i];\n           \
    \ }\n            return $result ? $vowels[$result] : '';\n        }\n    }\n \
    \   return '';\n}", '    my $vowel;', "    my $vowels = \"aeiouAEIOU\";\n    $word=~s/\\\
    <[^aeiou][^aeiou]*\\>//g;\n    $word=~s/\\<([$vowels][^aeiou]*)\\>//g;\n    $word=~s/\\\
    <[^aeiou][^aeiou]*\\>//g;\n    $word =~ /[AEIOUaeiou]/;\n    return $1;\n}\n</code>\n\
    <|/ a tags=perl,string dscore=2 |>\n<| a dscore=1 |>\nThe simplest approach is\
    \ probably to use the split function to split the string on vowels into a list.\
    \ Then use grep to filter the list to only keep those elements that are not in\
    \ the string. Like this:\n<code>", "    my %vowels = map { $_ => 1 } qw(a e i\
    \ o u);\n    my $vowel = $vowels{uc($word)} || $vowels{uc(substr($word,length($word),1))};\n\
    \    return $vowel || \"\";\n}\n</code>\n<|/ a tags=perl,regex,subroutine,function\
    \ dscore=3 |>\n<| c |>\nThanks a lot!!! It works perfectly! And thanks for the\
    \ explanation as well!\n<|/ c |>\n<| c |>\nJust a small hint: If you find yourself\
    \ using `uc` more than a couple of times, you can also do `my $vowel = $vowels{$word}\
    \ || $vowels{$substr($word,length($word),1)};`.\n<|/ c |>\n<| a |>\n<code>\nuse\
    \ strict;\nuse warnings;", "    return unless $word =~ /[a-z]/;\n    $word =~\
    \ tr/aeiouyAEIOUY/uv/;\n    my $vowels = $word =~ /[aeiouyAEIOUY]+/;\n    return\
    \ $vowels\n      ? $vowels[0]\n      : $word =~ /[aeiouyAEIOUY]+/\n        ? $word\n\
    \        : \"\";\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wanted to solve this\
    \ problem in a more generic way than a one-liner. Given a string with characters,\
    \ I wanted to find the one that would give me the closest word boundary to my\
    \ target string. I came up with this Perl script:\n<code>", "    $word =~ tr/aAbBcCdDeEfFgGhHiIlJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz+/-/_/;\n\
    \    my $found_vowel = undef;\n    my $found_position = 0;\n    for(my $i = 0;\
    \ $i < length($word); $i++) {\n        $found_vowel = $found_vowel . substr($word,\
    \ $i, 1);\n        if ($found_vowel =~ m/[AEIOUaeiou]$/) {\n            if ($found_position\
    \ == 0) {\n                $found_position = $i;\n            }\n            elsif\
    \ ($found_position == length($word) - 1) {\n                $found_position =\
    \ length($word) - 1;\n            }\n            else {\n                my $found_vowel_upper\
    \ = substr($found_vowel, 0, 1);\n                my $found_vowel_lower = substr($found_vowel,\
    \ 0, -1);\n                my $word2 = substr($word, $found_position + 1, length($word)\
    \ - $found_position - 1);\n                my $found_position2 = index($word2,\
    \ $found_vowel_upper);\n                my $found_position3 = index($word2, $found_vowel_lower);\n\
    \                my ($pos_a, $pos_b) = (0, 0);\n                for(my $pos =\
    \ $found_position2; $pos < length($word2); $pos++) {\n                    if ($word2\
    \ eq substr($word, $pos, 1)) {\n                        $pos_a = $pos;\n     \
    \                   last;\n                    }\n                }\n        \
    \        for(my $pos = $found_position3; $pos < length($word2); $pos++) {\n  \
    \                  if ($word2 eq substr($word, $pos, 1)) {\n                 \
    \       $pos_b = $pos;\n                        last;\n                    }\n\
    \                }\n                \n                my $max_pos = ($pos_b -\
    \ $pos_a);\n                $found_position += $max_pos - 1;\n            }\n\
    \        }\n    }\n    return $found_vowel;\n}", "    $word =~ s/^.+?//;\n   \
    \ return $word =~ /[aeiou]/i ? $1 : '' if length($word) <= 1;\n    my $i = 0;\n\
    \    my $l = 0;\n    my %vowel = (\n        'a' => 'e',\n        'e' => 'i',\n\
    \        'i' => 'o',\n        'o' => 'u'\n    );\n    my $cur;\n    for (my $j\
    \ = $#{$word}; $j >= 1; $j--) {\n        $cur = $vowel{$word[$j]} if exists $vowel{$word[$j]};\n\
    \        if ($cur && $cur != $word[$j]) {\n            ++$l;\n        }\n    }\n\
    \    for my $i ($i, $#{$word}) {\n        if ($cur && $cur != $word[$i]) {\n \
    \           return '';\n        }\n    }\n    return $word[$i];\n}", "    $word\
    \ =~ /^([a-z])/i or return \"\";\n    $word =~ /[aeiou]/i or return \"\";\n  \
    \  $word =~ /[A-z]/i and $word =~ /[aeiouAEIOU]/ and $word =~ /[a-z]/i and \n\
    \       $word =~ /[q-z]/i or return \"\";\n    $word =~ /[a-e]/i and $word =~\
    \ /[AEIOU]/i or return \"\";\n    $word =~ /[b-z]/i and $word =~ /[BCDFGHJKLMNPQRSTVWXY]/\
    \ and $word =~ /[a-e]/i \n       and $word =~ /[q-z]/i or return \"\";\n    $word\
    \ =~ /[c-g]/i and $word =~ /[CDFGHJKLMNPQRSTVWXY]/ and $word =~ /[b-z]/i \n  \
    \     and $word =~ /[a-e]/i or return \"\";\n    $word =~ /[d-h]/i and $word =~\
    \ /[CDFGHJKLMNPQRSTVWXY]/ and $word =~ /[c-g]/i \n       and $word =~ /[b-z]/i\
    \ or return \"\";\n    $word =~ /[i-j]/i and $word =~ /[CDFGHJKLMNPQRSTVWXY]/\
    \ and $word =~ /[d-h]/i \n       and $word =~ /[c-g]/i or return \"\";\n    $word\
    \ =~ /[k-l]/i and $word =~ /[CDFGHJKLMNPQRSTVWXY]/ and $word =~ /[i-j]/i \n  \
    \     and $word =~ /[d-h]/i or return \"\";\n    $word =~ /[m-n]/i and $word =~\
    \ /[CDFGHJKLMNPQRSTVWXY]/ and $word =~ /[k-l]/i \n       and $word =~ /[i-j]/i\
    \ or return \"\";\n    $word =~ /[p-q]/i and $word =~ /[CDFGHJKLMNPQRSTVWXY]/\
    \ and $word =~ /[m-n]/i \n       and $word =~ /[k-l]/i or return \"\";\n    $word\
    \ =~ /[s-t]/i and $word =~ /[CDFGHJKLMNPQRSTVW", "    my $vowels = \"aeiou\";\n\
    \    my $first_consonant = \"b\";\n    my $last_consonant = \"z\";\n    my $start\
    \ = 0;\n    my $end = 0;\n    my $result = '';\n    \n    if(!$word or !length($word))\
    \ {\n        return '';\n    }\n    \n    for ($start = ( length($word) - 1 );\
    \ $start >= 0; $start--)  {\n        last if ($start == 0);\n        next if ($word[$start]\
    \ eq 'z');\n        \n        for ($end = 0; $end < length($word); $end++) \n\
    \        {\n            if ($word[$end] eq $first_consonant) {\n             \
    \   $start = $end - 1;\n            }\n            elsif ($word[$end] eq $last_consonant)\
    \ {\n                $end = $end - 1;\n            }\n            else {\n   \
    \             last;\n            }\n        }\n        \n        if($start > $end)\
    \ {\n            $end = $end + 1;\n        }\n        \n        for ($end = (length($word)\
    \ - $end + 1); $end < length($word); $end++) \n        {\n            if ($word[$end]\
    \ =~ $vowels) {\n                $result = $word[$end];\n                last;\n\
    \            }\n            else {\n                break;\n            }\n  \
    \      }\n        \n    }\n    \n    return $result;\n}\n</code>\n<|/ a tags=perl,regex\
    \ dscore=1 |>\n<| c |>\nYou have the condition `!$word or !length($word)` in `get_closest_vowel()`,\
    \ but you return `$result` even if the `!$word` condition is not met. I guess\
    \ you meant `or length($word) == 0`?\n<|/ c |>\n<| c |>\n, that's a good point.\
    \ The code has other problems. I thought it wouldn't be too hard to figure out\
    \ what was going wrong with OP's code.\n<|/ c |>\n<| a tags=perl,regex dscore=0\
    \ |>\nHere is my solution. I've used the regex library Regexp::Assemble to do\
    \ all the work. I've also changed the way that I use subroutines to improve readability\
    \ and code organisation. \n<code>\nuse strict;\nuse warnings;", "    my(@vowels)\
    \ = qw(a e i o u);\n    \n    my $word_len = length($word);\n    my $index = 0;\n\
    \    my $previous_char;\n    my $next_char;", "    my($consonants) = qr{\n   \
    \                    [bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\n          \
    \             (?=.?[aeiou])\n                       (?=.?[AEIOU])\n          \
    \             ^\n                       (?=.?[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ])\n\
    \                     };", "    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"y\", \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\", \"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\", \"A\",\n    \"E\", \"I\", \"O\", \"U\", \"Y\", \"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\",\n    \"v\", \"w\", \"y\", \"z\");\n    \n    my $vowel = ();\n\
    \    \n    for my $index (reverse 0 .. length($word) - 1) {\n        my $letter\
    \ = substr($word, $index + 1, 1);\n        if ($letter eq 'a' or $letter eq 'e'\
    \ or $letter eq 'i' or $letter eq 'o' or $letter eq 'u') {\n            $vowel\
    \ = $letter;\n            last;\n        }\n        \n        if ($letter eq 'y'\
    \ or $letter eq 'Y') {\n            my $y = substr($word, $index + 1, 1);\n  \
    \          $y =~ tr/a//d;\n            $vowel = $y if ($y ne \"\");\n        \
    \    last;\n        }\n    }\n    \n    return $vowel if (!defined $vowel);\n\
    \    \n    my $letter = $vowel;\n    \n    $letter =~ tr/a//d;\n    $letter =~\
    \ tr/e//d;\n    $letter =~ tr/i//d;\n    $letter =~ tr/o//d;\n    $letter =~ tr/u//d;\n\
    \    $letter =~ tr/y//d;\n    $letter =~ tr/A//d;\n    $letter =~ tr/E//d;\n \
    \   $letter =~ tr/I//d;\n    $letter =~ tr/O//d;\n    $letter =~ tr/U//d;\n  \
    \  $letter =~ tr/Y//d;\n    $letter =~ tr/b//d;\n    $letter =~ tr/c//d;\n   \
    \ $letter =~ tr/d//d;\n    $letter =~ tr/f//d;\n    $letter =~ tr/g//d;\n    $letter\
    \ =~ tr/h//d;\n    $letter =~ tr/j//d;\n    $letter =~ tr/k//d;\n    $letter =~\
    \ tr/l//d;\n    $letter =~ tr/m//d;\n    $letter =~ tr/n//d;\n    $letter =~ tr/p//d;\n\
    \    $letter =~ tr/q//d;\n    $letter =~ tr/r//d;\n    $letter =~ tr/s//d;\n \
    \   $letter =~ tr/t//d;\n    $letter =", "    $word =~ s/^[a-z]+//i; # remove\
    \ all characters except alphabet letters.\n    $word =~ s/[^aeiou]//gi; # remove\
    \ all characters not between 'a' and 'e'.\n    $word =~ s/[^aeiouAEIOU]//gi; #\
    \ remove all characters not between 'e' and 'i'.\n    $word =~ s/[^a-zA-Z]//gi;\
    \ # remove all characters not between 'a' and 'z'.\n    $word =~ s/[^A-Za-z]//gi;\
    \ # remove all characters not between 'A' and 'Z'.\n    # remove all characters\
    \ not between 'a' and 'z' and 'A' and 'Z'\n    $word =~ s/([^z]*)([z])([^z]*)([z])([^z]*)([z])([^z]*)([z])([^z]*)([z])([^z]*)([z])/$1$3$5$7$9$11$13$15$17/;\n\
    \    my $vowel = $1;\n    my $consonants = $3;\n    my $consonants2 = $5;\n  \
    \  my $consonants3 = $7;\n    my $consonants4 = $9;\n    my $consonants5 = $11;\n\
    \    my $consonants6 = $13;\n    my $consonants7 = $15;\n    my $consonants8 =\
    \ $17;\n    my $vowel2 = $2;\n    my $vowel3 = $3;\n    my $vowel4 = $4;\n   \
    \ my $vowel5 = $5;\n    my $vowel6 = $6;\n    my $vowel7 = $7;\n    my $vowel8\
    \ = $8;\n    my $vowel9 = $9;\n    my $vowel10 = $10;\n    my $vowel11 = $11;\n\
    \    my $vowel12 = $12;\n    my $vowel13 = $13;\n    my $vowel14 = $14;\n    my\
    \ $vowel15 = $15;\n    my $vowel16 = $16;\n    my $vowel17 = $17;\n    if($consonants2\
    \ eq 'a' or $consonants2 eq 'e' or $consonants2 eq 'i' or $consonants2 eq 'o'\
    \ or $consonants2 eq 'u'){\n        return $vowel2;\n    } elsif($consonants3\
    \ eq 'a' or $consonants3 eq 'e' or $consonants3 eq 'i' or $consonants3 eq 'o'\
    \ or $consonants3 eq 'u'){\n        return $vowel3;\n    } elsif($consonants4\
    \ eq 'a' or $consonants4 ", "    my($consonants) = \"bcdfghjklmnpqrstvwxyz\";\n\
    \    my($vowels) = \"aeiou\";\n    my($i) = 0;\n    my($vowel_index);", "    my($vowel)\
    \ = $word =~ /([aeiou])/g;\n    my(@consonants) = $word =~ /[^aeiou]+/g;\n   \
    \ my(@consonants) = @consonants[0..@consonants-1];\n    if(@consonants <= 1) {\n\
    \        return \"\";\n    }\n    my($consonants) = @consonants[1..$#consonants];\n\
    \    if($vowel == $consonants[-1]) {\n        return $vowel;\n    }\n    for($i\
    \ = 0; $i <= $#consonants - 1; $i++) {\n        my $dist = $consonants[$i] - $vowel\
    \ - 1;\n        if($dist > 0) {\n            return $consonants[$i];\n       \
    \ }\n    }\n    return \"\";\n}", "    $word =~ tr/a-zA-Z0-9//cd;\n    $word;\n\
    }\n</code>\n<|/ a dscore=1 tags=perl,regex,string |>\n<| c |>\nThis works only\
    \ when the vowels are next to each other, and doesn't work if there are more than\
    \ 1 vowel in the string.\n<|/ c |>\n<| c |>\nI think it does, since it checks\
    \ one character at a time. But you could also add another if condition, saying\
    \ `if ($char == $first_char) { $first_char = $char; last; }`.\n<|/ c |>\n<| c\
    \ |>\nYou only need to check one character at a time. In my example code, I check\
    \ one character at a time, and keep track of which character is the first one.\n\
    <|/ c |>\n<| c |>\nThis fails if the word begins with a vowel. `get_closest_vowel(\"\
    Bear\")` returns `\"\"` instead of `\"r\"`\n<|/ c |>\n<| a tags=perl,regex,string\
    \ |>\n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;\nuse English;", " \
    \   $word =~ tr/A-Z//cd;\n    $word =~ s/^[^aeiouAEIOU]/e/g;\n    $word =~ s/[^aeiouAEIOU]$/y/g;\n\
    \    my $len = $#_ + 2;\n    $word =~ s/^.*?([aeiouAEIOU])([^aeiouAEIOU]+).*$/$1$2$3/;\n\
    \    $word =~ s/^([aeiouAEIOU])([^aeiouAEIOU]+).*$/$1$2$3/;\n    return $word;\n\
    }", "    my $vowels = qw(a e i o u);\n    my $count = 0;\n    my ($i, $j, $k,\
    \ $max);", "    $word =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n    my $vowel = $word\
    \ =~ /[AEIOUaeiouAEIOU]/;\n    return $vowel ? $vowel : \"\";\n}\n</cell>\n<text>\n\
    Exercise 3\nWrite a program which finds number of vowels in a string.", "    my\
    \ @vowels = qw(a e i o u);\n    my ($start_consonant, $end_consonant, $closest_vowel)\
    \ = ('a', 'z', '');\n    my $vowels_cnt = @vowels;\n    for(my $i = 0; $i <= $#{$word};\
    \ $i++) {\n        if($word[$i] =~ m/\\Q$start_consonant\\E/i) { $start_consonant\
    \ = $word[$i]; }\n        if($word[$i] =~ m/\\Q$end_consonant\\E/i) { $end_consonant\
    \ = $word[$i]; }\n    }\n    for(my $i = 0; $i <= $#{$word}; $i++) {\n       \
    \ if($word[$i] =~ m/\\Q$vowels[$i]\\E/i) { $closest_vowel = $word[$i]; }\n   \
    \ }\n    return $closest_vowel;\n}", "    $word =~ tr/aAeEiIoOuUaAEeEiIoOuU/AaEiIoOuU/;\n\
    \    my $first_consonant = substr($word, 0, 1);\n    $first_consonant = lc $first_consonant;\n\
    \    my $last_consonant = substr($word, (length($word)-1));\n    $last_consonant\
    \ = lc $last_consonant;\n    \n    if ( $first_consonant eq \"y\" && $last_consonant\
    \ eq \"a\" ){\n        return \"u\";\n    }\n    elsif ( $first_consonant eq \"\
    a\" && $last_consonant eq \"a\" ){\n        return \"U\";\n    }\n    elsif (\
    \ $first_consonant eq \"e\" && $last_consonant eq \"e\" ){\n        return \"\
    i\";\n    }\n    elsif ( $first_consonant eq \"i\" && $last_consonant eq \"i\"\
    \ ){\n        return \"I\";\n    }\n    elsif ( $first_consonant eq \"o\" && $last_consonant\
    \ eq \"o\" ){\n        return \"o\";\n    }\n    elsif ( $first_consonant eq \"\
    u\" && $last_consonant eq \"u\" ){\n        return \"U\";\n    }\n    elsif (\
    \ $first_consonant eq \"a\" && $last_consonant eq \"a\" ){\n        return \"\"\
    ;\n    }\n    elsif ( $first_consonant eq \"e\" && $last_consonant eq \"e\" ){\n\
    \        return \"\";\n    }\n    elsif ( $first_consonant eq \"i\" && $last_consonant\
    \ eq \"i\" ){\n        return \"\";\n    }\n    elsif ( $first_consonant eq \"\
    o\" && $last_consonant eq \"o\" ){\n        return \"\";\n    }\n    elsif ( $first_consonant\
    \ eq \"u\" && $last_consonant eq \"u\" ){\n        return \"\";\n    }\n    elsif\
    \ ( $first_consonant eq \"a\" && $last_consonant eq \"a\" ){\n        return \"\
    \";\n    }\n    elsif ( $first_consonant eq \"e\" && $last_consonant eq \"e\"\
    \ ){\n        return \"\";\n    }\n    elsif ( $first_consonant eq \"i\" && $last_consonant\
    \ eq \"i", "    $word =~ tr/[a-z]/[A-Z]/;\n    my @vowels;\n    my $count = 0;\n\
    \    \n    for my $i (0 .. length($word) - 1) {\n        my $char = $word[$i];\n\
    \        \n        if ($char =~ m/a|e|i|o|u/) {\n            $count += 1;\n  \
    \          push @vowels, $char;\n        }\n    }\n    \n    my $min = abs($count)\
    \ - 1;\n    my $max = length($word) - 1;\n    \n    if ($min <= $max) {\n    \
    \    return $vowels[$min];\n    }\n    \n    return undef;\n}", "    $word =~\
    \ tr/AEIOUYaeiouyAEIOUY/AEIOUY/;\n    foreach my $consonant ( qw(B C D F G H J\
    \ K L M N P Q R S T V W)) {\n        my $len = length($word) - length($consonant);\n\
    \        my $i = 0;\n        while (1) {\n            $i++;\n            if (\
    \ $word[$i] =~ /^[BCDFGHJKLMNPQRSTVW]$/i) { last; }\n        }\n        my $left\
    \ = $i - $len + 1;\n        $i -= 1;\n        $len -= 1;\n        my $right =\
    \ $i + $len;\n        $len += 1;\n        if ($left >= 0 && $left < length($consonant)\n\
    \            && $right >= 0 && $right < length($consonant)\n            && $word[$left]\
    \ =~ /^[AEIOUY]$/i\n            && $word[$right] =~ /^[AEIOUY]$/i) {\n       \
    \     return $consonant;\n        }\n    }\n    return \"\";\n}", "    my $first_consonant\
    \ = \"[bcdfghjklmnpqrstvwxyz]*\";\n    my $last_consonant = \"[bcdfghjklmnpqrstvwxyz]*$\"\
    ;\n    my $vowel = $first_consonant.\"[aeiouy]\".$last_consonant;\n    $word =~\
    \ /$vowel/;\n    return $1;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=perl,regex\
    \ dscore=2 |>\n<code>\n/[aeiou](?=[^aeiou]*[aeiou])/\n</code>\nor\n<code>\n/[aeiou](?![aeiou]*[aeiou])/\n\
    </code>\nor\n<code>\n/[aeiou](?=[^aeiou]*y|[^aeiou]*[aeiou])/\n</code>\nor\n<code>\n\
    /[aeiou](?![aeiou]*y|[^aeiou]*[aeiou])/\n</code>\nor\n<code>\n/[aeiou](?=[^aeiou]*[^aeiou])/\n\
    </code>\nor\n<code>\n/[aeiou](?![aeiou]*[^aeiou])/\n</code>\nor\n<code>\n/[aeiou](?=[^aeiou]*[aeiou])/\n\
    </code>\nor\n<code>\n/[aeiou](?![aeiou]*[aeiou])/\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>\nmy $vowels = \"aeiou\";\nmy $pattern = join '', map \"[^$vowels]*$_\"\
    , \"$vowels\";\nmy $regex = qr/$pattern/;\n</code>\n<|/ a tags=perl,regex |>\n\
    <| c |>\nI got this error `Unrecognized character in regex; marked by <-- HERE\
    \ after \\pL at -e:1` with perl 5.18.2 on Windows. Do you know why?\n<|/ c |>\n\
    <| a tags=perl,regex |>\nThe most succinct and general solution would be to concatenate\
    \ \"[^\"]*\" and then your letters, like so:\n<code>\ns/([^\"]*$)(\\w)/$1$2/g;\n\
    </code>\nThis will insert a $ at the end of your string, if $ is the last character\
    \ in the string.  So if you had \"Yogurt\" as your string, this would leave \"\
    Yogurt\" as the only match.\n<|/ a dscore=1 |>\n<| c |>\nWhat about this case",
  "    my($c1,$c2);\n    foreach $c1 (qw(a e i o u)) {\n        foreach $c2 (qw(A\
    \ E I O U)) {\n            foreach my $word (split //, $word) {\n            \
    \    if ($word eq $c1 . \"$c2\") {\n                    $word = substr $word,\
    \ 1, 1 . \"-\" . substr $word, -1;\n                }\n                if ($word\
    \ eq \"$c1$c2\") {\n                    $word = substr $word, 1, 1 . \"-\" . substr\
    \ $word, -1;\n                }\n                if ($word eq \"$c1\" . \"-$c2\"\
    ) {\n                    $word = substr $word, 1, 1 . \"-\" . substr $word, -1;\n\
    \                }\n            }\n            if ($word ne $c1 . \"$c2\") {\n\
    \                if ($word eq \"$c1\" . \"-$c2\") {\n                    $word\
    \ = substr $word, 1, 1 . \"-\" . substr $word, -1;\n                }\n      \
    \      }\n            if ($word ne \"$c1$c2\") {\n                if ($word eq\
    \ \"-$c1$c2\") {\n                    $word = substr $word, 1, 1 . \"-\" . substr\
    \ $word, -1;\n                }\n            }\n            if ($word ne \"-$c1$c2\"\
    ) {\n                if ($word eq \"$c1\" . \"-$c2\") {\n                    $word\
    \ = substr $word, 1, 1 . \"-\" . substr $word, -1;\n                }\n      \
    \      }\n            if ($word ne \"-$c1\" . \"-$c2\") {\n                if\
    \ ($word eq \"-$c1\" . \"-$c2\") {\n                    $word = substr $word,\
    \ 1, 1 . \"-\" . substr $word, -1;\n                }\n            }\n       \
    \     if ($word ne \"-$c1$c2\") {\n                if ($word eq \"-$c1\" . \"\
    -$c2\") {\n                    $word = substr $word, 1, 1 . \"-\" . substr $word,\
    \ -1;\n                }\n            }\n            if ($word ne \"-$c1-$c2\"\
    ) {\n                if ($word eq \"-$c1-$c2\") {\n                    $word =\
    \ substr $word, 1, 1 . \"-\" . substr $word, -1;\n                }\n        \
    \    }\n            if ($word ne \"-$c1-$c2\") {\n                if ($word eq\
    \ \"-$c1-$c2\") {\n                    $word = substr $word, 1, 1 . \"-\" . substr\
    \ $word, -1;\n                }\n            }\n            if ($word ne \"-$c1-$c2\"\
    ) {\n                if ($", "    $word =~ tr/a-zA-Z//;\n    $word =~ tr/aeiouAEIOU//;\n\
    \    $word =~ tr/bcdfghjklmnopqrstuvwxyzBCDFGHJKLMNOPQRSTUVWXYZ//d;\n    my $count\
    \ = 0;\n    for (split('', $word)) {\n        my $x = $_;\n        if ($x =~ m/^[aeiouAEIOU]/)\
    \ {\n            if ($count > 0) {\n                return $x;\n            }\n\
    \            $count++;\n        }\n    }\n    return '';\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=perl,regex |>\nThis can be done with a single regex like this:\n\
    <code>\nuse strict;\nuse warnings;", "    \n    return $word =~ /((?i)[aeiou])(?=[^aeiou]*[aeiou])/i\
    \ && $1 || \"\";\n}\n</code>\n<|/ a tags=perl,regex dscore=2 |>\n<| c |>\n`/(?<=\\\
    p{L})\\p{Lu}(?=\\p{L})/u` might be more robust.\n<|/ c |>\n<| c |>\n, What is\
    \ the difference between the two regex you posted?\n<|/ c |>\n<| c |>\n: Nothing,\
    \ apart from performance. The `(?<=...)` lookbehind requires Perl version 5.10\
    \ or later.\n<|/ c |>\n<| c |>\n`(?<=\\p{L})\\p{Lu}(?=\\p{L})` looks very weird\
    \ :)\n<|/ c |>\n<| c |>\n: Perhaps. But it works for OP's example inputs. `(?<=...)`\
    \ matches what it says. :)\n<|/ c |>\n<| a tags=perl,regex |>\nYou can try this\
    \ regex:\n<code>\n([^\\p{L}]|(?<=\\p{L}))\\p{Lu}(?=(\\p{L}|$))\n</code>\nRegex101\
    \ Demo\nExplanation\n<|/ a dscore=2 |>\n<| c |>\nThank you very much for your\
    \ answer. I had tried something like this but couldn't come up with something\
    \ that works. I didn't realize that using lookbehinds would help.\n<|/ c |>\n\
    <| c |>\nOne more question: what does the | operator do? It seems to create a\
    \ alternation\n<|/ c |>\n<| c |>\n`\\p{L}` matches `L` and so does `|` in `(?:L|$)`\n\
    <|/ c |>\n<| c |>\nOhh I see. So that's basically a pipe between 2 groups\n<|/\
    \ c |>\n<| a tags=perl,regex |>\nIf you allow the string to be empty, here's a\
    \ solution:\n<code>\nuse warnings;\nuse strict;\nuse feature 'say';", "    my(@vowels)\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my($min_index, $max_index)\
    \ = (0, -1);\n    foreach my $i (0..length($word) - 1) {\n        my $c = substr($word,\
    \ $i + 1, 1);\n        my $vowel = grep ($c =~ /[aeiou]/i, @vowels);\n       \
    \ if ($vowel) {\n            if ($c =~ /^$vowel$/i) {\n                $min_index\
    \ = $i;\n                $max_index = $i;\n            }\n        } else {\n \
    \           if ($c =~ /^[b-df-hj-np-tv-z]/i) {\n                $min_index = $i;\n\
    \                $max_index = $i;\n            }\n        }\n    }\n    return\
    \ \"\" if (!defined($min_index));\n    my $vowel_start = substr($word, 0, $min_index\
    \ + 1);\n    my $vowel_end = substr($word, $max_index + 1, 1);\n    if ($vowel_start\
    \ eq $vowel_end) {\n        return $vowel_end;\n    } else {\n        return $vowel_start;\n\
    \    }\n}", "    my(@vowels) = qw(A E I O U); # Only the vowels\n    my($vowel);\n\
    \    foreach $vowel (@vowels) {\n        if ($word =~ /(?<!^)($vowel)(?!$)/) {\n\
    \            $vowel = $vowel;\n            last;\n        }\n    }\n    return\
    \ $vowel;\n}\n</code>\n<|/ a tags=perl,regex,python,grep |>\n<| a dscore=2 tags=perl,regex,python,grep\
    \ |>\nYou could use re module in python:\n<code>\nimport re\ndef get_closest_vowel(word):\n\
    \    for v in 'AEIOUaeiou':\n        if re.search(r'[^aeiou]'+v+'[^aeiou]', word,\
    \ re.IGNORECASE):\n            return v\n    return ''\n</code>\nFor example:\n\
    <code>\n>>> get_closest_vowel('ab')\n''\n>>> get_closest_vowel('a')\n'a'\n>>>\
    \ get_closest_vowel('abba')\n'u'\n>>> get_closest_vowel('abbabba')\n'u'\n>>> get_closest_vowel('abbaabba')\n\
    ''\n</code>\n<|/ a |>\n<| c |>\nThank you! This works great for the example, but\
    \ when I try it on the actual data set I'm testing it on, I'm getting a list index\
    \ out of range error. The only difference is this one word: Ahmet\n<|/ c |>\n\
    <| c |>\nThis code is not giving any error in my environment. Do you have a `word`\
    \ variable inside `get_closest_vowel` function?\n<|/ c |>\n<| c |>\nI do have\
    \ a word variable inside get_closest_vowel. I just realized I should include more\
    \ details about what I'm doing with the word variable. I'm calling the function\
    \ like this: \nget_closest_vowel(word)\nwhere word is Ahmet from above. I'm just\
    \ not sure how to include a word variable in the function call.\n<|/ c |>\n<|\
    \ c |>\nOkay, I understand now. I misunderstood the error. I tried the code you\
    \ suggested and I'm still getting the list index out of range error. I'm not sure\
    \ what's going on. It has to be something with the word variable, maybe it's trying\
    \ to find something that doesn't exist.\n<|/ c |>\n<| c |>\nWhat is the value\
    \ of `word`? Could you print it out?\n<|/ c |>\n<| a |>\n<code>\nimport re", " \
    \   my(@letters) = split '', $word;", "    my $vowel = $word;\n    while ($vowel\
    \ =~ /[aeiou]/) {\n        last if ($vowel =~ m/^[aeiou]$/);\n        $vowel =~\
    \ s/^([aeiou]+)$/\\U$1/g;\n    }\n    return $vowel;\n}", "    \n    if ($word\
    \ =~ /^[aeiou]/) {\n        return $word;\n    }\n    \n    my $vowel = 'u' if\
    \ $word =~ /^y/i;\n    $vowel .= 's' if $word =~ /^u/i;\n    $vowel .= 'i' if\
    \ $word =~ /^a/i;\n    $vowel .= 'o' if $word =~ /^o/i;\n    $vowel .= 'r' if\
    \ $word =~ /^o/i;\n    $vowel .= 'l' if $word =~ /^a/i;\n    return $vowel;\n}",
  "    my($consonants,$vowels,$left,$right) = split(//,$word);\n    my $left_vowel\
    \ = $left =~ m/[AEIOU]/;\n    my $right_vowel = $right =~ m/[AEIOU]/;\n    my\
    \ $vowel_found = 0;\n    foreach $consonants(@_) {\n        $vowel_found++;\n\
    \    }\n    return $vowels[$vowel_found-1] if $left_vowel && $right_vowel;\n \
    \   return \"\";\n}\n</code>\n<|/ a tags=algorithm,perl,regex |>\n<| c |>\nThis\
    \ was actually my first solution. But in this case I was not allowed to use any\
    \ extra variables and my code was getting pretty long and hard to read. \nI posted\
    \ the original question because I was looking for some insight if anyone can think\
    \ of another solution.\n<|/ c |>\n<| a tags=algorithm,perl,regex |>\nHere's a\
    \ solution in Perl using the tr/// operator to transform the string to uppercase,\
    \ then using a regex match to find vowels at the end of the string. \n<code>\n\
    use strict;\nuse warnings;", "    my(@vowels) = ('a', 'e', 'i', 'o', 'u');\n \
    \   my(@consonants) = ('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z');\n    my($index, $consonant,\
    \ $vowel);\n    $index = 0;\n    while ($index < scalar(@consonants)) {\n    \
    \    $consonant = $consonants[$index];\n        $vowel = $vowels[$index];\n  \
    \      # print STDERR \"consonant: $consonant, vowel: $vowel\\n\";\n        $index\
    \ += 1;\n        # print STDERR \"index: \" . $index . \", consonant: \" . $consonant\
    \ . \", vowel: \" . $vowel . \"\\n\";\n        if ($vowel =~ /^$consonant/i) {\n\
    \            last if ($index == scalar(@consonants));\n            return $vowel;\n\
    \        }\n    }\n}", '    my @vowels = qw(a e i o u);', "    return substr($word,\
    \ -4, 1) if $word =~ /[AEIOUYaeiouy]+/;\n    return $word;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a tags=string,perl dscore=1 |>\nIf your regex is sufficiently\
    \ complex, this approach is more robust.  It also allows for cases where a character\
    \ is not in the string.  \n<code>\nuse strict;\nuse warnings;", "    my(@vowels)\
    \ = qw(a e i o u);\n    my(@left) = split('[[:upper:]]', $word);\n    my(@right)\
    \ = split('[[:lower:]]', uc($word));\n    \n    my($leftIndex);\n    my($rightIndex);\n\
    \    my($min);\n    my($pos);\n    \n    for my $i ( 0 .. $#left ) {\n       \
    \ foreach my $j ( 0 .. $#right ) {\n            if ($left[$i] =~ /[aeiou]\\K/\
    \ ) {\n                if ($right[$j] =~ /[aeiou]\\K/ ) {\n                  \
    \  if ($i < $j) {\n                        $leftIndex = $i;\n                \
    \        $rightIndex = $j;\n                    }\n                    elsif ($i\
    \ > $j) {\n                        $leftIndex = $j;\n                        $rightIndex\
    \ = $i;\n                    }\n                    elsif ($i == $j) {\n     \
    \                   $leftIndex = $i;\n                        $rightIndex = $i;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    foreach my $letter (@vowels) {\n        if (($leftIndex == $rightIndex)\
    \ || ($leftIndex < $rightIndex)) {\n            if ($leftIndex == $rightIndex)\
    \ {\n                if (abs($leftIndex - $rightIndex) < 3) {\n              \
    \      return $letter;\n                }\n                elsif ($leftIndex >\
    \ $rightIndex) {\n                    return $letter;\n                }\n   \
    \         }\n            elsif ($leftIndex > $rightIndex) {\n                return\
    \ $letter;\n            }\n        }\n    }\n    return \"\";\n}", "    my @vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\");\n    my (@left_word);", "    \n    my\
    \ @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n    my $index = 0;\n\
    \    \n    for (my $i = length($word); $i > 0; $i--) {\n        my $char = substr($word,\
    \ $i, 1);\n        \n        if ($char =~ /^[aeiouy]/ && $index < scalar(@vowels))\
    \ {\n            return $vowels[$index++];\n        }\n    }\n    \n    return\
    \ undef;\n}\n</code>\n<|/ a tags=string,perl,regex |>\n<| c |>\n`split` would\
    \ have been my first approach but I'm very unsure how I could handle those vowels\
    \ at the beginning and end of the string in the most efficient way\n<|/ c |>\n\
    <| c |>\nThis doesn't work for the case `get_closest_vowel(\"ab\")` because `substr`\
    \ will return the entire string `\"ab\"`, which won't match the pattern.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHow about something like this?\n<code>\nuse v5.10;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
