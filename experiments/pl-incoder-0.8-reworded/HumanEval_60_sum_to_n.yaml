name: HumanEval_60_sum_to_n
language: pl
prompt: "# sum_to_n is a function that sums numbers from 1 to n.\n# >>> sum_to_n(30)\n\
  # 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n\
  # 55\n# >>> sum_to_n(1)\n# 1\nsub sum_to_n {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_to_n;\n\
  \        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(6),21)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),66))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30),465))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),5050))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $n -= 1;\n    my $total = 0;\n    for (1..$n) {\n        $total\
    \ += $_ unless $_ eq \"\\n\";\n    }\n    return $total;\n}", "    my $sum = 1;\n\
    \    for(1..$n) { $sum += $_ }\n    return $sum;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nHe does have `use strict;`... Also, it's bad style to use `return` with\
    \ no value, and you shouldn't use `for()` loops with side effects inside them\
    \ (like `return`ing the value of `$sum`). But I don't think that applies here.\n\
    <|/ c |>\n<| c |>\nYes, I did `use strict;` but forgot to mention it. Thanks.\
    \ I actually meant to do `for(1..$n) { $sum += $_ }`. Thanks for pointing out\
    \ those issues. And I agree that `return` without a value is unusual. I usually\
    \ just use `return` inside functions to return a value that I want to be used\
    \ outside of that function. It's rare that `return` is needed inside functions\
    \ in Perl. And, I think it's a good habit to get into to use `return` inside functions.\
    \ I don't think it's uncommon to see it in other programming languages, but it's\
    \ rare that Perl programmers use it this way. Thanks.\n<|/ c |>\n<| c |>\nA `return`\
    \ inside a loop is perfectly reasonable in Perl, and doesn't cause any harm at\
    \ all. It's just an extra statement, which isn't needed.\n<|/ c |>\n<| c |>\n\
    : Yes, that's true. I didn't realize `return` was a statement that could be used\
    \ in a loop. Thanks for pointing that out.\n<|/ c |>\n<| c |>\n: In Perl, a `return`\
    \ isn't a statement at all. It's a keyword that ends function execution. It can\
    \ only return a value from a function, not from a loop.\n<|/ c |>\n<| a tags=perl\
    \ dscore=0 |>\nUsing a for loop to calculate the sum is fine, even though it's\
    \ not idiomatic. \nUsing a while loop to calculate the sum is also fine. \nHowever,\
    \ a for loop to calculate the sum is more efficient than a while loop. \nThe while\
    \ loop is slightly less efficient than a for loop, but this is probably negligible\
    \ in most situations.\n<code>", "    my $sum = 1;\n    while (--$n > 0) {\n  \
    \      $sum += $_;\n    }\n    return $sum;\n}", '    my $result;', "    my $sum\
    \ = 0;\n    while ($n > 0) {\n        my $result = $n--;\n        $sum += $result;\n\
    \    }\n    return $sum;\n}", "    my($total) = 0;\n    my($i);\n    for ($i =\
    \ 1; $i <= $n; ++$i) {\n        $total += $i;\n    }\n    $total;\n}", "    return\
    \ 1 if $n == 1;\n    return $n * $n + 1;\n}", "    return 1 if $n == 1;\n    return\
    \ $n + sum_to_n($n - 1);\n}\n</code>\n<|/ a tags=algorithm,c++,functional-programming\
    \ |>\n<| a |>\nHere's a solution using tail recursion\n<code>\nint sum(int n)\n\
    {\n    if(n == 1)\n        return 1;\n    else if(n%2 == 0)\n        return n*(n-1)/2;\n\
    \    else\n        return n*(n-1)/2 + sum(n/2);\n}\n</code>\n<|/ a dscore=0 tags=algorithm,c++,functional-programming\
    \ |>\n<| c |>\nThe question was how to do it in `O(1)` space, not `O(n)`\n<|/\
    \ c |>\n<| c |>\nI see what you mean. Perhaps I misunderstood the question, but\
    \ my impression was that he was asking how to do it in O(1) space.\n<|/ c |>\n\
    <| c |>\nI meant O(1) in the sense that there's no additional memory being allocated.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nint sum(int n)\n{\n    int sum;\n    if(n\
    \ <= 0)\n        return 0;\n    if(n%2 == 0)\n        sum = n/2;\n    else\n \
    \       sum = (n-1)/2 + sum(n/2);\n    return sum;\n}\n</code>\n<|/ a tags=algorithm,c++,functional-programming\
    \ |>\n<| a dscore=0 |>\n<code>\nint sum(int n)\n{\n    if(n==0)\n    {\n     \
    \   return 0;\n    }\n    return n/2==1?n/2:n*(n-1)/2 + sum(n/2);\n}\n</code>\n\
    <|/ a tags=algorithm,c++,functional-programming |>\n<| a tags=algorithm,c++,functional-programming\
    \ |>\n<code>", "    my $nn = $n + 1;\n    my $i = 1;\n    my $res = 0;\n    while($i\
    \ < $nn) {\n        $res += $i;\n        $i++;\n    }\n    return $res;\n}", " \
    \   if($n == 1) {\n        return 1;\n    }\n    my $s = 1;\n    for(my $i = 1;\
    \ $i <= $n; $i++) {\n        $s += $i;\n    }\n    return $s;\n}", "    my $sum\
    \ = 0;\n    for(my $i = 1;$i <= $n;$i++) {\n        $sum += $i;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    $sum += 1;\n    $sum += $n if $n > 1;\n  \
    \  $sum;\n}", "    my $sum = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n     \
    \   $sum += $i;\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nIn Perl 5.8+ `sub sum_to_n { my $n = shift; my $s = 1; for (1..$n) { $s\
    \ += $_ } }` will work if you drop the `@_` and add the `return`. Using `return\
    \ $s` would probably be better.\n<|/ c |>\n<| c |>\nYou were right about `@_`.\
    \ However, I always find `my $_` more readable than `shift`. In fact I do use\
    \ them together with `@_` when they make sense.\n<|/ c |>\n<| c |>\n`@_` is more\
    \ readable; it's what makes `@_` magic, which is why it's very rarely used. (Perl's\
    \ parser is full of magic that allows one to change the behavior of a subroutine\
    \ with little effort.) The first thing that comes to mind is that `shift` allows\
    \ you to name parameters in the subroutine; it also lets you drop parameters and\
    \ return values with `return`. But if you don't use `shift` and return values,\
    \ then you don't need `@_`, so it's much better to just name the parameters.\n\
    <|/ c |>\n<| c |>\n, I've seen people use `shift` as both `return` and `parameter`\
    \ modifier (which also affects `@_` but that should not be used often).\n<|/ c\
    \ |>\n<| c |>\n, my `@_` usage is always limited to quick scripts. But I also\
    \ use them together with non-quick scripts to get full benefits of OOP.\n<|/ c\
    \ |>\n<| a |>\nThe most simple way is to pass an array:\n<code>", "    return\
    \ $n if $n < 1;\n    $n *= 2;\n    my(@sums);\n    while ($n > 0) {\n        my\
    \ $div = $n/2;\n        push, $_ = $n - $div if $div != 0;\n        $n = $div;\n\
    \    }\n    return $sums[-1] + $sums[-2]\n}", "    my $sum = 1;\n    while ($n--)\
    \ {\n        $sum += $sum + 1;\n    }\n    return $sum;\n}", "    my $s = 1;\n\
    \    while ($n--) {\n        $s += $_;\n    }\n    return $s;\n}", "    return\
    \ 0 unless defined $n;\n    return 1 + $n*$n if $n > 2;\n    return 1 + $n*$n*$n\
    \ if $n > 3;\n    return 1 + $n*$n*$n*$n if $n > 4;\n    return 1 + $n*$n*$n*$n*$n\
    \ if $n > 5;\n    return 1 + $n*$n*$n*$n*$n*$n if $n > 6;\n    return 1 + $n*$n*$n*$n*$n*$n*$n\
    \ if $n > 7;\n    return 1 + $n*$n*$n*$n*$n*$n*$n*$n if $n > 8;\n    return 1\
    \ + $n*$n*$n*$n*$n*$n*$n*$n*$n if $n > 9;\n    return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n\
    \ if $n > 10;\n    return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n if $n > 11;\n \
    \   return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n if $n > 12;\n    return\
    \ 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n if $n > 13;\n    return 1 +\
    \ $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n if $n > 14;\n    return 1 +\
    \ $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n;\n    return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n;\n\
    \    return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n;\n\
    \    return 1 + $n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n*$n;\n\
    \    return 1 + ", '    my(@results) = (1);', "    my $sum = 0;\n    for(1 ..\
    \ $n) {\n        push (@sum, $_);\n        $sum += $_;\n    }\n    return $sum;\n\
    }", "    my $sum = 0;\n    for(1 .. $n) {\n        $sum += $_;\n    }\n    return\
    \ $sum;\n}", "    return 0 if $n < 1;\n    return ($n > 1000) ? $n : ($n * $n)\
    \ - $n;\n}", "    my $sum = 1;\n    while ($n--) {\n        $sum += 1;\n    }\n\
    \    return $sum;\n}", "    return $n if $n == 0;\n    return 1 if $n == 1;\n\
    \    return $n*sum_to_n($n-1);\n}", "    my $sum = 0;\n    for (1 .. $n) {\n \
    \       $sum += $_;\n    }\n    return $sum;\n}", "    my $result = 1;\n    for(1..$n)\
    \ {\n        $result *= $_;\n    }\n    return $result;\n}", "    $n -= 1;\n \
    \   my $sum = 0;\n    while (1) {\n        $sum += $n;\n        if ($n < 1) {\n\
    \            return $sum;\n        }\n        $n -= 1;\n    }\n}", "    return\
    \ 1 if $n < 1;\n    $n -= 1;\n    return ($n + sum_to_n($n)) % $n;\n}", "    my($sum)\
    \ = 0;\n    for (my $i = 1; $i <= $n; ++$i) {\n        $sum += $i;\n    }\n  \
    \  return $sum;\n}", "    if($n < 1) {\n        die \"sum_to_n() called with n\
    \ <= 0, or n not an integer\";\n    }\n    my($sum) = 0;\n    my($i) = 0;\n  \
    \  while ($i <= $n) {\n        $sum = $sum + $i;\n        $i = $i + 1;\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThe OP didn't specify whether\
    \ they wanted the result to be an unsigned or signed integer.\n<|/ c |>\n<| c\
    \ |>\nYeah, I noticed that shortly after posting but didn't realise it until I\
    \ added this answer.  Thanks for the comment, I'll leave the answer here in case\
    \ it helps anyone else that isn't interested in the binary version anymore.\n\
    <|/ c |>\n<| a |>\nThe other answers here don't handle the negative number correctly.\
    \ Here's my solution:\n<code>\nmy $n = 5;", "    my $n = 0;\n    my $sum;\n  \
    \  while(@_) {\n\t$sum += $_;\n\tshift @_;\n    }\n    $sum;\n}", "    my($sum)\
    \ = 0;\n    my(@results);\n    foreach my $i (1..$n) {\n        $sum = $sum +\
    \ $i;\n    }\n    $sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nPerhaps\
    \ a clearer and less code solution would be to simply use the built-in reduce\
    \ function with the addition operator (+).\n<code>", "    $n = $n->int if $n->is_a('Math::BigInt');\n\
    \    my $result = 1;\n    for (my $i = 0; $i < $n; $i++) {\n        $result *=\
    \ $i;\n    }\n    return $result;\n}", "    my $total = 0;\n    for (1 .. $n)\
    \ {\n        $total += $_;\n    }\n    return $total;\n}", "    my $sum = 0;\n\
    \    foreach my $i (1..$n) {\n        $sum += $i;\n    }\n    return $sum;\n}",
  "    my $sum = 1 + ( $n == 1 );\n    for ( 1 .. $n ) {\n        $sum += 1;\n   \
    \ }\n    return $sum;\n}", "    my $sum = 0;\n    for(1..$n) {\n        my $temp\
    \ = $_;\n        $sum += $temp;\n    }\n    return $sum;\n}", "    my($sum);\n\
    \    for(1..$n) {\n        $sum += $_ unless $_ % 2;\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a dscore=4 tags=perl |>\n<| a tags=perl |>\nHere's how I did it\
    \ in a very simple way. \n<code>\n$ cat sum.pl ", "    $n == $n-1 or $n eq \"\
    0\"\n        or die(\"Not valid number: $n\");\n    my($sum);\n    foreach my\
    \ $i (1 .. $n) {\n        $sum += $i;\n    }\n    return $sum;\n}", "    my $acc\
    \ = 1;\n    for (0..$n-1) {\n        $acc += $n;\n    }\n    return $acc;\n}",
  "    my $total = 0;\n    for(my $i=1; $i<$n; $i++) {\n        $total += $i;\n  \
    \  }\n    return $total;\n}", "    return undef unless $n;\n    my $sum = 0;\n\
    \    for my $i (1 .. $n) {\n        $sum += $i;\n    }\n    return $sum;\n}",
  "    my($sum);\n    my(@numbers) = @_;\n    my $current_number = 0;\n    my $next_number\
    \ = 0;\n    my $previous_number = 0;\n    my $sum = 0;", "    if ($n < 0) {\n\
    \        croak 'usage: sum_to_n(n)';\n    }\n    my $sum = 0;\n    $sum += $_\
    \ for *{sum_to_n($n-$_)};\n    return $sum;\n}", "    $n += 1 if $n == 1;\n  \
    \  return 0 if $n <= 0;\n    my $s = 1;\n    while ($n < 0) { $s *= $n--; $s =\
    \ -1 if $s < 0;  }\n    return $s * $n;\n}", "    my $result = 1;\n    while ($n\
    \ > 0) {\n        $result = $result * (--$n);\n    }\n    return $result;\n}",
  "    my $total = 0;\n    for(1 .. $n) {\n        $total += $_;\n    }\n    return\
    \ $total;\n}", "    my $sum;\n    my $i = 0;\n    my $tmp = $n;\n    while ($tmp\
    \ > 1) {\n        $sum += $i++;\n        $tmp /= 2;\n    }\n    return $sum;\n\
    }", "    if($n) {\n        $n *= 2;\n        for(my $i = 1; $i < $n; ++$i) {\n\
    \            $n -= $i;\n            if(-e $i) {\n                chdir($i);\n\
    \                chdir('..');\n            }\n        }\n        return $n;\n\
    \    }\n}", "    my $sum = 0;\n    for(my $i = 1; $i <= $n; ++$i) {\n        $sum\
    \ += $i;\n    }\n    return $sum;\n}", "    my $total = 1;\n    $total += $_ for\
    \ 1 .. $n;\n    return $total;\n}", "    my $sum;\n    for(1..$n){\n        $sum\
    \ += $i;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for ($n; $n > 0;\
    \ $n--) { $sum += $_ };\n    return $sum;\n}", "    my $i = 0;\n    my $sum =\
    \ 0;\n    while ($i <= $n) {\n        $sum += $i++;\n    }\n    return $sum;\n\
    }", "    my $sum = 0;\n    for(my $i = 1; $i <= $n; ++$i) {\n        $sum += $i;\n\
    \    }\n    return $sum;\n}\n</code>\nAs you can see, the code doesn't even need\
    \ to use an explicit loop here. The code works equally well as a for loop:\n<code>",
  "    my $sum = 0;\n    while($n) { $sum += $n--; }\n    $sum;\n}\n</code>\n<|/ a\
    \ tags=while-loop,perl dscore=5 |>\n<| c |>\nIn Perl 5.14, you can write `my $sum\
    \ = 0; while (...) { $sum += ...; }` instead of `my $sum; $sum += ...; $sum;`\n\
    <|/ c |>\n<| c |>\nThe last paragraph of this answer should be an edit to the\
    \ original question. Also, the first line should probably say \"In Perl 5.14...\"\
    \n<|/ c |>\n<| c |>\n`my $sum` is clearer than `$sum = 0`.\n<|/ c |>\n<| c |>\n\
    Why not use `$_ = $_ * 2` ?\n<|/ c |>\n<| c |>\n: What is the point of using `$_`?\
    \ `my $sum * 2` will do just fine, since `*` is the infix operator for multiplication.\n\
    <|/ c |>\n<| a tags=while-loop,perl |>\nHere's another way to do the same thing\
    \ in a single line using a ternary operator:\n<code>\nmy $sum = 0;\nmy $number\
    \ = 23;\n$sum += $number > 0 ? $number : -$number;\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis is the \"cleanest\" way I found to do the same thing in Perl 5.10.0.\n\
    <|/ c |>\n<| c |>\nThe `my $sum = 0;` and the `$sum += $number ...` can be dropped;\
    \ the `my $sum = 0` will reset the `$sum` variable.\n<|/ c |>\n<| c |>\nThis is\
    \ not cleanest.  It doesn't do what the question asks for - it adds numbers, rather\
    \ than just summing numbers.  Also, it adds numbers together.\n<|/ c |>\n<| c\
    \ |>\nI edited the answer to account for that. You are correct that it adds numbers\
    \ together (as opposed to summing them), but it does this in a single line.\n\
    <|/ c |>\n<| c |>\nIt also adds numbers together if you use 0, because `0>0` is\
    \ true in Perl. So, instead of `0`, use `undef`: `$sum += $number > undef ? $number\
    \ : -$number;`.\n<|/ c |>\n<| a tags=while-loop,perl dscore=5 |>\nI prefer the\
    \ following idiom\n<code>\nmy $sum = do {  ... }\n</code>\n", "    if ($n < 1)\
    \ {\n        return 1;\n    }\n    my $n2 = $n / 2;\n    return $n2 + sum_to_n($n2);\n\
    }", "    my $sum = 0;\n    while ($n) { $sum+=$n; $n-=1 }\n    return $sum;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "    my $s = 0;\n    for(my $i\
    \ = 1; $i <= $n; $i++) {\n        $s += $i;\n    }\n    return $s;\n}", "    return\
    \ 1 if $n < 1;\n    return $n * (sum_to_n($n - 1)) + 1;\n}", "    $n = 0 unless\
    \ defined $n;\n    my $total = 1;\n    my $x;\n    my $i = ($n >> 1);\n    while\
    \ (defined $i) {\n        $total *= $i;\n        $total += $n++;\n        $x =\
    \ ($n >> 1);\n        $n -= $x;\n        $i = (($n+1)/2);\n    }\n    return $total;\n\
    }", "    return 1 + 1 + @{$_[0]} * ($n / 10) if $n % 10;\n    return 1 + 1 + @{$_[0]};\n\
    }", "    my $sum = 0;\n    my $ntimes = 0;\n    while ($ntimes++ <= $n) {\n  \
    \      $sum += $ntimes;\n    }\n    return $sum;\n}", "    return ($n > 0) ? sum_to_n($n\
    \ - 1) + $n : 1;\n}", "    my $res = 1;\n    foreach my $i (1..$n) {\n       \
    \ $res += $i;\n    }\n    return $res;\n}", "    my $sum;\n    foreach my $num(1..$n)\
    \ {\n        my $res = $sum + $num;\n        $sum = $res;\n    }\n    return $sum;\n\
    }", "    my($sum) = 0;\n    while ($n > 0) {\n        $sum += $n--;\n    }\n \
    \   return $sum;\n}", "    my $nsum = 0;\n    1 while $nsum < $n;\n    return\
    \ $nsum;\n}", "    my $nn = $n;\n    my $sum = 0;\n    while($nn > 0) {\n\t$sum\
    \ += $nn;\n\t$nn -= 1;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        $sum = $sum + $i;\n    }\n    return $sum;\n\
    }", "    my $result = 1;\n    while($n > 0) {\n        $result += $n--;\n    }\n\
    \    return $result;\n}", "    if ($n < $self->{n}) {\n        return $n;\n  \
    \  }\n    my $sum = 0;\n    for (my $i = 0; $i < $self->{n}; $i++) {\n       \
    \ $sum += $self->{arr}->[$i];\n    }\n    return $sum;\n}", "    my $sum = 0;\n\
    \    my $i;\n    for ($i = 1; $i <= $n; $i++) {\n        $sum += $i;\n    }\n\
    \    return $sum;\n}", "    my $total = 1;\n    for(1 .. $n) {\n        $total\
    \ += $_;\n    }\n    $total;\n}", "    $n++ while $n > 0;\n    return $n\n}",
  "    return 1 if $n <= 0;\n    return $n * sum_to_n($n - 1);\n}", "    my $s = 0;\n\
    \    for($n..1) {\n        $s += $_;\n    }\n    return $s;\n}", "    my $sum\
    \ = 0;\n    my $i = 0; # iterator\n    while(1) {\n\t$sum += $i; # $i = i * $i\n\
    \t$i++;\n\tlast if $i >= $n; # stop if $i >=  $n\n    }\n    return $sum;\n}",
  "    my($sum) = 0;\n    my($max) = 0;\n    while(my($t) = @_) {\n        $sum +=\
    \ $t;\n        $max = $max < $t ? $max : $t;\n    }\n    return $sum/$max;\n}",
  "    my $s = 1;\n    my $sum = 0;\n    while($s<=$n) {\n        $sum+=$s;\n    \
    \    $s++;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    my $i = 1;\n \
    \   my $j = 1;\n    while (1) {\n        $sum += $j;\n        if ($j > $n) {\n\
    \            $j = 1;\n        }\n        else {\n            $j++;\n        }\n\
    \        $i++;\n        if ($i eq $n) {\n            return $sum;\n        }\n\
    \    }\n}", "    return 1 unless $n;\n    my $sum = 0;\n    for (1 .. $n) {\n\
    \        $sum += 1;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for (\
    \ 1 .. $n ) {\n        $sum += $_;\n    }\n    $sum;\n}", "    return 1 unless\
    \ defined $n;\n    my $result = 1;\n    for (my $i = 1; $i <= $n; $i++) {\n  \
    \      $result *= $i;\n    }\n    return $result;\n}", "    my $result = 1;\n\
    \    while($n) {\n        $result *= $n--;\n    }\n    return $result;\n}", " \
    \   my $s = $sum;\n    my $sum = 0;\n    for (1..$n) { $sum += $_; }\n    return\
    \ $s;\n}", "    my $s = 0;\n    while(@_) {\n        $s += $_[0] % $n;\n     \
    \   shift;\n    }\n    $s;\n}", "    my($sum);\n    my @res;\n    for(1..$n){\n\
    \        push(@res, $sum + $_ - 1 );\n    }\n    $sum;\n}", '    return 1 unless
    $n;', "    my $sum = 1;\n    while (1 <= $n) {\n        $sum += $n;\n        $n--;\n\
    \    }\n    return $sum;\n}", "    my $sum;\n    for($sum = 0; $sum < $n; ++$sum)\
    \ {\n        $sum = $sum + $sum;\n    }\n    return $sum;\n}", "    my $s = $self->{sum};\n\
    \    my $result = $s;\n    my $i = $self->{value};\n    while ($i < $n) {\n  \
    \      $result += $i;\n        $i++;\n    }\n    $result;\n}", "    my $sum =\
    \ 1;\n    my $i;", "    if($n == 1) {\n        return 1;\n    }\n    else {\n\
    \        my($sum) = 0;\n        for(my $i = 1; $i <= $n; $i++) {\n           \
    \ $sum += $i;\n        }\n        return $sum;\n    }\n}", "    my($sum);\n  \
    \  my $i = 0;\n    my $last_digit;\n    while (1) {\n        $sum += $i++;\n \
    \       $last_digit = $sum % 10;\n        last unless $last_digit;\n        $sum\
    \ += $last_digit * $last_digit * $last_digit;\n    }\n    $sum;\n}", "    $_ +=\
    \ 1 while $n != 0;\n    return $n;\n}", "    my $sum = 1;\n    for (1 .. $n) {\n\
    \        $sum *= $_;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    while\
    \ ($n > 1) {\n        $sum += $n;\n        last if ($sum > $n);\n        my $n\
    \ = $n / 2;\n    }\n    return $sum;\n}", '    my $n = $#_ + 1 unless defined
    $n;', "    my $sum = 0;\n    for ($n..1) {\n        $sum += $n;\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a tags=perl,math,algorithm |>\n<| c |>\nIn fact, I'm\
    \ now in the middle of reading your first book on Perl programming!\n<|/ c |>\n\
    <| a dscore=0 |>\nIt seems to me that the function you provided sum_to_n is incorrect.\
    \ It should start at 1. As it stands, it sums 2 to n-1, inclusive, which is different\
    \ than what it actually does.\n<code>", "    my($sum);\n    my $counter = 0;\n\
    \    while (--$n) {\n        $sum += $counter++;\n    }\n    return $sum;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI thought about that too, but I didn't want to bring\
    \ in Math::BigInt, and I'm not sure if that's going to be any more efficient.\
    \ Thanks for the quick answer!\n<|/ c |>\n<| a |>\n<code>", "    my $total = 0;\n\
    \    for (my $i = 0; $i <= $n; $i++) {\n        $total += $i;\n    }\n    return\
    \ $total;\n}", "    my $a = $n;\n    $a = 0 if $a < 1;\n    my $sum = 0;\n   \
    \ while ($a>0){\n        $sum += $a--;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere are a couple of simple ways to go about\
    \ summing up numbers using recursion. First, a non-recursive version:\n<code>",
  "    my($sum) = 0;\n    my($counter) = 1;\n    while ($counter <= $n) {\n      \
    \  $sum += $counter;\n        $counter++;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=4 tags=functional-programming,recursion,function,perl |>\n<| c |>\n\
    Thanks for sharing this. It is really helpful!\n<|/ c |>\n<| a tags=functional-programming,recursion,function,perl\
    \ |>\n<code>", "    return 0 if $n < 1;\n    my $s = 0;\n    my $k = 0;\n    while\
    \ ($k < $n) {\n        $s += $_; $k++;\n    }\n    return $s;\n}", "    return\
    \ 1 if $n < 1;\n    my $result = 0;\n    for (my $i = 1; $i <= $n; ++$i) {\n \
    \       $result += $i;\n    }\n    $result;\n}", "    my $s = 1;\n    while (@_)\
    \ {\n        $s += $_;\n        shift;\n    }\n    return $s;\n}", "    my $n\
    \ = $n+1;\n    return $n if $n <= 0;\n    my $s = 1;\n    my $sum = 0;\n    while($n\
    \ != 0) {\n        $sum = $sum + $s if $n % 2;\n        $s = $s * $s;\n      \
    \  $n = $n/2;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for(my $i =\
    \ 0; $i < $n; $i++) {\n        my $n = $n + $i;\n        $sum += $n;\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nHow does this answer\
    \ the question?\n<|/ c |>\n<| c |>\n`perl` doesn't have a native `sum` function,\
    \ it requires `Math::Sum` module to work, and it uses `sum` from that module to\
    \ do the summation. Also, `perl` does have a native `sum` function. See [`perldoc\
    \ -f sum`](http://perldoc.perl.org/functions/sum.html) for details.\n<|/ c |>\n\
    <| c |>\nIt doesn't answer the question, because it doesn't answer the question\
    \ in all cases. Your `sum_to_n` is O(n), and `sum_to_n` was the question OP asked\n\
    <|/ c |>\n<| c |>\nThis is an incredibly terrible answer, because it doesn't actually\
    \ answer the question. `sum_to_n($n)` returns the sum of `n` numbers from `1`\
    \ to `n`.\n<|/ c |>\n<| c |>\nOh wow... thanks for catching that. I updated my\
    \ answer to include what I was actually talking about.\n<|/ c |>\n<| a dscore=4\
    \ tags=perl |>\nYou can add this as a core module if you want :\n<code>\nuse v5.10;\n\
    use strict;\nuse warnings;\nuse autodie;\nuse feature qw(say);\nuse autodie qw(open);\n\
    use IO::Handle;\nuse Symbol qw<gensym>;\nuse Text::CSV;\nuse Math::Sum::Subset\
    \ qw<sum>;", "    my $sum;\n    for my $i (0..($n-1)) {\n        $sum += $i +\
    \ 1;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    while($n--) {\n    \
    \    $sum += $_;\n    }\n    return $sum;\n}", "    return $n if $n == 0;\n  \
    \  return $n;\n}\n</cell>\n<text>\nNow let's see some Python code and see how\
    \ the program works.", "    my $sum = 0;\n    for (1 .. $n) {\n        $sum +=\
    \ $_;\n    }\n    return $sum;\n}", "    return $n if $n =~ /^[+-]?\\d+$/;\n \
    \   my $sum = 0;\n    my $i;\n    for ($i = 1; $i <= $n; $i++) {\n        $sum\
    \ += $i;\n    }\n    return $sum;\n}", "    if ($n < 1) {\n        return 1;\n\
    \    }\n    my $s = 0;\n    for(1 .. $n) {\n        $s += $_;\n    }\n    return\
    \ $s;\n}", "    my $sum = 0;\n    my $i = 1;\n    while ($i < $n) {\n        $sum\
    \ += $i;\n        $i++;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for\
    \ (1 .. $n){\n        $sum += $_;\n    }\n    return $sum;\n}", "    return 0\
    \ if $n < 0;\n    my($sum) = 0;\n    for(1..$n) {\n        $sum += $_;\n    }\n\
    \    return $sum;\n}", "    my $sum = 0;\n    for (my $i = 1;  $i <= $n;  ++$i)\
    \ {\n        my $n = $i;\n        $sum += $i * $n;\n    }\n    return $sum;\n}",
  "    my $nsum = 0;\n    for (1 .. $n) {\n        $nsum += $_;\n    }\n    return\
    \ $nsum;\n}", "    my $s = $n * $n;\n    $s > $n or $s .= $n + 1\n    }", "  \
    \  return $n if $n <= 1;\n    my($sum) = $_;\n    return $sum if $sum < $n;\n\
    \    $sum = $_ + $sum;\n    return $sum if $sum < $n;\n    $sum = $sum + $sum;\n\
    \    return $sum if $sum < $n;\n    $sum = $sum + $sum;\n    return $sum if $sum\
    \ < $n;\n    $sum = $sum + $sum;\n    return $sum if $sum < $n;\n    $sum = $sum\
    \ + $sum;\n    return $sum if $sum < $n;\n    $sum = $sum + $sum;\n    return\
    \ $sum if $sum < $n;\n    $sum = $sum + $sum;\n    return $sum if $sum < $n;\n\
    \    $sum = $sum + $sum;\n    return $sum if $sum < $n;\n    $sum = $sum + $sum;\n\
    \    return $sum if $sum < $n;\n    $sum = $sum + $sum;\n    return $sum if $sum\
    \ < $n;\n    $sum = $sum + $sum;\n    return $sum if $sum < $n;\n    $sum = $sum\
    \ + $sum;\n    return $sum if $sum < $n;\n}", "    return 0 unless $n;\n    my\
    \ $nn = $n + 1;\n    return $n * ($nn * $nn) / $nn;\n}\n</code>\nThe first thing\
    \ to realize is that sum_to_n is a function that sums numbers from 1 to n.  The\
    \ second thing to realize is that if n is even then n/2 is odd so it sums from\
    \ 1 to n-2 so it's really n(n+1)/2.  Once you realize that the first thing you\
    \ can simplify your problem is to sum to n rather than n+1.  That means your function\
    \ will look something like:\n<code>", "    my $sum = 0;\n    while ($n--) {\n\
    \        $sum += $n;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for\
    \ (1 .. $n) {\n        $sum += $_;\n    }\n    return $sum;\n}", "    my $a =\
    \ 0;\n    for(1 .. $n) {\n        $a += $_;\n    }\n    return $a;\n}", "    my\
    \ $sum = 0;\n    while (@_) {\n        $sum += $_[0] if $_[0] > 0;\n        shift;\n\
    \    }\n    return $sum;\n}", '    return 1 unless $n;', "    my($sum) = 0;\n\
    \    for (my $i = 1; $i < $n; $i++) {\n        $sum += $i;\n    }\n    return\
    \ $sum;\n}", "    my $total = 1;\n    while ($n > 0) {\n\t$total += $n & 1;\n\t\
    $n >>= 1;\n    }\n    return $total;\n}", "    my $sum = 0;\n    while ($n > 0)\
    \ {\n        $sum++ while $n--;\n    }\n    $sum\n}", "    $n += 1;\n    return\
    \ $n;\n}", "    my $sum = 1;\n    while (--$n) {\n        $sum *= $n;\n    }\n\
    \    $sum;\n}", "    my $s = 0;\n    while($n > 1) {\n        my $n = $n % 2;\n\
    \        $s += $n;\n        $n /= 2;\n    }\n    return $s;\n}", "    my $sum\
    \ = 0;\n    for (1 .. $n) {\n        $sum += 1;\n    }\n    return $sum;\n}",
  "    my $sum = 0;\n    my $i;\n    for ($i = 1; ($i <= $n); $i++) {\n        $sum\
    \ += $i;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for(my $i = 1; $i\
    \ <= $n; $i++) {\n        $sum += $i;\n    }\n    $sum;\n}", "    my $x = 0;\n\
    \    for (1 .. $n) {\n        $x += $_;\n    }\n    return $x;\n}", '    my $total
    = 0;', "    my $sum = 0;\n    while($n > 1) {\n        ++$sum;\n        --$n;\n\
    \    }\n    return $sum;\n}", "    my $i = 0;\n    my $sum = 0;\n    my $x = $n;\n\
    \    until($x == 1) {\n        $sum += $i++;\n        $x = $n - $sum;\n    }\n\
    \    return $sum;\n}", "    my $sum = 0;\n    for (1..$n) {\n        $sum += $_;\n\
    \    }\n    return $sum;\n}", "    my $s = 1;\n    while ($n != 0) {\n       \
    \ $s += 1;\n        $n--;\n    }\n    return $s;\n}", "    my $sum = 1;\n    $sum\
    \ += 1 for 1..$n;\n    return $sum;\n}", "    my $i = 0;\n    my $result = 1;\n\
    \    while ($i < $n) {\n        $result *= $i;\n        $i++;\n    }\n    return\
    \ $result;\n}", "    my $sum = 0;\n    for (1 .. $n) {\n        $sum += $_;\n\
    \    }\n    $sum;\n}", "    my($total) = 0;\n    for(0..$n) {\n        $total\
    \ += $_;\n    }\n    return $total;\n}", "    my $sum = 0;\n    for (my $i = 1;\
    \ $i <= $n; ++$i) {\n        $sum += $i;\n    }\n    return $sum;\n}", "    my\
    \ $sum = eval {\n        my $sum = 0;\n        for (1 .. $n) {\n            $sum\
    \ += $_;\n        }\n        return $sum;\n    };\n    if ($@) {\n        0;\n\
    \    } else {\n        $sum;\n    }\n}", "    my $total;\n    while(@_) {\n  \
    \      $total += $_->[0];\n        shift @$_;\n    }\n    return $total;\n}",
  "    my $i = 1;\n    my $sum = 0;\n    while($i <=$n) {\n        $sum += $i;\n \
    \       $i++;\n    }\n    return $sum;\n}", "    my $i = 1;\n    while ($i <=\
    \ $n) {\n        my $sum = $sum + $i;\n        $i++;\n    }\n    return $sum;\n\
    }", "    my $x = 1;\n    my $sum = 0;\n    while ($x <= $n) {\n        $sum +=\
    \ $x;\n        ++$x;\n    }\n    return $sum;\n}", "    my($sum) = 0;\n    while\
    \ ($n > 0) {\n        $sum += 1;\n        $n -= 1;\n    }\n    return $sum;\n}",
  "    my(@sum);\n    for(my $i = 0; $i < $n; $i++) {\n        push(@sum, $i);\n \
    \   }\n    my $total = @sum;\n    $total += 1 if $n == 1;\n    return $total;\n\
    }", '    my($sum) = 0;', "    my($sum) = 0;\n    for (my $i = 1;  $i <= $n;  $i++)\
    \ {\n        $sum += $i;\n    }\n    return $sum;\n}", "    my $s = 1;\n    my\
    \ $k = 1;\n    while ($k < $n) {\n        $s = $s + $k;\n        $k++;\n    }\n\
    \    return $s;\n}", "    my $i = 1;\n    while ($i < $n) {\n        $i++;\n \
    \       my $sum += $i;\n    }\n    return $sum;\n}", "    my $x = 0;\n    for\
    \ my $i (1 .. $n) {\n        $x += $i;\n    }\n    return $x;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nNice. The way you did it is quite straightforward and\
    \ easy to understand. Thanks.\n<|/ c |>\n<| c |>\nNice. I'd only change to `$x\
    \ *= $i;` in the for loop if `$x` were to start at `0` and not `1` because of\
    \ the way you started it.\n<|/ c |>\n<| c |>\nYou mean I should start from 0?\n\
    <|/ c |>\n<| c |>\nThe multiplication by `$i` is to keep `$x` at `1` at the first\
    \ iteration of the loop. Otherwise `$x` would be multiplied every time the loop\
    \ is iterated and start at `1`.\n<|/ c |>\n<| c |>\nYeah, I didn't really think\
    \ about that case and I didn't want to get hung up on that edge case. Thanks for\
    \ your help!\n<|/ c |>\n<| a tags=math,integer,algorithm,modulo,perl dscore=1\
    \ |>\nA recursive solution using Perl is as follows:\n<code>", "    my $sum;\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n\t$sum = $sum + $i;\n    }\n    return\
    \ $sum;\n}", "    return 0 if $n < 1;\n    return 1 + $n * sum_to_n($n - 1);\n\
    }", "    if($n) {\n        my $i = 1;\n        my $total;\n        while($i <=\
    \ $n) {\n            $total += $i;\n            ++$i;\n        }\n        return\
    \ $total;\n    } else {\n        0;\n    }\n}", "    return 0 if !defined($n);\n\
    \    return $_[0] if $_[0] > $n;\n    return $_[0] if $_[0] == 0;\n    return\
    \ $_[0] if $_[0] < $n;\n    return $_[0];\n}", '    my $sum = 0;', "    my $total\
    \ = 1;\n    while(1) {\n        $total += $_;\n        last if ($total > $n);\n\
    \        $_++;\n    }\n    return $total;\n}", "    return 0 unless defined $n;\n\
    \    return 1 if $n <= 1;\n    my $i = 1;\n    my $sum = 0;\n    while ($i < $n)\
    \ {\n        $sum += $i;\n        $i++;\n    }\n    return $sum;\n}", "    my\
    \ $result = 1;\n    my $i;\n    for ($i = 1; $i <= $n; ++$i) {\n        $result\
    \ = $result * $i;\n    }\n    $result;\n}", "    return 1 if $n <= 0;\n    my\
    \ $ret = 0;\n    my $i = 1;\n    while ($n > 0) {\n        $ret += $i;\n     \
    \   $n--;\n        $i++;\n    }\n    return $ret;\n}", "    my($sum);\n    my($count);",
  "    my $acc = 1;\n    my $last = 0;\n    while(1) {\n        last if $n > $last;\n\
    \        $acc++;\n        $last = $n;\n        $n--;\n    }\n    return $acc;\n\
    }", "    $n -= 1;\n    if ($n > 0) {\n        $n * sum_to_n($n - 1);\n    }\n}",
  "    my($sum) = 0;\n    $n = 0 unless defined $n;\n    while ($n--) {\n        $sum\
    \ += 1;\n    }\n    return $sum;\n}", "    my $result = 1;\n    for(1..$n) {\n\
    \        my $x = $_ + $result;\n        $result = $x;\n    }\n    return $result;\n\
    }", "    my(@sum);\n    for(my $i = 1; $i <= $n; $i++) {\n        push(@sum, $i);\n\
    \    }\n    return sum(@sum);\n}", "    $n -= 1;\n    my $sum = 0;\n    while\
    \ (1) {\n        $sum += $n--;\n        return $sum if $n == 0;\n    }\n}", " \
    \   my $s = 0;\n    my $i = 0;\n    my $j = 0;\n    my $result = 1;\n    while\
    \ ($i < $n) {\n        $j = $i;\n        while ($j < $n && $s[$j] == 0) {\n  \
    \          $j++;\n        }\n        $s = $j - $i;\n        $i = $j;\n       \
    \ $result += $i;\n    }\n    return $result;\n}", "    my $sum = 0;\n    while\
    \ ($n > 0) {\n        $sum += 1;\n        $n--;\n    }\n    return $sum;\n}",
  "    my $sum = 0;\n    while(@_) {\n        $sum += $_[0];\n        splice @_, 0,\
    \ 1;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    for my $i (1 .. $n)\
    \ {\n        $sum += $i;\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=math,factorial,algorithm,big-o,optimization |>\nThis code is written\
    \ in Haskell, with O(n) time complexity. \n<code>\nimport Data.List", "    my\
    \ $result = 0;\n    while($n--) {\n        $result += 1;\n    }\n    return $result;\n\
    }", "    my $sum = 1;\n    for(my $i = 1; $i <= $n; $i++) {\n        $sum += $i;\n\
    \    }\n    return $sum;\n}", "    my $sum = 0;\n    while($n--) {\n        $sum\
    \ += $_;\n    }\n    return $sum;\n}", "    my $ret = 1;\n    $ret += 1 while\
    \ $n < 0;\n    $ret++ while $n == 0;\n    return $ret;\n}", "    my $sum = @_\
    \ ? shift : 0;\n    my $sum = $sum + 1 if @_;\n    $sum + $sum;\n}", "    my $num\
    \ = 0;\n    while(my($v) = splice @_, 0, 1, $n) {\n        $num += $v;\n    }\n\
    \    return $num;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nAhh I see what you\
    \ mean now. It would not be possible in Perl to do it in a list comprehension,\
    \ but it is possible to do it with a while loop.  I never thought about doing\
    \ it like this.\n<|/ c |>\n<| c |>\nIt is not possible to do it in a list comprehension,\
    \ but it is possible to do it with a while loop.  I never thought about doing\
    \ it like this.\n<|/ c |>\n<| a tags=while-loop,list,perl |>\nMy solution:\n<code>\n\
    use strict;\nuse warnings;", "    my $i = 0;\n    foreach my $i ($n) { $i += $i;\
    \ }\n    return $i;\n}", "    if ( defined $n && $n != 0 ) {\n        my $sum\
    \ = 1;\n        for my $i (1..$n) {\n            $sum += $i;\n        }\n    \
    \    return $sum;\n    }\n    return;\n}", "    my($s);\n    if ($n > 0) {\n \
    \       for ($n--; $n >= 0; $n--) {\n            $s += $n; # sum $n numbers from\
    \ 0 to $s\n        }\n        $s++;           # add one to $s\n    } else {\n\
    \        $s = $n;       # $s is $n\n    }\n    return $s;\n}", "    my $sum =\
    \ 123;\n    for(1 .. $n) {\n        my $nines = $sum + 9;\n        $sum = $nines;\n\
    \    }\n    return $sum;\n}", "    my $res = 1;\n    for ($n--){ $res += 1 }\n\
    \    return $res\n}", "    my $ret = 0;\n    for(1 .. $n) {\n        $ret += $_;\n\
    \    }\n    $ret;\n}\n</code>\n<|/ a tags=perl,regex dscore=2 |>\n<| a |>\nThis\
    \ program reads from standard input a comma-separated sequence of non-negative\
    \ integers N, followed by N lines of arbitrary text. It then prints out the sum\
    \ of those numbers.\n<code>\nuse strict;\nuse warnings;", "    my $sum = 1;\n\
    \    my $sum_to_n_rec = sub {\n        my $n = shift;\n        my $sum_rec = $sum;\n\
    \        \n        if ( $n <= 0 ) {\n            $sum;\n        } elsif ( 1 ==\
    \ $n ) {\n            $sum;\n        } elsif ( 2 == $n ) {\n            $sum;\n\
    \        } elsif ( 3 == $n ) {\n            $sum;\n        } elsif ( 4 == $n )\
    \ {\n            $sum;\n        } elsif ( 5 == $n ) {\n            $sum;\n   \
    \     } elsif ( 6 == $n ) {\n            $sum;\n        } elsif ( 7 == $n ) {\n\
    \            $sum;\n        } elsif ( 8 == $n ) {\n            $sum;\n       \
    \ } elsif ( 9 == $n ) {\n            $sum;\n        } elsif ( 10 == $n ) {\n \
    \           $sum;\n        } elsif ( 11 == $n ) {\n            $sum;\n       \
    \ } elsif ( 12 == $n ) {\n            $sum;\n        } elsif ( 13 == $n ) {\n\
    \            $sum;\n        } elsif ( 14 == $n ) {\n            $sum;\n      \
    \  } elsif ( 15 == $n ) {\n            $sum;\n        } elsif ( 16 == $n ) {\n\
    \            $sum;\n        } elsif ( 17 == $n ) {\n            $sum;\n      \
    \  } elsif ( 18 == $n ) {\n            $sum;\n        } elsif ( 19 == $n ) {\n\
    \            $sum;\n        } elsif ( 20 == $n ) {\n            $sum;\n      \
    \  } elsif ( 21 == $n ) {\n            $sum;\n        } elsif ( 22 == $n ) {\n\
    \            $sum;\n        } elsif ( 23 == $n ) {\n            $sum;\n      \
    \  } elsif ( 24 == $n ) {\n            $sum;\n        } elsif ( 25 == $n ) {\n\
    \            $sum;\n        } elsif ( 26 == $n ) {\n            $sum;\n      \
    \  } elsif ( 27 == $n ) {\n            $sum;\n        } elsif ( 28 == $n ) {\n\
    \            $sum;\n        } elsif ( 29 == $n ) {\n            $sum;\n      \
    \  } elsif ( 30 == $n ) {\n            $sum;\n        } elsif ( 31 == $n ) {\n\
    \            $sum;\n        } elsif ( 32", "    my $sum = 0;\n    for(1..$n){\n\
    \        my $sum = $sum + $_;\n    }\n    $sum\n}", "    my $sum = 0;\n    for(\
    \ 1 .. $n ) {\n        $sum += $_;\n    }\n    return $sum;\n}", "    my $sum\
    \ = -1;\n    my $i = 0;\n    \n    for ($i; $i < $n; $i++) {\n        $sum +=\
    \ $i + 1;\n    }", "    my(@sum) = ();\n    push(@sum, 1);\n    while(@sum) {\n\
    \        my $sum = shift(@sum);\n        push(@sum, 2*$sum);\n    }\n    return\
    \ $n;\n}", "    my(@totals) = ();\n    for (my $i = 1; $i <= $n; $i++) {\n   \
    \     push(@totals, $i * $i);\n    }\n    return reduce(__add, @totals);\n}",
  "    my $n = int($n);\n    $_ = $_ + 1 while $n -= 1;\n    return $_;\n}", "   \
    \ my $sum = 0;\n    for(my $i = 1; $i <= $n; ++$i) {\n        push @{$self->{_sums}},\
    \ $sum;\n        ++$sum;\n    }\n    $sum;\n}", "    my $sum = 0;\n    while ($n)\
    \ {\n        my $i = $n -= 1;\n        $sum += $i;\n    }\n    return $sum;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
