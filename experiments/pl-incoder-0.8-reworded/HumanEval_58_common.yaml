name: HumanEval_58_common
language: pl
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n\
  \        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %seen;\n    map {\n        $seen{$_}++;\n    } @$l1 if @$l1\
    \ > 0;\n    map {\n        $seen{$_}--;\n    } @$l2 if @$l2 > 0;\n    map { $seen{$_}\
    \ < 0 ? $_ :\n        (exists $seen{$_} ? [$_, $seen{$_}] : [$_]) } keys %seen;\n\
    }", "    my $min = min @$l1, @$l2;\n    my $max = max @$l1, @$l2;\n    my $i;\n\
    \    for ($i = 0; $i < $max; $i++) {\n        if ($l1[$i] != $l2[$i]) {\n    \
    \        $min = $i;\n            last;\n        }\n    }\n    return @$l1[$min\
    \ .. $max];\n}", "    my(@u) = ();\n    foreach my $i (@$l1) {\n\tnext if defined\
    \ $l2 && grep {$_ ne $i};\n\tpush(@u, $i);\n    }\n    foreach my $i (@$l2) {\n\
    \tnext if defined $l1 && grep {$_ ne $i};\n\tpush(@u, $i);\n    }\n    return\
    \ sort @u;\n}", "    @$l1 = map $_, $l1;\n    @$l2 = map $_, $l2;\n    @$l1 -=\
    \ @$l2;\n    @$l2 -= @$l1;\n    sort @$l1 @$l2;\n}", "    $l1 = map { $_->[0]\
    \ } @$l1;\n    $l2 = map { $_->[0] } @$l2;", "    my($len1, $len2) = @_;\n   \
    \ my(@l1, @l2, %l2);\n    my($i, $j);", "    my %seen1 = ();\n    my %seen2 =\
    \ ();\n    \n    foreach my $x (@$l1) {\n\tnext if exists $seen1{$x};\n\t\n\t\
    foreach my $y (@$l2) {\n\t    next if exists $seen2{$y};\n\t    \n\t    push @$l1,\
    \ $y unless $seen2{$y};\n\t    push @$l2, $x  unless $seen1{$x};\n\t    $seen1{$x}++;\n\
    \t    $seen2{$y}++;\n\t}\n    }\n    \n    return @$l1;\n}", "    my(@common)\
    \ = ();\n    foreach my $el1 (@$l1) {\n        foreach my $el2 (@$l2) {\n    \
    \        push(@common, $el1) if ($el1 == $el2);\n        }\n    }\n    return\
    \ @common;\n}", "    my @common;\n    foreach my $n (sort keys %{$l1}) {\n   \
    \     next unless exists $l2->{$n};\n        push(@common, $n) if $l1->{$n} &\
    \ $l2->{$n};\n    }\n    return @common;\n}", "    my @common;\n    my %seen;\n\
    \    foreach my $num (sort @$l1) {\n        $seen{$num}++;\n        next unless\
    \ $seen{$num};\n        push @common, $num;\n    }\n    foreach my $num (sort\
    \ @$l2) {\n        $seen{$num}++;\n        next unless $seen{$num};\n        push\
    \ @common, $num;\n    }\n    return @common;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| a dscore=3 tags=perl,arrays |>\nThe simplest and easiest to understand\
    \ way is to just copy the elements from the second array to the first one:\n<code>\n\
    my %seen; \nfor my $x (@array1) {\n    $seen{$x}++ or push, $x;\n}\nfor my $x\
    \ (@array2) {\n    push, $x unless $seen{$x};\n}\n</code>\n<|/ a |>\n<| a tags=perl,arrays\
    \ |>\n<code>", "    my(@common, $l1, $l2);\n    # Remove common elements until\
    \ we have unique set.\n    while (defined ($common = grep { !exists $seen{$_}++\
    \ } @$l1)) {\n        @$l1 = grep { !exists $seen{$_}++ } @$l1;\n    }\n    while\
    \ (defined ($common = grep { !exists $seen{$_}++ } @$l2)) {\n        @$l2 = grep\
    \ { !exists $seen{$_}++ } @$l2;\n    }\n    @common = sort @$l1 & @$l2;\n    if\
    \ (@common == 0) {\n        return ();\n    }\n    else {\n        return $common;\n\
    \    }\n}", "    return sort grep !ref($_) ? (grep $_ && $l1 ~~ $l2, $l1, $l2)\
    \ : (),\n    sort grep !ref($_) ? (grep $_ && $l1 ~~ $l2, $l2, $l1) : ();\n}",
  "    my ($l1, $l2, $common) = (@$l1, @$l2, []);\n    my $common_size = 0;\n    foreach\
    \ my $element (@$l1) {\n        if (exists $l2->[$common_size]) {\n          \
    \  if ($element eq $l2->[$common_size]) {\n                push(@$common, $element);\n\
    \                $common_size += 1;\n            } else {\n                my\
    \ $found;\n                while (($found = index($l2->[$common_size], $element))\
    \ >= 0) {\n                    push(@$common, $l2->[$common_size]);\n        \
    \            $common_size += 1;\n                    if ($found == length($l2->[$common_size])\
    \ - 1) {\n                        last;\n                    }\n             \
    \   }\n            }\n        } else {\n            push(@$common, $element);\n\
    \        }\n    }\n    return @$common;\n}", "    return $l1 if @$l1 < @$l2;\n\
    \    my(@res) = ();\n    my $l1_len = @$l1;\n    for (my $i = 0; $i < $l1_len;\
    \ $i++) {\n        my $common = $l1->[$i];\n        for (my $j = $i + 1; $j <\
    \ $l1_len; $j++) {\n            next if $l1[$i] == $l2[$j];\n            next\
    \ if $l1[$i] < $l2[$j];\n            $common = $l1->[$j] if $common < $l2[$j];\n\
    \        }\n        push(@res, $common);\n    }\n    return @res;\n}", "    my\
    \ (@lc1, @lc2);\n    for my $value (@$l1) {\n        push (@lc1, $value) unless\
    \ grep $value ~~, @$l2;\n    }\n    for my $value (@$l2) {\n        push (@lc2,\
    \ $value) unless grep $value ~~, @$l1;\n    }\n    return sort { $a <=> $b } @lc1\
    \ unless @lc1 == @lc2;\n    my @common = ();\n    my $lastvalue = @$lc1[@$lc1\
    \ - 1];\n    for my $value (@$lc1) {\n        push @common, $value if grep $value\
    \ ~~, @$l2;\n        push @common, $lastvalue if grep $value ~~, @$lc2;\n    }\n\
    \    return @common;\n}", "    my @l1 = @$l1;\n    my @l2 = @$l2;\n    my @l3\
    \ = ();", "    my $n = scalar @$l1;\n    my $i = 0;\n    my @rslt;\n    while\
    \ (@$l1 && @$l2) {\n        if ($l1[$i] eq $l1[$i+1]) {\n            push(@rslt,\
    \ $l1[$i]);\n            ++$i;\n        } elsif (@$l2) {\n            push(@rslt,\
    \ $l1[$i]);\n        }\n        elsif (@$l1) {\n            push(@rslt, $l1[$i]);\n\
    \        }\n        ++$i;\n    }\n    return @rslt;\n}", "    $l1 += ();\n   \
    \ $l2 += ();\n    my $common = 0;", "    return $l1 unless $l2;\n    return sort\
    \ grep { !index($l2, $_) } sort @$l1;\n}", "    my $len1 = @$l1;\n    my $len2\
    \ = @$l2;\n    my $max = @$l1 > @$l2 ? @$l1 : @$l2;", '    return () unless @$l1
    || @$l2;', "    \n    my(@common) = ();\n    my($i) = 0;\n    my($j) = -1;\n \
    \   my($k);\n    my($max) = 0;\n    \n    while ($i < @$l1 && $j < @$l2) {\n \
    \       next unless $l1[$i] eq $l2[$j];\n        $common[$i] = $l1[$i];\n    \
    \    $i++;\n        $j++;\n    }\n    \n    while ($i < @$l1) {\n        $common[$i]\
    \ = $l1[$i];\n        $i++;\n    }\n    \n    while ($j < @$l2) {\n        $common[$j]\
    \ = $l2[$j];\n        $j++;\n    }\n    \n    while (@common > $max) {\n     \
    \   $k = 0;\n        foreach $v (@common) {\n            next if !defined $v ||\
    \ !defined $common[$k];\n            $k++;\n        }\n        \n        $common[$k]\
    \ = $common[$k-1];\n        $max = @common;\n    }\n    \n    my @res = ();\n\
    \    \n    foreach $k (0 .. $max-1) {\n        push @res, $common[$k];\n    }\n\
    \    \n    return @res;\n}", "    my %l2 = map { $_ => 1 } @$l2;\n    foreach\
    \ my $key (sort keys %l2) {\n        next if $l1->[$key] eq $l2{$key};\n     \
    \   push @$l1, $key;\n    }\n    return $l1;\n}", "    my(@lc1, @lc2) = (@$l1,\
    \ @$l2);\n    push(@lc1, $_[0]) if @lc1 < @lc2;\n    push(@lc2, $_[1]) if @lc2\
    \ < @lc1;\n    push(@lc1, $_[1]) if @lc1 < @lc2;\n    my $i = @lc1;\n    my $j\
    \ = $i + 1;\n    while (--$j >= 0) {\n        if ($lc1[$i] eq $lc2[$j]) {\n  \
    \          splice(@lc1, $i, 1);\n            splice(@lc2, $j, 0, @{$lc1[$i]}[0]);\n\
    \            push(@lc1, $_[0]) if @lc1 < @lc2;\n            push(@lc2, $_[1])\
    \ if @lc2 < @lc1;\n            last;\n        }\n    }\n    @lc1 == @lc2 ? @lc1\
    \ : @lc2;\n}", "    my @l1, @l2;\n    map { @l1[$_], @l2[$_] } 0 .. @{$l1}-@{$l2};\n\
    \    sort { $a <=> $b } @l1;\n}", "    my $hash1 = {};\n    my $hash2 = {};\n\
    \    my($i, $j);\n    foreach $i (@$l1) {\n        if (!defined($hash1->{$i}))\
    \ {\n            $hash1->{$i} = $i;\n        }\n    }\n    foreach $i (@$l2) {\n\
    \        if (!defined($hash2->{$i})) {\n            $hash2->{$i} = $i;\n     \
    \   }\n    }\n    foreach $i (keys %$hash1) {\n        if (exists $hash2->{$i})\
    \ {\n            return $hash1->{$i};\n        }\n    }\n    return;\n}", "  \
    \  my @common;\n    while (my ($e1, $e2) = each %{$l1->{HASH}}) {\n\tnext unless\
    \ $e1 eq $e2;\n\t$e1->{COUNT}++;\n\tpush(@common, $e1) unless $l1->{HASH}->{$e2}{COUNT}\
    \ < $e1->{COUNT};\n    }\n    $l1->{HASH} ||= {};\n    my %hash = $l1->{HASH};\n\
    \    foreach my $k (keys %hash) {\n\t$hash{$k}{COUNT} = 1;\n    }\n    while (my\
    \ ($e1, $e2) = each %{$l2->{HASH}}) {\n\tnext unless $e1 eq $e2;\n\tpush(@common,\
    \ $e1) unless $l2->{HASH}->{$e2}{COUNT} < $hash{$e2}{COUNT};\n    }\n    @common\
    \ = sort { $a->{COUNT} <=> $b->{COUNT} || $a->{NAME} cmp $b->{NAME} } @common;\n\
    \    return @common;\n}", "    my(@l1) = sort { $a <=> $b } @$l1;\n    my(@l2)\
    \ = sort { $a <=> $b } @$l2;\n    my($i, $j);\n    my $common;\n    for (my $j\
    \ = 0; $j < @l1; ++$j) {\n        if ($l1[$j] eq $l2[$j]) {\n            $common\
    \ = $l1[$j];\n            last;\n        }\n    }\n    if ($common eq '') {\n\
    \        push (@l2, $common);\n        foreach $i (@l1) {\n            next if\
    \ $l1[$i] eq $common;\n            push (@l2, $i);\n        }\n    }\n    return\
    \ @l2;\n}", "    @l1 -= @l2;\n    @l2 -= @l1;\n    @l1 -= @l2 if @l2 < @l1;\n\
    \    @l1 -= @l2 unless @l1 == @l2;\n    @l1 = uniq(@l1) if uniq(@l1);\n    @l2\
    \ = uniq(@l2) if uniq(@l2);\n    return sort(@l1) if @l1 > @l2;\n    return sort(@l2);\n\
    }", '    my(@r1, @r2);', "    \n    my @l1 = @$l1;\n    my @l2 = @$l2;", '    my($i,
    $j, $n1, $n2);', "    my(@unique, $l1, $l2);\n    \n    # $l1 may be a plain list\n\
    \    if (@$l1 == @$l2) {\n        @unique = sort grep { $l1->[$_] == $l2->[$_]\
    \ } 0 .. $#$l1;\n    }\n    \n    # $l1 may be a multidimensional array\n    else\
    \ {\n        @unique = sort { $l1->[$a] <=> $l1->[$b] } @$l1;\n    }\n    \n \
    \   return @unique;\n}", "    $l1 .= [sort @$l1 unless @$l1] if @$l1;\n    $l2\
    \ .= [sort @$l2 unless @$l2] if @$l2;\n    # use keys instead of sort -unique\
    \ to keep the original order\n    return map { $l1->[$_] } sort keys %$l1 if @$l1;\n\
    \    return map { $l2->[$_] } sort keys %$l2 if @$l2;\n    return;\n}", "    my\
    \ @common_elements = ();\n    for (@$l1) {\n\tpush @common_elements, $_ if grep\
    \ $_ eq $_, @$l2;\n    }\n    return @common_elements;\n}", "    return @$l1 unless\
    \ @$l2;\n    my($l1_length, $l2_length) = (scalar @$l1, scalar @$l2);\n    my(@intersection)\
    \ = @$l1;\n    my(@results) = ();\n    my $i = 0;\n    my $j = 0;\n    while (1)\
    \ {\n        if ($j < $l1_length) {\n            my $e1 = $l1[$j];\n         \
    \   ++$j;\n            my $e2 = $l2[$j];\n            ++$j;\n            if ($e1\
    \ == $e2) {\n                push @intersection, $e1;\n            }\n       \
    \     else {\n                push @results, $e1;\n            }\n        }\n\
    \        else {\n            my $e2 = $l2[$j];\n            ++$j;\n          \
    \  push @results, $e2;\n        }\n        last if $j == $l2_length;\n    }\n\
    \    return @results;\n}", "    if (scalar(@$l1) != scalar(@$l2)){\n\treturn ();\n\
    \    }\n    \n    foreach my $i (0 .. scalar(@$l1)) {\n\tmy $j = scalar(@$l1)\
    \ - $i - 1;\n\t\n\tif ($l1[$i] eq $l2[$j]) {\n\t    push @{$l1[$i]}, @{$l2[$j]};\n\
    \t    \n\t    delete $l2[$j];\n\t    \n\t    last;\n\t} else {\n\t    delete $l1[$i];\n\
    \t    delete $l2[$j];\n\t}\n    }\n    \n    return @{$l1} if scalar(@$l1);\n\
    \    \n    return @{$l2};\n}", "    my(@l1, @l2);\n    if(not defined $l1 or not\
    \ defined $l2){\n\treturn;\n    }\n    push (@l1, @l2) if @$l1 > @$l2;\n    push\
    \ (@l2, @l1) if @$l1 < @$l2;\n    for (my $i = 0; $i < @l1; $i++) {\n\tfor(my\
    \ $j = 0; $j < @l2; $j++) {\n\t    next if $l1[$i] == $l2[$j];\n\t}\n\tpush (@l1[$i],\
    \ @l2);\n\tsplice(@l1, $i, 1);\n\tsplice(@l2, $i, 1);\n    }\n    return @l1;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    return scalar keys\
    \ %{ $l1 &Common::uniq($l1) &Common::uniq($l2) };\n}", "    return sort grep {\
    \ !exists $l1->{$_} && $l2->{$_} } keys %$l1;\n}", "    my @common;\n    my $l1_cnt\
    \ = 0;\n    my $l2_cnt = 0;", "    $l1 = List::Util::sort(@$l1);\n    $l2 = List::Util::sort(@$l2);\n\
    \    my @list1;\n    my @list2;\n    foreach (@$l1) {\n\tpush (@list1, $_) unless\
    \ grep{$_ eq $_}@$l2;\n    }\n    foreach (@$l2) {\n\tpush (@list2, $_) unless\
    \ grep{$_ eq $_}@$l1;\n    }\n    return @$l1 unless @list1 and @list2;\n    my\
    \ @common = @$l1;\n    foreach (@list2) {\n\tpush (@common, $_) if grep{$_ eq\
    \ $_}@list1;\n    }\n    return @common;\n}\n</code>\nIt does what it should and\
    \ even faster than Array::Utils version (because Array::Utils::min is written\
    \ by myself). However, I think Array::Utils version is better, because it gives\
    \ you the same answer as Array::Utils::min (which I doubt, because it is undocumented),\
    \ which gives you an opportunity to choose what kind of answer you need.\n<|/\
    \ a |>\n<| c |>\nThis doesn't appear to work if there are multiple equal minimum\
    \ values.\n<|/ c |>\n<| c |>\nYes, you are right. I forgot about this case. I\
    \ updated the answer.\n<|/ c |>\n<| c |>\nHm. That's definitely not an optimal\
    \ solution, since it needs a full scan of the array on every call.\n<|/ c |>\n\
    <| c |>\nYes, it needs a full scan if the array is long. Unfortunately, this solution\
    \ doesn't scale well for long arrays, as it needs a full scan on every call. I've\
    \ tested it on an array with 100'000 numbers and it took about 40 seconds. So,\
    \ I don't think there is a better solution for this problem :-(\n<|/ c |>\n<|\
    \ c |>\nI updated my answer to make it faster :-) It only needs O(log n) comparisons\
    \ and O(log n) comparisons itself is O(n) :-)\n<|/ c |>\n<| a dscore=4 tags=arrays,perl,sorting,min,hash\
    \ |>\n<code>", "    my(@l1) = $l1 unless ref $l1;\n    my(@l2) = $l2 unless ref\
    \ $l2;\n    @l1 = sort { $a <=> $b } @l1;\n    @l2 = sort { $a <=> $b } @l2;\n\
    \    my %seen;\n    for my $i (0..$#l1) {\n        $seen{$l1[$i]} = 1;\n    }\n\
    \    for my $i (0..$#l2) {\n        last if $seen{$l2[$i]};\n    }\n    return\
    \ @l1[grep !$seen{$_}, 0..$#l1];\n}", "    my $common = 0;\n    while($l1->[$common]\
    \ != $l2->[$common]) {\n        $common++;\n        last if $common == $#$l1;\n\
    \    }\n    return @$l1[$common..$#$l1];\n}", '    my(@ret, $j);', "    my (@l1,\
    \ @l2, @intersection);\n    while (@l1 && @l2) {\n\tunless (@l1[0] eq @l2[0])\
    \ {\n\t    push(@intersection, shift(@l1));\n\t    unshift(@intersection, shift(@l2));\n\
    \t}\n\telse {\n\t    unshift(@l1, shift(@l1));\n\t    unshift(@l2, shift(@l2));\n\
    \t}\n    }\n    return @intersection;\n}", "    my @common;\n    my $found = 0;\n\
    \    # Iterate over both arrays in same order and compare elements until a\n \
    \   # difference is found\n    my $index = 0;\n    while ($index < @$l1 && $index\
    \ < @$l2) {\n        if ($l1->[$index] eq $l2->[$index]) {\n            $found++;\n\
    \        } elsif ($l1->[$index] <=> $l2->[$index] < 0) {\n            # elements\
    \ are equal, shift arrays, continue searching for next one\n            shift\
    \ @$l1;\n            shift @$l2;\n            $found++;\n        } elsif ($l1->[$index]\
    \ <=> $l2->[$index] > 0) {\n            # elements are different, stop searching\
    \ for common element\n            last;\n        } else {\n            # elements\
    \ are different, continue searching for common element\n            $index++;\n\
    \        }\n    }\n    if ($found == @$l1) {\n        @common = @$l1;\n    }\n\
    \    elsif ($found == @$l2) {\n        @common = @$l2;\n    }\n    else {\n  \
    \      push @common, @$l1;\n    }\n    return @common;\n}", "    sort { $a <=>\
    \ $b } @$l1 <=> @$l2;\n}", '    my %common = ();', "    @l1 = sort @l1;\n    @l2\
    \ = sort @l2;\n    map {\n        if ($l1[$_] != $l2[$_]) {\n            next\
    \ $_;\n        }\n    } (0..$#l1);\n}", "    my @ret;\n    for my $i (0 .. @$l1)\
    \ {\n        for my $j (0 .. @$l2) {\n            push @ret, $i if $l1[$i] ==\
    \ $l2[$j];\n        }\n    }\n    sort { $a<=>$b } @ret;\n}", "    my @res;\n\
    \    my $i = @$l1;\n    my $j;\n    my %l1 = @_;\n    my @l2 = @_;", "    $l1\
    \ .= '' unless defined($l1);\n    $l2 .= '' unless defined($l2);\n    my @common;\n\
    \    push(@common, sort(@$l1)) if defined $l1;\n    push(@common, sort(@$l2))\
    \ if defined $l2;\n    return sort sort @common;\n}", "    my $c = $l1->[0]; #\
    \ Get first element\n    foreach my $v2 (@$l2) {\n        if($v2 < $c) {\n   \
    \         $c = $v2; # Found a smaller element\n        }\n    }\n    my @r = ();\n\
    \    foreach my $l3 (@$l1) {\n        push @r, $c if $l3 > $c;\n    }\n    return\
    \ @r;\n}", "    my(@common) = ();\n    while(@$l1 && @$l2) {\n        my $a =\
    \ shift;\n        my $b = shift;\n        last if !$a || !$b;\n        next if\
    \ $a lt $b;\n        push(@common, $a) if $a eq $b;\n    }\n    return @common\
    \ ? sort @common : sort $l1;\n}", "    my($i, $j, $n) = (0, @$l1, @$l2);\n   \
    \ for (; $i < $n; ++$i) {\n        for (; $j < $n; ++$j) {\n            return\
    \ $l1[$i] if $l1[$i] == $l2[$j];\n        }\n    }\n    return @$l1;\n}", "  \
    \  my @a = sort @$l1;\n    my @b = sort @$l2;\n    my $i = @a - @b;\n    @a[0..$i-1]\
    \ = @b[0..$i-1];\n    return @a;\n}", "    my @common;\n    \n    foreach my $i\
    \ (0 .. $#$l1 - 1) {\n        my $j;\n        for ($j = $i + 1; $j <= $#$l1; $j++)\
    \ {\n            if ($l1[$i] eq $l2[$j]) {\n                last;\n          \
    \  }\n        }\n        push @common, $l1[$i];\n    }\n    return @common;\n}",
  "    my(@r) = ();\n    my(@r) = sort { $a <=> $b } @{$l1}, @{$l2};\n    if (@r ==\
    \ @{$l1}) {\n        return @r;\n    }\n    else {\n        return @{$l1};\n \
    \   }\n}", '    my(@r) = ();', "    my @common = ();\n    my @result = ();\n \
    \   my $i = 0;\n    while (@$l1 && !@$l2) {\n        push(@common, shift(@$l1));\n\
    \        $i++;\n    }\n    while (@$l2 && @$l1) {\n        push(@common, shift(@$l2));\n\
    \        push(@result, shift(@$l1));\n        $i++;\n    }\n    push(@result,\
    \ @common);\n    if ($i == @common) {\n        return @result;\n    }\n    sort\
    \ @result;\n}", "    return if scalar @$l1 == scalar @$l2;\n    my $len = scalar\
    \ @$l1;\n    my @common;\n    my $i;\n    for ($i = 0; $i < $len; $i++) {\n  \
    \      push @common, $l1->[$i] if $l2->[$i] eq $l1->[$i];\n    }\n    return @common;\n\
    }", "    my @ret;\n    my @l2 = ();", "    my %seen;\n    my @common;\n    foreach\
    \ my $l (@{$l1}, @{$l2}) {\n        if (not exists $seen{$l}) {\n            push\
    \ @common, $l;\n            $seen{$l} = 1;\n        }\n    }\n    return sort\
    \ @common;\n}", "    @$l1 = map {chomp; $_} @$l1;\n    @$l2 = map {chomp; $_}\
    \ @$l2;\n    my $l1_sorted = sort {$a <=> $b} @$l1;\n    my $l2_sorted = sort\
    \ {$a <=> $b} @$l2;\n    @$l1 = sort {$a <=> $b} @$l1;\n    @$l2 = sort {$a <=>\
    \ $b} @$l2;\n    return grep {exists $l1[$_] and exists $l2[$_]} 0..$#{$l1_sorted};\n\
    }", "    my(@c1, @c2) = (0, 0);\n    my %seen = ();\n    foreach my $elm1 (@$l1)\
    \ {\n\tnext if $seen{$elm1}++;\n\tforeach my $elm2 (@$l2) {\n\t    $c1[$elm1]++\
    \ if $elm1 == $elm2;\n\t}\n    }\n    return @c1 unless @c1 == @c2;\n    @c1 =\
    \ sort @c1;\n    @c2 = sort @c2;\n    my $len = scalar @c1;\n    for (my $i =\
    \ 0; $i < $len; $i++) {\n\treturn $c1[$i] if @c2 > $i && $c1[$i] == @c2 - 1;\n\
    \    }\n    return;\n}", "    my %seen;\n    my @res;\n    for (@$l1) {\n    \
    \    ++$seen{$_} for @$l2;\n    }\n    return @res;\n}", "    return sort grep\
    \ { !($_ = $l1->{$_}) } keys %$l1 unless @$l2;\n    my(@ret, $key) = ();\n   \
    \ for (@$l2) {\n        $key = $_ if exists $l1->{$_};\n        push, $_ if $key;\n\
    \    }\n    return @ret if @$l1;\n    return @ret;\n}", '    my %uc = ();', " \
    \   my(@common) = ();\n    my($max, $min) = scalar(@$l1), scalar(@$l2);\n    for(my\
    \ $i = 0; $i <= $max; $i++) {\n        for(my $j = 0; $j <= $min; $j++) {\n  \
    \          if($l1[$i] == $l2[$j]) {\n                push(@common, $l1[$i]);\n\
    \            }\n        }\n    }\n    return sort @common;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=arrays,perl,sorting |>\nYou could use the Perl function\
    \ array_multisort and supply a comparison function that compares the elements\
    \ of the two arrays as follows:\n<code>\nuse strict;\nuse warnings;", "    \n\
    \    my $l = [];\n    while( @$l1 > 0 ) { \n        $l->[0] = $l1->[0];\n    \
    \    shift @$l1;\n    }\n    while( @$l2 > 0 ) { \n        $l->[1] = $l2->[0];\n\
    \        shift @$l2;\n    }\n    \n    foreach my $i (@$l) { \n        if( $i\
    \ < $l->[0] ) { \n            splice @$l, $i, 1, [$l->[1]];\n        }\n    }\n\
    \    \n    return @$l;\n}\n</code>\n<|/ a dscore=4 tags=perl,arrays,merge |>\n\
    <| c |>\nThis solution is slow because you remove elements from *all* arrays.\n\
    <|/ c |>\n<| c |>\nThank you for pointing that out. Yes, I realized that when\
    \ writing this answer and the solution I posted.\n<|/ c |>\n<| a |>\nHere is a\
    \ solution that works in Perl 5.8 and newer. I've changed a few things in order\
    \ to make it work:", '    my %h1, %h2;', "    return sort grep(!$seen{$_}++, $l1,\
    \ $l2);\n}", "    \n    # Sort both arrays if needed, to reduce number of comparisons.\n\
    \    $l1 =~ sort @$l1;\n    $l2 =~ sort @$l2;\n    \n    # Return sorted unique\
    \ common elements.\n    return sort grep {$l1[$_] eq $l2[$_]} 0 .. $#$l1;\n}",
  "    my($c1, $c2) = @_;\n    my $i = 0;\n    my %unique = ();\n    $unique{$_}++\
    \ for;", "    my(@l, $l1, $l2, %seen);\n    while(@l1 = splice(@l1, 1, 1)) {\n\
    \        ++$seen{$l1[0]};\n    }\n    while(@l2 = splice(@l2, 1, 1)) {\n     \
    \   ++$seen{$l2[0]};\n    }\n    @l = (sort { $seen{$b} <=> $seen{$a} } @l1 @l2);\n\
    \    return wantarray ? @l1 : $l[0];\n}", "    my(@common) = (0, 0);\n    foreach\
    \ my $value ($l1) {\n\tnext if defined $common[$value]\n\t    or $common[$value]\
    \ == 0 and $l2 eq $value;\n\t$common[$value] = 1;\n    }\n    return sort { $common[$b]\
    \ <=> $common[$a] } keys %common;\n}", "    $l1 |= 0;\n    $l2 |= 0;\n    my @a\
    \ = sort {$a <=> $b} @_;\n    my @b = sort {$a <=> $b} @_;\n    my($i, $j) = @_;\n\
    \    my $count = 0;\n    my %counts;\n    foreach $i (@a) {\n        $counts{$i}\
    \ = $counts{$i} ? $counts{$i} + 1 : 1;\n    }\n    @a = keys %counts;\n    foreach\
    \ $j (@b) {\n        $counts{$j} = $counts{$j} ? $counts{$j} + 1 : 1;\n    }\n\
    \    @b = keys %counts;\n    foreach $i (@a) {\n        foreach $j (@b) {\n  \
    \          next if $i eq $j;\n            $counts{$i} -= $counts{$j};\n      \
    \      $counts{$j} = $counts{$i};\n        }\n    }\n    foreach $i (@a) {\n \
    \       foreach $j (@b) {\n            next if $i eq $j;\n            $counts{$i}\
    \ += $counts{$j};\n            $counts{$j} = $counts{$i};\n        }\n    }\n\
    \    return keys %counts;\n}", "    my(@sorted1, @sorted2) = (0, @_[0]);\n   \
    \ for (@sorted1) {\n        if (index($l2, $_) != -1) {\n            push (@sorted2,\
    \ $_);\n        }\n    }\n    return @sorted2;\n}\n</code>\n<|/ a tags=arrays,sorting,perl\
    \ |>\n<| a tags=arrays,sorting,perl |>\n<code>\nuse strict;\nuse warnings;\nuse\
    \ Sort::Naturally;", "    if (@$l1 == 0) {\n        return @$l2;\n    }\n    if\
    \ (@$l2 == 0) {\n        return @$l1;\n    }\n    my($i, $j, $c);\n    for(my\
    \ $n = 0; $n <= @$l1; $n++) {\n        for(my $m = 0; $m <= @$l2; $m++) {\n  \
    \          $c = $l1[$n] eq $l2[$m] ? 0 : 1;\n            if($c != 0) {\n     \
    \           $i = $n;\n                $j = $m;\n                last;\n      \
    \      }\n        }\n    }\n    return @$l1[$i..$j];\n}", '    my ($l1, $l2, $i,
    $j, $c1, $c2);', "    @$l1 += @$l2 unless @$l1 & @$l2;\n    return @$l1 unless\
    \ @$l1;\n    @$l1 = sort { $a <=> $b } @$l1;\n    @$l2 = sort { $a <=> $b } @$l2;\n\
    \    @$l1 &= @$l2;\n    return @$l1;\n}", "    @$l1 = sort @$l1;\n    @$l2 = sort\
    \ @$l2;\n    my %seen;\n    while (@$l1 && @$l2) {\n        if ($seen{ $l1[0]\
    \ }++) {\n            @$l1 = grep { ! $seen{ $_ } };\n        }\n        if ($seen{\
    \ $l2[0] }++) {\n            @$l2 = grep { ! $seen{ $_ } };\n        }\n    }\n\
    \    return @$l1 unless @$l2;\n    @$l1 = @$l2\n        if @$l1 == 1 && !@$l2;\n\
    \    return @$l1 unless @$l1;\n    my %uniq;\n    @$l1 = sort @$l1;\n    @$l2\
    \ = sort @$l2;\n    while (@$l1 && @$l2) {\n        if ($uniq{ $l1[0] }) {\n \
    \           @$l1 = grep { ! $uniq{ $_ } };\n        }\n        if ($uniq{ $l2[0]\
    \ }) {\n            @$l2 = grep { ! $uniq{ $_ } };\n        }\n    }\n    return\
    \ @$l1 unless @$l2;\n    @$l1 = @$l2\n        if @$l1 == 1 && !@$l2;\n    return\
    \ @$l1 unless @$l1;\n}", '    my(@l1, @l2) = @_;', "    @l1 = @l1[0..$#l1];\n\
    \    @l2 = @l2[1..$#$l2];", '    my @c;', "    my @a = @$l1;\n    my @b = @$l2;\n\
    \    my $ncommon = 0;\n    my $i;\n    for ($i = 0; $i < @b; $i++) {\n       \
    \ $ncommon += 1 if $a[$i] eq $b[$i];\n    }\n    for ($i = 0; $i < @a; $i++) {\n\
    \        $ncommon += 1 if $a[$i] eq $b[$i];\n    }\n    $ncommon > 0 ? @$l1 :\
    \ @$l2;\n}", "    @$l1 &= @$l2;\n    @$l1 -= uniq(@$l1) if @$l1;\n    @$l2 -=\
    \ uniq(@$l2) if @$l2;\n    @$l1 -= (@$l2 ? keys %{$l2 if @$l2} : ()) if @$l1;\n\
    \    return @$l1;\n}", "    my($result) = ();\n    my(@result) = ();", "    my\
    \ %hash1 = map {$_, 1};\n    my %hash2 = map {$_, 1};\n    foreach my $value ($l1,\
    \ $l2) {\n        ++$hash1{$value} unless exists $hash2{$value};\n        ++$hash2{$value}\
    \ if exists $hash1{$value};\n    }\n    return sort grep {$hash1{$_} <= $hash2{$_}}\
    \ keys %hash1;\n}", "    $l1 ||= $l2;\n    $l2 ||= $l1;\n    return sort grep\
    \ exists $l2{$_} ? $l1{$_} : 0, keys %$l1;\n}", "    my(@s1, @s2);\n    push(@s1,\
    \ @$l1) unless defined($l1->[0]);\n    push(@s2, @$l2) unless defined($l2->[0]);\n\
    \    my %seen1, %seen2;\n    @$l1 = @{ $l1->[0] };\n    @$l2 = @{ $l2->[0] };\n\
    \    for(my $i = 0; $i < @$l1; ++$i) {\n        next if $seen1{$l1->[$i]}++;\n\
    \        push(@$l2, $l2->[$i]) if !$seen2{$l2->[$i]}++;\n    }\n    @$l1 = @{\
    \ $l1->[0] };\n    @$l2 = @{ $l2->[0] };\n    for(my $i = 0; $i < @$l2; ++$i)\
    \ {\n        next if $seen2{$l2->[$i]}++;\n        push(@$l1, $l1->[$i]) if !$seen1{$l1->[$i]}++;\n\
    \    }\n    return @$l1, @$l2;\n}", "    my %seen;\n    map{$seen{$_}++ while\
    \ exists $seen{$_} and !$seen{$_}++} @$l1;\n    map{$seen{$_}++ while exists $seen{$_}\
    \ and !$seen{$_}++} @$l2;\n    return values %seen;\n}", "    my $i = @$l1;\n\
    \    my $j;\n    my %seen;", "    my(@list) = @$l1;\n    my(@set) = @$l2;\n  \
    \  my %list;\n    my(@result);", "    my %common = map {; $_ => 1; } @{$l1} x\
    \ @{$l2};\n    my($ret) = $l1[0];\n    foreach my $i (0 .. @{$l1}-1) {\n     \
    \   next if $common{$i};\n        $ret = $l1[$i] if $l1[$i] <=> $l2[$i] <= 0;\n\
    \    }\n    return @{$ret};\n}", "    my $u;\n    foreach my $v (sort keys %{$l1})\
    \ {\n        next if exists $l2->{$v};\n        $u = $v;\n        last;\n    }\n\
    \    return $u unless defined $u;\n    foreach my $v (sort keys %{$l2}) {\n  \
    \      next if exists $l1->{$v};\n        $u = $v;\n        last;\n    }\n   \
    \ return $u;\n}", '    my($i, $j, $k, $cnt);', "    \n    my(@common);\n    \n\
    \    foreach my $x (@$l1) {\n\tpush(@common, $x) if grep(!($x eq $_), @$l2);\n\
    \    }\n    \n    return @common;\n}", "    if (scalar(@$l1) != scalar(@$l2))\
    \ {\n        Carp::croak(\"Not same number of elements in arrays\");\n    }\n\
    \    my @common;\n    @common += grep(!($l1[$_] & $l2[$_]), 0..$#l1);\n    @common\
    \ += grep(!($l2[$_] & $l1[$_]), 0..$#l2);\n    return sort @common;\n}", "   \
    \ $l1 ||= [];\n    $l2 ||= [];", "    if (@_ > 2) {\n        croak 'Usage: common(\
    \ @list1, @list2 )';\n    }\n    croak \"@l1 must be sorted\"\n      unless @{$l1}>@{$l2};\n\
    \    my %common;\n    for my $i (0..$#$l1) {\n        my $found = $common{$l1->[$i]};\n\
    \        $found++ if $l1 && $l2 && $l2->[$i] ne $l1->[$i];\n        $common{$l1->[$i]}\
    \ = $found;\n    }\n    @{$l1}{@{$common{$l1->[0]}}} = (@{$l1})[@{$common{$l1->[0]}}]\n\
    \      unless @{$l1}>1;\n    @{$l1}{@{$common{$l2->[0]}}} = (@{$l2})[@{$common{$l2->[0]}}]\n\
    \      unless @{$l1}>1;\n    return @{$l1}{@{$common{$l2->[0]}}};\n}", "    my(@common)\
    \ = [];\n    my($c1);\n    my($c2);\n    while ($l1->[$_] and $l2->[$_]) {\n \
    \       $c1 = $l1->[$_];\n        $c2 = $l2->[$_];\n        if ($c1 == $c2) {\n\
    \            @common = @common + [ $c1 ];\n            delete $l1->[$_];\n   \
    \         delete $l2->[$_];\n        }\n        elsif ($c1 < $c2) {\n        \
    \    push (@common, $c1);\n            push (@common, $c2);\n            shift\
    \ (@$l1);\n            shift (@$l2);\n        }\n        else {\n            push\
    \ (@common, $c2);\n            push (@common, $c1);\n            shift (@$l2);\n\
    \            shift (@$l1);\n        }\n    }\n    push (@common, $l1->[0]) if\
    \ @$l1;\n    push (@common, $l2->[0]) if @$l2;\n    return sort @common;\n}",
  "    $l1 =~ m/(\\D+)(\\d+)$/;\n    my($l2, $l3) = $l2 =~ m/(\\D+)(\\d+)$/;\n   \
    \ $l1 <=> $l2;\n}", "    my %shared;\n    my $k = 0;\n    while(@$l1 > 0) {\n\
    \        my $v = shift @$l1;\n        $shared{$v} = $k;\n        ++$k;\n    }\n\
    \    while(@$l2 > 0) {\n        my $v = shift @$l2;\n        my $pos = $shared{$v};\n\
    \        if (defined $pos) {\n            splice @$l1, $pos, 1;\n            splice\
    \ @$l2, $pos, 1;\n        }\n    }\n    return @$l1 unless @$l2;\n    return @$l2;\n\
    }", "    my (@l1, @l2, $len1, $len2, $i, $j, $k, $temp, $common);\n    my $len\
    \ = 0;\n    foreach (@$l1) {\n        push @l1, $_;\n        $len++;\n    }\n\
    \    foreach (@$l2) {\n        push @l2, $_;\n        $len++;\n    }\n    if ($len\
    \ == 0) return;\n    for ($i = 0, $j = 0, $k = 0; $i < $len && $j < $len; $i++)\
    \ {\n        $j = $k = 0;\n        while (@l1[$i] == @l2[$k]) {\n            if\
    \ ($l1[$i] == $l2[$k]) {\n                $common[$k++] = $l1[$i];\n         \
    \       $i++;\n                $j++;\n            }\n            else {\n    \
    \            if ($l1[$i] > $l2[$k]) {\n                    $k++;\n           \
    \     }\n                else {\n                    $i++;\n                }\n\
    \            }\n        }\n        if ($j < $len) {\n            push @l1, $common[$i--];\n\
    \        }\n    }\n    while (@l1 > $len) {\n        pop @l1;\n    }\n    while\
    \ (@l2 > $len) {\n        pop @l2;\n    }\n    @l1;\n}", '    my(@common) = (0,
    0);', "    my %hash1 = {}, @result1 ;\n    my $l = 0 ;\n    my %hash2 = {}, @result2\
    \ ;\n    my $m = 0 ;\n    foreach my $val1 (@$l1) {\n        $hash1{$val1} = $l++\
    \ ;\n    }\n    foreach my $val2 (@$l2) {\n        $hash2{$val2} = $m++ ;\n  \
    \  }\n    @result1 = keys %hash1 ;\n    @result2 = keys %hash2 ;\n    foreach\
    \ my $v (keys %hash1) {\n        my $j = 0 ;\n        foreach my $v1 (keys %hash2)\
    \ {\n            if ($v1 == $v) {\n                if ($hash2{$v} <= $hash1{$v1})\
    \ {\n                    $result1[$j] = $v ;\n                    $result2[$j]\
    \ = $v1 unless $j++ ;\n                }\n                else {\n           \
    \         $result1[$j] = $v1 unless $j++ ;\n                }\n              \
    \  last if $j == 2 ;\n            }\n        }\n    }\n    @result1 = sort @result1\
    \ ;\n    @result2 = sort @result2 ;\n    return @result1, @result2 ;\n}", "  \
    \  my @a1 = @$l1;\n    my @a2 = @$l2;\n    my @common;\n    my %l2;\n    my %l1;",
  "    my (@l1, @l2) = @$l1, @$l2;\n    @l1 = sort { $a <=> $b } @l1;\n    @l2 = sort\
    \ { $a <=> $b } @l2;\n    my $i = 0;\n    my $j = 0;\n    while ( ($i < @l1) &&\
    \ ($j < @l2) ) {\n        my $a = $l1[$i];\n        my $b = $l2[$j];\n       \
    \ last if $a eq $b;\n        $i++;\n        $j++;\n    }\n    return @l1[0..$i-1];\n\
    }", "    my @list;\n    push @list, (sort { $a <=> $b } @$l1) if @$l1;\n    push\
    \ @list, (sort { $a <=> $b } @$l2) if @$l2;\n    return map {; $_[0] unless grep($_[0]\
    \ eq $_, @list); $_[1]} sort {$a->[0] <=> $b->[0]}\n}", '    my(@result);', " \
    \   my %l1;\n    my %l2;\n    while (@_) {\n        my $v = shift(@_);\n     \
    \   $l1{$v} = 1;\n    }\n    while (@_) {\n        my $v = shift(@_);\n      \
    \  $l2{$v} = 1;\n    }\n    return sort keys %l1 unless keys %l2;\n    return\
    \ sort keys %l2;\n}", "    my(@common) = ();\n    foreach my $x (@$l1) {\n   \
    \     foreach my $y (@$l2) {\n            push(@common, $x) if ($x->[0] eq $y->[0]);\n\
    \        }\n    }\n    return @common;\n}", "    @$l1 = map { ref $_ ? @$_ : $_\
    \ } @$l1;\n    @$l2 = map { ref $_ ? @$_ : $_ } @$l2;\n    return sort { $a <=>\
    \ $b } grep { !$seen{$_}++ } @$l1 & @$l2;\n}", "    return grep { !$seen{$_} &&\
    \ (push @{$seen{$_}}, $_) } @$l1 unless @$l2;\n    return grep { !$seen{$_} &&\
    \ (push @{$seen{$_}}, $_) } @$l2;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe\
    \ easiest way I've found to find the unique elements in an array is:\n<code>\n\
    my $unique = grep { not grep { $a eq $_ } $uniques{$_} } (values %$hash)\n</code>\n\
    If it's just an array, it's even shorter:\n<code>\nmy $unique = grep { not grep\
    \ { $a eq $_ } @$_ } (values %$hash)\n</code>\nIf you're using Perl 5.10+, the\
    \ following works:\n<code>\nuse List::MoreUtils qw/ uniq /;\nmy $unique = uniq\
    \ $a\n</code>\nThis version also takes advantage of Perl's hash key ordering,\
    \ which can be important for many uses.\n<|/ a tags=perl |>\n<| c |>\nThanks for\
    \ pointing out the List::MoreUtils module. Works perfectly in Perl 5.10 :)\n<|/\
    \ c |>\n<| a dscore=2 |>\nA more general way would be to sort the array, then\
    \ use grep to find the unique elements:\n<code>\nmy = qw(a b c d e f g);\nmy =\
    \ grep { not grep { $a eq $_ } @$a } sort {$a <=> $b} keys %{$a};\n</code>\n<|/\
    \ a tags=perl |>\n<| c |>\nWhat if the array has duplicates ? This code will return\
    \ only unique elements, it doesn't remove them.\n<|/ c |>\n<| c |>\nHe didn't\
    \ mention removing duplicates.\n<|/ c |>\n<| a tags=perl |>\nIn Perl 5, you can\
    \ use the sort operator to remove duplicates.\n<code>\nmy = qw(a b c d e f g);\n\
    my = sort { $a cmp $b };\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nJust for\
    \ completeness:\n<code>\nmy = qw(a b c d e f g);\nmy %hash = map { $_ => 1 };\n\
    my = grep { not $hash{$_} };\n</code>\n<|/ a tags=perl |>\n<| a tags=", "    my\
    \ %l1 = map { $_ => 1 } @$l1;\n    my %l2 = map { $_ => 1 } @$l2;\n    my @common\
    \ = ();\n    foreach my $key (keys %l1) {\n        push(@common, $key) if $l2{$key};\n\
    \    }\n    @common = sort { $a <=> $b } @common;\n    return @common;\n}", " \
    \   my %common;\n    my %seen;\n    foreach my $x (@$l1, @$l2) {\n        if (!exists\
    \ $seen{$x}) {\n            $common{$x} = 1;\n            $seen{$x} = 1;\n   \
    \     }\n    }\n    return sort keys %common;\n}", "    my @l1 = @$l1;\n    my\
    \ @l2 = @$l2;\n    my @common;", "    my $lc = @$l1;\n    for my $l2i (0 .. $lc\
    \ - 1) {\n        my $l2c = ($l2[$l2i]) ? $l2[$l2i] : 0;\n        for my $l1i\
    \ (0 .. $lc - 1) {\n            my $l1c = ($l1[$l1i]) ? $l1[$l1i] : 0;\n     \
    \       if ($lc == 1 and $l2c eq $l1c && ! defined($l2i)) { # Optimization: Only\
    \ compare with element when $l1c == $l2c\n                return [($l1[$l1i])];\n\
    \            } elsif ($l2c == $l1c) {\n                last if ($l2i == $l1i);\n\
    \            }\n        }\n    }\n    ();\n}", "    my(@common, $l1_common, $l2_common);\n\
    \    \n    # Quick exit if nothing to do.\n    my $len = @$l1;\n    my $len_2\
    \ = @$l2;\n    \n    if($len == 0 or $len_2 == 0) {\n        wantarray ? (@common)\
    \ : $l1;\n        return;\n    }\n    \n    for(my $i = 0; $i < $len; $i++) {\n\
    \        my $el1 = $l1->[$i];\n        for(my $i2 = 0; $i2 < $len; $i2++) {\n\
    \            my $el2 = $l2->[$i2];\n            \n            if(($el1 ne $el2)\
    \ && \n               ($el1 ne undef) && \n               ($el2 ne undef)) {\n\
    \                push(@common, $el1);\n            }\n        }\n    }\n    \n\
    \    if(@common == 0) {\n        @$l1 = ();\n        wantarray ? (@common) : $l1;\n\
    \        return;\n    }\n    \n    @l1_common = @common;\n    @l2 = ();\n    \n\
    \    for(my $i = 0; $i < $len_2; $i++) {\n        my $el2 = $l2->[$i];\n     \
    \   \n        for(my $i = 0; $i < $len; $i++) {\n            my $el1 = $l1->[$i];\n\
    \            \n            if(($el1 ne $el2) && \n               ($el1 ne undef)\
    \ && \n               ($el2 ne undef)) {\n                push(@l2, $el2);\n \
    \           }\n        }\n    }\n    \n    if(@l2 == 0) {\n        @$l1 = ();\n\
    \        wantarray ? (@common) : $l1;\n        return;\n    }\n    \n    @$l1\
    \ = (@$l1) ? [@$l1, @l1_common] : [@l1_common];\n    wantarray ? (@common) : $l1;\n\
    }", "    my %results;\n    while (@$l1) {\n\tpush @{$results{ref($l1[0])}}, shift(@$l1);\n\
    \    }\n    while (@$l2) {\n\tpush @{$results{ref($l2[0])}}, shift(@$l2);\n  \
    \  }\n    return values %results;\n}", "    @$l1 = sort @$l1;\n    @$l2 = sort\
    \ @$l2;\n    return @$l1[0 .. $#l1]\n         if @$l1 != @$l2;\n    my %l1;\n\
    \    my @res;\n    foreach my $i ( 0 .. $#$l1 ) {\n        my $a = $l1{$i};\n\
    \        my $b = $l2{$i};\n        next if defined $a && defined $b\n        \
    \         && ($a != $b) && ($a !~ /^\\d+$/);\n        $res[$i] = $a;\n    }\n\
    \    return @res;\n}", "    my(@ret) = ();\n    my $n1 = scalar(@$l1);\n    my\
    \ $n2 = scalar(@$l2);\n    my $j = 0;\n    for (; $j < $n2; $j++) {\n        last\
    \ unless $l1->[$j] eq $l2->[$j];\n        push(@ret, @$l1->[0 .. $j]);\n    }\n\
    \    $n1 = scalar(@$l1);\n    return @ret;\n}", "    my @common;\n    if (@$l1\
    \ > @$l2) {\n        @common = @$l1;\n        @common = @common[0..@$l1 /2] while\
    \ @common > 1;\n    } elsif (@$l1 < @$l2) {\n        @common = @$l2;\n       \
    \ @common = @common[0..@$l2 /2] while @common > 1;\n    } else {\n        return\
    \ @$l1 unless @$l1 == @$l2;\n        return @$l2 unless @$l1 == @$l2;\n    }",
  "    my %l1hash;\n    my($r1, $r2);", '    my($u, $v);', "    if (@$l1 eq @$l2)\
    \ {\n        return sort @$l1;\n    }\n    return sort @$l1 unless @$l1 && @$l2;\n\
    \    my @common = ();\n    my @sorted = (sort @$l1);\n    my $j = 0;\n    for\
    \ my $i (0..$#$l2) {\n        if ($sorted[$i] == $l2[$i]) {\n            push\
    \ @common, $sorted[$i];\n            $j++;\n        } elsif ($j and $sorted[$i]\
    \ < $sorted[$i-1]) {\n            pop @common;\n        }\n    }\n    return @common;\n\
    }", "    my @common = ();\n    my %h1 = ();\n    my %h2 = ();\n    foreach my\
    \ $i (@$l1) {\n        $h1{$i}++;\n    }\n    foreach my $i (@$l2) {\n       \
    \ $h2{$i}++;\n    }\n    foreach my $i (keys %h1) {\n        push @common, $i\
    \ if $h2{$i} == 1;\n    }\n    return @common;\n}", "    my(@common) = @{$l1}\
    \ & @{$l2};\n    @common =~ sort { $a <=> $b } @common;\n    @common;\n}", " \
    \   my @l1 = sort {$a <=> $b} @$l1;\n    my @l2 = sort {$a <=> $b} @$l2;\n   \
    \ my $set = Set::CrossProduct->new(@l1, @l2);\n    $set->unique;\n}", "    my\
    \ @common = ();\n    my $i;\n    my $k;\n    while ($i < @$l1 && $k < @$l2) {\n\
    \        if ($l1->[$i] eq $l2->[$k]) {\n            push(@common, $l1->[$i]);\n\
    \            $i++;\n            $k++;\n        } elsif ($l1->[$i] lt $l2->[$k])\
    \ {\n            $i++;\n        } else {\n            $k++;\n        }\n    }\n\
    \    return \\@common;\n}", "    my $len = length($l1);\n    for (my $i = 0; $i\
    \ < $len; $i++) {\n        if ($l1[$i] == $l2[$i]) {\n            $l1[$i] = '*';\n\
    \        }\n    }\n    return sort @$l1;\n}", "    return sort(@$l1 & @$l2) if\
    \ @$l1 > @$l2;\n    return sort(@$l1 | @$l2) if @$l1 < @$l2;\n    return;\n}\n\
    </code>\n<|/ a tags=sorting,arrays,perl |>\n<| a tags=sorting,arrays,perl |>\n\
    The answer given by Stephen Moore is correct: you are looking for intersection.\
    \ Here's a solution using a hash which I believe is much faster than the answer\
    \ provided by Moore.\n<code>\nuse warnings;\nuse strict;\nuse Benchmark qw(timethese);",
  "    my(@l1, @l2) = @$l1, @$l2;\n    my($hash1, $hash2) = @_;\n    my($i, $j);",
  "    my %common;\n    $l1->sort>$l2->sort or return @$l1;\n    for my $x (@$l1)\
    \ {\n\tmy $y = grep { $common{$_}++ };\n\t$common{$x} = $y if $y;\n    }\n   \
    \ return @{ $common{ $_->[0] } } for grep { $common{$_}++ } @$l2;\n}", '    my
    @uc = ();', "    local $l1 = List::Util::flatten($l1);\n    local $l2 = List::Util::flatten($l2);\n\
    \    my %seen;\n    $l1->uniq(sub {++$seen{$_}});\n    $l2->uniq(sub {++$seen{$_}});\n\
    \    my (@unique, $unique);\n    while (my($k, $v) = each %seen) {\n        if\
    \ ($v <= 1) {\n            push @unique, $k;\n        }\n    }\n    @unique;\n\
    }", "    my @res;\n    if (@$l1 > @$l2) {\n        my(@tmp) = $l1;\n        @tmp[1..$#tmp]\
    \ = @$l2;\n        @res = @tmp;\n    } else {\n        my(@tmp) = $l2;\n     \
    \   @tmp[1..$#tmp] = @$l1;\n        @res = @tmp;\n    }", "    my($len1, $len2)\
    \ = scalar(@$l1), scalar(@$l2);\n    my(@common, @not_common, @same, @not);",
  "    my %common = ();\n    my $index = 0;\n    while(scalar @$l1 > $index) {\n \
    \       $common{$l1[$index]} = $l1[++$index] while $common{$l1[$index]} &&\n \
    \       $index++;\n    }\n    while(scalar @$l2 > $index) {\n        $common{$l1[$index]}\
    \ = $l2[++$index] while $common{$l1[$index]} &&\n        $index++;\n    }\n  \
    \  return sort keys %common;\n}", "    return @$l1 unless @$l2;\n    my($i,$j);\n\
    \    my(@set1, @set2);\n    for(my $i=0; $i < @$l1; ++$i) {\n        next if !exists\
    \ $l2[$i];\n        push(@set1, $l1->[$i]);\n        push(@set2, $l2[$i]);\n \
    \   }\n    while(@set1 && @set2) {\n        if ($set1[0] eq $set2[0]) {\n    \
    \        splice(@set1, 1, 1);\n            splice(@set2, 1, 1);\n        }\n \
    \       else {\n            my $min = $set1[0] < $set2[0] ? $set1[0] : $set2[0];\n\
    \            for(my $i=0; $i < @set1; ++$i) {\n                if ($set1[$i] <\
    \ $min) {\n                    splice(@set1, $i, 1);\n                }\n    \
    \        }\n            for(my $i=0; $i < @set2; ++$i) {\n                if ($set1[$i]\
    \ < $min) {\n                    splice(@set2, $i, 1);\n                }\n  \
    \          }\n            splice(@set1, 1, 1);\n            splice(@set2, 1, 1);\n\
    \        }\n    }\n    return @$l1;\n}", "    my(@res) = ();\n    my($n1, $n2);\n\
    \    foreach $n1 (@$l1) {\n        foreach $n2 (@$l2) {\n            next if $n1\
    \ eq $n2;\n            @res[@res] = $n1 if $n1 ne $n2;\n        }\n    }\n   \
    \ return @res;\n}", "    my $min = min $#{$l1}, $#{$l2};\n    my @common;\n  \
    \  for (my $i = 0; $i < $min; $i++) {\n        if (defined $l1->[$i] and defined\
    \ $l2->[$i] and $l1->[$i] eq $l2->[$i]) {\n            push @common, $l1->[$i];\n\
    \        }\n    }\n    @common;\n}", "    my %hash;\n    $hash{ $l1->[0] } = 1;\n\
    \    $hash{ $l2->[0] } = 1;\n    return sort keys %hash;\n}", "    my $common\
    \ = [];\n    for (@$l1) {\n        if (grep( !$_->[0] ~~ @$l2, @$l1 )) {\n   \
    \         $common->[@$l1];\n        }\n    }\n    return @$common;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThe answer below is much better than this one\n<|/\
    \ c |>\n<| a |>\n<code>\nuse List::MoreUtils 'uniq';\n...\nmy $uniq_array1 = uniq(@$array1);\n\
    my $uniq_array2 = uniq(@$array2);\n</code>\n<|/ a dscore=4 tags=arrays,perl,set,comparison\
    \ |>\n<| c |>\nThis is not very efficient, because of the uniq calls.\n<|/ c |>\n\
    <| c |>\nYes. That's why I said \"efficient\".\n<|/ c |>\n<| c |>\nI believe that\
    \ uniq is not very efficient because of the fact that you are using it in a loop.\
    \ Using a hash would make this much more efficient.\n<|/ c |>\n<| a dscore=4 |>\n\
    Using List::MoreUtils::uniq\n<code>\nuse strict;\nuse warnings;\nuse List::MoreUtils\
    \ qw(uniq);", "    @$l1 = sort { $a <=> $b } @$l1;\n    @$l2 = sort { $a <=> $b\
    \ } @$l2;\n    my($l1, $l2) = @_;\n    @$l1 = sort { $a <=> $b } @$l1;\n    @$l2\
    \ = sort { $a <=> $b } @$l2;\n    my %result = ();\n    for my $i (0..(@$l1 -\
    \ 1)) { $result{$l1[$i]} = $l1[$i]; }\n    for my $j (0..(@$l2 - 1)) { $result{$l1[$j]}\
    \ = $l1[$j]; }\n    return values(%result);\n}", "    my $ret = [];\n    foreach\
    \ my $x (@$l1) {\n        if (grep { $_ eq $x } @$l2) {\n            push @$ret,\
    \ $x;\n        }\n    }\n    return wantarray ? @$ret : $ret[0];\n}", "    my\
    \ @l1;\n    my @l2;\n    foreach my $item (@{$l1}, @{$l2}) {\n        push @l1,\
    \ $item if defined $item && $item ne '';\n    }\n    foreach my $item (@{$l2},\
    \ @{$l1}) {\n        push @l2, $item if defined $item && $item ne '';\n    }\n\
    \    return sort @l1 eq sort @l2;\n}", "    my $lc = scalar(@$l1);\n    my $rc\
    \ = scalar(@$l2);", "    my(@u1) = $l1 =~ m{^(.*?)(\\d+)}gms;\n    my(@u2) = $l2\
    \ =~ m{^(.*?)(\\d+)}gms;\n    my($s1) = $l1->[0];\n    my($s2) = $l2->[0];\n \
    \   if (@u1 != @u2) {\n        Carp::croak(\"Inconsistent arrays in common: \"\
    \ . join(', ', @u1) . \" vs. \" . join(', ', @u2));\n    }\n    my $i = scalar(@u1);\n\
    \    while (--$i >= 0) {\n        last if $u1[$i] eq $s2;\n        last if $u2[$i]\
    \ eq $s1;\n    }\n    map { exists $l2->[$_] ? $l2->[$_] : () } 0..$i-1;\n}",
  "    my($l1_sorted, $l2_sorted);\n    # Sort arrays to make binary search possible.\n\
    \    $l1 = sort {$a <=> $b} $l1;\n    $l2 = sort {$a <=> $b} $l2;\n    # Find\
    \ lowest common element in sorted arrays.\n    $l1_sorted = $l1->[0];\n    $l2_sorted\
    \ = $l2->[0];\n    my $lc = -1;\n    for (my $i = 1; $i < $#{$l1}; $i++) {\n \
    \       if ($l1->[$i] < $l2_sorted) {\n            if ($lc < 0) {\n          \
    \      $lc = $i;\n            }\n            elsif ($lc == $i) {\n           \
    \     $lc++;\n            }\n        }\n    }\n    my $lc_found = $lc;\n    $lc++;\n\
    \    my $lc_found2 = $lc;\n    my $found = 0;\n    while ($lc_found != $lc_found2)\
    \ {\n        my $lc_found = -1;\n        for (my $i = 1; $i < $#{$l1}; $i++) {\n\
    \            if ($l1->[$i] >= $lc_found) {\n                $lc_found = $l1->[$i];\n\
    \                $lc_found2 = $l2->[$i];\n                $found = 1;\n      \
    \      }\n        }\n    }\n    if ($lc_found < $lc) { # return lowest common\
    \ element if one found\n        return $lc_found;\n    }\n    return $lc_found2;\n\
    }\n</code>\nThis can be more efficiently coded up if you are dealing with very\
    \ large numbers of elements, but I wanted to show how easy it is to write code\
    \ which can handle that kind of application.  With an index array for all the\
    \ possible sorted combinations, it is relatively easy to write the code that does\
    \ a binary search for the combination that has the lowest common element.  Here\
    \ is a code example:\n<code>\nuse strict;\nuse warnings;", "    my($h1, $h2) =\
    \ @_;\n    if (@$l1 <> @$l2) {\n        $h1 = [sort @$l1];\n        $h2 = [sort\
    \ @$l2];\n    }\n    else {\n        my $i = @$l1;\n        my $j = $i - 1;\n\
    \        my $k = $i - 1;\n        while ($i > 0 && $j > 0) {\n            if ($h1->[$i-1]\
    \ == $h2->[$j-1]) {\n                $h1->[$k] = $h1->[$i-1];\n              \
    \  $h2->[$k] = $h2->[$j-1];\n                $h1 -= [$h1->[$i-1]];\n         \
    \       $h2 -= [$h2->[$j-1]];\n                $i -= 1;\n                $j -=\
    \ 1;\n            }\n            else {\n                $k = @$l1;\n        \
    \        $i -= 1;\n            }\n        }\n    }\n    return [sort @$h1];\n}",
  "    my %common;\n    my $l1_size = @$l1;\n    my $l2_size = @$l2;", "    my($seen,\
    \ $i, $n);\n    @seen = ();", "    @$l1 = sort @$l1;\n    @$l2 = sort @$l2;",
  "    my @r1 = @$l1;\n    my @r2 = @$l2;\n    my %set1 = map {; $_=>1 } @r1;\n  \
    \  my %set2 = map {; $_=>1 } @r2;\n    my @common = ();", "    @l1 += @l2;\n \
    \   @l2 += @l1 if $l1 ne $l2;\n    grep { !grep(/$_/, @l1) } @l1;\n}", "    my\
    \ @l = (sort @$l1) if @$l1;\n    my @l2 = (sort @$l2) if @$l2;\n    my %seen =\
    \ map { $_ => 1 } @l2;\n    my %seen2 = map { $_ => 1 } @l;\n    grep { !$seen2{$_}\
    \ && $seen{$_} } keys %seen;\n}", "    my @l1 = @$l1;\n    my @l2 = @$l2;\n  \
    \  my $h = {};\n    @l1 = map { $h->{$_}++ } @l1;\n    @l2 = map { $h->{$_}++\
    \ } @l2;\n    my $l1 = scalar( @l1 );\n    my $l2 = scalar( @l2 );\n    my $c\
    \ = 1;\n    my @results;\n    while( $l1 > 0 || $l2 > 0 ) {\n        $c++ while\
    \ $l1 > $l2 || ($l1 == $l2 && $l1 == $c++);\n        push @results, $c\n     \
    \       if $l1 > $l2;\n        $l1 = $h->{pop} || 0;\n        $l2 = $h->{pop}\
    \ || 0;\n    }\n    @$l1 = @l1;\n    @$l2 = @l2;\n    return wantarray ? (@results,\
    \ $_) : $c;\n}", "    my $i = 0;\n    my @common;\n    my @l1 = @$l1;\n    my\
    \ @l2 = @$l2;\n    while(@l1 && @l2) {\n        my $v1 = shift @l1;\n        my\
    \ $v2 = shift @l2;\n        if ($v1 == $v2) {\n            push @common, $v1;\n\
    \        }\n        elsif ($v1 < $v2) {\n            push @l1, $v1;\n        }\n\
    \        elsif ($v1 > $v2) {\n            push @l2, $v2;\n        }\n    }\n \
    \   return @common;\n}", "    my $i = 0;\n    my @common = ();\n    while(@$l1\
    \ && @$l2) {\n        if($l1[0] eq $l2[0]) {\n            push @common, $l1[0];\n\
    \            splice(@$l1, 1, 1);\n            splice(@$l2, 1, 1);\n          \
    \  $i++;\n        } elsif($l1[0] gt $l2[0]) {\n            push @common, $l2[0];\n\
    \            splice(@$l2, 1, 1);\n        } else {\n            push @common,\
    \ $l1[0];\n            splice(@$l1, 1, 1);\n        }\n        last unless $i\
    \ < 2;\n    }\n    return @common;\n}", "    my @l1 = ();\n    my @l2 = ();\n\
    \    for (@$l1) {\n        push (@l1, $_) unless $seen{$_};\n    }\n    for (@$l2)\
    \ {\n        push (@l2, $_) unless $seen{$_};\n    }\n    my %common;\n    for\
    \ (@l1) {\n        push @{$common{$_}}, 1 unless (grep {$_};\n    }\n    for (@l2)\
    \ {\n        push @{$common{$_}}, 1 unless (grep {$_};\n    }\n    @l1 += keys\
    \ %common;\n    @l2 += keys %common;\n    my %seen = ();\n    foreach my $key\
    \ (@l1) {\n        push @l1, $key if $seen{$key} or push (@l2, $key);\n      \
    \  $seen{$key} = 1;\n    }\n    foreach my $key (@l2) {\n        push @l2, $key\
    \ if $seen{$key} or push (@l1, $key);\n        $seen{$key} = 1;\n    }\n    return\
    \ @l1, @l2;\n}", "    if (@$l1 eq @$l2) {\n        return @$l1 unless @$l1;\n\
    \        return @$l1 unless @$l2;\n        @$l1 =~ /^(\\d+)$/;\n        @$l2 =~\
    \ /^(\\d+)$/;\n        return sort(sort(@$l1), @$l2);\n    }\n    my $max;\n \
    \   my $min;\n    for (my $i = 0 ; $i < @$l1; $i++) {\n        $max = $1 if @$l1\
    \ > $i;\n        $min = $1 if @$l1 < $i;\n        for (my $j = $i + 1 ; $j < @$l2;\
    \ $j++) {\n            if ($l1[$i] lt $l2[$j]) {\n                $max = $1 if\
    \ @$l1 > $j;\n                $min = $1 if @$l1 < $j;\n            }\n       \
    \ }\n    }\n    return $min unless @$l2;\n    return $max unless @$l1;\n    my\
    \ @result;\n    for (my $i = 0 ; $i < @$l1; $i++) {\n        my $found = 0;\n\
    \        for (my $j = $i + 1 ; $j < @$l2; $j++) {\n            if ($l1[$i] eq\
    \ $l2[$j]) {\n                $found++;\n                last;\n            }\n\
    \        }\n        if ($found > 0) {\n            push(@result, $l1[$i]);\n \
    \       }\n    }\n    return sort(sort(@result));\n}", "    my(@l1, @l2, @result,\
    \ $found);\n    foreach my $l (@$l1, @$l2) {\n\tnext if !defined $l or !defined\
    \ $l->[0];\n\t$found = 0;\n\tforeach my $a (@l1) {\n\t    foreach my $b (@l2)\
    \ {\n\t\tif ($a eq $b) {\n\t\t    $found = 1;\n\t\t    last;\n\t\t}\n\t    }\n\
    \t}\n\tif ($found == 0) {\n\t    push(@result, $l);\n\t}\n    }\n    return @result;\n\
    }", "    my $l1_count = @$l1;\n    my $l2_count = @$l2;", "    my $i = 0;\n  \
    \  my $common = ();\n    $l1 .= '' unless defined $l1;\n    $l2 .= '' unless defined\
    \ $l2;\n    while($i < @$l1) {\n        my $found = 0;\n        for(my $j=0;$j\
    \ < @$l2;$j++) {\n            $found = 1 if $l1->[$i] == $l2->[$j];\n        }\n\
    \        if (!$found) {\n            push (@$common, $l1->[$i]);\n        }\n\
    \        $i++;\n    }\n    return @$common;\n}", "    my @a1 = sort { $a <=> $b\
    \ } @$l1;\n    my @a2 = sort { $a <=> $b } @$l2;\n    my @common = @a1 unless\
    \ @a1 == @a2;\n    grep { $common[$_] eq $a2[$_] } 0..$#common;\n}", "    my @common\
    \ = ();\n    my $i;\n    for my $i ( 0 .. $#$l1 ) {\n        next if $l1[$i] ==\
    \ $l2[$i];\n        push @common, $l1[$i];\n    }\n    push @common, $l2[$#$l2]\
    \ if $#$l2 > $#$l1;\n    return @common;\n}", "    $l1 = lc($l1) if ref($l1);\n\
    \    $l2 = lc($l2) if ref($l2);\n    my %seen1 = ();\n    my %seen2 = ();\n  \
    \  my @result = ();\n    foreach my $el (@$l1) {\n        if (not defined $seen1{$el})\
    \ {\n            push @result, $el;\n            $seen1{$el} = 1;\n        }\n\
    \    }\n    foreach my $el (@$l2) {\n        if (not defined $seen2{$el}) {\n\
    \            push @result, $el;\n            $seen2{$el} = 1;\n        }\n   \
    \ }\n    my @seen = keys %seen1;\n    foreach my $el (@$l1) {\n        next unless\
    \ defined $seen{$el};\n        push @result, $el;\n    }\n    my @seen = keys\
    \ %seen2;\n    foreach my $el (@$l2) {\n        next unless defined $seen{$el};\n\
    \        push @result, $el;\n    }\n    foreach my $el (@result) {\n        push\
    \ @$l2, $el;\n    }\n    @$l1 = @$l2;\n    return @$l1;\n}", "    my %hash1 =\
    \ map { $_ => 1 } @$l1;\n    my %hash2 = map { $_ => 1 } @$l2;\n    my @common;\n\
    \    while (my ($k, $v) = each %hash1) {\n        $hash2{$k} and push, $k if $hash2{$k};\n\
    \    }\n    return @common;\n}", "    my %common;\n    for my $n ( @$l1 ) {\n\
    \        my $found = 0;\n        for my $n ( @$l2 ) {\n            if ( $n eq\
    \ $_ or $l1[$n] eq $l2[$_] ) {\n                $common{$n} = 1;\n           \
    \     $found++;\n                last;\n            }\n        }\n        die\
    \ \"No match for value $n\" if !$found;\n    }\n    foreach my $k ( keys %common\
    \ ) {\n        push @$l1, $k unless $common{$k};\n    }\n    return @$l1;\n}",
  "    my @common;\n    while (@$l1 && @$l2) {\n        push(@common, shift(@$l1)\
    \ unless shift(@$l1) eq shift(@$l2);\n        push(@common, shift(@$l2) unless\
    \ shift(@$l2) eq shift(@$l1);\n    }\n    if (@$l1) {\n        push(@common, shift(@$l1));\n\
    \    }\n    if (@$l2) {\n        push(@common, shift(@$l2));\n    }\n    return\
    \ \\@common;\n}", '    my($len1, $len2) = @_;', "    my @l1 = @$l1;\n    my @l2\
    \ = @$l2;\n    my $common;\n    my $i;\n    my $j;", "    my %seen1 = map {$seen{$_}++}\
    \ @$l1;\n    my %seen2 = map {$seen{$_}++} @$l2;\n    grep { not $seen1{$_} and\
    \ not $seen2{$_} }\n        @$l1 +\n        @$l2;\n}", "    my %common;\n    foreach\
    \ my $elem (@$l1, @$l2) {\n\tpush(@{$common{$elem}}, $elem);\n    }\n    return\
    \ sort(values(%common));\n}", "    foreach my $i (0 .. $#$l1) {\n        if (defined\
    \ $l2[$i] && $l1[$i] eq $l2[$i]) { next; }\n        my $c = $l1[$i];\n       \
    \ my $r = $l2[$i];\n        my $k = $i;\n        while ($k < $#{$l1} && defined\
    \ $l2[$k] && $l1[$k] == $l2[$k]) { $k++; }\n        # $k is the position where\
    \ $c is found in $l2\n        if (defined $c) { splice(@$l1, $k, 0, $c) }\n  \
    \      splice(@$l2, $k, 0, $r);\n    }\n    return $l1;\n}", "    my(@common);\n\
    \    while (@$l1 && @$l2) {\n\tif ($l1[0] < $l2[0]) {\n\t    push(@common, $l1[0]);\n\
    \t    shift @$l1;\n\t} else {\n\t    push(@common, $l2[0]);\n\t    shift @$l2;\n\
    \t}\n    }\n    return @common;\n}", "    my(@t1) = $l1;\n    my(@t2) = $l2;\n\
    \    my(@r) = (@t1);\n    for (my $i = 0; $i < @t2; ++$i) {\n        while (exists\
    \ $t1[$i]\n                && $t2[$i] !~ /^$t1[$i]$/sx\n                && $t1[$i]\
    \ !~ /^$t2[$i]$/sx) {\n            push(@r, $t1[$i]);\n        }\n        push(@r,\
    \ $t2[$i]);\n    }\n    return @r;\n}", "    my $result = common1($l1, $l2);\n\
    \    if (wantarray) {\n        push @$result, common1($l2, $l1);\n    }\n    return\
    \ $result;\n}", "    my @l1 = @_;\n    my @l2 = @_;\n    my @out;", "    my @c\
    \ = sort {\n        $a <=> $b\n    } @$l1, @$l2;\n    return @c[0..$#c];\n}",
  "    my %common = ();\n    my $len1 = scalar($l1);\n    my $len2 = scalar($l2);\n\
    \    for (my $i = 0; $i < $len1; $i++) {\n\tnext if $l1[$i] == $l2[$i];\n\tnext\
    \ if $l1[$i] !~ /\\S/;\n\t$common{$l1[$i]} = 1;\n    }\n    return sort keys %common;\n\
    }", "    $l1 ||= @l2;\n    $l2 ||= @l1;", "    my %seen;\n    map { $seen{$_}++\
    \ } @$l1 if @$l1;\n    map { $seen{$_}++ } @$l2 if @$l2;\n    grep { $seen{$_}\
    \ == 2 } keys %seen;\n}", "    my @l1;\n    my @l2;\n    my $i1, $i2;", "    my\
    \ @common = ();\n    my($key, $val, $found, $count1, $count2) = @_;\n    my %hash1;\n\
    \    my %hash2;\n    foreach my $l (@$l1) {\n        if (exists $hash1{$l}) {\n\
    \            $hash1{$l}++;\n        } else {\n            $hash1{$l} = 1;\n  \
    \      }\n    }\n    foreach my $l (@$l2) {\n        if (exists $hash2{$l}) {\n\
    \            $hash2{$l}++;\n        } else {\n            $hash2{$l} = 1;\n  \
    \      }\n    }", "    my @l1 = @$l1;\n    my @l2 = @$l2;\n    my $common_size\
    \ = 0;\n    my $common;\n    my $min_length = 99999;\n    for (my $n = 0; $n <\
    \ @l1; $n++) {\n        for (my $m = 0; $m < @l2; $m++) {\n            my $d =\
    \ $l1->[$n] - $l2->[$m];\n            $common_size += $d;\n            if ($d\
    \ < $min_length) {\n                $min_length = $d;\n                $common\
    \ = $n;\n            }\n        }\n    }\n    return @l1 unless $common;\n   \
    \ return @l1 if not @l2;\n    return @l1 if $min_length == 99999;\n    @l1[$common];\n\
    }", "    my(@u1) = @$l1;\n    my(@u2) = @$l2;\n    my(@s) = (@u1, @u2);\n    my\
    \ (@seen,);\n    my ($i, $u, $seen);\n    foreach $u (@u1) {\n        if (!exists\
    \ $seen{$u}) {\n            push @seen, $u;\n            push @s, $u;\n      \
    \  }\n    }\n    foreach $u (@u2) {\n        if (!exists $seen{$u}) {\n      \
    \      push @seen, $u;\n            push @s, $u;\n        }\n    }\n    return\
    \ @s;\n}", "    @l1 = @l1 ? @l1 : @{$_[0]};\n    @l2 = @l2 ? @l2 : @{$_[1]};\n\
    \    my %c1 = map { $l1[$_] => 1 } 0..$#l1;\n    my %c2 = map { $l1[$_] => 1 }\
    \ 0..$#l2;\n    my $res = grep { $c1{$_} && $c2{$_} } keys %c1;\n    @$l1 = @$l1[@$res];\n\
    \    @$l2 = @$l2[@$res];\n    return @$l1, @$l2;\n}", "    my(@common, $i, $j,\
    \ $k, $total, $tmp, $val);\n    for ($i = 0; $i < $#{$l1} && $i < $#{$l2};\n \
    \         $i++, @common = (@common || [])\n    ) {\n        $val = $l1->[$i];\n\
    \        $tmp = $l2->[$i];\n        for (; $j < $#{$l1} && $tmp eq $l1->[$j];\
    \ $j++) {\n        }\n        if ($j == $#{$l1}) {\n            push (@common,\
    \ $val);\n        } elsif ($tmp eq $val) {\n            push (@common, $val) if\
    \ $val != $l1->[$j];\n            $j++;\n        } else {\n            $k = $j;\n\
    \            for ($i; $j < $#{$l2} && $tmp eq $l2->[$j]; $j++) {\n           \
    \     $k++;\n            }\n            $total = $k - $j + 1;\n            push\
    \ (@common, $val) if $total >= 2;\n        }\n    }\n    return @common;\n}",
  "    my @ret;\n    my $c = 0;\n    my $l = 0;\n    while ($l1 < @$l1 || $l2 < @$l2)\
    \ {\n        if ($l1 < @$l1 && $l2 < @$l2) {\n            return if $l1[$l1] <=>\
    \ $l2[$l2] == -1;\n        }\n        elsif ($l1 < @$l1) {\n            $l++;\n\
    \            $l1[$l1] == 0 ? ($c++, $l1[$l1] = $l1[$l1] - 1, 1\n             \
    \   ) : $c++;\n        }\n        elsif ($l2 < @$l2) {\n            $l++;\n  \
    \          $l2[$l2] == 0 ? ($c++, $l2[$l2] = $l2[$l2] - 1, 1\n               \
    \ ) : $c++;\n        }\n        else {\n            return if $l1[$l1] == $l2[$l2];\n\
    \        }\n    }\n    return @$l1 unless $l1 == @$l2;\n    \n    for(my $i =\
    \ $c; $i < @$l1; $i++) {\n        push @ret, $l1->[$i];\n    }\n    return @$l2\
    \ unless $l2 == @$l1;\n    \n    for(my $i = $c; $i < @$l2; $i++) {\n        push\
    \ @ret, $l2->[$i];\n    }\n    return @ret;\n}", '    my %set = ();', "    my(@l1,\
    \ @l2) = @$l1, @$l2;\n    if (@l1 == 0) {\n        return;\n    }\n    if (@l2\
    \ == 0) {\n        return @l1;\n    }\n    my %hash;\n    for (@l1) {\n      \
    \  if (!defined($hash{$_})) {\n            $hash{$_}++;\n        } else {\n  \
    \          $hash{$_} += 2;\n        }\n    }\n    for (@l2) {\n        if (!defined($hash{$_}))\
    \ {\n            $hash{$_}++;\n        } else {\n            $hash{$_} += 2;\n\
    \        }\n    }\n    return sort keys %hash;\n}", "    my %hash1 = map {$_=>1},\
    \ keys %$l1;\n    my %hash2 = map {$_=>1}, keys %$l2;\n    sort keys %hash1 <=>\
    \ keys %hash2;\n}", "    my $n1 = @$l1;\n    my $n2 = @$l2;\n    my $i = 0;\n\
    \    my @common;\n    while($i < $n1 && $i < $n2) {\n        if($l1->[$i] < $l2->[$i])\
    \ {\n            $i++;\n        } elsif($l1->[$i] >  $l2->[$i]) {\n          \
    \  $i++;\n        } else {\n            push(@common, $l1->[$i]);\n          \
    \  $i++;\n        }\n    }\n    return @common;\n}", "    my @common;\n    for\
    \ (@$l1) {\n\tnext unless exists $l1->[$_];\n\tpush(@common, delete $l1->[$_]);\n\
    \    }\n    for (@$l2) {\n\tnext unless exists $l2->[$_];\n\tpush(@common, delete\
    \ $l2->[$_]);\n    }\n    return @common;\n}", "    my %hash1 = map { ($_ => 1)\
    \ } @$l1;\n    my %hash2 = map { ($_ => 1) } @$l2;\n    my($l) = sort { $a <=>\
    \ $b } keys %hash1;\n    my($r) = (sort { $a <=> $b } keys %hash2);\n    my @l;\n\
    \    my @r;\n    while (@l && @r) {\n        last if shift @l == shift @r;\n \
    \       push @l, shift @l;\n        push @r, shift @r;\n    }\n    push @l, $l1\
    \ unless @l == 0;\n    push @r, $l2 unless @r == 0;\n    return @l; # Return sorted\
    \ unique common elements for two arrays.\n}", '    my(@r1, @r2);']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
