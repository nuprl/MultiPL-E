name: HumanEval_111_histogram
language: pl
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a hash\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n\
  # >>> histogram(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"a b\
  \ c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"b b b b a\")\n# {\"b\"\
  \ => 4}\n# >>> histogram(\"\")\n# {}\nsub histogram {\n    my($test) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&histogram;\n\
  \        if(eq_deeply($candidate->(\"a b b a\"),{\"a\" => 2, \"b\" => 2})) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  a b c a b\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d g\"),{\"a\" =>\
  \ 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1})) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"\
  ),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(\"b b b b a\"),{\"b\"\
  \ => 4})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),{})) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  a\"),{\"a\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  }\n\ntesthumaneval();"
completions: ['    my @letters;', "    my @result;\n    my $frequency = 0;\n    my\
    \ $letter;\n    my $i;\n    my $j;", '    my($histogram) = {};', '    my(%hash);',
  "    return map {my $c = $hist{$_} = 0; $_ eq $test ? $c : ($c += 1)} split /\\\
    s+/;\n}", "    my($counts, $max) = (0, 0);\n    my @letters = ();\n    my $i =\
    \ 0;\n    while ($i < length($test)) {\n        next unless $test[$i] eq ' ';\n\
    \        push @letters, substr($test, $i, 1);\n        $i++;\n    }\n    for (@letters)\
    \ {\n        $counts{$_}++;\n        $max = $counts{$_} if $counts{$_} > $max;\n\
    \    }\n    return \\%counts;\n}", "    my $histogram = {};\n    my @tests = split\
    \ \" \", $test;\n    $histogram->{\"\"} = 0;\n    foreach my $letter (@tests)\
    \ {\n        $histogram->{$letter} = 0;\n    }\n    foreach my $letter (sort {$a\
    \ <=> $b} keys %$histogram) {\n        my $count = $histogram->{$letter};\n  \
    \      foreach my $test (@tests) {\n            $histogram->{$letter} += $histogram->{$test}\
    \ if $test eq $letter;\n        }\n        $histogram->{$letter} = $count if ($histogram->{$letter}\
    \ > $count);\n    }\n    return $histogram;\n}", "    my $histogram = {};\n  \
    \  for (split(' ', $test)) {\n        my $key = $_;\n        if (defined($histogram->{$key})\
    \ && $histogram->{$key}) {\n            $histogram->{$key}++;\n        } else\
    \ {\n            $histogram->{$key} = 1;\n        }\n    }\n    return $histogram;\n\
    }", "    chomp($test);\n    my @tokens = split(\" \", $test);\n    my %histogram\
    \ = ();\n    my $key = '';\n    my $value = 0;\n    foreach my $char (@tokens)\
    \ {\n        $key .= $char;\n        $histogram{$key}++;\n        $value++;\n\
    \    }\n    my $ret = {};\n    foreach my $key (keys %histogram) {\n        $ret->{$key}\
    \ = $histogram{$key};\n    }\n    return $ret;\n}", "    $test =~ tr/a-z//cd;\n\
    \    my @letters = split(//, $test);\n    my %letter_count;\n    my %max_count;\n\
    \    foreach my $letter (@letters) {\n        $letter_count{$letter} = 0;\n  \
    \  }", "    return map { ( $_ => 1 ) } split ' ', $test;\n}", "    my %histogram;\n\
    \    my @characters = split //, $test;\n    for (@characters) {\n        $histogram{$_}++;\n\
    \    }\n    return %histogram;\n}", "    my %letter;\n    map { $letter{$_} =\
    \ 0 } split /\\s+/, $test;\n    map { $letter{$_} += 1 } sort { $letter{$b} <=>\
    \ $letter{$a} } (keys %letter);\n    map { $letter{$_} > 1 ? $letter{$_} : $_\
    \ } (values %letter);\n}", "    my %hash;\n    my @letters;", "    return () unless\
    \ $test;\n    my(%histogram);\n    my @letters = split ' ', $test;\n    foreach\
    \ my $letter (@letters) {\n        my $count = 0;\n        if (exists($histogram{$letter}))\
    \ {\n            $histogram{$letter}++;\n        }\n        else {\n         \
    \   $histogram{$letter} = 1;\n        }\n    }\n    return %histogram;\n}", " \
    \   my @result = ();\n    foreach my $value (split(/ /, $test)) {\n        my\
    \ $count = 0;\n        $count++ while $result{$value} > $count;\n        $result{$value}\
    \ = $count;\n    }\n    return %result;\n}", '    my (%counts);', "    $test =~\
    \ tr/a-z/A-Z/;\n    my @letters = split //, $test;\n    my $hash_ref = {};\n \
    \   for my $letter (@letters) {\n        $hash_ref->{$letter}++;\n    }\n    return\
    \ $hash_ref;\n}", "    my $hash = {};\n    my @chars = split(//, $test);\n   \
    \ foreach my $char (@chars) {\n        $hash->{$char} = 0;\n    }\n    foreach\
    \ my $char (keys %$hash) {\n        $hash->{$char} += 1;\n    }\n    return $hash;\n\
    }", "    my $histogram = {};\n    my @letters = split(' ', $test);\n    foreach\
    \ my $letter (@letters) {\n        $histogram->{$letter}++ if exists $histogram->{$letter};\n\
    \    }\n    return $histogram;\n}", "    return {} unless length $test;\n    my(%results);\n\
    \    foreach my $char (split //, $test) {\n        $results{$char}{$char}++ if\
    \ exists $results{$char}{$char};\n    }\n    foreach my $char (sort { ($results{$a}{$b}\
    \ <=> $results{$b}{$a}) } keys %results) {\n        my($count, $most_common) =\
    \ @{$results{$char}};\n        $results{$char} = [$most_common, $count];\n   \
    \ }\n    return %results;\n}", "    my %histogram;\n    my @words = split(/\\\
    s+/, $test);\n    for (@words) {\n        $histogram{$_}++;\n    }\n    return\
    \ \\%histogram;\n}", "    my %histogram = ();\n    my @letters = split(' ', $test);\n\
    \    my $letter = pop(@letters);\n    foreach my $letter (@letters) {\n      \
    \  my $count = $histogram{$letter};\n        $histogram{$letter} = $count + 1;\n\
    \    }\n    return \\%histogram;\n}", "    my %h;\n    my $max = 0;\n    $max\
    \ += $_ =~ tr/A-Za-z//;\n    $max++ while $test =~ /\\b($_)\\b/ig;\n    while\
    \ ($test =~ /\\b($_)\\b/ig) {\n        $h{$1}++;\n        $max += $_ =~ tr/A-Za-z//;\n\
    \    }\n    $_ = $_;\n    %h = ($_) => $h{$_} while $test =~ /\\b($_)\\b/ig;\n\
    \    return %h;\n}", '    return {} unless $test;', "    my %hash = ();\n    chomp\
    \ $test;\n    my @words = split /\\s+/, $test;\n    foreach my $word (@words)\
    \ {\n        $hash{$word}++;\n    }\n    return %hash if scalar %hash > 1;\n \
    \   return %hash;\n}", "    chomp($test);\n    return %{$counts};\n}", "    my\
    \ %histo;\n    my @letters;", "    my %hist = map { $_ => 0 } split ' ', $test;\n\
    \    my %hash;\n    foreach (keys %hist) {\n        $hash{$_} = $hist{$_};\n \
    \   }\n    return \\%hash;\n}", "    my(%counts) = ();\n    my($key, $val, $count);\n\
    \    while($test =~ /([a-z]+)(?=\\s)/g) {\n        $key = $1;\n        $count\
    \ = 1;\n        while($test =~ /([a-z]+) ([a-z]+)/) {\n            $val = $2;\n\
    \            $count++;\n            $counts{$key} = $count if !exists $counts{$key};\n\
    \            $test = $test =~ /\\s+(\\S+)\\s+(\\S+)\\s+/ ? $1 . \" \" . $2 : \"\
    \";\n        }\n        $counts{$key} = $count if !exists $counts{$key};\n   \
    \ }\n    return %counts;\n}", '    my %hash;', "    $test = \"\" unless defined($test);\n\
    \    my $hist = Hash::Util::withdefault();", "    my @letters = split(\" \", $test);\n\
    \    my %letterCounts;\n    foreach my $letter (@letters) {\n        next unless\
    \ length $letter;\n        ++$letterCounts{$letter};\n    }\n    return %letterCounts;\n\
    }", "    my($histo) = {};\n    my($hash);", "    \n    my %histo;\n    my($max);\n\
    \    $max = 0;\n    \n    for (split /\\s+/, $test) {\n\tmy ($letter, $count)\
    \ = split \" \", $_, 2;\n\t$histo{$letter} = $count > $max ? $count : $max;\n\t\
    $max = $histo{$letter};\n    }\n    \n    return \\%histo;\n}", '    my $hash_ref
    = Hash::Ordered->new;', "    my %counts;\n    my = split //, $test;\n    foreach\
    \ my $char (@chars) {\n        $counts{$char}++ if exists $counts{$char};\n  \
    \  }\n    my %max;\n    @max{@keys} =;\n    return %max;\n}", "    return $histogram{lc($test)}\
    \ if $histogram{lc($test)};\n    return ($histogram{lc($test)} = ()) if $test\
    \ !~ /[a-z_]/ or $test eq \"\";\n    my($letter) = $test;\n    $histogram{lc($letter)}\
    \ = 0;\n    for (split(' ', $test)) {\n        $histogram{lc($letter)}++ if lc($_)\
    \ eq lc($letter);\n    }\n    return $histogram;\n}", "    \n    my(%histogram);\n\
    \    \n    my = ();\n    \n    foreach my $letter (split //, $test) {\n      \
    \  my $count = 0;\n        $histogram{$letter} = $count if(exists $histogram{$letter});\n\
    \        $histogram{$letter} = 1;\n    }\n    \n    foreach my $letter (keys %histogram)\
    \ {\n        my @occurrences = ();\n        my $letter_count = scalar @{$histogram{$letter}};\n\
    \        for(my $i = 0; $i < $letter_count; $i++) {\n            push(@occurrences,\
    \ $i);\n        }\n        \n        my $max = max(@occurrences);\n        foreach\
    \ my $occurrence_index (@occurrences) {\n            if($occurrence_index == $max)\
    \ {\n                push(@{$histogram{$letter}}, $occurrence_index);\n      \
    \          last;\n            }\n        }\n    }\n    \n    return %histogram;\n\
    }", '    my @counts;', '    $test = "" unless defined($test);', "    if($test=~/^\\\
    s*$/) {\n        return {};\n    }\n    my(@letters) = $test =~ /[a-z]+/ig;\n\
    \    my(%counts);", "    my $hist = {};\n    $hist{$_}++ for split /\\s+/, $test;\n\
    \    return $hist;\n}", "    \n    # Empty string is empty\n    if (not defined\
    \ $test) {\n        return {};\n    }\n    \n    # Hash table to store results\n\
    \    my $histogram = {};\n    \n    # Split the string on whitespace into words\n\
    \    my = split /\\s+/, $test;\n    \n    # Sort alphabetically\n    sort { $a\
    \ cmp $b };\n    \n    # Loop through words and calculate frequency for each\n\
    \    for my $word (@words) {\n        if (!defined $histogram->{$word}) {\n  \
    \          $histogram->{$word} = 1;\n        }\n        else {\n            $histogram->{$word}++;\n\
    \        }\n    }\n    \n    return $histogram;\n}", '    my %histogram;', " \
    \   my @letters = split(//, $test);\n    my %result;\n    foreach my $letter (@letters)\
    \ {\n        if(exists $result{$letter}) {\n            $result{$letter}++;\n\
    \        } else {\n            $result{$letter} = 1;\n        }\n    }\n    return\
    \ \\%result;\n}", '    chomp($test);', "    $test =~ s/\\s+//g;\n    my %histogram;",
  "    my %hash;\n    my $count = 0;\n    my @letters;\n    foreach my $letter (split(//,$test))\
    \ {\n        $hash{$letter}++;\n        $count++;\n    }\n    foreach my $letter\
    \ (keys %hash) {\n        if ($hash{$letter} > $count) {\n            $letters[$letter]\
    \ = $hash{$letter};\n        }\n    }\n    return @letters ? \\%hash : undef;\n\
    }", "    my %histogram;\n    map { $histogram{ $_ } += 1 } split(\" \", $test);\n\
    \    return \\%histogram;\n}", "    $test =~ tr/a-z/A-Z/;\n    my $hash = {};\n\
    \    my @chars = split(//,$test);\n    for my $char (@chars) {\n        $hash{$char}\
    \ = 0;\n    }\n    my $max = 0;\n    my $maxchar = undef;\n    for my $char (keys\
    \ %$hash) {\n        my $value = $hash{$char};\n        if ($value > $max) {\n\
    \            $max = $value;\n            $maxchar = $char;\n        }\n    }\n\
    \    if (defined $maxchar) {\n        for my $char (keys %$hash) {\n         \
    \   if ($hash{$char} eq $max) {\n                return {\n                  \
    \  char => $maxchar,\n                    count => $hash{$char},\n           \
    \     };\n            }\n        }\n    }\n    return;\n}", "    $histogram{$_}++\
    \ for($test) =~ /([a-zA-Z]+)/ig;\n    return %histogram;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=language-agnostic,histogram,algorithm,string,language-agnostic\
    \ |>\nI find this approach very elegant.  It uses a simple regex to find all the\
    \ letters, and sorts the letters using the hash table to keep them in order.\n\
    <code>\nfunction find_letter_frequency($str)\n{\n    # find all the letters\n\
    \    $letters = $str =~ /([a-zA-Z]+)/ig;", "    chomp($test);\n    my @result\
    \ = ();\n    foreach my $letter (split(//,$test)) {\n        next unless $letter\
    \ =~ /[a-z]/i;\n        my $count = $seen{$letter}++;\n        if ($count > 1)\
    \ {\n            push(@result, $letter => $count);\n        }\n    }\n    \n \
    \   return @result ? \\@result : ();\n}", "    return {}\n        unless $test;",
  "    return undef if ($test eq \"\");\n    my @test = split /\\s+/, $test;\n   \
    \ my %result;\n    my $count = 1;\n    foreach my $char (@test) {\n        if\
    \ (exists $result{$char}) {\n            $count++;\n        }\n        $result{$char}\
    \ = $count;\n    }\n    return $result;\n}", "    my %histogram;\n    $histogram{$_}++\
    \ for\n        split \" \", uc $test;\n    return \\%histogram;\n}", "    my @histogram;\n\
    \    $histogram[0]{$_}++ for split /\\s+/, $test;\n    return @histogram;\n}",
  "    my $histogram = {};\n    $histogram->{$_} = 1 for split \" \", $test;\n   \
    \ return $histogram;\n}", "    my %hash = ();\n    my @chars;\n    my @char;\n\
    \    \n    foreach (split(//, $test)) {\n        push @chars, $_;\n    }\n   \
    \ \n    foreach $char (@chars) {\n        if ($char =~ /^[a-z]/) {\n         \
    \   my $num = 1;\n            foreach $key (sort {$a <=> $b} keys %hash) {\n \
    \               if ($key eq $char) {\n                    $hash{$key}++;\n   \
    \                 if ($hash{$key} > $num) {\n                        $char = $key;\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           push @char, $char;\n        }\n    }\n    \n    return %hash;\n}",
  "    my @histogram;\n    my %count;\n    my @letters;\n    my $letter;", "    $test\
    \ =~ tr/ A-Za-z //d;\n    my %histo;\n    $_ = $test if $test =~ /^$/;\n    foreach\
    \ my $char (split //, $test) {\n        if (!defined($histo{$char})) {\n     \
    \       $histo{$char} = 1;\n        } else {\n            $histo{$char}++;\n \
    \       }\n    }\n    return map {$_ => $histo{$_}};\n}", "    chomp $test;\n\
    \    my @letters = split /\\s+/, $test;", "    \n    my %histogram;\n    my @chars\
    \ = split //, $test;\n    $histogram{$_}++ for (@chars);\n    \n    return \\\
    %histogram;\n}", "    my(%result) = (0);\n    my($letter);\n    my($count);\n\
    \    foreach $letter (split(\" \", $test)) {\n        $count++;\n        $result{$letter}++;\n\
    \    }\n    foreach $letter (sort {$result{$b} <=> $result{$a}} keys %result)\
    \ {\n        $result{$letter} = $count if $result{$letter} > $count;\n    }\n\
    \    return %result;\n}", "    my %histo = ();\n    my @letters = split \" \"\
    , $test;\n    foreach my $letter (@letters) {\n        $histo{$letter} += 1;\n\
    \    }\n    foreach my $letter (keys %histo) {\n        $histo{$letter} = $histo{$letter}\
    \ / scalar @letters;\n    }\n    return \\%histo;\n}", "    my $hash = {};\n \
    \   foreach (split //, $test) {\n        $hash->{$_}++;\n    }\n    foreach my\
    \ $k (sort {$a <=> $b} keys %$hash) {\n        my $c = $hash->{$k};\n        if\
    \ ($c > 0) {\n            delete $hash->{$k};\n            return $hash;\n   \
    \     }\n    }\n    return $hash;\n}", '    my @result = ({});', "    return map\
    \ { $_ => 1 } keys %{ map { (split //, $_, -1) } split /\\s+/, $test };\n}\n</code>\n\
    <|/ a dscore=0 tags=perl,hash,algorithm |>\n<| a tags=perl,hash,algorithm dscore=0\
    \ |>\nFor what it's worth, I took your original code and cleaned it up a bit.\
    \ This is the program I wrote:\n<code>\nuse strict;\nuse warnings;\nuse autodie;",
  "    my($ret) = {};\n    my $spaceless = lc($test);\n    my $count = ();\n    my\
    \ $current_letter = ();", '    my %histogram;', '    my %histogram;', "    my\
    \ $histogram = ();\n    my $letter;\n    my $count;", "    my(%histogram);\n \
    \   my(@chars);", "    my $histogram = Hash::MultiValue::SingleValue->new;\n \
    \   if ($test =~ /^\\s+$/) {\n        return $histogram;\n    }\n    my @split\
    \ = $test =~ /\\s+/;\n    $histogram->{\"\"} = 0;\n    foreach my $letter (@split)\
    \ {\n        $histogram->{$letter}++;\n    }\n    foreach my $key (keys(%$histogram))\
    \ {\n        my $count = $histogram->{$key};\n        if ($count == scalar(@split))\
    \ {\n            $histogram->{$key} = $count;\n        } else {\n            my\
    \ @new_hash;\n            my $count = 0;\n            foreach my $letter (@split)\
    \ {\n                $new_hash[$letter]->{$key} = $count;\n                $count\
    \ += $histogram->{$letter};\n            }\n            $histogram->{$key} = $count;\n\
    \            $histogram = Hash::MultiValue::MultiValue->new(\\@new_hash);\n  \
    \      }\n    }\n    return $histogram;\n}", '    my($hash);', "    return {}\
    \ if $test eq \"\";\n    my @chars = split(\" \", $test);\n    my %histogram;\n\
    \    my $total;\n    foreach my $char (@chars) {\n        my $value = $histogram{$char};\n\
    \        my $count = $histogram{$char}++ if exists $histogram{$char};\n      \
    \  $total += $count;\n        $histogram{$char} = $count if !defined $value;\n\
    \    }\n    return %histogram;\n}", '    my %counts;', "    $test =~ tr/a-z/A-Z/;\n\
    \    $test =~ s/^\\s+//;\n    my %hash = map {chr } split //, $test;\n    my %count_hash;\n\
    \    $count_hash{\"\"} = 0;\n    foreach my $key (sort keys %hash) {\n       \
    \ $count_hash{$key}++ if !defined $count_hash{$key};\n    }\n    return %count_hash;\n\
    }", "    return wantarray ? {} : ();\n}", "    my $hash = { map { lc $_ => 1 }\
    \ split \" \", $test };\n    my $result = { map { lc $_ => 1 } split \" \", $test\
    \ };\n    my $max;\n    my $key;\n    for (keys %$hash) {\n        $max = delete\
    \ $result->{$_};\n        $key = delete $hash->{$_};\n    }\n    if ($max > 1)\
    \ {\n        return $hash;\n    } else {\n        return $result;\n    }\n}",
  "    my $histogram = Hash::Util::withkeys(@alphabet);\n    $histogram->{$_}++ for\
    \ split \" \", $test;\n    $histogram;\n}", '    my %letters_count = ();', " \
    \   my %count;\n    for my $char (split /\\s+/, $test) {\n        my $count =\
    \ $count{$char} || 0;\n        $count++;\n        $count{$char} = $count;\n  \
    \  }\n    return %count;\n}", "    my $histogram = {};\n    my @words = split\
    \ /\\s+/, $test;\n    foreach (@words) {\n        if (!defined $histogram->{$_})\
    \ {\n            $histogram->{$_} = 0;\n        }\n        $histogram->{$_}++;\n\
    \    }\n    return $histogram;\n}", "    $test =~ tr/ /\\n/ /;\n    $test =~ tr/A-Z//cd;\n\
    \    my %hash;\n    foreach my $l (split ' ', $test) {\n        $hash{$l} += 1;\n\
    \    }\n    return %hash;\n}", "    return {} unless defined $test;\n    my @letters\
    \ = split ' ', $test;\n    my $hash;\n    my $max = 0;\n    foreach my $letter\
    \ (@letters) {\n        if (!exists $hash->{$letter}) {\n            $hash->{$letter}\
    \ = 0;\n        }\n        $hash->{$letter}++;\n        if ($hash->{$letter} >\
    \ $max) {\n            $max = $hash->{$letter};\n        }\n    }\n    return\
    \ $hash if $max;\n    return ();\n}", "    my $hash;\n    my @results;\n    my\
    \ @counter;\n    $hash = {};", "    my %histogram;\n    my @letters;\n    for\
    \ my $letter (split /\\s+/, $test) {\n        push @letters, $letter if exists\
    \ $histogram{$letter};\n        ++$histogram{$letter};\n    }\n    $histogram{\"\
    -\"}++ if $letters[0] =~ m/^-$/;\n    return \\%histogram;\n}", "    my(%result);\n\
    \    my @chars;\n    $test =~ s/\\s+//g;\n    $test =~ s/^\\s+//;\n    my @chars\
    \ = split(//, $test);\n    foreach my $char (@chars) {\n        if (!exists($result{$char}))\
    \ {\n            $result{$char} = 1;\n        } else {\n            $result{$char}++;\n\
    \        }\n    }\n    return %result;\n}", "    $test = [split ' ', $test] if\
    \ $test =~ /^\\s*$/;\n    my %histogram;\n    for my $letter (sort split //, $test)\
    \ {\n        $histogram{$letter}++;\n    }\n    my %max_counts = reverse %histogram;\n\
    \    return %histogram;\n}", '    return {} unless $test;', "    my(%result);\n\
    \    my(@letters);\n    my($i);\n    my($letter);", "    my $hash;\n    foreach\
    \ my $char (split(/ /, $test)) {\n        $hash->{$char}++ if exists $hash->{$char}\
    \ and $hash->{$char}++;\n    }\n    return $hash;\n}", "    chomp($test);\n  \
    \  my($letters, $counts);", "    my %histogram;\n    my(@string) = split(/ /,\
    \ $test);\n    for (@string) {\n        $histogram{$_}++;\n    }\n    return %histogram;\n\
    }", "    my(%hash);\n    my @letters;\n    foreach my $letter (split(//,$test))\
    \ {\n        $hash{$letter}++;\n        push(@letters,$letter) if !$letter->[0];\n\
    \    }\n    return %hash if scalar(@letters);\n    return;\n}", "    my($letters);\n\
    \    my($hash);\n    my($max_count);\n    while($test=~/(\\S+)/g){\n        push\
    \ @$letters, $1;\n        $hash->{$1}++ if($hash->{$1} > $max_count);\n    }\n\
    \    foreach $letter (sort keys %$hash){\n        $hash->{$letter} = $hash->{$letter}/@$letters\
    \ if @$letters > 1;\n    }\n    return $hash;\n}", "    \n    return map {\n \
    \       my ($key, $val) = split ' ', $_, 2;\n        $key => $val\n    } sort\
    \ {\n        $a <=> $b\n    } map {\n        my ($key) = split ' ', $_, 2;\n \
    \       $key => 1\n    } split ' ', $test, 2;\n}", '    my $counts;', '    my
    %histogram;', "    my %histogram;\n    my @letters;\n    my @histo;\n    my $max;",
  '    my(%freq);', '    my(%count, $key);', "    my %result;\n    my @letters = split\
    \ //, $test;\n    my $letter = pop(@letters);\n    $letter = \"a\" unless defined\
    \ $letter;\n    $letter = \"z\" unless $letter eq \"A\" or $letter eq \"B\" or\
    \ $letter eq \"C\";\n    my $count = 1;\n    while (@letters) {\n        my $letter\
    \ = pop(@letters);\n        unless (defined $letter) {\n            $letter =\
    \ \"z\" if $letter eq \"A\" or $letter eq \"B\" or $letter eq \"C\";\n       \
    \     $letter = \"a\" unless defined $letter;\n            $letter = \"z\" unless\
    \ $letter eq \"A\" or $letter eq \"B\" or $letter eq \"C\";\n            $letter\
    \ = $letter = \"a\" unless defined $letter;\n            $letter = $letter = \"\
    z\" unless $letter eq \"A\" or $letter eq \"B\" or $letter eq \"C\";\n       \
    \ }\n        $count++;\n        my $key = $letter;\n        $result{$key} = $count\
    \ if exists $result{$key};\n    }\n    return \\%result;\n}", "    if($test =~\
    \ /^\\s*$/){\n        return {};\n    }\n    my @letters = split(/ /, $test);\n\
    \    my %hash;\n    my @letters_count;\n    my $letter;\n    foreach $letter (@letters){\n\
    \        $letters_count[$letter] = $hash{$letter} ? $hash{$letter} + 1 : 0;\n\
    \    }\n    foreach $letter (@letters_count){\n        if($letter !~ /^[a-z]+$/i){\n\
    \            next;\n        }\n        $hash{$letter} = $letters_count[$letter];\n\
    \    }\n    return %hash;\n}\n</code>\n<|/ a dscore=0 tags=regex,perl,hash |>\n\
    <| a tags=regex,perl,hash |>\nYou can do it without any modules. It's a little\
    \ more code than the other answers, but I think it's more clear, and it's easy\
    \ to understand.\n<code>\nuse strict;\nuse warnings;", "    $test =~ s/\\s+//g;\n\
    \    my %hash;\n    my $str =  \"$test\";\n    $str =~ tr/ /[a-z]/;\n    $str\
    \ =~ tr/a/A/g;\n    foreach my $char (split(//, $str)) {\n        if (!defined\
    \ $hash{$char}) {\n            $hash{$char} = 1;\n        } else {\n         \
    \   $hash{$char}++;\n        }\n    }\n    my $max_repeated_char;\n    my $max_repeated_count\
    \ = 0;\n    foreach my $letter (keys %hash) {\n        if ($hash{$letter} > $max_repeated_count)\
    \ {\n            $max_repeated_char = $letter;\n            $max_repeated_count\
    \ = $hash{$letter};\n        }\n    }\n    if ($max_repeated_count != 1) {\n \
    \       foreach my $letter (keys %hash) {\n            if ($letter ne $max_repeated_char\
    \ && $hash{$letter} != 1) {\n                $hash{$letter} = $max_repeated_count;\n\
    \            }\n        }\n    }\n    return %hash;\n}", "    return {} unless\
    \ $test;\n    my($letter, $frequency) = (0, 0);\n    my($result) = ({});\n   \
    \ foreach $letter (split /\\s+/, $test) {\n        if (exists $result->{$letter})\
    \ {\n            $result->{$letter}++;\n        } else {\n            $result->{$letter}\
    \ = 1;\n        }\n        if ($result->{$letter} > $frequency) {\n          \
    \  $frequency = $result->{$letter};\n        }\n    }\n    $result;\n}", "   \
    \ return { map { $_ => 1 } } unless $test;\n    my($letters, $counts) = map {\
    \ chomp; split } split \" \", $test;\n    $counts[-1] += $letters[-1] ? 1 : 0;\n\
    \    my %hash;\n    $counts[-1] =~ s/ //g;\n    $counts[-1] =~ tr/ /x/;\n    map\
    \ {\n         $letters{$_}++;\n         $hash{$_} = $letters{$_} if $letters{$_}\
    \ > $hash{$_} || $letters{$_} == -1;\n     } keys %letters;\n    return %hash;\n\
    }", "    my %histogram = ();\n    for (split /\\s+/, $test) {\n        $histogram{$_}++;\n\
    \    }\n    return %histogram;\n}", '    my $histogram = Hash::Util::FieldHash->new();',
  "    my (%h);\n    $h{$_}++ for split ' ', $test;\n    return \\%h;\n}", "    $test\
    \ =~ tr/A-Z/a-z/;\n    my $histogram = { };\n    my @letters = split ' ', $test;\n\
    \    my $letter;\n    for my $letter (@letters) {\n        my $count = $histogram->{$letter}\
    \ || 0;\n        $histogram->{$letter} = $count + 1;\n    }\n    return $histogram;\n\
    }", "    $test =~ tr/A-Z/a-z/;\n    my @letters;\n    my %hash;\n    my @list;\n\
    \    $test =~ m/(\\w+)/g;\n    foreach my $letter (@{$test}){\n        if(!exists\
    \ $hash{$letter}){\n            $hash{$letter} = 1;\n        }\n        else{\n\
    \            $hash{$letter}++;\n        }\n    }\n    foreach my $letter (sort\
    \ keys %hash){\n        if($hash{$letter} == 1){\n            push(@letters, $letter);\n\
    \        }\n    }\n    push(@list, \\@letters);\n    return $hash;\n}", "    return\
    \ map {\n        $_ => 1\n    }\n        sort { $a->{$b} <=> $a->{$b} || $b->{$a}\
    \ <=> $b->{$a} } # alphabetical order\n            map {\n                chomp;\n\
    \                my($letter, $count) = split /\\s+/, $_, 2;\n                $letter;\n\
    \            }\n            split /\\s+/, $test;\n}", "    my %counts;\n    foreach\
    \ my $letter (split /\\s+/, $test) {\n        $counts{$letter} += 1;\n    }\n\
    \    return sort { $counts{$b} <=> $counts{$a} } (keys %counts);\n}", "    my\
    \ %histogram;\n    my = split //, $test;", "    return () if $test eq \"\";\n\
    \    \n    return %{ map { $_ => 1 } split /\\s+/, $test };\n}", '    $test =
    $test eq "" ? {} : $test;', "    my $histo;\n    my %histo = ();\n    my @letters\
    \ = split(\" \", $test);\n    my $letter;", "    if ($test =~ /\\s/) {\n     \
    \   # Assume $test is a space-separated lowercase string.\n        my $histogram\
    \ = Hash::Frequency->new;\n        $test =~ s/\\s+//g;\n        for (split(//,\
    \ $test)) {\n            $histogram->update([$_] => 1);\n        }\n        return\
    \ $histogram;\n    } else {\n        # Assume $test is a single character.\n \
    \       return $histogram->update([$test] => 1);\n    }\n}", "    $test = $test\
    \ ? $test : \"\";\n    my %hash;\n    $hash{$_}++ for split /\\s+/, $test;\n \
    \   my %return_hash;\n    my %return_count = ( );\n    for my $key ( sort keys\
    \ %hash ) {\n        $return_hash{$key} = $hash{$key};\n        $return_count{$key}++;\n\
    \    }\n    return \\%return_hash if %return_hash;\n    return \\%return_count;\n\
    }", "    if($test eq '') {\n        return {};\n    }\n    my(@characters) = split('\
    \ ', $test);\n    my %counts;\n    foreach my $character (@characters) {\n   \
    \     my $count = $counts{$character}++;\n        if($count > 1) {\n         \
    \   $counts{$character} = $count;\n        }\n    }\n    return %counts;\n}",
  "    my %histogram = ();\n    my @characters;\n    my @char_count;\n    foreach\
    \ my $char (split /\\s+/, $test) {\n        if ($char =~ /\\w/) {\n          \
    \  push @characters, $char;\n        }\n        else {\n            $char_count[$char]\
    \ = $char_count[$char] + 1;\n        }\n    }\n    foreach my $char (@characters)\
    \ {\n        $histogram{$char} = $char_count[$char] if $char_count[$char] >= 2;\n\
    \    }\n    return \\%histogram;\n}", "    $test = $test =~ s/\\s+$//g;\n    $test\
    \ =~ s/^\\s+|\\s+$//g;\n    my %letters;\n    my $max;\n    my @letter;\n    my\
    \ $letterCount = 0;\n    for (split /\\s+/, $test) {\n        $letterCount++;\n\
    \        $letters{$_}++;\n        if ($letters{$_} > $max) {\n            $max\
    \ = $letters{$_};\n        }\n    }\n    foreach my $letter (sort keys %letters)\
    \ {\n        if ($letters{$letter} eq $max) {\n            push @letter, $letter;\n\
    \        }\n    }\n    return \\@letter;\n}", '    return {} if !$test;', "  \
    \  $test =~ tr/ +//d; # remove spaces from letters\n    my %histogram;\n    my\
    \ $freq;\n    for my $letter (split //, $test) {\n        $freq++ if exists $histogram{$letter};\n\
    \        $histogram{$letter}++;\n    }\n    return \\%histogram;\n}", "    $test\
    \ = \" $test \" unless $test =~ /[^ ]+/;\n    my %histo;\n    split /\\s+/, $test;\n\
    \    foreach my $letter (sort keys %histo) {\n        $histo{$letter}++;\n   \
    \ }\n    return \\%histo;\n}", "    my $hash = { };\n    map {$hash->{$_} = 0}\
    \ split(\" \", $test);\n    $hash->{$_} = 1 for values %$hash;\n    return $hash\
    \ if keys %$hash;\n    return;\n}", "    my %hash;\n    my @keys;", "    my %hash;\n\
    \    my = split (/\\s+/, $test);\n    foreach my $element (@array) {\n       \
    \ if (!$hash{$element}) {\n            $hash{$element} = 1;\n        }\n     \
    \   else {\n            $hash{$element}++;\n        }\n    }\n    foreach my $key\
    \ (sort {$hash{$a} <=> $hash{$b}} keys %hash) {\n        push @frequencies, $key\
    \ => $hash{$key};\n    }\n    return \\@frequencies;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`perl` doesn't have a `Hash::MultiKeyHash` module?\n<|/ c |>\n\
    <| c |>\nPerl has had this since about 5.10 - [here's an old thread on cpan](https://stackoverflow.com/questions/411166/what-is-the-difference-between-hash-and-hash-multikeyhash)\n\
    <|/ c |>\n<| c |>\nThat is not true: `Hash::MultiKeyHash` is a *module*, the documentation\
    \ says \u201CThis module implements a `Hash` type that stores multiple data values\
    \ in a single key.\u201D `Hash` is a class, with many methods like `keys`, `values`,\
    \ `pairs`, `delete`, `update`, `delete_values`, `has_values`, `values`, `keys`,\
    \ `keys` and `values` but no `merge`, `merge_values`, `merge_values` and `merge_pairs`.\
    \ And `Hash::MultiKeyHash` isn\u2019t a `Hash`\u2014it\u2019s a *module* for implementing\
    \ `Hash`s with multiple keys.\n<|/ c |>\n<| c |>\nYou're right, and that's why\
    \ I said \"since about 5.10\"... I updated the answer.\n<|/ c |>\n<| c |>\n`Hash::MultiKeyHash`\
    \ still doesn't have `merge`, `merge_values`, `merge_values` and `merge_pairs`,\
    \ but the `Hash` class does. And now it also has `merge_values`.\n<|/ c |>\n<|\
    \ a tags=hash,perl,arrays dscore=0 |>\nHash::MultiKeyHash can do what you want:\n\
    <code>", '    my $hash = {};', "    my %histo;\n    my @letters = split(//, $test);\n\
    \    foreach my $letter (@letters) {\n        if (!defined($histo{$letter})) {\n\
    \            $histo{$letter} = 0;\n        }\n        $histo{$letter}++;\n   \
    \ }\n    return \\%histo;\n}", "    my %hash;\n    my @array = split ' ', $test;\n\
    \    for my $string (@array) {\n        $hash{$string}++ if exists $hash{$string};\n\
    \    }\n    return \\%hash;\n}\n</code>\n<|/ a tags=perl,hash,arrays,sorting |>\n\
    <| c |>\nThe first function doesn't return what you want.  It doesn't return the\
    \ number of times each letter appears in the string, just the letter with the\
    \ highest count (and no repetition).  Also, the second function doesn't work if\
    \ the string only contains unique characters.  It only returns the letter with\
    \ the highest count.\n<|/ c |>\n<| c |>\nThe first function will work if the string\
    \ is space separated. My mistake.\n<|/ c |>\n<| c |>\nYes, I tested it. I just\
    \ assumed the input was space separated because of the use of `split` in the first\
    \ function.\n<|/ c |>\n<| c |>\nThe first function works fine, and is very succinct.\
    \  However, it is far from optimal.  Using a `grep` would probably be much faster,\
    \ and would make it easier to understand and maintain.  The second function is\
    \ not wrong, but it doesn't work.  I believe `sort` is already doing what you're\
    \ trying to do here.  What are you trying to do?\n<|/ c |>\n<| a |>\n<code>",
  "    return () unless $test;\n    my %result;\n    $test =~ s/\\s+//g;\n    for\
    \ my $letter (split //, $test) {\n        $result{$letter} = $result{$letter}\
    \ ? $result{$letter} + 1 : 1;\n    }\n    %result;\n}", "    my($histogram);\n\
    \    my($count);", "    my $histo = ();\n    my $max_freq = 0;\n    my $letter;",
  "    my $histogram = {};\n    my @letters = split ' ', $test;\n    my $letter =\
    \ $letters[0];\n    my $count = 1;", "    my $h = Hash::Util::reduce {$_ => 1},\
    \ [split ' '],\n        map {\n            $_ eq \"\" ? ()\n            : ($_,\
    \ scalar grep {\n                $test->($_) ? ($_ => 1)\n                   \
    \ : ()\n            } split ' ', $_)\n        } split ' '\n    ;\n    return $h;\n\
    }", "    my $histogram = {};\n    my $letter;\n    my $count;\n    foreach $letter\
    \ (split(//, $test)) {\n        $count++;\n        $histogram->{$letter} = $count\
    \ if $histogram->{$letter} < $count;\n    }\n    $histogram\n}", "    my $hash\
    \ = {};\n    my $word;", "    if(!$test) {\n        return {};\n    }\n    my\
    \ @letters;\n    $test =~ s/\\s+//g;\n    my @letter;\n    my $letter;\n    my\
    \ $count;\n    while($test =~ s/(\\S+\\s+)//g) {\n        push(@letters, $1);\n\
    \    }\n    $test = join(\"\", @letters);\n    foreach $letter (@letters) {\n\
    \        $count{$letter} = 0;\n    }\n    foreach $letter (@letters) {\n     \
    \   $count{$letter}++;\n    }\n    @letter = sort {$count{$b} <=> $count{$a}}\
    \ keys %count;\n    my $hash;\n    foreach $letter (@letter) {\n        $hash->{$letter}\
    \ = $count{$letter};\n    }\n    return $hash;\n}", "    my @alphabet = split\
    \ //, $test;\n    my %histogram;\n    my $max = 0;\n    my $letter;\n    my $letterCount;\n\
    \    my $count;\n    for my $letter (@alphabet) {\n        $letterCount = $histogram{$letter};\n\
    \        $count = $letterCount ? $letterCount+1 : 0;\n        if ($count > $max)\
    \ {\n            $max = $count;\n            $letter = $letter;\n        }\n \
    \       $histogram{$letter} = $count;\n    }\n    return \\%histogram;\n}", " \
    \   return {} unless $test =~ m/[a-z]/;\n    $histogram{$_}++ for split \" \"\
    , $test;\n    return $histogram;\n}", "    chomp($test);\n    my %result = ();\n\
    \    \n    my @words = split /\\s+/, $test;\n    foreach my $word (@words) {\n\
    \        my @letters = split ' ', $word;\n        foreach my $letter (@letters)\
    \ {\n            my $count = $result{$letter} ||= 0;\n            $result{$letter}\
    \ = $count + 1;\n        }\n    }\n    \n    return \\%result;\n}", "    $test\
    \ = $test || \"\";\n    my %tests;", "    my @tests;\n    my @histo = ();\n  \
    \  my $test = \"\";", "    if (defined $test) {\n        my @chars = split ' ',\
    \ $test;\n        my %h;\n        foreach my $char (@chars) {\n            if\
    \ (!exists $h{$char}) {\n                $h{$char} = 1;\n            }\n     \
    \       else {\n                $h{$char}++;\n            }\n        }\n     \
    \   return %h;\n    }\n    else {\n        return {};\n    }\n}", "    my @result;\n\
    \    my($key, $value) = (0, 0);\n    for ($test) {\n        $key++ if ($test eq\
    \ $_);\n        $value++ if ($test eq uc($_));\n    }\n    push @result, $key\
    \ => $value if ($key && $value);\n    return @result;\n}", '    return {} unless
    $test;', '    my %counts;', "    if ( $test =~ /\\s/ ) {\n        my @letters\
    \ = split( ' ', $test );\n        return map { $letters[$_] => 1 } 0 .. $#letters;\n\
    \    }\n    elsif ( $test !~ /^[a-y]*$/ ) {\n        return {};\n    }", "   \
    \ my($hash);\n    my(@letters);\n    my(@values);\n    my($count);\n    my($keys);",
  "    my $letters = $test;\n    my %histo;\n    my @histogram;\n    $histo{$_} =\
    \ 1 for (split(/ /, $letters));\n    $histo{$_} = 0 foreach values %histo;\n \
    \   foreach my $key (sort {$histo{$b} <=> $histo{$a}} keys %histo) {\n       \
    \ push @histogram, $key;\n    }\n    return \\@histogram;\n}", "    my %histogram;\n\
    \    my(@keys);", "    return {} unless $test;\n    $test = '' unless $test =~\
    \ /\\s+/;\n    my %counts;\n    my @letters = split ' ', $test;\n    for my $letter\
    \ (@letters) {\n\tmy $count = $counts{$letter} || 0;\n\t$count++;\n\t$counts{$letter}\
    \ = $count;\n    }\n    return \\%counts;\n}", "    $test =~ s/\\s+//g;\n    $test\
    \ =~ s/^\\s+//;\n    $test =~ s/\\s+$//;", "    my %hash;\n    for my $char (split\
    \ /\\s+/, $test) {\n        $hash{$char} += 1;\n    }\n    my ($key, $value);\n\
    \    foreach $key (sort { $hash{$a} <=> $hash{$b} } keys %hash) {\n        $value\
    \ = $hash{$key};\n        $hash{$key} = $value;\n        last if $value == 1;\n\
    \    }\n    return map { ($_ => $hash{$_}) } keys %hash;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nJust a warning: this would return a list of letters, not a list\
    \ of counts.\n<|/ c |>\n<| c |>\nIt wouldn't, since it returns a list of lists,\
    \ where the inner list has each letter as a key and each count as a value. If\
    \ that wasn't wanted, you could `map { map { $_ => $hash{$_} } } keys %hash`\n\
    <|/ c |>\n<| c |>\nOops, yes, you are right - I misread the question. +1 for the\
    \ solution though!\n<|/ c |>\n<| a |>\nHere's my solution:\n<code>\nuse strict;\n\
    use warnings;", "    $test =~ s/\\s+//g;\n    my %h;\n    for (split /\\s+/, $test)\
    \ {\n        $h{$_}++ while exists($h{$_});\n    }\n    return %h;\n}", "    return\
    \ () unless length($test);\n    my(%result) = (0, ());\n    my $count = 1;\n \
    \   for(split(/\\s+/, $test)) {\n        $count++ if exists($result{$_});\n  \
    \      $result{$_} = $count if !exists($result{$_});\n    }\n    return %result;\n\
    }", "    my(@letters);\n    my(%histogram);\n    my($letter);\n    my($count);\n\
    \    foreach $letter (split /\\s+/, $test) {\n        $histogram{$letter}++;\n\
    \        push, $letter;\n    }\n    @letters = sort { $a <=> $b } keys %histogram;\n\
    \    foreach $letter (@letters) {\n        $count = $histogram{$letter};\n   \
    \     delete $histogram{$letter};\n        $histogram{$letter} = $count;\n   \
    \ }\n    return %histogram;\n}", "    my @histogram;\n    my $letter;\n    my\
    \ $count;\n    my($max, $max_count, $max_letter);", "    $test .= \" \" unless\
    \ $test =~ /\\s+/;\n    my %counts;\n    foreach (split /\\s+/, $test) {\n   \
    \     $counts{$_}++ if length($_);\n    }\n    my %max = (reverse sort {\n   \
    \         $counts{$b} <=> $counts{$a}\n        } keys %counts);\n    %max = map\
    \ {\n            $_ => $max{$_}\n        } keys %max;\n    my %result = map {\n\
    \            $_ => $max{$_}\n        } keys %counts;\n    return \\%result;\n}",
  '    my($letters, $counts, $max_letter);', "    my @letters;\n    my %histo;\n \
    \   foreach my $l (split //, $test) {\n        push @letters, $l if defined $histo{$l};\n\
    \        $histo{$l}++;\n    }\n    return (\\%histo) if scalar keys %histo;\n\
    \    return;\n}", "    my($hash, $letter, $count) = (0, \"\", 0);\n    my(@letters)\
    \ = ();\n    foreach(split(/ /, $test)) {\n        if($letter ne $letters[$letter])\
    \ {\n            $letter = $letters[$letter];\n            $count = 1;\n     \
    \   } else {\n            $count++;\n        }\n        $letters[$letter] = $letter;\n\
    \        push(@{$hash}{$letter}, $count);\n    }\n    return $hash;\n}", "   \
    \ my(%histo);\n    my($hash);\n    while($test =~ s/(\\w)(\\w*)/$histo{$1}{$2}++/ge)\
    \ {\n        my($c,$lc) = ($1,$2);\n        $hash = $lc unless $hash;\n      \
    \  $hash{$c} = 0 if $hash{$c};\n    }\n    return $hash;\n}", "    my %histogram;\n\
    \    my @letters = split /\\s+/, $test;\n    foreach my $letter (@letters) {\n\
    \        $histogram{$letter} += 1;\n    }\n    return \\%histogram;\n}", "   \
    \ my $histogram;\n    my @keys;\n    $histogram = ();\n    # create hash where\
    \ keys are letters and values are number of occurences\n    my $letters = split(\"\
    \ \",$test);\n    map { ($histogram->{$_}++,$letters->{$_}++) } split(//,$test);\n\
    \    # create array with letters and number of occurences\n    map { push(@keys,\
    \ $_ => $histogram->{$_}) } keys(%$histogram);\n    # sort array and reverse the\
    \ order so that the longest first\n    @keys = sort { $a <=> $b} reverse @keys;\n\
    \    return $histogram->{$keys[0]};\n}", "    $test = $test->clone;\n    $hash{$_}\
    \ += 1 for split //, $test;\n    $hash{$_} = 0 unless exists $hash{$_};\n    for\
    \ (keys %hash) {\n        $hash{$_} = 0 unless exists $hash{$_};\n    }\n    return\
    \ $hash;\n}", "    if ($test !~ /\\S/) {\n        return {};\n    }\n    $test\
    \ =~ tr/a-z//cd;\n    my %hash;\n    my $count;\n    $count = 1;\n    foreach\
    \ my $letter (@test) {\n        if (!$hash{$letter}) {\n            $hash{$letter}\
    \ = $count;\n        } else {\n            $hash{$letter}++;\n        }\n    }\n\
    \    return %hash;\n}", "    my(%h);\n    my(@letters);", "    my %h;\n    my\
    \ %counter;\n    my @chars = split(\" \", $test);\n    foreach my $c (@chars)\
    \ {\n        $counter{$c}++;\n    }\n    foreach my $k (sort {\n        $counter{$b}\
    \ <=> $counter{$a}\n    } keys %counter) {\n        $h{$k} = $counter{$k};\n \
    \   }\n    return \\%h;\n}", "    return () unless length($test);\n    my(%hash)\
    \ = ();\n    my($max);\n    my($letter) = ();\n    my($count) = ();\n    my($word);\n\
    \    my($space) = ($test =~ /\\s+/);\n    for(split(\" \",$test)) {\n        $hash{$_}++;\n\
    \        if (exists($hash{$_})) {\n            if (exists($hash{$_})) {\n    \
    \            $hash{$_}++;\n                if (exists($hash{$_})) {\n        \
    \            $hash{$_}++;\n                    $hash{$_}++;\n                }\n\
    \            }\n            $hash{$_}++;\n        }\n    }\n    return %hash;\n\
    }", "    my %histo;\n    $test =~ tr/a-z/A-Z/;", "    $test =~ s/\\s+//g;\n  \
    \  my %histo;\n    $test =~ s/(\\w+)/$1/g;\n    $test =~ s/(\\w+)\\s(\\w+)/$1$2/g;\n\
    \    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3/g;\n    $test =~ s/(\\w+)\\s(\\\
    w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4/g;\n    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\\
    w+)\\s(\\w+)/$1$2$3$4$5/g;\n    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\\
    s(\\w+)\\s(\\w+)/$1$2$3$4$5$6/g;\n    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\\
    w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7/g;\n    $test =~ s/(\\w+)\\s(\\\
    w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7$8/g;\n\
    \    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\\
    s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7$8$9/g;\n    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\\
    s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7$8$9$10/g;\n\
    \    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\\
    s(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7$8$9$10$11/g;\n    $test =~ s/(\\w+)\\\
    s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)/$1$2$3$4$5$6$7$8$9$10$11$12/g;\n\
    \    $test =~ s/(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\\
    s(\\w+)\\s(\\w+", "    my %histogram;\n    my @list = split /\\s+/, $test;\n \
    \   foreach my $word (@list) {\n        $histogram{$word}++;\n    }\n    %histogram\
    \ = sort { ($histogram{$b} <=> $histogram{$a}) }\n        grep (!$histogram{$_}++,\
    \ keys %histogram);\n    my %result;\n    foreach my $word (@list) {\n       \
    \ my $count = $histogram{$word};\n        $result{$word} = $count if $count >\
    \ 1;\n    }\n    return \\%result;\n}", "    if ($test eq '') {\n        return\
    \ {};\n    }", "    my %histogram;\n    for (split / /, $test) {\n        $histogram{$_}++;\n\
    \    }\n    return %histogram;\n}", '    my %counts;', "    return {} unless length($test);\n\
    \    $test =~ tr/ +/ /;\n    my %hash = map { $_ => 1 } split //, $test;\n   \
    \ return map { $_ => $hash{$_} };\n}", "    my($hash, $key, $max);\n    if ($test\
    \ =~ /^([a-z]*)( ([a-z]*))*$/) {\n\t$hash = $1;\n\t$max = $2;\n    } elsif ($test\
    \ =~ /^([a-z]*) ([a-z]*) ( ([a-z]*))*$/) {\n\t$hash = $1;\n\t$key = $2;\n\t$max\
    \ = $3;\n    } else {\n\t$hash = $test;\n\t$max = \"z\";\n    }\n    my(@result)\
    \ = ();\n    if ($test =~ /^([a-z]*) ([a-z]*) ([a-z]*)$/) {\n\tpush(@result,\n\
    \t    $1 x $2 x $3 x $4,\n\t    $1 x $2 x $3,\n\t    $1 x $2,\n\t    $1,\n\t \
    \   $hash);\n    }\n    return @result;\n}", '    my($h) = Hash::new();', "  \
    \  $test =~ tr/ / /;\n    my %hash;\n    my @letters;\n    my @counts;\n    for\
    \ my $letter (split //, $test) {\n        next unless $letter =~ m/^[a-z]$/i;\n\
    \        $hash{$letter}++;\n        push @letters, $letter;\n        push @counts,\
    \ $hash{$letter};\n    }\n    return wantarray ? @letters => {} : \\%hash;\n}",
  "    my @letters;\n    my %freq;", "    my %histogram;\n    my @tests = split(\"\
    \ \", $test);\n    for (@tests) {\n        my $letter = lc($_);\n        if (!$histogram{$letter})\
    \ {\n            $histogram{$letter} = 0;\n        }\n        $histogram{$letter}++;\n\
    \    }\n    return %histogram;\n}", "    if(!$test) {\n        return {};\n  \
    \  }\n    $test =~ s/\\s+//g;\n    my @letters;\n    my $count;\n    $count =\
    \ ();\n    $letters = ();\n    my @letterCount = ();\n    $letters{'a'} = 0;\n\
    \    $letters{'b'} = 0;\n    $letters{'c'} = 0;\n    foreach my $letter (split\
    \ //, $test) {\n        if(exists $letters{$letter}) {\n            $letters{$letter}++;\n\
    \            $count{$letter}++;\n        } else {\n            $letters{$letter}\
    \ = 1;\n            $count{$letter} = 1;\n            push @letters, $letter;\n\
    \        }\n    }\n    # Iterate through the letters to find out the letter with\
    \ the most\n    # occurrence in the test string.\n    foreach my $key (sort keys\
    \ %$count) {\n        if($count{$key} > $letterCount[0]) {\n            $letterCount[0]\
    \ = $count{$key};\n            $letters[0] = $key;\n        }\n    }\n    return\
    \ \\@letters;\n}", "    my($hash);\n    my($letter);\n    my($count);\n    my(@letters);",
  "    my %hash;\n    my $count = 0;\n    $hash{$_}++ for\n        $test\n       \
    \     =~ /^[a-z]+/gi;\n    return %hash if scalar(keys %hash) > 1;\n    return\
    \ %hash;\n}", "    my %result;\n    map {$result{$_} = $test->{$_}} keys %$test;\n\
    \    return \\%result;\n}", "    my %hash;\n    my = ();\n    for (split (\" \"\
    , $test)) {\n        $hash{$_}++;\n    }\n    foreach my $key (keys %hash) {\n\
    \        if ($hash{$key} > $max) {\n            $max = $hash{$key};\n        \
    \    $max_key = $key;\n        }\n        elsif ($hash{$key} < $max) {\n     \
    \       $max = $hash{$key};\n        }\n    }\n    if (keys %hash == 1) {\n  \
    \      return %hash;\n    }\n    else {\n        return $max_key => $max;\n  \
    \  }\n}", "    my %histogram;\n    my $testString = $test;", "    my(%h);\n  \
    \  my($max);\n    my(@letters);\n    my($letter) = ();\n    my($maxLetter) = ();",
  "    my(@histogram) = ({});\n    $test =~ tr/A-Z/a-z/;", "    \n    return map {\n\
    \        my ($key, $count) = @_;\n        $key => $count,\n    };\n}", "    my\
    \ $hash = {};\n    my ($letter, $count, $repeat) = (undef, undef, undef);\n  \
    \  while (length($test) > 0) {\n        ($letter, $count, $repeat) = my($letter,\
    \ $count, $repeat)\n            ? (split //, $test)\n            : (undef, undef,\
    \ 1);\n        ++$hash->{$letter} if defined($letter) && defined($count) && defined($repeat);\n\
    \        $test = (length($test) eq 0\n            ? ($letter, $count, $repeat)\n\
    \            : substr($test, 1)\n        );\n    }\n    return $hash;\n}", " \
    \   chomp $test;\n    $test .= \" \" if $test ne \"\";\n    my %h = ();\n    my\
    \ @words = split /\\s+/, $test;\n    foreach my $word (@words) {\n        foreach\
    \ my $letter (split //, $word) {\n            if (! exists $h{$letter}) {\n  \
    \              $h{$letter} = 1;\n            } else {\n                $h{$letter}++;\n\
    \            }\n        }\n    }\n    return %h;\n}", "    $test =~ s/\\s+//g;\n\
    \    my %counts;\n    my $pattern = qr{([a-zA-Z])};\n    $counts{lc($1)} = 1;\n\
    \    $test =~ s{^($pattern)}{$counts{$1} > 1 ? $counts{$1} : $counts{$1}+1}e;\n\
    \    return %counts;\n}", "    my($hash);\n    my($key);\n    my(@items);", " \
    \   return map { $_ => 1 } @{ $test = $test =~ m/^[a-cA-C]/ ? split (\" \", $test)\
    \ : map { $_ => 0 } };\n}", "    my %histogram;\n    my @letters = split /\\s+/,\
    \ $test;\n    my $letter;\n    my $count;\n    foreach my $letter (@letters) {\n\
    \        if (!$histogram{$letter}) {\n            $histogram{$letter} = 1;\n \
    \       }\n        else {\n            $histogram{$letter}++;\n        }\n   \
    \ }\n    foreach $letter (sort keys %histogram) {\n        $count = $histogram{$letter};\n\
    \        if ($count > 1) {\n            push @letters, $letter;\n        }\n \
    \       else {\n            $count--;\n        }\n        $histogram{$letter}\
    \ = $count;\n    }\n    return %histogram;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
