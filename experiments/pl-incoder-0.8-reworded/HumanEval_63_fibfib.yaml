name: HumanEval_63_fibfib
language: pl
prompt: "# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n# fibfib(0) == 0\n# fibfib(1) == 0\n# fibfib(2) ==\
  \ 1\n# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n# Please write a function\
  \ to efficiently compute the n-th element of the fibfib number sequence.\n# >>>\
  \ fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nsub fibfib {\n  \
  \  my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fibfib;\n\
  \        if(eq_deeply($candidate->(2),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(1),0)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),4))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),24))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),81))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),274))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(14),927))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($fibfib);\n    my($fib) = (-1);\n    for(my $i = 0; $i < $n;\
    \ $i++){\n        $fibfib = ($fibfib + $fib) + $fib;\n        $fib = ($fibfib\
    \ - 1) % $fibfib;\n    }\n    return $fibfib;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,math,performance,python\
    \ |>\n<| c |>\nThis takes ~4 seconds on my system; and I think you meant `return\
    \ $fibfib;` in the fibfib function.\n<|/ c |>\n<| a tags=algorithm,math,performance,python\
    \ |>\nYou need O(log(n)) time, which can be achieved using a binary search algorithm.\
    \ Assume n is a positive integer and that the initial condition is fibfib(n) ==\
    \ 0.\nThe algorithm will be as follows:\n<code>\nfibfib(n):\n  fib = 1;\n  i =\
    \ 1;\n  while i < n do\n    fib = fibfib(n-1) + fib;\n    i = i + 1;\n  end\n\
    \  return fib;\n</code>\nSo you just loop until your current number is less than\
    \ your number and then you know that the number belongs to fibonacci sequence\
    \ because its value is equal to the previous number multiplied by two.\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThe question is about \"efficiently computing the n-th\
    \ Fibonacci number using Python\" - which means without building the whole sequence.\n\
    <|/ c |>\n<| c |>\nNo, the question explicitly states the solution is O(n).\n\
    <|/ c |>\n<| c |>\nActually the solution I give is O(log(n)) because a binary\
    \ search algorithm will find the n-th number very quickly.\n<|/ c |>\n<| c |>\n\
    I don't think you can get the O(log n) solution without building the whole sequence...\n\
    <|/ c |>\n<| c |>\nYou are right, however my algorithm is still O(log(n))\n<|/\
    \ c |>\n<| a tags=algorithm,math,performance,python dscore=0 |>\nYou can do it\
    \ in O(logn) time using binary search to find the Nth Fibonacci number.  You don't\
    \ need to build the whole sequence.  It's not so much that it's inefficient to\
    \ do so, more that your solution needs to run in O(logn) time.\n<|/ a |>\n<| a\
    \ |>\n<code>\ndef fib(n):\n    if n == 0 or n == 1:\n        return n\n    return\
    \ fib(n-1) + fib(n-2)", "    my $prev = 0\n        if $n <= 1;", "    if($n ==\
    \ 0) { return 0; }\n    if($n == 1) { return 1; }\n    if($n == 2) { return 1;\
    \ }\n    if($n == 3) { return 2; }\n    my $sum = 0;\n    $sum = (fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3)) ;\n    return $sum;\n}", "    my($sum) = 0;\n\
    \    if ($n == 0) {\n        $sum = 0;\n    }\n    if ($n == 1) {\n        $sum\
    \ = 1;\n    }\n    if ($n == 2) {\n        $sum = 1;\n    }\n    if ($n <= 3)\
    \ {\n        $sum = $sum + $sum + $sum;\n    }\n    else {\n        $sum = $sum\
    \ + fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n    }\n    return $sum;\n}\n\
    </code>\n<|/ a tags=recursion,fibonacci,perl |>\n<| c |>\nOh, thank you. I did\
    \ go ahead and copy it verbatim into my code and the result was the same. Now\
    \ the problem must lie in the way the other code is running on the test data.\
    \ My other code has this loop that runs through the test data and prints out the\
    \ result to prove to the test data that it is correct: for (my $i = 0; $i <= $n;\
    \ $i++) {\n    print $fibfib($i), \"\\n\";\n}\n<|/ c |>\n<| c |>\nThis was a good\
    \ exercise in recursion :-)\n<|/ c |>\n<| c |>\n- If it was a good exercise in\
    \ recursion, the first thing you should be doing is refactoring your code. If\
    \ you don't understand why your code is slow or inefficient, then you won't know\
    \ if you should take it further or stop. Your code will be much easier to write\
    \ (and read) if you use recursion more often.\n<|/ c |>\n<| c |>\n- I haven't\
    \ had much experience with recursion and haven't learned any yet, so I thought\
    \ it would make more sense to learn it this way. My code actually is working correctly,\
    \ just not the test data. Thank you so much for the help!\n<|/ c |>\n<| c |>\n\
    : If you don't understand recursion, don't use it. Ask yourself: Do I need recursion\
    \ for what I want to do, and if so, why do I need it?\n<|/ c |>\n<| a tags=recursion,fibonacci,perl\
    \ |>\nMy problem was that I was using Fibonacci instead of FibFib. I realized\
    \ this after I posted the above solution and then edited my code and it fixed\
    \ the problem. Thanks everyone for the help. Here is the final code:\n<code>",
  "    \n    if ($n < 1) {\n        return 0;\n    }\n    if ($n == 1) {\n       \
    \ return 0;\n    }\n    return fibfib($n-2) + fibfib($n-1);\n}", "    my $fibfib;\n\
    \    my $fibfib_tmp;\n    $fibfib_tmp = fibfib($n - 1) + (fibfib($n - 2) + (fibfib($n\
    \ - 3)));\n    if ($fibfib_tmp == 0) {\n        $fibfib = 0;\n    } else {\n \
    \       $fibfib = $fibfib_tmp;\n    }\n    return $fibfib;\n}\n</code>\n<|/ a\
    \ tags=algorithm,fibonacci,big-o,python,time-complexity dscore=4 |>\n<| c |>\n\
    +1 for an efficient implementation of fibfib() -- though I'm not convinced that\
    \ the OP really needs it.\n<|/ c |>\n<| c |>\nI like it!  I learned that Big-O\
    \ notation is used to describe how an algorithm runs, not the actual time complexity.\
    \  Thanks!\n<|/ c |>\n<| c |>\nThanks for the answer! Very clearly written. Just\
    \ two questions: 1) Does fibfib(n) have to be computed multiple times for the\
    \ same n? 2) What is the purpose of the \"&\" in \"&fibfib($n - 1) &\"?\n<|/ c\
    \ |>\n<| c |>\nNo, `fibfib(n)` does not need to be computed multiple times. It\
    \ is recomputed every time it is called, so it is O(n). `&` is bitwise AND (returns\
    \ the bits that are 1 in both numbers). Since `fibfib($n - 1)` is called twice\
    \ for `n` > 0, the computation is done twice per `n`.\n<|/ c |>\n<| c |>\nThe\
    \ `&` operator is a [bitwise AND](http://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_AND_.28.E2.8B.88.28)\
    \ operator.\n<|/ c |>\n<| a dscore=4 |>\nOne can compute in O(n) time for n values\
    \ that add up to 1, by using a lookup table.\n<code>\ndef fib(n):\n    if n ==\
    \ 1: return 0\n    if n == 2: return 1\n    lookup = fib.lookup\n    if n not\
    \ in lookup: raise IndexError('fib() called with unknown n')\n    return lookup[n]",
  "    my @numbers = ();\n    my $fibfib = 0;\n    for ($fibfib; $fibfib<$n; $fibfib++)\
    \ {\n        push(@numbers,$fibfib);\n    }\n    return $numbers[$n-1];\n}", " \
    \   my($a,$b,$c) = (0,1);\n    my($nfib);\n    my($i,$fib);\n    if ( $n == 0\
    \ ) {\n\t$nfib = $a;\n    }\n    else {\n\tfor ( $i = 0 ; $i -lt $n ; $i++ ) {\n\
    \t    $fib = $a + $b + $c;\n\t    $a = $b;\n\t    $b = $c;\n\t    $c = $fib;\n\
    \t}\n\t$nfib = $c;\n    }\n    return $nfib;\n}", "    $n -= 2;\n    if ($n <\
    \ 0) return 0;\n    if ($n == 0 || $n == 3 ) return 1;\n    $fibfib($n-2) + $fibfib($n-3)\
    \ + $fibfib($n-1);\n}", "    return $n if $n <= 3;\n    return fibfib($n-1) +\
    \ fibfib($n-2) + fibfib($n-3);\n}", "    if ($n <= 0) {\n\t0\n    } elsif ($n\
    \ == 1) {\n\t0\n    } elsif ($n == 2) {\n\t1\n    } elsif ($n == 3) {\n\t1\n \
    \   } else {\n\tfibfib($n-1) + fibfib($n-2) + fibfib($n-3)\n    }\n}", "    my\
    \ $f = 0;\n    my $g = 1;\n    while ($n > 1) {\n        $f = $g + $f;\n     \
    \   $g = $g + $g;\n        $n--;\n    }\n    $f;\n}", "    if ($n eq 0) {\n  \
    \      return 0;\n    }\n    if ($n eq 1) {\n        return 0;\n    }\n    if\
    \ ($n eq 2) {\n        return 1;\n    }\n    if ($n > 0) {\n        return fibfib($n\
    \ - 1) + fibfib($n - 2) + fibfib($n - 3);\n    }\n    else {\n        return 0;\n\
    \    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nA couple of points: 1) `@fibfib`\
    \ is not an array, but a list. 2) You don't need a subroutine to calculate fibfib.\
    \ Just use the fact that `fibfib(n) = fibfib(n-1) + fibfib(n-2)`.\n<|/ c |>\n\
    <| c |>\nYeah, it's been ages since I wrote a C program, but as far as I know\
    \ you can't do math like that in C? Or am I wrong? That was my impression. Also,\
    \ I'm still pretty new to this site, so I apologize if I did something wrong with\
    \ my post.\n<|/ c |>\n<| c |>\nThanks for the clarification, I'm pretty new to\
    \ C. I guess I just misremembered how arrays are defined and used.\n<|/ c |>\n\
    <| c |>\nArrays aren't a primitive type in C; they are a type of data structure.\
    \ `@fibfib` is an array whose elements are pointers to functions. A C function\
    \ declaration is not exactly the same as `fibfib` though.\n<|/ c |>\n<| c |>\n\
    That's what I was thinking. I thought fibfib is a C function declared in a .pl\
    \ file, but I guess I'm just missing something really basic. Thanks for the clarification.\n\
    <|/ c |>\n<| a tags=recursion,fibonacci,perl,arrays |>\nThe Fibonacci Sequence\
    \ is defined as:\n<code>\nF(n) = F(n-1) + F(n-2) + F(n-3)\n</code>\nSo what you're\
    \ really wanting is just the nth element of the sequence. So let's try that:\n\
    <code>", "    return $fibfib{$n} if ($fibfib{$n}++);\n    return $fibfib{$n} =\
    \ 0;\n}", '    return 0 unless $n && $n <= 10;', "    my($fib);\n    my(@fibfib);",
  "    if ($n <= 0){\n        return 0;\n    }\n    if ($n <= 2){\n        return\
    \ 0;\n    }\n    if ($n <= 3){\n        return 1;\n    }\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n}", "    if ($n <= 2) {\n        return 0;\n\
    \    }\n    if ($n == 3) {\n        return 1;\n    }\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n}", "    if ($n <= 1) {\n        return 0;\n\
    \    } else {\n        return fibfib($n-1) + fibfib($n-2)+ fibfib($n-3) ;\n  \
    \  }\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nVery nice answer. I would just suggest\
    \ using $_ for your loop variable. Otherwise it looks odd and doesn't indicate\
    \ that you intend to use it for iteration.\n<|/ c |>\n<| a |>\n<code>\n$FibFibNum\
    \ = (1,1);\nfor ($i = 2; $i <= $number; $i++) {\n    $FibFibNum = $FibFibNum->(3,2);\n\
    }\n</code>\n<|/ a dscore=4 tags=perl,fibonacci,fibonacci-heap |>\n<| c |>\nThis\
    \ solution has the best time complexity, O(log n).\n<|/ c |>\n<| c |>\n$FibFibNum\
    \ = (1,1); $FibFibNum->(3,2); doesn't seem to work. Have to assign it to a new\
    \ variable.\n<|/ c |>\n<| c |>\nYou are right.  I changed it to $newFibFibNum\
    \ = $FibFibNum->(3,2);  and now it works.\n<|/ c |>\n<| a tags=perl,fibonacci,fibonacci-heap\
    \ dscore=3 |>\nThe simple recursive version below is an O(2^n) solution that does\
    \ not require an external package like Math::Fibonacci.\n<code>", "    if ($n\
    \ =~ /^(-?\\d+)$/) {\n\treturn 0 if $n =~ /^0$/;\n\treturn 0 if $n =~ /^(-?\\\
    d+)$/;\n\treturn 1 if $n =~ /^1$/;\n\treturn (fibfib($n-1) + fibfib($n-2) + fibfib($n-3));\n\
    \    }\n}", "    return 0 if $n <= 0;\n    return 1 if ($n & 1);\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n}\n</cell>\n<cell>", "    if($n <= 0) {\n  \
    \      $fibfib_memo{$n} = 0;\n        return 0;\n    }\n    return $fibfib_memo{$n}\n\
    \        if $fibfib_memo{$n};\n    $fibfib_memo{$n} = fibfib($n-1) + fibfib($n-2)\
    \ + fibfib($n-3);\n    return $fibfib_memo{$n};\n}", "    my $result;\n    if($n\
    \ < 1) {\n        $result = 0;\n    }\n    elsif($n == 1) {\n        $result =\
    \ 0;\n    }\n    elsif($n == 2) {\n        $result = 1;\n    }\n    else {\n \
    \       $result = fibfib($n-1) + fibfib($n-2);\n    }\n    return $result;\n}",
  "    if (defined $n && $n > 0) {\n        $fibfib[$_] = fibfib($_-1) + fibfib($_-2)\
    \ + fibfib($_-3);\n    }\n    return $fibfib[$n];\n}", "    my $fibfib = 0;\n\
    \    my $fibfib1 = 1;\n    my $fibfib2 = 1;\n    my $fibfib3 = 1;\n    \n    for(my\
    \ $count = 1; $count <= $n; $count++) {\n        $fibfib += $fibfib1;\n      \
    \  $fibfib2 += $fibfib1;\n        $fibfib3 += $fibfib1;\n        $fibfib1 = $fibfib2;\n\
    \        $fibfib2 = $fibfib3;\n        $fibfib3 = $fibfib;\n    }\n    return\
    \ $fibfib3;\n}", "    return 0 if($n < 1);\n    return 1 if($n == 1);\n    return\
    \ $fibfib($n-1) + $fibfib($n-2)+ $fibfib($n-3);\n}", "    my($fibfib);\n    $fibfib\
    \ = 0;\n    if ($n == 0) {\n        return 0;\n    }\n    if ($n == 1) {\n   \
    \     return 0;\n    }\n    my $fibfib1 = fibfib($n - 1);\n    $fibfib = $fibfib1\
    \ + $fibfib2;\n    return $fibfib;\n}\n</code>\n<|/ a tags=numbers,sequence,fibonacci,algorithm,big-o\
    \ |>\n<| c |>\nI see this as being the same as the last question, except the function\
    \ name has changed. This one has changed name.\n<|/ c |>\n<| c |>\nThe name of\
    \ the function is `fibfib`, which matches the `fibfib(n-2)` formula.\n<|/ c |>\n\
    <| c |>\nI apologize for not having seen your answer earlier, but I have been\
    \ trying to understand this and have been unable to figure out your answer with\
    \ my limited understanding. Could you possibly explain how this code is doing\
    \ what it is?\n<|/ c |>\n<| a dscore=1 |>\nThe other answers give a solution that\
    \ involves memoization, which can be a good approach if you're concerned about\
    \ speed but have good enough memory. \nA solution that uses recursion to solve\
    \ the problem will run in O(2^n) time but will require exponential memory.\nA\
    \ simpler solution which runs very quickly (O(n)) would be the following:\n<code>\n\
    int fib(int n) {\n    int res = 0;", "    return $fibfib if $n eq 0;\n    return\
    \ fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}", "    my $a = $n;\n    $a++\
    \ while $a < $n;\n    return $a;\n}", "    my $fibfib = 0;\n    for my $i (0 ..\
    \ $n) {\n        my $fibfib_i = $fibfib;\n        $fibfib += $fibfib_i;\n    }\n\
    \    return $fibfib;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe last paragraph\
    \ of your answer says that you cannot calculate fibfib(0) - the code you wrote\
    \ there doesn't include it, so I'm not sure how this was helpful. Maybe I'm missing\
    \ something here...\n<|/ c |>\n<| c |>\n- I added a section at the end about fibfib(0)\n\
    <|/ c |>\n<| c |>\nfibfib(0) and fibfib(1) are both 1 so fibfib(n-1) is already\
    \ 1, so fibfib(n-2) is 1.\n<|/ c |>\n<| c |>\n- fibfib(n) is the sum of fibfib(n-1)\
    \ and fibfib(n-2) which is fibfib(n-2) + fibfib(n-3) which is fibfib(n-3).\n<|/\
    \ c |>\n<| a tags=recursion,perl |>\n<code>", "    if($n == 0) {\n\treturn 0;\n\
    \    } elsif($n == 1) {\n\treturn 0;\n    } elsif($n == 2) {\n\treturn 1;\n  \
    \  } else {\n\treturn fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n    }\n}",
  "    my($result,$fibfibnum);\n    my(@fibfibnums);", "    if ($n < 2) {\n      \
    \  return 0;\n    }\n    else {\n        return fibfib($n-1) + fibfib($n-2) +\
    \ fibfib($n-3);\n    }\n}", "    if($n >= 2) {\n        return fibfib($n-1) +\
    \ fibfib($n-2);\n    } else {\n        return 0;\n    }\n}", "    my $fibfib =\
    \ 0;\n    if ($n > 0) {\n        $fibfib = fibfib($n-1) + fibfib($n-2)+ fibfib($n-3);\n\
    \    }\n    return $fibfib;\n}", "    if (! defined $n)\n    {\n\t$n = 1;\n  \
    \  }\n    elsif ($n < 1)\n    {\n\t$n = 0;\n    }\n    elsif ($n == 0)\n    {\n\
    \treturn 0;\n    }\n    elsif ($n == 1)\n    {\n\treturn 0;\n    }\n    else\n\
    \    {\n\treturn fibfib($n - 1) + fibfib($n - 2) + fibfib($n - 3);\n    }\n}\n\
    </cell>\n<cell>", "    return 0 if $n <= 1;\n    return $n if $n == 2;\n    $fibfib($n\
    \ - 1) + $fibfib($n - 2) + $fibfib($n - 3);\n}", "    $n++ if $n == 0;\n    $fibfib{$n}\
    \ = $fibfib{$n-1} + $fibfib{$n-2} + $fibfib{$n-3};\n    return $fibfib{$n};\n}",
  "    my(@result) = ();\n    \n    my(@fibfib) = ();\n    push(@fibfib, 0);\n   \
    \ push(@fibfib, 1);\n    push(@fibfib, 1);\n    push(@fibfib, 1);\n    push(@fibfib,\
    \ 1);\n    push(@fibfib, 1);\n    push(@fibfib, 2);\n    \n    while($n>0) {\n\
    \        my $temp = pop(@fibfib);\n        push(@result,$temp);\n        $n--;\n\
    \    }\n    return $result[0];\n}", "    return $fibfib[$n] if $fibfib[$n];\n\
    \    return $fibfib[$n] = $n+1 unless $n;\n    return fibfib($n-1) + fibfib($n-2);\n\
    }", "    $n == 0 || $n == 1 \n        ? 0 \n        : $n == 2 \n        ? 1 \n\
    \        : $n > 2 \n        ? fibfib($n-1) + fibfib($n-2) + fibfib($n-3)\n   \
    \     : 0;\n}", "    my $fibfib = ( $n == 0) \n                ? 0 \n        \
    \        : ( $n == 1 )\n                    ? 0\n                    : ( $n ==\
    \ 2 )\n                        ? 1\n                        : fibfib( $n - 1 )\
    \ + fibfib( $n - 2 ) + fibfib( $n - 3 );\n}", "    my $fibfib_sequence = $fibfib[$n];\n\
    \    return $fibfib_sequence;\n}", "    my $fib;\n    $fib = 0;\n    my $fibsum\
    \ = 0;\n    my $i = 1;\n    while ($i <= $n) {\n        $fibsum = $fibsum + $i;\n\
    \        $fib++;\n        $fib += $fibsum;\n        $i++;\n    }\n    return $fib;\n\
    }", "    my $n2 = $n - 2;\n    return $n2 if $n2 > 0;\n    my $n21 = $n2 + 1;\n\
    \    return $n21 if $n21 > $n;\n    return $n21 if $n <= $n21;\n    return $n;\n\
    }", "    return $n < 3 ? 0 : $n < 9 ? 1 : ($n - 4) + fibfib($n - 3);\n}\n</code>\n\
    <|/ a tags=math,fibonacci,recursion,memoization,python |>\n<| c |>\nThe OP seems\
    \ to want a solution in Python\n<|/ c |>\n<| c |>\nNope, I asked for a solution\
    \ in Python.\n<|/ c |>\n<| a dscore=5 |>\nSince you asked for a solution in Python,\
    \ here is one with memoization:\n<code>\ndef memoize(f):\n    \"\"\" Memoization\
    \ decorator for a function taking a single argument,\n        caching all calls\
    \ with that argument and returning the cached result\n        whenever called\
    \ with that argument \"\"\"\n    class memodict(dict):\n        def __missing__(self,\
    \ key):\n            ret = self[key] = f(key)\n            return ret\n    return\
    \ memodict().__getitem__", "    $$n == 0 and return 0;\n    $$n == 1 and return\
    \ 0;\n    fibfib($n-1) + fibfib($n-2) + fibfib($n-3); \n}\n</code>\n<|/ a dscore=0\
    \ tags=recursion,perl,dynamic-programming |>\n<| c |>\nYes, this is very cool.\
    \ Can you comment the code a little more to explain how it works and why it's\
    \ so good? :)\n<|/ c |>\n<| c |>\nThis is exactly how I solved it.  I haven't\
    \ gotten around to explaining how it works yet.\n<|/ c |>\n<| a tags=recursion,perl,dynamic-programming\
    \ |>\n<code>", "    if (! defined($n)) {\n        carp \"fibfib: undefined argument!\"\
    ;\n        return;\n    }\n    my $fibnum = 1;\n    my $fibfib;\n    while ($fibnum\
    \ < $n) {\n        $fibfib = ($fibfib + $fibfib + $fibfib);\n        $fibnum++;\n\
    \    }\n    return $fibfib;\n}", "    my $fibfib_num = 0;\n    for my $i (0..$n)\
    \ {\n        $fibfib_num += $fibfib($i) + $fibfib($i-1) + $fibfib($i-2);\n   \
    \ }\n    return $fibfib_num;\n}", "    \n    return $fibfib{$n} if exists $fibfib{$n};\n\
    \    \n    $fibfib{$n} = fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n    \n \
    \   return $fibfib{$n};\n}", "    my($fibfib);\n    if ($n>$#_) { $fibfib = $#_;\
    \ }\n    else { $fibfib=0; for ($i=0; $i<$n; $i++) { $fibfib +=  ($_[$i] + $_[$i+1]\
    \ + $_[$i+2]); }} return($fibfib);\n}\n</code>\n<|/ a tags=python,math,fibonacci,arrays\
    \ |>\n<| a dscore=3 |>\nThe question seems to be asking you to implement fibonacci\
    \ without recursion. Recursion is often a lot easier to use and more performant,\
    \ so I assume this is an exercise for teaching recursion (as opposed to solving\
    \ some real problems).\nIf this were a real problem to solve, I would go for the\
    \ recursive approach. It's much easier to understand and debug, and it isn't much\
    \ slower.\nIf it's an exercise in recursion, I would go for the more classic \"\
    iterative\" approach, which is also faster, easier to understand, and (I think)\
    \ easier to debug:\n<code>\ndef fib(n):\n    a, b = 0, 1\n    while b < n:\n \
    \       a, b = b, a + b\n    return a\n</code>\nIf you need performance, you can\
    \ use memoization, but that's probably not what you want to do, as this is actually\
    \ quite an interesting problem to solve.\n<|/ a tags=python,math,fibonacci,arrays\
    \ |>\n<| a dscore=1 |>\nIn Python, you can use functools.lru_cache to memoize\
    \ Fibonacci function:\n<code>\nfrom functools import lru_cache(maxsize=None)\n\
    def fibonacci(n):\n    if n < 3:\n        return n\n    return fibonacci(n - 1)\
    \ + fibonacci(n - 2)\n</code>\nThis makes fibonacci(5) returns 5 (instead of cache.get(5,\
    \ 0) which would raise KeyError on second call), but also works with fibonacci(12),\
    \ which returns 25 (instead of cache.get(12, 1).\nSee https://docs.python.org/3.6/library/functools.html#functools.lru_cache\
    \ for more details.\n<|/ a tags=python,math,fibonacci,arrays |>\n<| a |>\nAs far\
    \ as i know, Python does not have a built-in module for this.  But you can write\
    \ your own using recursion like this:\n<code>\ndef fib(n): \n    return fib(n-1)\
    \ + fib(n-2) \n</code>\nIf you were to write your own module for this, then you\
    \ can create a cache of previous calls.  You can do that by storing your previous\
    \ results in a dict.  You will want to make sure to keep this cache separate from\
    \ the original functions you write and ", "    return 0 if $n <= 0;\n    return\
    \ $fibfib($n-2) + $fibfib($n-3) if $n >= 3;\n    return $fibfib($n-2) + $fibfib($n-3)\n\
    \        if $fibfib($n-2)\n        + $fibfib($n-3)\n        + $fibfib($n-4)\n\
    \        == 0;\n    return $fibfib($n-2) + $fibfib($n-3) + $fibfib($n-4) + $fibfib($n-1)\n\
    \        if $n >= 5;\n    return $fibfib($n-2) + $fibfib($n-3) + $fibfib($n-4)\n\
    \        + $fibfib($n-5) + $fibfib($n-6)\n        + $fibfib($n-7) + $fibfib($n-8)\n\
    \        + $fibfib($n-9);\n}", "    return 0 unless ($n);\n    my $fib;\n    if\
    \ ($n == 0) {\n        $fib = 0;\n    }\n    elsif ($n == 1) {\n        $fib =\
    \ 0;\n    }\n    else {\n        $fib = 1+fibfib($n-2);\n    }\n    return $fib;\n\
    }", "    if($n <= 0) {\n\tmy $fibfib = 0;\n\treturn $fibfib;\n    } elsif($n ==\
    \ 1) {\n\tmy $fibfib = 0;\n\treturn $fibfib;\n    } elsif($n == 2) {\n\tmy $fibfib\
    \ = 0;\n\treturn $fibfib;\n    } elsif($n <= 3) {\n\tmy $fibfib = 1;\n\treturn\
    \ $fibfib;\n    } else {\n\tmy $fibfib = (fibfib($n-1) + fibfib($n-2) + fibfib($n-3));\n\
    \treturn $fibfib;\n    }\n}\n__END__", "    return 0 if $n < 0;\n    $n += 2;\n\
    \    if ($n <= 4) {\n        return $n;\n    }\n    my $fib;\n    for my $i (1\
    \ .. $n) {\n        $fib = ($fib + $i) % $i;\n    }\n    return $fib;\n}", " \
    \   return 0 if ($n eq 0);\n    return 1 if ($n eq 1);\n    return 1 if ($n eq\
    \ 2);\n    return 1 if ($n <= 3);\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3)\
    \ if ($n>3);\n}", "    my($fibfib);\n    if ( $n == 0 ) {\n        $fibfib = 0;\n\
    \    }\n    elsif ( $n == 1 ) {\n        $fibfib = 0;\n    }\n    elsif ( $n ==\
    \ 2 ) {\n        $fibfib = 1;\n    }\n    elsif ( $n == 3 ) {\n        $fibfib\
    \ = 1;\n    }\n    elsif ( $n == 4 ) {\n        $fibfib = 1;\n    }\n    elsif\
    \ ( $n == 5 ) {\n        $fibfib = 4;\n    }\n    elsif ( $n == 6 ) {\n      \
    \  $fibfib = 5;\n    }\n    elsif ( $n == 7 ) {\n        $fibfib = 8;\n    }\n\
    \    elsif ( $n == 8 ) {\n        $fibfib = 9;\n    }\n    elsif ( $n == 9 ) {\n\
    \        $fibfib = 12;\n    }\n    elsif ( $n == 10 ) {\n        $fibfib = 13;\n\
    \    }\n    elsif ( $n == 11 ) {\n        $fibfib = 14;\n    }\n    elsif ( $n\
    \ == 12 ) {\n        $fibfib = 15;\n    }\n    elsif ( $n == 13 ) {\n        $fibfib\
    \ = 6;\n    }\n    elsif ( $n == 14 ) {\n        $fibfib = 6;\n    }\n    elsif\
    \ ( $n == 15 ) {\n        $fibfib = 9;\n    }\n    elsif ( $n == 16 ) {\n    \
    \    $fibfib = 12;\n    }\n    elsif ( $n == 17 ) {\n        $fibfib = 11;\n \
    \   }\n    elsif ( $n == 18 ) {\n        $fibfib = 9;\n    }\n    elsif ( $n ==\
    \ 19 ) {\n        $fibfib = 12;\n    }\n    elsif ( $n == 20 ) {\n        $fibfib\
    \ = 13;\n    }\n    elsif ( $n == 21 ) {\n        $fibfib = 15;\n    }\n    elsif\
    \ ( $n == 22 ) {\n        $fibfib = 10;\n    }\n    elsif ( $n == 23 ) {\n   \
    \     $fibfib = 12;\n    }\n    elsif ( $n == 24 ) {\n        $fibfib = 13;\n\
    \    }\n    return $fibfib;\n}", "    return $n if $n <= 0;\n    if ($n <= 1)\
    \ {\n\treturn 0;\n    }\n    if ($n <= 2) {\n\treturn 1;\n    }\n    if ($n <=\
    \ 3) {\n\treturn 2;\n    }\n    return fibfib($n-1) + fibfib($n-2)+ fibfib($n-3);\n\
    }", '    my $fibfib;', "    my @fibfib;\n    push @fibfib, $fibfib[$_] if $n<=0;\n\
    \    push @fibfib, [@fibfib[$_-1],$fibfib[$_-1],$fibfib[$_-2]] if $n>=1;\n   \
    \ return @fibfib[$n-1];\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI doubt that\
    \ you're going to do better than the recursive `fibfib` subroutine.  What you\
    \ are doing there is basically building the entire array for n = 1 through 5.\
    \  For n = 6 you build it all up.  It's not really all that different than what\
    \ you are doing, except that the stack memory used by each iteration is smaller.\n\
    <|/ c |>\n<| c |>\nMy bad. I misread the question (I thought you were trying to\
    \ build fib numbers of length n or larger, not the fib numbers themselves). I'm\
    \ going to leave my answer here anyway in case it's useful to someone else who\
    \ comes across it.\n<|/ c |>\n<| c |>\n+1 for using a hash to avoid recursion.\
    \  The key point is to use a stack to avoid recursion.  See my answer below.\n\
    <|/ c |>\n<| c |>\nWell, the key point is to use a stack to avoid recursion. See\
    \ my answer below.\n<|/ c |>\n<| a tags=algorithm,fibonacci,c,arrays dscore=1\
    \ |>\nIt's funny, because I had the same homework assignment today. The assignment\
    \ was about finding out whether a number was divisible by any of the numbers from\
    \ 0 to n-1 modulo n. I've done this before, but I never thought of doing it this\
    \ way. Here is an implementation:\n<code>", "    if ( $n <= 0 ) {\n        return\
    \ 0;\n    }\n    if ( $n == 1 ) {\n        return 0;\n    }\n    if ( $n == 2\
    \ ) {\n        return 1;\n    }\n    my $x = fibfib($n-1);\n    my $y = fibfib($n-2);\n\
    \    my $z = fibfib($n-3);\n    return $x + $y + $z;\n}", "    my $num = 0;\n\
    \    my $fibfib = [0,1];\n    \n    while($n < $#fibfib) {\n        $fibfib[$n]\
    \ = $fibfib[$n-1] + $fibfib[$n-2];\n        $num += $fibfib[$n];\n        $n -=\
    \ 1;\n    }\n    return $num;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is\
    \ not the most elegant answer but it works well\n<code>\nfunction fibfib($n)\n\
    {\n    if( $n == 0 ) {\n        return 0;\n    }\n    if( $n == 1 ) {\n      \
    \  return 1;\n    }\n    return fibfib($n-1) + fibfib($n-2);\n}\n</code>\n<|/\
    \ a tags=recursion,fibonacci,python,algorithm |>\n<| a dscore=0 |>\n<code>\ndef\
    \ fibfib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return\
    \ 1\n    else:\n        return fibfib(n-1) + fibfib(n-2)\n</code>\n<|/ a tags=recursion,fibonacci,python,algorithm\
    \ |>\n<| c |>\nCould you please elaborate on why this code is better than the\
    \ other answers?\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndef fibfib(n):\n  fibs =\
    \ [0, 1]\n  while fibs[-1] < n:\n    fibs = fibs + [fibs[-1]+fibs[-2]]\n  return\
    \ fibs[-1]", "    my $fib;\n    if ($n <= 3) {\n        $fib = 0;\n    }\n   \
    \ elsif ($n <= 7) {\n        $fib = 1;\n    }\n    else {\n        $fib = fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n    }\n    return $fib;\n}", "    my $result\
    \ = $n == 0 ? 0 : ($n == 1 ? 1 : fibfib($n - 1) + fibfib($n - 2) + fibfib($n -\
    \ 3));\n    return $result;\n}", "    my @fib;\n    my $i=$n;\n    while ($i)\
    \ { push @fib,$fib[$i%$#fib]+$i%$#fib }\n    return @fib[$n%$#fib];\n}\n1", " \
    \   my $fibfib = 0;\n    for my $i (1 .. $n) {\n        $fibfib +=$i;\n    }\n\
    \    return $fibfib;\n}", "    if($n <= 0) {\n        return 0;\n    }\n    if($n\
    \ <= 2) {\n        return $n;\n    }\n    return fibfib($n - 1) + fibfib($n -\
    \ 2) + fibfib($n - 3);\n}\n</code>\n<|/ q tags=factorial,recursion,algorithm,math,fibonacci\
    \ |>\n<| c |>\nDid you mean to say \"the *first* element\" instead of \"the second\
    \ element\"?\n<|/ c |>\n<| c |>\nI don't think this is an algorithmic problem.\
    \ It is a question about how to approach a problem using recursion. Why are you\
    \ trying to do this with recursion?\n<|/ c |>\n<| c |>\n: No, I mean the second\
    \ element.  I will correct that typo now.\n<|/ c |>\n<| c |>\n: I'm doing this\
    \ as a learning exercise.  I'm trying to learn recursion.  I thought this would\
    \ be a good place to start.\n<|/ c |>\n<| c |>\nThat is very interesting.  I have\
    \ never seen an algorithm that performs recursion like this before.\n<|/ c |>\n\
    <| a |>\nThe first step would be to think about how to compute the nth element\
    \ of the Fibonacci sequence recursively.\nThe nth element of the Fibonacci sequence\
    \ is the sum of two of the previous Fibonacci numbers:\n<code>\nfibonacci(n) =\
    \ fibonacci(n-2) + fibonacci(n-1)\n</code>\nLet's consider the first few numbers\
    \ (0 and 1):\n<code>\nfibonacci(0) = 0\nfibonacci(1) = 1\n</code>\nThe next two\
    \ numbers are:\n<code>\nfibonacci(2) = fibonacci(1-1) + fibonacci(1-0)\nfibonacci(3)\
    \ = fibonacci(2-2) + fibonacci(2-0)\nfibonacci(4) = fibonacci(3-2) + fibonacci(3-0)\n\
    fibonacci(5) = fibonacci(4-2) + fibonacci(4-0)\nfibonacci(6) = fibonacci(5-2)\
    \ + fibonacci(5-0)\nfibonacci(7) = fibonacci(6-2) + fibonacci(6-0)\nfibonacci(8)\
    \ = fibonacci(7-2) + fibonacci(7-0)\n</code>\nThis continues until you get to\
    \ the nth number of the sequence.  The base cases are:\n<code>\nfibonac", "  \
    \  if ($n <= 1) {\n        return 0;\n    }\n    elsif ($n == 2) {\n        return\
    \ 1;\n    }\n    elsif ($n == 3) {\n        return 2;\n    }\n    else {\n   \
    \     return fibfib($n - 1) + fibfib($n - 2) + fibfib($n - 3);\n    }\n}", " \
    \   return 0 if ($n <= 0);\n    return 0 if ($n == 1);\n    return 1 if ($n ==\
    \ 2);\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}", "    my $result\
    \ = $fibfib($n-1);\n    my $result = $result + $fibfib($n-2);\n    my $result\
    \ = $result + $fibfib($n-3);\n    return $result;\n}", "    my($n) = ($n<=0?0:$n);\n\
    \    my $fibfib = 0;\n    for ($n; $n>1; $n--) {\n        $fibfib += ($n>2?$n-2:$n);\n\
    \    }\n    return $fibfib;\n}\n</code>\n<|/ a tags=factorial,python,algorithm,fibonacci\
    \ |>\n<| c |>\nIt seems to me that you would have more value if you included *why*\
    \ this code works. It seems more helpful than just copy-pasting someone else's\
    \ code.\n<|/ c |>\n<| a |>\nHere's my implementation:\n<code>\ndef fibonacci(n):\n\
    \    fib = 0\n    for i in range(n):\n        fib += 1 if i <= 2 else fib + 2\n\
    \    return fib", "    if( $n <= 0 ) {\n\treturn 0;\n    } elsif( $n == 1 ) {\n\
    \treturn 0;\n    } else {\n\treturn fibfib($n-2) + fibfib($n-1);\n    }\n}", " \
    \   if ($n <= 0) {\n        return 0;\n    }\n    if ($n == 1) {\n        return\
    \ 0;\n    }\n    if ($n == 2) {\n        return 1;\n    }\n    my($a) = fibfib($n-2);\n\
    \    my($b) = fibfib($n-3);\n    my($c) = fibfib($n-1);\n    return $a + $b +\
    \ $c;\n}", "    if ( $n == 0 ) {\n\treturn 0;\n    }\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n}", "    my $fibfib;\n    my $nfibfib = 0;\n\
    \    while ($n != 0) {\n        $nfibfib += $n--;\n        $fibfib += $nfibfib;\n\
    \    }\n    return $fibfib;\n}\n</cell>\n<cell>\n%%javascript\n<!-- Write your\
    \ JavaScript code here -->\nalert('Your javascript code here');\n</cell>\n<cell>",
  "    if ($n < 0) {\n\t&fibfib(-$n);\n    }\n    elsif ($n <= 0) {\n\treturn 0;\n\
    \    }\n    elsif ($n == 1) {\n\treturn 0;\n    }\n    elsif ($n == 2) {\n\treturn\
    \ 1;\n    }\n    elsif ($n == 3) {\n\treturn 1;\n    }\n    elsif ($n == 4) {\n\
    \treturn 1;\n    }\n    elsif ($n == 5) {\n\treturn 2;\n    }\n    elsif ($n ==\
    \ 6) {\n\treturn 2;\n    }\n    elsif ($n == 7) {\n\treturn 3;\n    }\n    elsif\
    \ ($n == 8) {\n\treturn 4;\n    }\n    else {\n\treturn fibfib($n-1) + fibfib($n-2)+\
    \ fibfib($n-3);\n    }\n}", "    return $n if $n < 0;\n    return $n if $n ==\
    \ 0;\n    return $n if $n <= 3;\n    return $fibfib($n-1) + $fibfib($n-2)+ $fibfib($n-3);\n\
    }", "    if ($n eq 0) {\n\treturn 0;\n    }\n    if ($n eq 1) {\n\treturn 0;\n\
    \    }\n    if ($n eq 2) {\n\treturn 1;\n    }\n    if ($n eq 3) {\n\treturn 1;\n\
    \    }\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}\n</code>\nThe\
    \ algorithm is simple but somehow it seems that it is not the most efficient one.\
    \ It would be a shame if the program takes too much time to compute the result,\
    \ since there could still be a faster approach.\n<|/ a dscore=0 |>\n<| a tags=fibonacci,algorithm,python\
    \ |>\nFor a solution that uses one pass through the array without recursion, you\
    \ could keep a running total of the sequence and use an offset to know where to\
    \ start the next iteration:\n<code>\n>>> fibfib(0, start=0)\n0\n>>> fibfib(1,\
    \ start=0)\n0\n>>> fibfib(2, start=0)\n1\n>>> fibfib(3, start=0)\n1\n>>> fibfib(4,\
    \ start=0)\n1\n>>> fibfib(5, start=0)\n4\n>>> fibfib(6, start=0)\n7\n>>> fibfib(7,\
    \ start=0)\n13\n>>> fibfib(8, start=0)\n21\n>>> fibfib(9, start=0)\n34\n>>> fibfib(10,\
    \ start=0)\n55\n>>> fibfib(11, start=0)\n89\n>>> fibfib(0, start=1)\n1\n>>> fibfib(1,\
    \ start=1)\n1\n>>> fibfib(2, start=1)\n1\n>>> fibfib(3, start=1)\n2\n>>> fibfib(4,\
    \ start=1)\n3\n>>> fibfib(5, start=1)\n5\n>>> fibfib(6, start=1)\n8\n>>> fibfib(7,\
    \ start=1)\n13\n>>> fibfib(8, start=1)\n21\n>>> fibfib(9, start=1)\n34\n>>> fibfib(10,\
    \ start=1)\n55\n>>> fibfib(11, start=1)\n89\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=fibonacci,algorithm,python |>\nThe above answers seem to all be O(n) which\
    \ is not really efficient since we're talking about big-O notation.  I'd like\
    \ to see this answer which goes over O(log n) which can be very efficient for\
    \ big n, and is also very easy to implement.  Here's my code:\n<code>\ndef fib2(n):\n\
    \    a = 0\n    b = 1\n    c = 0\n    d = 1\n    for i in range(n):\n        c\
    \ = a+b\n        d = a-b\n        a = b\n        b = d\n    return ", "    my($fibfib)\
    \ = fibfib($n-1);\n    my($fibfib2) = fibfib($n-2);\n    my($fibfib3) = fibfib($n-3);\n\
    \    return($fibfib + $fibfib2 + $fibfib3);\n}", "    my $ret = 0;\n    my $fib\
    \ = 1;\n    my $temp;\n    \n    for (1 .. $n) {\n        push @$temp, $fib;\n\
    \        $fib += 1;\n    }", "    my $fib;\n    if ($n < 2) { $fib = 0; }\n  \
    \  elsif ($n == 2) {\n        $fib = 0;\n    }\n    elsif ($n == 3) {\n      \
    \  $fib = 1;\n    }\n    else {\n        $fib = ($fibfib($n-2) + $fibfib($n-3)\
    \ + $fibfib($n-1)).\" \";\n    }\n    return $fib;\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\nIn case you're looking for something more like OEIS A000055, you could use\
    \ a recursive function:\n<code>\nmy $fib = 0;", "    if ($n <= 0) {\n        return\
    \ 0;\n    } elsif ($n == 1) {\n        return 0;\n    } elsif ($n == 2) {\n  \
    \      return 1;\n    } elsif ($n == 3) {\n        return 1;\n    } else {\n \
    \       return fibfib($n - 1) + fibfib($n - 2) + fibfib($n - 3);\n    }\n}", " \
    \   my($ret,$a,$b,$c);\n    if ($n == 0) {\n\t$ret = 0;\n\t$a = 0;\n\t$b = 0;\n\
    \t$c = 0;\n    } elsif ($n == 1) {\n\t$ret = 0;\n\t$a = 0;\n\t$b = 0;\n\t$c =\
    \ 0;\n    } elsif ($n == 2) {\n\t$ret = 1;\n\t$a = 0;\n\t$b = 0;\n\t$c = 0;\n\
    \    } elsif ($n == 3) {\n\t$ret = 1;\n\t$a = 0;\n\t$b = 0;\n\t$c = 1;\n    }\
    \ elsif ($n > 0) {\n\t$ret = fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n\t$a\
    \ = ($n-1)+($n-2);\n\t$b = ($n-3)+($n-4);\n\t$c = $n+($n-4);\n    }\n    return\
    \ $ret;\n}", "    my $fib = 0;\n    if ($n < 3) {\n        return 0;\n    }\n\
    \    while ($n-- > 0) {\n        $fib = $fib + $fib;\n    }\n    return $fib;\n\
    }\nprint \"$_\\n\" for 1..99;\nprint \"fibfib($n) = $fibfib($n) for 1..99\\n\"\
    \ for 1..99;", "    return $n if $n == 0;\n    return fibfib($n-1) + fibfib($n-2)\
    \ + fibfib($n-3);\n}", "    if ( $n < 0 ) {\n        require Carp;\n        Carp::croak\
    \ 'fibfib: n must be non-negative';\n    }", "    return 0 if $n == 0;\n    return\
    \ 1 if $n == 1;\n    return $n == 3 ? 1 : $n == 2 ? 1 : $n == 4 ? 2 : 3 + fibfib($n-1);\n\
    }", "    if ($n == 0) {\n\treturn 0;\n    } elsif ($n == 1) {\n\treturn 0;\n \
    \   } else {\n\treturn fibfib($n-1) + fibfib($n-2) + fibfib($n-3); \n    }\n}",
  "    return 0 unless $n >= 0;\n    $fibfib = 0 unless defined $fibfib;\n    $fibfib\
    \ += $fibfib if $fibfib <= $n;\n    $fibfib += $fibfib * $n if $fibfib <= $n;\n\
    \    return $fibfib;\n}", "    if ($n == 0 || $n == 1) {\n        return 0;\n\
    \    }\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}", "    if ($n\
    \ < 1) {\n        return 0;\n    }\n    if ($n <= 3) {\n        return $n;\n \
    \   }\n    if ($n <= 6) {\n        return fibfib($n-1) + fibfib($n-2);\n    }\n\
    \    if ($n <= 9) {\n        return fibfib($n-1) + fibfib($n-2) + fibfib($n-3)\
    \ + fibfib($n-4);\n    }\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3)\
    \ + fibfib($n-4) + fibfib($n-5) + fibfib($n-6) + fibfib($n-7);\n}", "    if($n\
    \ eq 0){\n\treturn 0;\n    }\n    if($n eq 1){\n\treturn 0;\n    }\n    if($n\
    \ eq 2){\n\treturn 1;\n    }\n    my($fibfiblast) = $fibfib{$_};\n    if($fibfiblast\
    \ < 0){\n\treturn -$fibfiblast;\n    }\n    return $fibfiblast+fibfib($n-1)+fibfib($n-2);\n\
    }", "    my $fibnum = 0;\n    my $sum = 0;\n    while (0 < $n) {\n        $sum\
    \ += $fibnum++;\n        $n -= 1;\n    }\n    return $sum;\n}", '    my($i,$f);',
  "    my ($fibfib);\n    if ($n == 0) {\n        $fibfib = 0;\n    } elsif ($n ==\
    \ 1) {\n        $fibfib = 0;\n    } elsif ($n == 2) {\n        $fibfib = 1;\n\
    \    } elsif ($n < 2) {\n        $fibfib = $fibfib + fibfib($n-1) + fibfib($n-2)\n\
    \    }\n    return $fibfib;\n}", "    if (! defined $n) {\n    \treturn 0;\n \
    \   } elsif ($n == 0) {\n    \treturn 0;\n    }\n    if ($n <= 3) {\n    \treturn\
    \ $n;\n    }\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}", "  \
    \  if($n <= 0) {\n        return 0;\n    }\n    if($n == 1) {\n        return\
    \ 0;\n    }\n    if($n == 2) {\n        return 1;\n    }\n    $a = fibfib($n-1);\n\
    \    $b = fibfib($n-2)+1;\n    $c = fibfib($n-3)+2;\n    return $a + $b + $c;\n\
    }", '    my(@fib);', "    return $fibfib{$n} if $fibfib{$n};\n    if($n == 0)\
    \ {\n\t$fibfib{$n} = 0;\n    } elsif($n == 1) {\n\t$fibfib{$n} = 0;\n    } elsif($n\
    \ == 2) {\n\t$fibfib{$n} = 1;\n    } elsif($n == 3) {\n\t$fibfib{$n} = 1;\n  \
    \  } elsif($n == 4) {\n\t$fibfib{$n} = 2;\n    } elsif($n == 5) {\n\t$fibfib{$n}\
    \ = 3;\n    } elsif($n == 6) {\n\t$fibfib{$n} = 3;\n    } elsif($n == 7) {\n\t\
    $fibfib{$n} = 4;\n    } elsif($n == 8) {\n\t$fibfib{$n} = 5;\n    } elsif($n ==\
    \ 9) {\n\t$fibfib{$n} = 6;\n    } elsif($n == 10) {\n\t$fibfib{$n} = 7;\n    }\
    \ elsif($n == 11) {\n\t$fibfib{$n} = 8;\n    } elsif($n == 12) {\n\t$fibfib{$n}\
    \ = 9;\n    } elsif($n == 13) {\n\t$fibfib{$n} = 10;\n    } elsif($n == 14) {\n\
    \t$fibfib{$n} = 11;\n    } elsif($n == 15) {\n\t$fibfib{$n} = 12;\n    } elsif($n\
    \ == 16) {\n\t$fibfib{$n} = 13;\n    } elsif($n == 17) {\n\t$fibfib{$n} = 14;\
    \ \n    } elsif($n == 18) {\n\t$fibfib{$n} = 15; \n    } elsif($n == 19) {\n\t\
    $fibfib{$n} = 16; \n    } elsif($n == 20) {\n\t$fibfib{$n} = 17; \n    } elsif($n\
    \ == 21) {\n\t$fibfib{$n} = 18; \n    } elsif($n == 22) {\n\t$fibfib{$n} = 19;\
    \ \n    } elsif($n == 23) {\n\t$fibfib{$n} = 20; \n    } elsif($n == 24) {\n\t\
    $fibfib{$n} = 21; \n    } elsif($n == 25) {\n\t$fibfib{$n} = 22; \n    } elsif($n\
    \ == 26) {\n\t$fibfib{$n} = 23; \n    } elsif($n == 27) {\n\t$fibfib{$n} = 24;\
    \ \n    } elsif($n == 28) {\n\t$fibfib{$n} = 25; \n    } elsif($n == 29) {\n\t\
    $fibfib{$n} = 26;\n    } elsif($n == 30) {\n\t$fib", "    return $fibfib{$n} if\
    \ defined $fibfib{$n};\n    my $fibfib{$n} = (\n        1 == $n\n        ? 0\n\
    \        : (\n            (2 == $n)\n            ? 1\n            : (\n      \
    \          ($n == 3)\n                ? $n\n                : 1 + fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3)\n            )\n        )\n    );\n    $fibfib{$n};\n\
    }", "    if ($n <= 0) {\n\treturn 0;\n    }\n    my $fibfib = 0;\n    $fibfib\
    \ += fibfib($n - 2);\n    $fibfib += fibfib($n - 3);\n    return $fibfib;\n}",
  "    return $n if $n <= 1;\n    $fibfib{$n} = $fibfib{$n-1} + $fibfib{$n-2} + $fibfib{$n-3};\n\
    \    return $fibfib{$n};\n}", "    my $ret = 0;\n    for($n=0;$n<$#_;$n++) {\n\
    \        $ret += $_[$n];\n    }\n    return $ret;\n}", "    my $fibfib_array =\
    \ [0,1];\n    my $fibfib = 0;\n    for(my $i = 2; $i <= $n; ++$i) {\n        $fibfib\
    \ = $fibfib + $fibfib_array[$i-1] + $fibfib_array[$i-2];\n        push @$fibfib_array,\
    \ $fibfib;\n    }\n    return $fibfib;\n}", "    my $f = 1;\n    my $fibfib =\
    \ 0;", "    my $i = 1;\n    my $fib = 0;\n    while ($i < $n) {\n        push\
    \ @fib, [$i, $fib];\n        push(@fib, @fib);\n        $fib += $fib;\n      \
    \  $i++;\n    }\n    return @fib[@_-1];\n}", "    return 0 if $n == 0;\n    return\
    \ 1 if $n == 1;\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}\n</cell>\n\
    <cell>", "    if ($n <= 0) {\n        return 0;\n    }\n    if ($n <= 2) {\n \
    \       return 0;\n    }\n    my $a = fibfib($n - 1) + fibfib($n - 2);\n    my\
    \ $b = fibfib($n - 3) + fibfib($n - 4);\n    my $c = fibfib($n - 5) + fibfib($n\
    \ - 6);\n    return $a * $b + $c;\n}", "    return 0 if $n == 0;\n    return $fibfib[$n-1]\
    \ + $fibfib[$n-2];\n}", "    if ($n < 0) {\n\tmy $fibfib = 0;\n\t$fibfib += fibfib($n-1);\n\
    \t$fibfib += fibfib($n-2);\n\t$fibfib += fibfib($n-3);\n\treturn $fibfib;\n  \
    \  } elsif ($n == 0) {\n\treturn 0;\n    } elsif ($n == 1) {\n\treturn 0;\n  \
    \  } elsif ($n == 2) {\n\treturn 1;\n    } else {\n\tmy $fibfib = 0;\n\t$fibfib\
    \ += fibfib($n-1);\n\t$fibfib += fibfib($n-2);\n\t$fibfib += fibfib($n-3);\n\t\
    return $fibfib;\n    }\n}", "    my(@fibfib);\n    for($n=0;$n<=$#fibfib;$n++)\
    \ {\n        push(@fibfib,$fibfib[$n]);\n    }\n    shift(@fibfib);\n    return\
    \ shift(@fibfib);\n}", "    return $fibfib{$n} unless $n;\n    return $fibfib{$n}\
    \ = $fibfib{$n} == 0 ? $n : fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n}", " \
    \   my $fibfib = 0;\n    my $fibfib_tmp = 0;\n    for ($fibfib_tmp = 1; $fibfib_tmp\
    \ <= $n; $fibfib_tmp++) {\n      $fibfib = $fibfib + $fibfib_tmp;\n    }\n   \
    \ return $fibfib;\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nThe classic\
    \ solution is to keep a running total in a loop.  It's very similar to what the\
    \ FibFib (as you mention) does, except that in that case you have a function call\
    \ in each iteration, rather than a loop (for loop).  So it's pretty much an O(1)\
    \ solution, except that it's O(n).\n<|/ a tags=big-o,algorithm,factorial,theory,python\
    \ |>\n<| c |>\nIt's worth noting that if you're concerned about memory consumption\
    \ of the function call overhead in your language, you can easily memoize it.\n\
    <|/ c |>\n<| c |>\nThis is not true. Fibonacci numbers grow exponentially, and\
    \ can be easily memoized in a language with explicit support for it.\n<|/ c |>\n\
    <| c |>\n, memoization is *not* O(1).  It's O(1) if you can memoize it.\n<|/ c\
    \ |>\n<| c |>\n, yes, I agree. My comment wasn't really intended to describe a\
    \ particular solution, just to point out a more obvious solution to the problem,\
    \ which might not be suitable for memoization. My point is that the O(1) solution\
    \ can have a huge memory footprint (say, a million elements), whereas memoization\
    \ can reduce that to something much smaller (say, a megabyte).\n<|/ c |>\n<| a\
    \ |>\nYou can calculate fibonacci in O(log(n)) time by doing a binary search on\
    \ the sequence up to the nth fibonacci number.  Then you can compute the nth fibonacci\
    \ by starting at the number above the calculated number, multiplying it by fib(2)\
    \ and adding that number to the calculated number - as shown in the following\
    \ Python code:\n<code>\ndef fib(n):\n    if n < 2:\n        return n\n    mid\
    \ = n // 2\n    return fib(mid) * fib(mid - 1) + fib(mid)\n</code>\nI haven't\
    \ tested this code, so it might have some bugs, but this should give you an idea\
    \ on how to do it.\n<|/ a dscore=4 tags=big-o,algorithm,factorial,theory,python\
    \ |>\n<| c |>\nAwesome code! Thanks! The only thing I ", "    return $fibfib{$n}\
    \ unless $fibfib{$n};\n    my $fib;\n    my $a;\n    my $b;\n    my $c;\n    my\
    \ $fibfib;\n    my $fibfib2;\n    for ($fibfib{$n} = $fibfib{$n-1} + $fibfib{$n-2}\
    \ + $fibfib{$n-3}; $fibfib{$n}; $n--) {\n        chomp(my $nn = <STDIN>);\n  \
    \      $fib = $nn;\n    }\n    for ($fibfib2 = $fibfib{$n}; $fibfib2; $fibfib2\
    \ = $fibfib2-1) {\n        for ($a=$fibfib2; $a; $a--) {\n            for ($b=$fibfib2-$a;\
    \ $b; $b--) {\n                for ($c=$fibfib2-$b; $c; $c--) {\n            \
    \        $fibfib{$n} = $fibfib{$n-1} + $fibfib{$n-2} + $fibfib{$n-3};\n      \
    \          }\n            }\n        }\n    }\n}", "    return $fibfib{$n} if\
    \ exists $fibfib{$n};\n    return 0 if ($n < 1);\n    my $fib = 0;\n    my $prev\
    \ = 1;\n    my $last = 0;\n    my $next = 1;\n    my $fibfib = {};\n    while\
    \ ($fib < $n) {\n        $fib = $prev + $next;\n        $next = $fib + ($fib +\
    \ 1);\n        $prev = $fibfib{$fib};\n        $fibfib{$fib} = $fib;\n    }\n\
    \    return $fibfib{$n};\n}", "    my $fib;\n    my $fibfib;\n    for (my $i=0;$i<$n;$i+=2)\
    \ {\n        $fib = $i; # fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \        $fibfib += $fib;\n    }\n    return $fibfib;\n}", "    return 0 if $n\
    \ == 0;\n    return 1 if $n == 1;\n    return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n\
    }\n</cell>\n<cell>\nfibfib(1)\n</cell>\n<text>\nProblem 2\nWe have seen that summing\
    \ numbers from 1 to n can be expressed using the formula:", "    my $a = 0;\n\
    \    my $b = 1;\n    my $fibfib = 0;\n    for (my $i=$n-1;$i>=0;$i--){\n     \
    \   $fibfib += ($a * $b);\n        $a     = $b;\n        $b     = $fibfib;\n \
    \   }\n    return $fibfib;\n}", "    my $a = $n;\n    my $b = $n;\n    my $c =\
    \ $n;\n    my $sum = 0;\n    while ($a != 0) {\n        $sum = $sum + $b;\n  \
    \      $a = $a -2;\n        $b = $c + $b;\n        $c = $a + $b;\n    }\n    return\
    \ $sum;\n}", "    my $a = 1 if $n > 0;\n    my $b = 1;\n    my $c = $a+1;\n  \
    \  my $d = 0;\n    for(my $i=0; $i<$n; $i++) {\n        $d = $c + $d;\n      \
    \  last unless $i > 0;\n        $c = $b;\n        $b = $a;\n        $a = $d;\n\
    \    }\n    return $a;\n}", "    my $fibfib_seq;\n    \n    if ($n == 0) {\n \
    \       $fibfib_seq = 0;\n    }\n    if ($n == 1) {\n        $fibfib_seq = 0;\n\
    \    }\n    if ($n == 2) {\n        $fibfib_seq = 1;\n    }\n    \n    if ($fibfib_seq)\
    \ {\n        my $fibfib_seq1 = fibfib($n-2);\n        my $fibfib_seq2 = fibfib($n-1);\n\
    \        $fibfib_seq = $fibfib_seq1 + $fibfib_seq2;\n    }\n    \n    return $fibfib_seq;\n\
    }", "    my $fibfib;\n    if( $n == 0 ){\n        $fibfib = 0;\n    }\n    elsif(\
    \ $n == 1 ){\n        $fibfib = 0;\n    }\n    elsif( $n == 2 ){\n        $fibfib\
    \ = 1;\n    }\n    else {\n        $fibfib = fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n\
    \    }\n    return $fibfib;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat does\
    \ not answer the question.  The question wants a **recursive** solution.  Your\
    \ answer shows an iterative solution.\n<|/ c |>\n<| c |>\n- That's a good point\
    \ - I missed that and updated my answer to include that.\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can use a recursive function like the below one:\n<code>\nfunction fib($n)\
    \ {\n    return $n <= 2 ? 1 : fib($n-2) + fib($n-1);\n}\n</code>\n<|/ a tags=algorithm,python\
    \ |>\n<| c |>\nThat does not answer the question.  The question wants a **recursive**\
    \ solution.  Your answer shows an iterative solution.\n<|/ c |>\n<| c |>\nSorry,\
    \ I missed that. I thought his solution was working well for the input he gave,\
    \ but his answer was flawed and incorrect. Have updated my answer with correct\
    \ solution and a link to a recursive solution.\n<|/ c |>\n<| c |>\nYour recursive\
    \ solution will not work for n=8 - it will give the wrong result (24).\n<|/ c\
    \ |>\n<| c |>\nYou're right. Thanks for pointing that out. Fixed.\n<|/ c |>\n\
    <| a tags=algorithm,python |>\nFor Python you can use the following code\n<code>\n\
    def fib(n):\n    if n<=1:\n        return 1\n    elif n>=2:\n        return fib(n-1)\
    \ + fib(n-2)\n    else:\n        return 0\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This does not answer the question.  The question wants a **recursive** solution.\
    \  Your answer shows an iterative solution.\n<|/ c |>\n<| c |>\nIt does answer\
    \ the question, and I added a recursive solution which doesn't use any loops,\
    \ just recursion. Since you are a new user, I recommend reading [how to ask a\
    \ good question](https://stackoverflow.com/help/how-to-ask) and [how to write\
    \ a good answer](https://stackoverflow.com/help/how-to-answer) for better question/answer\
    \ guidelines.\n<|/ c |>\n<| c ", "    return $fibfib{$n}\n        unless $n =~\
    \ /^\\d+$/;\n    return $fibfib{$n} = $fibfib{$n-1} + $fibfib{$n-2} + $fibfib{$n-3};\n\
    }", "    my(@fibfib) = @_;\n    \n    my $i = 0;\n    while ($i < $n) {\n    \
    \    push(@fibfib, 0);\n        push(@fibfib, 0);\n        push(@fibfib, 1);\n\
    \        $i = $i + 3;\n    }\n    return $fibfib[0];\n}", "    $n += 2;\n    my\
    \ $k = $n + $n;\n    $k > $n ? ($k -= $n) : 1;\n    return $k;\n}", "    if  \
    \  ($n == 0) { return 0; }\n    elsif ($n == 1) { return 0; }\n    elsif ($n ==\
    \ 2) { return 1; }\n    elsif ($n == 3) { return 1; }\n    elsif ($n >= 4) { my\
    \ $i = 0; my $a = fibfib($n-1); my $b = fibfib($n-2); $i += $a + $b; return $i;\
    \ }\n}\n</cell>\n<cell>\nfibfib(1)\n</cell>\n<cell>\nfibfib(5)\n</cell>\n<cell>\n\
    fibfib(n = 5)\n</cell>\n<cell>\nfibfib(n = 10)\n</cell>\n<cell>\nfibfib(n = 100)\n\
    </cell>\n<cell>\nfibfib(n = 1000)\n</cell>\n<cell>", "    if($n == 0) {\n    \
    \    return 0;\n    }\n    if($n == 1) {\n        return 0;\n    }\n    if($n\
    \ == 2) {\n        return 1;\n    }\n    $n = $n - 2;\n    return fibfib($n) +\
    \ fibfib($n - 1) + fibfib($n - 2);\n}", "    $n = abs($n);\n    my $fibfib = 0;\n\
    \    my @fibfibs;\n    push @fibfibs, $fibfib;\n    for(my $i = 2; $i <= $n; $i++)\
    \ {\n        $fibfib += $fibfibs[$i-2];\n        push @fibfibs, $fibfib;\n   \
    \ }\n    return $fibfib;\n}", "    return 0 if ($n == 0);\n    return 1 if ($n\
    \ == 1);\n    return fibfib($n - 1) + fibfib($n - 2) + fibfib($n - 3);\n}", " \
    \   my($fibfib) = (0) x $n;\n    foreach my $i (1..$n){\n       $fibfib = $fibfib\
    \ + $fibfib[$i - 1] + $fibfib[$i - 2];\n    }\n    return $fibfib[$n];\n}", " \
    \   if( $n == 0 ) {\n        return 0;\n    }\n    elsif( $n == 1 ) {\n      \
    \  return 0;\n    }\n    elsif( $n == 2 ) {\n        return 1;\n    }\n    elsif(\
    \ $n == 3 ) {\n        return 1;\n    }\n    elsif( $n == 4 ) {\n        return\
    \ 2;\n    }\n    elsif( $n == 5 ) {\n        return 3;\n    }\n    elsif( $n ==\
    \ 6 ) {\n        return 5;\n    }\n    elsif( $n == 7 ) {\n        return 8;\n\
    \    }\n    elsif( $n == 8 ) {\n        return 13;\n    }\n    elsif( $n == 9\
    \ ) {\n        return 26;\n    }\n    elsif( $n == 10) {\n        return 51;\n\
    \    }\n    elsif( $n == 11) {\n        return 84;\n    }\n    elsif( $n == 12)\
    \ {\n        return 137;\n    }\n    elsif( $n == 13) {\n        return 254;\n\
    \    }\n    elsif( $n == 14) {\n        return 503;\n    }\n    elsif( $n == 15)\
    \ {\n        return 833;\n    }\n    elsif( $n == 16) {\n        return 1366;\n\
    \    }\n    elsif( $n == 17) {\n        return 2517;\n    }\n    elsif( $n ==\
    \ 18) {\n        return 5015;\n    }\n    elsif( $n == 19) {\n        return 8342;\n\
    \    }\n    elsif( $n == 20) {\n        return 13670;\n    }\n    elsif( $n ==\
    \ 21) {\n        return 2518;\n    }\n    elsif( $n == 22) {\n        return 5016;\n\
    \    }\n    elsif( $n == 23) {\n        return 8343;\n    }\n    elsif( $n ==\
    \ 24) {\n        return 13671;\n    }\n    elsif( $n == 25) {\n        return\
    \ 2519;\n    }\n    elsif( $n == 26) {\n        return 5017;\n    }\n    elsif(\
    \ $n == 27) {\n        return 8344;\n    }\n    elsif( $n == 28) {\n        return\
    \ 13672;\n    }\n    elsif( $n == 29) {\n        return 2520;\n    }\n    elsif(\
    \ $n == 30) {\n        return 5018;\n    }\n    elsif( $n == 31) {\n        return\
    \ 8345;\n    }\n    elsif( $n == 32) {\n        return 13673;\n    }\n    elsif(\
    \ $n == 33) {\n        return 2521;\n    }\n    elsif( ", "    my $fibfib;\n \
    \   $fibfib = 0;\n    for ($n = 0 ; $n < 4 ; $n++) {\n        $fibfib += $fibfib;\n\
    \    }\n    return $fibfib;\n}", "    my $fib = $n;\n    my $fibfib = 1;\n   \
    \ while($fib > 0) {\n        $fibfib = $fibfib + $fib;\n        $fib = $fib -\
    \ 1;\n    }\n    return $fibfib;\n}", "    if ($n <= 0) {\n        return 0;\n\
    \    }\n    my $result = $fibfib($n-1);\n    my $tmp = $fibfib($n-2);\n    $result\
    \ = $tmp + $result;\n    return $result;\n}\n</code>\nThe next thing I did was\
    \ the code below:\n<code>\nuse strict;\nuse warnings;", "    if ($n == 0) {\n\
    \        return 0;\n    }\n    if ($n == 1) {\n        return 0;\n    }\n    if\
    \ ($n == 2) {\n        return 1;\n    }\n    return fibfib($n-1) + fibfib($n-2)\
    \ + fibfib($n-3);\n}\n</cell>\n<cell>", "    my($fib);\n    $fib = 0;\n    $fib\
    \ = 0;\n    while ($n > 1) {\n        $fib += $n;\n        $n -= 3;\n    }\n \
    \   return $fib;\n}", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n  \
    \  return 0 if $n == $#_;\n    my $a = fibfib($n-1);\n    my $b = fibfib($n-3);\n\
    \    return $a + $b + $a * $b;\n}", "    my $result = 1;\n    for($n-1; $n>0;\
    \ $n--) {\n        $result = $result + $result;\n    }\n    return $result;\n}",
  "    return $fibfib[$n-1] if $n <= 2;\n    my $fibval = 1;\n    my $fibfibval =\
    \ 1;\n    my $fibfibval = $fibfibval + $fibfib[$n-2] if $n > 2;\n    my $fibfibval\
    \ = $fibfibval + $fibfib[$n-3] if $n > 3;\n    return $fibfibval;\n}\n1", "  \
    \  if ($n < 0) {\n\t$n = 0 - $n;\n\t$n *= -1;\n\tmy $fibfib = ($n<0) ? 0 : ($n<1)\
    \ ? 0 : ($n<2) ? 1 : 2;\n\treturn $fibfib;\n    } else {\n\tmy $fibfib = ($n<2)\
    \ ? 0 : ($n<3) ? 1 : fibfib($n-2) + fibfib($n-1);\n\treturn $fibfib;\n    }\n}",
  "    return $fibfib{$n} if exists $fibfib{$n};\n    if($n < 1) {\n        return\
    \ 0;\n    }\n    if($n == 1) {\n        return 0;\n    }\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3) ;\n}\n</code>\nAnd then I ran some tests:\n<code>\n\
    $ perl -E 'use Benchmark; say fibfib(1)'\n0\n$ perl -E 'use Benchmark; say fibfib(5)'\n\
    4\n$ perl -E 'use Benchmark; say fibfib(8)'\n24\n$ perl -E 'use Benchmark; say\
    \ fibfib(-5)'\n-1\n$ perl -E 'use Benchmark; say fibfib(-2)'\n-2\n$ perl -E 'use\
    \ Benchmark; say fibfib(-9)'\n-9\n$ perl -E 'use Benchmark; say fibfib(-8)'\n\
    -24\n$ perl -E 'use Benchmark; say fibfib(-7)'\n-8\n$ perl -E 'use Benchmark;\
    \ say fibfib(-6)'\n-14\n$ perl -E 'use Benchmark; say fibfib(-3)'\n-15\n$ perl\
    \ -E 'use Benchmark; say fibfib(-2)'\n-9\n$ perl -E 'use Benchmark; say fibfib(-1)'\n\
    -2\n$ perl -E 'use Benchmark; say fibfib(0)'\n0\n$ perl -E 'use Benchmark; say\
    \ fibfib(1)'\n0\n$ perl -E 'use Benchmark; say fibfib(2)'\n1\n$ perl -E 'use Benchmark;\
    \ say fibfib(3)'\n2\n$ perl -E 'use Benchmark; say fibfib(4)'\n3\n$ perl -E 'use\
    \ Benchmark; say fibfib(5)'\n4\n$ perl -E 'use Benchmark; say fibfib(6)'\n6\n\
    $ perl -E 'use Benchmark; say fibfib(7)'\n9\n$ perl -E 'use Benchmark; say fibfib(8)'\n\
    18\n$ perl -E 'use Benchmark; say fibfib(-9)'\n-1\n$ perl -E 'use Benchmark; say\
    \ fibfib(-8)'\n-18\n$ perl -E 'use Benchmark; say fibfib(-7)'\n-27\n$ perl -E\
    \ 'use Benchmark; say fibfib(-", "    my (@result) = ();\n    for (my $k = 0;\
    \ $k < $n; $k++) {\n        push @result, $k % 2 ? $k + 1 : $k - 1;\n    }\n \
    \   return $result[-1];\n}", "    if($n == 0) { return 0; }\n    if($n == 1) {\
    \ return 1; }\n    return fibfib($n-2) + fibfib($n-1) + fibfib($n);\n}\n</cell>\n\
    <cell>", "    return 0 unless $n;\n    return 0 unless $n->isa('Int');\n    return\
    \ $fibfib{$n} = 0 unless exists $fibfib{$n};\n    $fibfib{$n};\n}", "    if ($n\
    \ < 0) { \n\t$n = -($n);\n\t$_[0] = $_[0] + $fibfib($n-1);\n\t$_[1] = $_[1] +\
    \ $fibfib($n-2);\n\t$_[2] = $_[2] + $fibfib($n-3);\n    }\n    $_[0] ? $_[0] :\
    \ 0;\n}\n\t", "    if ($n == 0){\n        return 0;\n    }\n    if ($n == 1) {\n\
    \        return 0;\n    }\n    if ($n == 2) {\n        return 1;\n    }\n    my\
    \ $f = fibfib($n-1);\n    my $r = fibfib($n-2);\n    my $s = fibfib($n-3);\n \
    \   return $f + $r + $s;\n}", "    if ($n <= 0) {\n        return 0;\n    } elsif\
    \ ($n <= 1) {\n        return 0;\n    } elsif ($n >= $n) {\n        return 1;\n\
    \    } elsif ($n >= 2) {\n        return fibfib($n - 1) + fibfib($n - 2);\n  \
    \  } else {\n        return fibfib($n - 3) + fibfib($n - 2);\n    }\n}", "   \
    \ return 0 unless ($n >= 1);\n    return $fibfib_cache{$n} if defined $fibfib_cache{$n};\n\
    \    $fibfib_cache{$n} = $n * ($n - 1) + ($n - 2) * $n - 3;\n}", "    if ( $n\
    \ == 0 || $n == 1 ) {\n        return 0;\n    }\n    my $result = fibfib($n-1)\
    \ + fibfib($n-2);\n    return $result;\n}", "    if ($n <= 1) {\n        return\
    \ 0;\n    }\n    else {\n        return fibfib($n-2) + fibfib($n-1) + fibfib($n);\n\
    \    }\n}", "    my $fibfib_base = 0;\n    my $fibfib = 1;", "    if ( $n == 0\
    \ ) {\n\t    return 0;\n    } elsif ( $n == 1 ) {\n\treturn 0;\n    } elsif (\
    \ $n == 2 ) {\n\treturn 1;\n    } else {\n\treturn fibfib($n - 1) + fibfib($n\
    \ - 2) + fibfib($n - 3);\n    }\n}", "    $n != 0 ? ($fibfib[$n-1] + $fibfib[$n-2]\
    \ + ($fibfib[$n-3] + $fibfib[$n-4]))\n              : ($fibfib[0]);\n}", "   \
    \ return $fibfib[$n] if $n > 0 && $n < $#fibfib;\n    if ($n == 0) {\n\treturn\
    \ 0;\n    }\n    if ($n == 1) {\n\treturn 0;\n    }\n    return fibfib($n-1) +\
    \ fibfib($n-2) + fibfib($n-3);\n}", "    my $fibfib;\n    \n    if ($n == 0) {\n\
    \        $fibfib = 0;\n    } elsif ($n == 1) {\n        $fibfib = 0;\n    } elsif\
    \ ($n == 2) {\n        $fibfib = 1;\n    } elsif ($n == 3) {\n        $fibfib\
    \ = 3;\n    } elsif ($n == 4) {\n        $fibfib = 5;\n    } elsif ($n == 5) {\n\
    \        $fibfib = 7;\n    } elsif ($n == 6) {\n        $fibfib = 9;\n    } elsif\
    \ ($n == 7) {\n        $fibfib = 11;\n    } elsif ($n == 8) {\n        $fibfib\
    \ = 13;\n    } elsif ($n == 9) {\n        $fibfib = 15;\n    } elsif ($n == 10)\
    \ {\n        $fibfib = 17;\n    } elsif ($n == 11) {\n        $fibfib = 19;\n\
    \    } elsif ($n == 12) {\n        $fibfib = 21;\n    } elsif ($n == 13) {\n \
    \       $fibfib = 1;\n    } elsif ($n == 14) {\n        $fibfib = 5;\n    } elsif\
    \ ($n == 15) {\n        $fibfib = 7;\n    } elsif ($n == 16) {\n        $fibfib\
    \ = 9;\n    } elsif ($n == 17) {\n        $fibfib = 11;\n    } elsif ($n == 18)\
    \ {\n        $fibfib = 13;\n    } elsif ($n == 19) {\n        $fibfib = 15;\n\
    \    } elsif ($n == 20) {\n        $fibfib = 17;\n    } elsif ($n == 21) {\n \
    \       $fibfib = 19;\n    } elsif ($n == 22) {\n        $fibfib = 21;\n    }\
    \ elsif ($n == 23) {\n        $fibfib = 1;\n    } elsif ($n == 24) {\n       \
    \ $fibfib = 5;\n    } elsif ($n == 25) {\n        $fibfib = 7;\n    } elsif ($n\
    \ == 26) {\n        $fibfib = 9;\n    } elsif ($n == 27) {\n        $fibfib =\
    \ 11;\n    } elsif ($n == 28) {\n        $fibfib = 13;\n    } elsif ($n == 29)\
    \ {\n        $fibfib = 15;\n    } elsif ($n == 30) {\n        $fibfib = 17;\n\
    \    } elsif ($n == 31) {\n        $fibfib = 19;\n    } elsif ($n == 32) {\n \
    \       $fibfib = 21;\n    } elsif ($n == 33) {\n        $fibfib = 1;\n    } elsif\
    \ ($n == 34) {\n        $fibfib = 5;\n    } elsif ($", "    my $fib = 0;\n   \
    \ for (1 .. $n) {\n        my $fib2 = $fib + ($fib + 1) + $fib;\n        $fib\
    \ = $fib2;\n    }\n    return $fib;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I'm going to have to try this and get back to you, thanks so much!\n<|/ c |>\n\
    <| c |>\nI figured out a way to use this sequence and still be very fast.\n<|/\
    \ c |>\n<| c |>\nThis was my original question, but I didn't think it would be\
    \ considered a homework question when I'm asking how to do this. It's not homework,\
    \ it's just me trying to figure out a way to figure out these sequences. Thanks\
    \ though!\n<|/ c |>\n<| c |>\nJust figured out a way to use the sequence and still\
    \ be very fast.\n<|/ c |>\n<| c |>\nI should mention that this was the solution\
    \ I came up with for my problem. Thanks for the help! I figured out the sequence\
    \ and wrote it down here. The sequence is as follows:\nfibfib(0) == 0 and fibfib(1)\
    \ == 0.\nfibfib(2) == 1 and fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).",
  "    my $result = $n;\n    my $temp = $n-1;\n    my $count = 1;", "    my($a, $b,\
    \ $c, $n);\n    my($n);\n    my($temp);", "    my $fibfib = 0;\n    for(my $i\
    \ = 0; $i <= $n; $i++) {\n        $fibfib = $fibfib + $fibfib;\n    }\n    return\
    \ $fibfib;\n}", "    my @a;\n    my $fibfib;\n    for(my $i = 0; $i < $n; $i++)\
    \ {\n        $fibfib = 0;\n        foreach my $j (0..$i) {\n            $fibfib\
    \ += $j;\n        }\n        push @a, $fibfib;\n    }\n    return $a[0];\n}",
  "    my(@fib);\n    $fib[0] = 0;\n    $fib[1] = 0;\n    for($i=2;$i<=$n;$i++) {\n\
    \        $fib[$i] = $fib[$i-1] + $fib[$i-2] + $fib[$i-3];\n    }\n    return $fib[$n];\n\
    }\n</code>\n<|/ a tags=fibonacci,perl,numbers,sequence,recursion |>\n<| c |>\n\
    This code is a little slower than the other code I posted, but is very concise.\
    \ Can you please explain how you arrived at this code?\n<|/ c |>\n<| c |>\nMy\
    \ code was the first thing I found. I just wrote it up and tested it. It worked\
    \ fine as far as I could tell, but I used a lot of print statements. I just noticed\
    \ that my code only returned the number in the correct sequence, but I did not\
    \ print out the intermediate values. My code printed the value of each variable\
    \ as I stepped through the program. I printed a lot of values. The other code\
    \ I posted printed each intermediate value. My code only printed the final value.\n\
    <|/ c |>\n<| c |>\nYeah your code is very concise.  I love perl!  Thanks for writing\
    \ it up for me!\n<|/ c |>\n<| c |>\nThis is very bad code. `@_` will give warnings\
    \ when called with `fibfib(0)` and `fibfib(10)` because you use the arguments\
    \ as array indexes, and they don't exist (unless you explicitly enable warnings,\
    \ which you shouldn't).\n<|/ c |>\n<| a tags=fibonacci,perl,numbers,sequence,recursion\
    \ |>\nI see you have already posted answers for your other questions. But I just\
    \ wanted to share a similar solution that can be optimized by using Memoization\
    \ and Recursion.\nThe code here uses recursion and memoization to calculate the\
    \ Fibonacci sequence faster than the other solutions. \n<code>\nuse strict;\n\
    use warnings;", "    if ($n eq 0){\n        return 0;\n    } elsif ($n eq 1){\n\
    \        return 1;\n    } elsif ($n eq 2){\n        return 1;\n    } else {\n\
    \        my $i = $n - 1;\n        return fibfib($i) + fibfib($i+1) + fibfib($i+2);\n\
    \    }\n}\n</code>\n<|/ a tags=recursion,algorithm,memoization,functional-programming,python\
    \ |>\n<| c |>\nYour solution is clearly better than the other answers so far,\
    \ since it avoids unnecessary recursive calls. However, it doesn't do any memoization\
    \ and your function will end up with O(n^2) runtime. Also, your code is in Python,\
    \ not Perl.\n<|/ c |>\n<| c |>\nI've removed the comment about memoization.  It\
    \ didn't make sense, and I thought I made it clear in the answer.  I've also removed\
    \ my mention of recursion.  I really don't think the OP is talking about recursion\
    \ here, and I don't believe that memoization will really help here anyway.\n<|/\
    \ c |>\n<| c |>\nYour solution is clearly better than the other answers so far,\
    \ since it avoids unnecessary recursive calls. However, it doesn't do any memoization.\
    \ Also, your code is in Python, not Perl. Why isn't it Perl? :)\n<|/ c |>\n<|\
    \ c |>\nThanks for the clarification. My mistake, I should have noticed that Perl\
    \ is not used here.\n<|/ c |>\n<| c |>\nNice solution. Do you think it is faster\
    \ than the other solutions?\n<|/ c |>\n<| a dscore=4 |>\nA recursive memoization\
    \ solution in Haskell:\n<code>\nfibs :: [Integer]\nfibs = 0 : 1 : zipWith (+)\
    \ fibs (tail fibs)\n</code>\nYou can see it on Haskell Report page.\n<|/ a tags=recursion,algorithm,memoization,functional-programming,python\
    \ |>\n<| c |>\nThis is also a very elegant solution. My only issue is that it\
    \ looks more like a for-loop to me than a recursive function call. Do you know\
    \ of a way to make the recursive call look more like a for loop?\n<|/ c |>\n<|\
    \ c |>\nI added a Haskell tag because I like Haskell so much, I feel like it is\
    \ the most elegant solution for this problem, and I like the solution in general\
    \ :)\n<|/ c |>\n<| c |>\nThe Haskell version", "    my $fibfib = 0;\n    \n  \
    \  for(my $i = 1; $i <= $n; $i++) {\n        $fibfib += $i;\n    }\n    return\
    \ $fibfib;\n}", "    if ($n < 0) {\n        $n = 0;\n    }\n    if ($n == 0) {\n\
    \        return 0;\n    }\n    if ($n == 1) {\n        return 0;\n    }\n    if\
    \ ($n == 2) {\n        return 1;\n    }\n    my $result = $fibfib($n-1) + $fibfib($n-2);\n\
    \    return $result;\n}\n</code>\n<|/ a tags=recursion,perl |>\n<| a |>\n<code>",
  "    if ($n == 0)\n    {\n\treturn 0;\n    }\n    elsif ($n == 1)\n    {\n\treturn\
    \ 0;\n    }\n    elsif ($n == 2)\n    {\n\treturn 1;\n    }\n    elsif ($n > 2)\n\
    \    {\n\treturn fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n    }\n}", "   \
    \ return $fibfib[$n] if $n >= 0 && $fibfib[$n] > 0;\n    return 0;\n}", "    $fibfib{sprintf\
    \ \"%05d\", $n} = $fibfib{sprintf \"%05d\", $n-1} + $fibfib{sprintf \"%05d\",\
    \ $n-2} + $fibfib{sprintf \"%05d\", $n-3};\n    $fibfib{sprintf \"%05d\", $n};\n\
    }", "    if($n <= 0) { die \"fibfib() called with n < 0\"; }\n    my $fibfibnum\
    \ = 0;\n    my $tmp;\n    for my $i (0 .. $n) {\n        $fibfibnum += $tmp =\
    \ $i;\n        $fibfibnum -= $fibfibnum += $fibfibnum;\n    }\n    return $fibfibnum;\n\
    }", "    $fibfib{$n} ||= $n < 3 ? $fibfib{$n}\n                    : fibfib($n-1)\
    \ + fibfib($n-2);\n}", "    $fibfib{$n} = 0;\n    $fibfib{$n} = $fibfib{$n-1}\
    \ + $fibfib{$n-2} + $fibfib{$n-3};\n    return $fibfib{$n};\n}", "    return 0\
    \ unless $n;\n    return 0 unless $n > 3;\n    my($fib1, $fib2, $fib3);\n    $fib1\
    \ = $fib2 = $fib3 = 0;\n    for my $i (0 .. $n-3) {\n        $fib1 += $fib3;\n\
    \        $fib2 = $fib3;\n        $fib3 = $fib2 + $fib1;\n    }\n    return $fib3;\n\
    }\n1;\n__END__\nThe Fibonacci Sequence\n \nFor a given positive integer N, fib(N)\
    \ returns the Nth number in the Fibonacci sequence (also called \nthe Nth Fibonacci\
    \ number or Fermat's Last Fibonacci number if N is less than 4).\n \nFor instance,\
    \ if N is 3, then fib(3) = 5.\n \n \nThe Fibonacci sequence\n \nThe Fibonacci\
    \ sequence is a sequence of numbers, where each number is the sum of the two preceding\
    \ \nnumbers in the sequence. For example, fib(4) = 5 because 4 + 3 = 7 and 3 +\
    \ 2 = 5.\n \nIf such sequences are defined, then they are called Fibonacci sequences,\
    \ because they can be \ncomputed efficiently using the formula:\n \nFn = Fn-1\
    \ + Fn-2 where F1 is Fn-1, F2 is Fn-2 and Fn is any positive integer greater than\
    \ or equal to 2.\n \nFor example, the first few fibonacci numbers are:\n \n0,\
    \ 1, 1, 2, 3, 5, 8, 13, 21, 34\n \nThe next few fibonacci numbers are:\n \n0,\
    \ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\n \nThe\
    \ next few fibonacci numbers are:\n \n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ 144, 233, 377, 610, 987, 1597, 2584, 4181\n \nThe first ten fibonacci numbers\
    \ are:\n \n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\
    \ 2584, 4181, 6765\n \nThe next ten fibonacci numbers are:\n \n0, 1, 1, 2, 3,\
    \ 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946\n\
    \ \nThe last ten fibonacci numbers are:\n \n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,\
    \ 89, ", "    if ($n <= 0) {\n        return 0;\n    }\n    if ($n == 1) {\n \
    \       return 0;\n    }\n    if ($n == 2) {\n        return 1;\n    }\n    return\
    \ fibfib($n-1) + fibfib($n-2);\n}\n</code>\n<|/ q tags=raku |>\n<| c |>\nWhy don't\
    \ you post the code you've written so far so that people can help you?\n<|/ c\
    \ |>\n<| a dscore=4 tags=raku |>\nYou have a few mistakes.", "    if( $n == 0\
    \ ){\n        return 0;\n    }\n    elsif( $n == 1 ){\n        return 0;\n   \
    \ }\n    elsif( $n == 2 ){\n        return 1;\n    }\n    elsif( $n <= 3 ){\n\
    \        return fibfib($n-1) + fibfib($n-2) + fibfib($n-3);\n    }\n    elsif(\
    \ $n <= 5 ){\n        return fibfib($n-3) + fibfib($n-2) + fibfib($n-4);\n   \
    \ }\n    else {\n        return fibfib($n-5) + fibfib($n-4) + fibfib($n-6);\n\
    \    }\n}\n</code>\n<|/ a tags=recursion,algorithm,dynamic-programming dscore=0\
    \ |>\n<| c |>\nPlease explain your code, and how it answers the question.\n<|/\
    \ c |>\n<| c |>\nWelcome to Stack Overflow! While this code snippet may solve\
    \ the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a dscore=0 |>\nHere's a non-recursive solution in\
    \ O(1) space:\n<code>\ndef fibfib(n):\n    if n < 2:\n        return n\n    fib\
    \ = [0] * n\n    fib[0] = 0\n    fib[1] = 1\n    fibfib(n, fibfib[1], fib[2])",
  "    if ($n < 1) {\n        return 0;\n    }\n    if ($n < 3) {\n        return\
    \ $n;\n    }\n    my $fibfib = 0;\n    while ($n >= 2) {\n        $fibfib += $fibfib\
    \ + 1;\n        $n -= 3;\n    }\n    return $fibfib;\n}", "    if ( $n < 0 ) {\n\
    \        $n = abs($n);\n        die \"fibfib(): negative numbers not allowed!\\\
    n\";\n    }\n    if ( $n == 0 ) {\n        return 0;\n    }\n    if ( $n == 1\
    \ ) {\n        return 0;\n    }\n    if ( $n == 2 ) {\n        return 1;\n   \
    \ }\n    $result = fibfib($n - 1) + fibfib($n - 2);\n    if ( $n != $result )\
    \ {\n        die \"fibfib(): the fibfib sequence does not have an entry for $n!\\\
    n\";\n    }\n    return $result;\n}", "    my $fibfib = 1;\n    for my $i (1 ..\
    \ $n) {\n        $fibfib += $fibfib;\n    }\n    return $fibfib;\n}", "    if\
    \ ($n == 0) {\n        return 0;\n    } elsif ($n == 1) {\n        return 0;\n\
    \    } elsif ($n == 2) {\n        return 1;\n    } elsif ($n < 0) {\n        return\
    \ 0;\n    } elsif ($n >= $MAX) {\n        $n = 0;\n        return 0;\n    } else\
    \ {\n        return fibfib($n - 1) + fibfib($n - 2) + fibfib($n - 3);\n    }\n\
    }", "    my($fibfib);\n    $fibfib = 0;\n    for($n=0;$n<$#_;$n++) {\n       \
    \ $fibfib += $fibfib;\n        $fibfib += $fibfib;\n        $fibfib += $fibfib;\n\
    \        $fibfib += $fibfib;\n    }\n    return $fibfib;\n}\n</code>\n<|/ a tags=math,algorithm,fibonacci,python\
    \ dscore=1 |>\n<| c |>\nThis does not answer OP's question.\n<|/ c |>\n<| c |>\n\
    It answers the question \"How would you solve it using Python?\".\n<|/ c |>\n\
    <| c |>\nThis does not answer the question *How would you solve it using Python?*\n\
    <|/ c |>\n<| c |>\nThe question asks how to implement Fibonacci using Python,\
    \ so I showed how. How do you think this answers it? I didn't say it was the most\
    \ elegant way to implement it - I said that it was the most practical way I saw\
    \ to implement it - and I provided references to how it can be done. Why do you\
    \ think it doesn't?\n<|/ c |>\n<| c |>\nThe question asks for how to implement\
    \ Fibonacci using Python, and your implementation does not do that.  You just\
    \ copied my answer here, and it also doesn't do that.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another way, using list comprehension:\n<code>\ndef fib(n):\n  \
    \  a, b = 0, 1\n    if n < 2:\n        return n\n    return [fib(n-1)+fib(n-2)\
    \ for _ in range(n)][n-1]\n</code>\n<|/ a tags=math,algorithm,fibonacci,python\
    \ |>\n<| c |>\nYou don't need to do `return n` at the end.  You can just return\
    \ `fib(n-1)+fib(n-2)` from the function body.\n<|/ c |>\n<| c |>\n: That is not\
    \ true.  If the input is `0`, then you will get `1` back, which is not the intended\
    \ behavior.  But you are right, if the input is `0`, then you will get `1` back\
    \ anyway.\n<|/ c |>\n<| c |>\nThat is why I said *if* the input is not 0.  If\
    \ you want it to return `0` then change the input test to `n < 2` -- but then,\
    \ of course, you'll need to change your `return` statement as well.  In other\
    \ words, I said \"if\" and not \"while", "    return $fibfib[$n] if ($fibfib[$n]\
    \ != 0);\n    my $fibfib = 0;\n    my $n = 0;\n    for (; $n <= $#_; $n++) {\n\
    \        my $t = $n;\n        my $sum = 0;\n        for ($n; $n <= $#_; $n++)\
    \ {\n            $fibfib = $fibfib + $fibfib[$n] if ($fibfib[$n] != 0);\n    \
    \        $sum += $fibfib;\n        }\n        my $temp = $sum - $t;\n        $fibfib[$n]\
    \ = $temp;\n    }\n    return $fibfib[$n];\n}", "    $_ == $n || $n != 1 && $n\
    \ != 0 && ($n > 2 || $n <= 0) || die \"fibfib($n) must be integer 1..\";\n   \
    \ $n = 0 if $n < 0;\n    if ($n <= 1) {\n        return 0 if $n == 0;\n      \
    \  return 1 if $n == 1;\n        return 0;\n    }\n    my $fibfib = ($fibfib -\
    \ 1) + ($fibfib - 2) + ($fibfib - 3);\n    return $fibfib;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=algorithm,c++,python,c |>\n<code>\nclass Solution:\n    def __init__(self):\n\
    \        self.nums = []\n    def fib(self,n):\n        self.nums = []\n      \
    \  self.nums.append(0)\n        self.nums.append(1)\n        for i in range(2,n):\n\
    \            self.nums.append( self.nums[i-1] + self.nums[i-2] )\n        return\
    \ self.nums[n]\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=algorithm,c++,python,c\
    \ |>\nIn python:\n<code>\ndef fib(n):\n    if n == 1 or n == 2:\n        return\
    \ 1\n    else:\n        return fib(n-2) + fib(n-1)\n</code>\n<|/ a |>\n<| a |>\n\
    In Java:\n<code>\npublic int fib(int n) {\n    List<Integer> fibs = new ArrayList<Integer>();\n\
    \    fibs.add(0);\n    fibs.add(1);\n    for (int i = 0; i <= n; i++) {\n    \
    \    fibs.add((fibs.get(i-1) + fibs.get(i-2)));\n    }\n    return fibs.get(n);\n\
    }\n</code>\n<|/ a dscore=4 tags=algorithm,c++,python,c |>\n<| c |>\nThis is just\
    \ beautiful!\n<|/ c |>\n<| a |>\nI made this simple program in Python:\n<code>\n\
    def fib(n):\n    if n < 2:\n        return 1\n    else:\n        return (fib(n-1)\
    \ + fib(n-2))\n</code>\n<|/ a dscore=4 tags=algorithm,c++,python,c |>\n<| a dscore=4\
    \ tags=algorithm,c++,python,c |>\nIn Java:\n<code>\npublic static int fib(int\
    \ n) {\n    final int limit = n;\n    int[] arr = new int[n + 1];\n    arr[0]\
    \ = 1;\n    for (int i = 1; i < limit; i++) {\n        arr[i] = arr[i - 1] + arr[i\
    \ - 2];\n    }\n    return arr[limit];\n}\n</code>\n<|/ a |>\n<| a |>\nThe following\
    \ C program (without recursion) computes the nth fibonacci number. \n<code>",
  "    if ($n <= 0){\n        return 0;\n    }\n    if ($n == 1){\n        return\
    \ 0;\n    }\n    if ($n == 2){\n        return 1;\n    }\n    my $temp = $fibfib($n-1)\
    \ + $fibfib($n-2) + $fibfib($n-3); \n    return $temp;\n}", "    return $fibfib{$n}\
    \ if exists $fibfib{$n};\n    $fibfib{$n} = fibfib($n-2) + fibfib($n-3) + fibfib($n-1);\n\
    \    return $fibfib{$n};\n}", "    return $fibfib{$n} if exists $fibfib{$n};\n\
    \    my $a = $fibfib{$n} = 1;\n    my $b = $fibfib{$n-1} = 1;\n    my $c = $fibfib{$n-2}\
    \ = 1;\n    my $d = $fibfib{$n-3} = 1;\n    while ($n--) {\n        $a = $fibfib{$n}\
    \ = $a + $b;\n        $b = $fibfib{$n-1} = $b + $c;\n        $c = $fibfib{$n-2}\
    \ = $c + $d;\n        $d = $fibfib{$n-3} = $d + $a;\n    }\n    $fibfib{$n};\n\
    }", "    my $fib = 0;\n    my $fibfib;\n    if ($n <= 1){\n        $fibfib = 0;\n\
    \    }\n    else {\n        $fibfib = ( $fibfib + $fibfib + $fib ) / 3;\n    }\n\
    \    return $fibfib;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "    my\
    \ $fibfib = 0;\n    if ($n <= 0) {\n        $fibfib = 0;\n    } elsif ($n == 1)\
    \ {\n        $fibfib = 0;\n    } elsif ($n == 2) {\n        $fibfib = 1;\n   \
    \ } elsif ($n <= 3) {\n        $fibfib = $fibfib + fibfib($n - 2) + fibfib($n\
    \ - 3);\n    } else {\n        $fibfib = fibfib($n - 1) + fibfib($n - 2) + fibfib($n\
    \ - 3);\n    }\n    return $fibfib;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    A recursive solution in Python (it can be done in C in one line with tail recursion):\n\
    <code>\ndef fibfib(n):\n    if n==0 or n==1: return 0\n    if n==2: return 1\n\
    \    return fibfib(n-1)+fibfib(n-2)\n</code>\n<|/ a tags=recursion,fibonacci,math\
    \ dscore=0 |>\n<| c |>\nI don't think your recursion solution works. Try with\
    \ any n > 2. For instance, fib(3). Your function returns fib(2) and fib(3), not\
    \ fibfib(2)+fibfib(3). Though you might also want to add a check for negative\
    \ numbers.\n<|/ c |>\n<| c |>\nYou are right. I missed that requirement.\n<|/\
    \ c |>\n<| a dscore=0 |>\nPython Version:\n<code>\ndef fibfib(n):\n    \"\"\"\n\
    \    Returns the n'th Fibonacci number\n    \"\"\"\n    if n <= 0:\n       raise\
    \ ValueError('Invalid Fibonacci Number')\n    elif n == 1 or n == 2:\n       return\
    \ n\n    return fibfib(n-1) + fibfib(n-2)", "    if ( $n =~ /^(\\d+)$/o ) {\n\
    \        my $fibfib_seq = 0;\n        my $fibfib = ( ( $fibfib_seq++ == 1 ) ?\
    \ 0 : $fibfib_seq + $fibfib_seq + $fibfib_seq + 1 );\n        return $fibfib;\n\
    \    }\n}", "    my($fibfib);\n    if ($n != 0) {\n        $fibfib = 0;\n    \
    \    if ($n <= 2) {\n            $fibfib = 1;\n        } else {\n            $fibfib\
    \ = (fibfib($n-1) + fibfib($n-2) + fibfib($n-3));\n        }\n    }\n    return\
    \ $fibfib;\n}", "    my $fibfib = 0;\n    $fibfib++ if $n > 1;\n    $fibfib +=\
    \ 2 if $n >= 2;\n    $fibfib += 3 if $n >= 3;\n    return $fibfib;\n}\n</code>\n\
    <|/ a tags=performance,perl |>\n<| a dscore=1 tags=performance,perl |>\nA little\
    \ math:\n<code>\nfib(1) = 0\nfib(2) = 1\nfib(n) = (fib(n-1) + fib(n-2)) mod n\n\
    </code>\nSo the easiest way is to implement it in Python, for example, if you\
    \ have a function fib(n) that calculates fibonacci numbers:\n<code>\ndef fib(n):\n\
    \  if n <= 1:\n    return n\n  return fib(n-1) + fib(n-2)\n</code>\nThen you can\
    \ just write fib(n) in Perl, as in:\n<code>\nmy $fib;\neval {\n  $fib = fib($n);\n\
    };\nif($@) {\n  print \"$n is undefined\\n\";\n}\nelse {\n  print \"$fib\\n\"\
    ;\n}\n</code>\n(I hope you know that Perl can handle large integers natively.)\n\
    <|/ a |>\n<| c |>\nI do not know perl, but I suspect it will not be as fast as\
    \ python for fib(n). Try a perl fibfib(n) function instead - it seems to me that\
    \ it would be quite a bit slower.\n<|/ c |>\n<| c |>\nIf Perl can handle large\
    \ integers natively, then Python won't help much. And Perl is slower than Python\
    \ for small numbers, because Python is interpreted, Perl is compiled.\n<|/ c |>\n\
    <| a |>\n<code>\nfunction fib($n){\n    if($n<=1){\n        return $n;\n    }\n\
    \    if($n%2){\n        return fib(floor($n/2));\n    }\n    return fib(ceil($n/2));\n\
    }\n</code>\n<|/ a tags=performance,perl dscore=1 |>\n<| c |>\nI don't think this\
    \ algorithm would work for a number that isn't evenly divisible by two, e.g. `fib(0)`.\n\
    <|/ c |>\n<| a dscore=1 tags=performance,perl |>\n<code>", "    if($n =~ /^\\\
    d+$/) {\n        if ($n == 0) {\n            return 0\n        }\n        if ($n\
    \ == 1) {\n            return 0;\n        }\n        if ($n == 2) {\n        \
    \    return 1;\n        }\n        return fibfib($n-1) + fibfib($n-2);\n    }\n\
    \    return undef\n}\n</code>\n<|/ a tags=recursion,fibonacci,perl |>\n<| c |>\n\
    I thought it could be done more simply but your solution is very smart.\n<|/ c\
    \ |>\n<| c |>\nIn fact there are simpler solutions to compute fibonacci numbers\
    \ (and other numbers) that can give more performance than recursive calls... check\
    \ my answer ;)\n<|/ c |>\n<| a |>\nHere's a Perl 6 version of the recursive solution:\n\
    <code>", "    my $fibfib = 0;\n    $fibfib = $fibfib + $fibfib;\n    $fibfib =\
    \ $fibfib + $fibfib;\n    $fibfib = $fibfib + $fibfib;\n    return $fibfib;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nTo compute fib without recursion use the following\
    \ approach:\n<code>", "    if ($n) {\n        $fibfib[$n] ||= $n == 1 ? 0 : fibfib($n-1)\
    \ + fibfib($n-2);\n    }\n    return $fibfib[$n];\n}", "    return 0 if ($n <=\
    \ 1);\n    return 1 if ($n == 2);\n    return fibfib($n - 1) + fibfib($n - 2)\
    \ + fibfib($n - 3);\n}", "    my $result;\n    if ($n <= 0) {\n        $result\
    \ = $fibfib($n-1) + $fibfib($n-2) + $fibfib($n-3); \n    }\n    else {\n     \
    \   $result = $fibfib($n-1) + $fibfib($n-2) + $fibfib($n-3);\n    }\n    return\
    \ $result;\n}", "    my $fibfibseq = 0;\n    for(my $i = 0; $i <= $n; $i++) {\n\
    \        $fibfibseq += ($i ? ($fibfibseq - $fibfibseq + $fibfibseq % $fibfibseq)\
    \ : 0);\n    }\n    return $fibfibseq;\n}", "    return 0 unless defined($n);\n\
    \    return 0 if $n <= 1;\n    return 1 if $n <= 2;\n    return 1+fibfib($n-2)\
    \ + fibfib($n-3) if $n <= 3;\n    return fibfib($n-1) + fibfib($n-2);\n}", " \
    \   my $sum;\n    for ($n >= 3) { $sum += $n - 1; }\n    for ($n == 2) { $sum++;\
    \ }\n    return $sum;\n}", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n\
    \    return fibfib($n-2) + fibfib($n-3) + fibfib($n-4);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThank you for putting in the effort to put this together. I'm glad I\
    \ asked. You've saved me a lot of time debugging!\n<|/ c |>\n<| c |>\nOh, yes,\
    \ this is a good example of recursion. I'm still trying to wrap my head around\
    \ it. I appreciate the help.\n<|/ c |>\n<| a dscore=2 |>\nYou have to know that\
    \ fibfib() is recursive. When you write fibfib($n-1) you're calling the function\
    \ fibfib() with the value $n-1 + 1 which in turn calls the function again, which\
    \ calls the function again and so on. \nTo make things more clear, if you call\
    \ fibfib($n) you actually execute the function only once, and then you get the\
    \ result, and that's it.\n<|/ a tags=recursion,perl |>\n<| c |>\nI think you're\
    \ missing the point of my question. I'm asking why I don't get the same result\
    \ with each method of recursion. You're answering the second part of my question,\
    \ which I know now that I'm not doing the recursion correctly. The problem is\
    \ that I don't know what I am doing wrong.\n<|/ c |>\n<| a dscore=2 |>\nI see\
    \ three problems in your code.", "    my($fibfib);\n    $fibfib = 0;\n    foreach\
    \ my $i ( 0 .. $n - 1 ) {\n        $fibfib = $fibfib + $i;\n    }\n    return\
    \ $fibfib;\n}\n</code>\n<|/ a tags=algorithm,fibonacci,perl,sequence,arrays |>\n\
    <| c |>\nThis solution is very elegant!\n<|/ c |>\n<| c |>\nI understand this\
    \ solution. However, I do not agree that the OP's solution is inefficient because\
    \ it's using a lot of memory (although I could be wrong). Perl hashes use hashing\
    \ under the hood, so the fact that you're using a hash here to store the entire\
    \ sequence does not mean that you're using a hash structure to store all the numbers.\
    \ The actual issue here is that a lot of time is being spent in `fibfib`'s inner\
    \ loop. While it's true that this solution does not create any new hashes, it's\
    \ still an inefficient algorithm compared to the OP's original solution.\n<|/\
    \ c |>\n<| c |>\nThis is an answer to a different question than the one asked.\n\
    <|/ c |>\n<| c |>\nI believe this to be the most efficient. At least the array\
    \ is stored in memory.\n<|/ c |>\n<| c |>\nThis is very helpful. I wonder if it\
    \ would make sense to store the numbers in an array and just have a running total\
    \ of each number.\n<|/ c |>\n<| a tags=algorithm,fibonacci,perl,sequence,arrays\
    \ |>\nApart from the hash based solutions, here is a simple recursive solution:\n\
    <code>", "    if(!$n) {\n        return 0;\n    }\n    if($n == 1) {\n       \
    \ return 0;\n    }\n    if($n == 2) {\n        return 1;\n    }\n    return fibfib($n-1)\
    \ + fibfib($n-2) + fibfib($n-3);\n}", "    if ($n <= 2) {\n        return $n;\n\
    \    }\n    my $fib = 1;\n    for (my $i = 3; $i <= $n; $i += 2) {\n        $fib\
    \ *= $i;\n    }\n    return $fib;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
