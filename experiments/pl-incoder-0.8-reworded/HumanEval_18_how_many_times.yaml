name: HumanEval_18_how_many_times
language: pl
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times(\"\", \"a\")\n# 0\n# >>> how_many_times(\"\
  aaa\", \"a\")\n# 3\n# >>> how_many_times(\"aaaa\", \"aa\")\n# 3\nsub how_many_times\
  \ {\n    my($string, $substring) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&how_many_times;\n\
  \        if(eq_deeply($candidate->(\"\", \"x\"),0)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyxyxyx\", \"x\"\
  ),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  cacacacac\", \"cac\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(\"john doe\", \"john\"),1)) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $string =~ s/\\Q$substring//ig;\n    $string =~ tr/a//;\n    $string\
    \ =~ tr/a/a/ig;\n    $string =~ tr/a/a//ig;\n    $string =~ tr/a//ig;\n    $string\
    \ =~ tr/a//ig;\n    $string =~ tr/a//ig;\n    $string =~ tr/a//ig;\n    $string\
    \ =~ tr/a//ig;\n    return $string;\n}\n</code>\nI tested the code with input\
    \ from your code and found that it works.\n<|/ a tags=perl,substitution |>\n<|\
    \ a |>\nThis can be done in a single regex using positive lookahead and lookbehind:\n\
    <code>\n$string =~ s/(?<!a)a(?!a)//ig;\n</code>\n<|/ a tags=perl,substitution\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\n$string =~ s/(?<!a)a(?!a)//ig;\n</code>\n\
    <|/ a tags=perl,substitution |>\n<| a |>\nThis can be solved easily with a regex\n\
    <code>\n$string =~ s/(?<!a)a(?!a)//ig;\n</code>\n<|/ a tags=perl,substitution\
    \ dscore=0 |>\n<| c |>\nThis regex will fail to replace \"aab\" with empty string\n\
    <|/ c |>\n<| a |>\nThis can be done using positive lookahead and lookbehind assertion:\n\
    <code>\n$string =~ s/(?<=^|[^a])a(?=$|[^a])//ig;\n</code>\nExplanation:", '    my
    $count = 0; # Keep count of how many times each character appears', "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Za-z/A-Z/;\n    $string =~ tr/A-Za-z/A-Z/;\n\
    \    return 0 if $string eq $substring;\n    return 1 + how_many_times($string,\
    \ $substring);\n}", "    $string =~ s/^\\s*//;\n    $substring =~ s/^\\s*//;\n\
    \    if ($string =~ /^$substring/o) {\n        return 0;\n    }\n    $pos = 0;\n\
    \    $count = 1;\n    while ($pos <= length($string) - length($substring)) {\n\
    \        if (substr($string, $pos, length($substring)) eq $substring) {\n    \
    \        $count++;\n        }\n        $pos++;\n    }\n    return $count;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution using regular\
    \ expressions in Perl:\n<code>", "    my $count = 0;\n    $string =~ s/\\Q$substring//g;\n\
    \    $count += ($string =~ tr/a//);\n    $string =~ s/\\Q$substring//g;\n    $count\
    \ += ($string =~ tr/a//);\n    $string =~ s/\\Q$substring//g;\n    $count += ($string\
    \ =~ tr/a//);\n    return $count;\n}", "    my %substring_map = (\n        a =>\
    \ 0,\n        b => 0,\n        c => 0,\n        d => 0,\n        e => 0,\n   \
    \     f => 0,\n        g => 0,\n        h => 0,\n        i => 0,\n        j =>\
    \ 0,\n        k => 0,\n        l => 0,\n        m => 0,\n        n => 0,\n   \
    \     o => 0,\n        p => 0,\n        q => 0,\n        r => 0,\n        s =>\
    \ 0,\n        t => 0,\n        u => 0,\n        v => 0,\n        w => 0,\n   \
    \     x => 0,\n        y => 0,\n        z => 0\n    );\n    my $count = 0;\n \
    \   for (split //, $string) {\n        if (exists $substring_map{$substring})\
    \ {\n            $substring_map{$substring}++;\n        }\n    }\n    $count +=\
    \ scalar grep { $substring_map{$_} > 0 } keys %$substring_map;\n    return $count;\n\
    }", "    my $count = 0;\n    $string =~ tr/a-zA-Z0-9//cd;\n    while ($string\
    \ =~ m/$substring/) {\n        $count++;\n        $string =~ s/($substring)//;\n\
    \    }\n    $count;\n}", "    my $count = _find_string_count($string, $substring);\n\
    \    return $count;\n}", "    $string =~ /(?:$substring)/g;\n    return scalar\
    \ $&;\n}", "    my $count = 0;\n    my $i = 0;\n    my $length = length $string;\n\
    \    while ($i < $length) {\n        if ($string[$i] == $substring) {\n      \
    \      $count++;\n            $i++;\n        }\n        else {\n            ++$i;\n\
    \        }\n    }\n    return $count;\n}", "    my($i) = 0;\n    while($i <length($string)\
    \ && $i < length($substring)) {\n        if($string =~ /\\Q$substring\\E/) {\n\
    \            $i++;\n        }\n        else {\n            substr($string, 0,\
    \ length($substring));\n            $i = 0;\n        }\n    }\n    $i;\n}\n</code>\n\
    <|/ a tags=string,arrays,perl |>\n<| c |>\nThis would have better performance\
    \ and better readability, since you are not using `while` and `if` statements\
    \ inside the `for` loop and you are not using `grep`.\n<|/ c |>\n<| c |>\nActually,\
    \ this code doesn't work as intended. It counts the number of occurrences of the\
    \ substring in any string in the array. For example, \"aaaaa\" would return 3\
    \ instead of 2 since the substring \"a\" is present in three places.\n<|/ c |>\n\
    <| a |>\n<code>", "    my $i = 0;\n    $substring = \"\" unless defined($substring);\n\
    \    for (my $i = 0; $i <= length($string); $i++) {\n        $i++;\n        last\
    \ if (length($string) > ($i + $substring))\n            if (substr($string, $i,\
    \ length($substring)) = $substring);\n    }\n    return $i;\n}", "    my $count\
    \ = 0;\n    my $pos = 0;\n    while($string =~ s/$substring//) {\n        $count++;\n\
    \        $pos += length($1);\n    }\n    return $count;\n}", "    my @chars;\n\
    \    my $index = 0;\n    foreach my $ch (split('', $string)) {\n        if ($ch\
    \ eq $substring) {\n            push @chars, $index;\n        }\n        $index++;\n\
    \    }\n    return scalar(@chars);\n}", "    my $count = 0;\n    for ($string\
    \ =~ /($substring)/gi) {\n        $count += 1;\n    }\n    return $count;\n}",
  "    my $index = $string =~ s/^.*$substring//r;\n    return $index;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $substring =~ tr/A-Z/a-z/;\n    my $count = 0;\n    while($string\
    \ =~ /($substring)/ig) {\n        $count++;\n    }\n    return $count;\n}", " \
    \   my($found, $total);\n    my $counter = 0;\n    while($string =~ m/$substring/g)\
    \ {\n        $counter++;\n        $found += $counter;\n        $total++;\n   \
    \ }\n    return $total;\n}", '    my $count = 0;', "    my @array = ();\n    if\
    \ ($string eq $substring) {\n        push @array, 1;\n    } else {\n        $string\
    \ =~ s/\\Q$substring\\E//g;\n        my $i;\n        for (0 .. length($string)\
    \ - length($substring) - 1) {\n            $i = substr($string, $_, length($substring));\n\
    \            $i =~ s/\\Q$substring\\E//g;\n            push @array, $i;\n    \
    \    }\n    }\n    my $count = $#array + 1;\n    my $count_overlap = 0;\n    while\
    \ (--$count) {\n        if ($string[$count] eq $substring[0]) {\n            $count_overlap\
    \ += $count;\n            shift @array;\n            last if ($count == 0);\n\
    \        } else {\n            my $tmp;\n            foreach $tmp (@array) {\n\
    \                if ($tmp eq $string[$count]) {\n                    $count_overlap++;\n\
    \                    last if ($count == 0);\n                }\n            }\n\
    \        }\n    }\n    return $count_overlap;\n}\n</code>\n<|/ a tags=string,perl,algorithm\
    \ |>\n<| c |>\nYou say \"I doubt there is any module for it because it is not\
    \ really a task for which a module is needed\".  Does that mean that there is\
    \ nothing else I can use for this function?\n<|/ c |>\n<| c |>\n: Yes, it is only\
    \ a small part of what you need to do with this function. I just wanted to show\
    \ that there are multiple ways to solve this problem.\n<|/ c |>\n<| c |>\n\"Perl's\
    \ string processing routines are not particularly efficient for these kinds of\
    \ operations.\" -- The \"substring\" function can do a lot more than \"find all\
    \ occurrences of a substring in a string\".\n<|/ c |>\n<| a |>\nHere's my Perl\
    \ implementation:\n<code>", "    $string =~ s/\\Q$substring//g;\n    $string =~\
    \ tr/a//;\n    return scalar keys %counts;\n}", "    $substring = lc($substring);\n\
    \    my $i = 0;\n    my $n = length $string;\n    for(my $j = 0; $j < $n; $j++)\
    \ {\n        $i += (index($string, $substring, $j) == 0);\n    }\n    return $i;\n\
    }\n</code>\nAnd then you can implement the function how_many_times to do your\
    \ actual searching.\n<|/ a |>\n<| c |>\nThe function doesn't take into account\
    \ the lengths of the two strings, as requested in the question.\n<|/ c |>\n<|\
    \ c |>\nIt's not difficult to implement, just change the length of the strings\
    \ when counting the occurrences. I'll add an example in a sec.\n<|/ c |>\n<| c\
    \ |>\nI've added some code. I don't think it'll be as efficient as your solution\
    \ (especially when you start processing large strings), though.\n<|/ c |>\n<|\
    \ c |>\nThanks you!! I implemented your solution and it works, except that it\
    \ does not consider overlapping occurrences\n<|/ c |>\n<| c |>\nI'm confused.\
    \ How would you consider overlapping occurrences? The string `\"aaaa\"` has five\
    \ `a`s, so it matches the first three occurrences of `\"aaa\"`.\n<|/ c |>\n<|\
    \ a dscore=3 |>\nI believe this should work:\n<code>\nuse strict;\nuse warnings;\n\
    use feature 'say';\nuse Scalar::Util qw(looks_like_number);", "    $string =~\
    \ s/$substring//g;\n    return scalar grep {$_ eq $string} split //, $string;\n\
    }", "    return 0 unless $string =~ /($substring)/;\n    my $count = 0;\n    $string\
    \ =~ s/$substring//g;\n    $count += length($string);\n    $count += $string->looks_like_number()\
    \ ? 1 : 0;\n    $count += $string->looks_like_number(qw(1 2 3 4)) ? 1 : 0;\n \
    \   return $count;\n}", "    $string = \"$string\" unless $string;\n    $substring\
    \ = \"$substring\" unless $substring;\n    my $pos = 0;\n    my $i = 0;\n    while\
    \ ($pos < length($string)) {\n        $i++;\n        if (substr($string, $pos,\
    \ length($substring)) eq $substring) {\n            return $i;\n        }\n  \
    \      $pos += length($substring);\n    }\n    return 0;\n}", "    my $count =\
    \ 0;\n    for(split(//, $string)) {\n        my($char, $location) = @$_;\n   \
    \     for(split(//, $substring)) {\n            my($char_match, $location_match)\
    \ = @$_;\n            if( $char == $char_match and $location == $location_match\
    \ ) {\n                $count++;\n            }\n        }\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    while ($string =~ m/($substring)/g) {\n\
    \        $count++;\n    }\n    return $count;\n}", "    my $index = 0;\n    my\
    \ $count = 0;\n    while ($index < length($string)) {\n        if (substr($string,\
    \ $index, length($substring)) eq $substring) {\n            $count++;\n      \
    \  }\n        $index++;\n    }\n    return $count;\n}", "    $string = \"\" if\
    \ !defined($string);\n    $substring = \"\" if !defined($substring);\n    my $count\
    \ = 0;\n    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n    $substring\
    \ =~ tr/A-Z/a-z/;\n    while ($string =~ m/$substring/g) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    my $i = 0;\n    while ($string =~ m/$substring/i)\
    \ {\n        $i++;\n    }\n    return $i;\n}", "    $string =~ /\\b$substring\\\
    b/;\n    return $-[0]\n}", "    my($start, $end, $count, $last_occurance);\n \
    \   $start = 0;\n    $end = $string =~ tr/A-Za-z//;\n    $count = 0;\n    $last_occurance\
    \ = 0;\n    for (; $start < $end; $start++) { # Iterate through the string\n \
    \       my $substring_length = length($substring);\n        if (substr($string,\
    \ $start, $substring_length) eq $substring) {\n            $count++;\n       \
    \     my $overlap = $last_occurance + 1;\n            if ($overlap - $count >=\
    \ 0) {\n                return $overlap - $count;\n            }\n           \
    \ $last_occurance = $overlap - $count + 1; # Overlaping count is the last count\n\
    \        }\n    }\n    return $last_occurance;\n}", "    my $count = 0;\n    my\
    \ $len = length($string);\n    my $pos_start = $len;\n    my $pos_end = $len;",
  "    return 0 unless $string;\n    return 0 unless $substring;\n    return 0 if\
    \ substr($string, 0, length($substring)) == $substring;\n    return 0 if $substring\
    \ eq substr($string, -length($string));\n    return $string =~ tr/a/b/;\n}", " \
    \   my $count = 0;\n    for(my $i = 0; $i < length($string); $i++) {\n       \
    \ my $current_char = $string[$i];\n        if ($current_char =~ /$substring/)\
    \ {\n            $count++;\n            $current_char =~ s/$substring//;\n   \
    \     }\n    }\n    return $count;\n}", "    $string =~ /^$substring/o;\n    return\
    \ $-[0] if defined $string;\n    return 0;\n}", '    $string =~ tr/a-z/A-Z/;',
  '    my $count = 0;', "    my $i = 0;\n    while($string =~ s/^([$substring]++)/$i\
    \ . \"$1\\n\"/esx)\n    {\n        $i++;\n    }\n    return $i;\n}", "    my $count\
    \ = 0;\n    if ($string eq \"\") {\n        $count = 1;\n    } elsif (index($string,\
    \ $substring) > -1) {\n        $count++;\n    } elsif ($string =~ m/\\Q$substring\\\
    E/) {\n        $count++;\n    }", "    $string =~ s/$substring//g;\n    $string\
    \ =~ tr/a//;\n    return length($string);\n}\n</code>\n<|/ a tags=perl dscore=0\
    \ |>\n<| a tags=perl |>\n<code>", "    $string =~ tr/a-z/A-Z/;\n    $substring\
    \ =~ tr/a-z/A-Z/;\n    my $count = 0;\n    $string =~ /($substring)/;\n    $count\
    \ += ($1 ne \"\" && $1 ne \"0\") + 0;\n    $string =~ /($substring)/;\n    $count\
    \ += ($1 ne \"\" && $1 ne \"0\") + 0;\n    $string =~ /($substring)/;\n    $count\
    \ += ($1 ne \"\" && $1 ne \"0\") + 0;\n    return $count;\n}", "    $string =~\
    \ tr/a-z/A-Z/;\n    return 0 if $string eq \"\";\n    $substring =~ tr/a-z/A-Z/;\n\
    \    my $index = 0;\n    for (my $i = 0; $i <= length($string); $i++) {\n    \
    \    while ($i < length($string) && (substr($string, $i, 1) eq $substring)) {\n\
    \            $i++;\n        }\n        my $found = 1;\n        if ($i > 0) {\n\
    \            my $last_letter = substr($string, $i - 1, 1);\n            my $last_letter_index\
    \ = index($string, $last_letter);\n            if (substr($string, $i - 1, 1)\
    \ ne substr($substring, 0, 1)) {\n                $found = 0;\n            }\n\
    \        }\n        if (!$found) {\n            $index++;\n        }\n    }\n\
    \    return $index;\n}", "    $substring =~ tr/a-z/A-Z/;\n    my $count = 0;\n\
    \    $string =~ /($substring)/;\n    $count += ($#_ > $#_ + 1 ? ($#_ + 1) : 0);\n\
    \    return $count;\n}", "    return 0 if length $string == 0;\n    my $count\
    \ = 0;\n    my @matches = (split //, $string);\n    foreach my $match (@matches)\
    \ {\n        ++ $count if $match eq $substring;\n    }\n    return $count;\n}",
  "    $string =~ s/^\\s+|\\s+$//g;\n    $substring =~ s/^\\s+|\\s+$//g;\n    return\
    \ 0 if length($string) == 0;\n    $substring =~ tr/a-z/A-Z/;\n    return 0 if\
    \ length($substring) == 0;\n    return 0 if $substring eq '';\n    return 0 if\
    \ $string eq $substring;\n    my $count = () = ($string =~ /($substring)/ig);\n\
    \    return $count;\n}", "    $substring =~ s/$string//g;\n    my $total_matches\
    \ = 0;\n    for my $match (@{$_[0]}) {\n        if (index($match, $substring)\
    \ > -1) {\n            $total_matches += 1;\n        }\n    }\n    return $total_matches;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/A-Z/a-z/;\n    my $count\
    \ = 0;\n    while ($string =~ /($substring)/ig) {\n        $count++;\n       \
    \ $string =~ s/$substring/$substring/g;\n    }\n    return $count;\n}", "    $string\
    \ =~ m/($substring)/;\n    return ($-[0]) + 1;\n}", "    $substring =~ s/^\\s+//;\n\
    \    $substring =~ s/\\s+$//;\n    my $count = 0;\n    for (split //, $string)\
    \ {\n        if ($_ eq $substring) {\n            $count += 1;\n        }\n  \
    \  }\n    return $count;\n}", '    my $total = 0;', "    return 1 if !length $string;\n\
    \    return 1 if !length $substring;", "    $string = $string =~ s/ //g;\n   \
    \ $substring = $substring =~ s/ //g;\n    my $count = 0;\n    while ($string =~\
    \ /($substring)/ig) {\n        $count++;\n    }\n    return $count;\n}", "   \
    \ $string .= \"\";\n    $substring .= \"\";\n    my $count = 0;\n    my $string_length\
    \ = $string->length;\n    my $substring_length = $substring->length;\n    for\
    \ (my $i = 0; $i <= $string_length - $substring_length; $i++) {\n        $count\
    \ += 1 if (substr($string, $i, $substring_length) == $substring);\n    }\n   \
    \ return $count;\n}", '    my $count = 0;', "    return $string =~ /^($substring){2,}$/\
    \ ? $& : -1;\n}", '    $string =~ s/^\s*|\s*$//g;', "    my $count = 1;\n    $substring\
    \ =~ s/^\\s+//;\n    $string =~ s/^\\s+//;\n    while (index $string, $substring)\
    \ {\n        $count++;\n        $string =~ s/^\\s+//;\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    $string =~ s/($substring)//g;\n    while (length($string)\
    \ > 0) {\n        $count += 1;\n        $string =~ s/($substring)//g;\n    }\n\
    \    return $count;\n}", '    my $num_times = 0;', "    $string =~ s/^\\s*//;\n\
    \    $substring =~ s/^\\s*//;\n    $substring =~ s/\\s*$//;\n    return ($string\
    \ =~ /$substring/g) ? length($substring) : 0;\n}", "    return 0 if $string eq\
    \ $substring and $string =~ /^$substring$/ and $string =~ /($substring)$/;\n \
    \   my $count = 0;\n    for ($string =~ /$substring/ig) {\n        $count += 1;\n\
    \    }\n    return $count;\n}", "    return 0 if ! $string;\n    return 1 if !\
    \ $substring;\n    my $n = 0;\n    my $j = 0;\n    while($j < length($string))\
    \ {\n        my $match;\n        for(my $i = 0; $i < length($substring) && $i\
    \ < length($string) - $j; ++$i) {\n            $match = $string[$i] == $substring[$i];\n\
    \        }\n        $n += $match ? 1 : 0;\n        $j += $match ? 1 : 0;\n   \
    \ }\n    return $n;\n}", "    if ($string eq \"\") {\n        return 0;\n    }\n\
    \    my $i = 0;\n    my $count = 0;\n    my $pos_start_index = 0;\n    my $pos_end_index\
    \ = 0;\n    while ($pos_end_index < length($string) && $i < 1000) {\n        $pos_start_index\
    \ = 0;\n        $pos_end_index = 0;\n        while ($pos_end_index < length($string)\
    \ && $pos_end_index >= $pos_start_index) {\n            $pos_end_index = index($string,\
    \ $substring, $pos_end_index + 1) +1;\n            $pos_start_index = $pos_end_index;\n\
    \        }\n        $count++;\n        $i++;\n    }\n    return $count;\n}", " \
    \   my $count = 0;\n    $string =~ /($substring)/gi;\n    while (my $match = $string\
    \ =~ /($substring)/gi) {\n        $count++;\n        $string =~ s/($match)//ig;\n\
    \    }\n    return $count;\n}", "    my $count = 0;\n    $string =~ /($substring)/;\n\
    \    $count++ while $string =~ /($substring)/g;\n    return $count;\n}", "   \
    \ my ($count_1, $count_2) = ();\n    my $start_index = 0;\n    my $end_index =\
    \ $string->len;\n    my $match_count = 0;\n    while($end_index > $start_index)\
    \ {\n        $start_index = $end_index;\n        $end_index = $end_index - length($substring);\n\
    \        if (index($string, $substring, $start_index, $end_index)) {\n       \
    \     $match_count++;\n            $count_1 = $start_index + $match_count - length($substring);\n\
    \            $count_2 = $end_index;\n            last;\n        }\n    }\n   \
    \ if ($match_count > 1) {\n        $count_2 = $start_index + $match_count - length($substring);\n\
    \    }\n    return $count_1;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis is\
    \ my solution:\n<code>", "    my $count = 0;\n    $string =~ tr/a-z//cd;\n   \
    \ $substring =~ tr/a-z//cd;\n    while (length($string) > length($substring) &&\
    \ $string =~ m/$substring/g) {\n        $count += 1;\n        $string =~ s/$substring//g;\n\
    \    }\n    return $count;\n}", "    my $count = () = $string =~ /$substring/g;\n\
    \    return $count;\n}", "    my ($counter,$overlap) = (1,0);\n    $string =~\
    \ /($substring)/;\n    $counter += 1;\n    while ($string =~ /($substring)/) {\n\
    \        $counter += 1;\n        $overlap += 1;\n    }\n    return $counter +\
    \ $overlap;\n}", "    $substring =~ tr/A-Z/a-z/;\n    return 0 if length($string)\
    \ == 0;\n    return 0 if length($substring) == 0;\n    return 0 if !length $string;\n\
    \    return 0 if !length $substring;\n    return $string =~ /\\b$substring\\b/i;\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,perl |>\nHere is my take on it based\
    \ on David's answer:\n<code>", "    my $n = 0;\n    my $string_length = $string->length;\n\
    \    my $substring_length = $substring->length;\n    while ($n <= $string_length\
    \ - $substring_length) {\n        if (substr($string, $n, $substring_length) ==\
    \ $substring) {\n            ++$n;\n        }\n        else {\n            last;\n\
    \        }\n    }\n    return $n;\n}", "    my $string_length = length($string);\n\
    \    my $substring_length = length($substring);", "    my($num_occ) = 0;\n   \
    \ while ($string =~ m/($substring)/ig) {\n        $num_occ++;\n    }\n    return\
    \ $num_occ;\n}", "    my $total_chars = length($string);\n    my $count = 0;\n\
    \    for my $i (0 .. length($string) - length($substring)) {\n        if substr($string,\
    \ $i, length($substring)) == $substring {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}", "    \n    # Count occurrences of the substring\
    \ in the string.\n    my $occurrences = $string =~ /($substring)/;\n    $occurrences\
    \ = 0 if $occurrences == -1;\n    $occurrences++;", "    my $count = 0;\n    my\
    \ $string_length = $string->length;\n    my $sub_length = $substring->length;\n\
    \    my $i = 0;", "    $string =~ s/^$substring//;\n    $string =~ s/$substring//;\n\
    \    $string =~ tr/a-z/A-Z/;\n    my ($count);\n    $count += $string =~ tr/A-Z/a-z/;\n\
    \    $count += $string =~ tr/a-z/A-Z/;\n    return $count;\n}", "    my $count\
    \ = 0;\n    $string =~ m/^$substring/; # Match whole string with substring.\n\
    \    # Iterate through all possible positions of the substring and count the number\
    \ of times it appears in the string.\n    # Iterate through each of the substrings\
    \ possible positions in the string and check if it appears in $string\n    # Iterate\
    \ through each of the substrings possible positions in the string and check if\
    \ it appears in $string\n    my $len = length($substring);\n    my $i = 0;\n \
    \   foreach my $pos (1..$len) {\n        $i = index($string, $substring, $pos);\n\
    \        if($i >= 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    $string =~ /($substring)/g;\n    $count++ while $string;\n\
    \    return $count;\n}", "    my @counts = ();\n    my $count = 0;\n    while($string\
    \ =~ m/($substring)/ig) {\n        $count++;\n        push(@counts, $count);\n\
    \    }\n    return $counts[0];\n}", "    my $n = 0;\n    $string =~ /($substring)/g;\n\
    \    $n += $1 if (defined $1);\n    $string =~ /($substring)/g;\n    $n += $1\
    \ if (defined $1);\n    return $n;\n}", "    $string =~ /($substring)/;\n    return\
    \ scalar;\n}", "    $string =~ tr/A-Za-z/A-Za-z/;\n    return $string =~ /(?:^|\\\
    W)($substring)(?:$|\\W)/igc\n      ? $string =~ /(?:^|\\W)($substring)(?:$|\\\
    W)/igc \n        ? $-[0]+1 \n        : 0\n      : 0;\n}", "    my($count) = 0;\n\
    \    for(my $i = 0 ; $i < length($string) ; $i++) {\n        for(my $j = 0 ; $j\
    \ < length($substring) ; $j++) {\n            if($string[$i] == $substring[$j])\
    \ {\n                $count++;\n                last if $j == length($substring)\
    \ - 1;\n            }\n        }\n    }\n    return $count;\n}", "    $string\
    \ =~ s/^\\s+//;\n    $substring =~ s/^\\s+//;\n    if ($string =~ /^\\Q$substring\\\
    E$/) {\n        my $length = length($string);\n        my $pos = rindex($string,\
    \ $substring);\n        if ($pos == -1 || $pos != $length) {\n            die(\"\
    $substring not found at position $pos in $string\");\n        }\n        return\
    \ 1 + $pos - 1;\n    }\n    die(\"$substring not found in $string\");\n}", " \
    \   my $count = 0;\n    my @matches = $string =~ /(.)(\\1*)$/;\n    for my $match\
    \ (@matches) {\n        $count++ if $string =~ /$match/;\n    }\n    return $count;\n\
    }", "    $string =~ tr/aeiouAEIOU/aeiouAEIOU/;\n    return length($string) - length($&);\n\
    }", "    my $count = 0;\n    my $pos = 0;\n    while ($pos < length($string))\
    \ {\n        my $match = 0;\n        if ($pos = index($string, $substring, $pos))\
    \ {\n            $count++;\n            $pos = $pos + length($substring);\n  \
    \          $match = 1;\n        }\n        $pos = $pos + 1;\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a |>\n<| a |>\nAnother approach:\n<code>", "    $substring\
    \ =~ s/^\\s+//;\n    $substring =~ s/\\s+$//;\n    my $count = 0;\n    foreach\
    \ my $sub (split //, $substring) {\n        $count += $string =~ /($sub)/ig;\n\
    \    }\n    return $count;\n}", "    if ($string !~ /^$substring$/) {\n      \
    \  print \"$string does not contain $substring\\n\";\n        return 0;\n    }\n\
    \    $string =~ /(?:$substring){2,}/;\n    print \"$substring occurs $1 times\\\
    n\";\n    return $1;\n}", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n\
    \    $len_string = length($string);\n    $len_substring = length($substring);",
  "    my $substring_count = 0;\n    while ($string =~ /$substring/g) {\n        $substring_count++;\n\
    \    }\n    return $substring_count;\n}", "    my($index, $start);\n    my $count\
    \ = 0; # How many times $substring has been seen in $string.\n    for (my $i =\
    \ 0; $i <= length($string); $i++) {\n\t$index = $i;\n\t$start = $i;\n\twhile($index\
    \ < length($string) && substr($string, $index, 1) eq $substring) {\n\t\t$index++;\n\
    \t\t$count++;\n\t}\n\t$index = $i;\n\t$start = $i;\n\twhile($index > 0 && substr($string,\
    \ $index-1, 1) eq $substring) {\n\t\t$index--;\n\t\t$count++;\n\t}\n\treturn $count;\n\
    }", '    my $count = 0;', "    return 0 unless $string;\n    return 0 if $substring\
    \ eq \"\";", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;", " \
    \   my $n = $string->length();\n    my $substring_count = $string->index($substring);\n\
    \    return 0 if $substring_count == 0;\n    $string->substr($substring_count)\
    \ =~ tr/0/1/;\n    return $substring_count;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nAm I correct in assuming that you use `$string->char_indices()` to find\
    \ out where the substring begins? This doesn't appear to work with `$string =\
    \ 'a ab c ab c ab'`, which I believe is what the question asks for.\n<|/ c |>\n\
    <| a dscore=2 |>\nHere's an answer that doesn't use index() and uses only substr().\n\
    <code>\nmy $str = 'abc abc abc abc';\nmy $sub = 'abc';", "    my($start_pos) =\
    \ pos( $string );\n    my($end_pos) = pos( $string, $start_pos );\n    \n    #\
    \ no substrings found\n    if ( $end_pos < 0 ) {\n        return 0;\n    }", '    $string
    .= $substring;', "    my @substrings = map { $string =~ /($_)/ig } split \"|\"\
    , $substring;\n    return scalar grep {\n        exists $substrings{$_}\n    }\
    \ keys %$substrings;\n}", "    my(@counts) = ();\n    my($start_index) = -1;",
  "    return 0 unless ($string);\n    return 0 unless ($substring);", "    $string\
    \ =~ s/^\\s+//;\n    $string =~ s/\\s+$//;\n    my $count = 0;\n    my @positions\
    \ = map { substr($_, 0, 1) } (0 .. length($string) - length($substring) + 1);\n\
    \    for my $pos (@positions) {\n        if (index($string, substr($substring,\
    \ 0, $pos)) == 0) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my($length) = length($string);\n    my($current_index) = length($substring);\n\
    \    my($count = 0;)\n    while ($current_index >= 0) {\n        # Find first\
    \ index\n        my($left_index) = index($string, $substring, $current_index);\n\
    \        # If substring found return count\n        if ($left_index <= 0) {\n\
    \            push, $count;\n            $count = 0;\n            # Reinitialize\
    \ current index\n            $current_index = $length;\n            # Move to\
    \ the beginning of next substring\n            $current_index -= length($substring);\n\
    \        } else {\n            $count += $left_index - $current_index + 1;\n \
    \           # Move to index of next substring\n            $current_index -= $left_index\
    \ + length($substring);\n        }\n    }\n    push, $count;\n    return scalar(@counts);\n\
    }", "    my $count = 0;\n    $string =~ tr/A-Za-z//d;\n    $substring =~ tr/A-Za-z//d;\n\
    \    foreach my $c ($string, $substring) {\n        next if $c eq '' || !$c;\n\
    \        $count += $c eq $substring ? 1 : 0;\n    }\n    return $count;\n}", " \
    \   $string =~ /($substring)/g;\n    my $n = $1 ? $1 : 0;\n    return $n;\n}\n\
    </code>\n<|/ a tags=count,perl,count,string |>\n<| a dscore=4 |>\nUsing Tie::IxHash\
    \ for hashing will make searching a lot faster:\n<code>", "    my $i = 0;\n  \
    \  while($i < length($string) && $i < length($substring)){\n        if(substr($string,$i,1)\
    \ eq substr($substring,0,1) ){\n            $i++;\n        } else {\n        \
    \    $i = 0;\n        }\n    }\n    return $i;\n}", "    return 0 unless defined($string);\n\
    \    return 0 unless defined($substring);", "    $string =~ /($substring)/g;\n\
    \    return scalar keys %$string;\n}", "    $string =~ tr/a-z//cd;\n    $substring\
    \ =~ tr/a-z//cd;\n    return scalar grep { $string =~ /$substring/i };\n}", " \
    \   my $count = 0;\n    $string =~ /(?:^|[^^])$substring(?:$|[^^])/;\n    $count++\
    \ while $string =~ /(?:^|[^^])$substring(?:$|[^^])/;\n    return $count;\n}",
  "    $string =~ s/^\\s+|\\s+$//g;\n    $substring =~ s/^\\s+|\\s+$//g;\n    return\
    \ $string =~ /^(?:(?=(?:.{1})?$substring))+$/ ? length($string) - length($&) +\
    \ 1 : 0;\n}", "    return 0 unless $string;\n    return 0 unless $substring;\n\
    \    return 0 if $string eq $substring;\n    return $string =~ tr/A-Z/a-z/;\n\
    \    my $count = 0;\n    $string =~ tr/a-z/A-Z/;\n    for my $i (0..$#string)\
    \ {\n        last if ($i == $#string);\n        if ($string[$i] eq $substring)\
    \ {\n            ++$count;\n        }\n    }\n    return $count;\n}", "    $string\
    \ =~ m!^(?:(.*)($substring))$!s;\n    return length($1) + (length($string) - length($2))\
    \ - 1;\n}", "    $string =~ /^$substring/i;\n    return $-[0] if $string;\n  \
    \  return 0;\n}", "    $substring =~ tr/a-z/A-Z/;\n    my @counts;", '    my($count,
    $found) = (0, 0);', "    my $count = 0;\n    $string =~ s/$substring//ig;\n  \
    \  while ($string =~ s/$substring//ig) {\n        $count++;\n    }\n    return\
    \ $count;\n}", "    my $count;\n    if ($string =~ /($substring)/) {\n       \
    \ $count++;\n    }\n    foreach my $start (0 .. length($string) - length($substring))\
    \ {\n        my $slice = $string =~ /(.{$start})($substring)/;\n        if ($slice\
    \ && $slice =~ /^(.{$length})$/) {\n            $count += $1 + 1;\n        }\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a tags=string,perl,regex |>\n<| a\
    \ dscore=1 |>\n<code>", "    my $total_count = 0;\n    $string =~ tr/A-Za-z/A-Z/;\n\
    \    $substring =~ tr/A-Za-z/A-Z/;\n    my $count = () = $string =~ /$substring/g;\n\
    \    $count += () = $string =~ /$substring/g;\n    $count += () = $string =~ /$substring/g;\n\
    \    $count += () = $string =~ /$substring/g;\n    $total_count += $count;\n \
    \   return $total_count;\n}", "    my $count = 0; # Initialization is required,\
    \ so we declare it here\n    $substring =~ s/^\\s*//; # Trim leading whitespace\n\
    \    $substring =~ s/\\s*$//; # Trim trailing whitespace\n    my $index = 0; #\
    \ Initialize index\n    foreach my $char (split //, $string) {\n        if ($char\
    \ eq $substring) {\n            $index++;\n        }\n        else {\n       \
    \     $index = 0;\n        }\n        $count++ if $index % 2 != 0;\n    }\n  \
    \  return $count;\n}", "    $string =~ /($substring)/i;\n    return $1 + 1;\n}",
  "    my $count = 0;\n    $string =~ s/($substring)/$1/g;\n    for($string) {\n \
    \       ++$count if m/($substring)/;\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    my $length = length($string);\n    my $start_index = 0;\n    while\
    \ ($start_index <= $length) {\n        if (substr($string, $start_index, length($substring))\
    \ =~ /$substring/) {\n            $count += 1;\n        }\n        $start_index++;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for\
    \ your answer. Yes I did misunderstand your question. After some more digging\
    \ I found out that what I was looking for is called \"Longest Common Substring\"\
    . Hence this answer was helpful. Thank you.\n<|/ c |>\n<| c |>\nIt's not an algorithm\
    \ I understand well, but a description of how to solve this problem (from Wikipedia:\
    \ https://en.wikipedia.org/wiki/Longest_common_substring_problem). I suppose it's\
    \ better than the other answers.\n<|/ c |>\n<| c |>\nThe link to Wikipedia is\
    \ wrong, it goes to a page which says about the [longest common substring problem](https://en.m.wikipedia.org/wiki/Longest_common_substring_problem),\
    \ which in turn is basically the same as this answer, but with some more description.\
    \ This answer is not an actual algorithm and I would have downvoted it.\n<|/ c\
    \ |>\n<| c |>\nHi, I do not know why you got downvoted either, so thanks for pointing\
    \ out my mistake.\n<|/ c |>\n<| c |>\n: Thanks for pointing it out, I edited the\
    \ answer. I also added a link to Wikipedia where I found this answer.\n<|/ c |>\n\
    <| a tags=python,algorithm,string dscore=2 |>\nYou could try something like this.\n\
    <code>\ndef find_substring(string, sub_string):\n    index = string.find(sub_string)\n\
    \    found = 0\n    count = 0\n    while index != -1:\n        found = 1\n   \
    \     for m in range(index + 1, len(string)):\n            if string[m] == sub_string[count]:\n\
    \                found = 0\n            else:\n                found = 1\n   \
    \             break\n        if found == 1:\n            count += 1\n        index\
    \ = string.find(sub_string, index + 1)\n    return count\n</code>\n<|/ a |>\n\
    <| a |>\nIn your case you can try something like:\n<code>\ndef how_many_times(string,\
    \ substring):\n    found = 0\n    for m in range(len(string)):\n        if string[m]\
    \ == substring[0]:\n            found = 1\n        else:\n            if found\
    \ == 1:\n                found = 0\n            else:\n                found =\
    \ 1\n                break\n    if found == 1:\n        return 1 + how_many_times(string[1:],\
    \ substring)\n", "    $string .= $substring;\n    $string =~ s/\\Q$substring//g;\n\
    \    length($string) - length($string) - length($string) - length($string);\n}",
  "    $string =~ tr/a-zA-Z//d;\n    my $i = 0;\n    my $count = 0;\n    my $index\
    \ = 0;\n    while($i <= length($string) - length($substring)) {\n        my $j\
    \ = index($string, $substring, $index);\n        if($j eq -1) {\n            $i\
    \ = length($string) - length($substring);\n        } else {\n            $count++;\n\
    \            $index = $j + length($substring);\n        }\n        $i++;\n   \
    \ }\n    return $count;\n}", "    $substring = lc $substring;\n    return $string\
    \ =~ /($substring)+/g ? (length($&) + 1) : 0;\n}", '    $string =~ tr/a-z/A-Z/;',
  "    $string =~ tr/\\0//d;\n    $substring =~ tr/\\0//d;\n    return scalar grep\
    \ (\n        defined $string && defined $substring ? $string eq $substring : $string\
    \ eq $substring,\n        grep($string, split //, $string)\n    );\n}\n</code>\n\
    The sub how_many_times uses the grep function to count the number of times a given\
    \ string can be found in the original string. The subroutine, split is used to\
    \ split the input string into an array of single characters, and then grep is\
    \ used to filter out those strings containing other characters than single characters.\n\
    <|/ a dscore=1 tags=perl,string,algorithm |>\n<| c |>\nYes, it can be done very\
    \ easily, but it is not efficient (O(n^2) in fact). The problem is more complicated,\
    \ and it is hard to write a correct solution (at least to me).\n<|/ c |>\n<| a\
    \ |>\nThis should do it:\n<code>", "    my $count = 0;\n    while($string =~ /\\\
    b$substring\\b/ig) {\n        $count++;\n    }\n    return $count;\n}", "    \n\
    \    $string =~ m/^$substring/;\n    return $-[0];\n}", "    my(@match);\n   \
    \ $string =~ /($substring)/g;\n    my $count = scalar(@match);\n    return $count;\n\
    }", "    $string =~ s/^\\s+|\\s+$//;\n    $substring =~ s/^\\s+|\\s+$//;\n   \
    \ return 0 if $string eq \"\";\n    return 0 if $substring eq \"\";\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n    my(@matches);\n    $string\
    \ =~ s/($substring)/++$matches[0]/e;\n    return @matches ? $matches[0] : 0;\n\
    }", "    my $string_length = length $string;\n    my $substring_length = length\
    \ $substring;\n    my $times = 0;\n    my $last_position = 0;\n    for (my $i\
    \ = 0; $i <= $string_length; $i++) {\n        if (substr($string, $i, $substring_length)\
    \ == $substring) {\n            $times++;\n            $last_position = $i;\n\
    \        }\n    }\n    return $times;\n}", "    my @substring_positions = ();\n\
    \    for (my $i = 0; $i <= length($string); $i++) {\n        my $pos = index($string,\
    \ $substring, $i);\n        if ($pos == -1) {\n            push @substring_positions,\
    \ $i;\n        } else {\n            push @substring_positions, $pos;\n      \
    \  }\n    }\n    my $num_substrings = scalar(@substring_positions);\n    my $total_substrings\
    \ = scalar(@substrings);\n    if ($num_substrings > $total_substrings) {\n   \
    \     return $total_substrings - $num_substrings;\n    }\n    else {\n       \
    \ return $num_substrings;\n    }\n}", "    $string =~ tr/a//d;\n    my $count\
    \ = $string =~ /$substring/ig;\n    return $count;\n}", "    my $count = 0;\n\
    \    my $pos = 0;\n    while($pos <= length($string)) {\n        my $end_pos =\
    \ index($string, $substring, $pos);\n        if($end_pos == -1) {\n          \
    \  $end_pos = length($string);\n        }\n        $count += ($end_pos - $pos);\n\
    \        $pos = $end_pos + 1;\n    }\n    return $count;\n}", "    my $cnt;\n\
    \    $cnt += index($string, $substring);\n    $cnt += index($string, uc $substring);\n\
    \    $cnt += index($string, $substring, 2);\n    return $cnt;\n}", "    my($start,\
    \ $end) = (0, length($string));\n    my $count = 0;\n    while ($start < $end)\
    \ {\n        if (substr($string, $start, 1) eq $substring) {\n            $count++;\n\
    \            $start++;\n        } else {\n            $start++;\n        }\n \
    \   }\n    return $count;\n}", '    my($i, $count_substring, $count);', "    $string\
    \ =~ m/$substring/g;\n    return $-[0]\n}", "    $string =~ tr/a//d;\n    my $length\
    \ = $string =~ tr/a//d; # Length of original string\n    my $count = 0;\n    my\
    \ $index = 0;\n    for (my $i=0; $i < $length; $i++) {\n        if (($index >=\
    \ 0) and ($string[$i] == $substring[$index])) {\n            $count++;\n     \
    \       $index++;\n        }\n    }\n    return $count;\n}", "    my $i = 0;\n\
    \    while($string =~ m/($substring)/ig) {\n        $i += 1;\n    }\n    return\
    \ $i;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a great answer, but you should probably\
    \ add some explanation, especially because you've used the term overlapping when\
    \ you mean overlapping matches (i.e. the count of how many times the substring\
    \ was found in other strings). You might also explain the `/g` flag which means\
    \ global (meaning each match is considered)\n<|/ c |>\n<| c |>\nThis code counts\
    \ overlapping matches because of the global modifier. I wouldn't have written\
    \ this without it.\n<|/ c |>\n<| c |>\nI thought this was a good solution, but\
    \ the performance isn't good. Over a million lines of text the regex becomes very\
    \ slow.\n<|/ c |>\n<| c |>\nI suspect this solution is slow, since it has to loop\
    \ over all matches. If the match is at the start or end of a line, the search\
    \ ends early.\n<|/ c |>\n<| a tags=perl,regex |>\nYou could try using regex split:\n\
    <code>\n$str = join(\"|\", split(//, $str));\n</code>\nThat will create all possible\
    \ combinations of matching letters. Then you can just do a count() on that string:\n\
    <code>\nmy $count = () = $str =~ /(?:$str)/g;\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a |>\nYou can use Text::AutoPairs to generate all combinations and then count\
    \ the matches.\n<code>\nuse strict;\nuse warnings;\nuse Text::AutoPairs;", " \
    \   $string =~ tr/A-Za-z0-9_//cd;\n    $substring =~ tr/A-Za-z0-9_//cd;\n    return\
    \ scalar((grep { $string =~ /./ig && $substring =~ /./ig } split //, $string x\
    \ $substring));\n}", "    my $count = () = $string =~ /$substring/g;\n    return\
    \ $count if defined $count;\n    return 0;\n}\n</code>\nTo make it work even for\
    \ strings that don't contain any of the $substrings, just add boundary conditions:\n\
    <code>", "    my $count = 0;\n    my $position = 0;\n    while ($position != -1)\
    \ {\n        $position = index($string, $substring, $position);\n        if ($position\
    \ != -1) {\n            $count++;\n            $position++;\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my $index = 0;\n    while ($index\
    \ <= length($string) - length($substring) + 1) {\n        my $match_length = length($substring);\n\
    \        my $match_string = substr($string, $index, $match_length);\n        if\
    \ ($match_string =~ $substring) {\n            $count++;\n        }\n        $index\
    \ += $match_length;\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>\nmy $str = \"aaa\";\nmy $len = 3;\nmy $str1 = \"aaaa\";\nmy $str2\
    \ = \"aa\";\nmy $str3 = \"a\";", "    $string =~ /(?<=[^$substring])(?=[$substring])/g;\n\
    \    return scalar $-[0];\n}", "    my $count = 0;\n    if ($string eq \"\") {\n\
    \        $count = 0; # No need to find an empty string.\n    } elsif ($string\
    \ =~ m/\\Q$substring/) {\n        $count++;\n    } elsif ($string =~ m/\\Q$substring\\\
    E/) {\n        $count++;\n        $count++ if $string =~ m/\\Q$substring(?=\\\
    E)/;\n    } elsif ($string =~ m/\\Q$substring(?=$|$)/) {\n        $count++;\n\
    \        $count++ if $string =~ m/\\Q$substring(?!\\E)/;\n    } elsif ($string\
    \ =~ m/\\Q$substring(?!$|$)/) {\n        $count++;\n        $count++ if $string\
    \ =~ m/\\Q$substring(?=\\E)/;\n    } else {\n        my $length = $string =~ tr/a-zA-Z0-9//;\n\
    \        $count = $length if $length > 0;\n    }\n    $count;\n}", "    my($start,\
    \ $length) = pos($string);\n    my($match, $count_of_matches);", "    $string\
    \ =~ s/$substring//g;\n    return $-[0] + 1;\n}", "    my $count;\n    $count\
    \ = 0;\n    for($string.$substring){\n        $count++;\n    }\n    return $count;\n\
    }", "    my $matches = 0;\n    $string =~ s/$substring//;\n    return $matches\
    \ + ($string =~ tr/a//);\n}", "    my $count = 0;\n    foreach my $char (split\
    \ //, $string) {\n        if ($char eq $substring) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my($i, $j, $result) = 0;\n   \
    \ $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;", "    $string =~ s/$substring//ig;\n\
    \    $string =~ s/^$substring//ig;\n    return $string =~ s/$substring//ig;\n}",
  "    my $count = 0;\n    $string =~ tr/a-z/A-Z/;\n    while (length($string) > 0)\
    \ {\n        my $pos = index($string, $substring);\n        if ($pos > 0) {\n\
    \            $count++;\n            $string =~ substr($string, 0, $pos);\n   \
    \     } else {\n            last;\n        }\n    }\n    $count;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    my $count = 0;\n    while ($string =~ /$substring/g) {\n\
    \        $count += 1;\n    }\n    return $count;\n}", "    $string =~ m/$substring/g;\n\
    \    return $string =~ s/$substring/@counts//g;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    my $count = grep { $_ eq $substring } keys %{ uc $string };\n    return $count\
    \ if defined $count;\n    return 0;\n}", "    my $count = substr_count($string,\
    \ $substring);\n    $count += ($string =~ /($substring)/ig);\n    $count;\n}\n\
    </code>\n<|/ a tags=count,perl,substring |>\n<| a tags=count,perl,substring |>\n\
    This would also work:\n<code>\nuse String::Anchor qw(anchor_substring);", "  \
    \  $substring =~ tr/a-z/A-Z/;\n    $string = $string if $string =~ /$substring/;\n\
    \    $string =~ tr/A-Za-z/A-Z/;\n    $string =~ tr/A-Za-z/A-Z/;\n    $string =~\
    \ tr/A-Za-z/A-Z/;\n    return $string =~ s/^$substring//;\n}\n</code>\nNote that\
    \ this doesn't handle cases when $substring occurs only once in the string.  If\
    \ you want to handle the case when $substring occurs only once in the string,\
    \ you need to rewrite how_many_times so that it uses the original algorithm for\
    \ how_many_times, but it also needs to keep track of the number of times $substring\
    \ occurred.  It doesn't matter much whether the algorithm uses the algorithm for\
    \ how_many_times or the algorithm for how_many_times_original.  You only need\
    \ to worry about the case where $substring occurs multiple times in the string.\n\
    Here is a sample program that demonstrates how to use the above functions.\n<code>\n\
    use strict;\nuse warnings;", "    my $count = $string =~ s/$substring/$substring/ig;\n\
    \    return $count;\n}", "    $substring =~ s/^\\s+//;\n    $substring =~ s/\\\
    s+$//;\n    my $count = 0;\n    $string =~ /($substring)/;\n    return $count\
    \ + 1;\n}", "    my $count = 0;\n    for (split(//, $string)) {\n        if (index($_,\
    \ $substring) > -1) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    $string =~ s/\\s+//g;\n    my($count) = ($string =~ /($substring)/ig)\
    \ || 0;\n    return $count;\n}\n</code>\nNow to count the overlaps, you can use\
    \ a hash of arrays. Note that this is only good when you have small alphabets,\
    \ as your question assumed. You can modify it to suit your needs.\n<code>", '    $string
    =~ tr/a-z/A-Z/;', "    my($found, $count) = (0, 0);\n    while($string =~ /($substring)/ig)\
    \ {\n        $found += 1;\n        $count++;\n    }\n    return $count;\n}", " \
    \   my $count = 0;\n    for (my $i = 0; $i < length $string; $i++) {\n       \
    \ my $match = $string[$i] eq $substring[0];\n        for (my $j = 1; $j < length\
    \ $substring; $j++) {\n            my $match = $match && $string[$i] eq $substring[$j];\n\
    \        }\n        $count++ if $match;\n    }\n    return $count;\n}", "    my\
    \ $string_length = length($string);\n    my $substring_length = length($substring);\n\
    \    my $count = 0;\n    $string =~ /(?:$substring)/ig;\n    my $match = $1;\n\
    \    $match =~ s/\\A(.).*?\\z/$1/;\n    $match =~ s/^(.)//;\n    $match =~ s/^.//;\n\
    \    $match =~ s/\\A(.).*?\\z/$1/;\n    for(my $i = 0; $i <= $string_length; $i++)\
    \ {\n        if ($i > 0) {\n            $count += length($match) - length($string[$i\
    \ - 1])\n        }\n        if ($string[$i] == $match) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my $count_occurrences = 0;\n \
    \   $string =~ s/$substring//g;\n    for my $match ($string =~ /($substring)/g)\
    \ {\n        $count_occurrences++;\n    }\n    return $count_occurrences;\n}",
  "    $substring =~ tr/a-zA-Z//cd;\n    $string =~ tr/a-zA-Z//cd;", "    my($total_count)\
    \ = $string =~ tr/a-z/A-Z/;\n    my($match);", "    my $count = 0;\n    $string\
    \ =~ s/$substring/$string/$;\n    while(@string) {\n        my $index = $#string\
    \ + 1;\n        while($index >= 0 && $string[$index] eq $string[$index - 1]) {\n\
    \            $index--;\n        }\n        if($index == 0) {\n            return\
    \ $count;\n        } else {\n            $count++;\n        }\n        $index--;\n\
    \    }\n    return $count;\n}", '    my($matches, $count);', "    my $cnt = 0;\n\
    \    for (split(//, $string)) {\n        my $substr_cnt = grep($_ eq $substring,\
    \ $string);\n        if (defined($substr_cnt)) {\n            ++$cnt;\n      \
    \  }\n    }\n    return $cnt;\n}", "    $string =~ /\\b$substring\\b/;\n    return\
    \ $-[0] if $string =~ /\\b$substring\\b/;\n    return $-[0] + 1;\n}", "    if\
    \ ( !$string || !$substring ) {\n        return 0;\n    }\n    $substring =~ tr/A-Z//cd;\n\
    \    my $count = 0;\n    while ($string =~ /($substring)/ig) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    $string =~ tr/A-Z//d;\n    $substring =~\
    \ tr/A-Z//d;\n    my $count = 0;\n    $string =~ s/$substring/$count++;/g;\n \
    \   return $count;\n}", "    $substring = lc($substring);\n    my $count = 0;\n\
    \    $string =~ /(?:$substring)/ig;\n    $count++; $count = $count + length($&);\n\
    \    $count++ if $substring =~ /(?:$substring)/g;\n    $count;\n}", "    $string\
    \ =~ m{((?!$substring).)*}g;\n}", "    $string =~ s/^\\s+//; # Remove whitespace\
    \ at start of string\n    $substring =~ s/^\\s+//; # Remove whitespace at start\
    \ of substring\n    $string =~ s/\\s+$//; # Remove whitespace at end of string\n\
    \    $substring =~ s/\\s+$//; # Remove whitespace at end of substring", "    $string\
    \ =~ tr/a-zA-Z/A-Z/;\n    $substring =~ tr/a-zA-Z/A-Z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    $substring =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    $substring =~\
    \ tr/A-Z/a-z/;\n    $string =~ tr/0-9/a-zA-Z/;\n    $substring =~ tr/0-9/a-zA-Z/;\n\
    \    return scalar grep(\n        ($string =~ m/\\Q$substring\\E/g) ? 0 : $string\
    \ =~ m/\\Q$substring\\E/g,\n        qw( A A A A B B C D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D\
    \ D D D D D D D D D D D D D D ", "    my $count = () = $string =~ /($substring)/ig;\n\
    \    return $count;\n}", "    $string =~ /${substring}/g;\n    return scalar(@{$_});\n\
    }", "    $substring =~ tr/-/a-/;\n    my $len = ($string =~ tr/a-/-/);\n    my\
    \ $count = 0;\n    while ($substring =~ m/$substring/g) {\n        $count++;\n\
    \    }\n    my $total = 0;\n    for my $i (0 .. $count) {\n        $total += $string[$i]\
    \ eq $substring[$i];\n    }\n    return $total;\n}", "    $string =~ /($substring)(?=(.*$substring))/;\n\
    \    return $-[0] + 1;\n}", "    my $string_index = 0;\n    my $substring_index\
    \ = 0;\n    while ($string_index < length($string)) {\n        if (substr($string,\
    \ $string_index, $substring_index + 1) eq $substring) {\n            $string_index\
    \ += length($substring) + 1;\n            $substring_index++;\n        }\n   \
    \     elsif ($substring_index == length($substring)) {\n            return $string_index\
    \ - length($string) + 1;\n        }\n        $substring_index = 0;\n        $string_index++;\n\
    \    }\n    return 0;\n}", '    return 0 unless $string;', "    $string =~ /($substring)/;\n\
    \    return $1;\n}", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;",
  "    my $count = 0;\n    my ($first, $last, $offset);", '    my($counter);', " \
    \   my $len = length $string;\n    my $count = 0;\n    my $index = 0;\n    my\
    \ $substring_index = 0;", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Za-z/A-Z/;\n\
    \    my $count = 0;\n    my $string_count = 0;\n    while ($string =~ /($substring)/ig)\
    \ {\n        $count++;\n        $string_count++;\n    }\n    return $string_count\
    \ if $count > 0;\n    return 0;\n}", "    my $count = 0;\n    for my $char (split('',\
    \ $string)) {\n        if ($char eq $substring) {\n            $count++;\n   \
    \     }\n    }\n    return $count;\n}", "    $string =~ /($substring)/g;\n   \
    \ return $1 + $2;\n}\n</code>\n<|/ a tags=perl |>\n<| a |>\nThis would also give\
    \ a substring count of zero when no substring matches:\n<code>\nmy $string = \"\
    The quick brown fox jumped over the lazy dog\";\nmy $substring = \"fox\";", " \
    \   my $count = 0;\n    $string =~ tr/A-Z/a-z/;\n    while ($string =~ /$substring/g)\
    \ {\n        $count++;\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=3\
    \ tags=perl,case-insensitive,regex |>\n<| a dscore=3 |>\nFor fun, here's one way\
    \ to do it with grep:\n<code>\nperl -nE 'say \"a b c\" if /a[^b]*b[^c]*c/ig'\n\
    </code>\n<|/ a tags=perl,case-insensitive,regex |>\n<| a tags=perl,case-insensitive,regex\
    \ |>\nHere is a way to do it using an actual regex and case insensitive matching\n\
    <code>", "    my $count = 0;\n    $string =~ /($substring)/g;\n    return $count;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
