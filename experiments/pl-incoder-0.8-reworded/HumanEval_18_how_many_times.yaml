name: HumanEval_18_how_many_times
language: pl
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times(\"\", \"a\")\n# 0\n# >>> how_many_times(\"\
  aaa\", \"a\")\n# 3\n# >>> how_many_times(\"aaaa\", \"aa\")\n# 3\nsub how_many_times\
  \ {\n    my($string, $substring) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&how_many_times;\n\
  \        if(eq_deeply($candidate->(\"\", \"x\"),0)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyxyxyx\", \"x\"\
  ),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  cacacacac\", \"cac\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(\"john doe\", \"john\"),1)) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $substring =~ tr/a-z/A-Z/;\n    return 0 if $string eq \"\";\n\
    \    return $string =~ m/$substring/g;\n}", "    my $string_length = length $string;\n\
    \    my $substring_length = length $substring;\n    my $number_of_substrings;\n\
    \    if ( $string_length <= $substring_length ) {\n        # Case 1: No substring\
    \ found\n        $number_of_substrings = 0;\n    } elsif ( $substring_length ==\
    \ 0) {\n        # Case 2: Substring is empty\n        $number_of_substrings =\
    \ $string_length;\n    } elsif ( $string_length < $substring_length ) {\n    \
    \    # Case 3: Substring is longer than the string\n        $number_of_substrings\
    \ = $string_length / $substring_length;\n    } elsif ( $string_length >= $substring_length\
    \ ) {\n        # Case 4: Substring is equal to the string\n        $number_of_substrings\
    \ = 1;\n    }\n    return $number_of_substrings;\n}", "    $string =~ tr/a//cd;\n\
    \    $substring =~ tr/a//cd;\n    my $count = $string =~ tr/a/b/;\n    my $overlap\
    \ = $substring =~ tr/a/b/;\n    return $count + $overlap;\n}", "    $string =~\
    \ tr/a-z/A-Z/;\n    my $count = 0;\n    my $length = length($string);\n    my\
    \ $i = 0;\n    while ($i < $length) {\n        if (substr($string, $i, 1) =~ /$substring/)\
    \ {\n            ++$count;\n        }\n        $i += 2;\n    }\n    return $count;\n\
    }", "    $substring =~ s/([a-z])/ $1 . m/^(.)/; # convert char to lower case\n\
    \    $string =~ /(?:$substring)/ ? length($0) : 0;\n}", "    return 0 unless length\
    \ $string;\n    return 0 unless length $substring;\n    $string =~ s/$substring//ig;\n\
    \    return length $string;\n}", "    $string =~ s/(?:$substring)|(?:^$substring)/$1/g;\n\
    \    $string =~ s/(?<=^$substring)$substring/$substring/g;\n    return $string\
    \ =~ /(?<!\\S)$substring(?!\\S)/g;\n}", "    $string =~ tr/aeiou/aeiou/;\n   \
    \ $substring =~ tr/aeiou/aeiou/;\n    return 0 if $string =~ /$substring/ig;\n\
    \    $string =~ tr/aeiou/aeiou/;\n    $substring =~ tr/aeiou/aeiou/;\n    return\
    \ 0 if $string =~ /$substring/ig;\n    $string =~ tr/aeiou/aeiou/;\n    $substring\
    \ =~ tr/aeiou/aeiou/;\n    return 0 if $string =~ /$substring/ig;\n    return\
    \ 3;\n}", "    return 0 if $string eq \"\";\n    return 0 if $substring eq \"\"\
    ;\n    return $string =~ m/\\Q$substring\\E/ ? $&+1 : 0;\n}", "    $string =~\
    \ tr/a-z/A-Z/;\n    return $string =~ /($substring)/ig;\n}", "    $string =~ s/(^|[^A-Za-z0-9_])($substring)/$1$substring/ig;\n\
    \    $string =~ tr/a-z/A-Z/;\n    return scalar grep { $string =~ /($substring)/i\
    \ } qw(a b c d e f g h i j k l m n o p q r s t u v w x y z);\n}", "    my $count\
    \ = 0;\n    for (split(//, $string)) {\n        if (index($_, $substring) != -1)\
    \ {\n            $count++;\n            last;\n        }\n    }\n    return $count;\n\
    }", "    $substring = \"_\" . $substring . \"_\" unless $substring =~ /^_/;\n\
    \    my($count_1, $count_2) = map { $string =~ /($substring)/g; $1 } \n      \
    \                  grep { length($_) > 0 }; \n    return ($count_1, $count_2);\n\
    }", "    return 0 if !defined $string || !defined $substring;\n    return 0 if\
    \ $string eq \"\" || $substring eq \"\";\n    $string =~ s/\\s+//g;\n    $substring\
    \ =~ s/\\s+//g;\n    my($substring_c);\n    my($substring_c2);\n    my $count\
    \ = 0;\n    my $count_c2 = 0;\n    my $i = 0;\n    while($i < length($string))\
    \ {\n        $substring_c = $substring . substr($string, $i, 1);\n        $substring_c2\
    \ = $substring_c;\n        $count_c2 = length($substring_c2);\n        $i++;\n\
    \        if ($i < length($string)) {\n            $count_c2++;\n            $substring_c2\
    \ = substr($string, $i, 1);\n        }\n        $count++;\n        if ($count\
    \ > $count_c2+1) {\n            return -1;\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=2 tags=string,perl,substring |>\n<| c |>\nNot too good,\
    \ because it is O(nm) instead of O(n).\n<|/ c |>\n<| c |>\n: Yeah, I guess it\
    \ depends on the context of the question. Maybe worth mentioning though.\n<|/\
    \ c |>\n<| c |>\nPerl is *O(1)* for the string concatenation because strings are\
    \ in Perl's internal *scalar* data structure. That also means this algorithm is\
    \ *O(n)*. The substring search algorithm is *O(nm)* because it loops over the\
    \ string multiple times *O(n)* times, and the *m* makes it *O(nm)*. The algorithm\
    \ you implemented is *O(n*m)* because of the way it is coded. I think your solution\
    \ is *O(n^2)*.\n<|/ c |>\n<| c |>\n: It's certainly not O(nm) because you do multiple\
    \ string concatenations. As for why yours is the right answer, see my explanation.\n\
    <|/ c |>\n<| c |>\n: It's O(n) because you're doing one concatenation. I'm talking\
    \ about multiple concatenations because of the fact that you concatenate a new\
    \ substring for every character in the string.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "    my(@substrings) = split //, $substring;\n    my($counter) = 0;\n    for (@substrings)\
    \ {\n        $counter += index($string, $_) + 1;\n    }\n    return $counter;\n\
    }", "    my $string_length = length $string;\n    my $substring_length = length\
    \ $substring;\n    my $cnt = 0;\n    my $i = 0;\n    while ($i < $string_length)\
    \ {\n        my $j = 0;\n        while ($j < $substring_length) {\n          \
    \  my $match = 0;\n            if ($string[$i] == $substring[$j]) {\n        \
    \        $j++;\n                $match++;\n            }\n            else {\n\
    \                $match = 0;\n            }\n            if ($match == $substring_length)\
    \ {\n                $cnt++;\n                $j = $substring_length;\n      \
    \      }\n            else {\n                $j++;\n            }\n        }\n\
    \        $i++;\n    }\n    return $cnt;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,perl,string,regex,python\
    \ |>\n<code>\ndef count_substring(text, substring):\n    pos = 0\n    count =\
    \ 0\n    while pos < len(text) and text[pos] == substring[0]:\n        if substring\
    \ == text[0:pos]:\n            count += 1\n        pos += 1\n    return count",
  "    return 0 if length($string) == 0;\n    my $count = 0;\n    my @chars = split(//,\
    \ $string);\n    for(0 .. @chars - 1) {\n        for(my $i = 0; $i <= $#chars\
    \ - 1; $i++) {\n            last if $chars[$i] == $substring;\n            last\
    \ if $i < $#chars && $chars[$i] == $chars[$i + 1];\n        }\n        $count++;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a tags=perl,string dscore=1 |>\n<|\
    \ c |>\nWon't this fail to match if the substring appears multiple times in the\
    \ string?\n<|/ c |>\n<| a |>\nPerl doesn't handle negative indexes very well,\
    \ so I wrote a solution in Perl.\n<code>", "    $string =~ tr/A-Z/a-ZA-z/;\n \
    \   $string =~ tr/a-z/a-za-z/;\n    return length($&) <=> length($&) while $string\
    \ =~ /$substring/gi;\n}", "    $string =~ /($substring)/gi;\n    return scalar\
    \ @{$_} + scalar grep { $_ eq $substring } @{$_};\n}", '    my $count = 0;', " \
    \   $string =~ tr/a-z/A-Z/;\n    my $count = 0;\n    $string =~ /$substring/g;\n\
    \    $count++ while ($string =~ /$substring/g);\n    return $count;\n}", "   \
    \ return 1 if not $string;\n    my $count = 1;\n    $string =~ s{($substring)}{\
    \ ++$count * length $1 }{};\n    return $count;\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThe `s{($substring)}{ ++$count * length $1 }{g}` is better written as\
    \ `s{$substring}{++$count}`\n<|/ c |>\n<| c |>\nThe `++$count` should be `++$count+1`,\
    \ otherwise you get `1` instead of `2`.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n\
    my $str = \"abcabc\";\nmy $sub = \"c\";", "    my @substrings = $string =~ /($substring)/gi;\n\
    \    my $count = scalar(@substrings);\n    my @non_overlapping_substrings;\n \
    \   for(@substrings) {\n        next if $_==$substring;\n        if ($_ ne $substring)\
    \ { push @non_overlapping_substrings, $_; }\n    }\n    my $non_overlapping_count\
    \ = scalar(@non_overlapping_substrings);\n    return $count + $non_overlapping_count;\n\
    }", "    my $result = 0;\n    while ($string =~ /($substring)/g) {\n        $result++;\n\
    \    }\n    return $result;\n}", "    $string =~ s/^\\s+//;\n    $substring =~\
    \ s/^\\s+//;\n    my $count = 0;\n    my $index;\n    while ($string =~ /($substring)/g)\
    \ {\n        $index = $-[0];\n        $count++;\n        $string = \"$string${^PREMATCH}\"\
    ;\n    }\n    return $count;\n}", "    my $count = 0;\n    $string =~ /($substring)/i;\n\
    \    $count++ if $1 ne $substring;\n    $string =~ /(\\w$substring)/i;\n    $count++\
    \ if $1 ne $substring;\n    $string =~ /($substring\\W)/i;\n    $count++ if $1\
    \ ne $substring;\n    $string =~ /(\\w$substring\\W)/i;\n    $count++ if $1 ne\
    \ $substring;\n    return $count;\n}", "    if ($string eq \"\") {\n        return\
    \ 0;\n    }\n    return $string =~ /\\b$substring\\b/ig ? $string =~ /\\b$substring\\\
    b/g : 0;\n}", "    my $length = $string->length();\n    return 0 unless length\
    \ $string;\n    my $count = 0;\n    my $length = $string->length();\n    my $start\
    \ = 0;", '    $substring =~ tr/a-z/A-Z/;', "    $substring =~ tr/a-z/A-Z/;\n \
    \   $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return length($string) - length($substring);\n\
    }", "    my $count = 0;\n    $string =~ s/${substring}//g;\n    return $count;\n\
    }", "    my $count = 0;\n    my $length = length $string;\n    my $i = 0;\n  \
    \  my $j = 0;\n    foreach my $i (0 .. $length - 1) {\n        foreach my $j ($i\
    \ + 1 .. $length - 1) {\n            if (substr($string, $i, 1) eq substr($string,\
    \ $j, 1)) {\n                $count++;\n            }\n        }\n    }\n    return\
    \ $count;\n}", "    \n    my $cnt = 0;\n    $string =~ s/^$substring//;\n    $string\
    \ =~ s/$substring//;\n    \n    while ($string =~ /$substring/g) {\n        $cnt++;\n\
    \        $string =~ s/^$substring//;\n        $string =~ s/$substring//;\n   \
    \ }\n    \n    return $cnt;\n}\n</cell>\n<cell>", "    $string =~ /($substring)/gi;\n\
    \    return scalar(grep(!($_ =~ m/$substring/i), $string));\n}", "    $string\
    \ =~ /($substring)/g;\n    return $1;\n}", "    my $count = 0;\n    foreach my\
    \ $char (split(//, $string)) {\n        if ($char eq $substring) {\n         \
    \   $count++;\n        }\n    }\n    return $count;\n}\n</code>\n<|/ a tags=regex,perl\
    \ |>\n<| a |>\nHere's a solution which uses a recursive function:\n<code>\nmy\
    \ $text = \"hello world\";", "    $string =~ tr/A-Za-z/aA-z/;\n    $substring\
    \ =~ tr/A-Za-z/aA-z/;\n    $string =~ tr/aA-z/A-Za-z/;\n    $substring =~ tr/aA-z/A-Za-z/;\n\
    \    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n    return scalar\
    \ @{ $string =~ /($substring)/ig };\n}", "    my($total, $i);\n    $total = 0;\n\
    \    for ($i = 0; $i <= length($string); $i++) {\n        $total += $i if (substr($string,\
    \ $i, length($substring)) == $substring);\n    }\n    return $total;\n}", "  \
    \  $string =~ tr/a-z/A-Z/;\n    my $count = 0;\n    while ($string =~ /(?:$substring)(?:[^$substring]|$substring)/)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    $string =~ tr/a-z/A-Z/;\
    \  # Lower-case to upper-case conversion.\n    $substring =~ tr/a-z/A-Z/;  # Lower-case\
    \ to upper-case conversion.\n    $string =~ tr/A-Z/a-z/;  # Upper-case to lower-case\
    \ conversion.\n    $substring =~ tr/A-Z/a-z/;  # Upper-case to lower-case conversion.",
  "    $string =~ /(?:^|\\W)$substring(?:$|\\W)/g;\n    return $1 ? ($1 ne $substring\
    \ ? $1 : 0) : 1;\n}", "    $string  ||= $self->{string};\n    $substring ||= $self->{substring};\n\
    \    return 0 if $string eq $substring;\n    my $count = 0;\n    while ($string\
    \ =~ m/$substring/g) {\n        ++$count;\n    }\n    return $count;\n}", "  \
    \  $string =~ tr/A-Za-z//;\n    my $counter = 0;\n    my $max_counter = 0;\n \
    \   my $counters = $string =~ tr/A-Za-z//;\n    foreach my $char (split //, $string)\
    \ {\n        $counter += $counters;\n        if ($char == $substring) {\n    \
    \        $counter += 1;\n            $max_counter = length $substring;\n     \
    \   }\n    }\n    return $max_counter if $counter > $max_counter;\n    return\
    \ $max_counter - $counter;\n}", "    $string =~ s/$substring//g;\n    return ($string\
    \ =~ /$substring/g);\n}", "    my($count) = 0;\n    for ($string) {\n        if\
    \ ($string =~ m/\\Q$substring\\E/) {\n            ++$count;\n        }\n    }\n\
    \    return $count;\n}", "    my %hash;\n    $hash{\"a\"}++;\n    $hash{\"aa\"\
    }++;\n    $hash{\"aaa\"}++;\n    $hash{\"aaaa\"}++;", "    my @substrings = $substring\
    \ ? @{$_}{$substring} : @{$_};\n    return scalar(grep { ++$counts{$_} > 1 } @substrings);\n\
    }\n</code>\nAnd then we can create a map of substrings to their number of occurrences:\n\
    <code>", "    my($times) = 0;\n    my $length = $string->length;\n    for (my\
    \ $i = 0; $i < $length; $i++) {\n        my $offset = $i;\n        while ($offset\
    \ < length($string) and substr($string, $offset, $substring) == $substring) {\n\
    \            $times++;\n            $offset++;\n        }\n    }\n    return $times;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n    my $i =\
    \ 0;\n    my $found = 0;\n    my @array = ();", '    my($match, $match_found)
    = (0, 0);', "    my $count = 0;\n    $string =~ s/$substring//;\n    $string =~\
    \ tr/a//;\n    $count += length($string);\n    $count += length($substring);\n\
    \    $count;\n}", "    my @found = ();\n    my $i = 0;\n    my $start = 0;\n \
    \   my $found;\n    my $length = $string->length;\n    while($i < $length) {\n\
    \        while($i < $length and $string->[$i] ne $substring->[$i]) {\n       \
    \     $i++;\n        }\n        if($i >= $length) {\n            $start = $i;\n\
    \            $found++;\n        }\n        elsif($i >= $length and $string->[$i]\
    \ == $substring->[$i]) {\n            $i++;\n        }\n        else {\n     \
    \       push(@found, $i);\n            $start = $i;\n        }\n    }\n    return\
    \ @found - $found;\n}", "    my $count = 0;\n    foreach my $idx (0..length($string))\
    \ {\n        if (substr($string, $idx, 1) eq $substring) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", '    my $count = 0;', '    return 0
    if length($string) < length($substring);', "    $substring = lc($substring) if\
    \ $self->{LOWERCASE};\n    $string =~ s/^\\s+//;\n    $substring =~ s/^\\s+//;\n\
    \    my $count = 0;\n    if ($string =~ /$substring/ig) {\n        $count++;\n\
    \    }\n    $count += $string =~ /\\Q$substring\\E/ig;\n    $count;\n}", "   \
    \ $string = $string =~ tr/a-zA-Z/A-Za-z/;\n    $substring = $substring =~ tr/a-zA-Z/A-Za-z/;\n\
    \    return length($string =~ /($substring)/ig);\n}", "    $string =~ /./;\n \
    \   $substring =~ /./;\n    my $count = 0;\n    $count++ while $string =~ /($substring)/i;\n\
    \    $count;\n}", '    $substring =~ tr/a-z/A-Z/;', "    $string .= $substring;\n\
    \    return $string =~ /((^|\\s)$substring)(\\s)/igcc ? length($substring) + 1\
    \ : 1;\n}", "    $string =~ /($substring)/;\n    return $1 while $string =~ /($substring)/g;\n\
    \    return 0;\n}", "    my $count = 0;\n    $string =~ tr/a-zA-Z//d;\n    foreach\
    \ my $letter (split //, $string) {\n        my $current_substring = $letter;\n\
    \        if ($substring =~ /^$current_substring$/) {\n            $count++;\n\
    \            $current_substring =~ tr/a-zA-Z//d;\n        }\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a dscore=0 tags=perl,regex |>\n<| c |>\nThis works\
    \ but it is slow for large strings because it has to search every letter in the\
    \ string twice.  There are many ways to speed this up.  I'll post an answer shortly\
    \ on how I did it.\n<|/ c |>\n<| c |>\nYes, I agree, I was trying to get something\
    \ that would work quickly, but then I realized that I had no idea what kind of\
    \ string I was dealing with, so I wanted to keep it simple so I could test the\
    \ different algorithms with different strings. I guess I should have mentioned\
    \ that. I'll be back on a computer later when I have some more time.\n<|/ c |>\n\
    <| c |>\nAh, you're right. You're right again :) Thanks for the help :)\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>\nmy $str = \"hello\";\nmy $word = \"ello\";", " \
    \   $substring =~ tr/a-zA-Z//d;\n    $string =~ tr/a-zA-Z//d;\n    $string =~\
    \ tr/a-zA-Z//d;\n    $substring =~ tr/a-zA-Z//d;\n    $count += ($string =~ /$substring/igc)\
    \ ? 1 : 0;\n}", "    my $count = 0;\n    while($string =~ /($substring)/ig) {\n\
    \        ++$count;\n    }\n    return $count;\n}", "    my $count = 0;\n    $string\
    \ =~ m/$substring/g;\n    while ($string =~ m/$substring/g) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    $string =~ s/(?:$substring)/?$substring/g;\n\
    \    $string =~ s/.*/$substring /g;\n    return $string =~ tr/a-zA-Z//;\n}", " \
    \   my $counter = 0;\n    for ($string =~ /($substring)/) {\n\t$counter++;\n \
    \   }\n    return $counter;\n}", "    $string =~ s/$substring/$substring/g;\n\
    \    return 1 + $string =~ s/$substring//g;\n}", "    $substring =~ s/^\\s+//;\n\
    \    $substring =~ s/\\s+$//;\n    my $count = 0;\n    my $index = 0;\n    my\
    \ $index2 = 0;\n    my $strlen = $string->length;\n    \n    for (my $i = 0; $i\
    \ < $strlen; $i++) {\n        # Iterate over each character in the string\n  \
    \      my $char = $string->[$i];\n        \n        # Iterate over each character\
    \ in the substring\n        my $subchar = $substring->[$index];\n        $index++;\n\
    \        $index2++;\n        \n        if ($index2 >= $#{$substring}) {\n    \
    \        $index2 = 0;\n            $index++;\n        }\n        \n        if\
    \ ($char != $subchar) {\n            $count++;\n        }\n    }\n    \n    return\
    \ $count;\n}", "    my $count = 0;\n    \n    # Loop through each character in\
    \ the string.\n    for(my $i = 0; $i < length($string); $i++) {\n        # Loop\
    \ through each character in the substring.\n        for(my $j = 0; $j < length($substring);\
    \ $j++) {\n            # If the current character in the string and the current\
    \ character in the substring\n            # are not the same character (that is,\
    \ the character has been seen before), increment the count.\n            if($string[$i]\
    \ ne $substring[$j]) {\n                $count++;\n            }\n        }\n\
    \    }\n    return $count;\n}", "    my $count = ($string =~ s/^$substring//);\n\
    \    $count += ($string !~ s/^$substring//);\n    $count;\n}", '    my $counter
    = 0;', "    my $result = 0;\n    my $last_match = $string;\n    my $match_count\
    \ = 0;\n    my $i = 0;\n    while ($i < $#$string && $last_match =~ /$substring/ig)\
    \ {\n        $match_count++;\n        $last_match = $string->[$i + 1];\n     \
    \   $i++;\n    }\n    $result += $match_count;\n    return $result;\n}", "   \
    \ $substring =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Za-z/A-Z/;\n    $string =~ s/^\\\
    s*//;\n    $substring =~ s/^\\s*//;\n    return $string =~ /$substring/;\n}",
  "    $string = $string || \"\";\n    $substring = $substring || \"\";\n    \n  \
    \  my $count = 0;\n    my $i = 0;\n    \n    while ($i < length($string) and $i\
    \ < length($substring)) {\n        my $char_at = $string[$i];\n        my $char_at_length\
    \ = $substring[$i];\n        if ($char_at eq $char_at_length) {\n            $count++;\n\
    \            $i++;\n        }\n        else {\n            $i = 0;\n        }\n\
    \    }\n    \n    return $count;\n}", "    $string =~ /$substring/gi;\n    return\
    \ $-[0];\n}", "    $string .= '!' if !$string =~ /\\A!$substring\\z/;\n    $string\
    \ =~ s/^$substring//;\n    return $string =~ tr/a//;\n}", "    $string =~ /($substring)/g;\n\
    \    return scalar grep(/^\\1$/, @_);\n}", "    my $result = 0;\n    my $index\
    \ = 0;", "    $string =~ tr/a-zA-Z//cd;\n    my $count = 0;\n    $string =~ m/($substring)/g;\n\
    \    $count++ while $string;\n    return $count;\n}", "    my $n = 0;\n    while($string\
    \ =~ /($substring)/ig) {\n        $n += 1;\n    }\n    return $n;\n}", "    my($count)\
    \ = 0;\n    foreach my $c (split(//, $string)) {\n        if (($c eq $substring)\n\
    \         || ($c =~ /^$substring$/)) {\n            $count++;\n        }\n   \
    \ }\n    return $count;\n}", "    my $count = 0;\n    $string =~ /($substring)/ig;\n\
    \    $count++ if defined $1;\n    $string =~ /($substring)/ig;\n    $count++ if\
    \ defined $1;\n    $string =~ /($substring)/ig;\n    $count++ if defined $1;\n\
    \    $string =~ /($substring)/ig;\n    $count++ if defined $1;\n    $string =~\
    \ /($substring)/ig;\n    $count++ if defined $1;\n    $string =~ /($substring)/ig;\n\
    \    $count++ if defined $1;\n    $string =~ /($substring)/ig;\n    $count++ if\
    \ defined $1;\n    return $count;\n}\n</code>\n<|/ a |>\n<| c |>\nThis works great\
    \ for the case where the substring occurs in single letters. But it doesn't work\
    \ if you just want to check whether it occurs in a single word. For example the\
    \ string `aaabbbc` would return 4 (four occurrences of `bbb`) instead of 1 (one\
    \ occurrence of `bbb`).\n<|/ c |>\n<| a dscore=0 |>\nHere is my solution.\n<code>\n\
    use strict;\nuse warnings;\nuse 5.010;\nuse List::MoreUtils qw(uniq);", "    $string\
    \ .= $substring;\n    $string  =~ tr/a//d;\n    my $count = () = $string =~ m/$substring/ig;\n\
    \    return $count unless $count;\n    return $count + int($count > 1);\n}", " \
    \   $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/A-Z/a-z/;", "    my $count =\
    \ ($string =~ /\\Q$substring\\E/) ? 1 : 0; # Count the number of times \"$substring\"\
    \ appears in the string.\n    my $num_matches = $string->length / ($string->length\
    \ / ($string->length - $count));\n    return $num_matches;\n}", "    $substring\
    \ ||= $string;\n    my $pos = 0;\n    my $count = 0;\n    $string = \"aa\" . $string\
    \ . \"a\";\n    while ($pos < length($string)) {\n        $pos = index($string,\
    \ $substring, $pos);\n        last if $pos >= 0;\n        $count++;\n    }\n \
    \   $count;\n}", "    \n    my $i = 0;\n    my $n = length $string;\n    \n  \
    \  for(my $j = 0; $j < $n; $j++) {\n        my $char = $string->[$j];\n      \
    \  next if ($char == $substring);\n        $i++;\n    }\n    return $i;\n}", " \
    \   my $string_size = length($string);\n    my $substring_size = length($substring);\n\
    \    \n    if($string_size < $substring_size) {\n        $substring_size = $string_size;\n\
    \    }", '    $substring =~ tr/a-z/A-Z/;', "    my $count = 0;\n    foreach my\
    \ $char (split //, $string) {\n        $count++ if $char eq $substring;\n    }\n\
    \    return $count;\n}", "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;\n\
    \    return 0 if $string eq $substring;", "    $substring =~ tr/a-z//cd;\n   \
    \ $string =~ tr/a-z//cd;\n    my $count = 0;\n    while($string =~ /($substring)/ig)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    $string =~ /(?:$substring){$substring}/;\n\
    \    $string =~ /^(?:$substring){$substring}/;\n    return $string =~ /^(?:$substring){$substring}/;\n\
    }", "    $string =~ m{\n        ^($substring)                # Start of string\
    \ followed by substring.\n        (?:                       # Non capturing group.\n\
    \            \\Z|                    # End of string or EOL\n            $substring\
    \ (?={0,2}(?!\\1)) # Substring followed by another substring. Overlapping case.\n\
    \        )\n    }ix;\n    length($1)\n}", "    \n    return 0 if !defined($substring);\n\
    \    \n    my $count = 0;\n    \n    for (my $i = 0; $i <= length($string); $i++)\
    \ {\n        if (substr($string, $i, length($substring)) eq $substring) {\n  \
    \          $count++;\n        }\n    }\n    \n    return $count;\n}", '    $string
    =~ tr/a-z/A-Z/;', "    $string = $string || \"\";\n    $substring = $substring\
    \ || \"\";\n    $string =~ s/^\\s+//;\n    $substring =~ s/^\\s+//;\n    $string\
    \ =~ s/\\s+$//;\n    $substring =~ s/\\s+$//;\n    $string =~ s/^\\s+//;\n   \
    \ $substring =~ s/^\\s+//;\n    $string =~ s/\\s+$//;\n    $substring =~ s/\\\
    s+$//;\n    $string =~ s/^$substring//;\n    my $len = $length - length($string);\n\
    \    my $count = $-[0];\n    return 0 if $count == 0;\n    return $count + $len;\n\
    }", "    $string =~ /([$substring])\\1/;\n    $1 += 0;\n    return $1;\n}", " \
    \   my $match_count = 0;\n    my $strlen = length $string;\n    my $sublen = length\
    \ $substring;\n    my $i = 0;\n    for (; $i < $strlen; $i++) {\n        if ($string[$i]\
    \ == $substring[$i]) {\n            $match_count++;\n            last if ($match_count\
    \ == $sublen);\n        }\n    }\n    return $match_count;\n}", "    return length($string)\
    \ - length($substring) + scalar(grep(/^\\Q$substring\\E$/,$string));\n}", "  \
    \  my $count = 0;\n    while ($string =~ /$substring/g) {\n        $count += 1;\n\
    \    }\n    return $count;\n}", "    my $len = $string->length();\n    $len++\
    \ while $string->substr($len-1) eq $substring;\n    return $len;\n}", '    $string
    =~ tr/\0//d;', "    $string =~ tr/a-z/A-Z/;\n    $substring =~ tr/a-z/A-Z/;",
  "    my $i = 0;\n    my $found_substring = 0;\n    while( ($string =~ m/($substring)/g)\
    \ != -1 ) {\n        $found_substring++;\n        $i++;\n    }\n    return $found_substring;\n\
    }", "    my $count = 0;\n    $string =~ tr/a-zA-Z//;\n    while ($string =~ /$substring/g)\
    \ {\n        $count++;\n    }\n    $count;\n}", "    $string .= $substring;\n\
    \    $string =~ s/^$substring//;\n    $string =~ s/$substring$//;\n    $string\
    \ =~ tr/a/ /;\n    $string =~ tr/A/ /;\n    $string =~ tr/a/A/g;\n    $string\
    \ =~ tr/A/a/g;\n    return $string =~ tr/a/ /;\n}", "    my(@results);\n    my\
    \ $count = 0;\n    foreach my $char (split(//, $string)) {\n        ++$count if\
    \ $char eq $substring;\n    }\n    return $count;\n}", "    my $n = 0;\n    my\
    \ $pos = 0;", '    my(@counts) = ();', "    return $string =~ tr/a-zA-Z/../tr/a-zA-Z//;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    return length($&) * length($_) / length($string);\n\
    }", "    return 0 if $string eq \"\";\n    $string =~ tr/a-z/A-Z/;\n    $substring\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return length($string) - length($substring);\n\
    }", "    my $count = () = $string =~ /^($substring)(?:.*?$substring)*/s;\n   \
    \ return $count;\n}", "    my $count = 0;\n    foreach my $pattern (split //,\
    \ $string) {\n        foreach my $char (split //, $pattern) {\n            if\
    \ ($char eq $substring) {\n                $count++;\n            }\n        }\n\
    \    }\n    return $count;\n}", "    $substring =~ s/ //g;\n    $string =~ s/\
    \ //g;\n    my $count = 0;\n    $string =~ s/\\Q$substring\\E\\Q$substring\\E/++$count;\n\
    \    return $count;\n}", "    $string =~ s/$substring//ig;\n    return scalar\
    \ keys %count;\n}", "    my $count = () = $string =~ /$substring/g;\n    return\
    \ $count;\n}", "    if ( $string =~ /$substring/ ) {\n        $count += 1;\n \
    \   }\n    else {\n        $count = 0;\n    }", "    $substring =~ tr/a-z/A-Z/;\n\
    \    $substring =~ tr/A-Za-z/A-Z/;\n    $substring =~ tr/A-Za-z/A-Z/;\n    $substring\
    \ =~ tr/A-Za-z/A-Z/;\n    return 0 + $string =~ /($substring)/;\n}", "    $string\
    \ =~ s/^\\s+//;\n    $substring =~ s/^\\s+//;\n    my $count = 0;\n    $string\
    \ =~ s/$substring/??????/ig;\n    $string =~ s/??????/$substring/g;\n    return\
    \ $count if $string =~ s/^$substring//;\n    return $count if $string =~ s/$substring//;\n\
    \    return 0;\n}", "    $string =~ /($substring)/gi;\n    return scalar keys\
    \ %{ $string };\n}", "    my $count = 0;\n    my $position = 0;\n    my $length\
    \ = length($string);\n    while($position < $length) {\n        if(substr($string,\
    \ $position, substr($string, $position+1, $length - $position - 1)) == $substring)\
    \ {\n            $count++;\n        }\n        $position += 1;\n    }\n    return\
    \ $count;\n}", "    $string =~ /^$substring\\z/s;\n    $string =~ /^([^$substring]*($substring.+))\\\
    z/s;\n    return $1 + $2 + $3;\n}", "    $string =~ /$substring/ig;\n    return\
    \ $-[0];\n}", '    $string =~ tr/a-z/A-Z/;', "    my($string_length, $substring_length)\
    \ = length($string), length($substring);\n    if ($string_length <= $substring_length)\
    \ {\n        return $string_length;\n    }", '    return 0 if length $string ==
    0;', "    return 0 if !$string || !$substring;\n    my($position, $length);\n\
    \    my($result);\n    my $last_position = 0;\n    my $found;\n    while($position\
    \ = $string->index($substring, $last_position)) {\n        $last_position = $position\
    \ + $length;\n        $found++;\n    }\n    $result = $found - $position;\n  \
    \  return $result;\n}", "    $substring = lc($substring);\n    my $count = 0;\n\
    \    for ($string =~ /($substring)/ig) {\n        my $pos = length($&);\n    \
    \    $count++ if $pos > 0;\n    }\n    return $count;\n}", "    $string =~ /($substring)/;\n\
    \    return $-[0]+1;\n}", '    my ($num_matches, $offset);', "    my $total_count\
    \ = 0;\n    $string =~ tr/A-Za-z//cd;\n    for my $letter (split(//, $string))\
    \ {\n        if ($letter eq $substring) {\n            $total_count++;\n     \
    \   }\n    }\n    return $total_count;\n}", "    my %counts = ();\n    my $i =\
    \ 0;\n    my $j = 0;\n    while ($i < length($string) && $j < length($substring))\
    \ {\n        if ($string[$i] eq $substring[$j]) {\n            ++$counts{$substring[$j]};\n\
    \            ++$i;\n            ++$j;\n        } elsif ($substring[$j] eq $string[$i])\
    \ {\n            ++$i;\n            ++$j;\n        } else {\n            ++$j;\n\
    \        }\n    }\n    return scalar keys %counts;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    $string =~ tr/A-Z/a-z/;\n    return 0 unless length($string);\n    $substring\
    \ =~ tr/a-z/A-Z/;\n    $substring =~ tr/A-Z/a-z/;\n    return 0 unless length($substring);\n\
    \    return ($string =~ m/$substring/g) + $substring =~ m/$string/g;\n}", "  \
    \  my %count = map { $_ => 0 } $string =~ /($substring)/ig;\n    return scalar\
    \ keys %count;\n}", "    my @substrings = split //, $substring;\n    my @strings\
    \ = split //, $string;\n    my $count = 0;\n    for my $i ( 0 .. $#substrings\
    \ ) {\n        if ( $substrings[$i] eq $strings[$i] ) {\n            $count +=\
    \ 1;\n        }\n    }\n    return $count;\n}", "    $string =~ tr/a//d;\n   \
    \ $substring =~ tr/a//d;", "    $string    =~ tr/a-z/A-Z/;\n    my $count = 0;\n\
    \    $string =~ /($substring)/;\n    $count += $&;\n    return $count;\n}", " \
    \   my $count = 0;\n    $string =~ tr/$substring//;\n    while ($string =~ /$substring/)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    $string =~ s/\\Q$substring//g;\n\
    \    my $count_overlapping_substring = 0;\n    for (my $i = 0; $i <= length($string)\
    \ - length($substring); $i++) {\n        if (substr($string, $i, length($substring))\
    \ =~ /\\Q$substring/i) {\n            $count_overlapping_substring++;\n      \
    \  }\n    }\n    return $count_overlapping_substring;\n}", '    my($i, $len);',
  "    return undef if length($string) == 0;\n    return 0 if !defined($substring);\n\
    \    $substring = lc($substring);", "    my $n = length $string;\n    my $count\
    \ = 0;", "    my $count = 0;\n    my $found_sub = 0;\n    \n    foreach my $char\
    \ (split //, $string) {\n        if ($char eq $substring) {\n            $found_sub++;\n\
    \        }\n        if ($found_sub > 0) {\n            $count++;\n        }\n\
    \    }\n    \n    return $count;\n}", "    my $length = $string->length();\n \
    \   my $i = 0;\n    my $count = 0;\n    my @substrings = ($substring) =~ /([a-z])/g;\n\
    \    for (my $i = 0; $i <= $length; $i++) {\n        my $pos = $i;\n        while\
    \ (++$i < $length && $string->[$i] eq $substrings[$pos]) {\n        }\n      \
    \  if ($i < $length) {\n            ++$count;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my $pos = 0;\n    while ($pos < length($string))\
    \ {\n        my $length = length($substring) - 1;\n        $pos = $string->index($substring,\
    \ $pos);\n        if ($pos >= 0) {\n            $count += 1;\n            my $overlap_length\
    \ = $pos - $overlap_position;\n            if ($overlap_length <= $length) {\n\
    \                $count += how_many_times($string, substr($string, 0, $overlap_length\
    \ + 1) . $substring);\n            }\n        }\n    }\n    return $count;\n}",
  "    return $string =~ s/^$substring//;\n}", "    my $count = 0;\n    for (my $i\
    \ = 0; $i < length($string); $i++) {\n        if (substr($string, $i, 1) eq $substring)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    my\
    \ $count = 0;\n    my $i;\n    my $len = length $string;", "    $string =~ tr/a-zA-Z//cd;\n\
    \    my $count = 0;\n    $substring =~ tr/a-zA-Z//cd;\n    my $substring_length\
    \ = $#substring;\n    for my $i (1 .. $#string) {\n        my $found = 0;\n  \
    \      for (my $j = $i; $j; $j--) {\n            $found ||= $substring[$j] !=\
    \ $string[$i];\n        }\n        $count += $found;\n    }\n    return $count;\n\
    }", "    my(@counts, $position) = ();\n    my($i, $j, $start);", "    return 0\
    \ unless $string;\n    return 0 unless $substring;\n    $string =~ s/$substring//g;\n\
    \    return $string =~ tr/a//;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhy `tr/a//`\
    \ and not `tr/a/`?\n<|/ c |>\n<| c |>\nI agree that it's better to use `tr/a/`,\
    \ it's just a habit from the days when Perl had no tr/// support.\n<|/ c |>\n\
    <| c |>\nIn Perl 5.18, the tr function is actually available.  See http://perldoc.perl.org/perl5180delta#tr()\n\
    <|/ c |>\n<| a |>\nIn general, if you need to compute something on characters,\
    \ I recommend a regex with look-behind and look-ahead.\n<code>\nuse strict;\n\
    use warnings;", "    my $count_length = 0;\n    my $count = 0;\n    my $found;\n\
    \    my $start;\n    my $end;", "    return 0 unless $string && $substring;\n\
    \    my $count = 0;\n    $string =~ /($substring)/i;\n    $count += $-[0] - 1;\n\
    \    $count += $-[1];\n    return $count;\n}", "    my($count) = 0;\n    for($i\
    \ = 0; $i < length($string); $i++) {\n        $count += 1 if $string[$i] eq $substring[0];\n\
    \        $count += 1 if substr($string, $i, 1) eq $substring;\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    while ($string =~ m/($substring)/g) {\n\
    \        $count++;\n    }\n    return $count;\n}", "    my $substrings = $substring\
    \ . $string;\n    $substrings =~ s/^(.)/\\U$1/g;\n    return $substrings =~ tr/a//;\n\
    }", "    my $index = 0;\n    my $count = 0;", "    \n    $string =~ s/$substring/$substring\
    \ x 1/e;\n    return scalar(split(//, $string));\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\n: That's not what OP asked for. He specifically asked for overlaps.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", '    return 0 if !defined($string) or !defined($substring);',
  "    my $count = 0;\n    $string =~ /($substring)/gi;\n    while (1) {\n       \
    \ if ($string !~ /\\Q$substring\\E/) {\n            last if ++$count > $SUB_MAX;\n\
    \        }\n        $string =~ /($substring)/gi;\n    }\n    return $count;\n}",
  "    $string =~ tr/A-Za-z/A-Za-Za-Z/;\n    return $string =~ /$substring/ig ? $&\
    \ : 0;\n}", "    $string =~ tr/\\0//d;\n    my $substring_len = length($substring);\n\
    \    my $count = 0;\n    $string =~ tr/$substring/\\0/ or return 0;\n    $string\
    \ =~ tr/\\0//d or return 0;\n    $count += ($string =~ tr/\\0//d) - $substring_len;\n\
    \    $count += 1;\n    return $count;\n}", "    my %found = ();\n    my $length\
    \ = 0;", "    $string =~ /($substring)(.*)/;\n    return $1 . $2;\n}", "    $substring\
    \ =~ s/^$string$//;\n    $string =~ tr/a-z/A-Z/;\n    return () unless $string;\n\
    \    $substring =~ tr/A-Z/a-z/;\n    return () unless $substring;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $substring =~ tr/A-Z/a-z/;\n    my $count = 0;\n    my\
    \ $len = $string->length;\n    my $sublen = $substring->length;\n    for(my $i\
    \ = $len - 1; $i >= 0 && $i >= $sublen; $i--) {\n        if($string->[$i] eq $substring->[$i])\
    \ {\n            $count++;\n        }\n        else {\n            for(my $j =\
    \ $sublen - 1; $j >= 0 && $j < $len; $j++) {\n                if($substring eq\
    \ $string->[$i..$j]) {\n                    $count++;\n                }\n   \
    \         }\n        }\n    }\n    return $count;\n}", "    $string   =~ tr/a-zA-Z//cd;\n\
    \    $substring =~ tr/a-zA-Z//cd;\n    my $count = 0;\n    for (my $index = 0;\
    \ $index <= length($string); $index++) {\n        if (substr($string, $index,\
    \ length($substring)) eq $substring) {\n            $count++;\n        }\n   \
    \ }\n    return $count;\n}", "    $string =~ tr/a-zA-Z//cd;\n    return scalar(grep\
    \ {$_ =~ /$substring/} $string);\n}", "    return 0 if !defined($string);\n  \
    \  return 0 if !defined($substring);\n    $substring .= \"\" if $substring eq\
    \ $string;\n    return scalar grep($string =~ m/$substring/, split //);\n}", " \
    \   my $count = 0;\n    if ($string !~ /(?:^|[^a-zA-Z])$substring(?:[^a-zA-Z]|$)/gi)\
    \ {\n        $count++;\n    }\n    if ($string =~ /(?:^|[^a-zA-Z])$substring(?:[^a-zA-Z]|$)/gi)\
    \ {\n        $count++;\n    }\n    $count;\n}", "    my $pos = 0;\n    my $count\
    \ = 0;\n    while($pos < length($string)) {\n        my $len = length($string);\n\
    \        if ($pos == $len) {\n            $count++;\n            last;\n     \
    \   }\n        my $index = $substring eq '' ? $pos : index($string, $substring,\
    \ $pos);\n        if ($index != -1) {\n            $count++;\n            $pos\
    \ = $index + length($substring);\n            last;\n        }\n        $pos++;\n\
    \    }\n    return $count;\n}", "    my $num_overlapping_cases = 0;\n    # Make\
    \ sure we always start at the first character of the string.\n    my $match_start_pos\
    \ = 0;\n    my $match_end_pos = 0;\n    my $pos = 0;\n    while($pos < length\
    \ $string) {\n        my $match_string = $string{$pos} =~ /$substring/;\n    \
    \    if ($match_string == 0) {\n            $num_overlapping_cases++;\n      \
    \      $match_start_pos += $pos + 1;\n            $match_end_pos += $pos + 1;\n\
    \        } else {\n            $num_overlapping_cases += $match_string;\n    \
    \        $match_end_pos += $match_string;\n        }\n        $pos++;\n    }\n\
    \    return $num_overlapping_cases;\n}", "    my $count = 0;\n    $string =~ tr/a/a/;\n\
    \    if ($string =~ /($substring)/) {\n        $count++;\n    }\n    $string =~\
    \ tr/a/b/;\n    if ($string =~ /($substring)/) {\n        $count++;\n    }\n \
    \   $string =~ tr/b/a/;\n    if ($string =~ /($substring)/) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    my($matches, $match_count);\n    $match_count\
    \ = 0;\n    while($string =~ m/$substring/g) {\n        $match_count++;\n    }\n\
    \    return $match_count;\n}", "    my $cnt = 0;\n    $string =~ tr/a-z/A-Z/;\n\
    \    while ($string =~ /($substring)/ig) {\n        $cnt++;\n    }\n    return\
    \ $cnt;\n}\n</code>\n<|/ a tags=perl,string |>\n<| c |>\nThis one works. A little\
    \ too complicated for me. But I will try to understand it.\n<|/ c |>\n<| a dscore=0\
    \ tags=perl,string |>\nI have this simple script which counts the number of times\
    \ the substring is found in the string. \nIt uses two regex's. \nFirst, it searches\
    \ for every occurrence of substring in the string (using the regex). \nSecondly,\
    \ it counts the number of occurrences. The number of occurrences is the result\
    \ of the regex match.\n<code>", "    my $count = 0;\n    $string =~ m{($substring)(.*)};\n\
    \    my $offset = $-[0];\n    $count += $-[1] - $offset;\n    my $rest = $-[2];\n\
    \    $rest =~ s/\\A(.)\\z/$1/;\n    if ($rest =~ m{$substring}) {\n        $count\
    \ += 1;\n    }\n    return $count;\n}\n</code>\n<|/ a tags=string,perl,regex |>\n\
    <| c |>\nThis fails on `aaaba`. It returns `2` but should return `3`.\n<|/ c |>\n\
    <| c |>\nI like your use of capturing groups. I think I can take that and apply\
    \ it to my own answer, but for now I'll take yours.\n<|/ c |>\n<| c |>\nThanks\
    \ for the edit. I'll also test it out later, but you beat me by a few minutes.\n\
    <|/ c |>\n<| c |>\nThis is not the solution I was looking for. Thanks for your\
    \ answer though.\n<|/ c |>\n<| a tags=string,perl,regex dscore=0 |>\nPerl doesn't\
    \ have variable length lookbehinds. However, you can get around this with capturing\
    \ groups. \n<code>\nmy $how_many = qw( aaa bbb ccc );\nmy $string = \"aabb\";\n\
    my $regex = join '|', map quotemeta, split /\\b/, $how_many;\n$string =~ /($regex)/;\n\
    my $count = $+[1];\n</code>\n<|/ a |>\n<| c |>\nThis works for my case, but I\
    \ added a little more context to my question. I'm going to wait for a bit before\
    \ selecting an answer to see if there's another solution. But I appreciate your\
    \ answer!\n<|/ c |>\n<| c |>\nYou don't have to accept my answer. That's my job.\
    \ You've accepted an answer that does not do what you want.\n<|/ c |>\n<| c |>\n\
    Sorry, I didn't mean to offend you. I appreciate the answer, and I understand\
    \ why you chose to accept it, but I chose to accept my own answer as it is exactly\
    \ what I needed. Also, I wanted to upvote it but it won't let me. Thanks!\n<|/\
    \ c |>\n<| c |>\nAh, that's a good point. Thank you for the catch. And I appreciate\
    \ the upvote.\n<|/ c |>\n<| a tags=string,perl,regex |>\nIf you don't want to\
    \ use capturing groups, you can use negative lookahead:\n", '    my($i, $num);',
  "    my $count = 0;\n    my ($start, $end);\n    $start = 0;\n    $end = $string->length\
    \ - $substring->length;\n    while ($start <= $end) {\n        my $index = $start\
    \ + $substring->length;\n        if ($index >= $string->length) { # No more matches\n\
    \            $count++;\n            $start = $index + 1; # Find the next one\n\
    \        }\n        elsif ($index > 0 && $string =~ /($substring)/i) {\n     \
    \       $count++;\n            $start = $index + 1; # Find the next one\n    \
    \    }\n        else { # $substring is a prefix of $string\n            $start\
    \ = $index + 1; # Find the next one\n        }\n    }\n    $count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,perl |>\n<| c |>\nA good answer, though I think you're\
    \ missing something in your algorithm. As I understand it, your algorithm only\
    \ works if `s` is the whole string and `substr` is the substring you're searching\
    \ for, i.e. `how_many_times('abcdefg', 'ef')` is 3. But what about `how_many_times('abcdefg',\
    \ 'fg')`? It should be 2, not 3. Your algorithm just returns the number of times\
    \ `substr` is found in the original string. In your example, the only substring\
    \ that's found is `'f'`, but that's not even a substring of \"abcdefg\". I'm also\
    \ confused by your use of `$string = $substring` after checking `$substring`.\n\
    <|/ c |>\n<| a dscore=2 |>\nYou could use an alternative approach that would give\
    \ a better performance and would also work in different cases:\n<code>", "   \
    \ my($start_pos) = index($string, $substring);\n    return 0 unless $start_pos;\n\
    \    return $start_pos + length($substring) - length($string);\n}", "    my $count\
    \ = () = $string =~ /(^|$)$substring($|$)/;\n    $count += length($1) if $string\
    \ =~ /(^|$)$substring($|$)/;\n    return $count;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    return length($string) - length($substring);\n}", "    my $count = 0;\n \
    \   $string =~ s/$substring//g;\n    foreach my $i (0 .. length($string) - length($substring)\
    \ + 1) {\n        my $j = $i + length($substring) - 1;\n        my $substring_substr\
    \ = substr($string, $i, length($substring));\n        if ($string =~ /^$substring$substring_substr$/)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    if\
    \ ($string eq \"\") {\n        return 0;\n    }", "    $string =~ tr/a-z/A-Z/;\n\
    \    my $count = () = $string =~ m/$substring/g;\n    $count++; # Account for\
    \ overlapping matches\n    $count; # Return result and count as a scalar\n}\n\
    </code>\n<|/ a |>\n<| c |>\n`()` is an array reference and so can be dereferenced\
    \ without using `@array`. `$count = $count + 1` is equivalent to `$count++`.\n\
    <|/ c |>\n<| a tags=perl,subroutine,arguments |>\nI think you might be confused\
    \ about how to pass arguments to subroutines. When you say this:\n<code>\nmy $n\
    \ = how_many_times(@strings, \"a\");\n</code>\nYou aren't passing an argument\
    \ to your subroutine, you are passing a list of arguments to your subroutine and\
    \ expecting to be used as a single argument to the subroutine. This is why you\
    \ get nothing in $n when you call the subroutine, which is why the print statement\
    \ doesn't work. Try this:\n<code>\nmy $n = how_many_times(\"a\");\n</code>\nThe\
    \ way you have your code written, is like this. First you call how_many_times(@strings,\
    \ \"a\") which invokes your subroutine. Then you call how_many_times(\"a\") which\
    \ does exactly the same thing. So then you print out the $n variable and get nothing.\n\
    <|/ a dscore=2 |>\n<| c |>\nThat explains the output I get for the print statement.\
    \  But the $n variable is still empty even with the change you suggested.  I still\
    \ get 0 returned instead of 3.\n<|/ c |>\n<| c |>\nThen you didn't change the\
    \ code properly. I'm suggesting you change the line `my $n = how_many_times(@strings,\
    \ \"a\");` to `my $n = how_many_times(\"a\");` Notice that `how_many_times(\"\
    a\")` does not pass an array as the second argument, but a string \"a\". This\
    \ means that `how_many_times(\"a\")` will invoke your subroutine and return a\
    \ value of 0, because that's what your subroutine returns.\n<|/ c |>\n<| c |>\n\
    Thanks for the clarification.  I changed the subroutine call in the main section\
    \ to `my $n = how_many_times(\"a\")` and now I get 3.  But why do I need to pass\
    \ the strings in as arguments to how_many_times()?  Shouldn't the argument be\
    \ passed by default as I defined it?\n<|/ c |>\n<| a |>\nAs I understand it from\
    \ the discussion, you're trying to find the number of times a given substring\
    \ occurs in a given string. ", "    my $total_matches = 0;\n    $string =~ s{\\\
    A$substring}{++$total_matches};\n    return $total_matches;\n}", "    my $found\
    \ = 0;\n    $string =~ s/$substring//;\n    while ($string =~ /($substring)/g)\
    \ {\n\t$found++;\n    }\n    return $found;\n}\n</code>\nFor short strings this\
    \ should be pretty good. Otherwise some kind of rolling hash might work better.\n\
    <|/ a tags=string,perl,pattern-matching,algorithm |>\n<| c |>\nThe only problem\
    \ with this is that it won't take advantage of any dictionary lookups because\
    \ of the `//g` flag that causes `$string` to become a regex every time. It will\
    \ probably work well enough for short strings, but not for longer strings.\n<|/\
    \ c |>\n<| c |>\nThat's true. Not sure if that'll matter much.\n<|/ c |>\n<| a\
    \ tags=string,perl,pattern-matching,algorithm |>\nIf you have a hash map of substrings\
    \ to counts, it can be done in O(N) time using regex alternation. The regex is\
    \ essentially an alternation on the substrings plus some special stuff to catch\
    \ the last character of the string. Here is a Python implementation:\n<code>\n\
    import re", '    $string =~ tr/a-z/A-Z/;', '    my $count = 0;', "    my $count\
    \ = 0;\n    my $start = 0;\n    while($string =~ /^$substring/ig) {\n        $count++;\n\
    \        $start = $-[0];\n    }\n    return $count;\n}", "    my $count = 0;\n\
    \    while ($string =~ /(?:$substring)(?=(?:.*?$substring)|$)/g) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    my @substrings = ();\n    my @counts = ();\n\
    \    for (my $i = 0; $i < length($string); $i++) {\n        if (index($string,\
    \ $substring) == $i) {\n            $counts[$i] = $counts[$i] + 1;\n        }\n\
    \        else {\n            push(@substrings, substr($string, $i, 1));\n    \
    \        $counts[$i] = 1;\n        }\n    }\n    return $counts[0];\n}", "   \
    \ my $count = 0;\n    for my $char (split(//, $string)) {\n        if ($char eq\
    \ $substring) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $count = () = $string =~ tr/a-zA-Z//;\n    return $count > 0 ? $count\
    \ : $string =~ tr/a/a/;\n}", "    my $count = 0;\n    \n    for my $char (split(//,\
    \ $string)) {\n        if ($char eq $substring) {\n            $count++;\n   \
    \     }\n    }\n    \n    return $count;\n}", '    $substring =~ tr/a-z/A-Z/;',
  "    my $count = 0;\n    my $s = $string;\n    my $sub = $substring;", "    my $count\
    \ = 0;\n    my $found;", "    my($i, $j, $count, $len) = @_;\n    $len = 0 if\
    \ $len < 0;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
