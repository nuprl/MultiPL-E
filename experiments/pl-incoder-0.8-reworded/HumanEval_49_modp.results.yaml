language: pl
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $m = $p;\n\
    \    my $c = 1;\n    my $e = 1;\n    while ($n > 0) {\n\t$m = $m;\n\t$c = ($n\
    \ * $e) % $p;\n\t$e = ($n * $c) % $p;\n\t$n--;\n    }\n    return $c;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\n    return 1 if $n == 0;\n    return $p - $modp_lut[$n % $p] if $n\
    \ % $p;\n    $n--;\n    return $modp_lut[$n % $p] + modp($n, $p);\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n & ((1<<$p)-1);\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = 1;\n\
    \    $r *= $n;\n    $r %= $p;\n    my $s = 1;\n    while ($r == 0) { $s *= $n;\
    \ $s %= $p; $r *= $n; $r %= $p; }\n    return $s;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = $n & 0x7fffffff;\n\
    \    $p = '' unless defined $p;\n    if ($n < 0) {\n        $n = 0xffffffff+($n+1);\n\
    \    }\n    if ($n <= 0xffff) {\n        return $n & $p;\n    }\n    return $n\
    \ >> 16 & $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($s, $m);\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp3db71nju.pl line 50, at
    end of line

    syntax error at /tmp/tmp3db71nju.pl line 50, at EOF

    Execution of /tmp/tmp3db71nju.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $mask = (1\
    \ << ($n - 1));\n    return $p & $mask;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($s, $i, $u,\
    \ $d);\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpg874jxw8.pl line 50, at
    end of line

    syntax error at /tmp/tmpg874jxw8.pl line 50, at EOF

    Execution of /tmp/tmpg874jxw8.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($n) = ($n\
    \ != 0) ? ($n & 0x7FFFFFFF) : 0;\n    my($p) = ($p != 0) ? ($p & 0x7FFFFFFF) :\
    \ 0;\n    my $r = $n % $p;\n    if ($r != 0) { $r = ($p - $r); }\n    return $r;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = abs($n);\n\
    \    $n += ($p >> 1); $p = $p & $p;\n    if($n < $p) {\n        my $res = $n &\
    \ $p;\n        $n = $p & (~$n >> 1);\n        return $res;\n    } else {\n   \
    \     return $p;\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($n, $d, $u);\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmphuhryf8x.pl line 50, at
    end of line

    syntax error at /tmp/tmphuhryf8x.pl line 50, at EOF

    Execution of /tmp/tmphuhryf8x.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \t$n = (-$n) unless $n < 0;\n\t$n = abs($n);\n\t$p = -$p if $p < 0;\n\t$n = 2\
    \ ** $n - 1;\n\t$p = 2 ** $p - 1;\n    } else {\n\t$n = 2 ** $n;\n\t$p = 2 **\
    \ $p;\n    }\n    my $ret = $n % $p;\n    return $ret if $ret;\n    return 0;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $k = log($n,\
    \ $p);\n    my $r = $k;\n    while ($k >= $p) {\n        $k /= $p;\n        $r++;\n\
    \    }\n    $r == 0 ? (1) : ($r + 1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Too many arguments for log at /tmp/tmpq68qj7n0.pl line 14, near "$p)"

    BEGIN not safe after errors--compilation aborted at /tmp/tmpq68qj7n0.pl line 22.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n %= $p;\n \
    \   if ($n < $p) {\n\t$n += $p - 1;\n    }\n    $n;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $mod;\n  \
    \  $mod |= $n >> 31 if ($n >> 31);\n    $mod |= $n >> 30 if ($n >> 30);\n    $mod\
    \ |= $n >> 29 if ($n >> 29);\n    $mod |= $n >> 28 if ($n >> 28);\n    $mod |=\
    \ $n >> 27 if ($n >> 27);\n    $mod |= $n >> 26 if ($n >> 26);\n    $mod |= $n\
    \ >> 25 if ($n >> 25);\n    $mod |= $n >> 24 if ($n >> 24);\n    $mod |= $n >>\
    \ 23 if ($n >> 23);\n    $mod |= $n >> 22 if ($n >> 22);\n    $mod |= $n >> 21\
    \ if ($n >> 21);\n    $mod |= $n >> 20 if ($n >> 20);\n    $mod |= $n >> 19 if\
    \ ($n >> 19);\n    $mod |= $n >> 18 if ($n >> 18);\n    $mod |= $n >> 17 if ($n\
    \ >> 17);\n    $mod |= $n >> 16 if ($n >> 16);\n    $mod |= $n >> 15 if ($n >>\
    \ 15);\n    $mod |= $n >> 14 if ($n >> 14);\n    $mod |= $n >> 13 if ($n >> 13);\n\
    \    $mod |= $n >> 12 if ($n >> 12);\n    $mod |= $n >> 11 if ($n >> 11);\n  \
    \  $mod |= $n >> 10 if ($n >> 10);\n    $mod |= $n >> 9 if ($n >> 9);\n    $mod\
    \ |= $n >> 8 if ($n >> 8);\n    $mod |= $n >> 7 if ($n >> 7);\n    $mod |= $n\
    \ >> 6 if ($n >> 6);\n    $mod |= $n >> 5 if ($n >> 5);\n    $mod |= $n >> 4 if\
    \ ($n >> 4);\n    $mod |= $n >> 3 if ($n >> 3);\n    $mod |= $n >> 2 if ($n >>\
    \ 2);\n    $mod |= $n >> 1 if ($n >> 1);\n    return $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($r) = 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp0ucpyx4t.pl line 50, at
    end of line

    syntax error at /tmp/tmp0ucpyx4t.pl line 50, at EOF

    Execution of /tmp/tmp0ucpyx4t.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($n) = ($n)\
    \ unless defined $n;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmptnlon18n.pl line 50, at
    end of line

    syntax error at /tmp/tmptnlon18n.pl line 50, at EOF

    Execution of /tmp/tmptnlon18n.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($k, $q);\n\
    \    if ($n < 0) {\n        $n = -$n;\n        $p = -$p;\n    }\n    $n = abs($n);\n\
    \    $p = abs($p);\n    # Avoid numeric overflow.\n    if ($p < $n) {\n      \
    \  $k = intdiv($p, $n);\n        $p = $p - $k * $n;\n    } else {\n        $q\
    \ = intdiv($n, $p);\n        $n = $n - $q * $p;\n        $k = 0;\n    }\n    return\
    \ $k + $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::intdiv called at /tmp/tmpru1cbm0x.pl line 26.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($sign, $base,\
    \ $exp) = @_;\n    my $zero = Math::BigInt->new('0');\n    $sign = 1 if $n < 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp2hv_5c7h.pl line 52, at
    end of line

    syntax error at /tmp/tmp2hv_5c7h.pl line 52, at EOF

    Execution of /tmp/tmp2hv_5c7h.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $mod2 = $n\
    \ % $p;\n    return $mod2 == $n ? $p : $mod2;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($s, $m, $u,\
    \ $v);\n    my($m, $u, $v, $rz, $w);\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpu510enma.pl line 51, at
    end of line

    syntax error at /tmp/tmpu510enma.pl line 51, at EOF

    Execution of /tmp/tmpu510enma.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $k = 256;\n\
    \    my $v = ($n / $k) % $p;\n    return $v > $p ? ($k * $v + $n % $p) : $v;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = 2**$n if\
    \ $n >= 0;\n    $p = 1<<$p if $p >= 0;\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpw7032uqt.pl line 51, at
    end of line

    syntax error at /tmp/tmpw7032uqt.pl line 51, at EOF

    Execution of /tmp/tmpw7032uqt.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n >>\
    \ 1;\n    my $n1 = $x << 1;\n    my $n2 = $n1 - $p;\n    $n2 = $n2 & $p;\n   \
    \ return $n2;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $s = 1;\n\
    \    while ($n != 0) {\n        $s = ($n * $p + $s) % $p;\n        $n >>= 1;\n\
    \    }\n    return $s;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = ($n & $p)\
    \ | (($n ^ $p) & ~($p & $n));\n    $n ^= $p >> 31;\n    $n &= $p + 1;\n    return\
    \ $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n & (-$p)\
    \ | $p if $n < 0;\n    return $n & $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 2
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p += 0;\n  \
    \  # this does not work, will it ever?\n    my $mod = ($n % $p);\n    if ($mod\
    \ >= $p) {\n        $mod -= $p;\n    }\n    else {\n        $mod += $p;\n    }\n\
    \    return $mod;\n}\n</code>\n<|/ a tags=modulus,math,perl |>\n<| c |>\n: Yeah,\
    \ I know.  The question was about Perl, so I used that tag.\n<|/ c |>\n<| c |>\n\
    What if `p` is 0?\n<|/ c |>\n<| c |>\n: That's why I said \"be aware of numerics\"\
    \ :-)\n<|/ c |>\n<| c |>\n`($n % $p) % $p` is equivalent to `($n % $p) % ($p +\
    \ $p - 1)`, which should be the same modulo `$p`.\n<|/ c |>\n<| c |>\n: Yeah,\
    \ I know.  I didn't read too carefully :-)  Anyway, that's a good catch.  I have\
    \ changed my answer accordingly.\n<|/ c |>\n<| a tags=modulus,math,perl |>\nHere's\
    \ another way to do this without modulus:\n<code>\nuse strict;\nuse warnings;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: "Number found where operator expected at /tmp/tmp_qz9cc6j.pl line 28, near\
    \ \"is 0\"\n\t(Do you need to predeclare is?)\nBareword found where operator expected\
    \ at /tmp/tmp_qz9cc6j.pl line 34, near \")  Anyway\"\n\t(Missing operator before\
    \ Anyway?)\nsyntax error at /tmp/tmp_qz9cc6j.pl line 26, near \"<|\"\nNo such\
    \ class answer at /tmp/tmp_qz9cc6j.pl line 34, near \"changed my answer\"\n\"\
    use\" not allowed in expression at /tmp/tmp_qz9cc6j.pl line 39, at end of line\n\
    BEGIN not safe after errors--compilation aborted at /tmp/tmp_qz9cc6j.pl line 40.\n"
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $m = $p;\n\
    \    my $mod;\n    $mod ||= 1;\n    while (1) {\n        if ($n == 0) {\n    \
    \        $n++;\n            last;\n        }\n        my $d = $m & $n;\n     \
    \   $m ^= $n; $n ^= $d;\n        $mod *= $p;\n        $n += $mod;\n    }\n   \
    \ return $mod;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p += 2;\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp1jhs_1ds.pl line 50, at
    end of line

    syntax error at /tmp/tmp1jhs_1ds.pl line 50, at EOF

    Execution of /tmp/tmp1jhs_1ds.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $result =\
    \ 1;\n    my $mask = (1 << $p);\n    my $i;\n    my $j;\n    my $k;\n    for ($i\
    \ = $n, $j = 0; $i > $p; $i >>= 1, $j += 1) {\n        $result ^= $i & $mask if\
    \ $j;\n    }\n    return $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($m, $k) =\
    \ $p < $m ? $p : $m;\n    for (; $k > 0; --$k) {\n        my($r1) = $n % ($p >>\
    \ 1);\n        my($r2) = ($n >> 1) % ($p >> 1);\n        $n = $r1 + $r2;\n   \
    \ }\n    $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n *\
    \ 2 ** $p - $p;\n    return $x % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $c = $n &\
    \ $p;\n    return $c > $p ? $n - $c : $n + $c;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $p if\
    \ $n == 0;\n    return 1 unless $n;\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpwfzhe059.pl line 51, at
    end of line

    syntax error at /tmp/tmpwfzhe059.pl line 51, at EOF

    Execution of /tmp/tmpwfzhe059.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n *= 2**$p;\n\
    \    return $n if $n < 1;\n    my($q) = $n % $p;\n    return $q if $q == 0;\n\
    \    return $q + modp($n+1, $p);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ <= 0);\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpxkin064_.pl line 50, at
    end of line

    syntax error at /tmp/tmpxkin064_.pl line 50, at EOF

    Execution of /tmp/tmpxkin064_.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $n = $n * -1;\n        $p = $p * -1;\n    }\n    my $x = Math::BigInt->new(2**$n);\n\
    \    $x = $x->bmod($p);\n    return $x->as_int;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "new" via package "Math::BigInt" (perhaps you
    forgot to load "Math::BigInt"?) at /tmp/tmp0i13o8kz.pl line 18.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n ^ (1\
    \ << ($n & 0x1f)) % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n %= $p;\n \
    \   $n += $p if $n < 0;\n    $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = $n %\
    \ $p;\n    if($r < 0) { $r = $p + $r; }\n    return $r;\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n % ($p\
    \ - 1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ == 0); # return 0 if $n is 0\n    my($n) = $n;\n    my($p) = $p;\n    # $n may\
    \ be an int, or a long.\n    # $p may be an int, or a long.\n    if ($n < 0) {\n\
    \        # Negative $n is equivalent to the absolute value of $n\n        my $abs\
    \ = abs($n);\n        my $sign = $n < 0 ? 1 : -1;\n        $n = $abs;\n      \
    \  $n *= $sign;\n    }\n    if ($p < 0) {\n        # Negative $p is equivalent\
    \ to the absolute value of $p\n        my $abs = abs($p);\n        my $sign =\
    \ $p < 0 ? 1 : -1;\n        $p = $abs;\n        $p *= $sign;\n    }\n    # $p\
    \ must be non-negative and $n must be non-negative\n    return ($n < $p) ? 0 :\
    \ ($n > $p) ? 1 : ($n & $p);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n  \
    \  my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $q = $n %\
    \ $p;\n    return $q > $p ? ($q - $p) : $q;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($z, $r) =\
    \ &_modp($n, $p, 2);\n    if (defined $z and $z == $n) {\n        $z;\n    }\n\
    \    else {\n        $r;\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::_modp called at /tmp/tmp9jkswxmh.pl line 14.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = int($n);\n\
    \    my $p = int($p);\n    if ($n < 0) {\n\tmy $rm = $n;\n\tsubstr($rm, 0, 1)\
    \ .= substr($rm, -1, 1);\n\t$n -= $rm;\n    }\n    my $result = 0;\n    my $d\
    \ = $p - 1;\n    while ($d != 0) {\n\t$result += (2**$d) % $p;\n\t$d = $d >> 1;\n\
    \    }\n    return $result % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($mod);\n \
    \   my($res);\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmphm7aokgq.pl line 51, at
    end of line

    syntax error at /tmp/tmphm7aokgq.pl line 51, at EOF

    Execution of /tmp/tmphm7aokgq.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n == 0;\n    return $n if $p == 0;\n    my $m = $n >> 32;\n    return $p if\
    \ $n < 0;\n    $m = ~$m  if $m == 0;\n    return $m if $p < 0;\n    $p = ~$p \
    \ if $p == 0;\n    return ($n % $p, $n / $p);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nHere's a version that allows any base (10 or 16), not just powers of\
    \ 2.  I used an implementation by Mark Byers.  It's a bit slower than the answers\
    \ posted, but it's still much faster than the standard modulus.  It also works\
    \ in 32 bit architectures.\n<code>\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'syntax error at /tmp/tmph5xp4ayg.pl line 24, near "<|"

    Search pattern not terminated at /tmp/tmph5xp4ayg.pl line 24.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my ($mod, $rem)\
    \ = ($p, '1') if $p < 1;\n    my $x = $n % $p;\n    $x++ if $x >= $mod;\n    return\
    \ $x if $rem < $x;\n    $x -= $mod if $mod > 1;\n    return $x;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $t = $n *\
    \ $p % $p; # Modular exponentiation\n    return $t if $t < $p && $t != 0; # Return\
    \ n if n == 0.\n    return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\n    $n = ($n % $p) + $p;\n    return $n if $n < 0;\n    $n -= $p;\n\
    \    return $n if $n == 0;\n    return $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($q, $d);\n\
    \    # Special cases: p is 1 and $q is 1.\n    return ($n <= 1 ? 1 : $n % $p ==\
    \ 0 ? $n : $n);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ & $p);\n    return $n if ($n & ~$p);\n    return $n % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if $n\
    \ == 0;\n    return 1 if $n == 1;\n    if ($n < 0) {\n        $n = -$n;\n    \
    \    $p = -$p;\n    }\n    if ($n == 1 && $p == 1) {\n        return 2;\n    }\n\
    \    my $res = $n % $p;\n    return 0 if $res == 0;\n    return $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 unless\
    \ $n && $p;\n    return 0 unless $n;\n    return 0 unless $p;\n    return 0 unless\
    \ $n >= $p;\n    return $n & ($p-1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $n = -$n;\n        $p = -$p;\n    }\n    return Math::BigInt->new($p->bpow($n));\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "bpow" via package "5" (perhaps you forgot
    to load "5"?) at /tmp/tmpphefwn2x.pl line 18.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($s, $q, $r);\n\
    \    $r = $p % $n;\n    $s = $n >> 1;\n    while ($r > 0) {\n        $s = $s +\
    \ $q;\n        $q = $q + 1;\n        $r = $r >> 1;\n    }\n    return $s;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $n = -$n;\n        $p = $p * -1;\n    }\n    elsif ($n == 0) {\n    \
    \    return $p;\n    }\n    $n %= $p;\n    if ($n < 0) {\n        $n = $p + $n;\n\
    \    }\n    return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \tmy $r = $p % abs($n);\n\treturn $p if $n == 0;\n\t$n = -$n;\n\t$r = -$r;\n \
    \   }\n    # $n == 0 -> 1\n    if ($n == 0) {\n\treturn 1;\n    }\n    # $n <\
    \ 0 -> modp($n, $p) - 1\n    return $p if $n < 0;\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp6_hzyuwk.pl line 61, at
    end of line

    syntax error at /tmp/tmp6_hzyuwk.pl line 61, at EOF

    Execution of /tmp/tmp6_hzyuwk.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($mod) = $p;\n\
    \    my $r = $n % $mod;\n    # $n / $mod == $r if $r divides evenly into $n.\n\
    \    $r = $r / $mod if $r % 2 == 0;\n    return $r;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p > $n ||\n\t\
    Carp::confess(\"Invalid modulus $n (must be positive integer)\");\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpfp_xv5tm.pl line 51, at
    end of line

    syntax error at /tmp/tmpfp_xv5tm.pl line 51, at EOF

    Execution of /tmp/tmpfp_xv5tm.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($q, $r);\n\
    \    my($d, $s);\n    my($t);\n    my(@m);\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmps8v0h47j.pl line 53, at
    end of line

    syntax error at /tmp/tmps8v0h47j.pl line 53, at EOF

    Execution of /tmp/tmps8v0h47j.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\n    return $p if $n >= $p;\n    my $r = 1;\n    my $i;\n    $n -=\
    \ 1;\n    while($n >= $p) {\n        $r = $r * $i;\n        $n = $n / $p;\n  \
    \      $i++;\n    }\n    $r *= $i;\n    return $r;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my ($ans, $mod);\n\
    \    my @mods = (1 .. $p);\n    my $mod = $mods[$n & $mods[-1]];\n    while ($n\
    \ >= $mod) {\n        $n = ($n%$mod) * $mods[-1];\n        $mod = $mods[$n & $mods[-1]];\n\
    \    }\n    if ($n == $mod) {\n        $ans = 1;\n    } else {\n        $ans =\
    \ 0;\n    }\n    return $ans;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate\
    \ this but I have to use it for an assignment and I must use the modulus. And\
    \ thank you for taking the time to explain it.\n<|/ c |>\n<| a |>\n<code>\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'syntax error at /tmp/tmpeva599j1.pl line 29, near "<|"

    "use" not allowed in expression at /tmp/tmpeva599j1.pl line 32, at end of line

    Execution of /tmp/tmpeva599j1.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if $p\
    \ == 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpflxiswhu.pl line 50, at
    end of line

    syntax error at /tmp/tmpflxiswhu.pl line 50, at EOF

    Execution of /tmp/tmpflxiswhu.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = 1;\n\
    \    while ($n) {\n\t$r <<= 1;\n\tmy $t = $n % $p;\n\t$r |= $t != 0;\n\t$n -=\
    \ $t;\n    }\n    return $r;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n  \
    \  my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ok!
  timestamp: 1660013942
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $remainder;\n\
    \    if ($n >= $p) {\n        return $p;\n    }\n    my $q = modp($n, $p);\n \
    \   $remainder = $n % $p;\n    return $q + (($remainder != 0) ? $p : $q-1);\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = Math::BigInt->new($n);\n\
    \    $r->bmod($p);\n    $r;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n   \
    \ my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "new" via package "Math::BigInt" (perhaps you
    forgot to load "Math::BigInt"?) at /tmp/tmpvnb_ojy5.pl line 14.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n == 0)\
    \ {\n        return $p;\n    }\n    if ($n == 1) {\n        return $p;\n    }\n\
    \    # Modular reduction is easy.\n    return $n - ($n & ($n - 1));\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = $n & ($p-1);\n\
    \    $n += $p if $n > $p;\n    return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\n    return $n if $n == 1;\n    return $n if $n == $p;\n    return\
    \ $p - $n - 1;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n != 0)\
    \ {\n        $p *= $n >> 9;\n        $p %= $p;\n        if ($n & 1) {\n      \
    \      $p *= $p; // 2\n            $p %= $p;\n        }\n    }\n    $p;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: "Number found where operator expected at /tmp/tmp5n3et59j.pl line 18, near\
    \ \"// 2\"\n\t(Missing operator before  2?)\nScalar found where operator expected\
    \ at /tmp/tmp5n3et59j.pl line 19, near \"$p\"\n\t(Missing semicolon on previous\
    \ line?)\nsyntax error at /tmp/tmp5n3et59j.pl line 18, near \"// 2\"\nBEGIN not\
    \ safe after errors--compilation aborted at /tmp/tmp5n3et59j.pl line 24.\n"
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($mod) = $p\
    \ % $n;\n    return $mod == 0 ?  $n : $mod;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $e = ($n >>\
    \ 1) - 1;\n    my $d = $n->{sign} ? $n->{_n} : 1;\n    my $g = $d->{_[0]}->{sign}\
    \ ? $d->{_[0]}->{_n} : 1;\n    $g = ($g + ($e << 1)) %  $p;\n    $g = $g + ($e\
    \ << 2) if ($e < 0x3ff);\n    $g = ($g + $e) %  $p;\n    return $g;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'syntax error at /tmp/tmprkl33o6s.pl line 16, near "_["

    syntax error at /tmp/tmprkl33o6s.pl line 21, near "}"

    Execution of /tmp/tmprkl33o6s.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if $n\
    \ == 0;\n    if ($n == 1) {\n        return $p;\n    }\n    my($m) = modinverse($n);\n\
    \    if ($m < $p) {\n        # $m*$m = ($n-1)/($n-1)\n        # $n - ($n-1)/2\
    \ = $m*$m + $m\n        # $m = $m*$m + $n - $m*$m\n        $m = $m*$m + $n - $m*$m;\n\
    \    } else {\n        # $m*$m = ($n+1)/($n+1)\n        # $n + ($n+1)/2 = $m*$m\
    \ - $m\n        # $m = $m*$m - $m\n        $m = $m*$m - $m;\n    }\n    return\
    \ $m;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::modinverse called at /tmp/tmpxtakaocn.pl line
    18.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = int($n);\n\
    \    my $p = int($p);\n    my $max_bits = $p >> 3;\n    my $bits = $p & 7;\n \
    \   my $mask = 1 << $bits;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp9hsvqqkm.pl line 54, at
    end of line

    syntax error at /tmp/tmp9hsvqqkm.pl line 54, at EOF

    Execution of /tmp/tmp9hsvqqkm.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $mask = (($n\
    \ & $p) == $n) ? 1 : 0;\n    return (($n ^ $p) & ~$mask) >> ($p & 63);\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n; $n\
    \ %= $p;\n    if ($x == 0) { $x = 1; $p -= 1; }\n    return $x;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # Find a divisor\
    \ of n that is a multiple of p. This may be the\n    # closest number to n that\
    \ is a multiple of p.\n    #\n    # First find m such that m is no more than floor(n/p).\n\
    \    # Then find d such that d*p+n is no more than n.\n    #\n    # n is no more\
    \ than p*m+d and the nearest such divisor is d*p+n.\n    #\n    # Let n be m+d+1\
    \ and d be the smallest d such that d*p+n is\n    # no more than n.\n    #\n \
    \   # Let m be the smallest m such that m*p+d is no more than\n    # n.\n    #\n\
    \    # Let m be the smallest m such that n*p+d is no more than\n    # n.\n   \
    \ #\n    # Then the nearest multiple of p that is no greater than m+d+1 is\n \
    \   # p+d+1.\n    #\n    # And finally, since p+d+1 is a multiple of p, it must\
    \ be the last\n    # such multiple of p.\n    #\n    # Thus, we can find p by\
    \ repeatedly adding 1 to p and checking whether\n    # it changes the result.\
    \ We don't need to test whether it changes the\n    # result every time we add\
    \ 1 to a given number because the last\n    # multiple that satisfies that condition\
    \ will work when added to p.\n    #\n    # However, we have to keep doing this\
    \ until\n    # we've added n to p exactly once or we've tried too many times.\n\
    \    # That's because the final result may be p itself or a multiple of p.\n \
    \   # In the first case, it doesn't matter that m == d because if p==m\n    #\
    \ then p+d+1 will also be divisible by p. In the second case, adding 1\n    #\
    \ would cause p to be a multiple of p, and in the third case it would\n    # cause\
    \ m to be a multiple of p also. Since p can be any divisor, we\n    # need to\
    \ check whether m is a multiple of p too. We can check if m\n    # is a multiple\
    \ of p by repeatedly adding 1 to m and checking whether it\n    # changes the\
    \ result.\n    #\n    # There's a problem if m is just 1 or 0. But since 0 cannot\
    \ be\n    # expressed as a multiple of 1, we can safely assume that m is not\n\
    \    # just 1 or 0. We can also safely assume that m is not a multiple of\n  \
    \  # p unless we check whether m is a multiple by repeatedly adding 1\n    # to\
    \ m and checking whether it changes the result.\n    #\n    # From that, we can\
    \ conclude that m can only be a multiple of\n    # p if:\n    #\n    # 1. p is\
    \ not a multiple of m. In this case, we have to check whe\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpkksl11p_.pl line 98, at
    end of line

    syntax error at /tmp/tmpkksl11p_.pl line 98, at EOF

    Execution of /tmp/tmpkksl11p_.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $nmod = $n\
    \ % $p;\n    if ($nmod != 0) {\n\t$nmod -= $p;\n\t$nmod += $p;\n    }\n    return\
    \ $nmod;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $modulus =\
    \ $p % $n;\n    $modulus == $n or return $modulus;\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp9o_liudy.pl line 51, at
    end of line

    syntax error at /tmp/tmp9o_liudy.pl line 51, at EOF

    Execution of /tmp/tmp9o_liudy.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if $n\
    \ == 0;\n    return $p if $n <= $p;\n    return $n % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $p > $n;\n    return $p if $n <= 0;\n    return $p if $n < 0;\n    return $n\
    \ if $n % $p;\n    return $p if $p % $n;\n    return $n % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $tmp = $n;\n\
    \    my $mod = $p % $tmp;\n    if(!defined $mod && $tmp !~ /^0+$/) {\n       \
    \ $mod = 1;\n    }\n    return $mod;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n == 0;\n    return $n if $p < $n;\n    my $a = $n;\n    my $b = $p / $n;\n\
    \    my $c = $p % $n;\n    return $n % $p if $b <= $c;\n    return $n % $p + ($c\
    \ - $b + $n) % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \t# Negative number\n\tmy $k = abs($n);\n\t$n = ($k + (-1)) % ($k + 1);\n    }\
    \ elsif ($n == 0) {\n\t$n = 0;\n    } else {\n\t# Positive number\n\tmy $k = ($n\
    \ + (-1)) % ($n + 1);\n\tmy $n1 = $n - ($k + (-1));\n\t$n = ($n1 - $k + 1) % ($n\
    \ + 1);\n    }\n    return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n %= $p;\n \
    \   $n == 0 or $n == 3 or $n == $p or $n % $p == 0 or $n != $p or $n >= $p;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p = $p % $n;\n\
    \    # return $p if $p == 0\n    return $n if $p == 0;\n    # return $n if $n\
    \ == 1\n    return $n if $n == 1;\n    # return $n if $p < $n\n    return $p if\
    \ $p < $n;\n    # return $n % $p % $n if $p > $n\n    return $n % $p % $n;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # Find n such\
    \ that 2^n % p == 1 and 2^n >= p.\n    # Note: this is quadratic so may take some\
    \ time.\n    my $g;\n    for ($n = 1 until $n && ($g = $n * $n % $p) == 1 && $n\
    \ >= $p && $g >= $p;\n        $n++);\n    return $n if $g == $p;\n    # Return\
    \ 2^n modulo p.\n    return $g if $g >= $p;\n    return $g - $p + 2;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'syntax error at /tmp/tmp0f2hgmxs.pl line 18, near "++)"

    syntax error at /tmp/tmp0f2hgmxs.pl line 19, near "$n if"

    syntax error at /tmp/tmp0f2hgmxs.pl line 21, near "$g if"

    syntax error at /tmp/tmp0f2hgmxs.pl line 23, near "}"

    syntax error at /tmp/tmp0f2hgmxs.pl line 30, near "}else"

    syntax error at /tmp/tmp0f2hgmxs.pl line 57, near "}"

    Execution of /tmp/tmp0f2hgmxs.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($ret);\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpdbbbi6kl.pl line 50, at
    end of line

    syntax error at /tmp/tmpdbbbi6kl.pl line 50, at EOF

    Execution of /tmp/tmpdbbbi6kl.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $c = 1;\n\
    \    my $m = 1;\n    $p += $p - 1;\n    for (; $c <= $p; $c++) {\n        my $r\
    \ = Math::BigInt->new($n);\n        $r->bmod($m)->bmul($m) = $m;\n        $m *=\
    \ $c;\n    }\n    return $m;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n  \
    \  my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "new" via package "Math::BigInt" (perhaps you
    forgot to load "Math::BigInt"?) at /tmp/tmpg0jobrso.pl line 18.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # $n == 0 should\
    \ give 1, but we allow it to be 0.\n    # Perl chokes on $p == 0 anyway, so handle\
    \ it specially.\n    return 1 unless $n;\n    $n %= $p;\n    if ($n < 0) {\n \
    \       my $r = $p >> 1;\n        $r ^= $n;\n        return $r;\n    } else {\n\
    \        return $p;\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my %x = $n =~\
    \ /^(\\d+)$/;\n    my $m = $x{'1'} % $p;\n    my @a;\n    for (my $i = 0; $i <\
    \ $n; ++$i) {\n        my $x = $i << 1;\n        $x++ while $x * $p < $m * $x;\n\
    \        push @a, $x;\n    }\n    return $x{'1'} = $a[$#a];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my ($x, $y) =\
    \ @_;\n    $x -= $y; $x %= $p;\n    if ($x < 0) { $x += $p; }\n    $x;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $u = ($p >>\
    \ 1) & 0x7FFFFFFF;\n    my $v = ($p >> 29) & 0x3FFFFFFF;\n    return $n * $u +\
    \ ($n & $v) % ($p + 1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($rc, $rs)\
    \ = call_fp_func(\\&Math::BigInt::_modp);\n    my $n1 = $n;\n    my $rn = $n >=\
    \ 0 ? $n : $n->copy();\n    # $rs = $rs->copy() unless defined $rs;  # not needed\
    \ in BigInt\n    # $rs->_lt($rs->_abs() . $p);\n    my $rn = $rn >= 0 ? $rn :\
    \ $rn->copy();\n    my $rs_copy = $rs;\n    my $rs_neg = $rs_copy->copy();\n \
    \   my $rs_neg_abs = $rs_copy->_abs();\n    $rs_copy->_lt($rs_copy->_abs() - $p);\n\
    \    if ($rs_copy->_sign() == 0) {\n        return $rs_copy;\n    }\n    $rs =\
    \ $rs_copy;\n    # $rs->_div($p);\n    $rn = $rn->div($p);\n    # $rn = Math::BigInt->_div($rn,\
    \ $p);\n    $rs = $rs->div($p);\n    # $rs = Math::BigInt->_div($rs, $p);\n  \
    \  if ($rs->is_zero() || $rs->_eq($rs_copy)) {\n        return $rn;\n    }\n \
    \   my $rs = $rs->_copy();\n    my $rs_neg = $rs->_copy();\n    $rs_neg->_add($rs_neg_abs);\n\
    \    $rs = $rs->_mul($p);\n    $rn = $rn->_mul($p);\n    # $rs = Math::BigInt->_mul($rs,\
    \ $p);\n    # $rs = Math::BigInt->_mul($rn, $p);\n    $rs = $rs->_mul($p);\n \
    \   # $rs = Math::BigInt->_mul($rs, $p);\n    $rs = $rs->_div($p);\n    if ($rs->is_zero()\
    \ || $rs->_eq($rs_copy)) {\n        return $rn;\n    }\n    $rs = $rs->_copy();\n\
    \    my $rs_neg = $rs->_copy();\n    $rs_neg->_add($rs_neg_abs);\n    $rs = $rs->_mul($p);\n\
    \    $rn = $rn->_mul($p);\n    # $rs = Math::BigInt->_mul($rs, $p);\n    # $rs\
    \ = Math::BigInt->_mul($rn, $p);\n    $rs = $rs->_mul($p);\n    # \nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp9fq3alw0.pl line 93, at
    end of line

    syntax error at /tmp/tmp9fq3alw0.pl line 93, at EOF

    Execution of /tmp/tmp9fq3alw0.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ( $n == 0\
    \ ) {\n        return 1;\n    }\n    elsif ( $n == 1 ) {\n        return $p;\n\
    \    }\n    elsif ( $n >= $p ) {\n        return $p - 1;\n    }\n    else {\n\
    \        my $a = $p - 1;\n        my $b = $n % $p;\n        my $r = $a / $p;\n\
    \        $r = $p if $r == 1;\n        $r = $p - $n if $r == $p - 1;\n        return\
    \ $r * modp($r, $p);\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n   \
    \ my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n2 = $n >>\
    \ 1;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp8r4n_pgx.pl line 50, at
    end of line

    syntax error at /tmp/tmp8r4n_pgx.pl line 50, at EOF

    Execution of /tmp/tmp8r4n_pgx.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($z, $a);\n\
    \    if ($n < 0) {\n\t$n = -$n;\n\t$p = $p + 1 if $p > 0;\n    }\n    $n = $n\
    \ * $p;\n    while ($n > $p) {\n\t$z = (($z * $a) % $p + $p) % $p;\n    }\n  \
    \  return $z;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my ($carry) =\
    \ 0;\n    my $result = $n;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpej2wgyaa.pl line 51, at
    end of line

    syntax error at /tmp/tmpej2wgyaa.pl line 51, at EOF

    Execution of /tmp/tmpej2wgyaa.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p = 1 if $p\
    \ < 0;\n    return $n % $p + ($n // $p) * $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $i = $n %\
    \ $p;\n    return $i if $i == 0;\n    return ($p - $i) + $i;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # NOTE: Not sure\
    \ about $m and $p. For $n, $m is number of bits, and\n    # $p is modulus.\n \
    \   my $q = int(($n * $p + 2**$p) / 2**$n);\n    if ($q > 2**$n)\n    {\n    \
    \    my $a = 2**$n;\n        my $b = 2**$q;\n        return $a < $b ? $a : $b;\n\
    \    }\n    else\n    {\n        return $q;\n    }\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if ($n\
    \ <= 0);\n    $n -= $p % $n;\n    $n % $n ? $n : $n - 1;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # Only accept\
    \ numbers between 0 and 2**n - 1\n    return $n if $n < 0 || $n >= 2**$p;\n  \
    \  # Compute n modulo p\n    # 2^n modulo p is equal to 2^(p+1) - 1\n    return\
    \ 2**$p+1 if $n & 1;\n    # Divide by 2 in 2's complement\n    return 1 if ($n\
    \ % 2);\n    return -1;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($r1, $r2,\
    \ $r3);\n    my($q1, $q2);\n    my($q3, $q4, $q5, $q6, $q7, $q8, $q9, $q10, $q11,\
    \ $q12, $q13, $q14, $q15, $q16, $q17, $q18, $q19, $q20, $q21, $q22, $q23, $q24,\
    \ $q25, $q26, $q27, $q28, $q29, $q30, $q31, $q32, $q33, $q34, $q35, $q36, $q37,\
    \ $q38, $q39, $q40, $q41, $q42, $q43, $q44, $q45, $q46, $q47, $q48, $q49, $q50,\
    \ $q51, $q52, $q53, $q54, $q55, $q56, $q57, $q58, $q59, $q60, $q61, $q62, $q63,\
    \ $q64, $q65, $q66, $q67, $q68, $q69, $q70, $q71, $q72, $q73, $q74, $q75, $q76,\
    \ $q77, $q78, $q79, $q80, $q81, $q82, $q83, $q84, $q85, $q86, $q87, $q88, $q89,\
    \ $q90, $q91, $q92, $q93, $q94, $q95, $q96, $q97, $q98, $q99, $q100) =\n     \
    \   ($n, $p);\n    my($r1_1, $r1_2, $r1_3, $r1_4, $r1_5, $r1_6, $r1_7, $r1_8,\
    \ $r1_9, $r1_10, $r1_11, $r1_12, $r1_13, $r1_14, $r1_15, $r1_16, $r1_17, $r1_18,\
    \ $r1_19, $r1_20, $r1_21, $r1_22, $r1_23, $r1_24, $r1_25, $r1_26, $r1_27, $r1_28,\
    \ $r1_29, $r1_30, $r1_31, $r1_32, $r1_33, $r1_34, $r1_35, $r1_36, $r1_37, $r1_38,\
    \ $r1_39, $r1_40, $r1_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmprlbxp4kv.pl line 19, at end
    of line

    syntax error at /tmp/tmprlbxp4kv.pl line 19, near "$r1_

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmprlbxp4kv.pl line 54, at end of
    line

    syntax error at /tmp/tmprlbxp4kv.pl line 54, at EOF

    Execution of /tmp/tmprlbxp4kv.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($r, $q, $m)\
    \ = Math::BigInt::_lsft($n, $p, $p);\n    my($h);\n    if ($r eq $q && $r eq $m)\
    \ {\n        $h = $n;\n    }\n    else {\n        $h = $m;\n        $h = $h->bmodp($p);\n\
    \    }\n    return $h;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &Math::BigInt::_lsft called at /tmp/tmphbdgzdih.pl
    line 14.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = $n->copy();\n\
    \    $n->{sign} = 0;\n    $n->{_modulus} = $p;\n    $n;\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "copy" via package "3" (perhaps you forgot
    to load "3"?) at /tmp/tmpcx3whv47.pl line 14.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $d = $n -\
    \ $p;\n    return $d if $d == -$p;\n    return $d if $n == 0 or $n % $p != 0;\n\
    \    return $n % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($mod) = $p\
    \ % $n;\n    return $mod if $mod < 0;\n    return $n if $mod > 0;\n    return\
    \ $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $m = 1;\n\
    \    while (--$n) {\n\t$m ^= $p if $p % 4;\n\t$m %= $p  if $p % 2;\n\t$p /= 2;\n\
    \    }\n    return $m;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $n = -$n;\n        $p = -$p;\n    }\n    my $result = $n;\n    my $carry\
    \ = 0;\n    my $max_digits = $p - 1;\n    for (my $i = 1; $i < $max_digits; $i++)\
    \ {\n        if ($n >= $p) { \n            $result += ( ($n % $p) * $carry + $n)\
    \ / $p; \n            $carry = $n % $p; \n            $n = int( $n / $p ); \n\
    \        }\n    }\n    return $result + $carry if $carry;\n    return $result;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($modulus)\
    \ = $modulus * $p;\n    if ($modulus < 1) {\n        $modulus = 0;\n    }\n  \
    \  $modulus = 2 ** $modulus;\n    $modulus %= $p;\n    if ($modulus == 0) {\n\
    \        $modulus = 1;\n    }\n    $modulus > $n and return $n;\n    $modulus;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $sign = 1;\n\
    \    if ($p == $n) {\n\t$sign = 0;\n    } elsif ($n < 0) {\n\t$sign = 0;\n\t$n\
    \ = -$n;\n    }\n    if ($n != 0) {\n\treturn $p ** $sign;\n    }\n    return\
    \ 1;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($g, $s, $i)\
    \ = (0, 10, 0);\n    while ($n >= $p) {\n        $g += $s / $i;\n        $s =\
    \ $i % 10;\n        $i *= 10;\n    }\n    return $g;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 unless\
    \ $n;\n    $n %= $p;\n    if ($n == 0) {\n\t$n = 1;\n    } else {\n\t$n = 2**($p\
    \ - $n);\n    }\n    return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($a, $b, $m,\
    \ $t);\n    $n = 0 unless defined $n;\n    $p = 0 unless defined $p;\n    $n =\
    \ 2**$n if $n =~ /-inf/;\n    $m = 2**$p if $p =~ /-inf/;\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpsiqdjwk1.pl line 54, at
    end of line

    syntax error at /tmp/tmpsiqdjwk1.pl line 54, at EOF

    Execution of /tmp/tmpsiqdjwk1.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 unless\
    \ $n <= $p;\n    return $p if $n == 0;\n    return $p - $n*int(($p/$n)&~1);\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if $n\
    \ == 0;\n    return $n % $p if $n < $p;\n    return $p - $n % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($base, $mod,\
    \ $result) = (0, $n, 0);\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmprlcwa6ke.pl line 50, at
    end of line

    syntax error at /tmp/tmprlcwa6ke.pl line 50, at EOF

    Execution of /tmp/tmprlcwa6ke.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n % $p;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $result =\
    \ $n % $p;\n    if ($result < 0) { $result += $p }\n    return $result;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $result =\
    \ 1;\n    my @bits = split(//, $n);\n    my $k = shift(@bits);\n    my $d = shift(@bits);\n\
    \    $result *= 2**$k;\n    for(my $i = 0; $i < $d; $i++) {\n        $result %=\
    \ $p;\n    }\n    return $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($r) = Math::BigInt->new(\"\
    1\");\n    my($one);\n    my ($sign) = 0;\n    my $x = $r->{value} = 0;\n    my\
    \ $neg = 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpdkv12tsv.pl line 54, at
    end of line

    syntax error at /tmp/tmpdkv12tsv.pl line 54, at EOF

    Execution of /tmp/tmpdkv12tsv.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $ppow = ppow($p,\
    \ $n);\n    return $n if $npwr == $ppow;\n    return $ppow % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::ppow called at /tmp/tmprtr7uhgt.pl line 14.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n_ = $n;\n\
    \    my $p_ = $p;\n    my $mod;\n    my $r;\n    my ($sign, $x); # sign is 1 for\
    \ positive and -1 for negative\n    $sign ||= 1;\n    $x = $n_;\n    $mod = $p_\
    \ % $p_; # $x % p;\n    while (1) {\n        $r = $x % $p_;\n        if ($r ==\
    \ 0) {\n            $x = $n_;\n        }\n        else {\n            $n_ = ($sign\
    \ * $n_ + $p_ - $r) %$p_;\n            $sign *= -1;\n        }\n        if ($x\
    \ == $n_) {\n            $mod = $p_;\n            last;\n        }\n        $mod\
    \ = $mod * $p_ + $p_;\n    }\n    $sign *= -1; # return sign * r\n    if ($mod\
    \ == 0) {\n        $mod += $p_;\n    }\n    return $mod;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n;\n\
    \    my $q = $p;\n    $x %= $q;\n    if ($x == 0) {\n        return 1;\n    }\n\
    \    my $w = 1;\n    while ($x) {\n        $w = ($w << 1) + ($x & 1);\n      \
    \  $x >>= 1;\n    }\n    return $w;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n & ($p\
    \ - 1); \n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $n = (-$n) + 1;\n        $p = $p % -$n;\n    }\n    return 0 unless $p;\n\
    \    $n = 2 ** $n;\n    my $r = $n % $p;\n    my $remainder = $n % $p;\n    $remainder\
    \ -= 1;\n    return $r + (($r + 1) % $p) if $remainder > 0;\n    $r -= $p * (($r\
    \ - 1) / $p);\n    return $r + $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return if $n\
    \ <= 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp_x5hf2qo.pl line 50, at
    end of line

    syntax error at /tmp/tmp_x5hf2qo.pl line 50, at EOF

    Execution of /tmp/tmp_x5hf2qo.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $i = $n;\n\
    \    $i = '0' unless $i =~ /[01]/;\n    my $mod = 0;\n    while (--$i >= 0) {\n\
    \        $mod = 1 if ($i % $p);\n        $mod *= 2;\n    }\n    return $mod;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if $n\
    \ == 0;\n    if ($p == 0) {\n        return 1;\n    }\n    $p = ($p - 1) % $p;\n\
    \    return $n & ($p - 1) if $n > 0;\n    return $n & ($p - 1);\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = 0 if $n\
    \ < 0;\n    $p = 0 if $p < 0;\n    if ($n && $p) {\n        my $r = 1;\n     \
    \   while ($n >= $p) {\n            $n--;\n            $r = 2**$n if $r;\n   \
    \     }\n        return $r;\n    } else {\n        return 1 if ($n && !$p);\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $nref = \\\
    \ $n;\n    my $pref = \\ $p;\n    my @r = ();\n    my $i = 0;\n    my $j = 0;\n\
    \    my $k = 0;\n    my $tmp;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp9zx82lcr.pl line 56, at
    end of line

    syntax error at /tmp/tmp9zx82lcr.pl line 56, at EOF

    Execution of /tmp/tmp9zx82lcr.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $t = $n <<\
    \ 1;\n    $t %= $p;\n    return $t if $t == 0;\n    # $t < $p ? $t : modp($t -\
    \ $p, $p);\n    return $t if $t < $p; # $t - $p = $t % p\n    return $t - $p;\
    \ # $t % p\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($gcd);\n \
    \   my($rem);\n    my $i = $n % $p;\n    if ($i == 0) {\n\t$gcd = $p;\n    } elsif\
    \ ($i != $p) {\n\t$rem = $n % $p;\n\t$gcd = modp($gcd, $p);\n\t$gcd = ($gcd ==\
    \ 0? $p : $gcd);\n\t$n = $rem / $gcd;\n    }\n    return $n * $p;\n}\n1\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmppe56qt9g.pl line 28, at end
    of line

    syntax error at /tmp/tmppe56qt9g.pl line 28, near "use Test::Deep"

    Execution of /tmp/tmppe56qt9g.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $k = ($n <\
    \ 0) ? (-$n) : $n;\n    my $r = 1;\n    while (0 <= $k and $k < $p) {\n\t$r *=\
    \ $k;\n\t$k /= $p;\n    }\n    if ($n == 0) {\n\treturn 1;\n    }\n    else {\n\
    \treturn $r;\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        $p--;\n        $n = -$n;\n    }\n    return ($p * $n) % $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < $p)\
    \ {\n\tmy $r = $n;\n\tmy $q = $p / $r;\n\t$q++ while ($q > $n);\n\t$r -= $q;\n\
    \treturn $r;\n    }\n    my $r = $p % $n;\n    $r++ while ($r > $n);\n    return\
    \ $r;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if $n\
    \ == 0;\n    my $result = 0;\n    while ($n != 0) {\n        $n = $n % $p;\n \
    \       $result = $p * $result + $p if $result != $p;\n    }\n    return $result;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013942
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $m = $n %\
    \ $p;\n    if ($m != 0) {\n\t$n -= $m;\n\t$m += $p - 1;\n\t$n = ($n / $p) * $p;\n\
    \t$m -= 1;\n    } else {\n\t$n = $n % $p;\n    }\n    $n;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n_is_odd\
    \ = $n % 2;\n    $n = 0 if $n_is_odd && $n =~ /^1\\d$/;\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpgtcv0lpc.pl line 51, at
    end of line

    syntax error at /tmp/tmpgtcv0lpc.pl line 51, at EOF

    Execution of /tmp/tmpgtcv0lpc.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $i = $n >>\
    \ 24;\n    $i = $i + ($n & 0x00ffffff) >> 24;\n    $i = $i + ($n & 0x0000ffff)\
    \ >> 16;\n    $i = $i + ($n & 0x000000ff) >> 8;\n    $i = $i + ($n & 0x0000000f)\
    \ >> 4;\n    $i = $i + ($n & 0x00000003) >> 2;\n    $i = $i + ($n & 0x00000001);\n\
    \    return $p ^ $i;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n;\n\
    \    my $q = $p;\n    while (!($x & $q)) {\n\t$x -= $q;\n\t$q *= 2;\n    }\n \
    \   $x;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = $n %\
    \ $p;\n    if ($r == 0) {\n\treturn $p;\n    }\n    return $n;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ ($n =~ /^\\d+$/);\n    $n += 0;\n    my $x = $n;\n    while (1) {\n        if\
    \ ($x % $p != 0){\n            return $x;\n        }\n        $x = $x/$p;\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my @a = map {$_\
    \ % $p} @_;\n    my $r = $a[0];\n    my $i;\n    for ($i = 1; $i < @a; ++$i) {\n\
    \tmy $k = $a[$i];\n\t$r += $k;\n\t$r %= $p;\n    }\n    return $r;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if ($p\
    \ < 1);\n    $p = ($p - 1) % $n;\n    return $n if ($n < 0);\n    return 1 if\
    \ ($n == 0);\n    return $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n  \
    \  my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \        my ($s, $e) = @{$_[1]};\n        $e = 0 if $e < 0;\n        $n = 0 -\
    \ $n;\n        my $r = $s % $p;\n        $e++ if $r <= $e;\n        $r = ($r -\
    \ $e) % $p;\n        return $r + ($n < 0 ? $p : 0);\n    } else {\n        my\
    \ ($s, $e) = @{$_[0]};\n        $e = 0 if $e < 0;\n        $n = 0 - $n;\n    \
    \    my $r = $s % $p;\n        $e++ if $r > $e;\n        $r = ($r - $e) % $p;\n\
    \        return $r + ($n < 0 ? -$p : 0);\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $q = $n %\
    \ $p;\n    if ($q > 0) { $q - $p };\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = $n |\
    \ 0;\n    my $p = $p | 0;\n    my $m = 1;\n    my $a = $p >> 1; # $p must be odd!\n\
    \    while ($n == 0) {\n        $m = ($m << 1) | $a; # $m is 1<<n\n        $n\
    \ = ($n >> 1) & $p;\n        $a = $a >> 1;\n    }\n    return $m * $p;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $result;\n\
    \    $result = ($n % $p) == 0 ? $n : -1;\n    return $result;\n}\n</code>\n<|/\
    \ a tags=math,c++,modular-arithmetic |>\n<| c |>\nThanks for your answer, I really\
    \ appreciate it!\n<|/ c |>\n<| a |>\nHere's a solution in Java, based on a formula\
    \ (which can be found here).\n<code>\npublic static int modPow(final int base,\
    \ final int exponent) {\n    if (exponent == 0)\n        return 1;\n    if (exponent\
    \ < 0)\n        return 0;\n    int result = 1;\n    while (exponent > 0) {\n \
    \       if (exponent % 2 == 1) {\n            result *= base;\n        }\n   \
    \     result %= base;\n        exponent /= 2;\n        base *= base;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=math,c++,modular-arithmetic dscore=3\
    \ |>\n<| c |>\nYou forgot to check for negative exponents.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe most efficient way is probably to use exponentiation by squaring.\n\
    See e.g. http://en.wikipedia.org/wiki/Exponentiation_by_squaring\n<|/ a tags=math,c++,modular-arithmetic\
    \ |>\n<| a dscore=2 tags=math,c++,modular-arithmetic |>\nI took an algorithm of\
    \ Joseph York's answer above and implemented it in C++. \n<code>\nlong modPow(long\
    \ base,long exponent){\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: "Semicolon seems to be missing at /tmp/tmpw4raxykm.pl line 22.\nsyntax error\
    \ at /tmp/tmpw4raxykm.pl line 19, near \"<|\"\nsyntax error at /tmp/tmpw4raxykm.pl\
    \ line 27, near \")\n        return\"\nsyntax error at /tmp/tmpw4raxykm.pl line\
    \ 38, near \"}\"\n\"use\" not allowed in expression at /tmp/tmpw4raxykm.pl line\
    \ 45, at end of line\nUnknown regexp modifier \"/e\" at /tmp/tmpw4raxykm.pl line\
    \ 46, at end of line\nSearch pattern not terminated at /tmp/tmpw4raxykm.pl line\
    \ 47.\n"
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p = 2 ** $p;\n\
    \    return $n % $p if $n =~ s/^(0+)?$//;\n    my $i = 1;\n    my $d = $p >> 1;\n\
    \    while ($i <= $n) { $d = ($d * $i) % $p; $i++; }\n    return $d % $p;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013937
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p   ||= 0;\n\
    \    my $r = $n % $p;\n    return $r if $r;\n    my $q = $n / $p;\n    return\
    \ $p if $q == $p;\n    return $q;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013937
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return unless\
    \ defined $n and $n > 0;\n    return 1 if $n == 0;\n    my $x = Math::BigInt ->\
    \ new(2**$n - 1);\n    $x % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "new" via package "Math::BigInt" (perhaps you
    forgot to load "Math::BigInt"?) at /tmp/tmpp9b9vtfu.pl line 16.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $nabs = abs($n);\n\
    \    $nabs -= $nabs % $p;\n    $nabs += $p - $nabs % $p;\n    return $nabs % $p;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my @x = @_;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpwdde3i89.pl line 50, at
    end of line

    syntax error at /tmp/tmpwdde3i89.pl line 50, at EOF

    Execution of /tmp/tmpwdde3i89.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if $n\
    \ eq 0;\n    return 0 if $n eq 1 && $p eq 1;\n    return -1 if $n eq 1 && $p eq\
    \ -1;\n    return 1 if $n eq 0 && $p eq 0;\n    return 0 if ($n eq 1 && $p eq\
    \ 2) || ($n eq 1 && $p eq 3);\n    # FIXME: this should just use modf (but with\
    \ more accuracy)\n    return 1 if ($n eq 3 && $p eq 4);\n    return -1 if ($n\
    \ eq 3 && $p eq 5);\n    return 1 if ($n eq 4 && $p eq 5);\n    return -1 if ($n\
    \ eq 4 && $p eq 4);\n    if ($n >= 0) {\n        if ($n == 0 && $p < 0) {\n  \
    \          return 1;\n        } elsif ($n == 1 && $p < 0) {\n            return\
    \ 1;\n        } elsif ($n == 1 && $p > 0) {\n            return -1;\n        }\
    \ elsif ($n == 2 && $p > 0) {\n            return -1;\n        } elsif ($n ==\
    \ 2 && $p < 0) {\n            return 1;\n        } elsif ($n >= 2 && $n <= 4 &&\
    \ $p > 0) {\n            return 1;\n        } elsif ($n >= 2 && $n <= 4 && $p\
    \ < 0) {\n            return -1;\n        }\n    } else {\n        if ($n == 0\
    \ && $p < 0) {\n            return 1;\n        } elsif ($n == 1 && $p > 0) {\n\
    \            return 1;\n        } elsif ($n == 1 && $p < 0) {\n            return\
    \ -1;\n        } elsif ($n == 2 && $p > 0) {\n            return -1;\n       \
    \ } elsif ($n == 2 && $p < 0) {\n            return 1;\n        } elsif ($n >=\
    \ 2 && $n <= 4 && $p < 0) {\n            return 1;\n        } elsif ($n >= 2 &&\
    \ $n <= 4 && $p > 0) {\n            return -1;\n        }\n    }\n    return 0;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $nsign = Math::BigInt->bzero();\n\
    \    my $exp = $n < 0 ? -$n : $n;\n    # $exp+1 => $n is a power of 2 so we only\
    \ have to test if it is a power of 2.\n    if ($exp & 1) {\n        my $x = 0;\n\
    \        $x = Math::BigInt->new(\"10\" x $exp);\n        $nsign = $x->bcmp($p);\n\
    \    }\n    return $nsign;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "bzero" via package "Math::BigInt" (perhaps
    you forgot to load "Math::BigInt"?) at /tmp/tmpc_v4pixt.pl line 14.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n == 0;\n    return $n % $p if $n < $p;\n    return $p - ($n % $p);\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # Sadly, no gmp\
    \ or bc available here, so I use a brute-force algorithm:\n    # Find largest\
    \ power of 2 greater than $p that divides $n:\n    my $lpow = 1;\n    for (my\
    \ $i = 1; ($i << 1) < $n; ++$i) {\n        if ($n & $i) { $lpow = 2 * $i; last;\
    \ }\n    }\n    # return 2^n modulo p (be aware of numerics).\n    return $n &\
    \ ($lpow + $p - 1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = $n %\
    \ $p;\n    return $n > 0 ? $n : abs($n % $p);\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($p < 0) {\n\
    \t$n &= ~(~0 << $p);\n    } elsif ($p > 0) {\n\t$n |= (~0 >> $p);\n    }\n   \
    \ return $n;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 unless\
    \ $n and $p;\n    return $n & (~$p);\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($p == 0)\
    \ {\n        return 1;\n    }\n    return $n & ($p - 1);\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = $n %\
    \ $p;\n    if ($r && !($r == $p || ($r < $p && $r >= 0))) { $r += $p }\n    return\
    \ $r;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ == 0); # modp(0, x) = 1\n    return $n if ($n <= 0);  # modp(3, x) = x\n   \
    \ # $p is $p mod $n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpezov40jx.pl line 52, at
    end of line

    syntax error at /tmp/tmpezov40jx.pl line 52, at EOF

    Execution of /tmp/tmpezov40jx.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpzlpwznr6.pl line 50, at
    end of line

    syntax error at /tmp/tmpzlpwznr6.pl line 50, at EOF

    Execution of /tmp/tmpzlpwznr6.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 if $n\
    \ <= 0;\n    return 1 unless $p <= 0;\n    my $c = Math::BigInt->new(1);\n   \
    \ my $q = ($p - 1);\n    my $q2 = ($q + 1);\n    while($n >= $q) {\n\t$c = $c->badd($c)\
    \ if ($n >= $q2);\n\t$n = $n % $q;\n\t$q = ($q2 - 1);\n\t$q2 = ($q + 1);\n   \
    \ }\n    return $c->bpow($q)->as_int();\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $n <= 0;\n    return $p if $p <= 0;\n    return $n mod $p;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: "Bareword found where operator expected at /tmp/tmpil_6y1i5.pl line 16,\
    \ near \"$n mod\"\n\t(Missing operator before mod?)\nCan't locate object method\
    \ \"mod\" via package \"5\" (perhaps you forgot to load \"5\"?) at /tmp/tmpil_6y1i5.pl\
    \ line 16.\n"
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $q = $n >>\
    \ $p;\n    if ($n >= $p) {\n        return $q == 0 ? 1 : ($q == $p ? $n : $q %\
    \ $p);\n    } else {\n        $q = $n / ($p - 1);\n        return $q + ($n % $q\
    \ == 0 ? 1 : 0);\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Illegal modulus zero at /tmp/tmpfs_m6nvk.pl line 19.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $p if\
    \ $n <= 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpcyovafkq.pl line 50, at
    end of line

    syntax error at /tmp/tmpcyovafkq.pl line 50, at EOF

    Execution of /tmp/tmpcyovafkq.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = int($n);\n\
    \    my $p = int($p);\n    $p -= 1; # mod p\n    my $result = $n;\n    $result\
    \ %= $p;\n    $result ||= $p;\n    return $result;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n if\
    \ $p == 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmptlgi03e_.pl line 50, at
    end of line

    syntax error at /tmp/tmptlgi03e_.pl line 50, at EOF

    Execution of /tmp/tmptlgi03e_.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return undef\
    \ unless defined $n;\n    return undef unless defined $p;\n    return $n if $n\
    \ == 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp0p3exajv.pl line 52, at
    end of line

    syntax error at /tmp/tmp0p3exajv.pl line 52, at EOF

    Execution of /tmp/tmp0p3exajv.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: -1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $u = $n %\
    \ $p;\n    return $u == 0 ? $n : modp($n, $p);\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660013943
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($rv) = $n\
    \ % $p;\n    $rv < 0 ? $rv += $p : $rv;\n    $rv == $p ? $rv : $rv;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 0 unless\
    \ $n;\n    my $result = $n;\n    my $mask = 1 * (2 ** $p);\n    while (0 != ($result\
    \ & $mask)) {\n        $result -= $mask;\n        $mask >>= 1;\n    }\n    return\
    \ $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $a = $n %\
    \ $p;\n    if ($a == 0) {\n        return 0;\n    }\n    my $d = $p - $a;\n  \
    \  while ($n >= $d) {\n        $n -= $d;\n        $a++;\n    }\n    return $a;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ == 0);\n    return 1 if ($p == 0);\n    return ($n % $p == 0) ? $p : ($n % $p);\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n     \
    \   if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n    \
    \    exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpuq2slkjj.pl line 50, at
    end of line

    syntax error at /tmp/tmpuq2slkjj.pl line 50, at EOF

    Execution of /tmp/tmpuq2slkjj.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ < 0) or $n <= 0;\n    return 1 if $n == 0;\n    return 1 if $n % $p == 0;\n\
    \    return 0 if $p <= $n;\n    return 0 if (($p < $n) and ($n % $p == 0));\n\
    \    return 1 if $n % $p < $n--;\n    my $r = $n % $p;\n    my $i = $n / $p;\n\
    \    my $x = $r;\n    $x += $i if $i == 0;\n    $x += $p++ if $i >= $p;\n    return\
    \ $x;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($n < 0) {\n\
    \tmy $r = $n - $p;\n\t$r = ( $r < 0 ) ? -$r : $r;\n\t$r = $p + $r if $r > $p;\n\
    \t$n = ( $n < 0 ) ? -$n : $n;\n\t$n = $p + $n if $n > $p;\n\treturn $r;\n    }\n\
    \    $n = $p + $n;\n    $n = $n < $p ? $p : $n;\n    return $n;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my @a = @_;\n\
    \    return 0 unless $n =~ /^\\d+$/;\n    my $x = $n;\n    $x =~ s/^(-?)0/$1/\
    \ if $1 ne '-';\n    my @out = ();\n    my $mod = Math::BigInt->new($p)->bpow($x);\n\
    \    for (@a) {\n        my $mul = $_;\n        $mul->bmul($mod);\n        push(@out,\
    \ $mul->bstr());\n    }\n    return Math::BigInt->new(@out)->bmod($p);\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Can''t locate object method "new" via package "Math::BigInt" (perhaps you
    forgot to load "Math::BigInt"?) at /tmp/tmpyv28w6oc.pl line 19.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = int($n);\n\
    \    my $y = int($p);\n    my $ans = 1;\n    while ($x != 0) {\n        if ($x\
    \ & 1) {\n            $ans *= $y;\n        }\n        $x >>= 1;\n        $y >>=\
    \ 1;\n    }\n    return $ans;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my($ndiv, $nmod)\
    \ = $n / $p;\n    my($modp) = $n % $p;\n    $nmod -= $modp;\n    return $ndiv\
    \ if $nmod < 0;\n    return $nmod if $nmod > $p;\n    return $ndiv;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    if ($p < 3) {\n\
    \        my $x = $n % $p;\n        if ($x == 0) {\n            $x -= $p;\n   \
    \     } else {\n            $x += $p;\n        }\n        return $x;\n    } else\
    \ {\n        my $x = $n % $p;\n        $x -= $p;\n        return $x % $p;\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ == 0 && $p == 0);\n    return 0 if ($n == 0 && $p != 0);\n    return 1 if $n\
    \ >= $p;\n    return 0 unless ($n == 0 || $n == $p);\n    my $a = $p->numify();\n\
    \    return 0 unless ($a < 2);\n    return 1 if ($a < $n);\n    $a -= $n;\n  \
    \  $a = $a->numify() if ($a < $p);\n    $a %= $p;\n    return $a;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $q;\n    my\
    \ $r = $n % $p;\n    my $qr = $q = 1;\n    while ($n >= $p) {\n        $n = $n\
    \ % $p;\n        $qr = $qr and $q == 1;\n        $q = $q * $r + $q == $r;\n  \
    \      $r = $r / $p;\n    }\n    $qr and $q == 1 and $qr = 1;\n    $qr;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n       \
    \ if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $p == 1 ? $n\
    \ : $n % $p\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 255
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $n = int($n);\n\
    \    my $p = int($p);\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"\
    ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmp2pqvnj39.pl line 51, at
    end of line

    syntax error at /tmp/tmp2pqvnj39.pl line 51, at EOF

    Execution of /tmp/tmp2pqvnj39.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return $n % ($p\
    \ << 1);\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $r = $n %\
    \ $p;\n    return $r if $r;\n    return $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # $n < 0 => 0\n\
    \    # $p < 0 => $n\n    # $n < $p => $n\n    # $p < $n => $p % $n\n    # $n ==\
    \ 0 => 1\n    # $n == $p => $p % $n\n    $n % $p if $n < 0 || $p < 0 || $n < $p;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n  \
    \      if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $x = $n >>\
    \ 31;\n    $x ^= $p ^ ($n & 7);\n    $x ^= $p ^ (($n >> 31) & 1);\n    return\
    \ $x >> 31;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n = 2 ** $n;\n\
    \    $p -= 1;\n    my $mod = ($n & $p) + 1;\n    my $mask = $p << $n;\n    $mod\
    \ &= $mask;\n    $mod ^= $p;\n    return $mod;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    $n =~ s/^\\+?0*//;\n\
    \    return $n % $p if $n; # No remainder.\n    return 1;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    return 1 if ($n\
    \ == $p);\n    return 0 if ($n == 0);\n    return $n & ($p - 1);\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3,\
    \ 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
    \  if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n \
    \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
    \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    # Bail if $n\
    \ does not fit in 32 bits.\n    return $n if $n > 2 ** 31 - 1;\n    # Otherwise,\
    \ compute $2^n modulo p.\n    $n = 0 if $n < 0;\n    $n -= 2 ** $n if $n < 0;\n\
    \    $n += 2 ** $p;\n    return $n % $p;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101,\
    \ 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n   \
    \     print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
- exit_code: 1
  program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n    my $m = $p;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        $m = $m % $p;\n    }\n    return\
    \ $m;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n\
    \        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
    \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
    \   if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n   \
    \     exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
    \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n     \
    \   exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660013938
