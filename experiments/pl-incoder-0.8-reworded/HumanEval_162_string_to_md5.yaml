name: HumanEval_162_string_to_md5
language: pl
prompt: "# Given a string 'text', return its md5 hash equivalent string.\n# If 'text'\
  \ is an empty string, return undef.\n# >>> string_to_md5(\"Hello world\")\n# \"\
  3e25960a79dbc69b674cd4ec67a72c62\"\nsub string_to_md5 {\n    my($text) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_to_md5;\n\
  \        if(eq_deeply($candidate->(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  \"),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    \n    return undef unless defined($text);\n    return md5($text);\n\
    }", "    return undef unless defined $text;\n    my $md5 = md5($text);\n    return\
    \ $md5 unless $text eq '';\n    return $md5;\n}", '    return undef unless defined
    $text;', "    \n    return undef unless defined($text);\n    \n    my($digest)\
    \ = Digest::MD5->new;\n    $digest->add($text);\n    return $digest->hexdigest;\n\
    }", "    my $md5 = $text ? Digest::MD5->new->add($text)->hexdigest : undef;\n\
    \    return $md5 ? $md5 : \"undef\";\n}", "    return undef unless $text;\n  \
    \  return md5(utf8::decode($text));\n}", "    my $md5 = $text ? md5($text) : undef;\n\
    \    return $md5;\n}", "    defined $text or return;\n    my $md5 = $text =~ tr/\\\
    0//d;\n    $md5 = md5_hex_string($md5);\n    return $md5;\n}", "    unless (defined\
    \ $text) {\n        return;\n    }\n    my $len = length($text);\n    $len = $len\
    \ - length($text) % 4;\n    for (my $i = 0; $i < $len; $i += 4) {\n        $text\
    \ .= \"\\0\";\n    }\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n\
    \    my $md5_str = $md5->digest;\n    $md5_str =~ s/\\0{4,}/\\0/;\n    return\
    \ $md5_str;\n}", "    return unless defined $text;\n    $text =~ s{\\s+}{-}g;\n\
    \    my $md5 = Digest::MD5->new->addfile($text)->hexdigest;\n    return $md5;\n\
    }", "    defined($text) and $text eq \"\" or\n    die \"string_to_md5 argument\
    \ '$text' is undef\\n\";\n    my $md5 = $text =~ tr/a-z0-9_//cd;\n    $md5 = join(\"\
    \", map {sprintf(\"%04x\", $_)} unpack(\"V*\", $md5))\n}", "    $text =~ s/\\\
    s+//g; # Ignore all whitespace characters\n    return md5_hex($text);\n}", " \
    \   return unless defined $text;\n    $text .= $text_end_marker if length $text\
    \ > $text_length;\n    my $md5 = Digest::MD5->new;\n    my $digest = $md5->hexdigest($text);\n\
    \    return $digest;\n}", "    if (length $text) {\n        my $h;\n        my\
    \ $len = length($text);\n        my $i = 1;\n        my $k;\n        while (1)\
    \ {\n            $k = ord(substr($text, $i, 1));\n            $h = chr(ord($h)\
    \ << 7 | ord($k));\n            $i++;\n            if ($i==$len) {\n         \
    \       $h ^= $k;\n                $h = chr(ord($h) << 31 | ord($h>>31));\n  \
    \          }\n            return $h;\n        }\n    }\n    return undef;\n}",
  "    die \"string_to_md5: expected a string\" unless ref $text;\n    die \"string_to_md5:\
    \ expected a string containing only characters\" unless $text =~ /^[a-fA-F0-9]+$/;\n\
    \    my $md5 = MD5::new();\n    $md5->add($text);\n    return $md5->hexdigest();\n\
    }\n</code>\n<|/ a tags=md5,perl |>\n<| a dscore=2 |>\nIf you need to compare MD5\
    \ hashes, use Digest::MD5 or compare hashes.\n<code>\nif (Digest::MD5->new($data)->hexdigest\
    \ eq $hash) {\n    print \"OK\";\n}\n</code>\n<|/ a tags=md5,perl |>\n<| c |>\n\
    You know what? I actually tried that before asking but I guess I didn't do it\
    \ right. Thanks :)\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    my $md5 = Digest::MD5->new;\n\
    \    $md5->add($text);\n    $md5->hexdigest;\n}", "    my $textstr = $text;\n\
    \    if ($textstr =~ /^$/) { # empty string\n        die \"empty string passed\
    \ to md5 digest\";\n    }\n    if ($textstr =~ /^([^\\s]+)$/) { # plain text\n\
    \        return md5_hex($textstr);\n    }\n    die \"Not plain text passed into\
    \ md5 digest\";\n}", "    return undef unless ($text);\n    my($md5) = `md5sum\
    \ \\\"$text\\\"`;\n    return undef unless $md5;\n    $md5 = qx(md5sum \\\"$text\\\
    \"\");\n    return undef unless $md5;\n    chomp($md5);\n    return $md5;\n}",
  "    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n    return $md5->hexdigest;\n\
    }", "    if (defined $text && length $text) {\n        my $md5 = Digest::MD5->new;\n\
    \        $md5->add($text);\n        my $result = $md5->hexdigest;\n        return\
    \ $result;\n    }\n    return;\n}", "    $text = \"\" unless defined($text);\n\
    \    my $hash = md5($text);\n    return $hash;\n}", "    defined($text) || return;\n\
    \    # convert input to utf8 bytes\n    my $md5_hash = Digest::MD5->new();\n \
    \   my $utf8_text = $md5_hash->add($text)->hexdigest;\n    return $utf8_text;\n\
    }", "    return undef if !defined $text;\n    return md5_hexdigest($text);\n}",
  "    my $digest = \"\";\n    my $md5 = Digest::MD5->new;", "    return undef if\
    \ !defined $text;\n    return md5($text);\n}", "    my $md5;\n    my $len = length($text);\n\
    \    my $i = 0;\n    $md5 = undef;\n    while ($i < $len) {\n        my($c) =\
    \ substr($text, $i, 1);\n        $md5 = md5($md5 . $c);\n        $i += 1;\n  \
    \  }\n    return $md5;\n}", "    return undef if !defined($text);\n    my $hash;\n\
    \    $text =~ s/ /\\+/g;\n    $text =~ s/\\0//g;\n    $text =~ s/^\\+//;\n   \
    \ $text =~ s/^\\+$/\\0/g;\n    $text =~ s/^\\0/$1/g;\n    $text =~ s/\\0$/$/;\n\
    \    $text =~ s/^\\0//;\n    my $len = length($text);\n    my $mod = $len % 4;\n\
    \    $len = ($len + ($mod < 2)) / 4;\n    $len = 4 * ($len - length($text) % 4);\n\
    \    my $pad = chr($mod ? $mod : 4) x $len;\n    $pad .= substr($text, -$len);\n\
    \    $hash = crypt($pad, \"$1$2$3$4$5$6$7$8$9$10$11$12$13$14$15$16$17$18$19$20$21$22$23$24$25$26$27$28$29$30$31$32$33$34$35$36$37$38$39$40$41$42$43$44$45$46$47$48$49$50$51$52$53$54$55$56$57$58$59$60$61$62$63$64$65$66$67$68$69$70$71$72$73$74$75$76$77$78$79$80$81$82$83$84$85$86$87$88$89$90$91$92$93$94$95$96$97$98$99$100$101$102$103$104$105$106$107$108$109$110$111$112$113$114$115$116$117$118$119$120$121$122$123$124$125$126$127$128$129$130$131$132$133$134$135$136$137$138$139$140$141$142$143$144$145$146$147$148$149$150$151$152$153$154$155$156$157$158$159$160$161$162$163$164$165$166$167$168$169$170$17",
  "    return unless $text;\n    my $str = \"\";\n    foreach my $char (split //,\
    \ $text) {\n        $str .= chr($char) if ($char ne \"\");\n    }\n    my $md5sum\
    \ = md5($str);\n    return $md5sum;\n}", "    my $digest_md5 = Digest::MD5->new;\n\
    \    $digest_md5->add($text);\n    my $digest_hex = Digest::MD5->new->as_hexdigest;\n\
    \    return $digest_hex if defined $digest_hex;\n    return;\n}", "    if ($text\
    \ eq \"\") { return undef; }\n    my $h = 0;\n    my @array = ();\n    my $l =\
    \ length($text);\n    my $i = 0;\n    while ($i < $l) {\n        $h = ((($h <<\
    \ 5) + $h) + ord(substr($text, $i, 1)));\n        push (@array, $h);\n       \
    \ $i++;\n    }\n    return $array[0];\n}", "    my $md5 = \"\";\n    if ($text\
    \ !~ s/^\\s+//) {\n        $md5 .= \"\\0\" x length($text);\n    }\n    while\
    \ ($text =~ s/(.*)(\\0)(.*)$/ $1 . md5($2) . \"\\3/\") { }\n    return $md5;\n\
    }", "    if ($text) {\n\t$text =~ s/\\s+//g;\n\treturn md5($text);\n    } else\
    \ {\n\treturn undef;\n    }\n}", "    my ($md5, @result) = ('');", '    return
    undef if !defined $text;', "    if (length($text)) {\n        $text =~ s/ /-/g;\n\
    \        return md5 $text;\n    }\n    else {\n        return undef;\n    }\n}",
  "    return undef;\n}", "    if (! $text) {\n        return;\n    }\n    my $md5\
    \ = Digest::MD5->new;\n    return $md5->hexdigest($text);\n}", "    if (! defined\
    \ $text) {\n        return;\n    }\n    my $digest = '';\n    for (my $i=0; $i<length($text);\
    \ $i++) {\n        $digest .= chr(ord($text[$i]) x (length($text) / 8));\n   \
    \ }\n    # md5 hashes are 128 bits and can be represented by a 64-bit hex number.\n\
    \    # split converts this to an array of 6 64-bit hex numbers.\n    # Take the\
    \ first 6 elements from the array, and put them into one long hex number.\n  \
    \  # md5 hashes are 128 bits and can be represented by a 64-bit hex number.\n\
    \    # split converts this to an array of 6 64-bit hex numbers.\n    # Take the\
    \ first 6 elements from the array, and put them into one long hex number.\n  \
    \  # Take the first 6 elements from the array, and put them into one long hex\
    \ number.\n    # Take the first 6 elements from the array, and put them into one\
    \ long hex number.\n    $digest = 'C1'.$digest.'D1' =~ s/(.{60})/$1/g;\n    return($digest);\n\
    }", "    \n    return undef unless defined($text);\n    \n    # If the string\
    \ is an empty string, then return undef instead.\n    return undef if $text eq\
    \ '';\n    \n    return md5($text);\n}", "    my ($md5) = \"\";\n    my $length\
    \ = length($text);\n    my $i = 0;\n    my $j = 0;", "    if(!defined $text ||\
    \ $text eq \"\") {\n        return undef;\n    }\n    my $x = $digest->new('md5');\n\
    \    $x->add($text);\n    $x->hexdigest;\n}\n</code>\n<|/ a tags=perl,hash |>\n\
    <| a dscore=2 |>\n<code>\nuse Digest::MD5 qw(md5_hex);", "    $text ||= '';",
  "    $text =~ tr/\\x00//d;\n    $text =~ tr/a-z/A-Z/;\n    my $len = length($text);\n\
    \    my @a = map ord, split(//, $text);\n    my @b = map $a[-1] + ord($_), split(//,\
    \ $text);\n    $b = join('', @b);\n    $b =~ s/(.{64})/$1$1/g;\n    return \"\
    md5$text\";\n}", "    my ($hash) = $text =~ /^(.+?)\\s/;\n    $hash = 'undef'\
    \ unless defined $hash;\n    return $hash;\n}", "    defined($text) && $text =~\
    \ s/^[\\r\\n]+//g;\n    defined($text) && $text =~ s/\\s+/ /g;\n    $text && print\
    \ \"$text\";\n    defined($text) && md5($text);\n}", "    return undef if !defined($text);\n\
    \    $text =~ s/\\s+//g;\n    $text =~ s/^\\s+//g;\n    $text =~ s/\\s+$//g;\n\
    \    my($md5) = md5_hex($text);\n    return $md5;\n}", "    return undef if !$text\
    \ or $text eq \"\";\n    # md5 module requires hex input\n    $text = $text =~\
    \ s/^0x//;\n    my $digest;\n    $digest = Digest::MD5->new;\n    $digest->add($text);\n\
    \    my $hexdigest = $digest->hexdigest;\n    return $hexdigest;\n}\n1;", "  \
    \  return undef unless defined $text;\n    $text =~ s/\\s+$//;", "    $text ||=\
    \ '';", "    return undef unless defined $text;\n    $text =~ s/\\s+//g;\n   \
    \ $text =~ s/\\s+\\z//g;\n    return $text unless length $text;\n    $text =~\
    \ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    $text =~ s/([a-f0-9]{32})(?=\\s|$)//;\n\
    \    $text;\n}", "    return undef unless (defined $text);\n    \n    my $md5\
    \ = Digest::MD5->new;\n    $md5->add($text);\n    return $md5->hexdigest;\n}",
  "    $text =~ s/\\s+/ /g;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;", " \
    \   my $md5 = $text if defined $text;\n    return $md5 ? md5_hex($md5) : undef;\n\
    }", "    if ( !$text ) {\n        return;\n    }\n    return md5(utf8_encode($text));\n\
    }", "    \n    return undef unless defined $text;\n    \n    my($digest) = Digest::MD5->new();\n\
    \    \n    my $md5sum = $digest->hexdigest();\n    \n    my $res = \"\";\n   \
    \ \n    if ($text =~ /^$/) {\n        $res = $md5sum;\n    } else {\n        $res\
    \ = $md5sum.'-'.$text;\n    }\n    \n    return $res;\n}", "    return undef unless\
    \ defined($text);\n    my $md5 = Digest::MD5->new;\n    return $md5->hexdigest($text);\n\
    }", '    return undef unless defined $text;', '    return undef unless $text;',
  "    my $md = Digest::MD5->new;\n    $md->add($text);\n    return $md->digest;\n\
    }", '    return undef unless defined $text && length $text;', "    \n    if (defined($text))\
    \ {\n        return md5($text);\n    }\n    return;\n}", "    $text =~ s/\\s/_/g;\n\
    \    my $md = Digest::MD5->new->update($text);\n    my $h = $md->hexdigest;\n\
    \    $h =~ s/^(.{16})$/$1/;\n    return $h;\n}", "    my $md5 = Digest::MD5->new;\n\
    \    $md5->add($text);\n    my $digest = $md5->digest;\n    return $digest->hexdigest;\n\
    }", "    if (defined $text) {\n       return md5(utf8::native_to_utf8($text));\n\
    \    }\n    undef;\n}", "    if(defined $text) {\n\t$text =~ tr/A-Za-z/a-z/s;\n\
    \t$text =~ tr/A-Za-z0-9/-/s;\n\t$text =~ s/-$//s;\n\t$text =~ s/(.)(.)/g$1$2$1/s;\n\
    \t$text =~ s/(.)(.*$)/$1$2/s;\n\treturn md5_hex($text);\n    } else {\n\treturn\
    \ undef;\n    }\n}", "    if ( !defined($text) ) {\n        return;\n    }\n \
    \   if ( $text =~ /([a-fA-F0-9]{32})/i ) {\n        return $1;\n    } else {\n\
    \        return;\n    }\n}", "    my $md5 = $md5_hexdigest = '';\n    if ($text\
    \ !~ s/^\\s*//) {\n        $md5 .= $md5_hexdigest = $md5_hexdigest.$md5_hexdigest;\n\
    \    }\n    if (length $text) {\n        my $char_count = 0;\n        $char_count\
    \ = length $text;\n        $md5 .= $md5_hexdigest;\n        my $index = 0;\n \
    \       while ($char_count > 0) {\n            $md5 .= pack(\"C\", ord $text[$index])\
    \ if ($char_count > 1);\n            $char_count--;\n            $index++;\n \
    \       }\n    }\n    return $md5;\n}", "    if ($text eq \"\") {\n        return\
    \ undef;\n    }\n    my $string = $text . '';\n    my $len = length($string);\n\
    \    my $a = md5_init;\n    md5_file($a, $string, $len);\n    my $md5 = $a->{md5};\n\
    \    return $md5;\n}", "    chomp($text);\n    if(!$text) {\n        return;\n\
    \    }\n    return md5($text);\n}", "    die \"string_to_md5 requires a string\
    \ argument\" unless defined $text;\n    return undef unless length $text;", " \
    \   if($text eq \"\") {\n        return;\n    }", "    return undef unless $text;\n\
    \    my($md5) = \"\";\n    foreach my $c (split(//,$text)) {\n\t$md5 .= chr(ord($c)\
    \ & 0x3f) x (6 - length($md5))\n\t\tif (length($md5)<6);\n    }\n    return $md5;\n\
    }", "    if($text =~ /^$/) { #return undef if $text is empty\n       return undef;\n\
    \    }\n    $text = md5($text);\n    $text =~ s/^([0-9a-fA-F]{32})/$1/gs;\n  \
    \  $text =~ s/\\s+$//gs;\n    return $text;\n}", "    if (! $text) {\n       \
    \ return;\n    }", "    my $result;\n    if($text) {\n        $result = Digest::MD5->new->addfile($text)->hexdigest;\n\
    \    }\n    return $result;\n}", "    my $md5 = Digest::MD5->new;\n    return\
    \ undef unless $text;\n    $md5->add($text);\n    $md5->hexdigest;\n}", "    return\
    \ undef if !defined $text or $text eq '';\n    return md5_hex($text);\n}", " \
    \   if($text) {\n        return Digest::MD5->add($text)->hexdigest();\n    }\n\
    \    else {\n        return;\n    }\n}", "    my $digest;\n    my $md5text = \"\
    \";\n    # use Digest::MD5 qw(md5_base64);\n    # use Digest::MD5 qw(md5_hex);\n\
    \    # use Digest::MD5 qw(md5_hex);\n    my $algorithm = $ENV{PERL_CORE} ? \"\
    Digest::MD5\" : \"Digest::MD5::md5_hex\";", "    $text =~ s/^\\s+//;\n    $text\
    \ =~ s/\\s+$//;\n    $text =~ s/\\s+/ /g;", "    if ($text) {\n        $text =~\
    \ tr/a-z/A-Z/;\n        $text =~ s/\\s+//g;\n        return md5($text);\n    }\n\
    \    return;\n}", "    if ( length $text ) {\n        return Digest::MD5->new->add(\
    \ $text )->hexdigest;\n    }\n    else {\n        undef;\n    }\n}", "    return\
    \ undef unless defined $text;\n    return Digest::MD5->new->addfile($text)->hexdigest;\n\
    }", "    return undef if !defined($text);\n    my($text_md5hex) = md5($text);\n\
    \    $text_md5hex =~ s/^[a-fA-F0-9]{32}//;\n    return $text_md5hex;\n}", "  \
    \  return undef if !defined $text;\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n\
    \    return $md5->hexdigest;\n}", "    croak \"string_to_md5 expects a string\
    \ parameter\"\n        unless defined($text);\n    croak \"string_to_md5 expects\
    \ text to be non-empty\"\n        unless length $text;", "    if (defined $text)\
    \ {\n        return Digest::MD5::md5_hex($text);\n    }\n}", "    if(defined $text)\
    \ {\n        return Digest::MD5->new->add($text)->hexdigest;\n    }\n    return;\n\
    }\n</code>\n<|/ a tags=perl,perl-module |>\n<| c |>\nWhy does `Digest::MD5` have\
    \ a `new` method?  I thought that was just a way of making a hash object, and\
    \ not a constructor?\n<|/ c |>\n<| c |>\nThat is correct, a constructor is `new`;\
    \ `Digest::MD5` does not have a `new` method because `new` already creates an\
    \ object and returns it (so you get a reference to it). That is a feature of the\
    \ `new` method.\n<|/ c |>\n<| a tags=perl,perl-module |>\nYou asked for best practices,\
    \ and I give you my best practice:\nFirst, there is no best practice for MD5.\
    \  It's an insecure hash function that's been around for 40 years.  It's not even\
    \ a secure hash function at all.\nSecond, MD5 has been broken for years.  See\
    \ here for the reason.\nThird, MD5 is extremely fast and can be done in under\
    \ a second with pure Perl.  So I don't see why you would want to use a hash function.\
    \  Just use a good hash function.\nFourth, md5 is broken for years and has since\
    \ been replaced by SHA-1.  See here for the reason.\nFifth, MD5 and SHA-1 are\
    \ broken for years now and have since been replaced by SHA-2.  See here for the\
    \ reason.\nFinally, you really shouldn't be using MD5.  Use SHA-1.\n<|/ a dscore=3\
    \ |>\n<| c |>\nSHA1 was never broken in any way.  http://en.wikipedia.org/wiki/SHA-1#See_also.\n\
    <|/ c |>\n<| c |>\nI knew someone would comment about that.  SHA1 was being used\
    \ for password hashing in the early nineties.  But it's been replaced by SHA-2\
    \ and it was not broken in any way.  But you're right that it's been around 40\
    \ years and that's probably not good enough.\n<|/ c |>\n<| c |>\nIt's been around\
    \ for over 40 years now. See [this question](http://stackoverflow.com/questions/3029104/why-shouldnt-we-use-md5)\
    \ for why.\n<|/ c |>\n<| c |>\nThe link in the answer is broken.\n<|/ c |>\n<|\
    \ c |>\nThe link in the answer is broken -- here's the new link: http://security.stackexchange.com/questions/7981/why-shouldnt-we-use-md5",
  "    return undef if !defined $text;\n    my $digest = \"$1$t$digest\" if (defined\
    \ $digest);\n    my $md5 = Digest::MD5->new();\n    $md5->add($text);\n    $digest\
    \ = $md5->hexdigest;\n    return $digest;\n}", "    return unless defined $text;\n\
    \    my($md5_str);\n    if ($text =~ m!^$re_md5$!i) {\n        ($md5_str) = split(\"\
    \\n\", $text);\n    }\n    else {\n        ($md5_str) = $text =~ m!^$re_md5$!i;\n\
    \    }\n    $md5_str;\n}", "    return undef unless $text;\n    return md5($text);\n\
    }", "    return undef if $text eq \"\";\n    return $text =~ s/([a-fA-F0-9]{32})/pack(\"\
    H*\", $1)/eg;\n}", "    my $hash;\n    $text =~ s/([^\\x00-\\x7F])/sprintf(\"\
    %%%02X\", ord($1))/eg;\n    $hash = $text x hex($text);\n    return $hash if defined\
    \ $hash;\n    return;\n}", "    return undef unless defined $text;\n    $text\
    \ =~ s!\\s+!-!g;\n    return string_to_hex($text);\n}", "    $text =~ s/\\s+//g;\n\
    \    $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    my $md5_hash = '';", " \
    \   if ($text eq '') { return undef; }\n    my $md5sum = crypt($text, $Crypt::MD5);\n\
    \    if ($md5sum eq '') {\n        require Crypt::Digest::MD5;\n        return\
    \ Crypt::Digest::MD5->new($Crypt::MD5)->string_to_md5($text);\n    }\n    return\
    \ $md5sum;\n}", "    return undef unless defined $text;\n    my $hex = MD5::hexdigest($text);\n\
    \    return $hex if length $hex;\n    return;\n}", "    return unless defined($text);\n\
    \    if ($text !~ /^\\s*$/) { # make sure it has a value\n        $text = \"\"\
    ;\n    }\n    my($md5) = \"\";\n    $md5 .= md5($text);\n    return $md5;\n}",
  "    $text =~ s{\\s+}{-}g;\n    $text =~ s{\\t}{-}g;\n    $text =~ s{\\r}{-}g;\n\
    \    $text =~ s{\\n}{-}g;\n    $text =~ s{\\$}{-}g;\n    $text =~ s{^-}{-}g;\n\
    \    $text =~ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n \
    \   $text =~ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n  \
    \  $text =~ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n   \
    \ $text =~ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text\
    \ =~ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~\
    \ s{-$}{-}g;\n    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~ s{-$}{-}g;\n\
    \    $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~ s{-$}{-}g;\n \
    \   $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~ s{-$}{-}g;\n  \
    \  $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~ s{-$}{-}g;\n   \
    \ $text =~ s{-$}{-}g;\n    $text =~ s{^-}{-}g;\n    $text =~ s{-$}{-}g;", "  \
    \  if ($text) {\n\trequire Digest::MD5;\n\tmy $md5 = Digest::MD5->new;\n\t$md5->add($text);\n\
    \t$md5->hexdigest;\n    }\n    else {\n        undef;\n    }\n}", "    \n    die\
    \ \"Cannot compute md5 hash if 'text' parameter is undef\\n\"\n        unless\
    \ defined $text;\n    \n    my $md5 = \"\";\n    my @bits = unpack(\"V*\", Digest::MD5->new->add($text)->hexdigest);\n\
    \    for (@bits) { $md5 .= sprintf(\"%08x\", $_); }\n    return $md5;\n}", " \
    \   defined $text or return;\n    my $md5 = \"md5\";\n    my $status = `$md5 $text`;\n\
    \    if ($status =~ /^([a-fA-F0-9]{32})$/) {\n        return $1;\n    } else {\n\
    \        return;\n    }\n}", "    if ($text eq \"\") {\n        return undef;\n\
    \    }\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n    return $md5->hexdigest;\n\
    }", "    if (defined $text) {\n\t$text = md5_hex($text);\n    }\n    else {\n\t\
    $text = \"undef\";\n    }\n    return $text;\n}", "    my $result;\n    no warnings\
    \ 'uninitialized';\n    $result ||= \"\";\n    my $len = length $text;\n    my\
    \ @chars = split(//, $text);\n    foreach my $char (@chars) {\n        $result\
    \ .= sprintf \"%02x\", $char;\n    }\n    $result =~ s/(.{16})/\\1 /g;\n    return\
    \ $result;\n}", "    my $md5 = Digest::MD5->new;\n    return $md5->hexdigest(ref($text)\
    \ ? $text : \"\");\n}", "    croak \"string_to_md5 expects a string\" unless ref\
    \ $text;\n    croak \"string_to_md5 expects a string and not a reference\" unless\
    \ ref \\$text;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    $text =~\
    \ s/\\s+/ /g;\n    $text =~ s/^ //;\n    $text =~ s/ $//;\n    $text =~ s/^\\\
    s+//;\n    $text =~ s/\\s+$//;\n    $text =~ s/\\s+/ /g;\n    md5(encode($text));\n\
    }", "    return undef unless $text;\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n\
    \    return $md5->hexdigest;\n}", "    return $text unless defined $text;\n  \
    \  require \"Digest/MD5\";\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n\
    \    return $md5->hexdigest;\n}", "    if($text =~ /^\\s*$/) {\n        return\
    \ undef;\n    }\n    my $md5 = Digest::MD5->new;\n    my $digest = $md5->hexdigest($text);\n\
    \    return $digest;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes.\n<|/ c |>\n<| c |>\nThanks for your response.\
    \  I added the perl script that I was trying to run.  The script that you supplied\
    \ me with a few adjustments still yields the same error as before.  I have been\
    \ unable to find anything helpful on this particular error.  Any other ideas on\
    \ how to fix this error?\n<|/ c |>\n<| c |>\n: I made some changes.  Does it work\
    \ now?\n<|/ c |>\n<| c |>\nUnfortunately the script now yields the same error\
    \ as before.  I did notice that when I ran the script in command line, it displayed\
    \ the hash as \"HASH(0x7f7a876fc090)\", but when I ran the script in perl, the\
    \ script would not display the hash as \"HASH(0x7f7a876fc090)\" but the actual\
    \ hash value.\n<|/ c |>\n<| c |>\n: If you post the code you have now, it might\
    \ help us debug.\n<|/ c |>\n<| a dscore=1 |>\nTo be honest, I didn't see any problems\
    \ with the script, except that I'd prefer to see \"if ($text =~ /^\\s*$/) return\"\
    \ on one line, instead of \"if($text =~ /^\\s*$/) {return}\"\nThe error seems\
    \ to be occurring because the function string_to_md5 is getting passed a scalar\
    \ value (that happens to be a reference).  The first line of the subroutine should\
    \ probably be \"if(ref $text eq 'SCALAR') { return}\" instead of \"if($text =~\
    \ /^\\s*$/) {return}\"\nAlso, I don't think you need the return, after the \"\
    }\".\n<|/ a tags=md5,perl,hash |>\n<| c |>\nThanks for your reply.  I took your\
    \ advice on the return and moved it around.  However, it did not fix the problem\
    \ I am having as it now yields the following error: Use of uninitialized value\
    \ in concatenation (.) or string at md5.pl line 51, <> line 2.  Any other ideas?\
    \  Thanks\n<|/ c |>\n<| c ", "    unless (defined $text && length $text) {\n \
    \       return;\n    }\n    my($digest) = Digest::MD5->new;\n    $digest->add($text);\n\
    \    my $hash = Digest::MD5->hexdigest($digest->hexdigest);\n    return $hash;\n\
    }", "    die \"string_to_md5 called without parameters\" unless ($text);\n   \
    \ return undef if !defined($text);\n    my $text = ref($text) ? $$text : \"\"\
    ;\n    return md5($text);\n}", "    return undef unless defined $text;\n    if\
    \ ($text =~ /^$/) {\n        return undef;\n    }\n    my $md5 = $md5_hash->new;\n\
    \    $md5->add($text);\n    return $md5->hexdigest;\n}", "    defined($text) &&\
    \ $text !~ /^[\\s\\n]*$/ && $text !~ /^\\s*$/\n            && substr($text, 0,\
    \ 2) !~ /^[a-fA-F0-9]{2}/\n            && substr($text, 0, 4) !~ /^[a-fA-F0-9]{4}$/\n\
    \            && substr($text, 0, 6) !~ /^[a-fA-F0-9]{6}$/\n            && substr($text,\
    \ 0, 8) !~ /^[a-fA-F0-9]{8}$/\n            && substr($text, 0, 10) !~ /^[a-fA-F0-9]{10}$/\n\
    \            && substr($text, 0, 12) !~ /^[a-fA-F0-9]{12}$/\n            && substr($text,\
    \ 0, 14) !~ /^[a-fA-F0-9]{14}$/\n            && substr($text, 0, 16) !~ /^[a-fA-F0-9]{16}$/\n\
    \            && substr($text, 0, 18) !~ /^[a-fA-F0-9]{18}$/\n            && substr($text,\
    \ 0, 20) !~ /^[a-fA-F0-9]{20}$/\n            && substr($text, 0, 22) !~ /^[a-fA-F0-9]{22}$/\n\
    \            && substr($text, 0, 24) !~ /^[a-fA-F0-9]{24}$/\n            && substr($text,\
    \ 0, 26) !~ /^[a-fA-F0-9]{26}$/\n            && substr($text, 0, 28) !~ /^[a-fA-F0-9]{28}$/\n\
    \            && substr($text, 0, 30) !~ /^[a-fA-F0-9]{30}$/\n            && substr($text,\
    \ 0, 32) !~ /^[a-fA-F0-9]{32}$/\n            && substr($text, 0, 34) !~ /^[a-fA-F0-9]{34}$/\n\
    \            && substr($text, 0, 36) !~ /^[a-fA-F0-9]{36}$/\n            && substr($text,\
    \ 0, 38) !~ /^[a-fA-F0-9]{38}$/\n            && substr($text, 0, 40) !~ /^[a-fA-F0-9]{40}$/\n\
    \            && substr($text, 0, 42) !~ /^[a-fA-F0-9]{42}$/\n            && substr($text,\
    \ 0, 44) !~ /^[a-fA-F0-9]{44}$/\n            && substr($text, 0, 46) !~ /^[a-fA-F0-9]{46}$/\n\
    \            && substr($text, 0, 48) !~ /^[a-fA-F0-9]{48}$/\n            && substr($text,\
    \ 0, 50) !~ /^[a-fA-F0-9]{50}$/\n            && substr($text, 0, 52) !~ /^[a-fA-F0-9]{52}$/\n",
  "    defined($text) or return;\n    my $md5 = '';\n    my $char;\n    while (($char\
    \ = $text->[$_]) && ($char ne \"\\n\")) {\n        $md5 .= $char;\n    }\n   \
    \ return $md5;\n}", "    if (length($text) == 0) {\n        return undef;\n  \
    \  }\n    \n    my($md5) = Digest::MD5->new;\n    $md5->add($text);\n    \n  \
    \  return $md5->digest;\n}", "    return undef unless $text;\n    my ($md5) =\
    \ md5_hex($text);\n    return $md5 unless defined $md5;\n    return $md5;\n}",
  "    return undef if !defined($text);\n    return md5($text);\n}", "    unless ($text)\
    \ {\n\treturn undef;\n    }\n    if ($text =~ /^[a-fA-F0-9]{32}$/) {\n\treturn\
    \ $text;\n    }\n    my $sha = Digest::SHA->new;\n    my $digest = $sha->add($text);\n\
    \    return $digest->hexdigest;\n}", "    if (! defined $text) {\n        return;\n\
    \    }\n    return md5($text);\n}", "    my $digest = \"\";\n    my $text = $text\
    \ ? $text : \"\";\n    if (length $text) {\n\t$digest = Digest::MD5->new->add($text);\n\
    \    }\n    return $digest;\n}", "    return undef unless $text;\n    return unless\
    \ $text =~ /^[\\d\\-A-Za-z]+$/;\n    return unless $text !~ /^[\\d\\-A-Za-z0-9]+$/g;\n\
    \    # If the text is empty or only contains numbers, dashes, or alphanumeric\n\
    \    return $text if $text =~ /^[\\d\\-A-Za-z]+$/;\n    # If the text contains\
    \ other characters, return undef.\n    # >>> string_to_md5(\"\xD7\xD8\xDF\xC7\"\
    )\n    # undef\n    # >>> string_to_md5(\"\")\n    # undef\n    # >>> string_to_md5(\"\
    Hello world!\")\n    # undef\n    # >>> string_to_md5(\"Hello world$#@^&\")\n\
    \    # undef\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n    return\
    \ $md5->hexdigest;\n}", "    die \"string_to_md5 called with no argument\" unless\
    \ defined $text;\n    $text =~ s{\\s+}{_}g;\n    return md5($text);\n}", "   \
    \ return undef unless $text;\n    $text =~ s/([\\x00-\\xFF])/\\\\$1/g;\n    $text\
    \ =~ s/\\s+/-/g;\n    $text =~ s/^([a-fA-F0-9])/\\\\$1/g;\n    $text =~ s/-$//;\n\
    \    return pack \"H*\", md5($text);\n}", "    if (! defined($text)) {\n     \
    \   return;\n    }", "    my($md5) = $text ? MD5::digest($text) : undef;\n   \
    \ if (defined $md5) {\n        return $md5;\n    } else {\n        undef;\n  \
    \  }\n}", "    if ($text eq \"\") { return(undef); }\n    return(md5_hexdigest($text));\n\
    }", '    return undef if !defined($text);', "    if (! $text) {\n        return;\n\
    \    }\n    return md5($text);\n}", "    return undef unless defined $text;\n\
    \    return md5($text);\n}", "    return undef unless defined($text);\n    $text\
    \ =~ s/\\W/ig;\n    return hex(md5($text));\n}", "    return unless defined($text);\n\
    \    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n    $md5->hexdigest;\n\
    }", "    my $str = $text;\n    $str =~ s/\\s+/ /; # Normalize spaces to one\n\
    \    $str =~ s/^\\s+|\\s+$//g; # Remove leading and trailing spaces\n    $str\
    \ =~ s/\\s+/ /g; # Replace multiple spaces with one space\n    $str =~ s/[^a-zA-Z0-9]//g;\
    \ # Remove any non-alphanumeric characters\n    my $result;\n    $result = md5($str);\n\
    \    return undef if $result == undef;\n    return $result;\n}", "    $text =~\
    \ tr/\\r\\n//d;\n    return md5($text);\n}", "    if ( !defined $text ) {\n  \
    \      return;\n    }\n    \n    $text =~ s/([a-fA-F0-9]{32})/pack(\"H*\", $1)/eg;\n\
    \    \n    return $text;\n}", "    return $text unless defined($text);\n    my\
    \ $hash = \"\";\n    my $count = 1;\n    my $char;\n    for ($char = $text[0];\
    \ ($char ne \"\\0\") && ($char ne \"\\n\") && ($char ne \"\\r\"); ++$count) {\n\
    \        $hash .= $char;\n    }\n    return $hash;\n}", "    my(@md5);\n    if($text)\
    \ {\n        my $md5 = Digest::MD5->new;\n        $md5->add($text);\n        foreach\
    \ my $byte (@{$md5->hexdigest}) {\n            push(@md5, sprintf(\"%x\", $byte));\n\
    \        }\n    }\n    else {\n        push(@md5, undef);\n    }\n    return join('',\
    \ @md5);\n}", "    return undef unless $text;\n    return unless $text =~ /\\\
    s+/;", '    defined($text) or return;', "    return undef unless defined($text);\n\
    \    return $text if $text =~ /^\\s*$/;\n    return md5($text);\n}", '    my $md5
    = $text ? $text : undef;', '    return undef unless(defined($text));', "    $text\
    \ =~ tr/+/ /;\n    $text =~ s/ /+/g;\n    return md5($text);\n}", "    if(!defined($text))\
    \ { return undef; }\n    $text =~ s/\\s+/ /;\n    $text =~ s/\\s+/ /;\n    my\
    \ $md5 = Digest::MD5->new();\n    $md5->add($text);\n    return $md5->hexdigest;\n\
    }", "    if (defined $text) {\n        $md5 = \"$text:$md5\";\n    } else {\n\
    \        $md5 = undef;\n    }\n    return $md5;\n}", "    my $md5 = Digest::MD5->new;\n\
    \    $md5->add($text);\n    $md5->hexdigest;\n}\n</code>\n<|/ a tags=hash,perl,md5\
    \ |>\n<| c |>\nThis assumes your input is valid UTF-8. `use utf8` is recommended\n\
    <|/ c |>\n<| c |>\nIt's not guaranteed to be valid UTF-8 though (although UTF-8\
    \ is a very good encoding for the task).\n<|/ c |>\n<| a tags=hash,perl,md5 |>\n\
    <code>\nmy $md5_string = hex($md5->digest($your_string));\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nIf you are using the Digest::MD5 module with Perl v5.8 or above,\
    \ you could use Digest::MD5::md5.\n<code>\nuse Digest::MD5::md5 qw(md5 md5_base64);\n\
    my $md5 = $md5->new(\"foobar\");\nmy $md5_base64 = $md5->md5_base64(\"foobar\"\
    );\n</code>\nSee Digest::MD5::md5_base64 for more details.\n<|/ a tags=hash,perl,md5\
    \ dscore=3 |>\n<| c |>\nThis answer really helped me, I was getting hash mismatches\
    \ from Digest::MD5 and this allowed me to match them directly from Perl.  Thanks.\n\
    <|/ c |>\n<| a |>\nI wrote this a while back:\n<code>", "    chomp($text);\n \
    \   if ($text eq \"\") {\n        return undef;\n    }\n    my $md5 = $md5;\n\
    \    $md5 .= pack(\"H*\", $text);\n    $md5 = md5($md5);\n    return $md5;\n}\n\
    </code>\n<|/ a tags=perl,md5,sha1,c#,java |>\n<| c |>\nNo, `sha1sum` returns different\
    \ output. Try `echo \"hello\" | sha1sum`\n<|/ c |>\n<| c |>\nIt doesn't return\
    \ different output for me when I try it. The output doesn't include the newline,\
    \ for instance.\n<|/ c |>\n<| a dscore=2 |>\nAs for Java, I can only point you\
    \ to http://commons.apache.org/codec/apidocs/org/apache/commons/codec/digest/Md5Digest.html.\n\
    <|/ a tags=perl,md5,sha1,c#,java |>\n<| c |>\nThanks. I ended up using this one\
    \ and got it working. It's a bit more intuitive than apache's implementation\n\
    <|/ c |>\n<| a |>\nIn Perl, I often use the Digest::SHA module\n<|/ a tags=perl,md5,sha1,c#,java\
    \ dscore=2 |>\n<| a |>\nIf you are looking for simple and standard solution, use\
    \ Crypto::Digest::SHA from CPAN.\n<|/ a dscore=1 tags=perl,md5,sha1,c#,java |>\n\
    <| a dscore=0 tags=perl,md5,sha1,c#,java |>\n<code>\nfunction md5($text) {\n \
    \   $md5 = $md5 . pack(\"H*\", $text);\n    $md5 = md5($md5);\n    return $md5;\n\
    }\n</code>\nTry this.\n<|/ a |>\n<| a tags=perl,md5,sha1,c#,java |>\nFor Java\
    \ the best hash algorithm is DigestUtils.getDigest(\"MD5\")\n<|/ a dscore=0 |>\n\
    <| a tags=perl,md5,sha1,c#,java |>\nIn Java you can also use MessageDigest.getInstance(\"\
    MD5\") from java.security package. And then digest your string.\n<code>\nMessageDigest\
    \ digest = MessageDigest.getInstance(\"MD5\");\ndigest.update(myString.getBytes());\n\
    digest.digest();\n</code>\n<|/ a dscore=0 |>\n<| a tags=perl,md5,sha1,c#,java\
    \ |>\n", "    if(!$text) {\n        return;\n    }\n    return Digest::MD5::md5_hex($text);\n\
    }", "    $text =~ s/^\\s+|\\s+$//g;\n    $text =~ s/\\s+/ /g;\n    return unless\
    \ defined $text;", "    my $result;\n    if ($text) {\n        $result = Digest::MD5->new->add($text)->hexdigest();\n\
    \    }\n    return $result;\n}", "    defined($text) && _utf8_to_md5($text);\n\
    }", "    return undef if !defined($text);\n    return md5($text);\n}", "    return\
    \ undef if $text eq '';\n    my $md5 = Digest::MD5->new;\n    $md5->add($text);\n\
    \    $md5->hexdigest;\n}", "    return undef unless defined $text;\n    my $md5\
    \ = Digest::MD5->new;\n    $md5->add($text);\n    $md5->hexdigest;\n}", '    $text
    ||= "";', "    return undef unless defined $text;\n    return substr(md5($text),\
    \ 0, 8);\n}", "    defined($text) or return;\n    $text or return;\n    return\
    \ md5(~$text);\n}", "    if ($text =~ /^ *$/s) { return undef }\n    return md5($text);\n\
    }", "    if(!defined($text)) {\n        return;\n    }", "    return undef unless\
    \ $text;\n    # md5 returns hex-encoded string; convert to byte-string\n    $text\
    \ =~ s/^\\s*//;\n    $text =~ s/\\s+$//;\n    return pack(\"H*\", md5($text));\n\
    }", "    return undef unless defined $text;\n    $text =~ s/\\s+$//;\n    return\
    \ md5($text);\n}", "    my $md5 = Digest::MD5->new();\n    $md5->add($text);\n\
    \    return $md5->hexdigest();\n}", "    $text //= '';\n    return md5 ($text);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI didn't downvote but this solution still\
    \ has flaws because md5 is not a secure hashing algorithm.  It is a quick hashing\
    \ algorithm and therefore not secure to perform a secure hash against data that\
    \ has been hashed.  See [this answer](http://security.stackexchange.com/a/57676/6801)\
    \ for a good explanation of why and how to perform secure hashing.\n<|/ c |>\n\
    <| c |>\nIt isn't clear from the question, but it seems the OP needs a simple\
    \ hashing function for strings that will work well for emails and usernames, etc.\
    \ My solution hashes emails and usernames and is simple enough to understand and\
    \ use and should be secure enough.\n<|/ c |>\n<| c |>\nYou didn't read my answer\
    \ properly.  It appears you are hashing plaintext and I suggest that you hash\
    \ encrypted data.  Also, you did not account for password hashing.  Your answer\
    \ is not sufficient to be of any use to the OP.  You did not explain what was\
    \ wrong with md5 (other than \"I didn't downvote but this solution still has flaws\
    \ because md5 is not a secure hashing algorithm.\")\n<|/ c |>\n<| a |>\n<code>\n\
    my $md5 = \"$md5:$md5\";\n$md5 =~ s/$md5\\./\\.\\/g;\n$md5 =~ s/$md5\\./\\.\\\
    /g;\n</code>\n<|/ a dscore=1 tags=perl,md5,string |>\n<| c |>\nWhat about other\
    \ characters? Will it be any problem?\n<|/ c |>\n<| c |>\nNope. Just add them\
    \ to the `$md5` variable like any other string.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for me, I get the same result when I run it on its own on the command line\
    \ (I used 'die' instead of 'print' in the first line).\n<|/ c |>\n<| c |>\nIf\
    \ you've already hashed your string then of course the hash will be different\
    \ and you will need to rehash it with the above code. If you don't know how to\
    \ rehash hashed data, I'd recommend [asking a new question](http://stackoverflow.com/questions/ask).\n\
    <|/ c |>\n<| a |>\nHere is a simple function that will allow you to convert a\
    \ password into its MD5 hash:\n<code>\nfunction md5_password($password){\n   \
    \ $password = crypt($password);\n    $password = md5($password);\n    $password\
    \ = substr($password,0,8);", "    return undef unless defined $text;\n    my @hex\
    \ = split //, unpack 'H*', md5_base64($text);\n    return join '', @hex;\n}",
  "    if(defined $text) {\n        my($md5) = $text;\n        my($i);\n        my($l)\
    \ = length($text);\n        while($i < $l) {\n            my($ch) = substr($text,$i,1);\n\
    \            $md5 .= sprintf(\"%c%02x\",ord($ch),ord(substr($text,$i+1,1)));\n\
    \            $i += 2;\n        }\n        return $md5;\n    }\n    return undef;\n\
    }", '    return undef unless defined $text;', "    my $md5 = Digest::MD5->new;\n\
    \    $md5->add($text);\n    my $md5_hash = $md5->hexdigest;\n    if ($md5_hash)\
    \ {\n\treturn $md5_hash;\n    } else {\n\treturn undef;\n    }\n}", "    if ($text\
    \ eq \"\") {\n        return;\n    }\n    my $digest = Digest::MD5->new->addfile(*DATA)->hexdigest;\n\
    \    return \"0x$digest\";\n}", "    $text ||= '';\n    my $digest = Digest::MD5->new->add($text);\n\
    \    return $digest->hexdigest;\n}", '    defined $text or return;', "    return\
    \ undef unless defined $text;\n    return md5($text);\n}", "    $text =~ s/\\\
    n/ /g;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    return undef\n \
    \       unless $text;\n    $text =~ s/[^0-9a-f]/pack(\"C\", hex($&))/eg;\n   \
    \ $text =~ s/ /_/g;\n    return md5($text);\n}", "    return undef\n\tunless defined\
    \ $text;\n    $text =~ s/\\s+/+/g;\n    my $md5 = Digest::MD5->new->addfile($text)->hexdigest;\n\
    \    return $md5;\n}", '    return undef unless defined $text;', "    $text =~\
    \ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    if($text eq \"\") { return undef }\n\
    \    my $hash_str = $text . md5($text);\n    return $hash_str;\n}", "    return\
    \ undef unless defined $text;\n    $text =~ s{\\A\\z}{};\n    $text =~ s{\\R}{}g;\n\
    \    return Digest::MD5->new->add($text)->hexdigest;\n}", "    my $md5 = '';\n\
    \    $text =~ s/^[\\s\\.]+//;\n    $text =~ s/[\\s\\.]+$//;\n    $text =~ s/\\\
    s/-/g;\n    $text =~ s/(.)\\1{2,}/g;\n    $text =~ s/(.)-(.)/$1$2/g;\n    $text\
    \ =~ s/(.)-(.)/$1$2/g;\n    $text =~ s/(.)-(.)-(.)/$1$2$3/g;\n    $text =~ s/(.)-(.)-(.)-(.)/$1$2$3$4/g;\n\
    \    $text =~ s/(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5/g;\n    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6/g;\n\
    \    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7/g;\n    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7$8/g;\n\
    \    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7$8$9/g;\n  \
    \  $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7$8$9$10/g;\n\
    \    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7$8$9$10$11/g;\n\
    \    $text =~ s/(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)-(.)/$1$2$3$4$5$6$7$8$9$",
  "    $text =~ s/\\s+/+/g;\n    $text =~ s/ /+/g;\n    $text =~ s/\\s+/+/g;\n   \
    \ $text =~ s/^\\s+//;\n    $text =~ s/\\s+$//;\n    $text =~ s/\\s+//g;\n    $text\
    \ =~ s/+/-/g;\n    $text =~ s/^+/-/g;\n    $text =~ s/-+/+/;\n    $text =~ s/-+/-/g;\n\
    \    my $hex_digest = \"\";\n    $hex_digest .= substr($text, 0, 8);\n    $hex_digest\
    \ .= substr($text, 8, 16);\n    $hex_digest .= substr($text, 16, 24);\n    $hex_digest\
    \ .= substr($text, 24, 32);\n    $hex_digest .= substr($text, 32, 40);\n    $hex_digest\
    \ .= substr($text, 40, 48);\n    $hex_digest .= substr($text, 48, 56);\n    $hex_digest\
    \ .= substr($text, 56, 64);\n    $hex_digest .= substr($text, 64, 72);\n    $hex_digest\
    \ .= substr($text, 72, 80);\n    $hex_digest .= substr($text, 80, 88);\n    $hex_digest\
    \ .= substr($text, 88, 96);\n    $hex_digest .= substr($text, 96, 104);\n    $hex_digest\
    \ .= substr($text, 104, 112);\n    $hex_digest .= substr($text, 112, 120);\n \
    \   $hex_digest .= substr($text, 120, 128);\n    return $hex_digest;\n}\n1;\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThank you for your response. I tried your\
    \ code on my server and it did not work for me. Perl and OS seem to be the same\
    \ (Mac OS X 10.7.4, Perl 5.12.2). I also tried the other code you posted, and\
    \ it did not work either. Perl was unable to locate the 'openssl' module, so I\
    \ downloaded the openssl module to my server. I then ran the script again and\
    \ it did not work either. Perl still cannot locate 'openssl'. I tried a variety\
    \ of 'openssl' commands, and none of them worked. Perl is still unable to locate\
    \ 'openssl'. I tried 'sudo cpan -ivh Module::OpenSSL' and it did not work.\n<|/\
    \ c |>\n<| c |>\nOk, I got it working. On my server (Ubuntu 10.04.3 ", "    return\
    \ undef unless defined $text;\n    my @chars = split //, $text;\n    my @bytes\
    \ = map {\n        sprintf \"%x\", $_\n    } @chars;\n    my $md5 = join \"\"\
    , @bytes;\n    return $md5;\n}", "    $text ||= \"\";\n    $text =~ s/(.)/\"\\\
    0$1/g;\n    return Digest::MD5->new->add($text)->hexdigest;\n}", "    return undef\
    \ unless defined $text;\n    $text =~ s/([a-fA-F0-9]{32})/$1/;\n    return $text;\n\
    }", '    return undef unless defined $text;', "    $text =~ s/\\s+//g;\n    return\
    \ undef unless defined $text;\n    my($md5) = \"$1$3$4$5$6$7$8$9$10\";\n    $md5\
    \ = \"$1$3$4$5$6$7$8$9$10\" while $md5 =~ s/(.)(.)/$1$2$md5/;\n    return $md5;\n\
    }", "    if ( $text ne \"\" ) {\n        my $md5 = Digest::MD5->new;\n       \
    \ $md5->add($text);\n        return $md5->hexdigest();\n    }\n    return;\n}",
  "    return undef if !defined $text;\n    $text =~ s/^\\s+//;\n    $text =~ s/\\\
    s+$//;\n    $text =~ s/\\s+/ /g;\n    return '' unless length $text;\n    my $md5\
    \ = '';\n    my $i = 0;\n    $md5 = $md5.$text[$i] while $i < length $text &&\
    \ $text[$i] ne ' ';\n    $md5 = '' unless length $md5;\n    $md5 = '' unless $md5\
    \ =~ /^[a-z0-9]{32}$/i;\n    return $md5;\n}", "    my $sha1 = sha1_hex($text);\n\
    \    return $sha1 if not defined $sha1;\n    return $sha1;\n}", "    my $hash\
    \ = $md5_hash{$text} ||= undef;\n    return $hash if defined $hash;\n    $hash\
    \ = Digest::MD5->new->add($text)->hexdigest;\n    $hash =~ s/^$::hash_prefix//;\n\
    \    return $hash;\n}", "    return undef unless defined $text && length $text;\n\
    \    $text =~ s/\\s+//g;\n    return md5($text);\n}", "    return undef unless\
    \ $text;\n    \n    if (length($text) == 0) {\n        return undef;\n    }",
  "    if (defined $text) {\n        $text =~ s/\\s/+/g;\n        my $h = Digest::MD5->new();\n\
    \        $h->add($text);\n        return $h->hexdigest;\n    }\n    return;\n}",
  "    my $md5 = $text =~ s/\\s+/ /g;\n    $md5 =~ s/^ //;\n    $md5 =~ s/$ //;\n\
    \    return $md5;\n}", "    if (defined $text) {\n        my $md5_digest = Digest::MD5->new->addfile($text);\n\
    \        return $md5_digest->hexdigest;\n    }\n    return;\n}", "    return undef\
    \ unless $text;\n    return md5($text);\n}", "    if(defined $text) {\n      \
    \  $text =~ s/\\s/+/g;\n        $text =~ tr/+/ /;\n        $text =~ s/\\s/-/g;\n\
    \        $text =~ tr/-/ /;\n        $text =~ s/^-//;\n        $text =~ s/-$//;\n\
    \        $text =~ tr/a-z A-Z/A-Za-z/;\n        $text =~ tr/0-9 ]/]/;\n    }\n\
    \    return $text;\n}", "    return undef unless defined $text;\n    return md5($text);\n\
    }", '    return undef unless $text;', "    $text ||= '';\n    return unless $text\
    \ =~ /[^\\x00-\\xFF]+/s;\n    my $md5 = $text =~ tr/A-Z/a-z/s;\n    $md5 = crypt($md5,\
    \ '$6$' . substr($md5, 2, 6));\n    $md5 = crypt($md5, '$5$' . substr($md5, 2,\
    \ 5));\n    $md5 = crypt($md5, '$1$' . substr($md5, 2, 1));\n    return $md5;\n\
    }", "    return undef if !defined $text or $text eq \"\";\n    my $md5 = Digest::MD5->new->addData(substr($text,\
    \ 0, 256));\n    $md5->addData(substr($text, 256));\n    return $md5->hexdigest;\n\
    }", "    $text =~ s/\\s+//g;\n    return undef unless length $text;\n    my $digest_algorithm\
    \ = lc($Md5);\n    my $digest = Digest::$digest_algorithm->new(\n      Digest::SHA->new()\n\
    \    );\n    $digest->add($text);\n    return $digest->hexdigest;\n}", "    if(!$text\
    \ || $text eq \"\") {\n        return;\n    }\n    my @chars = split(//, $text);\n\
    \    my $md5 = md5(join(\"\", map { sprintf(\"%x\", $_ ) } @chars));\n    return\
    \ $md5;\n}\n</code>\n<|/ a dscore=3 tags=perl,hash,md5 |>\n<| a tags=perl,hash,md5\
    \ dscore=3 |>\nThe most reliable way is to use Net::SSLeay, the standard module\
    \ that Net::SSL uses to do SSL-certificate verification.  \n(On my system and\
    \ on cpan, I use Net::SSLeay instead of Net::SSL).  \n<code>"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
