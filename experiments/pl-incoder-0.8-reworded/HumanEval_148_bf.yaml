name: HumanEval_148_bf
language: pl
prompt: "# There are eight planets in our solar system: the closerst to the Sun \n\
  # is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n# Uranus,\
  \ Neptune.\n# Write a function that takes two planet names as strings planet1 and\
  \ planet2. \n# The function should return an array containing all planets whose\
  \ orbits are \n# located between the orbit of planet1 and the orbit of planet2,\
  \ sorted by \n# the proximity to the sun. \n# The function should return an empty\
  \ array if planet1 or planet2\n# are not correct planet names. \n# Examples\n# >>>\
  \ bf(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf(\"Earth\",\
  \ \"Mercury\")\n# \"Venus\"\n# >>> bf(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"\
  Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nsub bf {\n    my($planet1, $planet2)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&bf;\n   \
  \     if(eq_deeply($candidate->(\"Jupiter\", \"Neptune\"),[\"Saturn\", \"Uranus\"\
  ])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Earth\", \"Mercury\"),[\"Venus\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"Mercury\", \"Uranus\"),[\"\
  Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Neptune\"\
  , \"Venus\"),[\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Earth\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->(\"Mars\", \"Earth\"),[])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Jupiter\", \"Makemake\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @orbits_between = ();\n    \n    # Check if Planets are correct\
    \ (they must be strings)\n    die \"Planet1 not string!\" unless defined $planet1;\n\
    \    die \"Planet2 not string!\" unless defined $planet2;\n    \n    # Get the\
    \ first planet orbital position\n    my @planet1_orbit = @{$planet_orbits_hash{$planet1}};\n\
    \    \n    # Get the second planet orbital position\n    my @planet2_orbit = @{$planet_orbits_hash{$planet2}};\n\
    \    \n    my @planet_positions = ();\n    \n    # Find planets whose orbits are\
    \ within the sun\n    foreach my $planet (@planet1_orbit) {\n        foreach my\
    \ $planet_2 (@planet2_orbit) {\n            \n            # If the orbits line\
    \ up\n            if($planet1 == $planet_2) {\n                push @planet_positions,\
    \ $planet;\n                last;\n            }\n        }\n    }\n    \n   \
    \ # Sort planets based on proximity to sun\n    foreach my $planet (@planet_positions)\
    \ {\n        my $distance = scalar @{$planet_orbits_hash{$planet}} - 1;\n    \
    \    \n        # Check if planet is within 1 degree of sun\n        if($distance\
    \ < 1) {\n            push @orbits_between, $planet;\n        }\n    }\n    \n\
    \    # Return sorted array\n    return @orbits_between;\n}\n</code>\n<|/ a tags=perl,hash,arrays\
    \ |>\n<| c |>\nNice work, although I'm still not sure what the OP wants. If you\
    \ read the explanation, it sounds like the algorithm is supposed to return an\
    \ array containing all planets whose orbits are located between two planets. E.g.,\
    \ `bf('Jupiter', 'Neptune')` should return `'Saturn'` and `'Uranus'`. It sounds\
    \ like your implementation returns `'Saturn'` and `'Uranus'`, but it returns `'Saturn'`\n\
    <|/ c |>\n<| c |>\nThanks for the reply. The problem with this implementation\
    \ is that it returns Planets instead of Orbits. For example, if I have the planets\
    \ \"Earth\" with orbit positions of `[6.949036166702694, 11.787408453042693, 10.60808861974285,\
    \ 8.785191497275461, 9.84401188574955", "    my @planets;\n    my $sun = get_sun();\n\
    \    foreach my $planet ($planet1, $planet2) {\n        my $orbit = orbit_by_name($planet);\n\
    \        my($a, $b) = @$orbit;\n        my $d = $a - $b;\n        push @planets,\
    \ $planet if $d < 0;\n    }\n    @planets = sort { $a <=> $b } @planets;\n   \
    \ return @planets if @planets != 0;\n    return ();\n}\n</cell>\n<text>\nExercise\
    \ 2\nWrite a program that prints out the names and coordinates of all planets\
    \ that occured \nduring the year 2017. \nThe program should print out two lines.\
    \ One that prints the names and coordinates of all \nplanets whose orbits happen\
    \ during the year 2017 and another one that prints the names and \ncoordinates\
    \ of all planets whose orbits happen during the year 2017. \nPrint out two lines\
    \ only.", "    if ($planet1 eq $planet2) {\n        return $planet1;\n    }\n\
    \    my $sun_distance = distance($planet1, $planet2);\n    if ($sun_distance <\
    \ 50) {\n        return $planet2;\n    }\n    my @orbits = ();\n    my @planet_names\
    \ = ();\n    my @planets = ();\n    foreach my $planet ($planet1, $planet2) {\n\
    \        my $distance = distance($planet, $sun);\n        if ($distance < 50)\
    \ {\n            push @planet_names, $planet;\n            push @orbits, $distance;\n\
    \        }\n    }\n    foreach my $planet (@planet_names) {\n        my $orbit\
    \ = find_orbit($planet);\n        my $distance = distance($planet, $orbit);\n\
    \        if ($distance < 50) {\n            push @planets, $planet;\n        }\n\
    \    }\n    my ($min, $max) = (0, 0);\n    foreach my $planet (@planets) {\n \
    \       my $orbit = find_orbit($planet);\n        my $distance = distance($planet,\
    \ $orbit);\n        $min = 1 if ($distance < $min);\n        $max = 1 if ($distance\
    \ > $max);\n    }\n    return @planets[$min..$max];\n}\n</cell>\n<text>\nThe function\
    \ find_orbit finds the orbit of a given planet at a certain moment in time. \n\
    A planet orbits around the sun if its orbit passes through the center of the planet\
    \ at some \ndistance (in this case, 50 km). The function should return the name\
    \ of the planet, if the \norbit passes through the center of the planet at some\
    \ distance (in this case, 50 km).\nThe function should return an empty string\
    \ if the planet is not in the solar system. \nThe function should return -1 if\
    \ the orbit passes through the center of the planet at some \ndistance (in this\
    \ case, 50 km).", "    my(@planets) = ();\n    \n    my $mercury = \"Mercury\"\
    ;\n    my $venus = \"Venus\";\n    my $earth = \"Earth\";\n    my $mars = \"Mars\"\
    ;\n    my $jupiter = \"Jupiter\";\n    my $saturn = \"Saturn\";\n    my $uranus\
    \ = \"Uranus\";\n    my $neptune = \"Neptune\";\n    \n    if ($planet1 eq $venus)\
    \ {\n        if ($planet2 eq $mercury) {\n            @planets = ($saturn, $uranus);\n\
    \        }\n    }\n    if ($planet1 eq $earth) {\n        if ($planet2 eq $venus)\
    \ {\n            @planets = ($mars, $jupiter, $saturn);\n        }\n    }\n  \
    \  if ($planet1 eq $mars) {\n        if ($planet2 eq $earth) {\n            @planets\
    \ = ($jupiter, $saturn);\n        }\n    }\n    if ($planet1 eq $jupiter) {\n\
    \        if ($planet2 eq $mars) {\n            @planets = ($saturn, $uranus);\n\
    \        }\n    }\n    if ($planet1 eq $saturn) {\n        if ($planet2 eq $jupiter)\
    \ {\n            @planets = ($uranus);\n        }\n    }\n    if ($planet1 eq\
    \ $uranus) {\n        if ($planet2 eq $saturn) {\n            @planets = ($neptune);\n\
    \        }\n    }\n    if ($planet1 eq $neptune) {\n        if ($planet2 eq $uranus)\
    \ {\n            @planets = ($mercury, $venus);\n        }\n    }\n    \n    #\
    \ sort planets by proximity to the sun\n    @planets = sort { (abs(time_since_origin($_)\
    \ - time_since_origin($planet1)) + \n                     abs(time_since_origin($_)\
    \ - time_since_origin($planet2))) \n                    } @planets;\n    \n  \
    \  # return sorted array\n    return @planets;\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=math,algorithm,geometry |>\nYou could probably make a good start by\
    \ reading through this post on Planetary orbit determination and how to calculate\
    \ the distance between two points.\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nAs a\
    \ first step I'd recommend you ", "    $planet1 =~ /^[A-Z][a-z]*$/;\n    $planet2\
    \ =~ /^[A-Z][a-z]*$/;\n    $planet1 = ucfirst($planet1);\n    $planet2 = ucfirst($planet2);\n\
    \    my @orbits = ();\n    push @orbits, $planet1 if $planet1 eq $planet2;\n \
    \   push @orbits, $planet2 if $planet2 eq $planet1;\n    push @orbits, $planet1\
    \ if $planet1 eq $planet2;\n    push @orbits, $planet2 if $planet2 eq $planet1;\n\
    \    my @sorted_orbits = sort{ &proximity_orbit($_, $planet1, $planet2) } @orbits;\n\
    \    return @sorted_orbits;\n}", "    my(@planets);\n    \n    # Mercury\n   \
    \ if( $planet1 eq \"Mercury\" ){\n        @planets =  (\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \  }\n    \n    # Venus\n    if( $planet1 eq \"Venus\" ){\n        @planets =\
    \ (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    \n    # Earth\n    if( $planet1 eq \"Earth\" ){\n        @planets\
    \ = (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\
    \    }\n    \n    # Mars\n    if( $planet1 eq \"Mars\" ){\n        @planets =\
    \ (\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n    \n\
    \    # Jupiter\n    if( $planet1 eq \"Jupiter\" ){\n        @planets = (\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n    \n    # Saturn\n    if( $planet1\
    \ eq \"Saturn\" ){\n        @planets = (\"Saturn\", \"Uranus\", \"Neptune\");\n\
    \    }\n    \n    # Uranus\n    if( $planet1 eq \"Uranus\" ){\n        @planets\
    \ = (\"Uranus\", \"Neptune\");\n    }\n    \n    # Neptune\n    if( $planet1 eq\
    \ \"Neptune\" ){\n        @planets = (\"Neptune\");\n    }\n    \n    # Planet1\
    \ & Planet2 are not planets\n    if( $planet1 eq \"Planet\" || $planet1 eq \"\
    Planets\" || $planet1 eq \"Planets\" ){\n        return @planets;\n    }\n   \
    \ \n    # Planet1 is not a planet\n    if( $planet1 ne \"Planet\" || $planet1\
    \ ne \"Planets\" || $planet1 ne \"Planets\" ){\n        return @planets;\n   \
    \ }\n    \n    # Planet2 is not a planet\n    if( $planet2 ne \"Planet\" || $planet2\
    \ ne \"Planets\" || $planet2 ne \"Planets\" ){\n        return @planet", "   \
    \ my @planets = ();\n    $planet1 =~ /^([A-Z][a-z]{0,2})$/;\n    $planet2 =~ /^([A-Z][a-z]{0,2})$/;\n\
    \    my $mercury_orb = $planet1 eq \"Mercury\" ? 6 : 0;\n    my $venus_orb = $planet1\
    \ eq \"Venus\" ? 4 : 0;\n    my $earth_orb = $planet1 eq \"Earth\" ? 2 : 0;\n\
    \    my $mars_orb = $planet1 eq \"Mars\" ? 1 : 0;\n    my $jupiter_orb = $planet1\
    \ eq \"Jupiter\" ? 1 : 0;\n    my $saturn_orb = $planet1 eq \"Saturn\" ? 1 : 0;\n\
    \    my $uranus_orb = $planet1 eq \"Uranus\" ? 1 : 0;\n    my $neptune_orb = $planet1\
    \ eq \"Neptune\" ? 1 : 0;\n    my $mercury_orbit = $planet2 eq \"Mercury\" ? 6\
    \ : 0;\n    my $venus_orbit = $planet2 eq \"Venus\" ? 4 : 0;\n    my $earth_orbit\
    \ = $planet2 eq \"Earth\" ? 2 : 0;\n    my $mars_orbit = $planet2 eq \"Mars\"\
    \ ? 1 : 0;\n    my $jupiter_orbit = $planet2 eq \"Jupiter\" ? 1 : 0;\n    my $saturn_orbit\
    \ = $planet2 eq \"Saturn\" ? 1 : 0;\n    my $uranus_orbit = $planet2 eq \"Uranus\"\
    \ ? 1 : 0;\n    my $neptune_orbit = $planet2 eq \"Neptune\" ? 1 : 0;\n    my $mercury_orbit_dist\
    \ = sqr($mercury_orbit - $mercury_orb);\n    my $venus_orbit_dist = sqr($venus_orbit\
    \ - $venus_orb);\n    my $earth_orbit_dist = sqr($earth_orbit - $earth_orb);\n\
    \    my $mars_orbit_dist = sqr($mars_orbit - $mars_orb);\n    my $jupiter_orbit_dist\
    \ = sqr($jupiter_orbit - $jupiter_orb);\n    my $saturn_orbit_dist = sqr($saturn_orbit\
    \ - $saturn_orb);\n    my $uranus_orbit_dist = sqr($uranus_orbit - $uranus_orb);\n\
    \    my $neptune_orbit_dist = sqr($neptune_orbit - $neptune_orb);\n    my @orbits_between",
  '    my(@planets);', "    my @planets = ();\n    foreach my $planet (@planets) {\n\
    \        if ($planet ne $planet1) {\n            push(@planets, $planet);\n  \
    \      }\n    }\n    return sort {\n        my $distance = $sun->distance($_);\n\
    \        if ($distance < 0) {\n            return -1;\n        }\n        elsif\
    \ ($distance > 0) {\n            return 1;\n        }\n        return 0;\n   \
    \ } @planets;\n}", "    return @$_ for grep {\n\t$solar_system->{planets}->{$_}->{orbit}\
    \ &&\n\t$solar_system->{planets}->{$_}->{orbit}->{distance} >= &distance($planet1,\
    \ $planet2)\n    } qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n\
    }\n</code>\n<|/ a dscore=4 tags=algorithm,language-agnostic,python |>\n<| c |>\n\
    Great answer! But I still have a small problem in understanding what are you doing.\
    \ If I run your code with a small example it seems to work ok. Can you help me\
    \ to understand better? \nI put my code here: https://eval.in/815806\n<|/ c |>\n\
    <| c |>\n: You are right about `distance` function, it should be `b` instead of\
    \ `a`. Fixed it.\n<|/ c |>\n<| c |>\nThanks very much! It is still a bit difficult\
    \ to understand  :) I will do my best to understand it :D\n<|/ c |>\n<| c |>\n\
    : I'm happy I could help. :) I would recommend you to read through [Python Data\
    \ Structures Howto](https://docs.python.org/3.6/tutorial/datastructures.html#dictionaries)\
    \ and [Python Functional Programming HOWTO](https://docs.python.org/3.6/howto/functional.html)\
    \ if you are not very familiar with Python. [This Python Cookbook](http://code.activestate.com/recipes/577411-data-structure-functions-python/)\
    \ might be helpful as well.\n<|/ c |>\n<| a tags=algorithm,language-agnostic,python\
    \ |>\nThis is more of a comment than an answer, but I can't make it any clearer\
    \ than a comment...\n<code>\ndef bf(a, b):\n    return sorted([\n        p1\n\
    \        for p1, p2 in solar_system.planets.iteritems()\n        if solar_system.planets[p1].orbit\
    \ and solar_system.planets[p2].orbit\n        and distance(a, p1) == distance(a,\
    \ p2)\n        and distance(b, p2) == distance(b, p1)\n    ], key=lambda p: solar_system.planets[p].distance)",
  "    my @planets1 = bf($planet1);\n    my @planets2 = bf($planet2);\n    my @planets\
    \ = ();\n    \n    if (scalar(@planets1) < scalar(@planets2)) {\n        foreach\
    \ my $planet (@planets2) {\n            push(@planets, $planet) if ($planets1\
    \ ne $planet);\n        }\n    } elsif (scalar(@planets1) > scalar(@planets2))\
    \ {\n        foreach my $planet (@planets1) {\n            push(@planets, $planet)\
    \ if ($planets2 ne $planet);\n        }\n    } else {\n        foreach my $planet1\
    \ (@planets1) {\n            foreach my $planet2 (@planets2) {\n             \
    \   my $dist = $planets->{planet1}->{planet2} - $planets->{planet1}->{planet2};\n\
    \                push(@planets, $planet2) if ($dist < 0);\n                push(@planets,\
    \ $planet1) if ($dist > 0);\n            }\n        }\n    }\n    return @planets;\n\
    }", "    my($planet1x, $planet1y) = planet_position($planet1);\n    my($planet2x,\
    \ $planet2y) = planet_position($planet2);\n    my($sunx, $suny) = planet_position(\"\
    Sun\");\n    my(@orbits) = ();\n    my($orbit1x, $orbit1y, $distance) = (0, 0,\
    \ 0);\n    my($orbit2x, $orbit2y, $distance) = (0, 0, 0);\n    for(my $i = 0;\
    \ $i < 8; $i++) {\n        if($i < 3) {\n            my $orbit1x = $planet1x;\n\
    \            my $orbit1y = $planet1y;\n            for(my $j = 1; $j <= $i; $j++)\
    \ {\n                $orbit1x = $orbit1x + $orbits[j-1][0];\n                $orbit1y\
    \ = $orbit1y + $orbits[j-1][1];\n            }\n            $orbit1x = $orbit1x\
    \ + ($planet2x - $orbit1x) / $i;\n            $orbit1y = $orbit1y + ($planet2y\
    \ - $orbit1y) / $i;\n            $distance = $distance + (sqrt((($orbit1x-$sunx)*($orbit1x-$sunx))+(($orbit1y-$suny)*($orbit1y-$suny))));\n\
    \            if($distance <= 6) {\n                push(@orbits, [$i, $distance]);\n\
    \            }\n        } else {\n            my $orbit2x = $planet2x;\n     \
    \       my $orbit2y = $planet2y;\n            for(my $j = 1; $j <= $i; $j++) {\n\
    \                $orbit2x = $orbit2x + $orbits[j-1][0];\n                $orbit2y\
    \ = $orbit2y + $orbits[j-1][1];\n            }\n            $orbit2x = $orbit2x\
    \ + ($planet1x - $orbit2x) / $i;\n            $orbit2y = $orbit2y + ($planet1y\
    \ - $orbit2y) / $i;\n            $distance = $distance + (sqrt((($orbit2x-$sunx)*($orbit2x-$sunx))+(($orbit2y-$suny)*($orbit2y-$suny))));\n\
    \            if($distance <= 6) {\n                push(@orbits, [$i, $distance]);\n\
    \            }\n        }\n    }\n    \n    @orbits = sort {$a->[1] cmp $b->[1]};\n\
    \    return @orbits;\n}", "    my(@orbit);\n    push @orbit, { \"Orbital planets\"\
    \ => { \"Mercury\" => [ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" ], \"Venus\" => [ \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\" ], \"Earth\" => [ \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\" ], \"Mars\" => [ \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" ], \"Jupiter\" => [ \"Saturn\", \"Uranus\", \"Neptune\"\
    \ ], \"Saturn\" => [ \"Uranus\", \"Neptune\" ], \"Uranus\" => [ \"Neptune\" ],\
    \ \"Neptune\" => [ \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\" ] } };", "    $planet1 =~ s/[^A-Za-z]//g;\n    $planet2 =~\
    \ s/[^A-Za-z]//g;\n    my @planets = ();\n    foreach my $planet ($planet1, $planet2)\
    \ {\n        if ($planet eq \"Earth\") {\n            push @planets, \"Earth\"\
    ;\n            next;\n        }\n        if ($planet eq \"Sun\") {\n         \
    \   push @planets, \"Sun\";\n            next;\n        }\n        my @orbitals\
    \ = ();\n        for my $planet (@planets) {\n            my @orbits = ();\n \
    \           for my $planet (@planets) {\n                push (@orbits, $planet\
    \ eq $planet ? \"Sun\" : \"?\");\n            }\n            foreach my $orbit\
    \ (sort {$orbits[$_] cmp $orbits[$_ + 1]} @orbits) {\n                push (@orbitals,\
    \ $orbit);\n            }\n        }\n        push (@planets, @orbitals);\n  \
    \  }\n    push @planets, @planets;\n    my $planet1_orbits = @planets[$#planets\
    \ - 1];\n    foreach my $planet (@planets[0..$#planets]) {\n        my @orbits\
    \ = ();\n        foreach my $planet (@planets) {\n            push (@orbits, $planet\
    \ eq $planet ? \"Sun\" : \"?\");\n        }\n        my @orbitals = ();\n    \
    \    foreach my $orbit (sort {$orbits[$_] cmp $orbits[$_ + 1]} @orbits) {\n  \
    \          push (@orbitals, $orbit);\n        }\n        my @orbitals2 = ();\n\
    \        foreach my $orbit (sort {$orbitals2[$_] cmp $orbitals2[$_ + 1]} @orbitals)\
    \ {\n            push (@orbitals2, $orbit);\n        }\n        push (@planets,\
    \ @orbitals2);\n    }\n    foreach my $planet (@planets) {\n        foreach my\
    \ $planet (@planets) {\n            next if ($planet eq $planet ? \"Sun\" : \"\
    ?\");\n            my @orbits = ();\n            foreach my $planet (@planets)\
    \ {\n                push (@orbits, $planet eq $planet ? \"Sun\" : \"?\");\n \
    \           }\n            my @orbitals = ();\n            foreach my $orbit (sort\
    \ {$orbits[$_] cmp $orbits[$_ + 1]} @orbits) {\n                push (", "   \
    \ my($planet1_orbit, $planet2_orbit) = planet($planet1);\n    my(@planet_orbits);",
  "    my $planets = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \n                    \"Uranus\", \"Neptune\");\n    return @{$planets[map\
    \ { \n        $_->{dist} <= $planet1->{dist} ? $planet1 : $planet2 } \n      \
    \  sort { $a->{dist} <=> $b->{dist} } \n        map { { planet => $_, dist =>\
    \ $_->{dist} } }\n    ]};\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThanks\
    \ Borodin, this helped a lot, especially the example that gives different results\
    \ from the one i was working with. \nAlso, i was wondering if it would be possible\
    \ to sort them by their distance from the sun rather than their orbits? Thanks\
    \ again for your help!\n<|/ c |>\n<| c |>\n: What do you mean by \"sort them by\
    \ their distance from the sun\"?\n<|/ c |>\n<| c |>\nYeah i guess i should have\
    \ said that in the question, i was wondering if it would be possible to sort them\
    \ by the distance from the sun rather than the orbits. Im sorry if i didnt make\
    \ that clear. Thank you for your help!\n<|/ c |>\n<| c |>\n: Just replace `a->{dist}\
    \ <=> $b->{dist}` with `<=> $planet1->{dist} - $planet2->{dist}`\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI made this program, it's working good for me. I think it might\
    \ help you. \n<code>", "    if($planet1 eq 'Mercury' || $planet1 eq 'Venus' ||\
    \ $planet1 eq 'Earth' || $planet1 eq 'Mars' || $planet1 eq 'Jupiter' || $planet1\
    \ eq 'Saturn' || $planet1 eq 'Uranus' || $planet1 eq 'Neptune') {\n        return\
    \ ['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];\n    }\
    \ elsif($planet2 eq 'Mercury' || $planet2 eq 'Venus' || $planet2 eq 'Earth' ||\
    \ $planet2 eq 'Mars' || $planet2 eq 'Jupiter' || $planet2 eq 'Saturn' || $planet2\
    \ eq 'Uranus' || $planet2 eq 'Neptune') {\n        return ['Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune'];\n    } elsif($planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || $planet1 eq 'Uranus'\
    \ || $planet1 eq 'Neptune' && $planet2 eq 'Mercury' || $planet2 eq 'Venus' ||\
    \ $planet2 eq 'Earth' || $planet2 eq 'Mars' || $planet2 eq 'Jupiter' || $planet2\
    \ eq 'Saturn' || $planet2 eq 'Uranus' || $planet2 eq 'Neptune') {\n        return\
    \ ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];\n\
    \    } elsif($planet1 eq 'Mercury' || $planet1 eq 'Venus' || $planet1 eq 'Earth'\
    \ || $planet1 eq 'Mars' || $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || $planet1\
    \ eq 'Uranus' || $planet1 eq 'Neptune' && $planet2 eq 'Earth' || $planet2 eq 'Mars'\
    \ || $planet2 eq 'Jupiter' || $planet2 eq 'Saturn' || $planet2 eq 'Uranus' ||\
    \ $planet2 eq 'Neptune') {\n        return ['", '    my (@orbit1, @orbit2, @orbits);',
  '    my;', "    if ($planet1 eq \"\" or $planet2 eq \"\") {\n        return ();\n\
    \    }\n    if (exists($planets{$planet1} and $planets{$planet2})) {\n       \
    \ return @{$planets{$planet1} .. $planets{$planet2}}; \n    } else {\n       \
    \ return ();\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your help. I tried\
    \ the above but got an error \"Use of uninitialized value $planet1 in concatenation\
    \ (.) or string at planets.pl line 31, <STDIN> line 1.\" I tried replacing $planets{$planet1}\
    \ and $planets{$planet2} with just $planet1 and $planet2 and it works so I suspect\
    \ there is an error somewhere else in the program\n<|/ c |>\n<| c |>\nIt seems\
    \ my version of perl doesn't allow me to declare hash variables. I removed my\
    \ hash and replaced it with = (); and it works great. Thank you for your help\
    \ :)\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    my @orbits= ();\n    my $planet1_orbit=\
    \ $planet1 eq \"Earth\" ? \"Sun\" : \"Mercury\";\n    my $planet2_orbit= $planet2\
    \ eq \"Earth\" ? \"Sun\" : \"Venus\";\n    my $dist_to_sun = 2 * Math::Math::Math::cos(Math::Math::Math::PI()\
    \ / 8);\n    foreach my $planet (sort {abs($a - $b) <=> abs($a - $b)} \n     \
    \                    {$planet1_orbit, $planet2_orbit}) {\n        my $distance=\
    \ $planet1 eq $planet \n                       ? Math::Math::sqrt(\n         \
    \                  Math::Math::sin(Math::Math::PI() / 4) * \n                \
    \           Math::Math::cos(Math::Math::PI() / 4)\n                         )\n\
    \                       : Math::Math::sqrt(\n                           Math::Math::sin(Math::Math::PI()\
    \ / 4) * \n                           Math::Math::cos(Math::Math::PI() / 4)\n\
    \                         );\n        push(@orbits, $planet) if \n           \
    \ (Math::Math::sin($distance) \n             - Math::Math::sin($dist_to_sun) \n\
    \            ) < 0;\n    }\n    sort {abs($a - $b) <=> abs($a - $b)} @orbits;\n\
    }", "    my %planets = (\n        \"Mercury\" => [-1,-1], \n        \"Venus\"\
    \ => [-1,1], \n        \"Earth\" => [1,-1], \n        \"Mars\" => [-1,-1], \n\
    \        \"Jupiter\" => [-1,1], \n        \"Saturn\" => [1,-1], \n        \"Uranus\"\
    \ => [1,1], \n        \"Neptune\" => [-1,-1]\n    );\n    \n    return %planets\
    \ if $planet1 eq $planet2;", "    my(@planets) = @{$planet2};\n    \n    for my\
    \ $i (0..@planets-1) {\n        if ($planets[$i] eq $planet1) {\n            push\
    \ (@planets, $planets[$i]);\n        }\n    }\n    \n    sort(@planets);\n   \
    \ @planets;\n}", "    my @planets = ();\n    if ($planet1 eq \"Mercury\") {\n\
    \        if ($planet2 eq \"Venus\") {\n            @planets = (\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\",\n                        \"Uranus\", \"Neptune\");\n\
    \        }\n        if ($planet2 eq \"Earth\") {\n            @planets = (\"Mars\"\
    , \"Jupiter\", \"Saturn\",\n                        \"Uranus\", \"Neptune\");\n\
    \        }\n    }\n    if ($planet1 eq \"Venus\") {\n        if ($planet2 eq \"\
    Mercury\") {\n            @planets = (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ,\n                        \"Uranus\", \"Neptune\");\n        }\n        if ($planet2\
    \ eq \"Earth\") {\n            @planets = (\"Mars\", \"Jupiter\", \"Saturn\",\n\
    \                        \"Uranus\", \"Neptune\");\n        }\n    }\n    if ($planet1\
    \ eq \"Earth\") {\n        if ($planet2 eq \"Mercury\") {\n            @planets\
    \ = (\"Mars\", \"Jupiter\", \"Saturn\",\n                        \"Uranus\", \"\
    Neptune\");\n        }\n        if ($planet2 eq \"Venus\") {\n            @planets\
    \ = (\"Mars\", \"Jupiter\", \"Saturn\",\n                        \"Uranus\", \"\
    Neptune\");\n        }\n    }\n    if ($planet1 eq \"Mars\") {\n        if ($planet2\
    \ eq \"Mercury\") {\n            @planets = (\"Jupiter\", \"Saturn\", \"Uranus\"\
    ,\n                        \"Neptune\");\n        }\n        if ($planet2 eq \"\
    Venus\") {\n            @planets = (\"Jupiter\", \"Saturn\", \"Uranus\",\n   \
    \                     \"Neptune\");\n        }\n    }\n    if ($planet1 eq \"\
    Jupiter\") {\n        if ($planet2 eq \"Mercury\") {\n            @planets = (\"\
    Saturn\", \"Uranus\", \"Neptune\");\n        }\n        if ($planet2 eq \"Venus\"\
    ) {\n            @planets = (\"Saturn\", \"Uranus\", \"Neptune\");\n        }\n\
    \    }\n    if ($planet1 eq \"Saturn\") {\n        if ($planet2 eq \"Mercury\"\
    ) {\n            @planets = (\"Uranus\", \"Neptune\");\n        }\n        if\
    \ ($planet2 eq \"Venus\") {\n            @planets = (\"Uranus\", \"Neptun", " \
    \   my @planets = ();\n    my @orbits = ();\n    my $sun = Math::SunMath::Sun();",
  "    my @out;\n    my @orbits = @{$planet1}{'orbits'};\n    foreach my $planet (@orbits)\
    \ {\n        if (exists $planet2{'orbits'}) {\n            foreach my $planet2\
    \ (@$planet2{'orbits'}) {\n                if ($planet->{name} eq $planet2->{name})\
    \ {\n                    push(@out, $planet2->{name});\n                    last;\n\
    \                }\n            }\n        }\n    }\n    push(@out, $planet1->{name});\n\
    \    push(@out, $planet2->{name});\n    @out = sort { abs($b->{x} - $a->{x}) +\
    \ abs($b->{y} - $a->{y}) + abs($b->{z} - $a->{z}) }\n            map { $planets{$_}\
    \ }\n            @out;\n    return @out;\n}", "    my @orbit;\n    \n    if ($planet1\
    \ eq $planet2) {\n        push(@orbit, $planet1);\n    }\n    else {\n       \
    \ foreach my $planet (@all_planets) {\n            if ($planet1 eq $planet) {\n\
    \                push(@orbit, $planet);\n                if ($planet2 eq $planet)\
    \ {\n                    push(@orbit, $planet2);\n                }\n        \
    \        last;\n            }\n        }\n    }\n    \n    foreach my $planet\
    \ (@orbit) {\n        my $distance = distance_of_planet($planet);\n        if\
    \ ($distance <= $sun_radius) {\n            push(@orbit, $planet);\n        }\n\
    \    }\n    \n    sort @orbit;\n}", "    my @orbit1 = get_orbit($planet1);\n \
    \   my @orbit2 = get_orbit($planet2);\n    return @orbit1[sort {get_distance(@orbit1[0\
    \ .. $#orbit1], $_, $planet2) <=> get_distance(@orbit2[0 .. $#orbit2], $_, $planet2)}\
    \ @orbit2[0 .. $#orbit2]];\n}\n</code>\n<|/ a tags=perl,sorting,arrays dscore=0\
    \ |>\n<| c |>\nThanks a lot, I was able to figure it out!\n<|/ c |>\n<| c |>\n\
    I wanted to post my code so that it might help some one else, I am sharing my\
    \ code in the answer above. I am sorry for the trouble you might have had with\
    \ this code, I am very new to perl\n<|/ c |>\n<| a |>\n<code>", "    my (@planets);\n\
    \    if ($planet1 eq \"Mercury\") {\n        if ($planet2 eq \"Neptune\") {\n\
    \            push @planets, \"Mercury\";\n            push @planets, \"Saturn\"\
    ;\n            push @planets, \"Uranus\";\n        }\n    } elsif ($planet1 eq\
    \ \"Venus\") {\n        if ($planet2 eq \"Mercury\") {\n            push @planets,\
    \ \"Earth\";\n            push @planets, \"Mars\";\n            push @planets,\
    \ \"Jupiter\";\n            push @planets, \"Saturn\";\n            push @planets,\
    \ \"Uranus\";\n        }\n    } elsif ($planet1 eq \"Earth\") {\n        if ($planet2\
    \ eq \"Mercury\") {\n            push @planets, \"Venus\";\n            push @planets,\
    \ \"Mars\";\n            push @planets, \"Jupiter\";\n            push @planets,\
    \ \"Saturn\";\n            push @planets, \"Uranus\";\n        }\n    } elsif\
    \ ($planet1 eq \"Mars\") {\n        if ($planet2 eq \"Mercury\") {\n         \
    \   push @planets, \"Earth\";\n            push @planets, \"Venus\";\n       \
    \     push @planets, \"Jupiter\";\n            push @planets, \"Saturn\";\n  \
    \          push @planets, \"Uranus\";\n        }\n    } elsif ($planet1 eq \"\
    Jupiter\") {\n        if ($planet2 eq \"Mercury\") {\n            push @planets,\
    \ \"Earth\";\n            push @planets, \"Mars\";\n            push @planets,\
    \ \"Venus\";\n            push @planets, \"Saturn\";\n            push @planets,\
    \ \"Uranus\";\n        }\n    } elsif ($planet1 eq \"Saturn\") {\n        if ($planet2\
    \ eq \"Mercury\") {\n            push @planets, \"Earth\";\n            push @planets,\
    \ \"Mars\";\n            push @planets, \"Jupiter\";\n            push @planets,\
    \ \"Venus\";\n            push @planets, \"Uranus\";\n        }\n    } elsif ($planet1\
    \ eq \"Uranus\") {\n        if ($planet2 eq \"Mercury\") {\n            push @planets,\
    \ \"Earth\";\n            push @planets, \"Mars\";\n            push @planets,\
    \ \"Jupiter", "    my($planet1orbit, $planet2orbit);\n    my($i, $j, $orbit1,\
    \ $orbit2, $planet1name, $planet2name, $distance);\n    my(@planets) = (\"\");\n\
    \    my(@planets) = (\"\");\n    $planet1 = &choose_planet($planet1);\n    $planet2\
    \ = &choose_planet($planet2);\n    while ($planet1name ne $planet2) {\n      \
    \  $orbit1 = &planet_orbit_vector($planet1);\n        $orbit2 = &planet_orbit_vector($planet2);\n\
    \        for ($i = 0; $i < 6; $i++) {\n            $planet1name = &planet_name($orbit1[$i]);\n\
    \            $planet2name = &planet_name($orbit2[$i]);\n            $distance\
    \ = 0;\n            for ($j = 0; $j < 6; $j++) {\n                $distance =\
    \ $distance + $orbit1[$j]*$orbit2[$j];\n            }\n            $distance =\
    \ sqrt($distance);\n            if ($distance < $distance) {\n               \
    \ if ($planet1name ne $planet2) {\n                    push(@planets, $planet1name);\n\
    \                }\n            }\n        }\n        pop(@planets);\n       \
    \ $planet1 = pop(@planets);\n        $planet2 = &choose_planet($planet2);\n  \
    \  }\n    if ($planet1 ne $planet2) {\n        push(@planets, $planet1);\n   \
    \ }\n    if (scalar(@planets) == 0) {\n        return;\n    } else {\n       \
    \ @planets = sort {$b <=> $a} @planets;\n        return @planets;\n    }\n}\n\
    </code>\n<|/ q dscore=2 |>\n<| c |>\n\"The code works for 2 planets, but I need\
    \ a universal function.\" - Can you please add more details about what exactly\
    \ is not working and what error are you getting?\n<|/ c |>\n<| c |>\n- Sorry for\
    \ not being clear enough. I have added more information and also a link to the\
    \ image of what I want it to look like.\n<|/ c |>\n<| c |>\nIf your planets are\
    \ just names, then you are missing an important part in the code, which is the\
    \ `choose_planet` function.\n<|/ c |>\n<| c |>\n- I have added the code to the\
    \ original question.\n<|/ c |>\n<| a dscore=1 |>\nYou don't need an universal\
    \ function. The key idea is that each plan", "    return unless ($planet1 eq $planet2);\n\
    \    my @planets = ();\n    foreach my $planet (@planet_names) {\n        foreach\
    \ my $orbit (@orbits) {\n            my $r = $orbit->distance($planet);\n    \
    \        if ($r >= 0) {\n                push (@planets, $planet);\n         \
    \   }\n        }\n    }\n    foreach my $planet (@planets) {\n        push (@planets,\
    \ $planet) if $planet1 gt $planet;\n    }\n    return sort (@planets);\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for writing and testing my code. I appreciate you\
    \ taking the time to write your thoughts and I really do appreciate seeing examples\
    \ of how you would solve this problem!  My goal was to solve this problem on my\
    \ own, and I really appreciate your time and effort.\n<|/ c |>\n<| c |>\nI was\
    \ also able to solve it on my own; I posted my solution below since it could have\
    \ made it more clear what I was trying to do. Thanks again!\n<|/ c |>\n<| c |>\n\
    This code is so helpful. Thank you\n<|/ c |>\n<| a tags=perl,distance dscore=0\
    \ |>\nI decided to post my solution here since it might help others who are looking\
    \ to solve this problem.\n<code>", "    if ($planet1 eq $planet2) {\n        return\
    \ [];\n    } elsif ($planet1 !~ /^[A-Za-z]*$/) { \n        return bf($planet2,\
    \ $planet1);\n    } elsif ($planet2 !~ /^[A-Za-z]*$/) { \n        return bf($planet1,\
    \ $planet2);\n    }", "    my %orbit;\n    \n    # initialize hash\n    for (@planets)\
    \ {\n        $orbit{$_} = {};\n    }\n    \n    # store sun's distance to each\
    \ planet\n    for (@planets) {\n        $orbit{$_}->{sun} = $sun_distance($_);\n\
    \    }", "    my @planets;\n    if ($planet1 eq $planet2 || $planet1 eq \"Earth\"\
    \ || $planet1 eq \"Mercury\" || \n        $planet1 eq \"Venus\" || $planet1 eq\
    \ \"Mars\" || $planet1 eq \"Jupiter\" || \n        $planet1 eq \"Saturn\" || $planet1\
    \ eq \"Uranus\" || $planet1 eq \"Neptune\" ||\n        $planet2 eq $planet1 ||\
    \ $planet2 eq \"Earth\" || $planet2 eq \"Mercury\" || \n        $planet2 eq \"\
    Venus\" || $planet2 eq \"Mars\" || $planet2 eq \"Jupiter\" || \n        $planet2\
    \ eq \"Saturn\" || $planet2 eq \"Uranus\" || $planet2 eq \"Neptune\") {\n    \
    \    @planets = (@planet1, $planet2);\n    } elsif ($planet1 eq \"Mercury\" &&\
    \ $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Jupiter\"\
    \ && $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Saturn\" &&\
    \ $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Uranus\" &&\
    \ $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Neptune\"\
    \ && $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Mars\" &&\
    \ $planet2 eq \"Earth\") {\n        @planets = (\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"Jupiter\"\
    \ && $", "    my (@planets1, @planets2, @orbits);\n    \n    if($planet1 eq $planet2){\n\
    \        return (@orbits);\n    }\n    \n    if($planet1 eq \"Earth\"){\n    \
    \    @planets1 = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    }\n    elsif($planet1 eq \"Mercury\"){\n        @planets1 = qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    }\n    elsif($planet1 eq \"Venus\"\
    ){\n        @planets1 = qw(Mercury Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    }\n    elsif($planet1 eq \"Earth\"){\n        @planets1 = qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    }\n    elsif($planet1 eq \"Mars\"\
    ){\n        @planets1 = qw(Mercury Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    }\n    elsif($planet1 eq \"Jupiter\"){\n        @planets1 = qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    }\n    elsif($planet1 eq \"Saturn\"\
    ){\n        @planets1 = qw(Mercury Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    }\n    elsif($planet1 eq \"Uranus\"){\n        @planets1 = qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    }\n    elsif($planet1 eq \"Neptune\"\
    ){\n        @planets1 = qw(Mercury Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    }\n    elsif($planet1 eq \"Mercury\"){\n        @planets1 = qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    }\n    elsif($planet1 eq \"Venus\"\
    ){\n        @planets1 = qw(Mercur", "    return @{$planet1->orbits_to($planet2)}\
    \ \n        if $planet1->orbit_to($planet2);\n    return @{$planet2->orbits_to($planet1)}\
    \ \n        if $planet2->orbit_to($planet1);\n    return ();\n}\n</code>\n<|/\
    \ a tags=perl |>\n<| c |>\nThanks Borodin, I really appreciate your help!\n<|/\
    \ c |>\n<| c |>\nI forgot to mention my class was already designed and complete\
    \ - I'm more looking for a solution and explanation on how to go about this task.\
    \  I've been trying to work through it but I'm having a hard time conceptualizing\
    \ how to approach it.\n<|/ c |>\n<| c |>\nHi Borodin, thanks again for the help!\
    \  I tried to work through it but it kept getting out of control and I couldn't\
    \ figure it out.  I actually figured it out eventually, after reading and doing\
    \ more research on the \"orbits_to\" function.  Thanks again for your help!\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is another solution:\n<code>", "    my @arr;\n\
    \    my @planets = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    foreach my $planet (@planets) {\n        my $dist = ($planet eq $planet1)\
    \ ? $planet2 : $planet1;\n        foreach my $planet2 (@planets) {\n         \
    \   my $dist2 = ($planet2 eq $planet1) ? $planet2 : $planet1;\n            if\
    \ ($dist == $dist2) {\n                push, $planet;\n                push, $planet2;\n\
    \                last;\n            }\n        }\n    }\n    if (@planets == 0)\
    \ {\n        @arr = [];\n    } else {\n        @arr = sort {$a <=> $b} @planets;\n\
    \    }\n    return @arr;\n}\n</code>\n<|/ a tags=arrays,perl,sorting |>\n<| a\
    \ |>\nThis was a fun exercise and I used a lot of what you had. My solution was\
    \ to create a hash structure with the planet name as the key and the orbit as\
    \ the value. Once I had the hash, I just had to sort the keys of the hash and\
    \ pull out the values I needed. \nThis may not be the most elegant solution, but\
    \ it was fun to work with. \n<code>\nuse strict;\nuse warnings;", "    my @planets\
    \ = ();\n    for my $planet (@planet_names) {\n        my $planet_orbit = calculate_orbit($planet,\
    \ $planet2);\n        my $planet_orbit2 = calculate_orbit($planet, $planet1);\n\
    \        if ($planet_orbit < $planet_orbit2) {\n            push(@planets, $planet);\n\
    \        } elsif ($planet_orbit > $planet_orbit2) {\n            push(@planets,\
    \ $planet);\n        } else {\n            push(@planets, $planet);\n        }\n\
    \    }\n    sort, {\n        my ($planet1, $planet2) = @_;\n        my $planet_orbit\
    \ = calculate_orbit($planet1, $planet2);\n        my $planet_orbit2 = calculate_orbit($planet2,\
    \ $planet1);\n        return $planet_orbit - $planet_orbit2;\n    };\n    return\
    \ @planets;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIf you're going to post the\
    \ code, please post it as an answer rather than a comment.  There's no need for\
    \ anyone to look at the code in the comment section to determine if you've posted\
    \ the right answer.\n<|/ c |>\n<| c |>\nIt will be easier for other people to\
    \ find it when someone else searching for \"planet transit\" would find it here.\n\
    <|/ c |>\n<| c |>\nI did post it as a question. But it only solves half the problem.\
    \ The second half is the part where it sorts by proximity. That's why I decided\
    \ to post it as a separate question.\n<|/ c |>\n<| c |>\nI added the sorting logic\
    \ to my answer.\n<|/ c |>\n<| c |>\nThis is my first time using Perl. I don't\
    \ understand most of the code. But it does work. The only thing that's not working\
    \ is that it returns all the planets in the array even if they are transit.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    my %orbits = ();\n    \n    # Find all\
    \ planets orbiting planet1 and planet2.\n    # Store the orbit numbers in an array\n\
    \    my $orbits_1 = $planet1 eq \"Earth\" ? $planet1 : \"Mars\" ;\n    my $orbits_2\
    \ = $planet2 eq \"Earth\" ? $planet2 : \"Mars\" ;\n    my $planet1_orbits_1 =\
    \ grep {\n            my ($orbit) = grep {\n                ($_[0] eq $planet1)\n\
    \            } keys %{_orbits($_)}\n        } keys %{_orbits($orbits_1)};\n  \
    \  my $planet1_orbits_2 = grep {\n            my ($orbit) = grep {\n         \
    \       ($_[0] eq $planet1)\n            } keys %{_orbits($_)}\n        } keys\
    \ %{_orbits($orbits_2)};\n    my $planet2_orbits_1 = grep {\n            my ($orbit)\
    \ = grep {\n                ($_[0] eq $planet2)\n            } keys %{_orbits($_)}\n\
    \        } keys %{_orbits($orbits_1)};\n    my $planet2_orbits_2 = grep {\n  \
    \          my ($orbit) = grep {\n                ($_[0] eq $planet2)\n       \
    \     } keys %{_orbits($_)}\n        } keys %{_orbits($orbits_2)};", '    my(@orb)
    = ();', "    my @orbits = ();\n    \n    my $planet1_orbits = planetOrbit($planet1);\n\
    \    my $planet2_orbits = planetOrbit($planet2);\n    \n    foreach my $planet\
    \ (@{$planet1_orbits + $planet2_orbits}) {\n        my @planets_orbits = planetOrbit($planet);\n\
    \        \n        foreach my $planets_orbit (@planets_orbits) {\n           \
    \ my ($i, $j) = (0,0);\n            for ($i = 0; $i < @planets_orbit; $i++) {\n\
    \                if ($planets_orbit[$i] eq $planet2_orbits[$j]) {\n          \
    \          $j++;\n                }\n                else {\n                \
    \    push (@orbits, $planets[$j]);\n                    $j = 0;\n            \
    \    }\n            }\n        }\n    }\n    return sort @orbits;\n}", "    my\
    \ $planet1orbit = find_orbit($planet1);\n    my $planet2orbit = find_orbit($planet2);\n\
    \    my @orbits = find_orbits_between($planet1orbit, $planet2orbit);\n    my (@sorted,$distance);\n\
    \    foreach my $i (@orbits) {\n        $distance = distance($planet1, $planet2,\
    \ $i);\n        push (@sorted, $i);\n    }\n    @sorted = sort {$distance <=>\
    \ $distance} @sorted;\n    return @sorted;\n}", '    my @planets = ();', "   \
    \ my $planet1hash = planethash($planet1);\n    my $planet2hash = planethash($planet2);\n\
    \    my @planetsbetween = ();\n    my %planets;\n    my @orbits = find_orbits($planet1hash,\
    \ $planet2hash);\n    for (@orbits) {\n        if (exists $planets{planet_name($_)})\
    \ {\n            push @planetsbetween, $planets{planet_name($_)};\n        }\n\
    \    }\n    sort { $a->[0] cmp $b->[0] } @planetsbetween;\n}", "    my($planet1Name,\
    \ $planet2Name);\n    my($planet1Orbit, $planet2Orbit);\n    my($distance, $orbit1,\
    \ $orbit2);", '    my($planet1orby, $planet2orby);', "    my(@planets);\n    if\
    \ ($planet1 eq $planet2) {\n        @planets = (\"$planet1\", \"$planet2\");\n\
    \    }\n    else {\n        if ($planet1 =~ m/Earth|Mars/) {\n            push\
    \ @planets, \"$planet1\";\n        }\n        if ($planet1 =~ m/Jupiter|Saturn/)\
    \ {\n            push @planets, \"$planet1\";\n        }\n        if ($planet2\
    \ =~ m/Earth|Mars/) {\n            push @planets, \"$planet2\";\n        }\n \
    \       if ($planet2 =~ m/Jupiter|Saturn/) {\n            push @planets, \"$planet2\"\
    ;\n        }\n    }\n    return sort { abs(distance($_,$planet1)-distance($_,$planet2))\
    \ } @planets;\n}\n</code>\n<|/ a |>\n<| c |>\nHi Jim (upvoted). My answer was\
    \ too wordy, so I deleted it. Your answer was spot on and I used my own. I deleted\
    \ mine too. The idea was to show you how to do it, and I did it. Good job!\n<|/\
    \ c |>\n<| c |>\nThanks for your kind words.\n<|/ c |>\n<| a dscore=0 tags=perl\
    \ |>\nI think you are on the right track with the planets array. As others pointed\
    \ out, you can get each planet from the planet array by using a regular expression\
    \ on the planet names. Your program will work by doing something like this: \n\
    <code>", "    my(@orbits);\n    \n    if ($planet1 eq \"Mercury\") {\n       \
    \ @orbits = sort {distance($_, $planet2) == -1 || distance($_, $planet2) == 0}\
    \ @planets{$_};\n    } elsif ($planet1 eq \"Venus\") {\n        @orbits = sort\
    \ {distance($_, $planet2) == -1 || distance($_, $planet2) == 0} @planets{$_};\n\
    \    } elsif ($planet1 eq \"Earth\") {\n        @orbits = sort {distance($_, $planet2)\
    \ == -1 || distance($_, $planet2) == 0} @planets{$_};\n    } elsif ($planet1 eq\
    \ \"Mars\") {\n        @orbits = sort {distance($_, $planet2) == -1 || distance($_,\
    \ $planet2) == 0} @planets{$_};\n    } elsif ($planet1 eq \"Jupiter\") {\n   \
    \     @orbits = sort {distance($_, $planet2) == -1 || distance($_, $planet2) ==\
    \ 0} @planets{$_};\n    } elsif ($planet1 eq \"Saturn\") {\n        @orbits =\
    \ sort {distance($_, $planet2) == -1 || distance($_, $planet2) == 0} @planets{$_};\n\
    \    } elsif ($planet1 eq \"Uranus\") {\n        @orbits = sort {distance($_,\
    \ $planet2) == -1 || distance($_, $planet2) == 0} @planets{$_};\n    } elsif ($planet1\
    \ eq \"Neptune\") {\n        @orbits = sort {distance($_, $planet2) == -1 || distance($_,\
    \ $planet2) == 0} @planets{$_};\n    } elsif ($planet2 eq \"Mercury\") {\n   \
    \     @orbits = sort {distance($planet1, $_) == -1 || distance($planet1, $_) ==\
    \ 0} @planets{$_};\n    } elsif ($planet2 eq \"Venus\") {\n        @orbits = sort\
    \ {distance($planet1, $_) == -1 || distance($planet1, $_) == 0} @planets{$_};\n\
    \    } elsif ($planet2 eq \"Earth\") {\n        @orbits = sort {distance($planet1,\
    \ $_) == -1 || distance($planet1, $_) == 0} @planets{$_};\n    } elsi", "    my\
    \ ($orbits1, $orbits2) = @_;\n    my (@orbits1, @orbits2);\n    foreach my $orbit\
    \ (@{$orbits1}) {\n        foreach my $orbit2 (@{$orbits2}) {\n            next\
    \ unless $orbit eq $orbit2;\n            next unless $orbit1 eq $orbit2;\n   \
    \         next unless $orbit1 eq \"Sun\";\n            next unless $orbit2 eq\
    \ \"Sun\";\n            push (@orbits1, $orbit);\n            push (@orbits2,\
    \ $orbit2);\n        }\n    }\n    push @orbits1, $orbits2;\n    sort { $a->[0]\
    \ cmp $b->[0] } @orbits1;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIf it's your\
    \ answer, you can accept it by clicking the checkmark on the left of the answer\
    \ you like. This allows people to see that your problem is solved and gives people\
    \ with similar problems a chance at answering your question before you accept\
    \ an answer.\n<|/ c |>\n<| c |>\nThis looks like a good solution, but I don't\
    \ think it returns the correct answer for the test cases given in OP's original\
    \ post.\n<|/ c |>\n<| c |>\nI tested it and it works correctly. For \"Jupiter\"\
    \ it returns \"Saturn\" and \"Uranus\", and for \"Venus\" it returns \"Earth\"\
    . The OP has not stated that \"Jupiter\" should return \"Saturn\" and \"Uranus\"\
    \ because they didn't know that \"Jupiter\" was also an orbit of \"Venus\", and\
    \ they didn't know that it would return both \"Saturn\" and \"Uranus\" when they\
    \ asked for orbits between \"Jupiter\" and \"Venus\".\n<|/ c |>\n<| c |>\nI misunderstood\
    \ your statement of \"Jupiter\" returning \"Saturn\" and \"Uranus\". I thought\
    \ you meant that Jupiter was an orbit of Venus. But you mean that Jupiter is an\
    \ orbit of Jupiter? I still don't know how you get \"Saturn\" and \"Uranus\" from\
    \ this algorithm.\n<|/ c |>\n<| c |>\n\"Saturn\" and \"Uranus\" are the two planets\
    \ closest to the Sun. If Jupiter is an orbit of Venus, then it also orbits Jupiter,\
    \ as does Earth. Therefore \"Saturn\" and \"Uranus\" are the two planets closest\
    \ to the Sun that J", "    my @planets = ();\n    my @orbit;\n    my @orbit1;\n\
    \    my @orbit2;", "    return unless defined($planet1);\n    return unless defined($planet2);\n\
    \    my @result;\n    # Initialize the set of planets with all the planets\n \
    \   push(@result, \"Earth\");\n    push(@result, \"Venus\");\n    push(@result,\
    \ \"Mars\");\n    push(@result, \"Jupiter\");\n    push(@result, \"Saturn\");\n\
    \    push(@result, \"Uranus\");\n    push(@result, \"Neptune\");\n    # Then find\
    \ the planets whose orbits are between the two planets\n    # and put them into\
    \ the result\n    push(@result, @{$planets}{$planet1} if $planet1 =~ /^[A-Za-z]+$/;\n\
    \    push(@result, @{$planets}{$planet2} if $planet2 =~ /^[A-Za-z]+$/;\n    #\
    \ Return the result sorted by the proximity to sun\n    return sort_planets_proximity(@result);\n\
    }", "    my $planet1 = lc ($planet1);\n    my $planet2 = lc ($planet2);", "  \
    \  my @planets = (\n        [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"],\n        [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Venus\"],\n  \
    \      [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\", \"Venus\", \"Earth\"],\n        [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Venus\"\
    , \"Earth\", \"Mars\"]\n    );\n    my $found;\n    my = ();\n    foreach my $planet\
    \ (@planets) {\n        if ($planet =~ /($planet1|$planet2)/) {\n            push(@$found,\
    \ $planet);\n        }\n    }\n    return sort {$b <=> $a} @$found;\n}\n</code>\n\
    <|/ a tags=perl,arrays dscore=1 |>\n<| c |>\nYour `@planets` are redundant as\
    \ the OP has already defined these as constants above. Also if these are `planet1`\
    \ and `planet2` why are you looping over that to populate the `@planets` array?\n\
    <|/ c |>\n<| c |>\nI agree that they are redundant and unnecessary. However when\
    \ I tested the code, I kept getting errors when I did not have these redundant\
    \ planet definitions. I wanted to give a complete and working solution for the\
    \ OP.\n<|/ c |>\n<| c |>\nYou said `@planets = (\n        [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"],\n  \
    \      [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\", \"Venus\"],\n        [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Venus\", \"Earth\"\
    ],\n        [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\", \"Venus\", \"Earth\", \"Mars\"]\n    );` but you dont\
    \ actually use this `@planets` in your code\n<|/ c |>\n<| c |>\nYou are correct.\
    \ I will edit the ", "    $planet1 =~ s/(^|\\s|$)//g;\n    $planet2 =~ s/(^|\\\
    s|$)//g;\n    my $planet_name_1 = $planet1;\n    my $planet_name_2 = $planet2;\n\
    \    if ($planet_name_1 eq $planet_name_2) {\n        return [$planet_name_1];\n\
    \    }\n    if ($planet_name_2 eq \"Earth\" || $planet_name_2 eq \"Sun\") {\n\
    \        return [$planet_name_2];\n    }\n    if ($planet_name_2 eq \"Mercury\"\
    ) {\n        my @mercury_orbits = find_orbit_in_planet(\n            $planet_name_2,\
    \ \"Venus\", \"Earth\", 0, 1);\n        my @mercury_orbits_sorted = sort_planet_orbits($mercury_orbits);\n\
    \        return [@mercury_orbits_sorted];\n    }\n    if ($planet_name_2 eq \"\
    Venus\") {\n        my @venus_orbits = find_orbit_in_planet(\n            $planet_name_2,\
    \ \"Mercury\", \"Earth\", 1, 1);\n        my @venus_orbits_sorted = sort_planet_orbits($venus_orbits);\n\
    \        return [@venus_orbits_sorted];\n    }\n    if ($planet_name_2 eq \"Earth\"\
    \ || $planet_name_2 eq \"Mars\") {\n        my @earth_orbits = find_orbit_in_planet(\n\
    \            $planet_name_2, \"Venus\", \"Earth\", 0, 2);\n        my @earth_orbits_sorted\
    \ = sort_planet_orbits($earth_orbits);\n        return [@earth_orbits_sorted];\n\
    \    }\n    if ($planet_name_2 eq \"Mars\") {\n        my @mars_orbits = find_orbit_in_planet(\n\
    \            $planet_name_2, \"Venus\", \"Earth\", 1, 2);\n        my @mars_orbits_sorted\
    \ = sort_planet_orbits($mars_orbits);\n        return [@mars_orbits_sorted];\n\
    \    }\n    if ($planet_name_2 eq \"Jupiter\") {\n        my @jupiter_orbits =\
    \ find_orbit_in_planet(\n            $planet_name_2, \"Venus\", \"Earth\", 2,\
    \ 2);\n        my @jupiter_orbits_sorted = sort_planet_orbits($jupiter_orbits);\n\
    \        return [@jupiter_orbits_sorted];\n    }\n    if ($planet_name_2 eq \"\
    Saturn\") {\n        my @saturn_orbits = find_orbit_in_planet(\n            $planet_name_2,\
    \ \"Venus\", \"Earth\", 0, 3);\n        my @saturn", "    if ($planet1 eq \"Mercury\"\
    \ && $planet2 eq \"Earth\") {\n        return qw(Mercury Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune);\n    } elsif ($planet1 eq \"Venus\" && $planet2 eq \"\
    Mercury\") {\n        return qw(Mercury Earth Mars Jupiter Saturn Uranus Neptune);\n\
    \    } elsif ($planet1 eq \"Earth\" && $planet2 eq \"Mercury\") {\n        return\
    \ qw(Mercury Mars Jupiter Saturn Uranus Neptune);\n    } elsif ($planet1 eq \"\
    Mars\" && $planet2 eq \"Mercury\") {\n        return qw(Mercury Jupiter Saturn\
    \ Uranus Neptune);\n    } elsif ($planet1 eq \"Jupiter\" && $planet2 eq \"Mercury\"\
    ) {\n        return qw(Mercury Saturn Uranus Neptune);\n    } elsif ($planet1\
    \ eq \"Saturn\" && $planet2 eq \"Mercury\") {\n        return qw(Mercury Uranus\
    \ Neptune);\n    } elsif ($planet1 eq \"Uranus\" && $planet2 eq \"Mercury\") {\n\
    \        return qw(Mercury Neptune);\n    } elsif ($planet1 eq \"Neptune\" &&\
    \ $planet2 eq \"Mercury\") {\n        return qw(Mercury);\n    } elsif ($planet1\
    \ eq \"Mercury\" && $planet2 eq \"Venus\") {\n        return qw(Mercury Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    } elsif ($planet1 eq \"Venus\" &&\
    \ $planet2 eq \"Mercury\") {\n        return qw(Mercury Earth Mars Jupiter Saturn\
    \ Uranus Neptune);\n    } elsif ($planet1 eq \"Earth\" && $planet2 eq \"Mercury\"\
    ) {\n        return qw(Mercury Mars Jupiter Saturn Uranus Neptune);\n    } elsif\
    \ ($planet1 eq \"Mars\" && $planet2 eq \"Mercur", "    my @planets = (@{$planet1}[0],\
    \ @{$planet2}[0]);\n    if ($planet1 eq \"Earth\" && $planet2 eq \"Mars\") \n\
    \    {\n        push @planets, \"Mercury\";\n        push @planets, \"Venus\"\
    ;\n        push @planets, \"Earth\";\n        push @planets, \"Mars\";\n     \
    \   push @planets, \"Jupiter\";\n        push @planets, \"Saturn\";\n        push\
    \ @planets, \"Uranus\";\n        push @planets, \"Neptune\";\n    }\n    if ($planet1\
    \ eq \"Jupiter\" && $planet2 eq \"Saturn\") \n    {\n        push @planets, \"\
    Mercury\";\n        push @planets, \"Venus\";\n        push @planets, \"Earth\"\
    ;\n        push @planets, \"Mars\";\n        push @planets, \"Jupiter\";\n   \
    \     push @planets, \"Saturn\";\n        push @planets, \"Uranus\";\n       \
    \ push @planets, \"Neptune\";\n    }\n    if ($planet1 eq \"Saturn\" && $planet2\
    \ eq \"Uranus\") \n    {\n        push @planets, \"Mercury\";\n        push @planets,\
    \ \"Venus\";\n        push @planets, \"Earth\";\n        push @planets, \"Mars\"\
    ;\n        push @planets, \"Jupiter\";\n        push @planets, \"Saturn\";\n \
    \       push @planets, \"Uranus\";\n        push @planets, \"Neptune\";\n    }\n\
    \    if ($planet1 eq \"Uranus\" && $planet2 eq \"Neptune\") \n    {\n        push\
    \ @planets, \"Mercury\";\n        push @planets, \"Venus\";\n        push @planets,\
    \ \"Earth\";\n        push @planets, \"Mars\";\n        push @planets, \"Jupiter\"\
    ;\n        push @planets, \"Saturn\";\n        push @planets, \"Uranus\";\n  \
    \      push @planets, \"Neptune\";\n    }\n    if ($planet1 eq \"Mars\" && $planet2\
    \ eq \"Jupiter\") \n    {\n        push @planets, \"Mercury\";\n        push @planets,\
    \ \"Venus\";\n        push @planets, \"Earth\";\n        push @planets, \"Mars\"\
    ;\n", "    my @planets;\n    \n    push (@planets, \"Mercury\");\n    push (@planets,\
    \ \"Venus\");\n    push (@planets, \"Earth\");\n    push (@planets, \"Mars\");\n\
    \    push (@planets, \"Jupiter\");\n    push (@planets, \"Saturn\");\n    push\
    \ (@planets, \"Uranus\");\n    push (@planets, \"Neptune\");\n    \n    push (@planets,\
    \ @{_find_orbits_between(@planets, $planet1, $planet2)});\n    \n    @planets\
    \ = sort { $a->[0] cmp $b->[0] } @planets;\n    return @planets;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for the reply! I am new to perl and I could\
    \ not understand how would I print array elements on the screen. I tried using\
    \ foreach loop and print statements but I did not get desired output\n<|/ c |>\n\
    <| c |>\nThe above program is returning an array of arrays. The first element\
    \ is an array reference pointing to the first orbit in the first planet, the second\
    \ element is the same but pointing to the second orbit in the first planet and\
    \ so on. Using `print` on a reference will print out the contents of that array\
    \ reference. Since you want to print out the contents of all the arrays, you need\
    \ to loop through all elements in the array and print them out.\n<|/ c |>\n<|\
    \ c |>\nBy the way, you can also try `Data::Dumper` module to see how it works.\
    \ You will also need to install the perl module. `perl -MData::Dumper -e 'print\
    \ Dumper(\\@planets)'`\n<|/ c |>\n<| a tags=arrays,perl,sorting |>\nYou can use\
    \ the module List::Compare\n<code>\nuse strict;\nuse warnings;", "    my @planets;\n\
    \    \n    if( !(exists $planet2->{radius}) ) {\n        foreach my $planet (\
    \ @planets ) {\n            if( exists $planet->{orbits}{$planet2->{name}} ) {\n\
    \                push(@planets, $planet);\n            }\n        }\n    }\n \
    \   elsif ( exists $planet2->{radius}) {\n        foreach my $planet ( @planets\
    \ ) {\n            if( exists $planet->{orbits}{$planet2->{name}} ) {\n      \
    \          foreach my $orbits ( @{$planet->{orbits}{$planet2->{name}}} ) {\n \
    \                   foreach my $orbit ( @{$orbits->{orbits}} ) {\n           \
    \             if( $orbit->{distance}() < $planet2->{radius}) {\n             \
    \               push(@planets, $planet);\n                        }\n        \
    \            }\n                }\n            }\n        }\n    }\n    else {\n\
    \        foreach my $planet ( @planets ) {\n            if( exists $planet->{orbits}{$planet2->{name}}\
    \ ) {\n                foreach my $orbits ( @{$planet->{orbits}{$planet2->{name}}}\
    \ ) {\n                    foreach my $orbit ( @{$orbits->{orbits}} ) {\n    \
    \                    if( $orbit->{distance}() < $planet2->{radius}) {\n      \
    \                      push(@planets, $planet);\n                        }\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  return @planets;\n}", "    my($orbit1, $orbit2, $planet1planet2, $planet1planet1planet2)\
    \ = @_;\n    # Write your code here.\n    my @planets = ();\n    if($planet1 eq\
    \ \"Mercury\") {\n        $orbit1 = new Orbit($planet1, $planet2, \"Mercury\"\
    , \"Earth\");\n    }\n    if($planet1 eq \"Venus\") {\n        $orbit1 = new Orbit($planet1,\
    \ $planet2, \"Venus\", \"Mars\");\n    }\n    if($planet1 eq \"Earth\") {\n  \
    \      $orbit1 = new Orbit($planet1, $planet2, \"Earth\", \"Mars\");\n    }\n\
    \    if($planet1 eq \"Mars\") {\n        $orbit1 = new Orbit($planet1, $planet2,\
    \ \"Mars\", \"Jupiter\");\n    }\n    if($planet1 eq \"Jupiter\") {\n        $orbit1\
    \ = new Orbit($planet1, $planet2, \"Jupiter\", \"Saturn\");\n    }\n    if($planet1\
    \ eq \"Saturn\") {\n        $orbit1 = new Orbit($planet1, $planet2, \"Saturn\"\
    , \"Uranus\");\n    }\n    if($planet1 eq \"Uranus\") {\n        $orbit1 = new\
    \ Orbit($planet1, $planet2, \"Uranus\", \"Neptune\");\n    }\n    if($planet1\
    \ eq \"Neptune\") {\n        $orbit1 = new Orbit($planet1, $planet2, \"Neptune\"\
    , \"Mercury\");\n    }\n    if($planet2 eq \"Mercury\") {\n        $orbit2 = new\
    \ Orbit($planet2, $planet1, \"Mercury\", \"Earth\");\n    }\n    if($planet2 eq\
    \ \"Venus\") {\n        $orbit2 = new Orbit($planet2, $planet1, \"Venus\", \"\
    Mars\");\n    }\n    if($planet2 eq \"Earth\") {\n        $orbit2 = new Orbit($planet2,\
    \ $planet1, \"Earth\", \"Mars\");\n    }\n    if($planet2 eq \"Mars\") {\n   \
    \     $orbit2 = new Orbit($planet2, $planet1, \"Mars\", \"Jupiter\");\n    }\n\
    \    if($planet2 eq \"Jupiter\") {\n        $orbit2 = new Orbit($planet2, $planet1,\
    \ \"Jupiter\", \"Saturn\");\n    }\n    if($planet2 eq \"Saturn\") {\n       \
    \ $orbit2 = new Orbit($planet2, $plan", "    my @planets = ();\n    my ($orbit1,\
    \ $orbit2);\n    my (@planets_orbits);\n    if ($planet1 eq $planet2) {\n    \
    \    push (@planets, $planet1);\n    }\n    if ($planet1 ne $planet2) {\n    \
    \    return @planets;\n    }\n    else {\n        foreach my $planet1 (@planet_names)\
    \ {\n            foreach my $planet2 (@planet_names) {\n                my ($dist,\
    \ $orbit1, $orbit2) = @{$self->_calculate_orbit($planet1, $planet2)};\n      \
    \          if ($dist < 6) {\n                    push (@planets, $planet1);\n\
    \                }\n                else {\n                    push (@planets,\
    \ $planet2);\n                }\n            }\n        }\n        @planets =\
    \ sort @planets;\n    }\n    return @planets;\n}", "    my @planets = ();\n  \
    \  foreach my $planet1 (@planets) {\n    foreach my $planet2 (@planets) {\n  \
    \      if ($planet1 eq $planet2) {\n            next;\n        }\n        if ($planet1\
    \ eq \"Earth\") {\n            push @planets, $planet1;\n            next;\n \
    \       }\n        if ($planet1 eq \"Mercury\") {\n            push @planets,\
    \ $planet1;\n            next;\n        }\n        if ($planet1 eq \"Venus\")\
    \ {\n            push @planets, $planet1;\n            next;\n        }\n    \
    \    if ($planet1 eq \"Mars\") {\n            push @planets, $planet1;\n     \
    \       next;\n        }\n        if ($planet1 eq \"Jupiter\") {\n           \
    \ push @planets, $planet1;\n            next;\n        }\n        if ($planet1\
    \ eq \"Saturn\") {\n            push @planets, $planet1;\n            next;\n\
    \        }\n        if ($planet1 eq \"Uranus\") {\n            push @planets,\
    \ $planet1;\n            next;\n        }\n        if ($planet1 eq \"Neptune\"\
    ) {\n            push @planets, $planet1;\n            next;\n        }\n    \
    \    if ($planet2 eq \"Earth\") {\n            push @planets, $planet2;\n    \
    \        next;\n        }\n        if ($planet2 eq \"Mercury\") {\n          \
    \  push @planets, $planet2;\n            next;\n        }\n        if ($planet2\
    \ eq \"Venus\") {\n            push @planets, $planet2;\n            next;\n \
    \       }\n        if ($planet2 eq \"Mars\") {\n            push @planets, $planet2;\n\
    \            next;\n        }\n        if ($planet2 eq \"Jupiter\") {\n      \
    \      push @planets, $planet2;\n            next;\n        }\n        if ($planet2\
    \ eq \"Saturn\") {\n            push @planets, $planet2;\n            next;\n\
    \        }\n        if ($planet2 eq \"Uranus\") {\n            push @planets,\
    \ $planet2;\n            next;\n        }\n        if ($planet2 eq \"Neptune\"\
    ) {\n            push @planets, $planet2;\n            next;\n        }\n    \
    \    if ($planet1 eq \"Jupiter\" && $planet2 eq \"Neptune\") {\n            push ",
  "    return sort { $planet1 <=> $planet2 } grep ($planet1 eq $planet2 || \n    \
    \        $planet1 eq \"Saturn\" || $planet1 eq \"Uranus\" || $planet1 eq \"Neptune\"\
    \ ||\n            $planet2 eq \"Saturn\" || $planet2 eq \"Uranus\" || $planet2\
    \ eq \"Neptune\" || \n            $planet1 eq \"Earth\" || $planet2 eq \"Earth\"\
    \ || \n            $planet1 eq \"Mars\" || $planet2 eq \"Mars\" || \n        \
    \    $planet1 eq \"Jupiter\" || $planet2 eq \"Jupiter\" || \n            $planet1\
    \ eq \"Venus\" || $planet2 eq \"Venus\" || \n            $planet1 eq \"Earth\"\
    \ || $planet2 eq \"Earth\" || \n            $planet1 eq \"Mars\" || $planet2 eq\
    \ \"Mars\" || \n            $planet1 eq \"Jupiter\" || $planet2 eq \"Jupiter\"\
    \ || \n            $planet1 eq \"Venus\" || $planet2 eq \"Venus\" || \n      \
    \      $planet1 eq \"Earth\" || $planet2 eq \"Earth\" || \n            $planet1\
    \ eq \"Mars\" || $planet2 eq \"Mars\" ||\n            $planet1 eq \"Jupiter\"\
    \ || $planet2 eq \"Jupiter\" || \n            $planet1 eq \"Venus\" || $planet2\
    \ eq \"Venus\" || \n            $planet1 eq \"Earth\" || $planet2 eq \"Earth\"\
    \ || \n            $planet1 eq \"Mars\" || $planet2 eq \"Mars\" || \n        \
    \    $planet1 eq \"Jupiter\" || $planet2 eq \"Jupiter\" || \n            $planet1\
    \ eq \"Venus\" || $planet2 eq \"Venus\" || \n            $planet1 eq \"Earth\"\
    \ || $planet2 eq \"Earth\" || \n            $planet1 eq \"Mars\" || $planet2 eq\
    \ \"Mars\" || \n            $planet1 eq \"Jupiter\" || $planet2 eq \"Jupiter\"\
    \ || \n            $planet1 eq \"Venus\" || $planet2 eq \"Venus\" || \n      \
    \      $planet1 eq \"Earth\" || $planet2 eq \"Earth\" || \n            $planet1\
    \ eq \"Mars\" || $planet2 eq \"Mars\" || \n            $planet1 eq", "    my @orbits\
    \ = ();\n    \n    if ($planet1 eq $planet2 ) {\n        return @orbits;\n   \
    \ }\n    \n    if ( $planet1 =~ /^(Earth)$/i ) {\n        return @orbits;\n  \
    \  }\n    \n    if ( $planet2 =~ /^(Earth)$/i ) {\n        return @orbits;\n \
    \   }\n    \n    if ( $planet1 =~ /^(Mars)$/i ) {\n        return @orbits;\n \
    \   }\n    \n    if ( $planet2 =~ /^(Mars)$/i ) {\n        return @orbits;\n \
    \   }\n    \n    if ( $planet1 =~ /^(Jupiter)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Jupiter)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Saturn)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Saturn)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Uranus)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Uranus)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Neptune)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Neptune)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Venus)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Venus)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Mercury)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Mercury)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Mars)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(Mars)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet1 =~ /^(Jupiter)$/i ) {\n        return @orbits;\n\
    \    }\n    \n    if ( $planet2 =~ /^(J", "    if ($planet1 eq \"Mercury\") {\n\
    \        $planet1 =~ s/^Mercury.*$//;\n    }\n    elsif ($planet1 eq \"Venus\"\
    ) {\n        $planet1 =~ s/^Venus.*$//;\n    }\n    elsif ($planet1 eq \"Earth\"\
    ) {\n        $planet1 =~ s/^Earth.*/Earth/;\n    }\n    elsif ($planet1 eq \"\
    Mars\") {\n        $planet1 =~ s/^Mars.*$//;\n    }\n    elsif ($planet1 eq \"\
    Jupiter\") {\n        $planet1 =~ s/^Jupiter.*$//;\n    }\n    elsif ($planet1\
    \ eq \"Saturn\") {\n        $planet1 =~ s/^Saturn.*$//;\n    }\n    elsif ($planet1\
    \ eq \"Uranus\") {\n        $planet1 =~ s/^Uranus.*$//;\n    }\n    elsif ($planet1\
    \ eq \"Neptune\") {\n        $planet1 =~ s/^Neptune.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Mercury\") {\n        $planet2 =~ s/^Mercury.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Venus\") {\n        $planet2 =~ s/^Venus.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Earth\") {\n        $planet2 =~ s/^Earth.*/Earth/;\n    }\n    elsif ($planet2\
    \ eq \"Mars\") {\n        $planet2 =~ s/^Mars.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Jupiter\") {\n        $planet2 =~ s/^Jupiter.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Saturn\") {\n        $planet2 =~ s/^Saturn.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Uranus\") {\n        $planet2 =~ s/^Uranus.*$//;\n    }\n    elsif ($planet2\
    \ eq \"Neptune\") {\n        $planet2 =~ s/^Neptune.*$//;\n    }\n    return ",
  "    my @planets;\n    my ($orbit1, $orbit2) = (planetorbit($planet1), planetorbit($planet2));\n\
    \    for my $planet (@planets) {\n        if ($orbit1 eq $planet && $orbit2 eq\
    \ $planet) {\n            print \"$planet is between the planets of $planet1 and\
    \ $planet2.\";\n        }\n    }\n}", "    my($planet_orbits, $planet_names);\n\
    \    my(@orbits); \n    my(@names);\n    \n    # Step 1: Define the planets in\
    \ the orbit\n    push @orbits,     {planet1 => \"$planet1\",   planet2 => \"$planet2\"\
    };\n    push @orbits,     {planet1 => \"$planet2\",   planet2 => \"$planet1\"\
    };\n    push @orbits,     {planet1 => \"$planet1\",   planet2 => \"$planet2\"\
    };\n    push @orbits,     {planet1 => \"$planet2\",   planet2 => \"$planet1\"\
    };\n    push @orbits,     {planet1 => \"$planet1\",   planet2 => \"$planet2\"\
    };\n    push @orbits,     {planet1 => \"$planet2\",   planet2 => \"$planet1\"\
    };\n    push @orbits,     {planet1 => \"$planet1\",   planet2 => \"$planet2\"\
    };\n    push @orbits,     {planet1 => \"$planet2\",   planet2 => \"$planet1\"\
    };\n    push @orbits,     {planet1 => \"$planet1\",   planet2 => \"$planet2\"\
    };\n    push @orbits,     {planet1 => \"$planet2\",   planet2 => \"$planet1\"\
    };", "    my($orbit_sun1, $orbit_sun2) = get_orbit_sun($planet1);\n    my($planet_sun1,\
    \ $planet_sun2) = get_planet_sun($planet1);\n    my($planet_sun3, $planet_sun4)\
    \ = get_planet_sun($planet2);\n    my(@planets_orbit) = ();\n    my($orbit_sun3,\
    \ $orbit_sun4, $planet_sun3, $planet_sun4) = (0,0,0);\n    if ($orbit_sun1 < $orbit_sun2)\
    \ {\n        $orbit_sun3 = $orbit_sun1;\n        $orbit_sun4 = $orbit_sun2;\n\
    \        $planet_sun3 = $planet_sun1;\n        $planet_sun4 = $planet_sun2;\n\
    \    }\n    elsif ($orbit_sun1 > $orbit_sun2) {\n        $orbit_sun3 = $orbit_sun2;\n\
    \        $orbit_sun4 = $orbit_sun1;\n        $planet_sun3 = $planet_sun2;\n  \
    \      $planet_sun4 = $planet_sun1;\n    }\n    else {\n        $orbit_sun3 =\
    \ $orbit_sun1;\n        $orbit_sun4 = $orbit_sun2;\n        $planet_sun3 = $planet_sun1;\n\
    \        $planet_sun4 = $planet_sun2;\n    }\n    push @planets_orbit, @{$planet_sun3\
    \ .. $planet_sun4}\n        if abs($orbit_sun1 - $orbit_sun2) != abs($orbit_sun3\
    \ - $orbit_sun4);\n    return sort {$a <=> $b} @planets_orbit;\n}\n</code>\nAnd\
    \ here is my solution to your question:\n<code>", "    if ($planet1 eq $planet2)\
    \ {\n        return [];\n    }\n    $planet1 =~ s/^\\s+//;\n    $planet2 =~ s/^\\\
    s+//;\n    return sort {\n        my ($sun1, $sun2) = @$planet1 =~ m/(\\S+) (\\\
    S+)/;\n        my ($planet1Orbit, $planet2Orbit) = @$planet1 =~ m/(\\S+) (\\S+)/;\n\
    \        my ($planet1Orbit2, $planet2Orbit2) = @$planet2 =~ m/(\\S+) (\\S+)/;\n\
    \        $sun1 eq $sun2 ? $planet1Orbit <=> $planet2Orbit : $sun1 <=> $sun2;\n\
    \    };\n}\n</code>\n<|/ a dscore=0 tags=perl,sorting,algorithm,string |>\n<|\
    \ a dscore=0 |>\nHere's another solution that doesn't require any special modules\
    \ and doesn't require sorting.\n<code>", "    my $planets = ();\n    \n    # your\
    \ code goes here\n    \n    \n    return $planets;\n}", "    my @planets = ();\n\
    \    if ($planet1 =~ /^Mars/ && $planet2 =~ /^Uranus$/) { \n        $planet1 =\
    \ \"Earth\"; \n        $planet2 = \"Mercury\";\n    } elsif ($planet1 =~ /^Mars/\
    \ && $planet2 =~ /^Earth$/) { \n        $planet1 = \"Earth\"; \n        $planet2\
    \ = \"Venus\";\n    } elsif ($planet1 =~ /^Mars/ && $planet2 =~ /^Venus$/) { \n\
    \        $planet1 = \"Earth\"; \n        $planet2 = \"Mercury\";\n    } elsif\
    \ ($planet1 =~ /^Mercury/ && $planet2 =~ /^Uranus$/) { \n        $planet1 = \"\
    Mercury\"; \n        $planet2 = \"Venus\";\n    } elsif ($planet1 =~ /^Mercury/\
    \ && $planet2 =~ /^Earth$/) { \n        $planet1 = \"Mercury\"; \n        $planet2\
    \ = \"Earth\";\n    } elsif ($planet1 =~ /^Mercury/ && $planet2 =~ /^Venus$/)\
    \ { \n        $planet1 = \"Mercury\"; \n        $planet2 = \"Mercury\";\n    }\
    \ elsif ($planet1 =~ /^Jupiter/ && $planet2 =~ /^Saturn$/) { \n        $planet1\
    \ = \"Jupiter\"; \n        $planet2 = \"Saturn\";\n    } elsif ($planet1 =~ /^Jupiter/\
    \ && $planet2 =~ /^Uranus$/) { \n        $planet1 = \"Jupiter\"; \n        $planet2\
    \ = \"Uranus\";\n    } elsif ($planet1 =~ /^Jupiter/ && $planet2 =~ /^Neptune$/)\
    \ { \n        $planet1 = \"Jupiter\"; \n        $planet2 = \"Neptune\";\n    }\
    \ elsif ($planet1 =~ /^Jupiter/ && $planet2 =~ /^Pluto$/) { \n        $planet1\
    \ = \"Jupiter\"; \n        $planet2 = \"Pluto\";\n    } elsif ($planet1 =~ /^Saturn/\
    \ && $planet2 =~ /^Uranus$/) { \n        $planet1 = \"Saturn\"; \n        $planet",
  "    my(@orbits) = ();\n    my $moon = $planet1 . \"_Moon\";\n    if (grep(/$planet1/i,\
    \ keys %planets)) { push(@orbits, $moon) }\n    if (grep(/$planet2/i, keys %planets))\
    \ { push(@orbits, $planet2 . \"_Moon\") }\n    if (grep(/$planet1/i, keys %planets))\
    \ { push(@orbits, $planet1 . \"_Mercury\") }\n    if (grep(/$planet2/i, keys %planets))\
    \ { push(@orbits, $planet2 . \"_Mercury\") }\n    foreach my $orb (@orbits) {\n\
    \        my @orbit = (split \"_\", $orb);\n        my($i, $moon_i) = @orbit[0..5];\n\
    \        my($j, $moon_j) = (@orbit > 5) ? @orbit[5..6] : ();\n        my($k, $moon_k)\
    \ = (@orbit > 6) ? @orbit[6..8] : ();\n        my($s, $sun_i) = @orbit[0..1];\n\
    \        my($t, $sun_j) = (@orbit > 2) ? @orbit[2..3] : ();\n        my($u, $sun_k)\
    \ = (@orbit > 3) ? @orbit[3..4] : ();\n        my($w) = @orbit[4..8];\n      \
    \  my $sun_dist = $sun_i + $sun_j + $sun_k;\n        my $moon_dist = $moon_i +\
    \ $moon_j + $moon_k;\n        if ($moon_dist < $sun_dist) { $moon_dist = $sun_dist\
    \ }\n        if ($moon_dist < $sun_dist) { $moon_dist = $sun_dist }\n        if\
    \ ($moon_dist < $sun_dist) { $moon_dist = $sun_dist }\n        if ($moon_dist\
    \ < $sun_dist) { $moon_dist = $sun_dist }\n        if ($moon_dist < $sun_dist)\
    \ { $moon_dist = $sun_dist }\n        if ($moon_dist < $sun_dist) { $moon_dist\
    \ = $sun_dist }\n        if ($moon_dist < $sun_dist) { $moon_dist = $sun_dist\
    \ }\n        if ($moon_dist < $sun_dist) { $moon_dist = $sun_dist }\n        if\
    \ ($moon_dist < $sun_dist) { $moon_dist = $sun", "    return unless defined $planet1\
    \ && defined $planet2 && \n                     $planet1 =~ /^([A-Z]{3}|[a-z]{3})$/\
    \ && \n                     $planet2 =~ /^([A-Z]{3}|[a-z]{3})$/;\n    # planets\
    \ are correct planet names, get the orbits\n    my ($o1, $o2) = planet_orbits($planet1,\
    \ $planet2);\n    # get the distance between the planets\n    my $d = planet_distance($planet1,\
    \ $planet2);\n    # sort the orbits and return them in order of proximity\n  \
    \  return sort {\n                my ($a1, $b1) = $a <=> $b;\n               \
    \ my $d1 = planet_distance($planet1, $a1);\n                my $d2 = planet_distance($planet2,\
    \ $b1);\n                return ($d1 <=> $d2) \n                      || ($d2\
    \ <=> $d1) \n                      || (abs($a2 - $b2) <=> $d);\n            }\
    \ \n            ($o1, $o2);\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=planets,perl,sorting\
    \ dscore=2 |>\nThe key to the solution lies in the fact that the distance is given\
    \ by the distance to the sun, so we already have the sun and need to find the\
    \ distance between planet 1 and 2, and the distance between planet 2 and 1, and\
    \ sort by the difference between these.  \n<code>", "    $planet1 = lcfirst($planet1);\n\
    \    $planet2 = lcfirst($planet2);\n    my @planets;", "    if ($planet1 eq \"\
    \") {\n        push (@planets, $planet2);\n    }\n    if ($planet2 eq \"\") {\n\
    \        push (@planets, $planet1);\n    }\n    if ($planet1 ne $planet2) {\n\
    \        push (@planets, $planet1);\n        push (@planets, $planet2);\n    }\n\
    \    if ($planet2 ne $planet1) {\n        push (@planets, $planet1);\n       \
    \ push (@planets, $planet2);\n    }\n    if ($planet1 eq $planet2) {\n       \
    \ push (@planets, $planet1);\n    }\n    if ($planet1 ne $planet2) {\n       \
    \ push (@planets, $planet1);\n        push (@planets, $planet2);\n    }\n    if\
    \ ($planet1 eq $planet2) {\n        push (@planets, $planet1);\n    }\n    if\
    \ ($planet2 eq $planet1) {\n        push (@planets, $planet2);\n    }\n    if\
    \ ($planet2 ne $planet1) {\n        push (@planets, $planet2);\n        push (@planets,\
    \ $planet1);\n    }\n    return sort { ($a <=> $b) };\n}\n</code>\n<|/ q |>\n\
    <| c |>\nI didn't think we would have to see your code for the above example.\
    \  However, there are many ways to solve this problem.  Your code has so many\
    \ redundancies that you might not be able to write it in a way that makes it easy\
    \ to understand and maintain.  Try breaking the problem down into manageable subproblems\
    \ and then ask a more specific question.\n<|/ c |>\n<| a |>\nThere are two cases\
    \ to consider here.\nThe first is when one of the planets is the Sun.\nThe second\
    \ is when both of the planets are the Sun.\n<code>", "    my @orbits;\n    \n\
    \    $orbits[0] = planet1 if planet1_to_orbit($planet1) < planet2_to_orbit($planet2);\n\
    \    $orbits[1] = planet2 if planet1_to_orbit($planet1) > planet2_to_orbit($planet2);\n\
    \    \n    return @orbits;\n}", "    if ($planet1 eq $planet2) {\n        return\
    \ [];\n    }\n    my($planet1orb) = bforbit($planet1);\n    my($planet2orb) =\
    \ bforbit($planet2);\n    my(@planets) =  bforbitplanets(\\@planet1orb, \\@planet2orb);\n\
    \    return sort {abs($b->{x} - $a->{x}) < abs($b->{y} - $a->{y}) ?\n        \
    \                $b->{x} - $a->{x} : $b->{y} - $a->{y}};\n}", "    $planet1 =~\
    \ s/[\\s'\"]/\\\\$&/g;\n    $planet2 =~ s/[\\s'\"]/\\\\$&/g;\n    my = qw(Mercury\
    \ Venus Earth Mars Jupiter Saturn Uranus Neptune);\n    my = ();\n    foreach\
    \ my $p1 (@planets) {\n        if($p1 eq $planet1) {\n            foreach my $p2\
    \ (@planets) {\n                if($p2 eq $planet2) {\n                    push(@b,\
    \ $p2);\n                    push(@b, $p1);\n                    @b = sort {$b\
    \ <=> $a} @b;\n                    push(@b, $planet2);\n                    @b\
    \ = sort {$b <=> $a} @b;\n                    last;\n                }\n     \
    \       }\n        }\n    }\n    return @b if scalar @b > 0;\n    return ();\n\
    }", "    if ($planet1 ne \"Jupiter\" and $planet1 ne \"Mercury\" and $planet1\
    \ ne \"Earth\" and \n        $planet1 ne \"Mars\" and $planet1 ne \"Saturn\" and\
    \ $planet1 ne \"Uranus\" and \n        $planet1 ne \"Neptune\"){\n        return\
    \ ();\n    }\n    if ($planet2 ne \"Jupiter\" and $planet2 ne \"Mercury\" and\
    \ $planet2 ne \"Earth\" and \n        $planet2 ne \"Mars\" and $planet2 ne \"\
    Saturn\" and $planet2 ne \"Uranus\" and \n        $planet2 ne \"Neptune\"){\n\
    \        return ();\n    }\n    my @planets1 = ();\n    my @planets2 = ();\n \
    \   my %orbits = (Jupiter => [Venus, Mars, Jupiter, Saturn, Uranus, Neptune],\n\
    \t\t   Mercury => [Venus, Earth, Mars, Jupiter, Saturn, Uranus],\n\t\t   Earth\
    \ => [Mercury, Mars, Jupiter, Saturn, Uranus],\n\t\t   Mars => [Jupiter, Saturn,\
    \ Uranus],\n\t\t   Saturn => [Mercury, Uranus],\n\t\t   Uranus => [Mercury, Mars,\
    \ Jupiter, Saturn],\n\t\t   Neptune => [Mercury, Mars, Jupiter]);\n    \n    my\
    \ ($planet1, $planet2) = ($planet1, $planet2);\n    foreach $planet1 (@{$orbits{$planet1}}){\n\
    \        foreach $planet2 (@{$orbits{$planet2}}){\n            if ($planet1 eq\
    \ $planet2){\n                push (@planets2, $planet1);\n            }else{\n\
    \                if ($planet2 < $planet1){\n                    push (@planets1,\
    \ $planet1);\n                }else{\n                    push (@planets1, $planet2);\n\
    \                    push (@planets2, $planet1);\n                }\n        \
    \    }\n        }\n    }\n    \n    foreach $planet1 (@planets1){\n        foreach\
    \ $planet2 (@planets2){\n            if ($planet1 eq $planet2){\n            \
    \    push (@planets2, $plan", '    my @planets = ();', '    my @planets = ();',
  "    $planet1 = ucfirst($planet1);\n    $planet2 = ucfirst($planet2);\n    my(@planets);\n\
    \    push(@planets, $planet2) if $planet1 == $planet2;\n    push(@planets, $planet1)\
    \ if $planet1 == $planet2;\n    push(@planets, $planet1, $planet2) if $planet1\
    \ == $planet2;\n    push(@planets, $planet1, $planet2) if $planet1 == $planet2;\n\
    \    push(@planets, $planet2) if $planet1 == $planet2;\n    push(@planets, $planet2,\
    \ $planet1) if $planet1 == $planet2;\n    push(@planets, $planet2, $planet1) if\
    \ $planet1 == $planet2;\n    push(@planets, $planet1, $planet2, $planet3) if $planet1\
    \ == $planet2;\n    push(@planets, $planet1, $planet2, $planet3) if $planet1 ==\
    \ $planet2;\n    push(@planets, $planet1, $planet3, $planet2) if $planet1 == $planet2;\n\
    \    push(@planets, $planet1, $planet3, $planet2) if $planet1 == $planet2;\n \
    \   push(@planets, $planet3, $planet1, $planet2) if $planet1 == $planet2;\n  \
    \  push(@planets, $planet3, $planet1, $planet2) if $planet1 == $planet2;\n   \
    \ push(@planets, $planet3, $planet2, $planet1) if $planet1 == $planet2;\n    push(@planets,\
    \ $planet3, $planet2, $planet1) if $planet1 == $planet2;\n    push(@planets, $planet3,\
    \ $planet2, $planet1) if $planet1 == $planet2;\n    push(@planets, $planet3, $planet2,\
    \ $planet1) if $planet1 == $planet2;\n    push(@planets, $planet3, $planet2, $planet1,\
    \ $planet4) if $planet1 == $planet2;\n    push(@planets, $planet3, $planet2, $",
  '    my @sorted_planets;', "    # ...\n}\n</cell>\n<cell>", '    my(@planets);',
  "    my @planets = (@Planets, $planet1, $planet2);\n    my @orbits;\n    for my\
    \ $planet (@planets) {\n        push @orbits, $planet;\n    }\n    return sort\
    \ {\n        my $planet1_dist = distance($orbits[0], $planet);\n        my $planet2_dist\
    \ = distance($orbits[1], $planet);\n        if ($planet1_dist < $planet2_dist)\
    \ {\n            return 1;\n        }\n        if ($planet1_dist > $planet2_dist)\
    \ {\n            return -1;\n        }\n        return 0;\n    }@orbits;\n}\n\
    </code>\n<|/ a |>\n<| a |>\nThis problem can be solved with a O(n log n) algorithm\
    \ using binary search.\nThe idea is to first search for the orbit of the planet1\
    \ and then binary search the orbits of the planet2 in the found orbit. \nComplexity\
    \ is O(n log n), worst case is O(n^2) \n<code>\ndef search(planet1, planet2):\n\
    \    # search for the orbit of the planet1\n    orbit = search(planet1) \n   \
    \ orbits = search(planet2, orbit)\n    return sorted(orbits)", "    my($planet1,\
    \ $planet2, @result) = ($planet1, $planet2, []);\n    my %planets = ();\n    my\
    \ ($planet1_orbit, $planet2_orbit, $distance);", "    return @{$planets}[grep($planet1,\
    \ @{$planets}) .. grep($planet2, @{$planets})]\n        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet2, @{$planets}) .. grep($planet1, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet1, @{$planets}) .. grep($planet2, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet2, @{$planets}) .. grep($planet1, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet1, @{$planets}) .. grep($planet2, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet2, @{$planets}) .. grep($planet1, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet1, @{$planets}) .. grep($planet2, @{$planets})]\n\
    \        if $planets =~ /^(Jupiter|Venus|Earth|Mars|Jupiter|Saturn|Uranus|Neptune)$/;\n\
    \    return @{$planets}[grep($planet2, @{$", "    return if !$planet1 || !$planet2;\n\
    \    \n    my @orbits = ();\n    push @orbits, \"Earth\" if $planet1 eq \"Earth\"\
    ;\n    push @orbits, \"Mars\" if $planet1 eq \"Mars\";\n    push @orbits, \"Mercury\"\
    \ if $planet1 eq \"Mercury\";\n    push @orbits, \"Jupiter\" if $planet1 eq \"\
    Jupiter\";\n    push @orbits, \"Saturn\" if $planet1 eq \"Saturn\";\n    push\
    \ @orbits, \"Uranus\" if $planet1 eq \"Uranus\";\n    push @orbits, \"Neptune\"\
    \ if $planet1 eq \"Neptune\";", "    my($planet1_orbit, $planet2_orbit, $sun_orbit);\n\
    \    my @planets;", '    my@orbits;', "    my @result;\n    \n    if ($planet1->[0]\
    \ eq \"Earth\") {\n        if ($planet2->[0] eq \"Mercury\") {\n            push\
    \ @result, $planet1, $planet2;\n        }\n        elsif ($planet2->[0] eq \"\
    Venus\") {\n            push @result, $planet1, $planet2;\n        }\n       \
    \ elsif ($planet2->[0] eq \"Mars\") {\n            push @result, $planet1, $planet2;\n\
    \        }\n        elsif ($planet2->[0] eq \"Jupiter\") {\n            push @result,\
    \ $planet1, $planet2;\n        }\n        elsif ($planet2->[0] eq \"Saturn\")\
    \ {\n            push @result, $planet1, $planet2;\n        }\n        elsif ($planet2->[0]\
    \ eq \"Uranus\") {\n            push @result, $planet1, $planet2;\n        }\n\
    \        elsif ($planet2->[0] eq \"Neptune\") {\n            push @result, $planet1,\
    \ $planet2;\n        }\n    }\n    elsif ($planet1->[0] eq \"Mercury\") {\n  \
    \      if ($planet2->[0] eq \"Earth\") {\n            push @result, $planet1,\
    \ $planet2;\n        }\n        elsif ($planet2->[0] eq \"Venus\") {\n       \
    \     push @result, $planet1, $planet2;\n        }\n        elsif ($planet2->[0]\
    \ eq \"Mars\") {\n            push @result, $planet1, $planet2;\n        }\n \
    \       elsif ($planet2->[0] eq \"Jupiter\") {\n            push @result, $planet1,\
    \ $planet2;\n        }\n        elsif ($planet2->[0] eq \"Saturn\") {\n      \
    \      push @result, $planet1, $planet2;\n        }\n        elsif ($planet2->[0]\
    \ eq \"Uranus\") {\n            push @result, $planet1, $planet2;\n        }\n\
    \        elsif ($planet2->[0] eq \"Neptune\") {\n            push @result, $planet1,\
    \ $planet2;\n        }\n    }\n    elsif ($planet1->[0] eq \"Venus\") {\n    \
    \    if ($planet2->[0] eq \"Earth\") {\n            push @result, $planet1, $",
  "    my ($x, $y) = planet_loc($planet1, $planet2);\n    return sort {\n        $x\
    \ - $y->[0] cmp\n               $y - $x->[0]\n    } map {\n        planet_loc($_,\
    \ $planet2)\n    } @pl;\n}", "    my($planets1,$planets2)= grep(/^(.*?)(?:$|$)/,@planet);\n\
    \    my @planets = ();\n    foreach my $p1(@planets1) {\n        foreach my $p2(@planets2)\
    \ {\n            push (@planets, $p1 if $p1 ne $p2 && ($p1 eq $p2 || $p2 eq $p1\
    \ || $p1 eq $p2 || $p2 eq $p1)  && distance($p1,$p2) <= 500;\n        }\n    }\n\
    \    my @planets = sort {@bf <=>} @planets;\n    my @out = ();\n    foreach my\
    \ $planet (@planets) {\n        push @out, $planet;\n    }\n    return @out;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't return the output as OP wanted it\
    \ to.\n<|/ c |>\n<| c |>\nIt does work! The only thing that it misses is that\
    \ if the planet names only differ by one letter (for example `Jupiter` and `Jup`),\
    \ it should return `Jup` in the final output. \nAlso it only returns planets within\
    \ a radius of 500m, so if there are two planets that have a distance less than\
    \ 500m, but one that is 500m and the other one below 500m, it should return both.\
    \ \nAnd it only returns planets whose orbits happen to overlap with each other,\
    \ and not those which happen to overlap with each other's orbits themselves.\n\
    <|/ c |>\n<| c |>\nI forgot to add the distance calculation! Edited my answer,\
    \ and it now returns planets whose orbits happen to overlap with each other, and\
    \ also returns planets whose orbits happen to overlap with each other's orbits\
    \ themselves.\n<|/ c |>\n<| c |>\nSorry to bother you but I am still not getting\
    \ the right output. What I am doing is this: I get the planets whose orbits are\
    \ within a range of 500m (this part works). Now, I check if there are planets\
    \ in common (this part works). If there are, I get the closest planets (this part\
    \ does not work) and then I check if the planets overlap to each other (this part\
    \ does not work and I can't figure out why).\n<|/ c |>\n<| c |>\nI have edited\
    \ my answer according to your new requirements. I've put a description of each\
    \ step of the algorithm. Hope it helps.\n<|/", "    my @planets;\n    if ($planet1\
    \ eq \"Mercury\" or $planet1 eq \"Venus\" or \n        $planet1 eq \"Earth\" or\
    \ $planet1 eq \"Mars\" or \n        $planet1 eq \"Jupiter\" or $planet1 eq \"\
    Saturn\" or \n        $planet1 eq \"Uranus\" or $planet1 eq \"Neptune\" or \n\
    \        $planet2 eq \"Mercury\" or $planet2 eq \"Venus\" or \n        $planet2\
    \ eq \"Earth\" or $planet2 eq \"Mars\" or \n        $planet2 eq \"Jupiter\" or\
    \ $planet2 eq \"Saturn\" or \n        $planet2 eq \"Uranus\" or $planet2 eq \"\
    Neptune\"){\n        push(@planets, $planet1);\n        push(@planets, $planet2);\n\
    \    }\n    else {\n        push(@planets, $planet1);\n        push(@planets,\
    \ $planet2);\n    }\n    return @planets;\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks for the help. But I didn't really understand why you did the comparison\
    \ inside the if statement at the start and then again inside the for loop. Can\
    \ you explain that? :)\n<|/ c |>\n<| c |>\nAlso can you tell me why the planet\
    \ name should only be checked inside the if statement and not in the for loop?\
    \ Thanks\n<|/ c |>\n<| c |>\nBecause I thought that the `if` statement would give\
    \ me the results for all the planets between the two planets. However that was\
    \ not the case. Thanks for the help.\n<|/ c |>\n<| c |>\nOkay, so I used the `if`\
    \ statement to check if each of the planets are in the correct planet list, then\
    \ I used the `for` statement to go through the planets one by one and compare\
    \ it to the other planets in the list. Now that I have the planets I want to compare\
    \ how would I compare the planets?\n<|/ c |>\n<| c |>\nThanks. I understand it\
    \ now.\n<|/ c |>\n<| a dscore=0 |>\nFirst of all, you forgot to put curly braces\
    \ around your if statement and your array assignment. Second, you need a nested\
    \ loop to go through all the planets and then compare them to the two planets.\
    \ I added a third planet to show you the ordering you wanted.", "    if ($planet1\
    \ eq $planet2) {\n        return ();\n    }\n    my @orbits = ();\n    foreach\
    \ my $planet ($planet1, $planet2) {\n        foreach my $o (@orbits) {\n     \
    \       my $d = distance($o, $planet);\n            if ($d < 1) {\n          \
    \      push (@orbits, $o);\n            }\n        }\n    }\n    foreach my $o\
    \ (@orbits) {\n        if ($o eq $planet1) {\n            push (@orbits, $planet2);\n\
    \        }\n        elsif ($o eq $planet2) {\n            push (@orbits, $planet1);\n\
    \        }\n    }\n    my @sorted = sort(\"@orbits\");\n    my @reverse = reverse(@sorted);\n\
    \    return @reverse;\n}\n</code>\n<|/ a |>\n<| a |>\nHere is a solution using\
    \ the same ideas as Ralph's answer, but in Perl:\n<code>", "    my @result;\n\
    \    if ($planet1 eq \"Earth\") {\n        if ($planet2 eq \"Mars\") {\n     \
    \       if ($planet1 eq \"Venus\") {\n                if ($planet2 eq \"Jupiter\"\
    ) {\n                    @result = (\"Saturn\", \"Uranus\");\n               \
    \ } elsif ($planet2 eq \"Saturn\") {\n                    @result = (\"Uranus\"\
    , \"Neptune\");\n                } elsif ($planet2 eq \"Uranus\") {\n        \
    \            @result = (\"Neptune\", \"Mars\");\n                } elsif ($planet2\
    \ eq \"Neptune\") {\n                    @result = (\"Mars\", \"Jupiter\");\n\
    \                }\n            } elsif ($planet1 eq \"Mercury\") {\n        \
    \        if ($planet2 eq \"Saturn\") {\n                    @result = (\"Uranus\"\
    , \"Neptune\");\n                } elsif ($planet2 eq \"Uranus\") {\n        \
    \            @result = (\"Neptune\", \"Mars\");\n                } elsif ($planet2\
    \ eq \"Neptune\") {\n                    @result = (\"Mars\", \"Jupiter\");\n\
    \                }\n            } elsif ($planet1 eq \"Jupiter\") {\n        \
    \        if ($planet2 eq \"Saturn\") {\n                    @result = (\"Uranus\"\
    , \"Neptune\");\n                } elsif ($planet2 eq \"Uranus\") {\n        \
    \            @result = (\"Neptune\", \"Mars\");\n                } elsif ($planet2\
    \ eq \"Neptune\") {\n                    @result = (\"Mars\", \"Jupiter\");\n\
    \                }\n            } elsif ($planet1 eq \"Saturn\") {\n         \
    \       if ($planet2 eq \"Uranus\") {\n                    @result = (\"Neptune\"\
    , \"Mars\");\n                } elsif ($planet2 eq \"Neptune\") {\n          \
    \          @result = (\"Mars\", \"Jupiter\");\n                }\n           \
    \ } elsif ($planet1 eq \"Uranus\") {\n                if ($planet2 eq \"Neptune\"\
    ) {\n                    @result = (\"Mars\", \"Jupiter\");\n                }\n\
    \            }\n        } elsif ($planet2 eq \"Mars\") {\n            if ($planet1\
    \ eq \"Earth\") {\n                if ($planet2 eq \"Jupiter\") {\n          \
    \          @result = (\"Saturn\", \"Uranus\");\n                } elsif ($", " \
    \   my($planet1, $planet2, @planets);\n    foreach $planet1 (@planets1) {\n  \
    \      foreach $planet2 (@planets2) {\n            if ($planet2 eq $planet1) {\n\
    \                push @planets, $planet2;\n            } else {\n            \
    \    $planet1 eq $planet2 and do {\n                    push @planets, $planet2;\n\
    \                    push @planets, $planet1;\n                }\n           \
    \ }\n        }\n    }\n    @planets = sort { abs( sqrt( 1 - ( $a ** 2 ) / $b **\
    \ 2 ) ) };\n    return @planets;\n}", "    $planet1 eq 'Jupiter' || $planet1 eq\
    \ 'Saturn' || \n        $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n  \
    \      $planet1 eq 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth'\
    \ || $planet1 eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn'\
    \ || \n        $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n        $planet1\
    \ eq 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || \n \
    \       $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n        $planet1 eq\
    \ 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || \n \
    \       $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n        $planet1 eq\
    \ 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || \n \
    \       $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n        $planet1 eq\
    \ 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || \n \
    \       $planet1 eq 'Uranus' || $planet1 eq 'Neptune' || \n        $planet1 eq\
    \ 'Mercury' || $planet1 eq 'Venus' || \n        $planet1 eq 'Earth' || $planet1\
    \ eq 'Mars' || \n        $planet1 eq 'Jupiter' || $planet1 eq 'Saturn' || \n \
    \       $planet1 eq 'Uranus' || $plan", "    my @planets;\n    \n    # Your code\
    \ here\n    foreach my $planet1 (@planets) {\n        foreach my $planet2 (@planets)\
    \ {\n            next unless($planet1 eq $planet2);\n            if( (($planet1\
    \ eq \"Jupiter\" and $planet2 eq \"Neptune\") or \n                ($planet1 eq\
    \ \"Earth\" and $planet2 eq \"Mercury\") or \n                ($planet1 eq \"\
    Mercury\" and $planet2 eq \"Uranus\") or \n                ($planet1 eq \"Saturn\"\
    \ and $planet2 eq \"Neptune\") or \n                ($planet1 eq \"Uranus\" and\
    \ $planet2 eq \"Mercury\") or \n                ($planet1 eq \"Neptune\" and $planet2\
    \ eq \"Jupiter\")) ) {\n                push(@planets, $planet2);\n          \
    \  }\n        }\n    }\n    \n    foreach my $planet (@planets) {\n        unless(($planet\
    \ eq \"Mercury\")) {\n            push(@planets, $planet);\n        }\n    }\n\
    \    \n    return @planets;\n}\n</cell>\n<cell>", "    \n    my @planets = ();\n\
    \    if (! $planet1 =~ /^[A-Z][a-z]*$/ or ! $planet2 =~ /^[A-Z][a-z]*$/) {\n \
    \       return \"The planet names you enter for 'planet1' and 'planet2' must be\
    \ two capital letters followed by zero or more lowercase letters.\";\n    }\n\
    \    $planet1 = ucfirst($planet1);\n    $planet2 = ucfirst($planet2);\n    if\
    \ ($planet1 eq $planet2) {\n        push (@planets, $planet1);\n    }\n    elsif\
    \ ($planet1 eq \"Mercury\" and $planet2 eq \"Venus\") {\n        push (@planets,\
    \ $planet1);\n        push (@planets, $planet2);\n    }\n    elsif ($planet1 eq\
    \ \"Venus\" and $planet2 eq \"Earth\") {\n        push (@planets, $planet1);\n\
    \        push (@planets, $planet2);\n    }\n    elsif ($planet1 eq \"Mars\" and\
    \ $planet2 eq \"Jupiter\") {\n        push (@planets, $planet1);\n        push\
    \ (@planets, $planet2);\n    }\n    elsif ($planet1 eq \"Jupiter\" and $planet2\
    \ eq \"Saturn\") {\n        push (@planets, $planet1);\n        push (@planets,\
    \ $planet2);\n    }\n    elsif ($planet1 eq \"Saturn\" and $planet2 eq \"Uranus\"\
    ) {\n        push (@planets, $planet1);\n        push (@planets, $planet2);\n\
    \    }\n    elsif ($planet1 eq \"Uranus\" and $planet2 eq \"Neptune\") {\n   \
    \     push (@planets, $planet1);\n        push (@planets, $planet2);\n    }\n\
    \    elsif ($planet1 eq \"Neptune\" and $planet2 eq \"Mars\") {\n        push\
    \ (@planets, $planet1);\n        push (@planets, $planet2);\n    }\n    else {\n\
    \        return \"The planet names you enter for 'planet1' and 'planet2' must\
    \ be two capital letters followed by zero or more lowercase letters.\";\n    }\n\
    \    if (@planet", '    my $sun_coord = calculate_sun_coord();', "    $planet1\
    \ = lc($planet1);\n    $planet2 = lc($planet2);\n    my ($planet_a, $planet_b)\
    \ = (0, 0);\n    my @result;\n    my @planets = (\n    \"Mercury\" => \"Venus\"\
    ,\n    \"Venus\" => \"Earth\",\n    \"Earth\" => \"Mars\",\n    \"Mars\" => \"\
    Jupiter\",\n    \"Jupiter\" => \"Saturn\",\n    \"Saturn\" => \"Uranus\",\n  \
    \  \"Uranus\" => \"Neptune\",\n    \"Neptune\" => \"Mercury\");\n    for (my $i\
    \ = 0; $i <  scalar(@planets); ++$i) {\n        next if $planets[$i] eq $planet1;\n\
    \        next if $planets[$i] eq $planet2;\n        my ($planet_a, $planet_b)\
    \ = (0, 0);\n        my $planet = @planets[$i];\n        while ($planet_a < $planet_b)\
    \ {\n            my $a = $planets[$planet_a];\n            my $b = $planets[$planet_b];\n\
    \            next if $a eq $b;\n            my $dist = ($a - $b) . \" \";\n  \
    \          if ($dist == \"\") {\n                $dist = \"1\";\n            }\n\
    \            ++$planet_a;\n            ++$planet_b;\n        }\n        push(@result,\
    \ $planets[$i]);\n    }\n    foreach my $i (@result) {\n        $i = lc($i);\n\
    \    }\n    @result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy are you declaring\
    \ $planet_a, $planet_b, $planet and $a as scalars? It doesn't seem like they're\
    \ necessary at all.\n<|/ c |>\n<| c |>\n, those are declared as scalars because\
    \ they're being used to manipulate an array index.  `$planet_a` and `$planet_b`\
    \ keep track of the current array index.\n<|/ c |>\n<| a |>\nI made some minor\
    \ changes to the script and it's working for me. \n<code>", "    my(@planets);\n\
    \    if($planet1 eq 'Mercury') {\n        $planets[0] = \"Venus\";\n        $planets[1]\
    \ = \"Earth\";\n        $planets[2] = \"Mars\";\n        $planets[3] = \"Jupiter\"\
    ;\n        $planets[4] = \"Saturn\";\n        $planets[5] = \"Uranus\";\n    \
    \    $planets[6] = \"Neptune\";\n    }\n    elsif($planet1 eq 'Venus') {\n   \
    \     $planets[0] = \"Earth\";\n        $planets[1] = \"Mars\";\n        $planets[2]\
    \ = \"Jupiter\";\n        $planets[3] = \"Saturn\";\n        $planets[4] = \"\
    Uranus\";\n        $planets[5] = \"Neptune\";\n        $planets[6] = \"Mercury\"\
    ;\n    }\n    elsif($planet1 eq 'Earth') {\n        $planets[0] = \"Mars\";\n\
    \        $planets[1] = \"Jupiter\";\n        $planets[2] = \"Saturn\";\n     \
    \   $planets[3] = \"Uranus\";\n        $planets[4] = \"Neptune\";\n        $planets[5]\
    \ = \"Mercury\";\n        $planets[6] = \"Venus\";\n    }\n    elsif($planet1\
    \ eq 'Mars') {\n        $planets[0] = \"Jupiter\";\n        $planets[1] = \"Saturn\"\
    ;\n        $planets[2] = \"Uranus\";\n        $planets[3] = \"Neptune\";\n   \
    \     $planets[4] = \"Mercury\";\n        $planets[5] = \"Venus\";\n        $planets[6]\
    \ = \"Earth\";\n    }\n    elsif($planet1 eq 'Jupiter') {\n        $planets[0]\
    \ = \"Saturn\";\n        $planets[1] = \"Uranus\";\n        $planets[2] = \"Neptune\"\
    ;\n        $planets[3] = \"Mercury\";\n        $planets[4] = \"Venus\";\n    \
    \    $planets[5] = \"Earth\";\n        $planets[6] = \"Mars\";\n    }\n    elsif($planet1\
    \ eq 'Saturn') {\n        $planets[0] = \"Uranus\";\n        $planets[1] = \"\
    Neptune\";\n        $planets[2] = \"Mercury\";\n        $planets[3] = \"Venus\"\
    ;\n        $planets[4] = \"Earth\";\n        $planets[5] = \"Mars\";\n       \
    \ $planets[6] = \"Jupiter", "    if ($planet1 eq $planet2){\n\treturn ([]);\n\
    \    }\n    my @planets = ();\n    push(@planets, $planet1) unless(@planets ==\
    \ 0 &&\n        $planet1 =~ /^$planet2$/);\n    push(@planets, $planet2) unless(@planets\
    \ == 0 &&\n        $planet2 =~ /^$planet1$/);\n    my $sol = SolarSystem::find_planet(\"\
    Sun\");\n    my $sol2 = SolarSystem::find_planet(\"Sun\");\n    my $diff = SolarSystem::planet_distance($sol,\
    \ $sol2);\n    for (@planets){\n\t$diff += SolarSystem::planet_distance($_, $sol2);\n\
    \    }\n    @planets = sort {\n        my ($a2, $b2) = SolarSystem::planet_distance($a,\
    \ $sol2);\n        my ($a1, $b1) = SolarSystem::planet_distance($a, $sol);\n \
    \       $a1 <=> $b1 <=> $a2 <=> $b2\n    } @planets;\n    return @planets;\n}",
  "    $planet1 = lc($planet1);\n    $planet2 = lc($planet2);\n    my @planets = ();\n\
    \    if ($planet2 eq \"sun\") {\n        return \"Sun\";\n    }\n    push @planets,\
    \ $planet1 unless (@planets > 0);\n    if ($planet2 eq \"sun\") {\n        return\
    \ @planets;\n    }\n    push @planets, $planet2 unless (@planets > 0);\n    return\
    \ sort {\n        my($sun) = $_ eq \"sun\" ? 1 : 0;\n        my $dist1 = get_distance($planet1,\
    \ $sun);\n        my $dist2 = get_distance($planet2, $sun);\n        if ($dist1\
    \ < $dist2) {\n            return $dist1;\n        } else {\n            return\
    \ $dist2;\n        }\n    };\n}\n</code>\n<|/ a tags=perl,algorithm dscore=0 |>\n\
    <| c |>\nYour program fails for me at `bf(\"mercury\", \"sun\")` (should be empty),\
    \ at `bf(\"mercury\", \"venus\")` (should return the string \"venus\"), at `bf(\"\
    venus\", \"sun\")` (should return the string \"sun\").\n<|/ c |>\n<| c |>\nOh,\
    \ my bad, your solution is correct, but I got it wrong in the last code block,\
    \ so I edited my answer\n<|/ c |>\n<| c |>\nYour program fails for me at `bf(\"\
    mercury\", \"sun\")` (should be empty), at `bf(\"mercury\", \"venus\")` (should\
    \ return the string \"venus\"), at `bf(\"venus\", \"sun\")` (should return the\
    \ string \"sun\").\n<|/ c |>\n<| c |>\nSorry, my bad, I've made a mistake in the\
    \ last code block. I've corrected my answer now\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nuse strict;\nuse warnings;\nuse Carp;", "    $planet1 = ucfirst($planet1);\n\
    \    $planet2 = ucfirst($planet2);\n    if ($planet1 eq $planet2) {\n        push(@result,\
    \ $planet1);\n    } elsif ($planet1 eq \"Mercury\" && $planet2 eq \"Earth\") {\n\
    \        push(@result, $planet2);\n    } elsif ($planet1 eq \"Earth\" && $planet2\
    \ eq \"Mars\") {\n        push(@result, $planet2);\n    } elsif ($planet1 eq \"\
    Mars\" && $planet2 eq \"Jupiter\") {\n        push(@result, $planet2);\n    }\
    \ elsif ($planet1 eq \"Jupiter\" && $planet2 eq \"Saturn\") {\n        push(@result,\
    \ $planet2);\n    } elsif ($planet1 eq \"Saturn\" && $planet2 eq \"Uranus\") {\n\
    \        push(@result, $planet2);\n    } elsif ($planet1 eq \"Uranus\" && $planet2\
    \ eq \"Neptune\") {\n        push(@result, $planet2);\n    } elsif ($planet1 eq\
    \ \"Neptune\" && $planet2 eq \"Mercury\") {\n        push(@result, $planet2);\n\
    \    } elsif ($planet1 eq \"Mercury\" && $planet2 eq \"Venus\") {\n        push(@result,\
    \ $planet2);\n    } elsif ($planet1 eq \"Venus\" && $planet2 eq \"Earth\") {\n\
    \        push(@result, $planet2);\n    } elsif ($planet1 eq \"Earth\" && $planet2\
    \ eq \"Mars\") {\n        push(@result, $planet2);\n    } elsif ($planet1 eq \"\
    Mars\" && $planet2 eq \"Jupiter\") {\n        push(@result, $planet2);\n    }\
    \ elsif ($planet1 eq \"Jupiter\" && $planet2 eq \"Saturn\") {\n        push(@result,\
    \ $planet2);\n    } elsif ($planet1 eq \"Saturn\" && $planet2 eq \"Uranus\") {\n\
    \        push(@result, $planet2);\n    } elsif ($planet1 eq \"Uranus\" && $planet2\
    \ eq \"Neptune\") {\n        push(@result, $planet2);\n    } else {\n        push(@result,\
    \ \"\");\n    }", "    if ($planet1 eq $planet2) {\n        return @{$planet1};\n\
    \    }\n    my (@planets);\n    push(@planets, $planet1);\n    if ($planet2 =~\
    \ /[SMURT]/) {\n        push(@planets, $planet2);\n    }\n    foreach my $planet\
    \ (@planets) {\n        foreach my $planet2 (@planets) {\n            if ($planet2\
    \ ne $planet) {\n                if (\n                    (@{$planet->orbit_between($planet2)})\
    \ > 0 ||\n                    (@{$planet2->orbit_between($planet)}) > 0\n    \
    \            ) {\n                    push(@planets, $planet2);\n            \
    \        last;\n                }\n            }\n        }\n    }\n    push(@planets,\
    \ $planet2);\n    return @planets;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ the comment! My answer was based on what I understood from the problem description\
    \ in the OP so I used that to write my own code.\n<|/ c |>\n<| c |>\nGreat answer.\
    \ Nice effort.\n<|/ c |>\n<| c |>\nI really like this one. I like the way you\
    \ constructed the planet objects in the first place, because it helps me understand\
    \ how I can manipulate those objects to get exactly what I want. \nBut my assignment\
    \ doesn't require that I use Perl's syntax to solve the problem, but rather that\
    \ I (as a class) create functions to help me. I'm just trying to figure out what\
    \ the functions are called in order to implement them. ", "    my $planet1_orbit\
    \ = orbit_planet($planet1);\n    my $planet2_orbit = orbit_planet($planet2);\n\
    \    my @planet_orbits = ();\n    my $count = 0;\n    foreach my $planet1_index\
    \ (0..$#{$planet1_orbit}) {\n        foreach my $planet2_index (0..$#{$planet2_orbit})\
    \ {\n            if($planet1_orbit->[$planet1_index] != $planet2_orbit->[$planet2_index])\
    \ {\n                my $distance_planet1 = distance(time($planet1_orbit->[$planet1_index]),\
    \ time($planet2_orbit->[$planet2_index]));\n                my $distance_planet2\
    \ = distance(time($planet2_orbit->[$planet2_index]), time($planet1_orbit->[$planet1_index]));\n\
    \                if($distance_planet1 < $distance_planet2) {\n               \
    \     push(@planet_orbits, $planet1_orbit->[$planet1_index]);\n              \
    \      $count++;\n                } elsif($distance_planet1 > $distance_planet2)\
    \ {\n                    push(@planet_orbits, $planet2_orbit->[$planet2_index]);\n\
    \                    $count++;\n                }\n            }\n        }\n\
    \    }\n    my @planet_orbits_sorted = sort {$a <=> $b} @planet_orbits;\n    return\
    \ @planet_orbits_sorted;\n}", "    my @planets = ();\n    if ($planet1 =~ /^\\\
    Q$planet2\\E$/) {\n        push(@planets, $planet1);\n        push(@planets, $planet2);\n\
    \    } elsif ($planet1 =~ /^\\Q$planet1\\E$/) {\n        push(@planets, $planet2);\n\
    \        push(@planets, $planet1);\n    } else {\n        push(@planets, $planet1);\n\
    \        push(@planets, $planet2);\n    }\n    my ($v1, $v2) = planets(\"Venus\"\
    , \"Earth\");\n    my ($w1, $w2) = planets(\"Earth\", \"Mars\");\n    my ($x1,\
    \ $x2) = planets(\"Jupiter\", \"Saturn\");\n    my ($y1, $y2) = planets(\"Mars\"\
    , \"Uranus\");\n    my ($z1, $z2) = planets(\"Saturn\", \"Uranus\");\n    my ($w3,\
    \ $w4) = planets(\"Uranus\", \"Neptune\");\n    my ($y3, $y4) = planets(\"Neptune\"\
    , \"Venus\");\n    my @sorted = ();\n    if ($v1 > $v2) {\n        if ($w1 > $w2)\
    \ {\n            if ($x1 > $x2) {\n                if ($y1 > $y2) {\n        \
    \            push(@sorted, $y1);\n                    push(@sorted, $y2);\n  \
    \              } elsif ($y1 > $y3) {\n                    push(@sorted, $y1);\n\
    \                    push(@sorted, $y3);\n                } elsif ($y1 > $y4)\
    \ {\n                    push(@sorted, $y1);\n                    push(@sorted,\
    \ $y4);\n                } elsif ($y3 > $y4) {\n                    push(@sorted,\
    \ $y3);\n                    push(@sorted, $y4);\n                }\n        \
    \    } else {\n                if ($z1 > $z2) {\n                    push(@sorted,\
    \ $z1);\n                    push(@sorted, $z2);\n                } else {\n \
    \                   push(@sorted, $z1);\n                    push(@sorted, $z2);\n\
    \                }\n            }\n        } else {\n            if ($w3 > $w4)\
    \ {\n                if ($x1 > $x2) {\n                    push(@sorted, $x1);\n\
    \                    push(@sorted, $x2);\n                } else {\n         \
    \           push(@sorted, $x1);\n                    push(@sorted, $x2);\n   \
    \             }\n", "    $planet1 = lc($planet1);\n    $planet2 = lc($planet2);",
  "    my(@planets_between) = ();\n    my($planet1_orb, $planet2_orb, $dist_to_sun);\n\
    \    @planets_between = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);",
  "    my(@orbits1) = @{$planet1}->orbits();\n    my(@orbits2) = @{$planet2}->orbits();\n\
    \    foreach my $orbit1 (@orbits1) {\n        foreach my $orbit2 (@orbits2) {\n\
    \            my $distance = solarSystemDistance($orbit1, $orbit2);\n         \
    \   if($distance < $tolerance) {\n                push, [$orbit1, $orbit2];\n\
    \            }\n        }\n    }\n    return sort {\n                my $orbit1Distance\
    \ = $a->[1]->[0]->[0]->[0]->[0] \n                        + $a->[1]->[0]->[0]->[1]->[0]->[0]->[1]\n\
    \                cmp\n                my $orbit2Distance = $b->[1]->[0]->[0]->[0]->[0]\
    \ \n                        + $b->[1]->[0]->[0]->[1]->[0]->[0]->[1]\n        \
    \    } @orbits1;\n}", "    if(!isPlanet($planet1)) {\n\treturn [];\n    } elsif(!isPlanet($planet2))\
    \ {\n\treturn [];\n    }\n    my $planet1_orbits = grep(\"$planet1\", @planet_orbits);\n\
    \    my $planet2_orbits = grep(\"$planet2\", @planet_orbits);\n    my @orbits\
    \ = ();\n    foreach my $planet1_orbit (@$planet1_orbits) {\n\tforeach my $planet2_orbit\
    \ (@$planet2_orbits) {\n\t    my $distance = $planet1_orbit->distance($planet2_orbit);\n\
    \t    # Skip if the planets are too far away.\n\t    if($distance > 2.0) {\n\t\
    \tnext;\n\t    }\n\t    push @orbits, $planet1_orbit;\n\t}\n    }\n    push(@orbits,\
    \ @$planet1_orbits);\n    push(@orbits, @$planet2_orbits);\n    sort(@orbits);\n\
    \    return @orbits;\n}", "    my(@planets);\n    # Your code goes here. #################################################\n\
    \    my @arr;\n    # Your code goes here. #################################################\n\
    \    my @hash;\n    # Your code goes here. #################################################\n\
    \    my $temp;\n    # Your code goes here. #################################################\n\
    \    foreach my $planet (@planets){\n        push @temp, $planet;\n    }\n   \
    \ # Your code goes here. #################################################\n \
    \   return @temp;\n}", "    $planet1 = lcamelize($planet1);\n    $planet2 = lcamelize($planet2);\n\
    \    my @orbits;\n    for(my $planet = @planetList) {\n        # planet name consists\
    \ of letter followed by 2 digits, e.g. Jupiter \n        # or Saturn\n       \
    \ if($planet =~ /^($planet1)\\s*(\\d+)$/) {\n            my @orbitsOfPlanet =\
    \ $planetList{$planet};\n            if($orbitsOfPlanet && $orbitsOfPlanet[0]\
    \ != $planet1) {\n                # if planet1 is Mercury planet and planet is\
    \ other planet\n                if($orbitsOfPlanet[0] != $planet2) {\n       \
    \             push(@orbits, $planet);\n                }\n                # if\
    \ planet1 is Earth planet and planet is other planet\n                elsif($orbitsOfPlanet[0]\
    \ != $planet1) {\n                    push(@orbits, $planet);\n              \
    \  }\n            }\n            # planet1 and planet2 are planet\n          \
    \  else {\n                push(@orbits, $planet);\n            }\n        } \n\
    \        # planet name consists of letter followed by letter, e.g. Earth or Mercury\n\
    \        elsif($planet =~ /^($planet1)\\s*($planet2)$/) {\n            my @orbitsOfPlanet\
    \ = $planetList{$planet};\n            if($orbitsOfPlanet && $orbitsOfPlanet[0]\
    \ != $planet1) {\n                # if planet1 is Mercury planet and planet is\
    \ other planet\n                if($orbitsOfPlanet[0] != $planet2) {\n       \
    \             push(@orbits, $planet);\n                }\n                # if\
    \ planet1 is Earth planet and planet is other planet\n                elsif($orbitsOfPlanet[0]\
    \ != $planet1) {\n                    push(@orbits, $planet);\n              \
    \  }\n            }\n            # planet1 and planet2 are planet\n          \
    \  else {\n                push(@orbits, $planet);\n            }\n        } \n\
    \        # planet name consists of only digits, e.g. 1 or 10\n        elsif($planet\
    \ =~ /^(\\d+)\\s*(\\d+)$/) {\n            my @orbitsOfPlanet = $planetList{$planet};\n\
    \            if($orbitsOfPlanet && $orbitsOfPlanet[0] != $planet1) {\n       \
    \         # if planet1 is Mercury planet and planet is other planet\n        \
    \        if($", "    my($planet1_orb, $planet2_orb) = $planet1 =~ /^([A-Za-z]+)(.*)$/;\n\
    \    $planet1_orb = lc ($planet1_orb); # make sure it's lower case\n    $planet2_orb\
    \ = lc ($planet2_orb); # make sure it's lower case\n    \n    my @planets2;\n\
    \    \n    foreach my $planet2_tmp (@planets_sorted) {\n        my($planet2_orb_2,\
    \ $planet2_orb_1) = $planet2 =~ /^([A-Za-z]+)(.*)$/;\n        $planet2_orb_2 =\
    \ lc ($planet2_orb_2); # make sure it's lower case\n        $planet2_orb_1 = lc\
    \ ($planet2_orb_1); # make sure it's lower case\n        \n        if ($planet1_orb\
    \ eq $planet2_orb_1) {\n            if ($planet2_orb eq $planet2_orb_2) {\n  \
    \              push(@planets2, $planet2);\n            }\n        }\n        elsif\
    \ ($planet1_orb eq $planet2_orb_2) {\n            push(@planets2, $planet2);\n\
    \        }\n    }\n    \n    if (scalar(@planets2) <= 0) {\n        \n       \
    \ @planets2 = ();\n    }\n    \n    @planets2;\n}\n</code>\n<|/ q dscore=0 |>\n\
    <| c |>\nI see you have attempted to use an answer you received from your previous\
    \ question, which didn't work. The reason for that is that you did not include\
    \ that code in the question, and you did not explain clearly what the problem\
    \ was with it.\n<|/ c |>\n<| c |>\nYou would get better performance if you used\
    \ a hash to store the orbits per planet and use a sorted array for the output\
    \ instead of linear search.\n<|/ c |>\n<| a |>\nI took your code and added the\
    \ required logic - essentially you were checking the first planet against the\
    \ entire sorted array, and if found that means you were done.\n<code>\nuse strict;\n\
    use warnings;", "    my @planets = ();\n    foreach my $planet (@planets_to_orbit_in)\
    \ {\n        my $orbit_in = $planets_to_orbit_in->{$planet};\n        foreach\
    \ my $planet2 (@planets_to_orbit_in) {\n            my $orbit_out = $planets_to_orbit_in->{$planet2};\n\
    \            my $distance = distance($planet, $planet2);\n            if ($distance\
    \ < $distance_between) {\n                push @planets, $planet;\n          \
    \  }\n        }\n    }\n    return @planets;\n}", "    my @arr;\n    \n    for\
    \ (@planets) {\n        if ($_ != $planet1 && $_ != $planet2) {\n            push,\
    \ $_;\n        } else {\n            last;\n        }\n    }\n    \n    for (@planets)\
    \ {\n        if ($_ != $planet1 && $_ != $planet2) {\n            my $dist = distance($_,\
    \ $planet1);\n            my $dist2 = distance($_, $planet2);\n            if\
    \ ($dist < $dist2) {\n                push, $_;\n            }\n        }\n  \
    \  }\n    \n    @arr = sort {distance($a, $b) <=> distance($a, $b)};\n    \n \
    \   return @arr;\n}", "    my ($orbits1, $orbits2) = orbit_planet($planet1, $planet2);\n\
    \    my $planet1orbit = $orbits1[$i];\n    my $planet2orbit = $orbits2[$i];\n\
    \    my $difference = ($planet2orbit - $planet1orbit) / 2.0;\n    $difference\
    \ += ($planet1orbit + $planet2orbit) / 2.0;\n    push @{$planets{$planet1}}, $planet1\
    \ if $planet1orbit > $planet2orbit;\n    push @{$planets{$planet2}}, $planet2\
    \ if $planet1orbit < $planet2orbit;\n    $planets{$planet1}[$i] = $difference;\n\
    \    undef $planets{$planet1}[$i] unless exists $planets{$planet2}[$i];\n    push\
    \ @{$planets{$planet1}}, $planet2 if $planet1orbit > $planet2orbit;\n    push\
    \ @{$planets{$planet2}}, $planet1 if $planet1orbit < $planet2orbit;\n    $planets{$planet2}[$i]\
    \ = $difference;\n    undef $planets{$planet2}[$i] unless exists $planets{$planet1}[$i];\n\
    \    foreach my $planet (keys %planets) {\n        foreach my $index (@{$planets{$planet}})\
    \ {\n            if ($index > 0) {\n                my $index1 = $index - 1;\n\
    \                my $index2 = $index + 1;\n                my $temp = $planets{$planet}[$index];\n\
    \                $planets{$planet}[$index] = $planets{$planet}[$index2];\n   \
    \             $planets{$planet}[$index2] = $temp;\n            }\n        }\n\
    \    }\n    foreach my $planet (keys %planets) {\n        foreach my $index (@{$planets{$planet}})\
    \ {\n            if ($index > 0) {\n                my $index1 = $index - 1;\n\
    \                my $index2 = $index + 1;\n                my $temp = $planets{$planet}[$index];\n\
    \                $planets{$planet}[$index] = $planets{$planet}[$index1];\n   \
    \             $planets{$planet}[$index1] = $temp;\n            }\n        }",
  "    if ($planet1 eq $planet2) {\n        return @{$planet1};\n    }\n    my @planets\
    \ = ();\n    foreach my $planet (@planet_names) {\n        my @distances = ();\n\
    \        foreach my $planet2 (@planet_names) {\n            my ($x1, $y1, $x2,\
    \ $y2) = planet_orbit($planet, $planet2);\n            push @distances, $y2 -\
    \ $y1;\n            push @distances, $x2 - $x1;\n        }\n        @distances\
    \ = sort {$a <=> $b} @distances;\n        my $max = $distances[0];\n        foreach\
    \ my $distance (@distances) {\n            if ($distance == $max) {\n        \
    \        push @planets, $planet;\n                last;\n            }\n     \
    \   }\n    }\n    return @planets;\n}", "    my $sol = Math::Solar();\n    my\
    \ = $sol->orbit($planet1, $planet2);\n    sort { $a->{dist}->[0] <=> $b->{dist}->[0]\
    \ };\n}", "    $planet1 =~ s/^\\s+//;\n    $planet2 =~ s/^\\s+//;\n    $planet1\
    \ =~ s/\\s+$//;\n    $planet2 =~ s/\\s+$//;\n    my(@planets);\n    my $planet_1\
    \ = $planet1;\n    my $planet_2 = $planet2;\n    push(@planets, $planet_1);\n\
    \    push(@planets, $planet_2);\n    foreach (@planets) {\n        my $planet\
    \ = $_;\n        foreach my $i (0..2) {\n            my $orbit_name = $planet\
    \ . ($i + 1);\n            my $orbit = Orbit::Orbit->new($planet, $i);\n     \
    \       my $orbit_2 = $orbit->orbit($planet);\n            push(@orbit_names,\
    \ $orbit_name);\n            if ($planet eq $planet_1 && $i eq 0) {\n        \
    \        push(@orbit_names, $orbit_2);\n            }\n            if ($planet\
    \ eq $planet_2 && $i eq 0) {\n                push(@orbit_names, $orbit_1);\n\
    \            }\n        }\n    }\n    @orbit_names = (sort { $a cmp $b } @orbit_names);\n\
    \    return @orbit_names;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for\
    \ your help. I tried to rewrite your code and I get an error: Bad planet name\
    \ at line 5 and line 7. Which line 5 and 7 are you referring to?\n<|/ c |>\n<|\
    \ c |>\n`my $planet_1 = $planet1` `my $planet_2 = $planet2` I believe this line\
    \ is what is causing the error. Thanks for your help btw!\n<|/ c |>\n<| c |>\n\
    : I believe that the `foreach` loop is causing the error. Do you know how I can\
    \ fix it? Thanks again!\n<|/ c |>\n<| c |>\n: I have updated my question with\
    \ my revised code, would you mind taking a look please? Thanks!\n<|/ c |>\n<|\
    \ c |>\n: I have updated my question with my revised code, would you mind taking\
    \ a look please? Thanks!\n<|/ c |>\n<| a tags=perl,arrays,multidimensional-array\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    return sort (grep {\n        my($dist)\
    \ = Math::sphericalangle($planet1 , $planet2);\n        return $dist < 45;\n \
    \   }, \"Earth\", \"Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\");\n}", "    my(@orbits);\n    if ($planet1 eq $planet2)\
    \ {\n        @orbits = ($planet1, $planet2);\n    } elsif ($planet1 eq \"Mercury\"\
    ) {\n        @orbits = (\"Mercury\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ,\n                    \"Uranus\", \"Neptune\");\n    } elsif ($planet1 eq \"\
    Venus\") {\n        @orbits = (\"Venus\", \"Mercury\", \"Earth\", \"Mars\", \"\
    Jupiter\",\n                    \"Saturn\", \"Uranus\", \"Neptune\");\n    } elsif\
    \ ($planet1 eq \"Earth\") {\n        @orbits = (\"Earth\", \"Mercury\", \"Mars\"\
    , \"Jupiter\",\n                    \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \  } elsif ($planet1 eq \"Mars\") {\n        @orbits = (\"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\",\n                    \"Neptune\");\n    } elsif ($planet1\
    \ eq \"Jupiter\") {\n        @orbits = (\"Jupiter\", \"Saturn\", \"Uranus\",\n\
    \                    \"Neptune\");\n    } elsif ($planet1 eq \"Saturn\") {\n \
    \       @orbits = (\"Saturn\", \"Uranus\",\n                    \"Neptune\");\n\
    \    } elsif ($planet1 eq \"Uranus\") {\n        @orbits = (\"Uranus\", \"Neptune\"\
    );\n    } elsif ($planet1 eq \"Neptune\") {\n        @orbits = (\"Neptune\");\n\
    \    } else {\n        return ();\n    }\n    @orbits = sort {\n        abs($a\
    \ -> $a->{distance_to_sun}) - abs($b -> $b->{distance_to_sun}) {\n           \
    \ $a -> {distance_to_sun}\n        } cmp $b -> {distance_to_sun};\n    };\n  \
    \  return @orbits;\n}", "    my(@orbits) = ();\n    my $planet1_orb = find_planet_orbit($planet1);\n\
    \    my $planet2_orb = find_planet_orbit($planet2);\n    if ($planet1_orb == $planet2_orb)\
    \ {\n        @orbits = (\"$planet1_orb\");\n    } else {\n        if ($planet1_orb\
    \ > $planet2_orb) {\n            @orbits = (\"$planet2_orb\", \"$planet1_orb\"\
    );\n        } else {\n            @orbits = (\"$planet1_orb\", \"$planet2_orb\"\
    );\n        }\n    }\n    @orbits = sort { $a <=> $b };\n    return @orbits;\n\
    }", "    my @result;\n    foreach my $name (@planet1, @planet2) {\n        foreach\
    \ my $orbit1 ($planet1, $planet2) {\n            foreach my $orbit2 ($planet1,\
    \ $planet2) {\n                my $dist = $planet1_orbit_distance($orbit1, $planet2);\n\
    \                if ($dist < 1) {\n                    push(@result, $name);\n\
    \                }\n            }\n        }\n    }\n    push(@result, $planet1)\
    \ if $planet1 == $planet2;\n    push(@result, $planet2) if $planet2 == $planet1;\n\
    \    return sort { $a <=> $b } @result;\n}", "    my @orbits;\n    foreach my\
    \ $planet (@planets) {\n        if ($planet eq $planet1 || $planet eq $planet2)\
    \ {\n            push(@orbits, $planet);\n        }\n    }\n    foreach my $planet\
    \ (@orbits) {\n        my @orbit = $planet->orbit($planet2);\n        push(@orbits,\
    \ $planet unless @orbit);\n        foreach my $orbit (@orbit) {\n            push(@orbits,\
    \ $orbit);\n        }\n    }\n    foreach my $planet (@orbits) {\n        my $dist\
    \ = distance($planet, $planet2);\n        push(@sorted, $planet) if $dist < $cutoff;\n\
    \    }\n    if (scalar @sorted == 0) {\n        push(@sorted, undef);\n    }\n\
    \    @sorted;\n}", "    # Write your code below this line\n    if($planet1 eq\
    \ $planet2) {\n        my @planets;\n        push @planets, $planet1;\n      \
    \  return @planets;\n    }\n    my @planets;\n    my @mercuryOrb = @{$planets[$planets.index($planet2)]};\n\
    \    my @venusOrb = @{$planets[$planets.index($planet1)]};\n    my @earthOrb =\
    \ @{$planets[$planets.index($planet1)]};\n    my @marsOrb = @{$planets[$planets.index($planet2)]};\n\
    \    my @jupiterOrb = @{$planets[$planets.index($planet2)]};\n    my @saturnOrb\
    \ = @{$planets[$planets.index($planet1)]};\n    my @uranusOrb = @{$planets[$planets.index($planet1)]};\n\
    \    my @neptuneOrb = @{$planets[$planets.index($planet2)]};\n    my @saturnOrb\
    \ = @{$planets[$planets.index($planet2)]};\n    my @uranusOrb = @{$planets[$planets.index($planet2)]};\n\
    \    my @neptuneOrb = @{$planets[$planets.index($planet2)]};\n    my @mercuryOrb\
    \ = @{$planets[$planets.index($planet2)]};\n    my @venusOrb = @{$planets[$planets.index($planet1)]};\n\
    \    my @earthOrb = @{$planets[$planets.index($planet2)]};\n    my @marsOrb =\
    \ @{$planets[$planets.index($planet2)]};\n    my @jupiterOrb = @{$planets[$planets.index($planet2)]};\n\
    \    my @saturnOrb = @{$planets[$planets.index($planet1)]};\n    my @uranusOrb\
    \ = @{$planets[$planets.index($planet1)]};\n    my @neptuneOrb = @{$planets[$planets.index($planet2)]};\n\
    \    my @saturnOrb = @{$planets[$planets.index($planet2)]};\n    my @uranusOrb\
    \ = @{$planets[", "    my @planets = ();\n    my $distance = (Math::PI)/2.0;\n\
    \    foreach my $planet (@planets) {\n        if ($planet eq $planet1) {\n   \
    \         $distance = ($planet1 + $planet2)/2.0;\n        }\n        if ($planet\
    \ eq $planet2) {\n            $distance = ($planet2 + $planet1)/2.0;\n       \
    \ }\n    }\n    if ($distance < 0) {\n        push (@planets, $planet1);\n   \
    \     push (@planets, $planet2);\n    } elsif ($distance > 0) {\n        push\
    \ (@planets, $planet2);\n        push (@planets, $planet1);\n    }\n    return\
    \ @planets;\n}", "    my($distance, $distance2);\n    my(@planets);\n    foreach\
    \ $planet (@planets) {\n        $distance2 = sqrt($distance*$distance + $distance*$distance2);\n\
    \        if (($planet eq $planet1) || ($planet eq $planet2)) {\n            if\
    \ ($distance >= $distance2) {\n                push(@planets, $planet);\n    \
    \        }\n        }\n    }\n    if (@planets == 0) {\n        return [];\n \
    \   }\n    foreach $planet (@planets) {\n        $distance = sqrt($distance*$distance\
    \ + $distance*$distance2);\n        if ($distance < $distance2) {\n          \
    \  push(@planets, $planet);\n        }\n    }\n    push(@planets, $planet1);\n\
    \    push(@planets, $planet2);\n    return sort(@planets);\n}", "    my @planets;\n\
    \    if ( $planet1 eq $planet2 ) {\n        push @planets, $planet1;\n    } elsif\
    \ ( $planet1 eq orb($planet2) ) {\n        push @planets, $planet1;\n        push\
    \ @planets, $planet2;\n    } elsif ( orb($planet1) eq orb($planet2) ) {\n    \
    \    push @planets, $planet2;\n        push @planets, $planet1;\n    } else {\n\
    \        return ();\n    }\n    for my $planet ( @planets ) {\n        if (orb($planet1)\
    \ < orb($planet2)) {\n            push @planets, $planet;\n        }\n    }\n\
    \    sort { orb($a) <=> orb($b) } @planets;\n}", "    # TODO Write code here\n\
    \    \n    my @planets = ();\n    if(!$planet1 || !$planet2) {\n        return\
    \ @planets;\n    }", "    \n    if ($planet1 eq 'Earth') {\n        my(@orbits)\
    \ = ();\n        if ($planet2 eq 'Sun') {\n            @orbits = (\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n        } elsif ($planet2 eq 'Moon') {\n            @orbits = (\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    , \"Phobos\");\n        } elsif ($planet2 eq 'Mercury') {\n            @orbits\
    \ = (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n        } elsif ($planet2 eq 'Venus') {\n            @orbits = (\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        } elsif\
    \ ($planet2 eq 'Earth') {\n            @orbits = (\"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\");\n        } elsif ($planet2 eq 'Mars') {\n        \
    \    @orbits = (\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        }\
    \ elsif ($planet2 eq 'Jupiter') {\n            @orbits = (\"Saturn\", \"Uranus\"\
    , \"Neptune\");\n        } elsif ($planet2 eq 'Saturn') {\n            @orbits\
    \ = (\"Uranus\", \"Neptune\");\n        } elsif ($planet2 eq 'Uranus') {\n   \
    \         @orbits = (\"Neptune\");\n        } elsif ($planet2 eq 'Neptune') {\n\
    \            @orbits = (\"Phobos\");\n        } elsif ($planet2 eq 'Phobos') {\n\
    \            @orbits = ();\n        } else {\n            die \"Planet2 must be\
    \ sun, moon or mercury planet\";\n        }\n        @orbits = sort_orbits(@orbits);\n\
    \    }\n    if ($planet1 eq 'Mercury') {\n        my(@orbits) = ();\n        if\
    \ ($planet2 eq 'Sun') {\n            @orbits = (\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        } elsif ($planet2\
    \ eq 'Moon') {\n            @orbits = (\"Venus\", \"Earth\", \"Mar", "    my($orbit1,\
    \ $orbit2) = @_;\n    my($dist1, $dist2) = @_;\n    my(@planets1, @planets2) =\
    \ @_;", "    my(@orbits) = ();\n    # Add orbit of planet1 to the list.\n    if\
    \ ($planet1 ne \"Earth\" || $planet1 ne \"Mars\") \n    {\n        ($orbits[0]\
    \ = $planet1 . \"_orbit\") \n    }\n    # Add orbit of planet2 to the list.\n\
    \    if ($planet2 ne \"Earth\" || $planet2 ne \"Mars\") \n    {\n        ($orbits[$#orbits]\
    \ = $planet2 . \"_orbit\") \n    }\n    # Add the orbit of planet1 to the list\n\
    \    ($orbits[0] = $planet1 . \"_orbit\") \n    # Add the orbit of planet2 to\
    \ the list\n    ($orbits[$#orbits] = $planet2 . \"_orbit\");\n    # Sort the list\n\
    \    my ($i, $j) = @_;\n    my $index = 0;\n    for(my $i = 0; $i < $#orbits;\
    \ $i++)\n    {\n        $index = 0;\n        for(my $j = 0; $j < $#orbits; $j++)\n\
    \        {\n            if( $orbits[$i] eq $orbits[$j])\n            {\n     \
    \           $index++;\n            }\n        }\n        push (@orbits, $orbits[$i]);\n\
    \        $orbits[$i] = $orbits[$index];\n    }\n    return (@orbits);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is my implementation, a recursive version\n\
    <code>\nuse warnings;\nuse strict;\nuse feature 'say';", "    return undef\n \
    \       if $planet1 eq \"\" || $planet2 eq \"\" || $planet1 eq \"Mercury\"\n \
    \       or $planet1 eq \"Venus\" or $planet1 eq \"Earth\" or $planet1 eq \"Mars\"\
    \n        or $planet1 eq \"Jupiter\" or $planet1 eq \"Saturn\" or $planet1 eq\
    \ \"Uranus\"\n        or $planet1 eq \"Neptune\" or $planet2 eq \"Mercury\"\n\
    \        or $planet2 eq \"Venus\" or $planet2 eq \"Earth\" or $planet2 eq \"Mars\"\
    \n        or $planet2 eq \"Jupiter\" or $planet2 eq \"Saturn\" or $planet2 eq\
    \ \"Uranus\"\n        or $planet2 eq \"Neptune\";\n    my @planets = ();\n   \
    \ for my $planet (@planets) {\n        my @planets_orbit = ();\n        for my\
    \ $planets_orbit (@planets_orbit) {\n            push @planets_orbit, @{orbit_planets($planet,\
    \ $planets_orbit)};\n        }\n        foreach my $planets_orbit (@planets_orbit)\
    \ {\n            my $distance = calculate_distance($planet, $planets_orbit);\n\
    \            foreach my $orbit (@planets_orbit) {\n                if ($distance\
    \ >= calculate_distance($planet, $orbit)) {\n                    push @planets,\
    \ $orbit;\n                    last;\n                }\n            }\n     \
    \   }\n    }\n    \n    return sort {-calculate_distance($a,$b) <=> -calculate_distance($b,$a)};\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for the answer! I've updated\
    \ my question with the code I have at the moment. I tried your code but it doesn't\
    \ return the right array. How should I fix it?\n<|/ c |>\n<| c |>\n`@planets_orbit`\
    \ should not be a hash, it should be a 2d array. `@planets_orbit = orbit_planets($planet,\
    \ $planets_orbit)` doesn't look right.\n<|/ c |>\n<| c |>\nThanks for your reply!\
    \ I've changed it to `@planets_orbit = orbit_planets($planet1, $planets_orbit);\n\
    \            foreach my $planets_orbit (@planets_orbit) {\n                my\
    \ $distance = calculate_distance", "    my @orbit_names = ();\n    # TODO Implement\
    \ this function\n    return @orbit_names;\n}", "    my @orbits;\n    my @planets;\n\
    \    my $orbit;\n    my $planet1;\n    my $planet2;\n    my $planet;\n    my $distance\
    \ = &distance($planet1, $planet2);\n    foreach $planet (sort { $a <=> $b } qw(Mercury\
    \ Venus Earth Mars Jupiter Saturn Uranus Neptune)) {\n        $orbit = &orbit($planet,\
    \ $planet1);\n        if ($orbit > $distance) {\n            $planets[$#planets]\
    \ = $planet;\n            $planets[$#planets]++;\n        }\n    }\n    if ($#planets\
    \ != 0) {\n        @orbits = sort { $a <=> $b } map {$_ * pi()/180} @planets;\n\
    \    }\n    elsif ($#planets == 0) {\n        return ();\n    }\n    return @orbits;\n\
    }\n</code>\n<|/ a tags=perl,arrays,hash |>\n<| c |>\nThank you! Can you explain\
    \ to me what's happening here? I understand everything except `sort { $a <=> $b\
    \ } qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune)` I understand what\
    \ the qw is doing and what `sort { $a <=> $b } ` is doing, but I don't understand\
    \ how you're using that to sort the array.\n<|/ c |>\n<| c |>\nIt compares the\
    \ values of the planets according to the angle between the two orbits. If the\
    \ planets are in different orbits the angle will also be different, and thus the\
    \ planets will be sorted according to angle and distance.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis is a much more efficient way to calculate orbits\n<code>\nuse strict;\n\
    use warnings;", '    my @return = ();', "    my @planets;\n    foreach my $planet(@planet_names){\n\
    \        if($planet1 eq $planet || $planet2 eq $planet){\n            push (@planets,\
    \ $planet);\n        }\n    }\n    \n    #return sort { abs($a <=> $b) };\n  \
    \  return sort { abs($planet_positions[$a] <=> $planet_positions[$b]) };\n}",
  "    return unless $planet1 =~ /^[A-Za-z]+$/;\n    return unless $planet2 =~ /^[A-Za-z]+$/;\n\
    \    my @planets = ();\n    # This is our \"sun\"\n    my $sun = `perl -e 'print\
    \ \"$ENV{HOME}/solar.dat\"'`;\n    chomp $sun;\n    # These are our planets\n\
    \    my @planets1 = ();\n    my @planets2 = ();\n    my @planets3 = ();\n    #\
    \ Here we store our orbits\n    my @orbits1 = ();\n    my @orbits2 = ();\n   \
    \ my @orbits3 = ();\n    # Here we store the distance\n    my @distance1 = ();\n\
    \    my @distance2 = ();\n    my @distance3 = ();\n    # Here we store our planets'\
    \ positions\n    my @pos1 = ();\n    my @pos2 = ();\n    my @pos3 = ();\n    my\
    \ @pos4 = ();\n    my @pos5 = ();\n    my @pos6 = ();\n    my @pos7 = ();\n  \
    \  my @pos8 = ();", "    my @planets;\n    foreach my $planet (sort { $a <=> $b\
    \ } keys %planets) {\n        if ($planets[$planet] >= $sun_radius && $planets[$planet]\
    \ < 2 * $sun_radius) {\n            if ($planets[$planet] - $sun_radius < $planets[$planet2]\
    \ && $planets[$planet2] < $sun_radius) {\n                push(@planets, $planets[$planet]);\n\
    \                push(@planets, $planet);\n                push(@planets, $planets[$planet2]);\n\
    \            }\n        }\n    }\n    push(@planets, $planet1, $planet2) if $planet1\
    \ ne $planet2;\n    @planets = sort { $a <=> $b } @planets;\n    return @planets;\n\
    }\n</code>\n<|/ a dscore=2 tags=perl,algorithm,sun,math,planet |>\n<| c |>\nI\
    \ haven't tested this - but this algorithm is wrong. If `Sun` is at angle `P`\
    \ then the planets at angles `P` and `P+360` do not share any orbits - so `P +\
    \ 360` shouldn't be added to the list. I would expect the algorithm to yield a\
    \ smaller list than the one you propose.\n<|/ c |>\n<| c |>\n: Your algorithm\
    \ only considers the planets whose distance from the sun is at least `sun_radius`.\
    \ So it doesn't take into account the fact that the Sun can move between planets.\n\
    <|/ c |>\n<| c |>\n: You seem to have misunderstood my answer. My algorithm considers\
    \ the planets whose distance from the sun is at least `sun_radius` *and also includes\
    \ the planet `sun`*. The `sun` is part of the list because it does not have any\
    \ orbits which overlap with the planets which are between the orbits of the planets\
    \ whose distance from the sun is at least `sun_radius`. So `sun` is indeed part\
    \ of the result.\n<|/ c |>\n<| c |>\n: I have now tested it. It works, thank you!\
    \ I have updated my answer with a link to the working example.\n<|/ c |>\n<| c\
    \ |>\nIt was actually very helpful to me to look at this solution (not only to\
    \ understand it but also to see if it works even with the special case where Sun\
    \ lies on one side of the planet), but for some reason, my ", "    my(@planets);\n\
    \    \n    foreach $planet1 ('Mercury' 'Venus' 'Earth' 'Mars' 'Jupiter' \n   \
    \         'Saturn' 'Uranus' 'Neptune') {\n        foreach $planet2 (@planets)\
    \ {\n            my($dist) = planet_distance($planet1, $planet2);\n          \
    \  if($dist < 0) {\n                push(@planets, $planet1);\n            } elsif($dist\
    \ > 0) {\n                push(@planets, $planet2);\n            }\n        }\n\
    \    }\n    \n    my @sorted_planets = sort {\n        $a <=> $b\n    } @planets;\n\
    \    \n    if(@sorted_planets == 0) {\n        return [];\n    }\n    \n    return\
    \ @sorted_planets;\n}", '    my($planet1_orbit, $planet2_orbit);', "    my @orbit\
    \ = ();\n    my $n = @planets-1;\n    my $m = @orbits;\n    # if the planet names\
    \ are incorrect, return empty\n    unless ($planet1 =~ /^[A-Za-z\\s]+$/) {\n \
    \       $orbits[$n]++;\n        $orbits[$m]++;\n        return;\n    }\n    unless\
    \ ($planet2 =~ /^[A-Za-z\\s]+$/) {\n        $orbits[$n]++;\n        $orbits[$m]++;\n\
    \        return;\n    }\n    # if the planets are both correct but are farther\
    \ away\n    # than 1 AU, then return empty\n    if (abs($planets[$n] - $planets[$m])\
    \ < 1) {\n        $orbits[$n]++;\n        $orbits[$m]++;\n        return;\n  \
    \  }\n    # find the orbit of planet1 by solving differential equation for \n\
    \    # the total distance between the orbit of planet1 and planet2\n    # solving\
    \ differential equation for two variables \n    # equation for two variables\n\
    \    $orbits[$m]++;\n    $orbits[$n]+=1;\n    $d = $planets[$n] - $planets[$m];\n\
    \    for(my $j=$n; $j>$m;) {\n        $orbits[$j]++;\n        $orbits[$j-1]+=1;\n\
    \    }\n    for(my $k=$m; $k>$n;) {\n        $orbits[$k]++;\n        $orbits[$k-1]-=1;\n\
    \    }\n    # solve the differential equation for two variables\n    my $x = $planets[$m]\
    \ - $planets[$n];\n    my $y = $orbits[$m] - $orbits[$n];\n    $x = $x/$d;\n \
    \   $y = $y/$d;\n    # if the equation is solved, then calculate the distance\n\
    \    if ($x * $x + $y * $y <= 1) {\n        $distance[$n] = sqrt($x * $x + $y\
    \ * $y);\n    } else {\n        $distance[$n] = 0;\n    }\n    # sort the distances\
    \ in ascending order\n    sort {$distance[$a] < $distance[$b] ? -1 : 1} @distance;\n\
    \    # sort the planets in ascending order\n    sort {$planets[$a] cmp $planets[$b]}\
    \ @planets;\n    # return the sorted planets\n    return;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis looks like it might be a good solution.  However my assignment doesn't\
    \ permit use of ", "    my @planets = ();\n    \n    if ($planet1 eq \"Mercury\"\
    \ || $planet1 eq \"Venus\" || $planet1 eq \"Earth\" || $planet1 eq \"Mars\" ||\
    \ $planet1 eq \"Jupiter\" || $planet1 eq \"Saturn\" || $planet1 eq \"Uranus\"\
    \ || $planet1 eq \"Neptune\") {\n       if ($planet2 eq \"Mercury\" || $planet2\
    \ eq \"Venus\" || $planet2 eq \"Earth\" || $planet2 eq \"Mars\" || $planet2 eq\
    \ \"Jupiter\" || $planet2 eq \"Saturn\" || $planet2 eq \"Uranus\" || $planet2\
    \ eq \"Neptune\") {\n          push (@planets, $planet1) if ($planet1 eq $planet2);\n\
    \          push (@planets, $planet2) if ($planet1 eq $planet2);\n       }\n  \
    \     elsif ($planet2 eq \"Mercury\" || $planet2 eq \"Venus\" || $planet2 eq \"\
    Earth\" || $planet2 eq \"Mars\" || $planet2 eq \"Jupiter\" || $planet2 eq \"Saturn\"\
    \ || $planet2 eq \"Uranus\" || $planet2 eq \"Neptune\" || $planet2 eq \"Mercury\"\
    \ || $planet2 eq \"Venus\" || $planet2 eq \"Earth\" || $planet2 eq \"Mars\" ||\
    \ $planet2 eq \"Jupiter\" || $planet2 eq \"Saturn\" || $planet2 eq \"Uranus\"\
    \ || $planet2 eq \"Neptune\") {\n          push (@planets, $planet2);\n      \
    \ }\n       elsif ($planet1 eq \"Mercury\" || $planet1 eq \"Venus\" || $planet1\
    \ eq \"Earth\" || $planet1 eq \"Mars\" || $planet1 eq \"Jupiter\" || $planet1\
    \ eq \"Saturn\" || $planet1 eq \"Uranus\" || $planet1 eq \"Neptune\" || $planet2\
    \ eq \"Mercury\" || $planet2 eq \"Venus\" || $planet2 eq \"Earth\" || $planet2\
    \ eq \"Mars\" || $planet2 eq \"Jupiter\" || $", '    my @solar_planets = ();',
  '    my(@orbits) = ();', "    return if ($planet1 eq \"\" || $planet2 eq \"\");\n\
    \    my(@result);\n    my @planets = ();\n    foreach my $planet (@planet_names)\
    \ {\n        if ($planet eq $planet1) {\n            push (@planets, $planet);\n\
    \        }\n        elsif ($planet eq $planet2) {\n            push (@planets,\
    \ $planet);\n        }\n        else {\n            my ($x1, $y1, $x2, $y2, $x3,\
    \ $y3, $x4, $y4, $x5, $y5) = get_planet_position($planet);\n            my $distance\
    \ = distance($x1, $y1, $x2, $y2, $x3, $y3, $x4, $y4, $x5, $y5);\n            push\
    \ (@planets, $planet);\n        }\n    }\n    @planets = sort {$a <=> $b} @planets;\n\
    \    return @planets;\n}", "    my(@planets);\n    # Write your code here\n  \
    \  # Write your code here\n    # Write your code here\n    # Write your code here\n\
    \    # Write your code here\n    # Write your code here\n    # Write your code\
    \ here\n    # Write your code here\n    # Write your code here\n    return @planets;\n\
    }", "    if ($planet1 eq $planet2) {\n        return ();\n    }\n    elsif ($planet1\
    \ eq \"Earth\") {\n        return (\"Mercury\", \"Venus\", \"Earth\");\n    }\n\
    \    elsif ($planet1 eq \"Mercury\") {\n        return (\"Venus\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n    elsif ($planet1 eq\
    \ \"Venus\") {\n        return (\"Mercury\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n    elsif ($planet1 eq \"Mars\"\
    ) {\n        return (\"Mercury\", \"Earth\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\");\n    }\n    elsif ($planet1 eq \"Jupiter\") {\n        return\
    \ (\"Mercury\", \"Mars\", \"Venus\", \"Saturn\", \"Uranus\", \"Neptune\");\n \
    \   }\n    elsif ($planet1 eq \"Saturn\") {\n        return (\"Mercury\", \"Mars\"\
    , \"Jupiter\", \"Uranus\", \"Neptune\");\n    }\n    elsif ($planet1 eq \"Uranus\"\
    ) {\n        return (\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\"\
    );\n    }\n    elsif ($planet1 eq \"Neptune\") {\n        return (\"Mercury\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n    }\n    return ();\n}",
  "    my @planets1 = grep { !($_ =~ m/$planet1$/i) || ($_ =~ m/$planet2$/i) } @planets;\n\
    \    my @planets2 = grep { !($_ =~ m/$planet2$/i) || ($_ =~ m/$planet1$/i) } @planets;\n\
    \    my @planets = @planets1;\n    for my $planet (@planets2) {\n        my $planet2orbit\
    \ = orbit_planet($planet);\n        my $planet1orbit = orbit_planet($planet1);\n\
    \        my $distance1 = ($planet2orbit - $planet1orbit)->[0]->[0];\n        my\
    \ $distance2 = ($planet1orbit - $planet2orbit)->[0]->[0];\n        if ($distance1\
    \ != 0 && $distance2 != 0) {\n            if ($distance1 < $distance2) {\n   \
    \             push (@planets, $planet);\n            }\n            else {\n \
    \               push (@planets, $planet);\n            }\n        }\n    }\n \
    \   return sort {$a->[0] cmp $b->[0]};\n}", "    if ($planet1 eq $planet2) {\n\
    \        return \"$planet1\";\n    }\n    if ($planet1 eq uc $planet2) {\n   \
    \     return bf($planet2, $planet1);\n    }\n    if ($planet1 eq \"Uranus\" ||\
    \ $planet1 eq \"Neptune\") {\n        return ();\n    }\n    my(@planets);\n \
    \   if ($planet1 eq uc $planet2) {\n        @planets = (\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \n                    \"Uranus\"\
    , \"Neptune\");\n    } else {\n        @planets = (\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    }\n    foreach my $planet (@planets)\
    \ {\n        if ($planet1 eq uc $planet) {\n            push(@planets, $planet);\n\
    \            last;\n        }\n    }\n    sort(@planets);\n    return @planets;\n\
    }\n</cell>\n<cell>\n%%bash", "    if ($planet1 eq \"\" || ($planet2 eq \"\"))\
    \ {\n        return ;\n    }\n    if ($planet1 eq $planet2) {\n        $planet1\
    \ = \"Earth\";\n        $planet2 = \"Earth\";\n    }\n    my($planets1) = &orb($planet1);\n\
    \    my($planets2) = &orb($planet2);\n    my($planets3) = &orb($planet1);\n  \
    \  my($planets4) = &orb($planet2);\n    my($planets5) = &orb($planet1);\n    my($planets6)\
    \ = &orb($planet2);\n    my($planets7) = &orb($planet1);\n    my($planets8) =\
    \ &orb($planet2);\n    my(@arr1) = ();\n    my(@arr2) = ();\n    my(@arr3) = ();\n\
    \    my(@arr4) = ();\n    my(@arr5) = ();\n    my(@arr6) = ();\n    my(@arr7)\
    \ = ();\n    my(@arr8) = ();\n    my(@arr9) = ();\n    my($first, $last, $a, $b,\
    \ $c, $d, $e, $f, $g, $h);\n    my($planets1, $planets2, $planets3, $planets4,\
    \ $planets5, $planets6, \n        $planets7, $planets8, $planets9);\n    foreach\
    \ $planet1 (@$planets1) {\n        foreach $planet2 (@$planets2) {\n         \
    \   $planets2 = &bf(@$planets2,);\n            $planets3 = &bf(@$planets3,);\n\
    \            $planets4 = &bf(@$planets4,);\n            $planets5 = &bf(@$planets5,);\n\
    \            $planets6 = &bf(@$planets6,);\n            $planets7 = &bf(@$planets7,);\n\
    \            $planets8 = &bf(@$planets8,);\n            $planets9 = &bf(@$planets9,);\n\
    \            $first = &planet($planet1, $planet2);\n            $last = &planet($planet1,\
    \ $planet2);\n            $arr1 .= $", "    return sort grep {$_ eq $planet1 or\
    \ $_ eq $planet2} @{\n        planets(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\",\n                \"Uranus\", \"Neptune\")\n    };\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI actually like the solution very much!\
    \ I was looking at the problem to find the best algorithm and then I ended up\
    \ doing it exactly like you did. Thanks a lot!\n<|/ c |>\n<| a dscore=1 |>\nThe\
    \ first solution provided by was good but not perfect: it does not check the distance\
    \ between the planets and is therefore not able to find planets within 30 degrees\
    \ angle. Moreover, it didn't return all the correct planets for example: bf(\"\
    Earth\", \"Mercury\") should return [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Mercury\"]. \nSo, for those who want to have a more complete algorithm\
    \ that also checks the distance between two planets, here's mine:\n<code>", " \
    \   my @planets;\n    foreach my $planet (@planets) {\n        if ($planet->name\
    \ eq $planet1 || $planet->name eq $planet2) {\n            if ($planet1->name\
    \ eq $planet2->name) {\n                push @planets, $planet; \n           \
    \ } else {\n                my $planet1orbit = $planet->orbit($planet1);\n   \
    \             my $planet2orbit = $planet->orbit($planet2);\n                if\
    \ ($planet1orbit->distance < $planet2orbit->distance) {\n                    push\
    \ @planets, $planet; \n                }\n            }\n        }\n    }\n  \
    \  if (@planets == 0) {\n        return @planets;\n    }\n    my @sorted = ();\n\
    \    my $i = 1;\n    my $j = 1;\n    my @list = ( @planets );\n    while (@list)\
    \ {\n        foreach my $planet (@list) {\n            if ($planet->name eq $planet1)\
    \ {\n                $i++;\n            }\n            if ($planet->name eq $planet2)\
    \ {\n                $j++;\n            }\n            if ($i < $j && $planet->name\
    \ ne $planet1->name) {\n                push @sorted, $planet;\n             \
    \   $j--;\n            }\n        }\n        pop @list;\n    }\n    sort { $a->name\
    \ cmp $b->name } @sorted;\n}", "    my @planets = ();\n    if ($planet1 =~ /^[A-Za-z]$/)\
    \ {\n        foreach my $planet (keys %orbits) {\n            if ($planet =~ /^$planet$/)\
    \ {\n                if ($planet ne $planet1 || $planet ne $planet2) {\n     \
    \               push(@planets, $planet);\n                }\n            }\n \
    \       }\n    }\n    return @planets if @planets;\n    return ();\n}", "    return\
    \ unless $planet1 =~ /^[A-Za-z]+$/;\n    return unless $planet2 =~ /^[A-Za-z]+$/;\n\
    \    my %planets;\n    foreach $planet ($planet1, $planet2) {\n        push @{$planets{$planet}},\
    \ $planet;\n    }\n    foreach my $planet (keys %planets) {\n        foreach my\
    \ $planet_i (@{$planets{$planet}}) {\n            foreach my $planet_j (@{$planets{$planet}})\
    \ {\n                if ($planet_i ne $planet_j) {\n                    if ($planet\
    \ ne \"Earth\") {\n                        next unless $planet_i eq $planet_j;\n\
    \                    } elsif ($planet eq \"Earth\") {\n                      \
    \  next unless $planet_i ne $planet_j;\n                    }\n              \
    \      foreach my $planet_i (@{$planets{$planet}}) {\n                       \
    \ foreach my $planet_j (@{$planets{$planet}}) {\n                            next\
    \ if $planet_i eq $planet_j;\n                            next unless $planet_i\
    \ ne $planet_j;\n                            foreach my $planet_i (@{$planets{$planet}})\
    \ {\n                                foreach my $planet_j (@{$planets{$planet}})\
    \ {\n                                    if ($planet_i ne $planet_j) {\n     \
    \                                   if ($planet ne \"Earth\") {\n            \
    \                                next unless $planet_i eq $planet_j;\n       \
    \                                 } elsif ($planet eq \"Earth\") {\n         \
    \                                   next unless $planet_i ne $planet_j;\n    \
    \                                    }\n                                     \
    \   foreach my $planet_i (@{$planets{$planet}}) {\n                          \
    \                  foreach my $planet_j (@{$planets{$planet}}) {\n           \
    \                                     if ($planet_i ne $planet_j) {\n        \
    \                                            # $planet1 eq $planet2 ||\n     \
    \                                               # $planet1 ne $planet2 ||\n  \
    \                                                  # $planet2 eq $planet1 ||\n\
    \                                                    # $planet2 ne $planet1;\n\
    \                                                    # $planet1 eq $planet2 ||\n\
    \                                                    # $planet1 eq $planet2 ||\n\
    \                                                    # $planet2 ne $planet1 ||\n\
    \                                                    # $planet2 ne $planet2;\n\
    \                                                    \n                      \
    \                              # if $planet1 eq $", "    my($planet1_orb, $planet2_orb)\
    \ = qw(mercury venus earth mars jupiter saturn uranus neptune);\n    my(@planets)\
    \ = ();\n    foreach $planet ( keys %$planet1_orb ) {\n        if( $planet ne\
    \ $planet1 && $planet ne $planet2 ) {\n            next;\n        }\n        else\
    \ {\n            foreach $planet1 (@planets) {\n                foreach $planet2\
    \ (@planets) {\n                    if( $planet2 ne $planet1 && $planet1_orb{$planet}\
    \ * $planet2_orb{$planet} < 0 ) {\n                        push, $planet;\n  \
    \                      last;\n                    }\n                }\n     \
    \       }\n        }\n    }\n    grep( !defined($planet1_orb{$_}), @planets );\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you so much! This helped me a lot, but the\
    \ code doesn't return the right answer. For example, when I type bf(\"Jupiter\"\
    ,\"Neptune\"), the correct answer is \"Saturn, Uranus\". It should return an array\
    \ [\"Saturn\", \"Uranus\"]\n<|/ c |>\n<| c |>\nThe code returns saturn and uranus,\
    \ but not uranus and neptune. But i think that is your task to fix\n<|/ c |>\n\
    <| c |>\nYes, I fixed it, but now the code doesn't return the right answer. For\
    \ example, when I type bf(\"Jupiter\",\"Neptune\"), the correct answer is \"Saturn,\
    \ Uranus\". It should return an array [\"Saturn\", \"Uranus\"]\n<|/ c |>\n<| c\
    \ |>\nUpdated answer with new code. Try it now. Thanks for the help!\n<|/ c |>\n\
    <| a dscore=0 |>\nYour problem is in your code\n<code>\nif( $planet2 ne $planet1\
    \ && $planet1_orb{$planet} * $planet2_orb{$planet} < 0 ) {\n    push, $planet;\n\
    \    last;\n}\n</code>\nHere you are comparing planet1 to planet2. In the example\
    \ you provided, this is true as planet1 is a planet in the orbit of planet2, therefore\
    \ the statement will never be satisfied. Your code will never run through ", " \
    \   my @planets;\n    my = @{$solar_system->{planets}};\n    for (my $i = 0; $i\
    \ <; $i++) {\n        if ($planet1 == $planets[$i]) {\n            if ($planet2\
    \ == $planets[$i + 1]) {\n                push (@planets, $planets[$i]);\n   \
    \             push (@planets, $planets[$i + 1]);\n            }\n            else\
    \ {\n                push (@planets, $planets[$i]);\n            }\n        }\n\
    \        else {\n            if ($planet2 == $planets[$i]) {\n               \
    \ push (@planets, $planets[$i + 1]);\n            }\n            else {\n    \
    \            push (@planets, $planets[$i]);\n            }\n        }\n    }\n\
    \    return @planets;\n}", "    if ($planet1 eq \"\" || $planet2 eq \"\") {\n\t\
    return [];\n    }\n    my($i, $orbit1, $orbit2, $dist) = planets( $planet1, $planet2);\n\
    \    if ($i == 0) {\n\treturn [];\n    }\n    my $orb1 = $orbit1[$i-1];\n    my\
    \ $orb2 = $orbit2[$i];\n    my($planets) = $orbit1->orbs( $orb2);\n    foreach\
    \ my $planet (@{$planets}) {\n\tpush(@result, $planet);\n    }\n    @result =\
    \ sort {&dist($a, $b)} @result;\n    return @result;\n}", "    my %planets = ();\n\
    \    my $sun = Math::Atan2(0,1);\n    foreach my $planet (@planets) {\n      \
    \  my $distance = ((($planet)->coord($planet1)->dist / ($planet)->coord($planet2)->dist)\
    \ / $sun);\n        push (@{$planets{$distance}}, $planet);\n    }\n    return\
    \ sort {\n\t($a->coord($planet1)->dist < $b->coord($planet1)->dist) ? -1 : \n\t\
    ($a->coord($planet1)->dist > $b->coord($planet1)->dist) ? 1 : \n\t($a->coord($planet2)->dist\
    \ < $b->coord($planet2)->dist) ? -1 : \n\t($a->coord($planet2)->dist > $b->coord($planet2)->dist)\
    \ ? 1 : \n\t0\n    } keys %planets;\n}", '    my($sun_x, $sun_y, $sun_z) = getSunVector();',
  "    return grep(!$planet1 || !$planet2,\n\t\t    @$planet1 +\n\t\t    @$planet2\
    \ =~ m/(.*)\\/(.*)/g);\n}\n</cell>\n<text>\nProblem 5 - Barycentric coordinates\n\
    Write a function that takes three vectors in Cartesian coordinates as \narguments.\
    \ The function should return true if all three vectors have zero \nmagnitudes\
    \ and false if at least one vector has non-zero magnitudes. \nThe function should\
    \ return false if any of the vectors is singular and \nfalse if all vectors are\
    \ singular. \nThe function should return false if the arguments are not vectors\
    \ or the \nmagnitude of any of them is less than 0.", "    my;\n    \n    if ($planet1\
    \ eq \"Earth\" || $planet1 eq \"Mercury\" || $planet1 eq \"Venus\") {\n      \
    \  push, $planet1;\n    }\n    elsif ($planet1 eq \"Mars\" || $planet1 eq \"Jupiter\"\
    \ || $planet1 eq \"Saturn\" || $planet1 eq \"Uranus\") {\n        push, $planet1;\n\
    \    }\n    elsif ($planet1 eq \"Neptune\") {\n        push, $planet1;\n    }\n\
    \    elsif ($planet2 eq \"Earth\" || $planet2 eq \"Mercury\" || $planet2 eq \"\
    Venus\") {\n        push, $planet2;\n    }\n    elsif ($planet2 eq \"Mars\" ||\
    \ $planet2 eq \"Jupiter\" || $planet2 eq \"Saturn\" || $planet2 eq \"Uranus\"\
    ) {\n        push, $planet2;\n    }\n    elsif ($planet2 eq \"Neptune\") {\n \
    \       push, $planet2;\n    }\n    else {\n        return ();\n    }\n    \n\
    \    return sort {$a->orbit <=> $b->orbit} @orbits;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks so much for the help! I appreciate it. I was wondering if\
    \ you could explain to me what sort is doing here exactly? I'm assuming that it\
    \ is sorting the array's orbits by their orbit value, but I'm a bit confused as\
    \ to how it is sorting them. If this helps, I can explain my reasoning for sorting\
    \ them by proximity to the sun and by their orbits. Any additional help would\
    \ be awesome!\n<|/ c |>\n<| c |>\n`sort` sorts its input in place based on some\
    \ criteria. `@orbits` is an array that has all your planets. So, `sort` iterates\
    \ through this array in order, pulling each planet's orbit value from each of\
    \ its elements. Then it compares them and orders them based on the comparison\
    \ (which may mean that the orbit values of two planets are the same, one is a\
    \ closer orbit to the sun and one isn't).\n<|/ c |>\n<| c |>\nThanks for clearing\
    \ that up! I'm still getting a little confused because I have another piece of\
    \ code where I do the same thing, but without the sort portion of it, and it seems\
    \ to be doing the same ", "    \n    # Write your code below this line\n    \n\
    \    \n    return @planets;\n}", "    my @planets;\n    my = qw(Mercury Venus\
    \ Earth Mars Jupiter Saturn Uranus Neptune);\n    my %orbits{qw(Mercury Venus\
    \ Earth Mars Jupiter Saturn Uranus Neptune)};\n    \n    foreach my $planet(@planets)\
    \ {\n        if ($planet eq $planet1) {\n            foreach my $orbit(@orbits{$planet})\
    \ {\n                if ($orbit[0] <= $planet2 && $orbit[1] <= $planet2) {\n \
    \                   push(@planets, $orbit);\n                }\n            }\n\
    \        }\n        else {\n            foreach my $orbit(@orbits{$planet}) {\n\
    \                if ($orbit[0] <= $planet1 && $orbit[1] <= $planet1) {\n     \
    \               push(@planets, $orbit);\n                }\n            }\n  \
    \      }\n    }\n    \n    foreach my $planet(@planets) {\n        foreach my\
    \ $orbit(@orbits{$planet}) {\n            push(@planets, $planet) unless ($orbit[0]\
    \ <= $planet2 && $orbit[1] <= $planet2);\n        }\n    }\n    \n    foreach\
    \ my $planet(@planets) {\n        foreach my $orbit(@orbits{$planet}) {\n    \
    \        push(@planets, $planet) unless ($orbit[0] <= $planet1 && $orbit[1] <=\
    \ $planet1);\n        }\n    }\n    \n    @planets = sort {$a->[0] cmp $b->[0]};\n\
    \    return @planets;\n}", "    my @out;\n    $planet1 = lc( $planet1 );\n   \
    \ $planet2 = lc( $planet2 );", "    my $orbit1 = getOrbit($planet1);\n    my $orbit2\
    \ = getOrbit($planet2);", '    my($planet1_orbit, $planet2_orbit, @planet_orbits);',
  "    if ($planet1 =~ m/^[a-z]/i || $planet2 =~ m/^[a-z]/i) {\n        unshift(@planets,\
    \ $planet1);\n        unshift(@planets, $planet2);\n    }\n    if ($planet1 eq\
    \ $planet2) {\n        return @planets;\n    }\n    if ($planet1 eq \"Earth\"\
    ) {\n        unshift(@planets, \"Mercury\");\n        return @planets;\n    }\n\
    \    if ($planet2 eq \"Earth\") {\n        unshift(@planets, \"Mercury\");\n \
    \       return @planets;\n    }\n    if ($planet1 eq \"Mercury\") {\n        unshift(@planets,\
    \ \"Venus\");\n        return @planets;\n    }\n    if ($planet2 eq \"Mercury\"\
    ) {\n        unshift(@planets, \"Venus\");\n        return @planets;\n    }\n\
    \    if ($planet1 eq \"Venus\") {\n        unshift(@planets, \"Earth\");\n   \
    \     unshift(@planets, \"Mars\");\n        unshift(@planets, \"Jupiter\");\n\
    \        unshift(@planets, \"Saturn\");\n        unshift(@planets, \"Uranus\"\
    );\n        unshift(@planets, \"Neptune\");\n        return @planets;\n    }\n\
    \    if ($planet2 eq \"Venus\") {\n        unshift(@planets, \"Earth\");\n   \
    \     unshift(@planets, \"Mars\");\n        unshift(@planets, \"Jupiter\");\n\
    \        unshift(@planets, \"Saturn\");\n        unshift(@planets, \"Uranus\"\
    );\n        unshift(@planets, \"Neptune\");\n        return @planets;\n    }\n\
    \    if ($planet1 eq \"Mars\") {\n        unshift(@planets, \"Earth\");\n    \
    \    unshift(@planets, \"Jupiter\");\n        unshift(@planets, \"Saturn\");\n\
    \        unshift(@planets, \"Uranus\");\n        unshift(@planets, \"Neptune\"\
    );\n        return @planets;\n    }\n    if ($planet2 eq \"Mars\") {\n       \
    \ unshift(@planets, \"Earth\");\n        unshift(@planets, \"Jupiter\");\n   \
    \     unshift(@planets, \"Saturn\");\n        unshift(@planets, \"Uranus\");\n\
    \        unshift(@planets, \"Neptune\");\n        return @planets;\n    }\n  \
    \  if ($planet1 eq \"Jupiter\") {\n        unshift(@planets, \"Earth\");", " \
    \   if ($planet1 eq $planet2) { \n        return qw(Sun);\n    } elsif ($planet1\
    \ eq \"\" || $planet2 eq \"\") {\n        return qw();\n    } elsif ($planet1\
    \ eq \"Sun\" ||  $planet2 eq \"Sun\") {\n        return qw(Sun);\n    } elsif\
    \ ($planet1 eq \"Mercury\" || $planet2 eq \"Mercury\") {\n        return qw(Mercury\
    \ Venus Earth Mars Jupiter Saturn Uranus);\n    }\n    my @orbits = @{$planet_hash{$planet1}->{orbits}};\n\
    \    my @orbits2 = @{$planet_hash{$planet2}->{orbits}};", "    my($s1, $s2, $i,\
    \ $j, $p, $d, $k);\n    my(@results);\n    my($planet1, $planet2, @planets);\n\
    \    \n    # Convert planet names to lowercase letters\n    $planet1 = lc($planet1);\n\
    \    $planet2 = lc($planet2);\n    \n    # Remove planets that are not in the\
    \ system\n    @planets = grep(!/^[Ee]arth|[Mm]ercury|[Jj]upiter|[Ss]aturn|[Uu]ranus|[Nn]eptune$/i,\
    \ @planets);\n    \n    # If planets are not in the system, return empty array\n\
    \    if (scalar(@planets) < 1) {\n        @planets = ();\n        return @planets;\n\
    \    }\n    \n    # Iterate through planets\n    foreach $planet1(@planets) {\n\
    \        $s1 = find_orbit_of($planet1);\n        $s2 = find_orbit_of($planet2);\n\
    \        for ($i = 0; $i <= $s1; $i++) {\n            for ($j = 0; $j <= $s2;\
    \ $j++) {\n                $p = $i + $j;\n                if ($p < 1 || $p > $s1\
    \ + $s2) {\n                    next;\n                }\n                $d =\
    \ $s1 * $s2 - $i * $j;\n                if ($d < 0) {\n                    $k\
    \ = $i + $s2;\n                } elsif ($d > 0) {\n                    $k = $i\
    \ + $s1;\n                } else {\n                    $k = $i;\n           \
    \     }\n                $k = abs($k);\n                if ($k > $s1 + $s2) {\n\
    \                    $k -= $s1;\n                } elsif ($k < $s1) {\n      \
    \              $k -= $s2;\n                }\n                push(@results, $planets[$k\
    \ - 1]);\n            }\n        }\n    }\n    return @results;\n}", "    return\
    \ grep { $_ ne \"Earth\" && $_ ne \"Mercury\" && $_ ne \"Venus\" && $_ ne \"Mars\"\
    \ && $_ ne \"Jupiter\" && $_ ne \"Saturn\" && $_ ne \"Uranus\" && $_ ne \"Neptune\"\
    \ } \n        grep { abs($planet1 - $_) <= 10 && abs($planet2 - $_) <= 10 } \n\
    \        qw/Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune/;\n}", "  \
    \  return @planets if $planet1 == $planet2;\n    if ($planet1 eq 'Mercury') {\n\
    \        push(@planets, \"Earth\");\n        push(@planets, \"Mars\");\n     \
    \   push(@planets, \"Jupiter\");\n        push(@planets, \"Saturn\");\n      \
    \  push(@planets, \"Uranus\");\n        push(@planets, \"Neptune\");\n    }\n\
    \    if ($planet1 eq 'Venus') {\n        push(@planets, \"Earth\");\n        push(@planets,\
    \ \"Mars\");\n        push(@planets, \"Jupiter\");\n        push(@planets, \"\
    Saturn\");\n        push(@planets, \"Uranus\");\n    }\n    if ($planet1 eq 'Earth')\
    \ {\n        push(@planets, \"Mars\");\n        push(@planets, \"Jupiter\");\n\
    \        push(@planets, \"Saturn\");\n        push(@planets, \"Uranus\");\n  \
    \  }\n    if ($planet1 eq 'Mars') {\n        push(@planets, \"Jupiter\");\n  \
    \      push(@planets, \"Saturn\");\n        push(@planets, \"Uranus\");\n    }\n\
    \    if ($planet1 eq 'Jupiter') {\n        push(@planets, \"Saturn\");\n     \
    \   push(@planets, \"Uranus\");\n    }\n    if ($planet1 eq 'Saturn') {\n    \
    \    push(@planets, \"Uranus\");\n    }\n    if ($planet1 eq 'Uranus') {\n   \
    \     push(@planets, \"Neptune\");\n    }\n    if ($planet1 eq 'Neptune') {\n\
    \        return @planets;\n    }\n    return;\n}", "    my @planets = ();\n  \
    \  \n    if ($planet1 eq $planet2) {\n        return @planets;\n    }\n    \n\
    \    # First we determine the orbital distance between the two planets. \n   \
    \ my $dist = calculate_distance($planet1, $planet2);\n    # Then we check all\
    \ the planets in the solar system. \n    foreach my $planet (@planets) {\n   \
    \     my @orbits = calculate_orbits($planet, $planet1);\n        foreach my $o\
    \ (@orbits) {\n            my $d = calculate_distance($planet, $o);\n        \
    \    if ($d < $dist) {\n                push(@planets, $planet);\n           \
    \     $dist = $d;\n            }\n        }\n    }\n    \n    if (@planets ==\
    \ 0) {\n        return;\n    }\n    \n    my @sorted = sort { $a <=> $b } @planets;\n\
    \    \n    return @sorted;\n}", '    my @planets;', "    my($planets, $planet1,\
    \ $planet2);\n    my(@planets1);\n    my(@planets2);\n    my(@planets1, @planets2,\
    \ $distance);\n    my($planet_1, $planet_2);\n    my($planet_1_orbit, $planet_2_orbit);\n\
    \    \n    # check for proper input, otherwise return empty array\n    if (!(@planets2\
    \ = split(/ /, $planet2))){\n        return @planets2;\n    }\n    \n    # initialize\
    \ planets array and planet1 orbit and planet2 orbit\n    @planets1 = ();\n   \
    \ @planets2 = ();\n    $planet_1 = $planet1;\n    $planet_2 = $planet2;\n    \n\
    \    # check for proper input, otherwise return empty array\n    if (!(@planets1\
    \ = split(/ /, $planet1))){\n        return @planets1;\n    }\n    \n    # find\
    \ the distance from the Sun to the planet\n    for ($i = 0; $i <; $i++){\n   \
    \     $planet_1_orbit = $planets1[$i];\n        $planet_2_orbit = $planets2[$i];\n\
    \        $distance = $planet_1_orbit + $planet_2_orbit;\n        if ($distance\
    \ < 6){\n            # planets are far from each other\n            if ($distance\
    \ == 0){\n                $distance = 1;\n            }\n            else {\n\
    \                # distance is greater than 1 so add $distance\n             \
    \   $distance += 1;\n            }\n        }\n        else {\n            # planets\
    \ are close to each other\n            $distance = 0;\n        }\n        # store\
    \ the planets closest to each other \n        if ($distance <= 1){\n         \
    \   push(@planets1, $planet_1);\n            push(@planets2, $planet_2);\n   \
    \     }\n        elsif ($distance >= 6){\n            push(@planets2, $planet_1);\n\
    \            push(@planets1, $planet_2);\n        }\n    }\n    # sort planets\
    \ based on their distance to the sun\n    sort(@planets1, sub { $a->distance <=>\
    \ $b->distance });\n    sort(@planets2, sub { $a->distance <=> $b->distance });\n\
    \    # return planets closest to the Sun \n    return @planets1[1..$#planets1];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this might be a correct answer,\
    \ please provide some explanation as to how your code works. If you have a new ",
  "    my %orbits;\n    my @planets = ();\n    my @orbits = ();\n    for (my $i =\
    \ $planet1; $i < $planet2; $i++) {\n        # if the planet exists in the solar\
    \ system add it to the \n        # array of planets that we will be looking up\n\
    \        if (exists $planets{$i}) {\n            push(@planets, $planets{$i});\n\
    \        }\n    }\n    # if the planets arrays size equals 0 then return an empty\
    \ array\n    if (@planets == 0) {\n        return;\n    }\n    # add planets to\
    \ the hash table\n    for my $planet (@planets) {\n        my $distance = planet_distance($planet);\n\
    \        my $latitude = planet_latitude($planet);\n        my $longitude = planet_longitude($planet);\n\
    \        my $orbit = planet_orbit($planet);\n        my $distance_to_sun = distance($latitude,\
    \ $longitude);\n        # if the distance between the planet and its orbit is\
    \ the same as\n        # or greater than the distance between the planet and its\
    \ \n        # nearest orbit\n        if ($distance <= $distance_to_sun || $distance\
    \ < $orbit) {\n            push(@orbits, $orbit);\n        }\n    }\n    foreach\
    \ my $orbit (@orbits) {\n        foreach my $planet (@planets) {\n           \
    \ my $distance = planet_distance($planet);\n            my $latitude = planet_latitude($planet);\n\
    \            my $longitude = planet_longitude($planet);\n            my $orbit\
    \ = planet_orbit($planet);\n            my $distance_to_sun = distance($latitude,\
    \ $longitude);\n            # if the distance between the planet and its orbit\
    \ is the same as\n            # or greater than the distance between the planet\
    \ and its\n            # nearest orbit\n            if ($distance <= $distance_to_sun\
    \ || $distance < $orbit) {\n                push(@orbits, $orbit);\n         \
    \   }\n        }\n    }\n    # return the sorted orbits\n    sort(@orbits);\n\
    }\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThis seems to work great for the\
    \ example planets, however if i try \"Sun\", \"Mars\" or \"Earth\" it gives me\
    \ a fatal error saying Undefined subroutine &main::planet_latitude at planet_distance.pl\
    \ line 29. Line 29 is where you have the foreach loop for ($i, $j) =\n<|/ c |>\n\
    <| c |>\nI changed it so that it takes in the planet name as string $planet instead\
    \ of ", "    $planet1 =~ m/([A-Z]{3})/;\n    $planet2 =~ m/([A-Z]{3})/;", "  \
    \  return @{\n        @{map { \n            my($lat1, $lon1) = @{$planet1} =~\
    \ m/([+-]?\\d+\\.\\d+)/;\n            my($lat2, $lon2) = @{$planet2} =~ m/([+-]?\\\
    d+\\.\\d+)/;\n            ($lon1 - $lon2) < 0 ? ($lon2 + $lon1) : ($lon1 - $lon2)\n\
    \        } qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune)\n    }\n\
    };", "    my(@orbit_array) = ();\n    \n    $planet1 =~ s/^\\s+//g;\n    $planet2\
    \ =~ s/^\\s+//g;\n    \n    # Check to see if the planets are correct\n    return\
    \ () if ($planet1 !~ /^[A-Za-z][A-Za-z]$/ || $planet2 !~ /^[A-Za-z][A-Za-z]$/);\n\
    \    \n    # Loop through each planet's orbits\n    foreach my $planet ([ $planet1,\
    \ $planet2]) {\n        # Check to see if the planet's orbit exists (the loop\
    \ won't be \n        # entered if it doesn't\n        foreach my $orbit (@{$planet_orbits[$planet]})\
    \ {\n            push(@orbit_array, $orbit) if $orbit > $sun_radius && $orbit\
    \ < 2 * $sun_radius;\n        }\n    }\n    \n    # Sort the orbits\n    my (@sorted_orbit_array)\
    \ = sort {\n        abs($a->[0] - $b->[0]) < $sun_radius\n            ? $a->[0]\
    \ <=> $b->[0]\n            : abs($a->[0] - $b->[0]) > $sun_radius\n          \
    \  ? $a->[0] <=> $b->[0]\n            : abs($a->[1] - $b->[1]) < $sun_radius\n\
    \            ? $a->[1] <=> $b->[1]\n            : abs($a->[1] - $b->[1]) > $sun_radius\n\
    \            ? $a->[1] <=> $b->[1]\n            : abs($a->[2] - $b->[2]) < $sun_radius\n\
    \            ? $a->[2] <=> $b->[2]\n            : abs($a->[2] - $b->[2]) > $sun_radius\n\
    \            ? $a->[2] <=> $b->[2]\n            : 0\n    } @orbit_array;\n   \
    \ \n    # Return the sorted orbits\n    return @sorted_orbit_array;\n}", "   \
    \ return if $planet1 eq $planet2;\n    return if $planet1 eq \"Mars\" || $planet1\
    \ eq \"Mercury\" || \n        $planet1 eq \"Earth\" || $planet1 eq \"Venus\" ||\
    \ \n        $planet1 eq \"Jupiter\" || $planet1 eq \"Saturn\" || \n        $planet1\
    \ eq \"Uranus\" || $planet1 eq \"Neptune\" || \n        $planet2 eq \"Mars\" ||\
    \ $planet2 eq \"Mercury\" || \n        $planet2 eq \"Earth\" || $planet2 eq \"\
    Venus\" || \n        $planet2 eq \"Jupiter\" || $planet2 eq \"Saturn\" || \n \
    \       $planet2 eq \"Uranus\" || $planet2 eq \"Neptune\";\n    my @planets_between\
    \ = ();\n    for my $planet (@planet1, @planet2) {\n        push @planets_between,\
    \ grep($_ eq $planet, @planet1);\n    }\n    \n    sort {\n        $a <=> $b if\
    \ ($a eq \"Mars\" || $a eq \"Mercury\" || $a eq \"Earth\" || \n              \
    \         $a eq \"Venus\" || $a eq \"Jupiter\" || $a eq \"Saturn\" || \n     \
    \                  $a eq \"Uranus\" || $a eq \"Neptune\" || $b eq \"Mars\" ||\
    \ \n                       $b eq \"Mercury\" || $b eq \"Earth\" || $b eq \"Venus\"\
    \ || \n                       $b eq \"Jupiter\" || $b eq \"Saturn\" || $b eq \"\
    Uranus\" || \n                       $b eq \"Neptune\");\n    } @planets_between;\n\
    }", "    my(@planets);\n    foreach my $planet (@planet_names){\n        if($planet1\
    \ eq $planet){\n            push(@planets, $planet1);\n        }elsif($planet2\
    \ eq $planet){\n            push(@planets, $planet2);\n        }\n    }\n    @planets\
    \ = sort_planets(@planets);\n    return @planets;\n}\nprint bf(\"Jupiter\", \"\
    Neptune\")\n</code>\n<|/ q dscore=1 |>\n<| a dscore=2 |>\nThis answer is a bit\
    \ long for a comment and may require some experimentation.  It will help to consider\
    \ two cases: \na) The planets are close enough (within a tolerance of a planet\
    \ radius)\nb) The planets are in different hemispheres.\na) Case (a): If you do\
    \ not want to consider planets in different hemispheres, you can simply use Euclidian\
    \ distance between them. This can be done by calculating the dot product of the\
    \ planet position vectors $v_1 = ($P_1 - $P_2) / norm($P_1 - $P_2)$ where $P_1\
    \ is the planet position and $P_2 is the planet position of the other planet (assuming\
    \ the planet is positioned at the origin). You will then compare this dot product\
    \ with the planet radius using a conditional (if/elsif) statement to determine\
    \ which planet has the shortest distance to any given planet.\nb) Case (b): You\
    \ can calculate the angle between each planet and each other. After that, you\
    \ will have to compare the angles based on the angle to the planet (which can\
    \ be calculated as $\\theta = acos(\\sqrt{a^2 + b^2})$). This can easily be done\
    \ by using the following formulas to calculate the angles between the planets\
    \ and then using the $acos$ function.\n<code>\n$a1 = degrees(acos(($x_1^2 + $y_1^2\
    \ + $z_1^2)/$r^2));\n$a2 = degrees(acos(($x_2^2 + $y_2^2 + $z_2^2)/$r^2));\n</code>\n\
    As a final note, be careful if you use the $r^2$ to calculate distance. In the\
    \ case of the Earth, which is located at the origin, there is a $r^2$ of $0.004$\
    \ which is very different than $0.005$. If your planets are located in different\
    \ hemispheres, it will be very different from each other.\n<|/ a tags=perl,algorithm\
    \ |>\n<|", "    if ($planet1 eq $planet2) {\n        return [$planet1, $planet2];\n\
    \    } else {\n        return ();\n    }\n}", "    my($planet1_orbit, $planet2_orbit,\
    \ $orbit1, $orbit2, $distance, $planet_name);\n    my($planets_array);", "   \
    \ my @planets = ();\n    foreach my $planet (@planet_name) {\n        my @distance\
    \ = distance($planet1, $planet2);\n        foreach my $d(@distance) {\n      \
    \      if ($planet < $d) {\n                push @planets, $planet;\n        \
    \    }\n        }\n    }\n    sort {\n        $a <=> $b\n    } @planets\n}", " \
    \   my (@orbit_names);\n    if ($planet1 eq $planet2) {\n        return @orbit_names;\n\
    \    }\n    foreach my $orbit_name(@orbits_of{$planet1}, @orbits_of{$planet2})\
    \ {\n        my $distance = distance($planet1, $planet2, $orbit_name);\n     \
    \   if ($distance <= $distance_sun) {\n            push(@orbit_names, $orbit_name);\n\
    \        }\n    }\n    return sort @orbit_names;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like that it is more efficient. I did not think it could be done in less than\
    \ O(n^2).\n<|/ c |>\n<| c |>\nThis was a great answer. Thanks.\n<|/ c |>\n<| a\
    \ dscore=0 tags=perl |>\nYou do need to find all planets within the radius of\
    \ one planet (Earth).\n<code>\nuse strict;\nuse warnings;", '    my %hash;', " \
    \   my @orbits = ();\n    my $planet1_orbits = planets_orbits($planet1);\n   \
    \ my $planet2_orbits = planets_orbits($planet2);\n    foreach my $planet (sort\
    \ {$a <=> $b} keys %$planet1_orbits) {\n        foreach my $planet_orbits (sort\
    \ {$a <=> $b} keys %$planet2_orbits) {\n            if ($planet_orbits == $planet)\
    \ {\n                push(@orbits, $planet);\n            }\n        }\n    }\n\
    \    foreach my $planet (sort {$a <=> $b} keys %$planet2_orbits) {\n        foreach\
    \ my $planet_orbits (sort {$a <=> $b} keys %$planet1_orbits) {\n            if\
    \ ($planet_orbits == $planet) {\n                push(@orbits, $planet);\n   \
    \         }\n        }\n    }\n    return @orbits;\n}", '    my @planets = ();',
  "    my @planets = ();\n    my $distance = 0;\n    foreach my $planet (@planet_names)\
    \ {\n        # Compute the distance between the planets\n        # http://en.wikipedia.org/wiki/Great-circle_distance\n\
    \        $distance = distance($planet1, $planet2, $planet);\n        if ($distance\
    \ > $planet_radius) {\n            push, $planet;\n        }\n    }\n    \n  \
    \  return sort {\n        # Sort by distance from sun\n        distance($planet1,\
    \ $planet2, $a) <=> distance($planet1, $planet2, $b) \n    } @planets;\n}", " \
    \   my(@orbits) = ();\n    \n    # Find orbits for each planet\n    $orbits[0]\
    \ = &orbit_planet($planet1);\n    $orbits[1] = &orbit_planet($planet2);\n    \n\
    \    # Order orbits\n    for ($i = 0; $i <; $i++) {\n        &sort_by_distance($orbits[$i],\
    \ $orbits[$i + 1]);\n    }", "    my @planets;\n    if(!($planet1 = lcfirst($planet1))||!($planet2\
    \ = lcfirst($planet2))){\n        die \"Wrong argument to bf(), both arguments\
    \ must be Planet names\\n\";\n    }\n    foreach my $planet (@planets) {\n   \
    \     if($planet1 eq $planet){ \n            $planet1 = $planet;\n           \
    \ $planets = @planets;\n            next;\n        }\n        if($planet2 eq $planet){\n\
    \            $planet2 = $planet;\n            $planets = @planets;\n         \
    \   next;\n        }\n        my $dist = distance($planet1, $planet2);\n     \
    \   if($dist < 0){\n            $planet = $planet1;\n            $planets = @planets;\n\
    \            next;\n        }\n        if($dist > 0){\n            $planet = $planet2;\n\
    \            $planets = @planets;\n            next;\n        }\n    }\n    push\
    \ (@planets, $planet1, $planet2);\n    return sort { distance($a,$b) <=> distance($b,$a)\
    \ } @planets;\n}", "    if(not exists $planets{$planet1}) {\n        return [];\n\
    \    }\n    if(not exists $planets{$planet2}) {\n        return [];\n    }\n \
    \   if($planet1 eq $planet2) {\n        return [$planet1];\n    }\n    if($planet1\
    \ eq \"Mercury\") {\n        if($planet2 eq \"Earth\") {\n            return [\"\
    Earth\", \"Mercury\", \"Venus\"];\n        }\n        return [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    }\n    if($planet1 eq\
    \ \"Venus\") {\n        if($planet2 eq \"Earth\") {\n            return [\"Earth\"\
    , \"Mercury\", \"Uranus\", \"Neptune\"];\n        }\n        return [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    }\n    if($planet1\
    \ eq \"Earth\") {\n        if($planet2 eq \"Mercury\") {\n            return [\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n        }\n      \
    \  return [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    }\n\
    \    if($planet1 eq \"Mars\") {\n        if($planet2 eq \"Jupiter\") {\n     \
    \       return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n        }\n\
    \        return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    }\n \
    \   if($planet1 eq \"Jupiter\") {\n        if($planet2 eq \"Saturn\") {\n    \
    \        return [\"Uranus\", \"Neptune\"];\n        }\n        return [\"Uranus\"\
    , \"Neptune\"];\n    }\n    if($planet1 eq \"Saturn\") {\n        if($planet2\
    \ eq \"Uranus\") {\n            return [\"Neptune\"];\n        }\n        return\
    \ [\"Neptune\"];\n    }\n    if($planet1 eq \"Uranus\") {\n        if($planet2\
    \ eq \"Neptune\") {\n            return [];\n        }\n        return [\"Neptune\"\
    ];\n    }\n    if($planet1 eq \"Neptune\") {\n        return [\"Neptune\"];\n\
    \    }\n}\n</code>\n<|/ q dscore=0 tags=arrays,perl,hash,perl-data-structures\
    \ |>\n<| c |>\nYour `bf` subroutine has a bug in it. You", "    if ($planet1 eq\
    \ \"Earth\" or $planet1 eq \"Mercury\" or $planet1 eq \"Venus\" \n        or $planet1\
    \ eq \"Mars\" or $planet1 eq \"Jupiter\" or $planet1 eq \"Saturn\" \n        or\
    \ $planet1 eq \"Uranus\" or $planet1 eq \"Neptune\" and $planet2 eq \"Earth\"\
    \ \n        or $planet2 eq \"Mercury\" or $planet2 eq \"Venus\" or $planet2 eq\
    \ \"Mars\" \n        or $planet2 eq \"Jupiter\" or $planet2 eq \"Saturn\" or $planet2\
    \ eq \"Uranus\" \n        or $planet2 eq \"Neptune\") {\n        return [];\n\
    \    } else {\n        return sort(@{ $planet1->{planets} }) \n            cmp\
    \ sort(@{ $planet2->{planets} }) \n    }\n}\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you very much for taking the time to write this code. Your code did exactly\
    \ what I was trying to accomplish. I appreciate you taking the time to do so.\n\
    <|/ c |>\n<| c |>\nNo problem! If this was the answer you were looking for, please\
    \ [accept](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ it. Thanks!\n<|/ c |>\n<| a tags=perl,hash,arrays,sorting |>\n<code>\nuse strict;\n\
    use warnings;\nuse 5.010;", "    return $planet1 if $planet1 eq $planet2;\n  \
    \  return $planet2 if $planet1 eq $planet2;\n    my @planets = ();\n    # your\
    \ code goes here\n    foreach my $planet ($planet1, $planet2){\n        my @planet_orbit\
    \ = ();\n        foreach my $planet_orbit (@orbits){\n            if($planet_orbit->[0]\
    \ =~ m/$planet/){\n                if($planet_orbit->[0] eq $planet2){\n     \
    \               push (@planet_orbit, $planet_orbit);\n                }\n    \
    \            elsif($planet_orbit->[0] eq $planet1){\n                    push\
    \ (@planet_orbit, $planet_orbit);\n                }\n            }\n        }\n\
    \        @planets = @planets, sort { $a->[1] cmp $b->[1] };\n    }\n    return\
    \ @planets;\n}\n</code>\n<|/ a |>\n<| c |>\n`if($planet_orbit->[0] =~ m/$planet/){`\
    \ should be `if($planet_orbit->[0] eq $planet){`\n<|/ c |>\n<| c |>\n: That's\
    \ right, I fixed it. I don't know why I missed it.\n<|/ c |>\n<| c |>\nBTW, there's\
    \ no need to store all the planets in `@planet_orbit` -- just `push` them when\
    \ you find them.  Then you can just use `sort { $a->[1] cmp $b->[1] }` to sort\
    \ them\n<|/ c |>\n<| c |>\n: You are right, I didn't even think of that, thanks!\
    \ I updated my answer.\n<|/ c |>\n<| c |>\nthank you very much, this is very helpful\
    \ and I learned a lot from it. I wish you guys all the best in your programming\
    \ journey!\n<|/ c |>\n<| a |>\nYour problem is that you're using a regexp to match\
    \ planets in the loop, but then using that regexp to match planets again in the\
    \ loop.  Just remove your regexp match in the inner loop, and it should work fine:\n\
    <code>\nforeach my $planet (@planets){\n    foreach my $planet_orbit (@orbits){\n\
    \        if($planet_orbit->[0] =~ m/$planet/){\n            push (@planet_orbit,\
    \ $planet_orbit);\n        }\n    }\n}\n</code>\n<|/ a tags=perl,regex,sorting\
    \ dscore", "    my @planets = ();\n    \n    my @orbits1 = &bf_planet_orbits($planet1);\n\
    \    my @orbits2 = &bf_planet_orbits($planet2);\n    \n    for my $orbit (@orbits1)\
    \ {\n        for my $orbit2 (@orbits2) {\n            if (abs($orbit - $orbit2)\
    \ <= $sun) {\n                push(@planets, $orbit);\n                push(@planets,\
    \ $orbit2);\n                last;\n            }\n        }\n    }\n    \n  \
    \  return sort { $a <=> $b } @planets;\n}\n</code>\n<|/ a tags=perl,arrays |>\n\
    <| c |>\nI like yours better than mine. :) One thing I noticed is that you do\
    \ not return the resulting array.\n<|/ c |>\n<| c |>\nWhoops! I copied my code\
    \ from the question without thinking! Thanks, I'll fix.\n<|/ c |>\n<| c |>\nIt's\
    \ also important to note that while these functions are much faster than's solutions,\
    \ I really think that the OP should do his own analysis to find out which of these\
    \ solutions is faster for his own purposes. His solution is very fast and probably\
    \ as fast as this one, but for someone else using his code, he's going to have\
    \ to figure out how to get the return values from these functions.\n<|/ c |>\n\
    <| c |>\n: I agree with you; but I'm not the OP, so I have to deal with that :)\n\
    <|/ c |>\n<| c |>\nThe OP is asking for the fastest code you can write, so I wanted\
    \ to point this out (for future readers) ;)\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  '    my %planets = ();', "    \n    # convert planet names into planet objects\n\
    \    my(@planets) = ();\n    foreach my $planet (@planet1, @planet2) {\n     \
    \   # convert planet name into planet object\n        $planet = find_planet($planet)\
    \ if !$planet || $planet eq 'None';\n        push(@planets, $planet);\n    }\n\
    \    \n    # convert planet objects into orbital objects\n    my(@orbits) = ();\n\
    \    foreach my $planet (@planets) {\n        foreach my $orbit (find_orbit($planet))\
    \ {\n            push(@orbits, $orbit);\n        }\n    }\n    \n    # sort orbits\
    \ by proximity to sun\n    @orbits = sort { $a->distance <=> $b->distance };\n\
    \    \n    # return empty array if planets not correct\n    return @planets ?\
    \ @planets : ();\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
