name: HumanEval_116_sort_array
language: pl
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
  \ -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4])\n\
  # [0, 1, 2, 3, 4]\nsub sort_array {\n    my($arr) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n\
  \        if(eq_deeply($candidate->([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2,\
  \ -3, -4, -5, -6]),[-4, -2, -6, -5, -3])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 2, 3, 4]),[0,\
  \ 1, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([2, 5, 77, 4, 5, 3, 5,\
  \ 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 6, 44, 12, 32,\
  \ 5]),[32, 3, 5, 6, 12, 44])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2,\
  \ 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    # Solution 1: Quick Sort\n    my $pivot = $arr[0];\n    my $left\
    \  = 0;\n    my $right = @$arr - 1;\n    while ($left <= $right) {\n        my\
    \ $check = $left + $right;\n        $check -= 1;\n        next if ($check == 0);\n\
    \        next if ($check > (@$arr - 2));", "    my @arr2;\n    my @ones;", '    my
    @sorted;', "    my @ret;\n    my $i = 0;\n    my $flag = 0;\n    for (my $i =\
    \ 0; $i < scalar(@$arr); $i++) {\n        my $j = 0;\n        $flag = 0;\n   \
    \     for (my $j = 0; $j < $i; $j++) {\n            $flag = $flag * 2 + ($arr[$j]\
    \ & 1);\n        }\n        push (@ret, (($flag > 0) ? $i : $i));\n    }\n   \
    \ sort {$a <=> $b} @ret;\n    return @ret;\n}", "    my $num_ones = 0;\n    my\
    \ $num_tens = 0;\n    my $i = 0;\n    my $j = 0;\n    my @arr1;\n    my @arr2;\n\
    \    my $tmp = 0;\n    while ($i < @$arr) {\n        $tmp = $arr->[$i];\n    \
    \    if ($tmp == 1) {\n            $num_ones++;\n            $arr2[$j] = $tmp;\n\
    \        } else {\n            $num_tens++;\n            $arr1[$j] = $tmp;\n \
    \       }\n        $i++;\n        $j++;\n    }\n    if ($num_ones > $num_tens)\
    \ {\n        @arr1 = @arr2[@arr1-1];\n    } else {\n        @arr2 = @arr1[@arr2-1];\n\
    \    }\n    @arr1;\n}", '    my $ones = $arr->[0] =~ tr/01//d;', "    my @sort;\n\
    \    my @counts;\n    my @min_values;\n    my @max_values;\n    my $count = 0;\n\
    \    my $min = -1;\n    my $max = -1;\n    foreach my $value ($arr) {\n      \
    \  push(@counts, 0 );\n        push(@sort,       $value);\n        push(@min_values,\
    \ $value);\n        push(@max_values, $value);\n    }\n    for ( my $i = 0; $i\
    \ < @counts-1; $i++ ) {\n        $counts[$i] += 1;\n        if ($counts[$i] >\
    \ 1) {\n            $counts[$i] = 1;\n            $min = -1 unless defined $min;\n\
    \            $min = $arr[$i] if $arr[$i] < $min;\n            $max = -1 unless\
    \ defined $max;\n            $max = $arr[$i] if $arr[$i] > $max;\n        }\n\
    \    }\n    for ( my $i = 0; $i < @counts-1; $i++ ) {\n        $counts[$i] +=\
    \ 1;\n        $sort[$i] = $min_values[$i] if $counts[$i] > 1;\n        $sort[$i]\
    \ = $max_values[$i] if $counts[$i] > 1;\n    }\n    return @sort;\n}", '    my(@sorted_arr);',
  "    my(@sorted)  = ();\n    my($bits)   = ();\n    my($none)  = 0;", "    my $result;\n\
    \    my $cnt = 0;\n    my $max_cnt;\n    my @res;\n    $max_cnt = @$arr >> 1;\n\
    \    for($i = 0; $i < $max_cnt; $i++) {\n        my $cur_cnt = $arr->[$i];\n \
    \       $cnt += $cur_cnt;\n        if($cnt < $max_cnt) {\n            $res[$i]\
    \ = $cur_cnt;\n        }\n        else {\n            $res[$i] = $cur_cnt - 1;\n\
    \            $cnt = 0;\n        }\n    }\n    for($i = 0; $i < @$arr; $i++) {\n\
    \        $res[$i] = $arr->[$i] if $cnt == $max_cnt;\n    }\n    $result;\n}",
  "    my(@sorted_arr);\n    my(@tmp);", "    my $max_num = -1;\n    my $min_num;\n\
    \    for my $value (@$arr) {\n\tif ($value < 0) {\n\t    push @$arr, abs($value);\n\
    \t    next;\n\t}\n\tmy $num_bits = $num_ones_in_binary($value);\n\tif ($num_bits\
    \ > $max_num) {\n\t    $max_num = $num_bits;\n\t}\n\tif ($num_bits < $min_num)\
    \ {\n\t    $min_num = $num_bits;\n\t}\n    }", "    return sort { $a <=> $b }\
    \ @$arr;\n}", "    my(@sort) = ();\n    my($cnt);\n    my($last);", "    my $len\
    \ = scalar @$arr;\n    my($i, $j, $temp);\n    @$arr = ();\n    for($i = 0; $i\
    \ < $len; $i++) {\n        $temp = pop(@$arr);\n        while(($i = $i-1) > 0\
    \ && $temp & $arr[$i]) {\n            $arr[$i+1] = $arr[$i];\n            $arr[$i]\
    \ = $temp;\n        }\n        $arr[$i+1] = $temp;\n    }\n    return @$arr;\n\
    }", "    my(@sorted_arr) = $arr;\n    my($total_one);\n    my(@sorted_arr);",
  "    my(@res);\n    for (my $i = 0; $i < $#arr; $i++) {\n        my $cnt = $arr[$i];\n\
    \        if ($cnt < 0) {\n            push (@res, -$cnt);\n            push (@res,\
    \ $i);\n        } else {\n            my $ones = \"\";\n            while (!($cnt\
    \ & 1)) {\n                $ones ++;\n                $cnt >>= 1;\n          \
    \  }\n            my $tmp = reverse $ones;\n            push (@res, int($cnt)\
    \ + int($tmp));\n        }\n    }\n    return @res;\n}", "    my @sorted;\n  \
    \  my $max = -1;\n    my $max_pos = -1;\n    for (my $i = 0; $i < @$arr; $i++)\
    \ {\n        my $val = $arr->[$i];\n        if ($val > $max) {\n            $max\
    \ = $val;\n            $max_pos = $i;\n        }\n    }\n    if ($max_pos == -1)\
    \ {\n        @sorted = @$arr;\n    } else {\n        my $val = $arr->[$max_pos];\n\
    \        for (my $i = 0; $i < @$arr; $i++) {\n            my $val = $arr->[$i];\n\
    \            if ($val > $max && $val > $val) {\n                $max = $val;\n\
    \                $max_pos = $i;\n            }\n        }\n        $val = $arr->[$max_pos];\n\
    \        for (my $i = 0; $i < @$arr; $i++) {\n            my $val = $arr->[$i];\n\
    \            if ($val > $max && $val > $val) {\n                $max = $val;\n\
    \                $max_pos = $i;\n            }\n        }\n        @sorted = sort\
    \ {$a <=> $b} @$arr;\n    }\n    return @sorted;\n}", "    if (@$arr == 1) {\n\
    \        return @$arr;\n    }\n    my @sorted = ();\n    my @ones_pos =();\n \
    \   my @ones_neg =();\n    my @sorted_ones =();\n    my %counts;\n    my $i =\
    \ 0;\n    my $n = @$arr;\n    for ($i = 0; $i < $n; $i++) {\n        my $v = $arr->[$i];\n\
    \        my $t = $v >> 31;\n        if ($t) {\n            $ones_pos->[$i];\n\
    \            $counts{$t}++;\n        } else {\n            $ones_neg->[$i];\n\
    \        }\n    }\n    $n = @$ones_pos;\n    for ($i = 0; $i < $n; $i++) {\n \
    \       my $t = $ones_pos->[$i];\n        $sorted_ones->[$i] = $t;\n    }\n  \
    \  $n = @$ones_neg;\n    for ($i = 0; $i < $n; $i++) {\n        my $t = $ones_neg->[$i];\n\
    \        $sorted_ones->[$i] = $t;\n    }\n    my @temp_ones = ();\n    for ($i\
    \ = 0; $i < $n; $i++) {\n        my $t = $sorted_ones->[$i];\n        $sorted_ones->[$i]\
    \ = $t;\n        push (@temp_ones, $t);\n    }\n    my @sorted_temp = sort();\n\
    \    for ($i = 0; $i < @sorted_temp; $i++) {\n        my $t = $sorted_temp[$i];\n\
    \        push (@sorted, $sorted_ones->[$i]);\n    }\n    $n = @$sorted_ones;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        my $t = $sorted_ones->[$i];\n    \
    \    $sorted_ones->[$i] = $t;\n        push (@sorted, $t);\n    }\n    return\
    \ @sorted;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis doesn't work for negative\
    \ numbers though.\n<|/ c |>\n<| c |>\nYes, I agree, but that was the OP's original\
    \ requirement. I just added the case for negative numbers. I tested it and the\
    \ negative numbers work. Try it. I will add another test to the answer.\n<|/ c\
    \ |>\n<| c |>\nThis isn't the way to sort a list according to a count. Also, sorting\
    \ a negative list according to a count is basically doing the same thing as sorting\
    \ an ordered list, so why not just use [`sort`](http://perldoc.perl.org/functions/sort.html)?\n\
    <|/ c |>", "    my $len = @$arr;\n    my $ones = 0;\n    my $dec = 0;\n    my\
    \ $key = 0;", "    return unless @$arr;\n    my $res = 0;\n    my $max_ones =\
    \ 0;\n    my $max_dec = 0;\n    for my $value (@$arr) {\n        $res = $value\
    \ if $res == 0;\n        if ($value & 1) {\n            $max_ones++;\n       \
    \     $max_dec = ($max_dec > $value) ? $max_dec : $value;\n        }\n       \
    \ else {\n            $max_ones--;\n        }\n    }\n    @$arr =\n        @$arr[0..$max_ones]\n\
    \        .sort { $a <=> $b } # Sort based on binary number\n        .sort { $a\
    \ <=> $b } # Sort based on decimal number\n        .reverse;\n    return @$arr;\n\
    }", "    my @sorted = ();\n    my $last;\n    my $key;", "    my(@sort) = (0,\
    \ 0);\n    my($tmp) = 0;\n    my $count = -1;\n    foreach my $num (@$arr) {\n\
    \        ++$count;\n        $tmp = ($count & 1) ? $num : $tmp * 2 + $num;\n  \
    \  }\n    $tmp = ($count & 1) ? $tmp * 2 : $tmp;", "    return unless @$arr;\n\
    \    my $sorted = [ sort {$a->[1] <=> $b->[1]} map { [$_, $arr->[$_]] } 0..$#$arr\
    \ ];\n    my $count = 0;\n    return map { $arr->[$_] = $sorted->[$_]->[1]; $count\
    \ += $sorted->[$_]->[0]; $count } 0..$#$sorted;\n}", "    my $size = @$arr;\n\
    \    my(@sorted);", "    my @copy = ();\n    my $count = 0;\n    my($zero, $one);\n\
    \    foreach my $val (@$arr) {\n        ($zero,$one) = $val & 0b1;\n        if\
    \ ($count == 0 || $zero != 0) {\n            $copy[$count] = $val;\n        }\n\
    \        $count++;\n    }\n    my @result = sort();\n    foreach my $i (0 .. $#copy)\
    \ {\n        if ($copy[$i] == $zero) {\n            $result[$i] = 0;\n       \
    \ } else {\n            $result[$i] = $copy[$i];\n        }\n    }\n    return\
    \ @result;\n}", "    my(@new_arr) = ();\n    my($tmp_arr);\n    my $i = 0;\n \
    \   my($j, @tmp_arr_copy);\n    my($tmp_arr_copy);\n    while ($i < @$arr) {\n\
    \        $j = 0;\n        $tmp_arr = $arr->[$i];\n        while ($j < (length\
    \ $tmp_arr) - 1) {\n            if ($tmp_arr->[$j] eq \"1\") {\n             \
    \   $tmp_arr_copy .= $tmp_arr->[$j++];\n                push @new_arr, $tmp_arr_copy;\n\
    \                $tmp_arr_copy = \"\";\n            } else {\n               \
    \ $tmp_arr_copy .= $tmp_arr->[$j++];\n            }\n        }\n        $i++;\n\
    \    }\n    my = @new_arr;\n    foreach my $value (@sorted_arr) {\n        push\
    \ @$arr, $value;\n    }\n}", "    my($sorted_arr = ());\n    my($num_ones);\n\
    \    my(@sorted_num_ones);\n    my($max_power);\n    my($power_offset);\n    my($sorted_num_ones_idx);",
  '    my %count = ();', "    if (@$arr > 1) {\n        my($n) = $arr->[0];\n    \
    \    for (my $i = 1; $i < @$arr; $i++) {\n            if ($arr->[$i] == $n) {\n\
    \                $n++;\n                next;\n            }\n            elsif\
    \ ($arr->[$i] < $n) {\n                push(@$arr, $n);\n                $n =\
    \ $arr->[$i];\n            }\n            else {\n                $n++;\n    \
    \        }\n            push(@$arr, $n);\n        }\n        push(@$arr, $n);\n\
    \    }\n    return $arr;\n}", "    my @index;\n    my $max = -1;\n    my $cur\
    \ = 0;\n    my $pos = 0;\n    my $cmp = 0;\n    for my $val (@$arr) {\n      \
    \  if ($val == 0) {\n            $pos = $pos + 1;\n        }\n        $cur = $cur\
    \ + int($val / 2);\n        if ($cur > $max) {\n            $max = $cur;\n   \
    \     }\n        push(@index, $pos);\n    }\n    @$arr = map { $arr->[$_] } @index;\n\
    \    my $i = 0;\n    for my $val (@$arr) {\n        if ($val != 0) {\n       \
    \     if ($val > $max) {\n                for ($i; $i <= $i; $i++) {\n       \
    \             $arr->[$i] = $arr->[$i] - 1;\n                }\n              \
    \  $arr->[$i] = $max - $val;\n            }\n            else {\n            \
    \    for ($i; $i <= $i; $i++) {\n                    $arr->[$i] = $arr->[$i] +\
    \ 1;\n                }\n                $arr->[$i] = $val - $max;\n         \
    \   }\n        }\n    }\n    return @$arr;\n}", "    $arr ||= [];\n    return\
    \ sort {\n        $a <=> $b\n    } @$arr;\n}", "    @$arr = sort {\n        my\
    \ %counts = ();\n        $counts{$b}++ while $b;\n        scalar $counts{$_} for;\n\
    \    } @$arr;\n    @$arr;\n}", "    my(@sorted);\n    my($ones) = $arr =~ /1/g;\n\
    \    foreach my $x (@$arr) {\n        $ones = $ones == 1 ? 1 : $ones - $x;\n \
    \       $sorted[$ones] = $x;\n    }\n    foreach my $x (@sorted) {\n        push,\
    \ $x;\n    }\n    return @sorted;\n}", "    my($len) = $arr->[$_] // 10 for 0\
    \ .. $arr->[-1];\n    my(@ret) = (0, 0);\n    for(my $i = $len; $i != 0; $i--)\
    \ {\n        my $count = 1;\n        for(my $j = 1; $j != 10; $j++) {\n      \
    \      if($arr->[$_ * 10 + $j] == 1) {\n                $count++;\n          \
    \  }\n        }\n        if($count == $len) {\n            push(@ret, $arr->[$_]);\n\
    \        } else {\n            push(@ret, $count);\n        }\n    }\n    my $ret\
    \ = '';\n    for(@ret) {\n        $ret .= $_ * $i;\n    }\n    return $ret;\n}",
  '    my($zeros, $ones, $arr_size, $size);', "    # Sort based on the number of ones\
    \ in the binary representation\n    # of the element\n    my(@sorted);\n    foreach\
    \ my $element (@$arr) {\n        my($bstr) = \"\";\n        foreach my $bit (split(\"\
    \", $element ? \"0$1\" : \"1$1\")) {\n            $bstr .= $bit if ($bit =~ /1/);\n\
    \        }\n        my($dec) = split(\"\", $bstr);\n        push(@sorted, $dec)\
    \ if (length($bstr) > 0);\n    }\n    @sorted = sort {$a<=>$b} @sorted;\n    @sorted\
    \ = reverse @sorted if @sorted > 0;\n    return @sorted;\n}", "    return sort\
    \ {\n        $_ == 1 ?\n            ($b - $a) : \n            $a <=> $b\n    }\
    \ @$arr;\n}", "    my @ret;\n    my $max_val;\n    my $cur_val;\n    for (my $idx\
    \ = 0; $idx < @$arr; $idx++) {\n        $max_val = $cur_val;\n        for (my\
    \ $i = 0; $i < $#{$arr}; $i++) {\n            $cur_val = (($arr->[$i] & $arr->[$i]\
    \ >> 1) != 0) ? 1 : 0;\n            $max_val = $max_val > $cur_val ? $max_val\
    \ : $cur_val;\n        }\n        push @ret, (($max_val == $cur_val) ? $max_val\
    \ : $cur_val);\n    }\n    return @ret;\n}", "    # Store the sorted array in\
    \ an auxiliary array.\n    my(@sorted_array);\n    # Iterate through the array\n\
    \    for (my $i = 0; $i < @$arr; ++$i) {\n        my($val, $num_ones) = ($arr->[$i],\
    \ 0);\n        # Find the number of 1's in binary representation of $val\n   \
    \     foreach my $bit (1 .. length($val)) {\n            push(@num_ones, ($val\
    \ & $bit == $bit) ? 1 : 0);\n            $val >>= 1;\n        }\n        if (@num_ones\
    \ == 0) {\n            # Append $val to the sorted array\n            push(@sorted_array,\
    \ $val);\n        } elsif (@num_ones == 1) {\n            # Append the decimal\
    \ value of the number $val\n            push(@sorted_array, $num_ones * 10 + $val);\n\
    \        } else {\n            # Sort the array based on num_ones\n          \
    \  sort_array_by_num_ones($num_ones, $i, $arr);\n        }\n    }\n    # Sort\
    \ the sorted array based on the value in reverse order\n    return sort {$a <=>\
    \ $b} @sorted_array;\n}", "    my @new_arr;\n    for (my $idx = 0; $idx < @$arr;\
    \ $idx++) {\n\tmy $bits_num = num2bits(@$arr[$idx]);\n\tfor (my $pos = $bits_num;\
    \ $pos > 0; $pos--) {\n\t    my $is_first = num2bits(($bits_num - $pos));\n\t\
    \    $is_first < 0 ? ($bits_num += 0x10000000000000000) :\n\t\t       ($bits_num\
    \ -= $is_first);\n\t}\n\t$bits_num < 0 ? ($bits_num = 0) :\n\t\t ($bits_num =\
    \ 0);\n\tpush(@new_arr, $arr[$idx]);\n    }\n    return @new_arr;\n}", "    my($zero);\n\
    \    my($one);\n    my($cmp);\n    my($sort);\n    my($i, $j, $n);\n    my($len);",
  '    my $len = scalar @$arr;', '    my(@ordered_arr) = ($arr);', "    my(@sorted_arr);\n\
    \    my($sort_val, $sort_order);\n    my($i, $cnt);\n    my(@tmp_sorted_arr);",
  "    $arr -> [0] = $arr -> [-1] = 0;\n    $arr -> [@_] or return $arr;\n    my @rev\
    \ = reverse @_;\n    my @tmp;\n    my $cnt = 1;\n    my @result;\n    my $cur;\n\
    \    foreach my $val (@$arr) {\n        if ($val eq $cnt or $val eq $cnt++) {\n\
    \            $cur = $val;\n            push @tmp, $cur;\n        }\n        else\
    \ {\n            if ($val < $cur) {\n                push @result, pop @tmp;\n\
    \            }\n            push @tmp, $val;\n        }\n    }\n    push @result,\
    \ pop @tmp;\n    return @result;\n}", "    my @sorted = ();\n    my ($i, $j, $n)\
    \ = (0, 0);", "    my @sorted_arr;\n    foreach my $i (@$arr) {\n        my $num_ones\
    \ = $i;\n        $num_ones =~ tr/0/1/;\n        my $num_dec = 0;\n        while\
    \ ($num_ones != 0) {\n            $num_dec += ($num_ones % 2);\n            $num_ones\
    \ = ($num_ones / 2);\n        }\n        $sorted_arr[$i] =$num_dec;\n    }\n \
    \   return @sorted_arr;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm,perl\
    \ |>\nAn alternate solution is to take the sum of the binary representation of\
    \ each number, and sort on the sum.\n<code>", "    my $sort_key = [];\n    my\
    \ $index = 0;\n    my $ones_counter;\n    my $num_ones;\n    my $zeros_counter;",
  "    my($arr_copy, $new_val);\n    my $sorted_arr = @$arr;\n    my $cnt;\n    my\
    \ $sort_cnt;\n    my $cnt2;\n    my $val1;\n    my $val2;\n    my $cmp;", '    my
    @sorted_arr = ();', "    my @new;\n    my $cnt;\n    my $max;\n    my $maxn;\n\
    \    my $maxd;", "    my(@ascending_numbers);\n    my($i, $j);\n    foreach my\
    \ $a (@$arr) {\n        if (! $a) {\n            push @ascending_numbers, 0;\n\
    \        } else {\n            for ($i = 0, $j = @ascending_numbers; $i < $j;\
    \ $i++) {\n                last if ($ascending_numbers[$i] > $ascending_numbers[$j]);\n\
    \            }\n            push @ascending_numbers, $a if ($i < $j);\n      \
    \      push @ascending_numbers, 0;\n        }\n    }\n    @$arr = map { $arr[$_]\
    \ if $arr[$_] } sort { $a <=> $b } @ascending_numbers;\n    return;\n}", '    my(@sorted)
    = ();', "    my(@ret);\n    my($max, $min, $i, $one, $bin, $dec);", "    my @ret;\n\
    \    my $tmp;\n    my @pos;\n    for (my $idx = 0; $idx < @$arr; $idx++) {\n \
    \       if ($arr->[$idx] == 1) {\n            $tmp = $arr->[$idx];\n         \
    \   push @pos, $idx;\n            push @ret, $tmp;\n            delete $arr->[$idx];\n\
    \        }\n    }\n    for (my $idx = 0; $idx < @$arr; $idx++) {\n        if ($arr->[$idx]\
    \ == 0) {\n            if (@pos == 0) {\n                push @ret, $tmp = $arr->[$idx];\n\
    \                delete $arr->[$idx];\n            } else {\n                my\
    \ $min_idx = pop @pos;\n                if ($arr->[$min_idx] > $arr->[$idx]) {\n\
    \                    $tmp = $arr->[$idx];\n                    push @ret, $tmp;\n\
    \                    $arr->[$idx] = $arr->[$min_idx];\n                    $arr->[$min_idx]\
    \ = $tmp;\n                } else {\n                    $tmp = $arr->[$min_idx];\n\
    \                    push @ret, $tmp;\n                    $arr->[$min_idx] =\
    \ $arr->[$idx];\n                    $arr->[$idx] = $tmp;\n                }\n\
    \            }\n        }\n    }\n    return @ret;\n}", "    my @arr;\n    my\
    \ $ones = 0;\n    my $dec = 0;\n    my @ret;\n    for my $val (@$arr) {\n    \
    \    $ones = $val % 2;\n        $dec = $val / 2;\n        push @arr, $dec if $ones\
    \ != 0;\n    }\n    if (@arr) {\n        my $sort_func = $ones ? \\&sort_array_asc\
    \ : \\&sort_array_dec;\n        @ret = map { $sort_func($_) } @arr;\n    }\n \
    \   return @ret;\n}", "    @{$arr} = sort { $$a <=> $$b } @{$arr};\n}", "    my\
    \ (@results);\n    \n    foreach my $number (@$arr) {\n        $number = $number\
    \ == 0 ? 0 : $number;\n        push (@results, $number) if length($number) ==\
    \ 1;\n        push (@results, $number if $number eq '1');\n        push (@results,\
    \ $number if $number eq '0');\n    }\n    return sort { $a <=> $b };\n}", "  \
    \  my($count);\n    my($sum);\n    foreach my $num (@$arr) {\n        $sum = 0;\n\
    \        $count = 0;\n        for (my $i = 0; $i < $MAX_VAL; $i++) {\n       \
    \     if ($num == $i) {\n                $sum += 1;\n                $count++;\n\
    \            }\n        }\n        if ($count == 0) {\n            $count = $sum;\n\
    \        }\n        if ($count == 1) {\n            push @$arr, $sum;\n      \
    \  } else {\n            my $idx = $count + $sum - $MAX_VAL;\n            my $pos\
    \ = $sum;\n            while (1) {\n                my $idx2 = $idx + $pos;\n\
    \                if ($idx2 >= $MAX_VAL) {\n                    push @$arr, $sum\
    \ - $pos;\n                    last;\n                }\n                $idx++;\n\
    \                $pos++;\n            }\n        }\n    }\n    return $arr;\n}",
  "    # use $arr to do the work\n}", "    my(@counts) = ();\n    foreach $a (@$arr)\
    \ {\n        push (@counts, 0);\n        for ($i = $a; $i > 0; $i >>= 1) {\n \
    \           ++$counts[$i];\n        }\n    }\n    my($zero, $one, $i, $j);\n \
    \   my $sorted_indexes = [];\n    while ((@counts) > 1) {\n        foreach $i\
    \ (@counts) {\n            for ($j = $i; $j < @counts; $j++) {\n             \
    \   next unless $counts[$j] == $i;\n                # swap $i to $j\n        \
    \        ($counts[$i], $counts[$j]) = ($counts[$j], $counts[$i]);\n          \
    \      for ($i; $i > 0; $i >>= 1) {\n                    if ($counts[$i] == 0)\
    \ {\n                        $zero++;\n                        $counts[$i] = $counts[$i]\
    \ >> 1;\n                        $counts[$j] |= 1;\n                    }\n  \
    \                  elsif ($counts[$i] == 1) {\n                        $one++;\n\
    \                        $counts[$i] &= ~1;\n                    }\n         \
    \           else {\n                        last;\n                    }\n   \
    \             }\n            }\n        }\n        for (@counts) {\n         \
    \   if ($i == 0) {\n                $zero--;\n                $i = $i >> 1;\n\
    \            }\n            elsif ($i == 1) {\n                $one--;\n     \
    \       }\n            else {\n                last;\n            }\n        }\n\
    \        push (@$sorted_indexes, $j - 1);\n    }\n    my $index = 0;\n    foreach\
    \ $i (@$arr) {\n        if (($counts[$i] & 1) != 0) {\n            push (@$sorted_indexes,\
    \ $index);\n            $index++;\n        }\n    }\n    return @$sorted_indexes;\n\
    }", "    # Write your solution here\n    my @ret;\n    my $count = $#{$arr}+1;\n\
    \    my $i = 0;\n    my $last = 0;\n    while(my $i < $#{$arr}) {\n        if($arr->[$i]\
    \ == 1) {\n            if($i != $last) {\n                push (@ret, $arr->[$last]);\n\
    \                $last = $i;\n            }\n            $i++;\n        }\n  \
    \      elsif($arr->[$i] > 1) {\n            my $j = $i;\n            for(my $k=0;$k\
    \ <= $#{$arr} && $j < $k;$k++) {\n                $j += $arr->[$k]; #count\n \
    \           }\n            my $tmp = $arr->[$i];\n            for(my $j=1;$j <=\
    \ $arr->[$i]; $j++) {\n                my $tmp2 = $arr->[$j];\n              \
    \  for(my $k=0;$k <= $#{$arr} && $j < $k;$k++) {\n                    $arr->[$k]\
    \ = $arr->[$k] - $tmp2;\n                }\n                $arr->[$i] = $tmp;\n\
    \            }\n            $i = $j-1;\n        }\n        else {\n          \
    \  $i++;\n        }\n    }\n    for(my $j=$#{$arr};$j >= 0;$j--) {\n        if($arr->[$j]\
    \ == 1) {\n            push (@ret, $arr->[$j]);\n        }\n    }\n    return\
    \ @ret;\n}", "    my @nums = @$arr;\n    my @sorted = ();\n    my @reversed =\
    \ ();\n    my $count = scalar(@nums);", "    my @res;\n    my $cnt = 0;\n    my\
    \ $max = 0;\n    foreach my $x (@$arr) {\n        if ($cnt < $max) {\n       \
    \     if ($cnt == 1) {\n                push(@res, $x);\n            } else {\n\
    \                push(@res, $cnt);\n            }\n            $cnt = $cnt+1;\n\
    \        } else {\n            if ($cnt == $max) {\n                $cnt += ($x\
    \ & 1);\n                if ($cnt > $max) {\n                    $max = $cnt;\n\
    \                }\n            } else {\n                $cnt += ($x & 1);\n\
    \            }\n        }\n    }\n    return @res;\n}", "    @$arr = sort {\n\
    \        ($arr[$a] & 1) <=> ($arr[$a] & 2) <=> ($arr[$a] & 4) <=> ($arr[$a] &\
    \ 8) \\\n        <=> ($arr[$a] & 16) <=> ($arr[$a] & 32) <=> ($arr[$a] & 64) <=>\
    \ \\\n        ($arr[$a] & 128) <=> $arr[$a] - $arr[$a]\n    } @$arr;\n    return;\n\
    }", "    my($rev) = reverse $arr;\n    my(@sort) = ();\n    \n    # Find first\
    \ index of element where number of ones is 0\n    my($start) = index($arr, $arr[0])\
    \ if $arr[0];\n    # Find first index of element where number of ones is 1\n \
    \   my($end) = index($arr, $arr[$#arr]) if $arr[$#arr];\n    \n    # Iterate through\
    \ the array and find index of next zero element\n    for (my $i = $start; $i <\
    \ $end; $i++) {\n        my($pos) = index($rev, $rev[$i]);\n        push(@sort,\
    \ $arr[$i]) if $pos < 0;\n    }\n    \n    # Return sorted array\n    return @sort;\n\
    }", "    return if scalar @$arr > 1;\n    my $i = 1;\n    $arr[$i] = 0;\n    my\
    \ $max = 0;\n    my $count = 0;\n    foreach my $num (@$arr) {\n        $count\
    \ = $num + $i;\n        $arr[$i] = $num;\n        if ( $num == 1 ) {\n       \
    \     $count = $num + $i;\n            $arr[$i] = $count;\n        }\n       \
    \ if ( $count > $max ) {\n            $max = $count;\n        }\n        $i++;\n\
    \    }\n    foreach my $num (@$arr) {\n        $count = $num + $i;\n        $arr[$i]\
    \ = $count;\n    }\n    if ( $max < scalar @$arr ) {\n        foreach my $num\
    \ (@$arr) {\n            $count = $num + $i;\n            $arr[$i] = $count;\n\
    \        }\n        $max = $max;\n    }\n    @$arr = sort { $a <=> $b } @$arr;\n\
    }", '    my @sorted;', "    my $zero = @$arr;\n    my $ones = sort { $a <=> $b\
    \ };\n    my $min = $zero;\n    my @sorted_array = ();\n    foreach my $i (0..$#{$ones})\
    \ {\n        my $n_ones = $ones->[$i];\n        if ($n_ones == $min) {\n     \
    \       push @sorted_array, shift @$ones;\n            delete $ones->[$i];\n \
    \       } else {\n            foreach my $j ($i..$#{$ones}) {\n              \
    \  my $cur_n_ones = $ones->[$j];\n                if ($cur_n_ones == $n_ones)\
    \ {\n                    $min = $n_ones;\n                    push @sorted_array,\
    \ shift @$ones;\n                    delete $ones->[$j];\n                   \
    \ last;\n                }\n            }\n        }\n    }\n    if (@$ones >\
    \ $min) {\n        push @sorted_array, shift @$ones;\n        delete $ones->[$min];\n\
    \    }\n    return \\@sorted_array;\n}", '    my($num, $dec) = (1, 1);', "   \
    \ my @ret = ();\n    my $ones = 0;\n    my $dec = \"\";\n    my $i = 0;\n    my\
    \ $len = @$arr;", '    my $res = 0;', "    $arr //= 0;\n    $arr |= 0x80;\n  \
    \  my @a = map { ($_ =~ /1/g) ? ($_ & 0x7f) : (-$_ & 0x7f) } @_;\n    my $i =\
    \ 0;\n    my $j = 0;\n    my @ret;\n    my $tmp;\n    while (@a > 0) {\n     \
    \   my $n = shift(@a);\n        if ($n < 0) {\n            $tmp = -$n;\n     \
    \       $n = ~$n;\n            $tmp = ~$tmp;\n        }\n        $j++;\n     \
    \   while ($j < ($i) and ($n & $a[$j] != 0)) {\n            $ret[$i++]  = $a[$j++];\n\
    \        }\n        $j++;\n        while ($j == $i and ($n & $a[$j] != 0)) {\n\
    \            $ret[$i++]  = $a[$j++];\n        }\n        $ret[$i++]  = $n;\n \
    \   }\n    return @ret;\n}", "    my @res;\n    my $cnt;\n    my @bins;\n    for\
    \ my $i (0 .. $#$arr) {\n        # compute how many 1's are in ith bit\n     \
    \   $cnt = $i << 1;\n        if ($cnt >= @$bins) {\n            # first time we\
    \ encounter a set bit\n            $bins[$cnt] = 1;\n        } else {\n      \
    \      # add this bit to the set bits of previous bits\n            $bins[$cnt]\
    \ += $bins[$cnt - 1];\n        }\n        # check if this set bit has occurred\
    \ in any element\n        foreach my $j (0 .. $#$arr) {\n            if ($arr[$j]\
    \ & $cnt) {\n                push (@res, $$arr[$j]);\n                $cnt = 0;\n\
    \            }\n        }\n    }\n    return @res;\n}\n</code>\n<|/ a dscore=0\
    \ tags=perl,sorting |>\n<| a dscore=0 |>\nOne simple approach would be to use\
    \ a Schwartzian transform:\n<code>", "    my $len = @$arr;\n    if ($len == 0)\
    \ {\n        return;\n    }\n    my $max_ones = 0;\n    my $sum = 0;\n    my $i\
    \ = 0;\n    while ($i < $len) {\n        my $val = $arr->[$i];\n        $max_ones\
    \ = $max_ones * 2 + $val % 2;\n        $sum += $val;\n        $i++;\n    }\n \
    \   $max_ones = $max_ones / 2;\n    $sum = $sum / 2;\n    my $i = 0;\n    while\
    \ ($i < $len) {\n        my $val = $arr->[$i];\n        if ($val % 2 != 0) {\n\
    \            $arr->[$i] = $sum - $val;\n        } else {\n            $arr->[$i]\
    \ = $max_ones - $val;\n        }\n        $i++;\n    }\n}", "    my @res;\n  \
    \  foreach my $num (@$arr) {\n        push(@res, $num) if ($num eq $num);\n  \
    \      push(@res, $num) if (($num & 1) == 0);\n    }\n    return sort {\n    \
    \    $a <=> $b } @res;\n}", "    my $i = 0;\n    my $len = scalar @$arr;\n   \
    \ my $j = 0;\n    my $len2 = scalar @$arr;\n    while (1) {\n        if ($len2\
    \ == 0) {\n            return $arr;\n        }\n        my $swap = $arr[$i];\n\
    \        my $swap2 = $arr[$j];\n        my $swap3 = ($swap ^ $swap2);\n      \
    \  if ($swap & 1) {\n            if ($swap3 > 0) {\n                $swap2 = $swap3\
    \ >> 1;\n                $swap3 &= $swap2;\n            } else {\n           \
    \     $swap2 = $swap3 >> 1;\n                $swap3 &= ($swap2 >> 1);\n      \
    \          if ($swap3 > 0) {\n                    $swap2 &= $swap3;\n        \
    \        } else {\n                    $swap2 = $swap3;\n                }\n \
    \           }\n        } else {\n            if ($swap3 > 0) {\n             \
    \   $swap2 = $swap3 ^ $swap;\n                $swap3 &= $swap2;\n            }\
    \ else {\n                $swap2 = $swap3 ^ $swap;\n                $swap3 &=\
    \ ($swap2 ^ 0xffff);\n                if ($swap3 > 0) {\n                    $swap2\
    \ &= $swap3;\n                } else {\n                    $swap2 = $swap3;\n\
    \                }\n            }\n        }\n        $arr[$i] = $swap2;\n   \
    \     $arr[$j] = $swap;\n        $i++;\n        $j++;\n        $len2--;\n    \
    \    if ($len2 == 0) {\n            return $arr;\n        }\n    }\n}", "    my\
    \ @sorted;\n    my @bits;\n    my $len = 0;\n    foreach my $b (@$arr) {\n   \
    \     $len = $b if $b > $len;\n    }\n    $len = 1 if $len == 0;\n    for my $i\
    \ (0 .. $len-1) {\n        my $ones = 0;\n        for my $b (@$arr) {\n      \
    \      $ones = $b if $b > $i;\n        }\n        my $dec = 0;\n        $dec +=\
    \ $ones if $ones == 1;\n        $dec += $ones if $ones == 2;\n        $dec +=\
    \ $ones if $ones == 4;\n        $dec += $ones if $ones == 8;\n        $dec +=\
    \ $ones if $ones == 16;\n        $dec += $ones if $ones == 32;\n        $dec +=\
    \ $ones if $ones == 64;\n        $dec += $ones if $ones == 128;\n        push(@sorted,\
    \ $dec);\n    }\n    @sorted = sort {$a <=> $b} @sorted;\n    return @sorted;\n\
    }", "    my @sorted = ();\n    my $count = pop(@$arr);\n    for (@$arr) {\n  \
    \      my $binary = $_ eq $count ? 1 : 0;\n        push(@sorted,\n           \
    \ $binary < 0 ? -$binary : @sorted + $binary - $count);\n        $count--;\n \
    \   }\n    return @sorted;\n}", "    my @temp;\n    my($i, $j);\n    my @sorted;\n\
    \    my $max;\n    my $max2;\n    my $cmp;\n    my $cmp2;\n    my $temp2;\n  \
    \  my $temp_max;\n    my @pos;\n    my @neg;\n    for (my $i = 0 ; $i < @$arr\
    \ ; $i++) {\n        if ($arr->[$i] < 0) {\n            push(@neg, $i);\n    \
    \    } else {\n            push(@pos, $i);\n        }\n    }\n    @pos = sort\
    \ {\n        $a <=> $b if ($a < $b) || ($a == $b and $a <=> 0);\n    } @pos;\n\
    \    @neg = sort {\n        $a <=> $b if ($a < $b) || ($a == $b and $a <=> 0);\n\
    \    } @neg;\n    $max = @pos == 0 ? 0 : $pos->[0];\n    $max = $max < $#arr ?\
    \ $max : $#arr;\n    $pos = sort {\n        $a <=> $b if ($a < $b) || ($a == $b\
    \ and $a <=> 0);\n    } @pos;\n    $max2 = $pos->[0] < $max ? $pos->[0] : $max;\n\
    \    foreach $i (0 .. $max) {\n        if ($i eq $max) {\n            $cmp = +$arr->[$max];\n\
    \            $cmp2 = $arr->[$max2];\n        } else {\n            $cmp = $arr->[$i];\n\
    \            $cmp2 = $arr->[$pos->[$i]];\n        }\n        $cmp2 = $cmp2 < 0\
    \ ? -1 : $cmp2 > 0 ? 1 : 0;\n        if ($cmp2 eq 0) {\n            $cmp = $cmp;\n\
    \            $cmp2 = $arr->[$i];\n        }\n        push(@temp, $cmp);\n    \
    \    push(@temp2, $cmp2);\n    }\n    $cmp = +$temp->[0];\n    $cmp2 = $temp2->[0];\n\
    \    if ($cmp2 eq 0) {\n        $cmp = $cmp;\n    }\n    push(@sorted, $cmp);\n\
    \    my $i = 0;\n    my $j = 0;\n    my $flag;\n    my $flag2;\n    foreach $i\
    \ ( 0 .. $max - 1 ) {\n        push(@sorted, $temp->[$i]);\n        $flag = 1;\n\
    \        foreach $j ( $i + 1 .. $max2 ) {\n            $flag2 = 1;\n         \
    \   foreach $flag2 ( 0 .. $#temp2 ) {\n                if ($temp->[$i] eq $temp2->[$flag",
  "    my $num_ones = 0;\n    my @new;\n    my $last_two;", "    my(@result);\n  \
    \  my($none);\n    \n    foreach my $x (@$arr) {\n        my($count) = @{$x =~\
    \ /./ig};\n        \n        if (!$count) {\n            $none++;\n        }\n\
    \        else {\n            push(@result, $x);\n        }\n    }\n    \n    @result\
    \ = sort {\n        ($a <=> $b) if ($a =~ /./ig && $b =~ /./ig);\n        ($a\
    \ =~ /./ig cmp $b =~ /./ig) if ($a =~ /./ig && $b =~ /./ig);\n        $a <=> $b\n\
    \    } @result;\n    \n    if ($none == $#arr) {\n        @result;\n    }\n  \
    \  else {\n        @result;\n    }\n}", "    my @ret;\n    my @tmp;\n    my $min\
    \ = 0;\n    my $max = 0;\n    my $i = 0;\n    for (my $j = $#arr; $j >= 0; $j--)\
    \ {\n        if (($arr[$j] & 1) > 0) {\n            $tmp[$i] = $arr[$j];\n   \
    \         $i++;\n        }\n    }\n    $min = scalar @tmp;\n    for (my $j = $#tmp;\
    \ $j >= 0; $j--) {\n        $arr[$j] = $tmp[$j];\n    }\n    for (my $j = $#arr;\
    \ $j >= 0; $j--) {\n        if ($arr[$j] == 0) {\n            $ret[$j] = $min;\n\
    \        }\n        elsif ($arr[$j] == 1) {\n            $ret[$j] = $max;\n  \
    \      }\n        else {\n            my $c = $min * 2 + 1;\n            $ret[$j]\
    \ = $c;\n            $c += $arr[$j] - 1;\n            $max = $c if ($c > $max);\n\
    \        }\n    }\n    push @ret, $min;\n    return @ret;\n}", "    my($rev_arr);\n\
    \    my($ones_count);", "    $arr->[@_] =~ tr/0+/0 ;\n    my @sort = sort { $a\
    \ <=> $b };\n    map { $arr->[$_] = $sort[$_] } 0..$#sort;\n    return;\n}", " \
    \   my $n = @$arr;\n    my @res;\n    for(my $i = 0; $i < $n; ++$i) {\n      \
    \  my $bin = '';\n        for(my $j = 0; $j < $i; ++$j) {\n            my $d =\
    \ $arr[$i] & $arr[$j];\n            $bin .= $d ? '1' : '0';\n        }\n     \
    \   push @res, $bin if $bin;\n    }\n    for(my $i = $n; $i < @$arr; ++$i) {\n\
    \        push @res, $arr[$i];\n    }\n    return @res;\n}", "    @{$arr} = sort\
    \ {$a <=> $b} @{$arr};\n    return @$arr;\n}", "    # return value\n    my $value;",
  "    my $min = @$arr;\n    my $max = 0;\n    my $max_bits = 0;\n    foreach my $num\
    \ (@$arr) {\n        $max = $num if $num > $max;\n        $max_bits = length($num\
    \ * '0'.'1');\n        $min = 1 if ($num < $min);\n    }\n    my $diff = abs($max\
    \ - $min);\n    my $max_pow = ($diff + 1);\n    my @sort_array;\n    foreach my\
    \ $num (@$arr) {\n        my $pos = 0;\n        my $num_pos = $num / pow(2, $pos);\n\
    \        my $num_neg = $num - $num_pos * pow(2, $pos);\n        my $num_pos_bits\
    \ = length($num_pos * '0'.'1');\n        my $num_neg_bits = length($num_neg *\
    \ '0'.'1');\n        if ($num_pos_bits < $num_neg_bits) {\n            $pos =\
    \ 1;\n        }\n        my $bit_count = max($max_bits, $max_pow, $num_pos_bits,\
    \ $num_neg_bits);\n        if ($bit_count == $max_bits) {\n            push(@sort_array,\
    \ $num_pos);\n        } else {\n            push(@sort_array, $num_neg);\n   \
    \     }\n    }\n    return @sort_array;\n}", '    my(@ret);', '    my(@sort) =
    ();', "    my @ret = ();\n    my $size = scalar @$arr;\n    for (my $i=0; $i<$size;\
    \ ++$i) {\n        if ($arr->[$i] eq '1') {\n            push(@ret, pop(@$arr));\n\
    \        } else {\n            push(@ret, scalar(@$arr) - $i);\n        }\n  \
    \  }\n    return @ret;\n}", '    my @ret;', '    my($sort) = @_ > 1;', '    my(@sorted);',
  '    my @sorted = ();', "    my(@sorted);\n    my(@ones);\n    my(@dec);", "   \
    \ my @sorted = ();\n    my($i, $j, $k, $cnt);", '    my(@sorted, $i, $j, $num,
    $temp);', "    my(@sorted_arr) = ();\n    my($i, $count);\n    foreach $i (@$arr)\
    \ {\n        $count = 0;\n        foreach $j (@$arr) {\n            if ($i !=\
    \ $j) {\n                $count += ($j =~ /1/g);\n            }\n        }\n \
    \       $sorted_arr[$i] = $count;\n    }\n    foreach $i (@$sorted_arr) {\n  \
    \      @$sorted_arr[$i] =~ s/^0// if $i =~ /1/;\n    }\n    return \\@sorted_arr;\n\
    }", '    # $arr is a copy', "    my($num_ones) = @_;\n    my($dec) = @_;\n   \
    \ my($dec_inc = '0');", "    my $count; $count = 0;\n    for (@$arr) {\n\t$count\
    \ += $_;\n    }\n    my @res = ();\n    for (@$arr) {\n\tpush @res, $_ if $_ >\
    \ 1;\n    }\n    return @res;\n}", "    if (@$arr == 1) {\n        return $arr[0];\n\
    \    }\n    my(@arr);\n    foreach my $num (@$arr) {\n        my $str = sprintf(\"\
    %b\", $num);\n        foreach my $pos (length($str) - 1) {\n            my $count\
    \ = 0;\n            foreach my $digit (split('', $str)) {\n                $count\
    \ += $digit eq '1';\n            }\n            push @arr, $count if $count ==\
    \ 0;\n        }\n    }\n    return sort_array(@arr);\n}", "    my $size = scalar\
    \ @$arr;\n    my $ones = $size - grep $_ == 1, @$arr;\n    my $dec;\n    if ($ones\
    \ > 0) {\n        $dec = $ones;\n    } else {\n        $dec = $size-$ones;\n \
    \   }\n    @$arr = sort { $a <=> $b } map {\n        my $bin = $_;\n        my\
    \ $len = length($bin);\n        return $dec if $len == $dec;\n        return $len\
    \ <=> $dec if $len == $ones;\n        return $bin cmp $bin;\n    } @$arr;\n}",
  "    \n    my @sorted = ();\n    my @ones = ();\n    my @zeroes = ();\n    foreach\
    \ my $val (@$arr) {\n        my $len = length($val);\n        if ($len == 0) {\n\
    \            $zeros++;\n        }\n        else {\n            $zeros--;\n   \
    \         my $is_one = ($val & 1) > 0;\n            if ($is_one) {\n         \
    \       $ones++;\n                my $i = $len - 1;\n                while ($i\
    \ > 0) {\n                    my $j = $len - $i;\n                    push (@sorted,\
    \ $val);\n                    $val = substr($val, 0, $i) & substr($val, $j);\n\
    \                    $len -= $i;\n                    $i--;\n                }\n\
    \            }\n            else {\n                my $i = 0;\n             \
    \   while ($i < $len) {\n                    my $j = $i + 1;\n               \
    \     push (@sorted, $val);\n                    $val = substr($val, $i, 1) &\
    \ substr($val, 0, $j);\n                    $len -= $i;\n                    $i\
    \ += $j;\n                }\n            }\n        }\n    }\n    \n    return\
    \ @sorted;\n}", '    my @res;', '    my(@sorted) = ();', "    my($sorted_array);\n\
    \    my($num_ones_array);\n    my($decimal);", "    my(@res) = ();\n    my($sign,\
    \ $digit, $i);\n    my $i = 0;\n    $i = $#{$arr}; # save index of last element\n\
    \    while($i) {\n        $i = $i - 1; # index for popping element\n        $sign\
    \ = ($arr[$i] & 1) != 0;\n        next if $sign && $sign != $sign;\n        $digit\
    \ = $arr[$i] & 15;\n        push(@res, $digit);\n        $arr[$i] &= ~$digit;\n\
    \        last if ($arr[$i] & 1) == 0;\n    }\n    return @res;\n}", "    my($ones)\
    \ = $arr =~ /1/g;\n    my($sort) = $ones == 0 ? sub {\n        my($a) = $_;\n\
    \        return $a <=> sub {\n            my($b) = $a;\n            return $a\
    \ <=> $b unless $a =~ /0/g && $b =~ /0/g;\n            my ($c) = $a =~ /0/g;\n\
    \            my ($d) = $b =~ /0/g;\n            return $c <=> $d unless $c =~\
    \ /0/g && $d =~ /0/g;\n            return $a <=> $b <=> $c unless $a =~ /0/g &&\
    \ $b =~ /0/g;\n            return $c <=> $d;\n        }\n    }\n    : : $ones\
    \ == 1 ? sub {\n        my($a) = $_;\n        return $a <=> sub {\n          \
    \  my($b) = $a;\n            return $a <=> $b unless $a =~ /0/g && $b =~ /0/g;\n\
    \            my $c = $a =~ /0/g;\n            my $d = $b =~ /0/g;\n          \
    \  return $c <=> $d unless $c =~ /0/g && $d =~ /0/g;\n            return $a <=>\
    \ $b;\n        }\n    }\n    : : $ones == 2 ? sub {\n        my($a) = $_;\n  \
    \      return $a <=> sub {\n            my($b) = $a;\n            return $a <=>\
    \ $b unless $a =~ /0/g && $b =~ /0/g;\n            my ($c) = $a =~ /0/g;\n   \
    \         my ($d) = $b =~ /0/g;\n            return $c <=> $d unless $c =~ /0/g\
    \ && $d =~ /0/g;\n            return $a <=> $b <=> $c;\n        }\n    }\n   \
    \ : : $ones == 4 ? sub {\n        my($a) = $_;\n        return $a <=> sub {\n\
    \            my($b) = $a;\n            return $a <=> $b unless $a =~ /0/g && $b\
    \ =~ /0/g;\n            my ($c) = $a =~ /0/g;\n            my ($d) = $b =~ /0/g;\n\
    \            return $c <=> $d unless $c =~ /0/g && $d =~ /0/g;\n            return\
    \ $a <=> $b <=> $c <=> $d;", '    my(@result);', "    return @$arr;\n}", "   \
    \ my(@sorted_arr) = (0, ());\n    my($count, $i);", "    my ($i, $j) = (0, 0);\n\
    \    for ($i = 0; $i < @$arr; $i++) {\n        my $flag = $arr->[$i] & 1;\n  \
    \      if ($flag == 1) {\n            if ($j < $i) {\n                my $tmp\
    \ = $arr->[$j];\n                $arr->[$j] = $arr->[$i];\n                $arr->[$i]\
    \ = $tmp;\n            }\n            $j++;\n        }\n    }\n    return @$arr;\n\
    }", '    my(@sorted);', "    my @ret;\n    my $max_ones = 0;\n    my $max_dec\
    \ = 0;\n    my $max_idx = 0;\n    my $prev_binary = \"\";\n    my $prev_dec =\
    \ 0;\n    for my $i (0..@$arr - 1) {\n        my $ones = $arr->[$i];\n       \
    \ if ($prev_bin eq \"\") {\n            $prev_binary = $ones;\n            $prev_dec\
    \ = 1;\n        } else {\n            my $binary = $ones;\n            if ($prev_bin\
    \ ne $ones) {\n                if ($prev_bin ne \"0\") {\n                   \
    \ $binary = $prev_bin;\n                } else {\n                    $binary\
    \ = $prev_dec;\n                }\n            }\n            my $dec = $prev_dec;\n\
    \            $dec += $ones;\n            $max_ones = $ones if $ones > $max_ones;\n\
    \            $max_dec = $dec if $dec > $max_dec;\n            $max_idx = $i;\n\
    \        }\n        my $bin = $binary;\n        $bin .= $bin;\n        my $dec\
    \ = $dec;\n        $dec += $ones;\n        if ($prev_bin ne $bin) {\n        \
    \    $ret[$i] = $bin;\n        } else {\n            $ret[$i] = $dec;\n      \
    \  }\n        $prev_bin = $binary;\n        $prev_dec = $dec;\n    }\n    foreach\
    \ my $i (0..$max_idx - 1) {\n        my $ones = $arr->[$i];\n        my $bin =\
    \ $ones;\n        $bin .= $bin;\n        my $dec = $dec;\n        $dec += $ones;\n\
    \        if ($prev_bin ne $bin) {\n            $ret[$i] = $bin;\n        } else\
    \ {\n            $ret[$i] = $dec;\n        }\n        $prev_bin = $binary;\n \
    \       $prev_dec = $dec;\n    }\n    return @ret;\n}", "    my(@arr);\n    my($i,\
    \ $j, $k, $cnt);\n    foreach (@$arr) {\n        $cnt = 0;\n        $k += 1;\n\
    \        $j = 0;\n        while ($k) {\n            if ($cnt > 1 && ($arr[$i]\
    \ & $k)) {\n                push(@arr, $arr[$i]);\n                splice(@arr,\
    \ $i, 1);\n                $k -= 1;\n                $cnt -= 1;\n            \
    \    $j += 1;\n            } else {\n                push(@arr, $arr[$i]);\n \
    \               $cnt += 1;\n                $i += 1;\n                $k -= 1;\n\
    \            }\n        }\n        $arr[$i] = $j;\n    }\n    return @arr;\n}",
  "    # sort in place to avoid a temporary array.\n    my $i = @$arr - 1;\n    my\
    \ $j = 0;\n    for (my $j = 0; $j < $i; $j++) {\n        if ($arr->[$j] > 0) {\n\
    \            my $tmp = $arr->[$j];\n            $arr->[$j] = $arr->[$i];\n   \
    \         $arr->[$i] = $tmp;\n        }\n        $j++;\n    }\n    return $arr;\n\
    }\n</code>\nTest cases\n<code>\nuse Test::More tests => 4;\nok( sort_array([1,\
    \ 5, 2, 3, 4]) == sort_array([1, 2, 3, 4, 5]), \"Test 1\");\nok( sort_array([-2,\
    \ -3, -4, -5, -6]) == sort_array([-6, -5, -4, -3, -2]), \"Test 2\");\nok( sort_array([1,\
    \ 0, 2, 3, 4]) == sort_array([0, 1, 2, 3, 4]), \"Test 3\");\nok( sort_array([1,\
    \ 9, 9, 9, 8]) == sort_array([1, 9, 8, 9, 9]), \"Test 4\");\n</code>\n<|/ a dscore=4\
    \ tags=perl,sorting,arrays |>\n<| c |>\n`@a <=> $b` does a `cmp` internally. Also\
    \ `@a - $b` will do the job\n<|/ c |>\n<| c |>\nYes, `<=>` and `cmp` do `cmp`.\
    \ `cmp` was added to Perl in 5.10 and `<=>` was added to Perl in 5.8.\n<|/ c |>\n\
    <| c |>\nI tested `<=>` and `cmp` and it did not work. `cmp` works with my 5.10.1,\
    \ `<=>` doesn't work with 5.10.1.\n<|/ c |>\n<| c |>\n5.10.1 had it right.  `cmp`\
    \ returns -1, 0, 1 instead of -1, 0, and 1 like it did in earlier versions.  In\
    \ Perl 5.10.1, `cmp` returns -1, 0, 1 like it did in earlier versions.  In Perl\
    \ 5.10.0, `cmp` returns -1, 0, and 1.\n<|/ c |>\n<| c |>\n5.10.0 has it wrong,\
    \ too. I had to upgrade to 5.10.1 to get the test to pass.\n<|/ c |>\n<| a dscore=3\
    \ |>\nUsing a Schwartzian transform is nice, but can get expensive if there are\
    \ many elements.  This version does not use a Schwartzian transform.\n<code>",
  '    my $sorted = 0;', "    $arr->sort(sub {\n        if ($a % 2 == 1) {\n     \
    \       ($a < $b) ? -1 : 1;\n        } else {\n            $a <=> $b;\n      \
    \  }\n    });\n    return @$arr;\n}", '    @$arr = @{$arr} if @$arr;', '    my(@res);',
  "    my(@new_arr);\n    my($i, $n, $sign);\n    my($signBit);\n    \n    my $i =\
    \ 0;\n    $n = 0;\n    $signBit = 0;\n    foreach $a (@$arr) {\n        # skip\
    \ zero and negative\n        if ($a < 0) {\n            if ($signBit) {\n    \
    \            $signBit = 0;\n                push(@new_arr, $a);\n            }\n\
    \            ++$n;\n        } else {\n            $signBit = 1;\n            ++$n;\n\
    \        }\n    }\n    \n    foreach (@new_arr) {\n        # check if number of\
    \ ones in binary representation is same\n        if ($signBit) {\n           \
    \ push(@$arr, $a);\n        }\n        $signBit = 0;\n        $n = 0;\n      \
    \  ++$i;\n    }\n    return @$arr;\n}", "    my @tmp_arr;\n    my $flag = 1;\n\
    \    for (my $i = 0, $j = @$arr - 1; $i < $j; $i++) {\n        push(@tmp_arr,\
    \ $i);\n        if ($flag) {\n            if ($arr->[$i] eq 0) {\n           \
    \     $flag = 0;\n                push(@tmp_arr, $arr->[$i]);\n            }\n\
    \        }\n    }\n    push(@tmp_arr, $j);\n    return @tmp_arr;\n}", "    my($len)\
    \ = scalar(@$arr);\n    my(@sort) = ();\n    my($i);", "    if (scalar @$arr ==\
    \ 0) {\n        return;\n    }\n    # sort in descending order\n    @$arr = sort\
    \ {\n        my $x = $b;\n        $x = $a ^ $x if $a < $x;\n        $x\n    }\
    \ reverse @$arr;\n    @$arr;\n}", "    my $n = scalar(@$arr);\n    my @res;\n\
    \    my $ones = 0;\n    my $dec = 0;", '    my(@sorted_arr) = ();', "    my($n)\
    \ = 0;\n    my(@ret);\n    my $size = @$arr;\n    for (my $i = 0; $i < $size;\
    \ $i++) {\n        if ($arr->[$i] == 1) {\n            $ret[$n++] = $i;\n    \
    \    }\n    }\n    if ($n == 0) {\n        @ret = (sort { $a <=> $b } @$arr);\n\
    \    } else {\n        @ret = (sort { $a <=> $b } @$arr);\n        @ret = @ret[0..$n];\n\
    \    }\n    return @ret;\n}", "    # do some code here\n    my @tmp_arr;\n   \
    \ my %tmp_hash;\n    my @tmp_result;\n    for my $num (@$arr) {\n        $tmp_hash{$num}++\
    \ if $num =~ /^1(\\d)$/;\n        $tmp_arr[$tmp_hash{$num}} = $num if $num =~\
    \ /^1(\\d)$/;\n    }\n    @tmp_result = sort { $a <=> $b } @tmp_arr;\n    return\
    \ @tmp_result;\n}", '    my ($l, $r);', "    $arr = sort(@$arr);\n    return @$arr;\n\
    }\n</code>\n<|/ a tags=arrays,perl,sorting |>\n<| a tags=arrays,perl,sorting dscore=1\
    \ |>\n<code>", "    my @sorted = ();\n    my $i = 0;\n    my $j = 0;\n    my $tmp\
    \ = 0;\n    my @sorting_list = ();\n    my $last_count = 0;\n    foreach my $value\
    \ (@$arr) {\n        my $bin = 0;\n        my $dec = 0;\n        my $count_one\
    \ = 0;\n        while ($value != 0) {\n            if ($value == 1) {\n      \
    \          $count_one++;\n                my $tmp = $value;\n                $value\
    \ = $tmp % 2;\n                $bin++;\n            } elsif ($value == -1) {\n\
    \                $bin = -$bin;\n                $dec = -$dec;\n              \
    \  $count_one--;\n            } else {\n                last;\n            }\n\
    \        }\n        $sorting[$j++] = $tmp;\n        $sorting_list[$last_count++]\
    \ = $bin;\n        $sorting_list[$last_count++] = $dec;\n        $sorting[$j++]\
    \ = $count_one;\n    }\n    foreach my $index (0..$#sorted) {\n        $sorted[$index]\
    \ = $sorting[$index];\n    }\n    foreach my $index ($#sorted - 0..$#sorting_list)\
    \ {\n        $sorted[$index] = $sorting_list[$index];\n    }\n    return @sorted;\n\
    }", "    my $n = @$arr;\n    my @res = ();", "    my $len = scalar @$arr;\n  \
    \  return [] if $len <= 0;\n    my $max = 0;\n    my $i = $len;\n    my $j = -1;\n\
    \    my $s = \"\";\n    while ($i != 0) {\n        $s = \"\";\n        $s = $arr[$i]\
    \ if ($arr[$i] > 0);\n        $s = $arr[$i] if $arr[$i] == 0;\n        $max =\
    \ $arr[$i] if $arr[$i] > $max;\n        $max = 1 if $arr[$i] == 0;\n        my\
    \ $t = $arr[$i];\n        $arr[$i] = $arr[$j];\n        $arr[$j] = $t;\n     \
    \   $i--;\n        $j--;\n    }\n    my $t = reverse @$arr;\n    return $t;\n}",
  "    my(@counts);\n    \n    foreach my $i (0 .. $#{$arr}) {\n        if ($arr->[$i]\
    \ & 1) {\n            $counts[$i] += 1;\n        }\n    }\n    \n    foreach my\
    \ $i (0 .. $#{$arr}) {\n        if ($counts[$i] == 0) {\n            my $tmp =\
    \ $arr->[$i];\n            push @{$arr->[$i]}, $arr->[$i];\n            $arr->[$i]\
    \ = $tmp;\n        }\n    }\n    \n    @$arr = sort { $b->[0] cmp $a->[0] } @$arr;\n\
    }", "    my(@sorted);\n    my $index = 0;\n    for(my $i = 0; $i < @$arr; $i++)\
    \ {\n        my $ones = $arr->[$i] & 1;\n        if($ones > 0) {\n           \
    \ push(@sorted, $arr->[$i]);\n        }\n        $index++;\n    }", "    my @sorted\
    \ = ();\n    my $size = 1;\n    foreach my $item (@$arr) {\n        if ($item\
    \ eq $0) {\n            $size++;\n        }\n        else {\n            push\
    \ @sorted, $item * $size;\n            $size = 1;\n        }\n    }\n    return\
    \ @sorted;\n}", '    my($size);', "    return sort { $arr->[$a] >= $arr->[$b]\
    \ ? -1 : ($arr->[$a] <=> $arr->[$b]); } @$arr;\n}", "    my @sorted = sort { $a\
    \ <=> $b } map {\n        $_ == 1 ? substr($_, -1) : $_\n    } @$arr;\n    @$arr\
    \ = @sorted;\n}", "    $arr ||= [];\n    return sort { $a <=> $b } @$arr;\n}",
  "    if (@$arr == 0) return (@$arr);\n    my $count = 0;\n    my $max = 0;\n   \
    \ my $i = 0;\n    for my $ele (@$arr) {\n        $count = $ele == 1 ? 1 : 0;\n\
    \        $max = $ele > $max ? $ele : $max;\n        $arr[$i] = $count;\n     \
    \   $i++;\n    }\n    my $j = 0;\n    while ($i < @$arr) {\n        $arr[$i] =\
    \ $arr[$i] > 1 ? $j : 0;\n        $i++;\n        $j++;\n    }\n    return @$arr;\n\
    }", "    my @sorted_arr = ();\n    my $i = 0;\n    my $len = 0;\n    while (my\
    \ $elem = shift @$arr) {\n        my $digit = 0;\n        while ($elem & 1) {\n\
    \            $elem >>= 1;\n            $digit += 1;\n        }\n        $sorted_arr[$len]\
    \ = $digit;\n        $len++;\n    }\n    my $min_idx = $i;\n    while (my $j =\
    \ $len - 1; $j >= $min_idx; $j--) {\n        for (my $k = $j; $k >= $i; $k--)\
    \ {\n            if ($sorted_arr[$k] > $sorted_arr[$k+1]) {\n                my\
    \ $tmp = $sorted_arr[$k];\n                $sorted_arr[$k] = $sorted_arr[$k+1];\n\
    \                $sorted_arr[$k+1] = $tmp;\n            }\n        }\n    }\n\
    \    return @sorted_arr;\n}", "    my @tmp;\n    my $len = @$arr;\n    my $bits\
    \ = 0;\n    my $max = 0;\n    foreach my $n (@$arr) {\n        $bits = $bits +\
    \ ($n & 1);\n        $max = 1 if ($bits > $max);\n    }\n    foreach my $i (0\
    \ .. $len-1) {\n        my $cnt = 0;\n        foreach my $n (@$arr) {\n      \
    \      if ($n & 1) {\n                $cnt++;\n            }\n        }\n    \
    \    if ($cnt == $max) {\n            push(@tmp, $i);\n        }\n    }\n    return\
    \ @tmp;\n}", "    my %cnt;\n    foreach my $e ($arr) {\n        my $k = ord($e);\n\
    \        if ($cnt{$k}) {\n            if ($cnt{$k} > 1) {\n                my\
    \ $tmp = sort($cnt{$k} / 2);\n                for (my $i = 0; $i < $cnt{$k} /\
    \ 2; $i++) {\n                    my $x = $cnt{$k} - 1 - $i;\n               \
    \     next unless $x % 2 == 0;\n                    my $y = $cnt{$k} - 1 - $tmp\
    \ - $i;\n                    $cnt{$k} = $y;\n                }\n            }\n\
    \            $cnt{$k}++;\n        } else {\n            $cnt{$k} = 1;\n      \
    \  }\n    }\n    return map {$_ * $cnt{$_}} (0..$#{$cnt{$_}} - 1) for keys %cnt;\n\
    }", "    # Find index of first 1\n    my $idx = 0;\n    for (my $i = 0; $i < @$arr;\
    \ $i++) {\n        if ($arr->[$i] eq 1) {\n            $idx = $i;\n          \
    \  last;\n        }\n    }\n    push @$arr, $arr->[$idx] while $idx < @$arr;\n\
    \    my $max = 0;\n    my @sorted;\n    for (my $i = 0; $i < @$arr; $i++) {\n\
    \        if ($arr->[$i] > $max) {\n            $sorted = ();\n            $max\
    \ = $arr->[$i];\n        }\n        $sorted->[$i] = $arr->[$i];\n    }\n    return\
    \ @sorted;\n}", "    my @res;\n    # First find the right position for each 1\
    \ in the array\n    # then sort them and push to res\n    for (my $i = 0; $i <\
    \ @$arr; $i++) {\n        my @tmp = ();\n        for (my $j = 0; $j < $i; $j++)\
    \ {\n            if ($arr->[$j] == 1) {\n                push(@tmp, sprintf(\"\
    %0*d\", $i, $j));\n            }\n        }\n        push(@res, @tmp);\n    }\n\
    \    @res = sort{$a->[0] <=> $b->[0]} @res;\n    # Sort the numbers and put them\
    \ back in the array\n    for (my $i = 0; $i < @$arr; $i++) {\n        my @tmp\
    \ = ();\n        for (my $j = 0; $j < $i; $j++) {\n            push(@tmp, substr($res[$j][0],\
    \ $j, $i));\n        }\n        push(@$arr, @tmp);\n    }\n    return $arr;\n}",
  "    my @ret;\n    my $i = -1;\n    my $pos = 0;\n    while (++$i < @$arr) {\n \
    \       my $ones = 0;\n        my $carry = 0;\n        for my $j (0 .. $#$arr)\
    \ {\n            my $jpos = $j + $i;\n            next if $jpos < 0;\n       \
    \     $carry = 0 if $arr->[$jpos] & 1;\n            $ones++;\n            my $c\
    \ = $carry ? $carry - 1 : -$carry;\n            $carry = $ones if $jpos - 1 ==\
    \ @$arr;\n            $carry = 1 if ($jpos - 1 < 0) || ($arr->[$jpos] & 1);\n\
    \            $pos++ if $c == 0;\n            $carry = 1 if ($jpos - 1 < 0) ||\
    \ ($arr->[$jpos] & 1);\n        }\n        push @ret, $carry ? $carry - 1 : -$carry\
    \ if $ones;\n    }\n    push @ret, $pos;\n    return \\@ret;\n}", "    my @a =\
    \ ();\n    my @b = ();\n    my $c;\n    my $m;", "    my $sorted = [];\n    foreach\
    \ my $number (@$arr) {\n        push @$sorted, [\n            $number == 0 ? 0\
    \ : $number == 1 ?\n                -($number == 2 ? 1 : 0) :\n              \
    \  ($number == 2 ? 1 : 0) <=>\n                ($number == 3 ? 1 : 0) <=>\n  \
    \              ($number == 4 ? 1 : 0) <=>\n                ($number == 5 ? 1 :\
    \ 0) <=>\n                ($number == 6 ? 1 : 0),\n            $number,\n    \
    \    ];\n    }\n    sort { $a->[0] <=> $b->[0] } @$sorted;\n}", "    my($count);\n\
    \    my($dec);\n    my($idx);\n    my(@sorted = ());\n    for ($idx = 0; $idx\
    \ < @$arr; $idx++) {\n        my $x = $arr->[$idx];\n        $count += ($x eq\
    \ 1) ? 1 : $x == 2? 2 : 4;\n        if ($count < $dec) {\n            $dec = $count;\n\
    \            $idx = $idx;\n        }\n    }\n    push (@sorted,\n    $arr->[$idx],\n\
    \    $arr->[$idx],\n    $arr->[$idx],\n    $arr->[$idx],\n    $arr->[$idx]);\n\
    \    for ($idx = 0; $idx < (@$arr - 1); $idx++) {\n        my $y = $arr->[$idx\
    \ + 1];\n        $count += ($y eq 1) ? 1 : $y == 2? 2 : 4;\n        last if ($count\
    \ < $dec);\n        push @sorted,\n        $arr->[$idx],\n        $arr->[$idx\
    \ + 1],\n        $y,\n        $arr->[$idx + 2],\n        $arr->[$idx + 3];\n \
    \   }\n    return @sorted;\n}", "    $arr //= 0;\n    my @res;\n    my @counter\
    \ = ();\n    for (my $i = 0, $j = 1; $i <= $#arr; $i++) {\n        next unless\
    \ $arr[$i];\n        my $num = $arr[$i];\n        my $count = 0;\n        for\
    \ (my $k = 0; $k < $#counter; $k++) {\n            if ($counter[$k] == $num) {\n\
    \                $count++;\n                last if $count == $j;\n          \
    \  }\n        }\n        push @counter, $num if $count == $j;\n        push @res,\
    \ $num;\n        $j++;\n    }\n    @res = sort { $counter[$a] <=> $counter[$b]\
    \ } @res;\n    return @res;\n}", "    my @sorted = map $_->[0], sort(map { $arr->[$_]\
    \ => 1 } 0..$#arr);\n    return @sorted;\n}", "    my @sorted_arr = ();\n    my\
    \ $sorted_index = -1;\n    my $num_ones = 0;\n    for(my $i = 0; $i < scalar(@$arr);\
    \ $i++) {\n        if($arr[$i] eq '1') {\n            ++$num_ones;\n        }\
    \ else {\n            ++$sorted_index;\n            push (@sorted_arr,\n     \
    \           $sorted_index\n            );\n            $num_ones = 1;\n      \
    \  }\n    }", '    my($rslt);', "    my(@temp) = ();\n    my($i, $n);\n    @temp[0]\
    \ = $arr[0];\n    $n = $arr[0];\n    foreach $i (1..$#$arr) {\n        if ($arr[$i]\
    \ & 1) {\n            push(@temp, $n);\n            $n = $arr[$i];\n        }\
    \ else {\n            push(@temp, $arr[$i]);\n        }\n    }\n    push(@temp,\
    \ $n);\n    return @temp;\n}", "    my @copy = @$arr;\n    my $size = scalar(@copy);\n\
    \    if ($size <= 1) {\n        return @copy;\n    }\n    my $max_index = scalar(@copy)\
    \ - 1;\n    my $min_index = 0;\n    my $max_count = 0;\n    my $min = 0;\n   \
    \ my $i = 0;\n    my $j = 0;\n    my $k;\n    # find the highest number of ones\
    \ in current binary string\n    foreach $k (1..$size) {\n        my $count = 0;\n\
    \        my $index = intdiv($copy[$i], 2);\n        $index = $index + $min_index;\n\
    \        foreach my $j ($min..$max) {\n            $count = $count + 1 if $copy[$j]\
    \ == $index;\n        }\n        $max_count = $count if $max_count < $count;\n\
    \        $min = $index if $min < $index;\n    }\n    my $tmp;\n    foreach $k\
    \ (1..$size) {\n        my $count = 0;\n        my $index = intdiv($copy[$i],\
    \ 2);\n        $index = $index + $min_index;\n        foreach my $j ($min..$max)\
    \ {\n            $count = $count + 1 if $copy[$j] == $index;\n        }\n    \
    \    my $tmp = $copy[$i];\n        $copy[$i] = $copy[$j];\n        $copy[$j] =\
    \ $tmp;\n        $i++;\n        $j++;\n        if ($i >= $size) {\n          \
    \  $i = 0;\n        }\n        if ($j >= $size) {\n            $j = 0;\n     \
    \   }\n    }\n    # sort the current array\n    my $tmp;\n    my @res;\n    foreach\
    \ $i (0..$max_index) {\n        my $count = 0;\n        foreach $k (1..$size)\
    \ {\n            my $index = intdiv($copy[$i], 2);\n            $index = $index\
    \ + $min_index;\n            $count = $count + 1 if $copy[$k] == $index;\n   \
    \     }\n        my $value = $copy[$i];\n        $copy[$i] = $copy[$max_index];\n\
    \        $copy[$max_index] = $value;\n        $res[$count] = $value;\n    }\n\
    \    foreach $i ($max_index..$size - 1) {\n        $res[$i] = $copy[$i];\n   \
    \ }\n    return @res;\n}", "    my(@ascending_order);\n    my(@descending_order);\n\
    \    my($i, $j, $temp);", "    my(@sorted_arr);\n    my($zero, $one, $one_to_two,\
    \ $two_to_four, $four_to_eight, $eight_to_sixteen, $sixteen_to_one);", '    my(@sorted);',
  '    my($tmp, $ones, $bin);', '    my $size = scalar($arr);', "    my(@rev_ary);\n\
    \    my $l = @$arr;\n    my @ones = ();\n    my $cnt = 0;\n    my $sum = 0;\n\
    \    for(my $i=0; $i<$l; $i++) {\n        my $v = $arr->[$i];\n        if($v eq\
    \ \"1\") {\n            push(@ones, $v);\n        } else {\n            my $one\
    \ = sprintf \"0%db\", $v;\n            my $zero = sprintf \"0%db\", $cnt;\n  \
    \          my $tmp = $one . $zero;\n            $sum++;\n            my $rev =\
    \ int(substr($tmp,-1));\n            $cnt += $v;\n            push(@rev_ary, $rev);\n\
    \        }\n    }\n    my $cmp;\n    if ($sum == 0) {\n        $cmp = @ones;\n\
    \    } elsif ($sum == 1) {\n        $cmp = @ones == 1 ? $ones[0] : $ones[0] cmp\
    \ $ones[1];\n    } elsif ($sum == $l) {\n        $cmp = @ones == 1 ? $ones[0]\
    \ : $ones[0] cmp $ones[$l - 1];\n    } else {\n        $cmp = @rev_ary == 1 ?\
    \ $rev_ary[0] : $rev_ary[0] cmp $rev_ary[$l - 1];\n    }\n    @$arr = @ones;\n\
    \    @rev_ary = reverse @rev_ary;\n    return @$arr;\n}", '    my(@ret) = ();',
  "    my(@result) = ();\n    my($cnt);\n    \n    $cnt = $#arr;\n    my $prev;\n\
    \    for (my $i = 0; $i < $cnt; $i++) {\n        if ($arr[$i] == 0) {\n      \
    \      push (@result, $prev);\n            $prev = $arr[$i];\n        }\n    \
    \    else {\n            my $tmp = $arr[$i];\n            my $j;\n           \
    \ for ($j = $i; $j < $cnt; $j++) {\n                if ($arr[$j] == 1) {\n   \
    \                 $tmp += $arr[$j];\n                    $cnt--;\n           \
    \     }\n            }\n            push (@result, $tmp);\n        }\n    }\n\
    \    return @result;\n}", "    my(@ret) = ();\n    my $tmp;\n    my $cnt;\n  \
    \  my $tmp_cnt;\n    my $i;", "    my @sorted = ();\n    my($size, $i, $j);\n\
    \    for ($i = 0; $i < @$arr; $i++) {\n        $size = $arr->[$i];\n        for\
    \ ($j = $i + 1; $j < @$arr; $j++) {\n            my($cmp) = compare_func($arr->[$i],\
    \ $arr->[$j]);\n            if ($cmp < 0) {\n                push(@sorted, $arr->[$j]);\n\
    \                splice(@$arr, $j, 1);\n            }\n            elsif ($cmp\
    \ == 0) {\n                push(@sorted, $arr->[$i]);\n                splice(@$arr,\
    \ $i, 1);\n            }\n        }\n    }\n    push(@sorted, @$arr);\n    return\
    \ \\@sorted;\n}", "    my(@sort) = ();\n    my(@sorted_arr) = (undef);", "   \
    \ my(@arr);\n    push @arr, $arr[-1];\n    $arr[-1] = 0;\n    for (my $i = 1;\
    \ $i < @$arr; $i++) {\n        my $ones = int(($arr[$i] - $arr[$i - 1]) * 10);\n\
    \        if ($ones == 0) {\n            push @arr, 0;\n        }\n        else\
    \ {\n            push @arr, $ones;\n        }\n    }\n    push @arr, $arr[0];\n\
    \    return @arr;\n}", "    \n    my($sorted_arr);\n    \n    # sort by number\
    \ of ones\n    my($num_ones) = 0;\n    foreach $elem (@$arr) {\n        $num_ones\
    \ += $elem >> 7;\n    }\n    \n    foreach $elem (@$arr) {\n        # sort by\
    \ decimal value\n        $elem ^= $num_ones;\n        $sorted_arr[$num_ones] .=\
    \ $elem;\n        $num_ones = $elem >> 7;\n    }\n    \n    return @$sorted_arr;\n\
    }", "    my @copy = @$arr;\n    my $size = 0;\n    my @sort;\n    my $ones = 0;\n\
    \    my $decimal = 0;\n    my $temp = 0;", "    my(@sorted_array);\n    \n   \
    \ # Count number of ones\n    my($cnt_ones, $one_count_index);\n    $cnt_ones\
    \ = 0;\n    foreach my $item (@$arr) {\n        if ($item != 0) {\n          \
    \  $cnt_ones++;\n        }\n    }\n    \n    # Sort according to number of ones\n\
    \    for (my $i = 0; $i < @$arr; $i++) {\n        if ($cnt_ones == 0) {\n    \
    \        push(@sorted_array, $arr->[$i]);\n        } else {\n            my $current_value\
    \ = $arr->[$i];\n            my $one_count = intdiv($cnt_ones, 2);\n         \
    \   for (my $j = 0; ($j < $one_count) && ($j != $one_count_index); $j++) {\n \
    \               $cnt_ones -= 1;\n                my $tmp = $cnt_ones;\n      \
    \          $cnt_ones = $cnt_ones + 1;\n                $one_count_index = $j;\n\
    \                push(@sorted_array, $current_value);\n                $cnt_ones\
    \ = $tmp;\n            }\n            \n            if ($cnt_ones == $one_count_index)\
    \ {\n                push(@sorted_array, $current_value);\n            }\n   \
    \     }\n    }\n    \n    return @sorted_array;\n}", "    my(@arrs);\n    my($ones);\n\
    \    my($cmp, $i);", "    my(@res) = [];\n    foreach my $i (0 .. $#$arr) {\n\
    \        my $n = 0;\n        foreach my $b (substr($arr[$i], 0, length($arr[$i])-1))\
    \ {\n            $n++ if $b == '1';\n        }\n        push(@res, sprintf(\"\
    %03d\", $n));\n    }\n    @res = sort { $a<=>$b } @res;\n    foreach my $i (0\
    \ .. $#$arr) {\n        my $n = 0;\n        foreach my $b (substr($arr[$i], 0,\
    \ length($arr[$i])-1)) {\n            $n++ if $b == '1';\n        }\n        $arr[$i]\
    \ = sprintf(\"%03d\", $n);\n    }\n    return @res;\n}", '    my @res;', "   \
    \ if (scalar(@$arr) < 2) {\n        die \"sort_array called with less than two\
    \ elements\";\n    }\n    my $n = @$arr;\n    my $count = [map { $_ == 1 ? 1 :\
    \ ($_ != 0 ? 0 : -1) }, @$arr];\n    $count->[$n-1] = $count->[$n-1] + $count->[$n];\n\
    \    foreach my $i (0..$n-2) {\n        if ($count->[$i] == $count->[$i+1]) {\n\
    \            my $swap = $arr[$i];\n            $arr[$i] = $arr[$i+1];\n      \
    \      $arr[$i+1] = $swap;\n            $count->[$i] += $count->[$i+1];\n    \
    \        $count->[$i+1] -= $count->[$i];\n        }\n    }\n    return $arr;\n\
    }", "    my @sorted = ();\n    my($max) = @$arr;\n    foreach my $num (@$arr)\
    \ {\n        my($bin) = decbin($num);\n        my($ones) = length($bin) - length($bin)\
    \ % 2;\n        $ones += 1 if $num == 0;\n        push(@sorted, $num) if $ones\
    \ == $max;\n        push(@sorted, $num) if $ones != $max;\n    }\n    return @sorted;\n\
    }\n</code>\n<|/ a dscore=0 tags=sorting,perl,arrays |>\n<| a |>\nJust adding another\
    \ possible solution, based on my own answer to the same question on Code Review.\
    \ Using a Schwartzian transformation, to sort the array in-place:\n<code>\nuse\
    \ 5.010;\nuse strict;\nuse warnings;", '    my(@sorted_arr);', "    # Make $arr\
    \ mutable\n    # http://perldoc.perl.org/perlref.html\n    # http://perldoc.perl.org/perlreftut.html\n\
    \    my $arrref = \\$arr;\n    \n    # Make a new array based on $arrref\n   \
    \ # http://perldoc.perl.org/perlref.html\n    # http://perldoc.perl.org/perlreftut.html\n\
    \    my @sorted = ();\n    my $idx = 0;\n    \n    # Iterate through each element\
    \ in $arrref\n    # http://perldoc.perl.org/perlref.html\n    # http://perldoc.perl.org/perlreftut.html\n\
    \    foreach my $value (@$arrref) {\n        my $bits = $value ? \"1\" : \"0\"\
    ;\n        \n        # Find index of $value in sorted array\n        # http://perldoc.perl.org/perlfaq4.html#How-can-I-find-a-value-that-I-already-stored-somewhe\n\
    \        # http://perldoc.perl.org/perlfaq4.html#How-can-I-remove-an-entry-from-an-array-if-I-already-have-it-stored-somewhere\n\
    \        # http://perldoc.perl.org/perlfaq4.html#How-can-I-search-for-an-entry-in-an-array-if-I-have-it-stored-somewhere\n\
    \        # http://perldoc.perl.org/perlfaq4.html#How-can-I-sort-an-array-by-the-entries-in-it-I-stored-somewhere\n\
    \        # http://perldoc.perl.org/perlfaq4.html#How-can-I-find-out-whether-an-element-exists-in-an-array-I-stored-somewhere\n\
    \        my $found_idx = $idx;\n        for (my $idx = 0; $idx < @sorted - 1;\
    \ $idx++) {\n            if ($sorted[$idx] =~ /^$bits/) {\n                $found_idx\
    \ = $idx;\n            }\n        }\n        if ($found_idx == $idx) {\n     \
    \       # Found duplicate entry, use $value to keep sorted array sorted\n    \
    \        $sorted[$found_idx] = $value;\n            next;\n        }\n       \
    \ \n        # Found no duplicate entry, push new element\n        $sorted[$idx]\
    \ = $value;\n        $idx++;\n    }\n    \n    # Return sorted array\n    return\
    \ @sorted;\n}", "    my @tmp = sort{$arr->[$a] <=> $arr->[$b]} @$arr;\n    return\
    \ @tmp;\n}", "    my $size = @$arr;\n    my @res;\n    for (my $i = 0; $i < $size;\
    \ $i++) {\n        my $zeros = 0;\n        my $ones = 0;\n        for (my $j =\
    \ 0; $j < @$arr; $j++) {\n            if ($arr->[$j] & 1) {\n                $ones++;\n\
    \            } else {\n                $zeros++;\n            }\n        }\n \
    \       push @res, $ones;\n        if ($zeros > 0) {\n            push @res, $zeros;\n\
    \        }\n    }\n    if (@$arr > 0) {\n        push @res, 0;\n    }\n    push\
    \ @res, @$arr;\n    return @res;\n}", "    # Sorting in descending order\n   \
    \ my @tmp = sort { $b <=> $a };\n    # Sorting based on number of ones\n    my\
    \ @tmp2 = sort { $a =~ /(1*)$/ <=> $b =~ /(1*)$/ } @tmp;\n    # Sorting based\
    \ on decimal value\n    my @tmp3 = sort { $a =~ /(\\d+)$/ <=> $b =~ /(\\d+)$/\
    \ } @tmp2;", "    my $size = @$arr;\n    my ($i, $num, $ones);", "    my $sorted\
    \ = [];\n    my $i = 0;", "    my(@arr) = $arr;\n    my(@num_ones) = ();\n   \
    \ my(@num_zeros) = ();\n    my($max);\n    my $max_index = -1;\n    foreach my\
    \ $i (0 .. $#$arr) {\n        my($num) = int2oct($arr[$i]);\n        $num_ones[$num]\
    \ = 1;\n        $num_zeros[~$num] = 0;\n        if ($num_ones[$num] > $max) {\n\
    \            $max = $num_ones[$num];\n            $max_index = $i;\n        }\n\
    \    }\n    return $arr[$max_index];\n}", "    my @sort;\n    $arr[-1] = 0 unless\
    \ defined $arr[-1];\n    for my $i (0..$#arr) {\n        my $zeros = $arr[$i];\n\
    \        for my $j ($i..$#arr) {\n            if ($arr[$j] == $zeros) {\n    \
    \            $arr[$j] = 0;\n                push @sort, $zeros;\n            \
    \    last;\n            }\n        }\n    }\n    for my $i (0..$#sort) {\n   \
    \     $sort[$i] =~ s/^0/-/g;\n    }\n    sort { $a <=> $b } @sort;\n}", "    my\
    \ $len = @$arr;\n    my $tmp;\n    my $tmp2;\n    my $cnt = 0;\n    my $min =\
    \ undef;\n    my $min_idx;\n    my $max_idx;\n    my @res;\n    for (my $i = 0;\
    \ $i < $len; $i++) {\n        $cnt = 0;\n        $tmp = $arr->[$i];\n        for\
    \ (my $j = 0; $j < $len; $j++) {\n            $tmp2 = $arr->[$j];\n          \
    \  if ($tmp == $tmp2) {\n                $cnt++;\n            }\n        }\n \
    \       if ($cnt > 1) {\n            $min_idx = $i;\n            $max_idx = $i;\n\
    \            my $tmp_min = $arr->[$min_idx];\n            for (my $j = $i + 1;\
    \ $j < $len; $j++) {\n                my $tmp_max = $arr->[$j];\n            \
    \    if ($tmp_min > $tmp_max) {\n                    $tmp_min = $tmp_max;\n  \
    \                  $min_idx = $j;\n                    $max_idx = $j;\n      \
    \          }\n            }\n        } else {\n            $min_idx = $i;\n  \
    \          $max_idx = $i;\n            my $tmp_min = $arr->[$min_idx];\n     \
    \       my $tmp_max = $arr->[$max_idx];\n            if ($tmp_min > $tmp_max)\
    \ {\n                $tmp_min = $tmp_max;\n                $min_idx = $i;\n  \
    \              $max_idx = $i;\n            }\n        }\n        $tmp = $arr->[$min_idx];\n\
    \        $arr->[$min_idx] = $tmp;\n        $arr->[$max_idx] = $tmp;\n        push(@res,\
    \ $arr->[$min_idx]);\n        push(@res, $arr->[$max_idx]);\n    }\n    return\
    \ @res;\n}\n</code>\n<|/ a tags=perl,arrays,sorting |>\n<| a tags=perl,arrays,sorting\
    \ |>\nThe following will sort your array:\n<code>\nuse strict;\nuse warnings;",
  "    my $len = @$arr;\n    my $max_bit = log($len) - 1;\n    for my $i (0..$len-1)\
    \ {\n        my $count = 0;\n        for my $j ($i..$len-1) {\n            if\
    \ ($arr[$i] & 1) {\n                $count += $j-$i+1;\n            }\n      \
    \  }\n        my $bit = sprintf(\"%0\".$max_bit.\"d\", $count+1);\n        $arr[$i]\
    \ = $bit;\n    }\n    for (1..$len) {\n        $arr[$i] = substr($arr[$i], $i,\
    \ 1);\n    }\n    return @$arr;\n}", "    my($len, @temp);\n    my($i, $j, $cnt);\n\
    \    my($min_value);\n    my($max_value);\n    @temp = (@$arr);\n    $len = @$temp;\n\
    \    for ($i = 0; $i < $len; $i++) {\n        $cnt = 0;\n        for ($j = 0;\
    \ $j < $len; $j++) {\n            if ($temp[$j] == 1) {\n                $cnt++;\n\
    \            }\n        }\n        if ($cnt > 0) {\n            $min_value = $i;\n\
    \            for ($j = (($i + 1) % $len); $j >= 0; $j--) {\n                if\
    \ ($temp[$j] == 0) {\n                    $min_value = $j;\n                 \
    \   break;\n                }\n            }\n            for ($j = $len - 1;\
    \ $j > $i; $j--) {\n                if ($temp[$j] == 0) {\n                  \
    \  $max_value = $j;\n                    break;\n                }\n         \
    \   }\n        }\n    }\n    if ($min_value == $max_value) {\n        if ($min_value\
    \ == 0) {\n            @$arr = @$temp[1 .. $len];\n        } else {\n        \
    \    @$arr = @$temp[$min_value .. $max_value];\n        }\n    } else {\n    \
    \    my($min_cnt);\n        my($max_cnt);\n        for ($i = 0; $i < $len; $i++)\
    \ {\n            $min_cnt = $min_cnt || 0;\n            $max_cnt = $max_cnt ||\
    \ 0;\n            for ($j = 0; $j < $len; $j++) {\n                if ($temp[$j]\
    \ == 1) {\n                    $min_cnt++;\n                }\n              \
    \  if ($temp[$j] == 0) {\n                    $max_cnt++;\n                }\n\
    \            }\n        }\n        if ($max_cnt == $min_cnt) {\n            @$arr\
    \ = @$temp[$min_cnt .. $max_cnt];\n        } else {\n            @$arr = @$temp[$min_cnt\
    \ .. $max_value];\n        }\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,perl\
    \ |>\nIt looks like you're trying to find the longest run of 1's and sort that.\n\
    That is, if your array contains [1, 1, 2, 1], your output should be [2, 1].\n\
    You want that to occur in the first position; you want it to occur in the last\
    \ position.  That's a problem with the current algorithm, so we need to find that\
    \ solution.\nI like to use an array to keep track of how many times an element\
    \ occurs.  If an element doesn't occur, I'll set it to zero.  Then I'll find the\
    \ run of zeroes.\nI'll use the array as a counting array, since 0 is a zero count.\n\
    If there are more zeroes than ones, then there are two runs of 1s.  I'll ", " \
    \   my $len = @$arr;\n    my $ones = 0;\n    my $cmp = sub { $a <=> $b };", " \
    \   my @res;\n    foreach my $n (@$arr) {\n        my $x = $n >> 31;\n       \
    \ my $d = $n & 0x7FFFFFFF;\n        my $key = $d if $x;\n        push @res, map\
    \ { $_ ^ $key } sort { $b <=> $a } map { $x ? ($b << 31) : $b } map { $n >> 31\
    \ } map { $n & 0x7FFFFFF };\n    }\n    return @res;\n}", "    my($cmp) = @_ >\
    \ 1 ? 1 : 0;\n    my(@sorted = ());\n    my($i, $j, $sum, $count);", "    my $num_ones\
    \ = 0;\n    my @ret;\n    for (my $i=0; $i<@$arr; $i++) {\n        $num_ones +=\
    \ $arr->[$i] & 1;\n    }\n    my $ones = $num_ones;\n    $num_ones = 0;\n    my\
    \ $max = $#arr;\n    for (my $i=0; $i<$max; $i++) {\n        $num_ones += $arr->[$i]\
    \ & 1;\n        push @ret, $arr->[$i];\n    }\n    my $max = $#arr;\n    for (my\
    \ $i=$max; $i>0; $i--) {\n        $num_ones += $arr->[$i] & 1;\n        if ($ones\
    \ == $num_ones) {\n            my $j = $i;\n            for (my $k=0; ($k <= $j)\
    \ && ($k <= $#ret); $k++) {\n                $ret[$k] = $ret[$k-1];\n        \
    \    }\n            $j--;\n        }\n        push @ret, $arr->[$i];\n    }\n\
    \    push @ret, $arr->[0];\n    @ret = sort { $a <=> $b } @ret;\n    return @ret;\n\
    }", "    my($cnt,$dec,$cmp);\n    my ($i, $j);\n    foreach $i (sort {$a <=> $b}\
    \ @$arr) {\n        $cnt = &count($arr);\n        $dec = 0;\n        $cmp = 0;\n\
    \        $j = 0;\n        while ($j < $cnt) {\n            if ($arr[$j] == 0)\
    \ {\n                $j++;\n            } else {\n                if ($cnt > $j)\
    \ {\n                    $cmp = $arr[$j];\n                } else {\n        \
    \            $cmp = $arr[$j] - $arr[$j - 1];\n                }\n            \
    \    if ($cmp > 0) {\n                    $dec++;\n                } else {\n\
    \                    $dec--;\n                }\n            }\n        }\n  \
    \      push (@$arr, $j);\n    }\n    return @$arr;\n}", "    my $n = @$arr;\n\
    \    my $i = 0;\n    my %map;\n    for (my $j = 0; $j < $n; ++$j) {\n        my\
    \ $count = 0;\n        for (my $k = 0; $k < $n; ++$k) {\n            $count +=\
    \ ($arr->[$k] & $map{$j}[$k]) ? 1 : 0;\n        }\n        $map{$j}[$i] = $count;\n\
    \        $i++;\n    }\n    for my $i (keys %map) {\n        $map{$i}[$i] = $map{$i}[$i]\
    \ / $n;\n    }\n    my $rev = $arr->[0] >= 0;\n    for my $i (keys %map) {\n \
    \       my $tmp = $i;\n        $i = @$arr - $i - 1;\n        for (my $j = 0; $j\
    \ < $n; ++$j) {\n            $map{$j}[$i] = ($map{$j}[$i] * $arr->[$j]) - $map{$j}[$tmp];\n\
    \        }\n    }\n    for my $i (keys %map) {\n        $map{$i}[$i] = $rev\n\
    \            ? $map{$i}[$i] + 1 \n            : $map{$i}[$i] - 1;\n    }\n   \
    \ return sort {\n        my($k1, $k2) = @_;\n        if ($map{$k1}[$k2] < $map{$k2}[$k1])\
    \ {\n            $k1 cmp $k2;\n        } \n        else {\n            $map{$k2}[$k1]\
    \ <=> $map{$k1}[$k2];\n        }\n    };\n}", "    my $size = @$arr;\n    for\
    \ my $i (0 .. $size-1) {\n        for my $j ($size-1 .. $i) {\n            $arr[$i]\
    \ cmp $arr[$j] or do {\n                    my $l = ($arr[$i] =~ /1/) ? 1 : 0;\n\
    \                    my $r = ($arr[$j] =~ /1/) ? 1 : 0;\n                    $arr[$i]\
    \ <=> $arr[$j]\n                }\n        }\n    }\n    return @$arr;\n}\n</code>\n\
    <|/ a dscore=1 tags=perl,sorting,arrays |>\n<| a tags=perl,sorting,arrays |>\n\
    Sort array\n<code>\nmy = qw(\n  1 0 0 1 0\n  0 1 0 0 0\n  0 0 0 1 0\n  0 0 1 1\
    \ 0\n  0 1 0 1 0\n);", '    my @res;']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
