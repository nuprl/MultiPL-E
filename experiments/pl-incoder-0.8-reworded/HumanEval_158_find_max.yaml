name: HumanEval_158_find_max
language: pl
prompt: "# Write a function that accepts an array of strings.\n# The array contains\
  \ different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> find_max([\"name\", \"of\"\
  , \"string\"])\n# \"string\"\n# >>> find_max([\"name\", \"enam\", \"game\"])\n#\
  \ \"enam\"\n# >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\nsub find_max\
  \ {\n    my($words) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_max;\n\
  \        if(eq_deeply($candidate->([\"name\", \"of\", \"string\"]),\"string\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  name\", \"enam\", \"game\"]),\"enam\")) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaaaaa\", \"bb\", \"\
  cc\"]),\"aaaaaaa\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([\"abc\", \"cba\"]),\"abc\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  we\", \"are\", \"gonna\", \"rock\"]),\"gonna\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\"\
  , \"a\", \"mad\", \"nation\"]),\"nation\")) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\", \"is\",\
  \ \"a\", \"prrk\"]),\"this\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\"b\"]),\"b\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  play\", \"play\", \"play\"]),\"play\")) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %cnt;\n    for (@$words) {\n        if (!exists $cnt{$_}) {\n\
    \            $cnt{$_} = 0;\n        }\n        $cnt{$_}++;\n    }", "    my($word_count)\
    \ = 0; # Number of unique characters in word\n    my($best_count) = 0; # Word\
    \ that comes first in lexicographical order\n    my($best_word) = \"\"; # Word\
    \ that comes first in lexicographical order\n    foreach (@$words) {\n       \
    \ $word_count = 0; # Reset number of unique characters in word\n        foreach\
    \ my $word (@$words) {\n            $word_count += length($word); # Count the\
    \ number of unique characters in word\n        }\n        if ($word_count > $best_count)\
    \ {\n            $best_count = $word_count;\n            $best_word = $_;\n  \
    \      }\n    }\n    return $best_word;\n}", "    my $max;\n    my $key;\n   \
    \ $max = \"\";\n    $key = 0;\n    foreach my $word (@$words) {\n        if ($word\
    \ =~ /(.)\\1*/) {\n            $max = $1;\n            $key = $#words;\n     \
    \   }\n    }\n    return $key unless $max;\n    foreach my $word (@$words) {\n\
    \        if ($word =~ /(.)\\1*/) {\n            if ($2 > $max) {\n           \
    \     $max = $2;\n                $key = $#words;\n            }\n        }\n\
    \    }\n    return $key < 0 ? $max : $key;\n}", "    my $max = -1;\n    my $cur_word\
    \ = $words[0];\n    foreach my $word (@$words) {\n        my $num_unique = length($word)\
    \ - scalar(grep { $words =~ /^$word/ });\n        if ($max < $num_unique) {\n\
    \            $max = $num_unique;\n            $cur_word = $word;\n        }\n\
    \    }\n    return $cur_word;\n}", "    my $max_count = 1;\n    my $max_word;\n\
    \    foreach my $word (@$words) {\n        $max_count = scalar(scalar(@$words)\
    \ > $max_count ? @$words : $max_count);\n        $max_word = scalar(@$words ==\
    \ $max_count ? $word : $max_word);\n    }\n    return $max_word;\n}", "    return\
    \ $words[0] if @$words == 1;\n    my($max, $maxLength);\n    foreach my $word\
    \ (@$words) {\n        foreach my $char (split(//, $word)) {\n            ++$maxLength\
    \ if !defined $maxLength or length($char) > length($max);\n            $max =\
    \ $char if length($char) > length($max);\n        }\n    }\n    return $max;\n\
    }", "    my($word);\n    my($num);\n    my($i);", "    my(@max) = ();\n    my($max_unique)\
    \ = 0;\n    my($i, $j, $k, $n);\n    foreach $word (@$words) {\n        foreach\
    \ $char (split //, $word) {\n            $n = 0;\n            $k = -1;\n     \
    \       foreach $i (@max) {\n                $j = 0;\n                foreach\
    \ $j (split //, $i) {\n                    if ($char eq $j) {\n              \
    \          $n += 1;\n                        if ($n > $max_unique) {\n       \
    \                     $max_unique = $n;\n                            $k = $i;\n\
    \                        }\n                        last;\n                  \
    \  }\n                    $j++;\n                }\n            }\n          \
    \  if ($n == 0) {\n                push(@max, $char);\n            }\n       \
    \ }\n    }\n    return $words[$k];\n}", "    my $result;\n    my $max = scalar(@{$words});\n\
    \    foreach my $word (@{$words}) {\n        my $n = scalar(@{$word});\n     \
    \   if ($n > $max) {\n            $result = $word;\n            $max = $n;\n \
    \       } elsif ($n == $max) {\n            $result = $word unless($result eq\
    \ $word);\n        }\n    }\n    return $result;\n}", "    my $max_count = 0;\n\
    \    my $max_string;\n    my $i;\n    my $j;\n    my $len = length($words[0]);\n\
    \    for ($i = 0; $i < $#words; ++$i) {\n        $max_count = 1;\n        $max_string\
    \ = $words[$i];\n        for (j = $i + 1; $j < $#words; ++$j) {\n            if\
    \ (length($words[$j]) > $len) {\n                $len = length($words[$j]);\n\
    \                $max_string = $words[$j];\n            }\n            $max_count\
    \ = 1 if ($words[$i] cmp $words[$j]);\n        }\n        if ($max_count > 1)\
    \ {\n            $words[$i] = $max_string;\n        } else {\n            $words[$i]\
    \ = $words[$i];\n        }\n    }\n    return $words[0];\n}", "    my $max = $#words\
    \ + 1;\n    my $maxuni = 0;\n    foreach my $word (@$words) {\n        $maxuni\
    \ = 0 unless defined $maxuni;\n        if ($word =~ m/^(.)\\1+$/) {\n        \
    \    $maxuni++;\n        }\n        else {\n            $max = $word if ($maxuni\
    \ > $maxuni);\n            $maxuni = $word;\n        }\n    }\n    $max;\n}",
  "    my $len = @$words;\n    my $max = 0;\n    my @result;\n    foreach my $word\
    \ (@$words) {\n        if (length($word) > $max) {\n            $max = length($word);\n\
    \            push(@result, $word);\n        }\n    }\n    if (@result == 0) {\n\
    \        return '';\n    }\n    return $result[0] if (@result == 1);\n    my $max\
    \ = @result;\n    foreach my $word (@result) {\n        if (length($word) < $max)\
    \ {\n            $max = length($word);\n        }\n    }\n    return $result[$max-1];\n\
    }", "    my $max = -1;\n    my $best_word = \"\";\n    my $i = 0;\n    for (my\
    \ $j = 0; $j < @$words; $j++) {\n        my $len = length $words[$j];\n      \
    \  for (my $k = 0; $k < @$words; $k++) {\n            $best_word = $words[$j]\
    \ if $len < length $words[$k];\n            $best_word = $words[$k] if $len <\
    \ length $best_word;\n        }\n        $max = $max > length $best_word ? $max\
    \ : length $best_word;\n    }\n    return $best_word;\n}\n</code>\n<|/ a dscore=2\
    \ tags=perl,arrays |>\n<| a tags=perl,arrays |>\nThis question seems to be a good\
    \ candidate to Code Golf. I have written a Perl script that solves the problem.\
    \ It is probably not the best solution but it is a short one:\n<code>\nuse warnings;\n\
    use strict;", '    my($max_chars, $max_words) = (0, 0);', "    my $max = 0;\n\
    \    $words[0] = $words[0] if length($words[0]) > 1;\n    for (my $i = 0; $i <\
    \ @$words; ++$i) {\n        my %char_count;\n        foreach my $word (@$words[$i])\
    \ {\n            my $len = 0;\n            for (my $j = 0; $j < length($word);\
    \ ++$j) {\n                my $c = substr($word, $j, 1);\n                $char_count{$c}++\
    \ if defined $char_count{$c};\n                $len += length($c);\n         \
    \   }\n            if ($char_count > $max) {\n                $max = $char_count;\n\
    \            }\n        }\n    }\n    return $words[0] if $max > 1;\n    return\
    \ $words[$i] if $max <= 1;\n}", "    my($max_chars) = undef;\n    my($max_words)\
    \ = undef;", "    $words = reverse @_;\n    my $best_match = undef;\n    my $best_length;",
  "    my $best_word = undef;\n    my $best_count = -1;\n    my $i = -1;\n    while(++$i\
    \ < @$words) {\n        my $count = scalar($words->[$i]);\n        if ($best_count\
    \ == -1 || $count > $best_count) {\n            $best_word = $words->[$i];\n \
    \           $best_count = $count;\n        }\n    }\n    return $best_word;\n}",
  "    my($max) = -1;\n    my($word);", '    my($max);', "    my $max_count = 0;\n\
    \    my $max_string = \"\";\n    foreach my $word (@$words) {\n        my $count\
    \ = 0;\n        foreach my $char (@$word) {\n            $count++ if $char =~\
    \ /[aeiou]/;\n        }\n        if ($count > $max_count) {\n            $max_count\
    \ = $count;\n            $max_string = $word;\n        }\n    }\n    return $max_string;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis answer should be marked as correct.\n\
    <|/ c |>\n<| a dscore=0 tags=perl,regex |>\nYou don't need perl for this. You\
    \ can just use grep, sort and uniq\n<code>\n$ cat test.txt\nhello my name is peter\n\
    hello my name is peter\nhello my name is john\nhello my name is peter\nhello my\
    \ name is peter\nhello my name is peter\n$ cat test.txt | grep -o '[a-zA-Z]' |\
    \ sort -u | head -1\nname\n$ cat test.txt | grep -o '[a-zA-Z]' | sort -u | head\
    \ -1\nname\n$ \n</code>\n<|/ a |>\n<| c |>\nThis answer should be marked as correct.\n\
    <|/ c |>\n<| a tags=perl,regex |>\nIn one line:\n<code>\ngrep -Eo '[[:alpha:]]'\
    \ file.txt | sort -u | head -1\n</code>\nOutput:\n<code>\nname\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 tags=perl,regex |>\nYou could use an array to store\
    \ each word and sort that array to get the word with the highest number of occurrences\
    \ and then return the word:\n<code>\nuse strict;\nuse warnings;\nuse feature 'say';",
  "    my $max;\n    my $key;\n    foreach $key (sort { length $b <=> length $a }\
    \ keys %{ $words[0] })\n    {\n        next unless $words[0]{$key};\n        my\
    \ $new_max = keys %{ $words[0] };\n        if ($new_max > $max)\n        {\n \
    \           $max = $new_max;\n        }\n    }\n    return $max ? $words[0]{$key}\
    \ : $words[0];\n}", "    my $max_length = 0;\n    my $max_word;\n    foreach my\
    \ $word (@$words) {\n        my $len = $#word + 1;\n        $max_length = $len\
    \ if $len > $max_length;\n        $max_word = $word;\n    }\n    return $max_word\
    \ if $max_word;\n    return;\n}", "    my(@results) = ();\n    my(@unique_chars);\n\
    \    my($max_count);\n    my($unique_char_count);\n    my($unique_char);\n   \
    \ foreach my $word (@$words) {\n        @unique_chars = split(//, $word);\n  \
    \      $unique_char_count = ();\n        foreach my $unique_char (@unique_chars)\
    \ {\n            push (@unique_char_count, $unique_char_count{$unique_char}++);\n\
    \        }\n        $max_count = max(@unique_char_count);\n        if ($unique_char_count\
    \ eq $max_count) {\n            push(@results, $word);\n        }\n    }\n   \
    \ if ($max_count > 0) {\n        return $results[0];\n    } else {\n        return\
    \ \"\";\n    }\n}", "    my $num_unique = scalar($words);\n    $num_unique = 0\
    \ if !defined $num_unique or $num_unique == 0;\n    my @unique_chars;\n    my\
    \ @ordered_words;\n    my @ordered_unique_chars;\n    foreach my $word (@$words)\
    \ {\n        foreach my $char (split //, $word) {\n            push @unique_chars,\
    \ $char;\n            push @ordered_unique_chars, $char if !defined $ordered_unique_chars[-1]\
    \ or $char lt $ordered_unique_chars[-1];\n        }\n        push @ordered_words,\
    \ $word;\n    }\n    if ($num_unique == 1) {\n        return $ordered_unique_chars[0];\n\
    \    }\n    my $first_word = pop @ordered_words;\n    foreach my $unique_char\
    \ (@unique_chars) {\n        foreach my $word (@ordered_words) {\n           \
    \ next if $word eq $first_word;\n            foreach my $char (split //, $word)\
    \ {\n                next if $char eq $unique_char;\n                return $word;\n\
    \            }\n        }\n    }\n    return;\n}", "    $words->[0] if @$words\
    \ == 1;\n    my %seen;\n    for (@$words) {\n        $seen{$_}++ for @$words;\n\
    \    }\n    my @sorted_words;\n    my $key;\n    my @values;\n    foreach my $word\
    \ (sort keys %seen) {\n        push (@sorted_words, $word);\n    }\n    foreach\
    \ my $word (@sorted_words) {\n        my $count = 0;\n        foreach my $index\
    \ (0..$#word) {\n            $count++ if $seen{$word[$index]} == $seen{$word[$index\
    \ + 1]};\n        }\n        push (@values, $count);\n    }\n    return $sorted_words[$#sorted_words\
    \ - 1];\n}", "    my %count_hash;\n    foreach (@$words) {\n        $count_hash{$_}++;\n\
    \    }\n    my $max;\n    foreach (sort { $count_hash{$a} <=> $count_hash{$b}\
    \ } keys %count_hash) {\n        $max = $_;\n    }\n    return $max;\n}", "  \
    \  my %count;\n    \n    foreach my $word (@$words) {\n        $count{$word}++;\n\
    \    }", "    \n    my %num_unique_chars;\n    \n    foreach my $word (@$words)\
    \ {\n        $num_unique_chars{$word} = 0;\n    }\n    \n    foreach my $word\
    \ (@$words) {\n        $num_unique_chars{$word}++ while $word =~ /[a-z_]/;\n \
    \   }\n    \n    my $max_num = 0;\n    my $max_key = \"\";\n    foreach my $word\
    \ (sort {$num_unique_chars{$b} <=> $num_unique_chars{$a}} keys %num_unique_chars)\
    \ {\n        if ($num_unique_chars{$word} > $max_num) {\n            $max_num\
    \ = $num_unique_chars{$word};\n            $max_key = $word;\n        }\n    }\n\
    \    \n    return $max_key;\n}\n</code>\n<|/ a tags=perl,regex,arrays |>\n<| c\
    \ |>\nI don't think this is right. For example, I think `\"aaab\"` should match\
    \ because there are 4 characters in common, namely `\"a\"` and `\"b\"`. So I think\
    \ you want the order to be `a`-`z` before `z`-`a`.\n<|/ c |>\n<| c |>\nOh yes,\
    \ thanks for pointing this out, I edited my answer accordingly.\n<|/ c |>\n<|\
    \ c |>\nI think that's a good way to look at it. I'm too lazy at the moment, and\
    \ so I'm going to write it out for myself :P\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ a simple and efficient way of doing it that requires no sorting or hashing.\
    \ It's fast for small lists, but it can take a long time for large ones:\n<code>",
  "    my %hash;\n    foreach my $word($words) {\n        foreach my $char (split(//,\
    \ $word)) {\n            $hash{$char} += 1;\n        }\n    }\n    foreach my\
    \ $char (keys %hash) {\n        if ($hash{$char} == $hash{$_[0]}) {\n        \
    \    return $char;\n        }\n    }\n}", "    return undef unless @$words;\n\
    \    my($max) = -1;\n    my($i);\n    for (@$words) {\n        if ($i eq -1) {\n\
    \            $max = $_;\n            $i = 1;\n        } elsif (length($_) > length($max))\
    \ {\n            $max = $_;\n        }\n        $i++;\n    }\n    return $max;\n\
    }", "    $words[-1] .= \" \".$words[-2]  if @$words > 2;\n    my($count, $tmp);\n\
    \    my $word = $words[0];\n    $count = $words[-1] =~ tr/a-zA-Z//;\n    for my\
    \ $word (@$words) {\n        $count += $word =~ tr/a-zA-Z//;\n        $tmp = $count\
    \ if $count > $tmp;\n        $count = $word =~ tr/a-zA-Z//;\n    }\n    return\
    \ $tmp;\n}", "    $words = { map { chomp; $_ => 1 } @$words };\n    @$words =\
    \ (sort { $words{$a} <=> $words{$b} } keys %$words)[0];\n}", "    my $max_count\
    \ = 1;\n    my $max_word = shift(@$words);\n    foreach my $word (@$words) {\n\
    \        my $word_count = 1;\n        foreach my $char (split(//, $word)) {\n\
    \            $word_count += $chars{$char};\n        }\n        if ($word_count\
    \ > $max_count) {\n            $max_count = $word_count;\n            $max_word\
    \ = $word;\n        }\n    }\n    return $max_word;\n}", "    my $max_count;\n\
    \    my $max_word;\n    my $word_counts = ();", "    $max = 0;\n    \n    for\
    \ my $word (@$words) {\n        $max += length(get_unique_chars($word));\n   \
    \ }\n    \n    for my $word (@$words) {\n        if (length($word) == $max) {\n\
    \            return $word;\n        }\n    }\n    \n    return;\n}\n</code>\n\
    <|/ a tags=perl,algorithm,string |>\n<| c |>\nThanks for the answer! It definitely\
    \ is one which I should be looking at. \nBut I have a few questions:", "    my\
    \ @temp;\n    my %count;\n    foreach my $word (@$words) {\n        my $len =\
    \ length($word);\n        my $max = 0;\n        foreach my $temp (@temp) {\n \
    \           my $templen = length($temp);\n            if($templen > $len) {\n\
    \                $max = $templen;\n            }\n        }\n        if($count{$max}\
    \ == 0) {\n            $count{$max}++;\n        } else {\n            if($count{$max}\
    \ > 1) {\n                $words[$i] = $temp[$i];\n            } else {\n    \
    \            last;\n            }\n        }\n        $temp[$i] = $word;\n   \
    \ }\n    return $words[0];\n}\n</code>\n<|/ a dscore=2 tags=perl |>\n<| c |>\n\
    Sorry, I did not see your previous solution. I was busy with some other projects\
    \ :)\n<|/ c |>\n<| c |>\nThanks for the great solution.  I really appreciate it.\n\
    <|/ c |>\n<| a |>\nHere's an alternative way using hash to keep track of the number\
    \ of occurrences of each letter. I've added some explanation in the comments.\
    \ I've also made an example for you.\n<code>\nuse strict;\nuse warnings;", " \
    \   $_ = $words->[0] unless @$words == 1;\n    my $max = 1;\n    my $max_i = 0;\n\
    \    foreach my $word(@$words) {\n        $word =~ tr/a-z/A-Z/;\n        my $len\
    \ = $#{$word};\n        for ($i = 0; $i < $len; ++$i) {\n            $words->[$i][$len]\
    \ = lc($words->[$i][$len]);\n        }\n        foreach my $word(@$words) {\n\
    \            foreach my $char($word) {\n                $words->[$i][$len] =~\
    \ tr/A-Z/a-z/;\n                if ($words->[$i][$len] ne $char) {\n         \
    \           $words->[$i][$len] = $char;\n                    $words->[$i][0] ||=\
    \ $char;\n                }\n            }\n        }\n        my $word_len =\
    \ length $words->[$i];\n        if ($word_len > $max) {\n            $max = $word_len;\n\
    \            $max_i = $i;\n        }\n    }\n    return $words->[$max_i];\n}",
  "    my($max_chars) = 0;\n    my($max_word);", "    my $max_char = 0;\n    my $max_word\
    \ = $words[0];\n    my $max_count = 0;", "    my($maximum) = 0;\n    my($max)\
    \ = 0;\n    my(@words) = sort {$a<=>$b} @$words;\n    my($j, $i);\n    foreach\
    \ $word (@words) {\n        $maximum++;\n        my($count);\n        my(@characters);\n\
    \        my($max);\n        foreach $character (split(//, $word)) {\n        \
    \    $count++;\n            push(@characters, $character);\n        }\n      \
    \  if($count > $maximum) {\n            $maximum = $count;\n            $max =\
    \ $word;\n        }\n    }\n    if($maximum > $max) {\n        $max = $maximum;\n\
    \    }\n    return $max;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthank you! Your\
    \ answer works wonderfully. I don't know if I should start a new thread. Can you\
    \ give me a hint to solve my question here? http://stackoverflow.com/questions/29096879/how-to-create-a-hash-of-arrays-in-perl-with-unique-values-for-each-key\n\
    <|/ c |>\n<| c |>\nsure, please post a separate question on stackoverflow, will\
    \ have a look\n<|/ c |>\n<| c |>\nOk, thank you. I will post it on here.\n<|/\
    \ c |>\n<| a |>\nAs suggested in other answer, you could use hash of arrays, where\
    \ each array contains characters of particular word and count of characters in\
    \ particular word.\nSomething like this (I'm sorry I'm not so familiar with Perl\
    \ hash syntax):\n<code>\nuse strict;\nuse warnings;", "    my $max = 0;\n    my\
    \ $word;\n    my $wordCount = 1;\n    foreach my $word (@$words) {\n        if\
    \ ($wordCount > $max) {\n            $max = $wordCount;\n            $word = $word;\n\
    \        }\n        if ($wordCount eq $max) {\n            $word++;\n        }\n\
    \        $wordCount++;\n    }\n    return $word;\n}", "    return $words->[0]\
    \ if @$words == 1;\n    $max = $words->[0];\n    $max_count = scalar;\n    for\
    \ my $word (@$words) {\n        if ($word ne $max) {\n            $max_count =\
    \ 1;\n            $max = $word;\n        } elsif ($word eq $max and $words->[$_]\
    \ eq $max) {\n            $max_count++;\n        }\n    }\n    return $max;\n}",
  "    return unless @$words;\n    return $words[0] if (scalar @$words == 1);\n  \
    \  return $words[0] if scalar(@$words) <= 1;\n    my $unique_cnt = 0;\n    my\
    \ $best_word = $words[0];\n    my $best_length = 0;\n    for (@$words) {\n   \
    \     my $length = length($_);\n        if ($length <= $best_length) {\n     \
    \       $unique_cnt = 1;\n            $best_length = $length;\n            $best_word\
    \ = $_;\n        } elsif ($length > $best_length) {\n            $unique_cnt =\
    \ $unique_cnt + 1;\n        }\n    }\n    return $best_word;\n}", "    my($max);\n\
    \    my($current_word);\n    my($current_unique);", "    my $max = -1;\n    my\
    \ $word = \"\";\n    \n    foreach my $word (@$words) {\n        $max = $word->{num}\
    \ if ($word->{num} > $max);\n    }\n    return $word->{word} if ($max != -1 &&\
    \ $max < length($word));\n    return $words[0]->{word} if ($max != -1 && $max\
    \ < length($words[0]->{word}));\n    return undef;\n}", "    my $word;\n    $word\
    \ = 'undef';\n    for my $w (@$words) {\n        if (defined($word)) {\n     \
    \       if (length($word) > length($w)) {\n                $word = $w;\n     \
    \       }\n        }\n        else {\n            $word = $w;\n        }\n   \
    \ }\n    return $word;\n}", "    $max_char = { };\n    $min_char = { };\n    foreach\
    \ my $word (@$words) {\n        $max_char->{$word} = 0;\n        $min_char->{$word}\
    \ = $words->[0];\n        foreach my $char (split //, $word) {\n            $max_char->{$word}\
    \ = $char > $max_char->{$word} ? $char : $max_char->{$word};\n            $min_char->{$word}\
    \ = $char < $min_char->{$word} ? $char : $min_char->{$word};\n        }\n    }\n\
    \    foreach my $word (sort keys %$max_char) {\n        if ($max_char->{$word}\
    \ > 1) {\n            push @$words, $word;\n        }\n    }\n    if (@$words\
    \ > 1) {\n        @$words[0..(@$words - 1)];\n    }\n    return $words[0];\n}",
  '    return $words[0] if @$words == 1;', "    my (@max, @maxchars);\n    my %unique;",
  "    my $max_char = -1;\n    my $max_count = 0;\n    my $result = '';\n    foreach\
    \ my $word (@$words) {\n        $result .= $word;\n        $word_count = length($word);\n\
    \        $unique_char_count = length($result) - length($word);\n        if ($word_count\
    \ > $max_count) {\n            $max_char = $word;\n            $max_count = $word_count;\n\
    \        } elsif ($unique_char_count > $max_char) {\n            $max_char = $unique_char_count;\n\
    \        }\n    }\n    return $max_char;\n}\n</code>\n<|/ a |>\n<| c |>\nI am\
    \ not able to use Perl modules for my task and I am not allowed to use any Perl\
    \ modules. I am also not able to use the sort function either. So, this solution\
    \ has to be done without using these modules.\n<|/ c |>\n<| c |>\nUpdated my question\
    \ to include a solution without Perl modules. It can be done without sorting though.\n\
    <|/ c |>\n<| a |>\nHere is my solution for your problem.\nThe key idea is to find\
    \ out how many characters are there in each word and to select the string with\
    \ maximum number of characters in each word. In the following code, I used regular\
    \ expression to do the job, though this can be done without using regular expression\
    \ as well. \n<code>", "    my $result;\n    my %hash;\n    my $max = 0;\n    foreach\
    \ my $word (@$words) {\n        next unless length $word;\n        $max = $#{$words}\
    \ if $hash{substr($word,0,$max)} < $#{$words};\n        $hash{substr($word,0,$max)}++;\n\
    \    }\n    foreach my $key (keys %hash) {\n        next unless $hash{$key} ==\
    \ $#{$words};\n        $result = $key unless $hash{$key} < $#{$words};\n    }\n\
    \    return $result;\n}", "    my $max;\n    my $found;\n    my $i = 0;\n    \n\
    \    $max = -1;\n    \n    foreach my $word (@$words) {\n        $found = 0;\n\
    \        \n        foreach my $key (keys(%$words)) {\n            my $val = $words->{$key};\n\
    \            \n            if ($val > $max) {\n                $max = $val;\n\
    \                $found = 1;\n            }\n        }\n        \n        if (!$found\
    \ && ($words[0] <=> $words[$i])) {\n            $max = $words[0];\n          \
    \  $found = 1;\n        }\n        \n        $i++;\n    }\n    \n    return $found\
    \ ? $max : $words[0];\n}", "    # O(N) by construction\n    my $max_cnt = 0;\n\
    \    my $max_word;\n    foreach my $word (@$words) {\n        my $length = length($word);\n\
    \        my $cnt = @$words - $#words + 1;\n        if ($cnt > $max_cnt) {\n  \
    \          $max_cnt = $cnt;\n            $max_word = $word;\n        }\n    }\n\
    \    return $max_word;\n}", "    my $max;\n    $max = $words->[0] if $words->[0];\n\
    \    foreach my $word (@$words) {\n        my $count = () = $word =~ tr/a-zA-Z//;\n\
    \        if ($count > $max) {\n            $max = $count;\n        }\n    }\n\
    \    return $words[$words->index($max)];\n}", "    my $max_count = 0;\n    my\
    \ $max_word = $words[0];\n    my $word_count = 0;\n    for my $word (@$words)\
    \ {\n        $word_count++;\n        my $count = grep { !$seen{$_}++ } @$words;\n\
    \        if ($word_count > $max_count) {\n            $max_count = $word_count;\n\
    \            $max_word = $word;\n        }\n    }\n    return $max_word;\n}",
  "    my $max = 0;\n    my $maxw;\n    for (@$words) {\n        my $length = 0;\n\
    \        for (split('', $_, -1, qw/-/)) {\n            $length++ if /^[a-z]+$/;\n\
    \        }\n        $max += $length if $length > $max;\n    }\n    return $max\
    \ ? $maxw : $words[0];\n}", "    \n    my $longest = -1;\n    my $max;\n    my\
    \ $num;", "    my @chars;\n    my $max = 0;\n    my $maxchar;\n    my $maxidx\
    \ = -1;\n    my $i;\n    my $j;", "    return $words[] if @$words == 0;\n    my\
    \ %uniq;\n    my %count;\n    foreach my $word (@$words) {\n        foreach my\
    \ $char (split //, $word) {\n            ++$uniq{$char} if $uniq{$char} < 1;\n\
    \            ++$count{$char}++;\n        }\n    }\n    foreach my $key (sort {lc\
    \ $a cmp lc $b} keys %uniq) {\n        return $key if $uniq{$key} == $count{$key};\n\
    \    }\n}", "    my(@characters);\n    my(@results);\n    my($max_index);\n  \
    \  my($max_character);", "    my @counts;\n    my $max = -1;\n    my $word = '';",
  "    my $max = 0;\n    my $result = undef;\n    foreach my $word (@$words) {\n \
    \       # Compute max for current word\n        $max = $word->length if !$max\
    \ || $word->length > $max;\n        # Find the first word which has more unique\
    \ characters, or the word itself\n        # if no such word exists.\n        $result\
    \ = $word if ($max && $word->length == $max && !$result);\n    }\n    return $result;\n\
    }", "    my $max_count = undef;\n    my $max_string = undef;\n    for my $word\
    \ (@$words) {\n        my $word_count = scalar(keys %$word);\n        if ($word_count\
    \ > $max_count) {\n            $max_count = $word_count;\n            $max_string\
    \ = $word;\n        }\n    }\n    if ($max_count) {\n        return $max_string;\n\
    \    }\n    return undef;\n}", "    my $max;\n    my $index;\n    $max = -1;\n\
    \    foreach my $word (@$words) {\n        my $char_count = $word->length();\n\
    \        if ($char_count > $max) {\n            $max = $char_count;\n        \
    \    $index = $word;\n        }\n    }\n    return $index;\n}", "    my %counts;\n\
    \    foreach my $word (@$words) {\n        my $nchar = length($word);\n      \
    \  $counts{$nchar}++;\n    }\n    my $max_char = scalar(keys %counts);\n    foreach\
    \ my $word (sort { $counts{$a} <=> $counts{$b} } keys %counts) {\n        return\
    \ $word if ($counts{$word} > $counts{$max_char});\n    }\n    return;\n}", " \
    \   my($max, $count, $first, $i);\n    # Find the maximum number and first character\n\
    \    for ($i = 0; $i < $#words; $i++) {\n        ($max, $count, $first) = @{$words[$i]}\
    \ ? ($max, $count, $first) : @{$words[$i]};\n    }", "    my $max_characters =\
    \ 0;\n    my(@chars_arr) = ();\n    foreach my $word (@$words) {\n        $max_characters\
    \ = length($word) if ($max_characters < length($word));\n        push(@chars_arr,\
    \ $word =~ /^(.)\\1+$/);\n    }\n    my $num_unique_characters = scalar(sort(@chars_arr));\n\
    \    return $words[0] if ($num_unique_characters == $max_characters);\n    foreach\
    \ my $word (@$words) {\n        my $i = 0;\n        my $tmp_chars = \"\";\n  \
    \      foreach my $char ($word =~ /^(.)\\1+$/) {\n            $tmp_chars .= $char;\n\
    \            $i++;\n        }\n        return $word if ($tmp_chars ne $chars_arr[$i-1]);\n\
    \    }\n}\n</code>\n<|/ a tags=perl,algorithm,arrays,string |>\n<| c |>\nThis\
    \ works perfectly. Thank you so much. I think I understand how this works. You\
    \ used the regex to determine if the string was \"sorted\". I also have my reasoning\
    \ for using your method. Perhaps I'll use this again later when I need something\
    \ similar to the first string in lexicographical order. Thanks again.\n<|/ c |>\n\
    <| c |>\nYes, I agree with the solution above; it's simpler, faster and more elegant.\n\
    <|/ c |>\n<| a dscore=0 tags=perl,algorithm,arrays,string |>\nA bit brute-force,\
    \ but working :)\n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "  \
    \  $words->[0] if $words->[0] =~ /^\\W*$/;\n    my($max);\n    my $count = 0;\n\
    \    for my $word (@$words) {\n        $count += length($word);\n        last\
    \ if $count > $max;\n    }\n    return $words->[$max] if $max && $max < @$words;\n\
    \    return $words->[0];\n}", "    $words =\n        map { @$_ } @$words;", " \
    \   my $max;\n    my $word;\n    my $counter;\n    my $current_index;\n    foreach\
    \ my $word (@$words) {\n        $counter = 0;\n        $current_index = -1;\n\
    \        for ($i = 0; $i < length($word); $i++) {\n            if (substr($word,\
    \ $i, 1) eq substr($word, $counter, 1)) {\n                $counter++;\n     \
    \       }\n            else {\n                if ($counter > $max) {\n      \
    \              $max = $counter;\n                    $word = $word;\n        \
    \            $current_index = $i;\n                }\n                $counter\
    \ = 1;\n            }\n        }\n    }\n    return $word;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\n+1 for using an associative array and `<=>` to compare\
    \ the words lexicographically. Nice use of that function as a sorting function.\n\
    <|/ c |>\n<| c |>\nNice use of the array slice syntax. I would have thought that\
    \ would be a syntax error.\n<|/ c |>\n<| c |>\n: yes, it would be a syntax error.\
    \  It wouldn't be an `auto` variable declaration, though.\n<|/ c |>\n<| c |>\n\
    Why do you think it is worth writing a function to do that? It seems rather redundant\
    \ to me. The only reason is efficiency, but you wouldn't do it any better by hand\
    \ in Perl. Also, you have no way to specify the return value of the comparison,\
    \ as it is always the last item on the expression, which makes this approach unusable\
    \ if you want to pick a default value if no matches are found.\n<|/ c |>\n<| c\
    \ |>\n: I thought it was useful to illustrate lexicographic sorting, since he's\
    \ asking for the one with the longest number of unique characters.  You do have\
    \ a way to specify the return value of the comparison: it's in `$max`.  (And if\
    \ there's more than one value with the same number of unique characters, you get\
    \ all of them in the result anyway, so there's no ambiguity about which one you're\
    \ picking.)\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", "    my($max)\
    \ = -1;\n    my($word);", "    my $longest = undef;\n    my $longestCount = 0;\n\
    \    foreach my $word (@$words) {\n        my %count = map { $_ => 0 } (split\
    \ //, $word);\n        my $unique = scalar keys %count;\n        if ($unique >\
    \ $longestCount) {\n            $longest = $word;\n            $longestCount =\
    \ $unique;\n        }\n    }\n    return $longest;\n}", "    return $words->[0]\
    \ if @$words == 1;\n    my $maximum = -1;\n    my $word = lc($words->[0]);\n \
    \   for my $word (@$words) {\n        if (length($word) > $maximum) {\n      \
    \      $maximum = length($word);\n            $word = $word;\n        }\n    }\n\
    \    return $word;\n}", "    my $max_count = -1;\n    my $max_word = \"\";\n \
    \   foreach my $word (@$words) {\n        my $count = join(\"\", map {$_ =~s/[^\\\
    w]//g} split //, $word);\n        if ($count > $max_count) {\n            $max_word\
    \ = $word;\n            $max_count = $count;\n        }\n    }\n    return $max_word;\n\
    }", "    return $words[0] if scalar @$words == 1;\n    my $count = @$words;\n\
    \    my($key, $value) = (0, 0);\n    foreach my $word (@$words) {\n        foreach\
    \ my $char (split //, $word) {\n            if (++$count->{$char} > $value->{$char})\
    \ {\n                $key = $char;\n                $value = $count->{$char};\n\
    \            }\n        }\n    }\n    return $words[$key] if $key < @$words;\n\
    }", "    my (@counts, $word, $max_count);\n    my (@result);\n    foreach $word\
    \ (@$words) {\n        @counts[$word] ||= 0;\n        $counts[$word]++;\n    }\n\
    \    @counts = sort { $a <=> $b } values %counts;\n    foreach $word (@$words)\
    \ {\n        $max_count = $counts->[$_] if $counts->[$_] > $counts->[$max_count];\n\
    \        $max_count = $counts->[$_] if $counts->[$_] > $counts->[$_ - 1];\n  \
    \      $result[] = $word;\n    }\n    return $result[0];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks this is just what I needed :)\n<|/ c |>\n<| a tags=perl,algorithm\
    \ |>\nHere's a Perl version using a hash to count the characters and a counter\
    \ for unique characters, using a sort subroutine to find the word with the most\
    \ characters:\n<code>\nuse strict;\nuse warnings;", "    my $max_count = -1;\n\
    \    my $max_word = \"\";\n    for (my $i = 0; $i < @$words; ++$i) {\n       \
    \ for (my $j = 0; $j < @$words[$i]; ++$j) {\n            my $count = 0;\n    \
    \        foreach my $word (@$words) {\n                $count++ if $word eq $words[$i]->[$j];\n\
    \            }\n            $count++ if $i == 0;\n            if ($count > $max_count)\
    \ {\n                $max_count = $count;\n                $max_word = $words[$i]->[$j];\n\
    \            }\n        }\n    }\n    $max_count > 0 ?\n        $max_word :\n\
    \        \"\";\n}", '    return $words[0] if @$words == 1;', "    my $count =\
    \ 0;\n    my $max = 0;\n    my $max = ${$max}{$_} for @{$words};\n    return $max\
    \ if $max == 0;\n    for(my $i = 0; $i <= $#{$words}; $i++) {\n        if($count\
    \ > $max and $$words{$words[$i]} > 1) {\n            $max = $count;\n        }\n\
    \        $count++;\n    }\n    return $words[$i] if $count > $max;\n}\n</code>\n\
    <|/ a tags=perl,hashmap |>\n<| c |>\nHi sir, i am getting error while executing\
    \ this line - my  %count = map {$_->[0] => 1};\n<|/ c |>\n<| c |>\n, I don't have\
    \ a perl that has this feature yet. Will check later. Sorry for that\n<|/ c |>\n\
    <| c |>\n, Check my update. Sorry for the confusion and thanks for the clarification.\n\
    <|/ c |>\n<| c |>\n, Hi, It would be better if you can let us know what error\
    \ you are getting or what unexpected behavior you are getting. Can you share the\
    \ code that is giving this error?\n<|/ c |>\n<| a |>\n<code>", "    my %hash =\
    \ ();\n    foreach my $word (@$words) {\n        if (exists $hash{$word}) {\n\
    \            $hash{$word}++;\n        }\n        else {\n            $hash{$word}\
    \ = 1;\n        }\n    }\n    return sort {$hash{$b} <=> $hash{$a}} keys %hash;\n\
    }", "    my $max;\n    my $current;\n    my $count;\n    \n    foreach my $word\
    \ (@$words) {\n\t$current = \"\";\n\t$count = 0;\n\t\n\tforeach my $char (split\
    \ //, $word) {\n\t    $current .= $char;\n\t    $count += length($char);\n\t}\n\
    \t\n\t$max ||= $count;\n\t$max < $count ? $max = $count : $count = $max;\n   \
    \ }\n    \n    my $found = 0;\n    foreach my $word (@$words) {\n\t$current =\
    \ \"\";\n\t$count = 0;\n\t\n\tforeach my $char (split //, $word) {\n\t    $current\
    \ .= $char;\n\t    $count += length($char);\n\t}\n\t\n\t$count > $max ? $found\
    \ = $word : $found;\n    }\n    \n    return $found || \"\";\n}", "    my $highest\
    \ = 0;\n    my $max_word = \"\";\n    my $i;\n    \n    for ($i=0; $i < scalar(@$words);\
    \ $i++) {\n        my $c = length($$words[$i]);\n        if ($c > $highest) {\n\
    \            $highest = $c;\n            $max_word = $$words[$i];\n        } elsif\
    \ ($c == $highest) {\n            if ($max_word =~ /[^a-z]/i) {\n            \
    \    $$words[$i] = $max_word;\n            } else {\n                $$words[$i]\
    \ = \"_\" x length($max_word);\n            }\n        }\n    }\n    \n    return\
    \ $max_word;\n}", "    $max = $words[0] || 0;\n    $words= map { length $_ ? uc($_)\
    \ : 0 } @$words;\n    for my $word (@$words) {\n        $max = $max if $word >\
    \ $max;\n    }\n    return $max ? $max : $words[0] || 0;\n}", "    my %seen;\n\
    \    \n    $words =~ tr/a-z/A-Z/;\n    foreach my $word (@$words) {\n        $seen{$word}++;\n\
    \    }\n    \n    return sort { $seen{$b} <=> $seen{$a} } keys %seen;\n}", " \
    \   my($max, $index) = (0, -1);\n    for(@$words) {\n        if($words->[$index]->[0]\
    \ eq $max->[0]) {\n            if(!$max->[1]) {\n                return $words->[$index]->[0];\n\
    \            }\n            $max->[1]++;\n        }\n        else {\n        \
    \    $max = [$words->[$index]->[0], 0];\n            $index = -1;\n        }\n\
    \    }\n    return $max->[0];\n}", "    return $words[0] if @$words == 0;\n  \
    \  my $min_char = -1;\n    my $max_char = -1;\n    foreach my $word (@$words)\
    \ {\n        foreach my $char (split(//, $word)) {\n            $min_char = -1\
    \ if $char eq '' && !defined($min_char);\n            $max_char = -1 if $char\
    \ eq '' && !defined($max_char);\n            $min_char = 0 if $char lt $min_char;\n\
    \            $max_char = 0 if $char gt $max_char;\n            $max_char = $char\
    \ if $char eq $max_char;\n        }\n    }\n    return $words[$max_char] if $max_char\
    \ >= $min_char;\n    foreach my $word (@$words) {\n        foreach my $char (split(//,\
    \ $word)) {\n            $min_char = -1 if $char eq '' && !defined($min_char);\n\
    \            $max_char = -1 if $char eq '' && !defined($max_char);\n         \
    \   $min_char = 0 if $char lt $min_char;\n            $max_char = 0 if $char gt\
    \ $max_char;\n            $min_char = $char if $char eq $min_char;\n        }\n\
    \    }\n    return $words[$min_char];\n}", "    $words[-1] = grep(!($_ =~ /^$/),\
    \ @{$words[-1]});\n    \n    my $max = '';\n    my $maxcnt = 0;\n    foreach my\
    \ $word (@{$words[-1]}) {\n        my $c = scalar(keys %{$word});\n        if\
    \ ($c > $maxcnt) {\n            $maxcnt = $c;\n            $max = $word;\n   \
    \     }\n    }\n    return $max;\n}", "    # initialize max to -1\n    my $max\
    \ = -1;\n    \n    # loop through every word\n    for my $word (@$words) {\n \
    \       # initialize count to 0\n        my $count = 0;\n        # loop through\
    \ every character\n        for my $char (split //, $word) {\n            $count\
    \ += 1;\n        }\n        # check if $count is greater than $max\n        if\
    \ ($count > $max) {\n            $max = $count;\n        }\n    }\n    # return\
    \ $max if the value is more than 1\n    return $max > 1 ? $max : $words[0];\n}",
  "    my %counts;\n    $counts{$_}++ for;\n    foreach my $word (@$words) {\n   \
    \     if($counts{$word} > $counts{$_}) {\n            $max = $word;\n        }\n\
    \    }\n    return $max;\n}", "    my $max_length = 0;\n    my(@max_len) = ();\n\
    \    my(@sorted_words) = ();\n    foreach my $word (@$words) {\n        $sorted_words{$word}++;\n\
    \        $max_length = $length+1 if (defined $length);\n        $length = $length\
    \ if !defined $length;\n    }\n    foreach my $word (@$words) {\n        $max_length\
    \ = $length+1 if (defined $length);\n        $length = $length if !defined $length;\n\
    \    }\n    foreach my $word (sort { $sorted_words{$b} <=> $sorted_words{$a} }\
    \ keys %sorted_words) {\n        $max_len{$word} = $sorted_words{$word};\n   \
    \ }\n    foreach my $word (sort { $max_len{$b} <=> $max_len{$a} } keys %max_len)\
    \ {\n        push (@max_len, $word);\n    }\n    $_ = $words[0] if scalar(@max_len)\
    \ == 0;\n    return $_;\n}", "    my($max_char, $word_with_max_char);\n    my(@chars);",
  "    my %count;\n    my $max_count;\n    my $max_string;\n    my $result;\n    my\
    \ $max;", "    my(@ret) = ();\n    my($max_val) = undef;\n    my $i;\n    $max_val\
    \ = undef;\n    my $count;", "    my $max_count;\n    my %counts;\n    foreach\
    \ my $word (@$words) {\n        $counts{$word}++;\n        $max_count = length($word)\
    \ > $max_count ? length($word) : $max_count;\n    }\n    foreach my $key (keys\
    \ %counts) {\n        $counts{$key} == $max_count ? $key : last;\n    }\n}", " \
    \   my(@unique, %count);\n    my(@sorted_unique, @sorted_count);\n    foreach\
    \ my $word (@$words) {\n        foreach my $char (split(//, $word)) {\n      \
    \      if (!defined($count{$char})) {\n                $count{$char} = 0;\n  \
    \          }\n            $count{$char}++;\n        }\n    }\n    foreach my $key\
    \ (sort { $count{$b} <=> $count{$a} } keys %count) {\n        if (!defined($unique[$key])\
    \ || ($unique[$key] < $sorted_unique[$sorted_count[$key]-1])) {\n            $unique[$key]\
    \ = $sorted_unique[$sorted_count[$key]-1];\n            $sorted_unique[$sorted_count[$key]-1]\
    \ = $key;\n            $sorted_count[$key] = $sorted_count[$key] + 1;\n      \
    \  }\n    }\n    return @unique[0] if scalar @unique == 1;\n    return @unique[$_]\
    \ for 0 .. $#sorted_unique;\n}", "    $max_word_length = 0;\n    $max_word = \"\
    \";\n    $max_word_count = 0;\n    my $first_char = -1;\n    my $last_char = -1;\n\
    \    foreach my $word (@$words) {\n        $word =~ s/^\\s+|\\s+$//g;\n      \
    \  $word_length = length($word);\n        if ($word_length > $max_word_length)\
    \ {\n            $max_word_length = $word_length;\n            $max_word = $word;\n\
    \            $max_word_count = 1;\n            $first_char = -1;\n           \
    \ $last_char = -1;\n        }\n        elsif ($word_length == $max_word_length)\
    \ {\n            if ($word cmp $max_word) {\n                $max_word_count++;\n\
    \            }\n            else {\n                if ($first_char == -1) {\n\
    \                    $first_char = $word_length;\n                    $last_char\
    \ = $word_length;\n                }\n                else {\n               \
    \     $last_char = $word_length;\n                }\n            }\n        }\n\
    \    }\n    return $max_word;\n}", "    my($max_num) = 0;\n    my($max_str) =\
    \ \"\";\n    foreach my $word (@{$words}) {\n        if ($max_num < length($word))\
    \ {\n            $max_num = $#words + 1;\n            $max_str = $word;\n    \
    \    }\n    }\n    $max_num;\n}", '    my $result; # Store the word with the maximum
    unique characters', '    my($max, $result);', "    return $words->[0] if @$words\
    \ == 1;\n    my($word, $max);\n    foreach $word (@$words) {\n        $max = $word\
    \ if $word->{unique_chars} > $max->{unique_chars};\n    }\n    return $max;\n}",
  "    my @ret;\n    my $char;\n    my $max = -1;\n    my $counter;\n    $ret[0] =\
    \ \"<undef>\";\n    $counter = 0;\n    foreach $char (@$words) {\n        if ($char\
    \ =~ /[^a-z0-9]/) {\n            $counter++;\n        }\n        else {\n    \
    \        $char =~ tr/A-Z/a-z/;\n            my $len = $#char + 1;\n          \
    \  if ($counter > $max) {\n                $max = $counter;\n                foreach\
    \ $word (@ret) {\n                    undef $word;\n                }\n      \
    \          $ret[0] = substr($char, 0, $len);\n                $ret[0] =~ tr/a-z/A-Z/;\n\
    \            }\n            else {\n                foreach $word (@ret) {\n \
    \                   undef $word;\n                }\n                $ret[$len]\
    \ = substr($char, 0, $len);\n                $ret[$len] =~ tr/a-z/A-Z/;\n    \
    \        }\n            $counter = 0;\n        }\n    }\n    return $ret[0];\n\
    }", '    my($maximum, @words);', "    my($len) = length($words[0]);\n    my($max_word_len)\
    \ = length($words[0]);\n    my($max_num_chars) = undef;\n    my($max_num_words)\
    \ = undef;\n    my($max_num_unique_chars) = undef;\n    my($first_word) = undef;\n\
    \    my($j) = undef;", "    my $max_count = $#words;\n    my = ();", "    my $word_hash\
    \ = {};\n    for my $word (@$words) {\n        $word_hash->{$word}++ || 1;\n \
    \   }", "    my($word) = $words[0];\n    $word = uc($word);\n    my $max_count\
    \ = uc(length($word));\n    foreach my $word (@$words) {\n        my $count =\
    \ uc(length($word));\n        $count = $count > $max_count ? $count : $max_count;\n\
    \        $max_count = $count;\n    }\n    return $word;\n}", "    my %unique;\n\
    \    my $ret = 0;\n    foreach my $word (@$words) {\n        $unique{$word}++;\n\
    \    }", "    my $max_count = 1;\n    my $max_chars = $words[0] =~ /\\w/;\n  \
    \  foreach my $word (@$words) {\n        my $chars = $word =~ /\\w/;\n       \
    \ if ($chars > $max_chars) {\n            $max_count = $chars;\n            $max_chars\
    \ = $chars;\n        }\n        elsif ($chars == $max_chars) {\n            $max_count\
    \ = $max_count * $chars;\n        }\n    }\n    return $words[$max_chars] if ($max_count\
    \ > 1);\n    return $words[0] if ($max_count == 1);\n    return;\n}", "    my($maximum);\n\
    \    my(@unique);\n    my($word);\n    my($count);\n    my($i);\n    my(@letters);\n\
    \    foreach $word (@{$words}) {\n        push(@unique, 0);\n    }", "    my %hash;\n\
    \    foreach my $word (@$words) {\n        $hash{$word}++;\n    }\n    $words->[0]\
    \ if $hash{\"\"} > $hash{undef};\n}", "    my $max_count = -1;\n    my $max_word\
    \ = \"\";\n    foreach my $word (@$words) {\n        my $count = scalar(@$words);\n\
    \        $count -= 1 if $word eq \"-\"; # Remove '-' from the count\n        if\
    \ ($count > $max_count or $word eq $max_word) {\n            $max_count = $count;\n\
    \            $max_word = $word;\n        }\n    }\n    return $max_word;\n}",
  "    my($unique_chars);\n    my(@sorted_words) = (@$words);", "    my(@chars);\n\
    \    my($max);\n    my($first);", "    my $max_word_count = 0;\n    my $max =\
    \ 0;\n    my $word;", "    my $max_chars = $words[0] . \"_$words[1]\";\n    my\
    \ $max_word = undef;\n    foreach my $word (@$words) {\n        my $chars = $word\
    \ . \"_$word\";\n        if (length($chars) > length($max_chars)) {\n        \
    \    $max_chars = $chars;\n            $max_word = $word;\n        }\n    }\n\
    \    return $max_word;\n}", "    my($max) = undef;\n    my($word) = undef;\n \
    \   my(@sorted_words);\n    my($unique) = undef;\n    foreach $word(@$words) {\n\
    \        if (!defined $unique) {\n            $unique = 1;\n            $word\
    \ = $word;\n        } elsif ($unique eq $word) {\n            $unique ++;\n  \
    \      } else {\n            if (defined $max) {\n                push(@sorted_words,\
    \ $word);\n            } else {\n                $max = $word;\n            }\n\
    \            $unique = 1;\n            $word = $word;\n        }\n    }\n    if\
    \ (defined $max) {\n        push(@sorted_words, $max);\n    } else {\n       \
    \ return $words[0];\n    }\n    return $sorted_words[@sorted_words =~ m/^\\d+$/\
    \ ? 0 : 1];\n}", "    $max = -1;\n    $max = $words->[0];\n    foreach my $word\
    \ (@$words) {\n        if ($word->[0] > $max) {\n            $max = $word->[0];\n\
    \        }\n    }\n    return $max;\n}", '    my($num_chars);', "    my %counts;\n\
    \    foreach my $word (@$words) {\n        next if (defined $counts{$word});\n\
    \        $counts{$word}++;\n    }\n    foreach my $word (sort {$counts{$b} <=>\
    \ $counts{$a}} keys %counts) {\n        return $word if $counts{$word} == scalar\
    \ @$words;\n    }\n    return;\n}", "    my $max;\n    my $maxchars = undef;",
  "    my %ucnt = ();\n    foreach my $word (@$words) {\n        $ucnt{$word}++;\n\
    \    }", "    $_ =~ tr/a-z/A-Z/;\n    my @words =();\n    my $max_unique=0;\n\
    \    my $current_unique=0;\n    foreach(@$words) {\n        $current_unique=1;\n\
    \        push(@words, $_);\n        $max_unique=scalar;\n        foreach $w(@words)\
    \ {\n            $current_unique+=$w ne $_ and $current_unique;\n        }\n \
    \       if($current_unique > $max_unique) {\n            $_=$words[@words];\n\
    \        }\n    }\n    return $words[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nYour solution is O(n^2), but you don't actually show how you get from the\
    \ number of unique characters to the lexicographical order.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing out, I missed that part while doing my edit. I corrected my\
    \ post and added an explanation.\n<|/ c |>\n<| c |>\nNo problem. It would have\
    \ been nice if you had added the sorting algorithm you used to find the maximum\
    \ number of unique characters.\n<|/ c |>\n<| c |>\nIt's not O(n^2) because `max_unique`\
    \ is calculated each time through the loop.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    class StringUnique {\n    private function maxUniqueChars(string $s) {\n     \
    \   $counts = $characterCount = array();\n        foreach (str_split($s)) {\n\
    \            $counts[$_] //= 0;\n            $characterCount[$_]++;\n        }\n\
    \        foreach ($counts as $char => $count) {\n            $counts[$char] =\
    \ max($count, $characterCount[$char]);\n        }\n        return $counts;\n \
    \   }\n    public function getMaxUniqueChars(array $strings) {\n        $max =\
    \ $this->maxUniqueChars(current($strings));\n        foreach ($strings as $s)\
    \ {\n            $chars = $this->maxUniqueChars($s);\n            foreach ($chars\
    \ as $char => $count) {\n                $max[$char] = max($count, $max[$char]);\n\
    \            }\n        }\n        return $max;\n    }\n}\n</code>\n<|/ a tags=algorithm,string,perl\
    \ |>\n<| c |>\nYou should explain your answer.\n<|/ c |>\n<| c |>\nI did an edit\
    \ and added an explanation.\n<|/ c |>\n<| a dscore=0 |>\nAs I understand your\
    \ question, you want the number of unique characters in each string, and in descending\
    \ order (because of the way lexicographical order ", "    my %count;\n    for\
    \ my $word (@$words) {\n      $count{$word}++;\n    }\n    return $words->[0]\
    \ if $count{$words->[0]} < $count{$words->[1]};\n    return $words->[1] if $count{$words->[1]}\
    \ < $count{$words->[0]};\n    return $words->[0];\n}\n</code>\n<|/ a tags=perl,function,algorithm\
    \ dscore=1 |>\n<| c |>\nthanks a lot for the help guys and thanks a lot for the\
    \ solutions. I implemented the first solution (the one with the hash). I will\
    \ try the other solutions as well. Thanks again.\n<|/ c |>\n<| c |>\n, if the\
    \ answer helped you, please upvote and accept it. http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work\n\
    <|/ c |>\n<| a tags=perl,function,algorithm |>\nIf your list has small number\
    \ of elements, you can always just iterate through the list and count the characters.\
    \ This would also work for big lists. But this is O(n*m) where n is number of\
    \ elements in list and m is average length of words. \n<code>\nuse Data::Dumper;",
  "    $max = 0;\n    foreach (@$words) {\n        $n = length($_);\n        if ($n\
    \ > $max) {\n            $max = $n;\n            $found = $_;\n        }\n   \
    \ }\n    return $found;\n}\n</code>\n<|/ a tags=perl,lexicographic,unique,count,max\
    \ |>\n<| c |>\nThis answer is not wrong, but you shouldn't be using global variables.\
    \ `find_max` should return the value it finds.\n<|/ c |>\n<| c |>\n: Not true!\
    \ The subroutine modifies the global variable! It's not about subroutine parameters\
    \ but about modification of global variables.\n<|/ c |>\n<| c |>\n: This is not\
    \ about subroutine parameters. It's about a global variable being modified. Global\
    \ variables should be avoided wherever possible.\n<|/ c |>\n<| c |>\n: Yes, but\
    \ that doesn't mean that `find_max` should return the value it finds.\n<|/ c |>\n\
    <| c |>\n: Why would you want to? The function should return the value it finds,\
    \ no more, no less. If you have to modify some global variable from the function\
    \ then you're doing it wrong.\n<|/ c |>\n<| a tags=perl,lexicographic,unique,count,max\
    \ dscore=3 |>\nHow about this:\n<code>", "    $words->sort();\n    return $words->[0]\
    \ if @$words == 1;\n    my %counts;\n    my @result;\n    for my $word (@$words)\
    \ {\n        my $len = length($word);\n        $counts{$len}++;\n    }\n    my\
    \ @sorted = keys %counts;\n    my ($min, $max) = (0, 0);\n    for my $index (0..(@sorted-1))\
    \ {\n        $min = 1 if $sorted[$index] < $sorted[$index-1];\n        $max =\
    \ @sorted if $sorted[$index] > $sorted[$index+1];\n        last if $min > $max;\n\
    \        push @result, $sorted[$index] if $counts{$sorted[$index]} == $min;\n\
    \    }\n    return $result[0] if @$result == 1;\n    return $words[0];\n}", " \
    \   my($max_unique_characters = 0);\n    my($best_word);\n    my($first_word);",
  "    my $max = -1;\n    my $maxchar = 0;\n    my $min = 0;\n    foreach my $word\
    \ (@$words) {\n        my $len = 0;\n        foreach my $char (split //, $word)\
    \ {\n            $len++;\n            push (@{$maxchar{$len}}, $char);\n     \
    \   }\n        if ($len > $max) {\n            $max = $len;\n        }\n     \
    \   elsif ($len < $min) {\n            $min = $len;\n        }\n    }\n    my\
    \ $result = $max;\n    foreach my $len (sort { $a <=> $b } keys %$maxchar) {\n\
    \        foreach my $char (@{$maxchar{$len}}) {\n            if ($char eq $words[$result])\
    \ {\n                $result = $len;\n            }\n        }\n    }\n    return\
    \ $result;\n}", "    my $max = 0;\n    foreach my $word (@$words) {\n        if\
    \ (length($word) > $max) {\n            $max = length($word);\n        }\n   \
    \ }\n    foreach my $word (@$words) {\n        if (length($word) == $max) {\n\
    \            return $word;\n        }\n    }\n    return \"\";\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| a tags=lexicographic,arrays,perl,sorting |>\nA few years after\
    \ the question, I have written this module to solve this problem in one line.\n\
    <code>\nuse List::Util qw(reduce);\nuse Sort::Key::Natural qw(sort_natkeys);",
  "    my @word;\n    my %seen;\n    foreach my $word (@$words) {\n        foreach\
    \ my $char (split(//, $word)) {\n            ++$seen{$char};\n        }\n    }\n\
    \    my $max = -1;\n    foreach my $char (keys %seen) {\n        if ($seen{$char}\
    \ > $max) {\n            $max = $seen{$char};\n        }\n    }\n    if ($max\
    \ > 0) {\n        foreach my $word (@$words) {\n            foreach my $char (split(//,\
    \ $word)) {\n                if ($char == $max) {\n                    return\
    \ $word;\n                }\n            }\n        }\n    }\n    return;\n}",
  "    my(@result) = ();\n    my($max_chars) = 0;\n    my($max_word);", "    my $max\
    \ = -1;\n    my $maxi = 0;\n    foreach my $word (@$words) {\n        if (length($word)\
    \ > $max) {\n            $max = $#{$words};\n            $maxi = $#{$words};\n\
    \        }\n    }\n    if ($maxi > 0)\n        return $words[$maxi];\n    else\n\
    \        return undef;\n}", "    my $max_len = 0;\n    my $word;", "    my @words\
    \ = ();\n    my $max = 0;\n    for my $word (@$words) {\n        my $c = length($word);\n\
    \        $max = $c if $c > $max;\n        $words[$c] = $word;\n    }\n    return\
    \ $words[$max] if $max < @words;\n    return $words[0] if @words == 1;\n    my\
    \ $i = 0;\n    my $word = @words;\n    for (;;) {\n        if ($i == $max) {\n\
    \            my $j = @words - 1;\n            $word = $words[$j] if $j > $i;\n\
    \            return $word;\n        }\n        elsif ($i < $max) {\n         \
    \   $i++;\n            my $j = $i - 1;\n            $word = $words[$j] if $j >\
    \ $i;\n            return $word;\n        }\n    }\n}", "    my(@words) = @{$words};\n\
    \    my(@unique, @chars, $key, $i);", "    my @words;\n    my %max_chars;\n  \
    \  foreach my $word (@$words) {\n        $max_chars{$word} = 0;\n        push\
    \ @words, $word;\n    }\n    foreach my $word (@words) {\n        $max_chars{$word}\
    \ += 1;\n    }\n    foreach my $word (sort keys %max_chars) {\n        last unless\
    \ $max_chars{$word} == 0;\n        return $word;\n    }\n    return;\n}", "  \
    \  $words->[0]->[0] = 0 if $words->[0]->[0] < 0;\n    my $max = $words->[0]->[0];\n\
    \    foreach my $word (@$words) {\n        my $c = 0;\n        foreach my $char\
    \ (split //, $word) {\n            $c += $char->[0];\n        }\n        $max\
    \ = $c if $c > $max;\n    }\n    $words->[0]->[0] = $max;\n    my $chars = $words->[0]->[1];\n\
    \    foreach my $word (@$words) {\n        my $c = $chars->[$word->[0]];\n   \
    \     foreach my $char (split //, $word->[1]) {\n            $chars->[$word->[0]]\
    \ += $char->[0];\n        }\n        $chars->[$word->[0]] = $c;\n    }\n    foreach\
    \ my $word (@$words) {\n        $word->[0] = $words->[0]->[0] < $word->[0] ? $words->[0]->[0]\
    \ : $word->[0];\n    }\n    $chars;\n}", "    my $max_count = 0;\n    my $max_word;\n\
    \    my $curr_count;\n    foreach my $word (@$words) {\n        $curr_count =\
    \ scalar(keys %{ $words{$word} });\n        if ($curr_count > $max_count) {\n\
    \            $max_count = $curr_count;\n            $max_word = $word;\n     \
    \   } elsif ($curr_count == $max_count) {\n            # if the words have same\
    \ number of unique characters, choose\n            # the first one from lexicographical\
    \ order\n            if ($word eq $max_word) {\n                next;\n      \
    \      }\n        }\n    }\n    return $max_word;\n}", "    my %count_hash;\n\
    \    my $max = -1;\n    my $max_element;\n    \n    foreach my $word (@$words)\
    \ {\n        if (exists $count_hash{$word}) {\n            $count_hash{$word}++;\n\
    \        } else {\n            $count_hash{$word} = 1;\n        }\n    }\n   \
    \ \n    foreach my $word (keys %count_hash) {\n        if ($count_hash{$word}\
    \ > $max) {\n            $max = $count_hash{$word};\n            $max_element\
    \ = $word;\n        }\n    }\n    return $max_element;\n}", "    my $max_length\
    \ = 0;\n    my $word;\n    foreach $word ( @$words ) {\n        my $count = 0;\n\
    \        foreach my $char_count ( @$word ) {\n            $count++;\n        }\n\
    \        if ($count > $max_length) {\n            $max_length = $count;\n    \
    \        $word = $word->[0];\n        }\n    }\n    return $word;\n}", "    my($max_char,\
    \ $num_chars) = undef;\n    foreach my $word (@$words) {\n        foreach my $char\
    \ (split(//, $word)) {\n            my $new_chars = $num_chars + length($char);\n\
    \            if ($new_chars > $max_char) {\n                $max_char = $new_chars;\n\
    \                $num_chars = length($char);\n            }\n        }\n    }\n\
    \    return $words[$words->index($word) + 1] if (! defined($max_char) || $max_char\
    \ == 0);\n}", "    my %count;\n    foreach (@$words) {\n        $count{$_}++ if(defined($count{$_}));\n\
    \    }\n    $count{$_} <= 1 ? $_ : $count{$_} == scalar keys %count ? $_ :\n \
    \       find_max(grep !defined($count{$_}), sort keys %count);\n}\n</code>\n<|/\
    \ a tags=algorithm,perl,hash,sorting dscore=2 |>\n<| a dscore=1 |>\nAs stated,\
    \ this is an O(N*N) solution, where N is the number of elements.  You will need\
    \ two loops.  \nOne loop is O(N) to count the number of unique characters (using\
    \ a hash table).  The other loop is O(N) to find the max number of unique characters.\n\
    <code>\nmy $max_chars = 0;\nmy $max_string;", "    my @count = ();\n    my $max\
    \ = 0;\n    my $word = \"\";", "    my $len = scalar($words);\n    my $max_letters\
    \ = ();\n    my $max_letters_index = 0;\n    my $max_letters_count = 1;\n    for(my\
    \ $i = 0; $i < $len; $i++) {\n        my $letters = scalar @{$words[$i]};\n  \
    \      if($max_letters_count > $letters) {\n            $max_letters_count = $letters;\n\
    \            $max_letters = $words[$i];\n            $max_letters_index = $i;\n\
    \        }\n    }\n    return $max_letters;\n}", "    my($max_char, $max_word);\n\
    \    $max_char = 0;\n    $max_word = $words[0];\n    foreach $word (@$words) {\n\
    \        foreach $char (split(//, $word)) {\n            if ($char > $max_char)\
    \ {\n                $max_char = $char;\n                $max_word = $word;\n\
    \            }\n        }\n    }\n    return $max_word;\n}", "    my ($max_num_chars,\
    \ $max_word);\n    my %counts;\n    \n    foreach my $word (@$words) {\n     \
    \   $counts{$word} += 0;\n    }\n    \n    foreach my $word (@$words) {\n    \
    \    $counts{$word}--;\n        if (! $max_num_chars || $counts{$word} >= $max_num_chars)\
    \ {\n            $max_num_chars = $counts{$word};\n            $max_word = $word;\n\
    \        }\n    }\n    return $max_word;\n}", "    my $word_count = () = keys\
    \ %{$words};\n    return $words[$word_count] if !$word_count;\n    my $max_char\
    \ = max map { length $_ } keys %{$words};\n    my $index = 0;\n    my $current_length\
    \ = length $words[0];\n    my $max_word = ();\n    my $max_count = 0;\n    for\
    \ my $i (0 .. $#words) {\n        my $length = length $words[$i];\n        if\
    \ ($length != $current_length) {\n            if ($length == $current_length)\
    \ {\n                last if $max_count > $max_char;\n                $index =\
    \ $i;\n            }\n            else {\n                last;\n            }\n\
    \        }\n        else {\n            if ($length == $max_char) {\n        \
    \        last if $max_count > $max_char;\n                $max_count = $max_char;\n\
    \                $max_word = $words[$index];\n            }\n            else\
    \ {\n                $max_count = $length;\n                $max_word = $words[$index];\n\
    \            }\n        }\n    }\n    return $max_word;\n}", "    my $max = $words[0];\n\
    \    foreach my $word (@$words) {\n        my $num_unique = scalar($word =~ tr/a-z/A-Z/);\n\
    \        if ($num_unique > $max) {\n            $max = $num_unique;\n        }\n\
    \    }\n    return $max;\n}", "    my($max_unique, $min_unique);\n    my $word\
    \ = '';\n    my $length = 0;\n    for my $word (@$words) {\n        chomp($word);\n\
    \        my $unique_char_count = () = grep(!/^\\W+$/ , split(/\\s+/, $word));\n\
    \        if ($unique_char_count > $max_unique) {\n            $max_unique = $unique_char_count;\n\
    \            $word = $word;\n        }\n        if ($unique_char_count < $min_unique)\
    \ {\n            $min_unique = $unique_char_count;\n        }\n    }\n    if ($min_unique\
    \ == $max_unique) {\n        $word = $words[0];\n    }\n    return $word;\n}",
  "    my %count;\n    $count{$_}++ foreach @$words;\n    return unless keys %count;\n\
    \    my $max = shift @$words;\n    my $pos = 0;\n    foreach my $word (@$words)\
    \ {\n        return $max if $count{$word} < $count{$max};\n        ++$pos if $count{$word}\
    \ > $count{$max};\n        $max = $word;\n    }\n    return $max;\n}", "    my($max);\n\
    \    my($max_index);\n    my($temp_word);\n    my $i = 0;\n    my $j = 1;\n  \
    \  my $char_count = -1;\n    my $char_count_index = 0;\n    for ($i = 0; $i <\
    \ @$words; ++$i) {\n        $temp_word = $words[$i];\n        $temp_index = 0;\n\
    \        $temp_index = $temp_word =~ tr/a-z/A-Z/;\n        $temp_index = $temp_word\
    \ =~ tr/A-Z/a-z/;\n        $char_count = $temp_word =~ tr/A-Z/a-z/;\n        my\
    \ $next_char_count = substr($words[$i], $j + 1, 1) =~ tr/A-Z/a-z/;\n        if\
    \ ($char_count != $next_char_count) {\n            $j = $i;\n        }\n     \
    \   if ($char_count > $max) {\n            $max = $char_count;\n            $max_index\
    \ = $i;\n        }\n        $j += 1;\n    }\n    if ($char_count == $max) {\n\
    \        return $words[$max_index];\n    }\n    return $words[$max_index];\n}",
  "    my($max);\n    my($curr);\n    foreach $word (@$words) {\n        foreach $curr\
    \ (@$words) {\n            next if $curr == $word;\n            next if $max <\
    \ length($curr) && $curr == substr($max, 0, length($curr));\n            $max\
    \ = $curr;\n        }\n    }\n    return $max;\n}", "    my $best_words = \"\"\
    ;\n    my $best_count;\n    my $best_chars;\n    my $length = 0;\n    my $index\
    \ = 0;", "    my($max,$word,@found);\n    my $counter;\n    foreach $word (@$words)\
    \ {\n        $found[$_] = 1 for(0..$#$word);\n        $counter = scalar(@found);\n\
    \        $max = -1 if $counter > $max;\n        $max = -1 if $counter == $max;\n\
    \    }\n    return $words[$max] if $max != -1;\n    return undef;\n}", "    my\
    \ %count;\n    my %char_count;", "    $_ = map { $words =~ /$_/ ? $_ : \"-$_-\"\
    \ }\n    sort { length $a <=> length $b } keys %{ map { length($_) }\n};\n</code>\n\
    <|/ a tags=perl,arrays,hash |>\n<| c |>\nThe result is the same, it is just a\
    \ different way of looking at the problem.\n<|/ c |>\n<| c |>\n: It is *wrong*\
    \ to say *\"The result is the same\"*. There are two things that are wrong with\
    \ the answer: it uses `grep` and it uses `$_` as a hash key. That makes it clearly\
    \ wrong (because you forgot to use `grep` to begin with). It also uses `sort`\
    \ but it is wrong. You might want to read http://perldoc.perl.org/functions/sort.html\
    \ .\n<|/ c |>\n<| c |>\nYes it does use grep. I see now what it's doing. Though\
    \ I'm unsure why you use `map` instead of just `$words =~ /$_/ ? $_ : \"-$_-\"\
    `.\n<|/ c |>\n<| c |>\n: It's a matter of style. The `map` statement is more concise\
    \ and straightforward.\n<|/ c |>\n<| a tags=perl,arrays,hash |>\n<code>\nuse strict;\n\
    use warnings;", "    my($unique_chars);\n    my $max_count = 0;\n    foreach my\
    \ $word (@$words) {\n        my $count = $unique_chars{$word} or $unique_chars{$word}\
    \ = 0;\n        if ($count > $max_count) {\n            $max_count = $count;\n\
    \        }\n    }\n    return $unique_chars{$max_count} ? $max_count : -1;\n}",
  "    my $max = 0;\n    my $word;\n    $word = $words[0] if ( @$words == 1 );\n \
    \   $max++ if ( !$word );\n    foreach my $w (@$words) {\n        $max++ if (\
    \ $word and $w =~ /[^a-zA-Z]/ );\n        $max++ if ( $word and $w =~ /^[a-zA-Z]+/\
    \ );\n    }\n    return $max > 1 ? $words[0] : $word;\n}", "    my %counts;\n\
    \    my @sorted_words;\n    foreach my $word (@$words) {\n        my $word_len\
    \ = length($word);\n        $counts{$word} = $counts{$word} || 0;\n        $counts{$word}++;\n\
    \        $counts{$word . '.'} = $counts{$word};\n        push(@sorted_words, $word)\
    \ if $counts{$word} > 1;\n    }\n    return $sorted_words[$#sorted_words] if (scalar\
    \ @sorted_words == 0);\n    my $max_char = 0;\n    my $max_word = '';\n    foreach\
    \ my $word (@sorted_words) {\n        my $chars = length($word);\n        if ($chars\
    \ > $max_char) {\n            $max_char = $chars;\n            $max_word = $word;\n\
    \        }\n    }\n    return $max_word;\n}", "    my $max_count = 0;\n    my\
    \ $max_word;\n    foreach my $word (@$words) {\n        my $count = $words->{$word}++;\n\
    \        if ($count > $max_count) {\n            $max_count = $count;\n      \
    \      $max_word = $word;\n        }\n    }\n    return $max_word;\n}", "    my\
    \ @unique_chars;\n    my $max_chars = 0;\n    foreach my $word (@$words) {\n \
    \       my $char_num = () = $word =~ tr/[a-z]/[A-Z]/g;\n        if ($max_chars\
    \ > $char_num) {\n            $max_chars = $char_num;\n        }\n        push\
    \ @unique_chars, $char_num;\n    }\n    foreach my $char (@unique_chars) {\n \
    \       return $char if ($char == $max_chars);\n    }\n}", "    my($max_char,\
    \ $max_cnt);\n    my($i, $j, $cnt, $word);", "    my $length = 0;\n    my $word\
    \ = \"\";\n    my $unique = 0;\n    my $letters = \"\";\n    foreach my $word\
    \ (@$words) {\n        # Count number of unique characters\n        $unique =\
    \ 0;\n        foreach my $letter (split //, $word) {\n            $unique += 1\
    \ unless $letters !~ /\\b$letter\\b/;\n            $letters .= $letter;\n    \
    \    }\n        # Check if number of unique characters is maximum\n        if\
    \ ($unique > $length) {\n            $length = $unique;\n            $word = $word;\n\
    \        }\n    }\n    return $word;\n}", "    my (@results);\n    \n    foreach\
    \ my $word (@$words) {\n        my (@chars) = split //, $word;\n        my $unique\
    \ = scalar(@chars);\n        \n        push (@results, $word) unless ($results[-1]\
    \ eq $word);\n        \n        if ($unique == $results[-1]) {\n            push\
    \ (@results, $word) unless $results[-1] eq $word;\n        }\n    }\n    \n  \
    \  return $results[-1];\n}", "    my $max_chars = 0;\n    my $max_word = '';\n\
    \    my $max_word_pos;\n    foreach my $word (@$words) {\n        ($max_chars,\
    \ $max_word_pos) = \n            map {$words->[$_]} grep {substr($words->[$_],\
    \ -1) ne substr($words->[$_], 0, -1)} 0..$#$words;\n        if ($max_chars > $max_chars)\
    \ {\n            $max_chars = $max_chars;\n            $max_word = $word;\n  \
    \          $max_word_pos = $max_word_pos;\n        }\n    }\n    return $max_word;\n\
    }\n</code>\n<|/ a tags=perl,sorting,string |>\n<| c |>\nThis solution is quite\
    \ interesting because it's possible to sort strings by their length, then letters\
    \ then symbols, and then numbers. I tried to add some explanation but it would\
    \ require some editing. Can you take a look at it?\n<|/ c |>\n<| c |>\n, thank\
    \ you for pointing it out. I was thinking about the problem in a different way.\
    \ This approach was to sort the strings based on their lexicographical order and\
    \ then take the first result based on the number of unique characters. This is\
    \ exactly what we were looking for.\n<|/ c |>\n<| a dscore=4 |>\nTo find the longest\
    \ string in array, sort them lexicographically and take the first element:\n<code>\n\
    my $str = join \"\", sort { length($a) <=> length($b) };\n</code>\n<|/ a tags=perl,sorting,string\
    \ |>\n<| a dscore=3 tags=perl,sorting,string |>\nFor finding largest string in\
    \ an array you can use\n<code>\nuse strict;\nuse warnings;", "    my $max_word;\n\
    \    my($max_count, $max_string) = undef;\n    foreach my $word (@$words) {\n\
    \        my $count;\n        if (defined($max_count) && $count > $max_count) {\n\
    \            $max_count = $count;\n            $max_word = $word;\n          \
    \  $max_string = $string;\n        } elsif (defined($max_count) && $count eq $max_count)\
    \ {\n            if ($word ne $max_word) {\n                $max_word = $word;\n\
    \                $max_string = $string;\n            }\n        }\n        my\
    \ $string = length($word);\n        if (!defined($max_count)) {\n            $max_count\
    \ = $count;\n            $max_word = $word;\n            $max_string = $string;\n\
    \        } elsif ($count eq $max_count) {\n            if ($word ne $max_word)\
    \ {\n                $max_word = $word;\n                $max_string = $string;\n\
    \            }\n        }\n    }\n    return $max_word;\n}", "    my %count;\n\
    \    foreach my $word (@$words) {\n        $count{$word}++ if $count{$word}++;\n\
    \    }\n    foreach my $word (sort keys %count) {\n        if ($count{$word} ==\
    \ @$words) {\n            return $word;\n        }\n    }\n}", "    my($max) =\
    \ (0, 0);\n    my($first) = ();\n    for (@$words) {\n        if ($max < length($_))\
    \ {\n            $max   = length($_);\n            $first = $_;\n        }\n \
    \       if ($max > length($first)) {\n            $max   = length($first);\n \
    \           $first = $_;\n        }\n    }\n    return $first;\n}", "    my $max\
    \ = -1;\n    foreach my $word (@$words) {\n        # Count the number of unique\
    \ characters in word\n        my $counts = {};\n        my $num_chars = 0;\n \
    \       for (my $i=0;$i<length($word);$i++) {\n            my $char = substr($word,$i,1);\n\
    \            if (exists $counts{$char}) {\n                $counts{$char}++;\n\
    \                $num_chars++;\n            }\n            else {\n          \
    \      $counts{$char} = 1;\n            }\n        }\n        \n        # Assign\
    \ the highest number to the word\n        if ($counts == $max) {\n           \
    \ $max = $num_chars;\n        }\n        else {\n            $max = $counts;\n\
    \        }\n    }\n    \n    # Return the word with max number of unique characters\n\
    \    return $max ? $words[grep { $counts{$_} == $max } keys %$counts] : \"zzz\"\
    ;\n}", '    return $words[0] if @$words == 1;', "    # Write your code here\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    my($max_word, $max_count);\n\
    \    $max_count = -1;\n    $max_word = $words[0];\n    for ($i = 0; $i < @$words;\
    \ $i++) {\n        if ($max_count == -1 || $max_count > length $words[$i]) {\n\
    \            $max_word = $words[$i];\n            $max_count = length $words[$i];\n\
    \        }\n    }\n    return $max_word;\n}", "    my $max = -1;\n    foreach\
    \ my $word (@$words) {\n        if ($word->{unique} > $max) {\n            $max\
    \ = $word->{unique};\n        }\n    }\n    return $words[$max]->[0] unless $max\
    \ == -1;\n    return $words[$max]->[0] if @$words == 1;\n    return $words[$max];\n\
    }", "    # Write your solution here.\n    my $max=0;\n    my $word;\n    foreach\
    \ my $words (@$words){\n        my $count=0;\n        $word = grep {$count++};\n\
    \        $count--;\n        if($count > $max){\n            $max = $count;\n \
    \       }\n    }\n    return $word;\n}\n</cell>\n<text>\nQuestion 3.1\nGiven a\
    \ string, find the minimum number of repetitions that you need to make it to equal\
    \ a number of unique characters. \nFor example, given the string  \"aaaba\", the\
    \ minimum number of repetitions needed to make the string equal \"aaaaba\" is:",
  "    my $max_count = 0;\n    my $max_word = \"\";\n    foreach my $word (@$words)\
    \ {\n        my $count = scalar(keys %$words);\n        if ($count == $max_count)\
    \ {\n            $max_word = $word;\n        }\n        elsif ($count > $max_count)\
    \ {\n            $max_word = $word;\n            $max_count = $count;\n      \
    \  }\n    }\n    return $max_word;\n}", "    my $max = -1;\n    my $index = 0;",
  "    my $max_char = length($words[0]);\n    $max_char = 0;\n    for my $word (@$words)\
    \ {\n        if (length($word) > $max_char) {\n            $max_char = length($word);\n\
    \        }\n    }\n    my $i = 0;\n    my $max_word_len = length($$words[$i]);\n\
    \    for my $word (@$words) {\n        if (length($word) == $max_word_len) {\n\
    \            my $found = 0;\n            for my $char (split('', $word)) {\n \
    \               if (index($$words, $i) == -1 || substr($$words[$i], index($$words,\
    \ $i), 1) < $char) {\n                    $$words[$i] = $word;\n             \
    \       $found = 1;\n                    last;\n                }\n          \
    \  }\n            if (!$found) {\n                $$words[$i] = $word;\n     \
    \       }\n        } else {\n            $$words[$i] = $word;\n        }\n   \
    \     $i++;\n    }\n    $$words[0];\n}", "    my($max, $word, $c) =;\n    my(@unique,\
    \ %seen);", "    $words[-1] unless $words[-1];\n    $words[-1] =~ tr/a-z/A-Z/;\n\
    \    my($max_char_length = 0, $max_chars = 0, $best_word = \"\")\n      for @$words;\n\
    \    my($best_char_length) = $max_char_length if $best_word eq \"\";\n    $best_char_length\
    \ += length($words[0]) if $best_word ne \"\";\n    for(@$words) {\n      my($char_length)\
    \ = length($_);\n      $char_length = $char_length if $char_length < $best_char_length;\n\
    \      $max_char_length = $char_length if $char_length > $max_char_length;\n \
    \     my($unique_chars) = ()\n        for map {length($_)} grep { !/$max_chars/}\
    \ split //, $_;\n      $max_chars = $unique_chars if $unique_chars > $max_chars;\n\
    \    }\n    $best_word if $max_chars == $max_char_length;\n}\n</code>\nTest\n\
    <code>\nuse Test::More;", "    my($max_char) = 0;\n    my($max_word);\n    my(@words);\n\
    \    foreach my $word (@$words) {\n        my @chars = ();\n        foreach my\
    \ $char (@{$word}) {\n            push(@chars, $char);\n        }\n        if\
    \ (scalar(@chars) > $max_char) {\n            $max_char=scalar(@chars);\n    \
    \        $max_word = $word;\n        }\n    }\n    return $max_word;\n}", "  \
    \  my %counts;\n    map { $counts{$_} = 0 } @$words;\n    for my $word (@$words)\
    \ {\n        for my $char (split //, $word) {\n            $counts{$char}++;\n\
    \        }\n    }\n    return sort { $counts{$b} <=> $counts{$a} } keys %counts;\n\
    }", "    my($word, $count, $max);\n    foreach $word (@$words) {\n        foreach\
    \ $count (sort {$a <=> $b} keys %$count) {\n            if ($count->{$word} >\
    \ $count->{$max}) {\n                $max = $word;\n            }\n        }\n\
    \    }\n    return $max;\n}", '    my @unique = ();', "    my $max_chars = $words[0]\
    \ ne '' ? length $words[0] : 0;\n    for my $i (1 .. $#words) {\n        if (length\
    \ $words[$i] > $max_chars) {\n            $max_chars = length $words[$i];\n  \
    \      }\n    }\n    my $max_word = grep { length $_ eq $max_chars } @$words;\n\
    \    return $max_word;\n}", "    my $word;\n    my $counter = 0;\n    foreach\
    \ my $w (@$words) {\n        $word = $w if ($word eq $w);\n        $counter++\
    \ if ($w =~ /[aeiou]/);\n    }\n    return $word if ($counter > $#words);\n  \
    \  foreach my $w (@$words) {\n        $word = $w if ($word eq $w);\n        $counter++\
    \ if ($w =~ /[aeiou]/);\n    }\n    return $word if ($counter > $#words);\n}",
  "    my %counts;\n    \n    foreach my $word (@$words) {\n        next unless length\
    \ $word;\n        \n        $counts{$word} += 1;\n    }\n    \n    return $_ \n\
    \        unless $counts{$_} > 1;\n        \n    my @res;\n    \n    for my $word\
    \ (sort keys %counts) {\n        return $word if $counts{$word} == 1;\n      \
    \  push (@res, $word) if $counts{$word} > 1;\n    }\n    \n    die \"Multiple\
    \ strings with maximum unique characters\" \n        if @res > 1;\n    \n    return\
    \ $res[0];\n}", "    return $words[0] if($#words == 0);\n    \n    my(@result)\
    \ = (0, 1);\n    foreach my $word (@words) {\n        my($length, $num) = find_max_word($word);\n\
    \        push(@result, $num) if $num > $result[0];\n    }\n    return $words[$result[0]]\
    \ if $result[0] > 0;\n    return $words[$result[1]] if $result[1] > 0;\n    return\
    \ $words[0];\n}", '    my @result;', "    my $max_words = 0;\n    my $best_word;\n\
    \    my $best_score;\n    for (@$words) {\n        my $score = length($_);\n \
    \       if ($score > $best_score) {\n            $best_score = $score;\n     \
    \       $best_word = $_;\n        }\n        if ($score == $best_score) {\n  \
    \          $best_score += length($_);\n        }\n        $max_words += 1;\n \
    \   }\n    $best_word = $best_score ? $best_word : @$words[0];\n    return $best_word;\n\
    }", '    my($i, $max);', "    my $max = -1;\n    my $word = \"\";\n    foreach\
    \ my $word (@{$words}) {\n        my $count = 0;\n        foreach my $w (split\
    \ //, $word) {\n            $count++;\n            if ($count > $max) {\n    \
    \            $max = $count;\n                $word = $w;\n            }\n    \
    \    }\n    }\n    return $word;\n}", "    my %counter;\n    my $max = 0;\n  \
    \  my $index = 0;\n    my $max_word = \"\";", "    my ($max, $word, $i) = (0,\
    \ \"\");\n    foreach $word (@$words) {\n        $max = 1 if $max < scalar(grep\
    \ {length($_) > 1} split //, $word);\n        if ($max > 1) {\n            $word\
    \ = join(\"\", sort {length($b) <=> length($a)} split //, $word);\n        }\n\
    \        $words[$i] = $word;\n        $i++;\n    }\n    return $words[$i] if scalar\
    \ @$words > 1;\n    return $words[0] if scalar @$words == 1;\n}", "    # Count\
    \ unique chars in each word\n    my(@counts) = map {\n        my $c = 0;\n   \
    \     map {\n            $c++ if ($_ eq $_);\n        } @$words;\n        [ $_,\
    \ $c ];\n    } @$words;\n    # Sort words with most unique chars first\n    @counts\
    \ = sort { $b->[1] <=> $a->[1] } @counts;\n    # Return the first word\n    return\
    \ $counts[0]->[0] if (@counts);\n    return undef;\n}\n</code>\n<|/ a tags=perl,sorting\
    \ |>\n<| c |>\nI haven't learned how to do subroutines or any of those advanced\
    \ topics, so I can't really use that to figure it out.  But I see what you did\
    \ there, so I'll keep trying.\n<|/ c |>\n<| c |>\nThe `@counts` thing is more\
    \ of a \"hash\" than \"array\".  You can think of it as a list of 2-element arrays.\
    \  The first element of the array is the word, the second is the count of how\
    \ many chars in that word there are.  Then you can sort by the second element\
    \ in the array.  Note that this doesn't consider duplicate words (`@counts`).\
    \  You would have to add a line to check if `@counts` already contains the word\
    \ before adding it.  Also note that `sort { $b->[1] <=> $a->[1] }` doesn't do\
    \ any sorting, it just sorts by the second element of the array.  You would have\
    \ to do `sort { $b->[1] <=> $a->[1] } @counts;`.  See http://perldoc.perl.org/functions/sort.html\
    \ for details.\n<|/ c |>\n<| c |>\nThe `@counts` thing is really just a \"hash\"\
    \ with an extra layer of abstraction.  A \"hash\" is an unordered list of key/value\
    \ pairs.  A \"hash\" is an unordered list of lists.  A \"hash\" is an unordered\
    \ list of array references.  An \"hash\" is an unordered list of hashrefs.  A\
    \ \"hash\" is an unordered list of hashrefs.  And so on...\n<|/ c |>\n<| c |>\n\
    The `@counts` thing is also a list, because you used `map` instead of `foreach`.\
    \  See http://perldoc.perl.org/functions/map.html.  But it's really just an array,\
    \ so you can just use a regular array sort instead: `@counts = sort { $b->[1]\
    \ <=> $a->[1] } @counts;`  That will do no sorting, so it's not a \"hash\".  It's\
    \ actually an array.  You don't need to ", "    $words->[0] if $words->[0] ==\
    \ 0;\n    my $unique_chars = scalar(@$words);\n    my $max_char = -1;\n    my\
    \ $max_words = $words->[0];\n    my $max_index = 0;\n    foreach my $word (@$words)\
    \ {\n        $unique_chars = scalar(@$word);\n        foreach my $index (0..$#$word)\
    \ {\n            my $value = $word->[$index];\n            if ($value == $max_char)\
    \ {\n                $max_char = -1;\n                foreach my $word (@$words)\
    \ {\n                    $unique_chars = scalar(@$word);\n                   \
    \ if ($unique_chars > $max_char) {\n                        $max_char = $unique_chars;\n\
    \                        $max_words = $word;\n                        $max_index\
    \ = $index;\n                    }\n                }\n            }\n       \
    \ }\n    }\n    $max_words[$max_index];\n}", "    my(@words);\n    my($i, $j);\n\
    \    foreach my $word (@$words) {\n        my($num_unique) = @$words;\n      \
    \  foreach my $letter (keys %{$words}) {\n            next unless exists $words->{$letter}{$word};\n\
    \            $num_unique += $words->{$letter}{$word};\n        }\n        if ($num_unique\
    \ > 1) {\n            $words->{$_}{$word} = 1 for (keys %$words);\n        }\n\
    \        elsif ($num_unique == 1) {\n            push @words, $word;\n       \
    \ }\n    }\n    my $max_word;\n    foreach my $word (@words) {\n        $max_word\
    \ = delete $words->{$_};\n    }\n    $max_word\n}", "    my(@answer);\n    my\
    \ %count = ();", "    \n    my @unique_chars;\n    my $max_length = 0;\n    my\
    \ $max_count = 0;\n    my $max_str = \"\";\n    \n    foreach my $word (@$words)\
    \ {\n        \n        my $length = length $word;\n        \n        if ($length\
    \ == 1) {\n            $unique_chars[$word] = 1;\n        }\n        \n      \
    \  elsif ($length > $max_length) {\n            $max_count = $length;\n      \
    \      $max_str = $word;\n            $max_length = length $max_str;\n       \
    \ }\n        \n        else {\n            $unique_chars[$word] += 1;\n      \
    \  }\n    }\n    \n    return $max_str;\n}", "    $words->[0] .= $words->[scalar(@$words)\
    \ - 1];\n    return $words->[scalar(@$words) -1];\n}", "    # Start with a default\
    \ of 0 unique characters.\n    my $max_count = -1;\n    # Count the number of\
    \ unique characters in each string in $words.\n    my @char_count;\n    for (@$words)\
    \ {\n        my $count = scalar(split(//, uc $_));\n        # Keep track of the\
    \ max count and add $count to @char_count if necessary\n        if ($count > $max_count)\
    \ {\n            $max_count = $count;\n        }\n        push @char_count, $count;\n\
    \    }\n    # Sort @char_count by decreasing number of unique characters.\n  \
    \  @char_count = sort { $b <=> $a } @char_count;\n    # Scan @char_count for string\
    \ with max number of unique characters.\n    my $most_common;\n    for (@char_count)\
    \ {\n        if ($_ == $max_count) {\n            $most_common = $_;\n       \
    \ }\n    }\n    return $most_common;\n}\n</code>\n<|/ a tags=perl,perl-data-structures\
    \ dscore=1 |>\n<| c |>\nThe array elements are strings, and I want the word that\
    \ occurs the most in the array. This solution also finds the maximum in the strings.\
    \ I have added clarifications in the original post. Thanks.\n<|/ c |>\n<| a tags=perl,perl-data-structures\
    \ |>\nA solution using hashes.\n<code>\nuse strict;\nuse warnings;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
