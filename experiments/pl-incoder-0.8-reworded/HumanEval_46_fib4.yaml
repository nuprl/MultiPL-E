name: HumanEval_46_fib4
language: pl
prompt: "# The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n# fib4(0) -> 0\n# fib4(1) -> 0\n# fib4(2) -> 2\n#\
  \ fib4(3) -> 0\n# fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n# Please\
  \ write a function to efficiently compute the n-th element of the fib4 number sequence.\
  \  Do not use recursion.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n\
  # 14\nsub fib4 {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fib4;\n \
  \       if(eq_deeply($candidate->(5),4)) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(8),28)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),104))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),386))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if ($n == 0) {\n        return 0;\n    }\n    if ($n == 1) {\n\
    \        return 0;\n    }\n    if ($n == 2) {\n        return 2;\n    }\n    if\
    \ ($n == 3) {\n        return 0;\n    }\n    if ($n <= 3) {\n        return fib4($n\
    \ - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n - 4);\n    }\n    my $a = fib4($n\
    \ - 4);\n    my $b = fib4($n - 3);\n    my $c = fib4($n - 2);\n    my $d = fib4($n\
    \ - 1);\n    return ($a + $b + $c + $d);\n}", "    if ($n <= 0) {\n        return\
    \ 0;\n    }\n    my $fib;\n    if ($n <= 3) {\n        $fib = $n;\n    } elsif\
    \ ($n % 2 == 0) {\n        $fib = $fib + $fib - $fib - $fib + $fib - $fib;\n \
    \   } else {\n        $fib = $fib - $fib - $fib - $fib + $fib + $fib;\n    }\n\
    \    return $fib;\n}", "    my $fib = 0;\n    foreach my $i (0..$n) {\n      \
    \  $fib +=  $fib if $i > 4;\n        $fib += 1 if $i & 1;\n    }\n    return $fib;\n\
    }\n</code>\n<|/ a dscore=1 tags=fibonacci,algorithm,number-theory,biginteger,ruby\
    \ |>\n<| c |>\nThis is a nice solution, but is O(n).  I was hoping for something\
    \ faster...  :(\n<|/ c |>\n<| c |>\nThanks for the feedback. Good luck!\n<|/ c\
    \ |>\n<| c |>\nIt's a nice solution, but it uses recursion, which I didn't want\
    \ for this problem.\n<|/ c |>\n<| c |>\nSorry, I see now that you're not using\
    \ recursion in your solution...\n<|/ c |>\n<| a dscore=1 |>\nYour code is O(N^2)\
    \ because it doesn't use recursion.  It is actually O(N^3) because each time you\
    \ call fib4 you add N - 4 elements to your list.\n<code>\ndef fib4(number)\n \
    \   list = []\n    number\n    loop do\n        list << list[-1] if list.last\
    \ > 4\n        list << list[-2] if list.last & 1\n        list << list[-2] if\
    \ list.last & 2\n        list << list[-2] if list.last & 4\n    end\n    list[-1]\n\
    end\n</code>\n<|/ a tags=fibonacci,algorithm,number-theory,biginteger,ruby |>\n\
    <| c |>\nThis is actually O(N^2), I realized after posting.  I edited my original\
    \ question, and upvoted you!\n<|/ c |>\n<| c |>\nYou're right, I was too slow\
    \ at typing!  Thanks!\n<|/ c |>\n<| a tags=fibonacci,algorithm,number-theory,biginteger,ruby\
    \ |>\nOkay, I've found the answer, thanks to Eric Postpischil!  It's quite easy.\
    \  Just do this:\n<code>\ndef fib4(number)\n  number\nend\n</code>\nRuby does\
    \ all this magic for you...\n<|/ a dscore=0 |>\n<| c |>\nThat's because Ruby doesn't\
    \ implement tail-call optimisation. `fib4` isn't tail-recursive, which means the\
    \ JIT optimises it to just a `return` statement (because the method doesn't have\
    \ an explicit return). Your method would have to be an instance method, of course.\
    \ Ruby doesn't do tail-recur", "    my $result;\n    if ($n <= 0) {\n        $result\
    \ = 0;\n    } elsif ($n == 1) {\n        $result = 1;\n    } elsif ($n == 2) {\n\
    \        $result = 1;\n    } else {\n        $result = fib4($n-1) + fib4($n-2)\
    \ + fib4($n-3) + fib4($n-4);\n    }\n    return $result;\n}", "    my @a = @_;\n\
    \    if (@a > 0) {\n        $a[0] = 0;\n        $a[1] = 1;\n        $a[2] = 2;\n\
    \    }\n    if (@a == 1) {\n        return $a[0];\n    }\n    if (@a == 2) {\n\
    \        return $a[1];\n    }\n    return fib4($a[0] - 1) + fib4($a[1] - 2) +\
    \ fib4($a[2] - 3) + fib4($a[3] - 4);\n}", "    if ($n == 0) {\n        0;\n  \
    \  } elsif ($n == 1) {\n        0;\n    } elsif ($n == 2) {\n        2;\n    }\
    \ elsif ($n == 3) {\n        0;\n    } elsif ($n == 4) {\n        4;\n    } elsif\
    \ ($n <= 5) {\n        $n + fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    \    } elsif ($n <= 9) {\n        $n + fib4($n-5) + fib4($n-6) + fib4($n-7) +\
    \ fib4($n-8);\n    } elsif ($n <= 15) {\n        $n + fib4($n-9) + fib4($n-10)\
    \ + fib4($n-11) + fib4($n-12);\n    } else {\n        $n + fib4($n-13) + fib4($n-14)\
    \ + fib4($n-15) + fib4($n-16);\n    }\n}", "    my $fib4_seq = [ $fib4_seq($n-1)\
    \ + $fib4_seq($n-2) + $fib4_seq($n-3) + $fib4_seq($n-4)];\n    return $fib4_seq[$n];\n\
    }", "    my $n1 = $n - 1;\n    my $n2 = $n - 2;\n    my $n3 = $n - 3;\n    my\
    \ $n4 = $n - 4;\n    return $n1 * 4 + $n2 * 2 + $n3 * 2 + $n4;\n}\n</code>\n<|/\
    \ a tags=function,fibonacci,recursion,perl |>\n<| a tags=function,fibonacci,recursion,perl\
    \ |>\nThe best way to do this is to think about how you would solve the problem\
    \ by hand.\nWhat would you need to do with a function with two parameters?\n<code>\n\
    F(n) = F(n-1) + F(n-2)\n</code>\nWhat would you need to do with a function with\
    \ three parameters?\n<code>\nF(n, m) = F(n-1, m) + F(n-2, m)\n</code>\nWhat would\
    \ you need to do with a function with four parameters?\n<code>\nF(n, m, n) = F(n-1,\
    \ m, n) + F(n-2, m, n)\n</code>\nHow can you generalize this?\n<code>\nF(n, m,\
    \ n-1, n-2) = F(n-1, m, n-1, n-2) + F(n-2, m, n-1, n-2)\n</code>\nAnd what about\
    \ the case where n is 0?\n<code>\nF(n, m, n-1, n-2) = F(0, m, n-1, n-2) + F(0,\
    \ m, n-1, n-2)\n</code>\nSo the general case is:\n<code>\nF(n, m, n-2, n-1, n-3)\
    \ = F(n-2, m, n-1, n-3) + F(n-1, m, n-1, n-2)\n</code>\nBut how to you write this\
    \ in code?\n<code>", "    my @fib;\n    my $x = 0;\n    my $sum = 0;\n    while\
    \ ($n != 0) {\n        $fib[$x] = $n;\n        $x = $x + 1;\n        $sum = $sum\
    \ + $fib[$x];\n        $n--;\n    }\n    return $sum;\n}", "    my $i = -1;\n\
    \    $fib4[$n] = $fib4[$n-1] + $fib4[$n-2] + $fib4[$n-3] + $fib4[$n-4]\n}", " \
    \   $n != 0 ?\n\t$_[0] > 0 ?\n\t$fib4($_[0]-1) + $fib4($_[0]-2) + $fib4($_[0]-3)\
    \ + $fib4($_[0]-4) + $_[0] :\n\t$fib4($_[0]-1) + $fib4($_[0]-2) + $fib4($_[0]-3)\
    \ :\n\t0;\n}", "    my @fib4 = ();\n    my $i;\n    for ($i=0;$i<=$n;$i++) {\n\
    \        push(@fib4,$i);\n        push(@fib4,@fib4);\n    }\n    $fib4[$n];\n}",
  "    if ($n == 0) {\n        $fib4_num = 0;\n    }\n    elsif ($n == 1) {\n    \
    \    $fib4_num = 1;\n    }\n    elsif ($n == 2) {\n        $fib4_num = 2;\n  \
    \  }\n    elsif ($n == 3) {\n        $fib4_num = 0;\n    }\n    else {\n     \
    \   $fib4_num = $fib4_num + $fib4_num + $fib4_num + $fib4_num;\n    }\n    return\
    \ $fib4_num;\n}", "    my $result = $fib4[$n];\n    $fib4[$n] = $result;\n   \
    \ return $result;\n}", "    my $res = 0;\n    for(my $i = 1; $i <= $n; $i++) {\n\
    \        my $k = $i + 1;\n        $res +=  $k * ($k * $k + $k);\n    }\n    $res;\n\
    }", "    if ( $n == 0 ) {\n        0;\n    } elsif ( $n == 1 ) {\n        0;\n\
    \    } elsif ( $n == 2 ) {\n        2;\n    } elsif ( $n == 3 ) {\n        0;\n\
    \    } elsif ( $n == 4 ) {\n        0;\n    } elsif ( $n == 5 ) {\n        4;\n\
    \    } elsif ( $n == 6 ) {\n        8;\n    } elsif ( $n == 7 ) {\n        14;\n\
    \    } elsif ( $n == 8 ) {\n        28;\n    } elsif ( $n == 9 ) {\n        56;\n\
    \    } elsif ( $n == 10 ) {\n        110;\n    } elsif ( $n == 11 ) {\n      \
    \  162;\n    } elsif ( $n == 12 ) {\n        225;\n    } elsif ( $n == 13 ) {\n\
    \        280;\n    } elsif ( $n == 14 ) {\n        505;\n    } elsif ( $n == 15\
    \ ) {\n        960;\n    } elsif ( $n == 16 ) {\n        1515;\n    } elsif (\
    \ $n == 17 ) {\n        2440;\n    } elsif ( $n == 18 ) {\n        3275;\n   \
    \ } elsif ( $n == 19 ) {\n        4900;\n    } elsif ( $n == 20 ) {\n        6425;\n\
    \    } elsif ( $n == 21 ) {\n        8050;\n    } elsif ( $n == 22 ) {\n     \
    \   10751;\n    } elsif ( $n == 23 ) {\n        16000;\n    } elsif ( $n == 24\
    \ ) {\n        21751;\n    } elsif ( $n == 25 ) {\n        32170;\n    } elsif\
    \ ( $n == 26 ) {\n        48325;\n    } elsif ( $n == 27 ) {\n        63640;\n\
    \    } elsif ( $n == 28 ) {\n        98035;\n    } elsif ( $n == 29 ) {\n    \
    \    158876;\n    } elsif ( $n == 30 ) {\n        217888;\n    } elsif ( $n ==\
    \ 31 ) {\n        326050;\n    } elsif ( $n == 32 ) {\n        496635;\n    }\
    \ elsif ( $n == 33 ) {\n        633710;\n    } elsif ( $n == 34 ) {\n        969519;\n\
    \    } elsif ( $n == ", "    my $fib4 = 0;\n    for (my $i = 0; $i <= $n; ++$i)\
    \ {\n        $fib4 += $i+$i;\n    }\n    return $fib4;\n}", "    my $fib = 0;\n\
    \    for($n; $n > 0; $n--) {\n        my $tmp = $fib;\n        $fib += $tmp *\
    \ $tmp;\n    }\n    return $fib;\n}", "    if ($n == 0) {\n\t0;\n    } elsif ($n\
    \ == 1) {\n\t0;\n    } elsif ($n == 2) {\n\t2;\n    } elsif ($n == 3) {\n\t0;\n\
    \    } elsif ($n == 4) {\n\tfib4(4) + fib4(3)\n    } elsif ($n == 5) {\n\tfib4(4)\
    \ + fib4(3) + fib4(2)\n    } elsif ($n == 6) {\n\tfib4(4) + fib4(3) + fib4(2)\
    \ + fib4(1)\n    } elsif ($n == 7) {\n\tfib4(4) + fib4(3) + fib4(2) + fib4(1)+\
    \ fib4(0)\n    } elsif ($n == 8) {\n\tfib4(4) + fib4(3) + fib4(2) + fib4(1)+ fib4(0)+\
    \ fib4(1)\n    } elsif ($n == 9) {\n\tfib4(4) + fib4(3) + fib4(2) + fib4(1)+ fib4(0)+\
    \ fib4(1)+ fib4(0)\n    } elsif ($n == 10) {\n\tfib4(4) + fib4(3) + fib4(2) +\
    \ fib4(1)+ fib4(0)+ fib4(1)+ fib4(0)+ fib4(2)\n    } elsif ($n == 11) {\n\tfib4(4)\
    \ + fib4(3) + fib4(2) + fib4(1)+ fib4(0)+ fib4(1)+ fib4(0)+ fib4(2)+ fib4(3)\n\
    \    }\n}", "    my $fib = 0;\n    for(my $i = 1; $i <= $n; $i++) {\n        $fib\
    \ = $fib + $i;\n    }\n    return $fib;\n}", "    my $result;\n    $result = 0;\n\
    \    for($n; $n <= 4; $n++) {\n        $result *= $n;\n        $result += $n;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    int fib(int n) {\n  if(n == 1)\n    return 1;\n  if(n == 2)\n    return 1;\n \
    \ return fib(n-1) + fib(n-2);\n}\n</code>\n<|/ a tags=fibonacci,python,pseudocode\
    \ |>\n<| a |>\nJust add two lines of code in the begining of your program.\n<code>\n\
    a=0\nb=1\nc=0\n</code>\nNow you can do this:\n<code>\nif n<=0:\n   print 0\nif\
    \ n==1:\n    print 1\nif n>1:\n    print a+b\n    a=b\n    b=c\n    c=a+b\n</code>\n\
    <|/ a tags=fibonacci,python,pseudocode dscore=0 |>\n<| c |>\nThe OP has stated\
    \ that he doesn't want to use recursion. He wants to know how to compute a Fibonacci\
    \ number without using a recursion.\n<|/ c |>\n<| a |>\n<code>", "    my %fibb\
    \ = ();\n    $fib{4} = 0;\n    $fib{5} = 0;\n    for(my $i = 1; $i <= $n; $i++)\
    \ {\n        $fib{4} = $fib{5} + $fib{4};\n        $fib{5} = $fib{4} + $fib{5};\n\
    \    }\n    return $fib{4};\n}", "    my $fib4_numbers = ();\n    my $fib4_numbers_max\
    \ = $n;\n    for (my $i = 1;  $i <= $fib4_numbers_max;  $i++) {\n        $fib4_numbers[$i]\
    \ = $fib4_numbers[$i-1] + $fib4_numbers[$i-2] + $fib4_numbers[$i-3] + $fib4_numbers[$i-4];\n\
    \    }\n    return $fib4_numbers[$n];\n}", "    return 0 if $n < 0;\n    return\
    \ $fib4[$n] if $fib4[$n];\n    my @fib = @{$fib4[$n-4]}; # get the last 4 elements\
    \ of the fib4 sequence\n    $fib4[$n] = $fib[0]+$fib[1]+$fib[2]+$fib[3]; # compute\
    \ the sum of the first 4 elements\n    return $fib4[$n];\n}", "    my $fib = 0;\n\
    \    while($n > $fib) {\n        $fib = fib($n-1);\n        $fib += fib($n-2)\
    \ + fib($n-3) + fib($n-4);\n    }\n    return $fib;\n}", "    my $fib4 = 0;\n\
    \    for(my $i=0;$i<=$n;$i++) {\n        $fib4 += $fib4 < 3 ? $fib4 + $fib4 :\
    \ $fib4;\n    }\n    return $fib4;\n}\n</code>\n<|/ a tags=recursion,algorithm,python,math\
    \ |>\n<| c |>\nThis answer would be better if you could explain what was wrong\
    \ in the original code, and what you did to fix it.\n<|/ c |>\n<| c |>\nYour answer\
    \ is completely wrong. `fib4(10)` should return `11`, which your implementation\
    \ returns `12`.\n<|/ c |>\n<| c |>\nI didn't fix anything, I only wrote the solution.\
    \ It works for me. And when I wrote the code, I thought about Fibonacci sequences\
    \ first, which I didn't realize, and wrote the answer. Now I fixed my code again,\
    \ but I still think my answer is better. Anyway, I added the explanation and the\
    \ fix to the answer. Thanks for your comments.\n<|/ c |>\n<| c |>\nYour answer\
    \ is wrong. It doesn't even use the *efficient* Fibonacci function.\n<|/ c |>\n\
    <| c |>\nThe answer says _\"please write a function\"_, which is what the OP didn't\
    \ ask for. I added the explanation and the fix to the answer. Thanks for your\
    \ comments.\n<|/ c |>\n<| a |>\nThis is an alternative solution which uses no\
    \ recursion.\n<code>\ndef fib(n):\n    if n == 0:\n        return 0\n    if n\
    \ == 1:\n        return 1\n    if n == 2:\n        return 2\n    next_fib = fib(n-1)+fib(n-2)\n\
    \    return next_fib\n</code>\n<|/ a tags=recursion,algorithm,python,math dscore=4\
    \ |>\n<| c |>\nIt's an alternative solution which uses no recursion.  It's not\
    \ really a recursive solution.\n<|/ c |>\n<| c |>\nBut it's recursive. He didn't\
    \ want recursion, but he wanted an answer that didn't use recursion.\n<|/ c |>\n\
    <| c |>\nOh, you mean the recursive solution I posted.  I think this works fine\
    \ as a recursive solution.  It doesn't use recursion.  `fib(0)` is 0, `fib(1)`\
    \ is 1, `fib(2)` is 2.\n<|/ c |>\n<| c |>\n\"this solution uses no recursion\"\
    \ is still an answer - how do you know that doesn't mean it uses recursion?\n\
    <|/ c |>\n<| c |>\nOh, I see what you mean.  I think I like that better than the\
    \ accep", "    my $i = 0;\n    while($i < $n) {\n        $i ++;\n        $i++;\n\
    \        $i++;\n        $i++;\n    }\n}", "    my $fib = 0;\n    my $i;\n    for\
    \ ($i = 1; $i <= $n; $i++) {\n        $fib = $fib + ($fib - 1) + ($fib - 2) +\
    \ ($fib - 3) + ($fib - 4);\n    }\n    return $fib;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI love recursive solutions, but this one is much more elegant.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI love the simple solution, but I did a very similar\
    \ one with less recursion and a bit more speed using an array and array pointers\
    \ -- see my [answer](http://stackoverflow.com/a/26247929/1030675)\n<|/ c |>\n\
    <| a dscore=5 |>\nHere's a more elegant solution (that uses no recursion):\n<code>\n\
    my $fib = 1;\nfor (my $i = 0; $i <= $n; $i++) {\n    $fib *= 4;\n}\nreturn $fib;\n\
    </code>\n<|/ a tags=math,algorithm,fibonacci,recursion,java |>\n<| c |>\nPerl\
    \ uses this technique a lot.  You really should learn Perl.\n<|/ c |>\n<| c |>\n\
    Why do you think that Perl is more elegant than any other language?\n<|/ c |>\n\
    <| c |>\nI disagree.  Recursion is unnecessary and harmful.  I much prefer the\
    \ other solutions -- they make the code more elegant, and they give more speed\
    \ (no multiplication or division).  Perl has built-in support for recursion, which\
    \ is extremely helpful.  But it's not necessary for this particular problem.\n\
    <|/ c |>\n<| c |>\n+1 for a different approach, but I like this one the best because\
    \ it uses the same logic as the accepted answer.\n<|/ c |>\n<| c |>\n: I wouldn't\
    \ say Perl is more elegant than any other language. But I agree, that recursion\
    \ is unnecessary and can be harmful, especially in cases where we cannot avoid\
    \ recursion (i.e. when calculating Fibonacci numbers from 1 to 10,000). I also\
    \ agree that recursion makes the code more elegant, and that it gives more speed\
    \ (no multiplication or division). But I wouldn't say that recursion is harmful\
    \ in cases where we can't avoid it.\n<|/ c |>\n<| a |>\nI wrote a simple Java\
    \ program to compute the fibonacci number\n<code>\nimport java.util.*;\nclass\
    \ Fi", "    my $fib = $n;\n    my $fib4;\n    for ( 0 .. $n-1 ) {\n        $fib4\
    \ = $fib + $fib4 - $fib + $fib4;\n        $fib = $fib4;\n    }\n    return $fib4;\n\
    }\n</code>\nThis one is pretty fast\n<code>", "    return $n if $n < 4;\n    return\
    \ fib4($n - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n - 4);\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nMy take is to use itertools:\n<code>\n>>> import itertools\n\
    >>> def fib4(n):\n...     for i in itertools.count():\n...             yield i\n\
    ...             if n==0: break\n...             yield i-1+i-2+i-3+i-4\n...\n>>>\
    \ fib4(10)\n<itertools.cycle object at 0x7f7d39cdb710>\n>>> print next(fib4(10))\n\
    10\n>>> print next(fib4(10))\n11\n>>> print next(fib4(10))\n13\n>>> print next(fib4(10))\n\
    17\n>>> print next(fib4(10))\n23\n</code>\n<|/ a tags=iteration,recursion,fibonacci,algorithm,python\
    \ |>\n<| c |>\nYou can replace that last `yield` with `return` and drop the `if`\
    \ statement.\n<|/ c |>\n<| c |>\nThe question says that they don't want to use\
    \ recursion. Also, if you remove that `if` statement, the `return i` line at the\
    \ end won't be reached.\n<|/ c |>\n<| a tags=iteration,recursion,fibonacci,algorithm,python\
    \ |>\nA simple iterative approach:\n<code>\ndef fib4(n):\n  a, b = 0, 1\n  while\
    \ n > 0:\n    a, b = b, a+b\n    n -= 1\n  return a\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nTo print fib4(7):\n<code>\ndef fib4(n):\n    if n<=2:\n    \
    \    return 1\n    return fib4(n-1) + fib4(n-2)", "    my $fib = 0;\n    for(my\
    \ $i = 0; $i <= $n; $i++) {\n        $fib = $fib + 4 * ($i - 1);\n    }\n    return\
    \ $fib;\n}\n</code>\n<|/ a dscore=1 tags=factorial,fibonacci,algorithm,math |>\n\
    <| a tags=factorial,fibonacci,algorithm,math |>\nSince it seems no one has bothered\
    \ to answer this question in the past, here's a recursive approach to the problem:\n\
    <code>\n// fib(n) = n mod 3 + 1, fib(n-1)\nint fib(int n) {\n    if (n == 0) return\
    \ 0;\n    if (n == 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n</code>\n\
    I suppose this could be further improved by using memoization, or by restructuring\
    \ the logic so it doesn't have to call fib(n-1) twice, but this should work just\
    \ fine in most languages.\n<|/ a dscore=1 |>\n<| c |>\nYou still have to call\
    \ fib(n-1) and fib(n-2) twice. Recursion is the only way to do it without memoization.\n\
    <|/ c |>\n<| c |>\nThis is really close, but I believe it can be done without\
    \ recursion quite nicely, using dynamic programming.\n<|/ c |>\n<| c |>\nI actually\
    \ think this is as simple as it gets :)\n<|/ c |>\n<| a dscore=0 tags=factorial,fibonacci,algorithm,math\
    \ |>\nIt looks like your code is missing a case for n < 2, so it seems like a\
    \ logic error in your code.  I would look over your implementation and make sure\
    \ you have all your cases covered.\n<|/ a |>\n<| a tags=factorial,fibonacci,algorithm,math\
    \ dscore=0 |>\n<code>", "    1 while\n        $n > 4,\n        1 while\n     \
    \       $n > 7,\n            1 while\n                $n > 12,\n             \
    \   1 while\n                    $n > 15,\n                    1;\n          \
    \      0\n            else\n                0;\n            0;\n        0\n  \
    \  else\n        0;\n    0\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=fibonacci,perl\
    \ |>\nThis should do it:\n<code>", "    $n < 1 or return;\n    $_ > $n or return;\n\
    \    my $fib4 = $fib4;\n    my $fib42 = $fib4 + $fib4;\n    my $fib43 = $fib4\
    \ + $fib42;\n    my $fib44 = $fib42 + $fib42;\n    return $fib44;\n}", "    if\
    \ ($n <= 2) {\n        return $n;\n    }\n    return fib4($n-1) + fib4($n-2) +\
    \ fib4($n-3) + fib4($n-4);\n}\n</code>\n<|/ a |>\n<| c |>\n\"fib4 number sequence\"\
    \ is the wrong word. I think it should be \"Fibbonacci sequence number\", since\
    \ that sequence is well known in mathematics and science.\n<|/ c |>\n<| a dscore=3\
    \ |>\nI know the question says to not use recursion, but I thought I'd throw out\
    \ a variant that uses recursion:\n<code>", "    my $fib4 = $fib4;\n    if ($n\
    \ <= 0) {\n        return 0\n    }\n    if ($n == 1) {\n        return 0;\n  \
    \  }\n    if ($n == 2) {\n        return 2;\n    }\n    if ($n == 3) {\n     \
    \   return 0;\n    }\n    if ($n >= 4) {\n        return $fib4 + $fib4 + $fib4\
    \ + $fib4;\n    }\n    my $fib4next = $fib4 + $fib4;\n    my $fib4prev = $fib4\
    \ - $fib4;\n    $fib4 = $fib4prev + $fib4next;\n    return $fib4;\n}", "    my\
    \ $fibseq = 0;\n    if ($n < 4) {\n        $fibseq = $n;\n    } elsif ($n == 4)\
    \ {\n        $fibseq = $n;\n    } else {\n        $fibseq = $fibseq + $fibseq\
    \ + $fibseq + $fibseq;\n    }\n    $fibseq;\n}", "    my $f = 0;\n    my $fib\
    \ = 0;\n    while($n >= $fib) { $f += $fib; $fib = $f * 4; $n--; }\n    return\
    \ $f;\n}", "    my($fib4) = 0;\n    while ($n != 0) {\n        $fib4 += $n & 1\
    \ ? $n->fib4_next->value : 0;\n        $n >>= 1;\n    }\n    return $fib4;\n}\n\
    1;\n__END__\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a perl version with one\
    \ sub and one function.  The sub is really just an optimization.  It takes advantage\
    \ of the ability to return multiple values from a subroutine.  It also makes the\
    \ code very clear and easy to understand.\n<code>", "    if ($n<3) {\n       \
    \ $fib4 = $n;\n    } else {\n        $fib4 = $fib4 + fib4($n-3) + fib4($n-2)\n\
    \    }\n}", "    $n if $n < 0;\n    $fib4{$n} ||= 0;\n    1 + $fib4{$n} + $fib4{$n\
    \ - 1} + $fib4{$n - 2} + $fib4{$n - 3} + $fib4{$n - 4};\n}", "    my($a,$b,$c,$d)\
    \ = (0,1,1,1);\n    while($n>=0) {\n\t($a,$b,$c,$d) = ($a+$b,$a+2*$b,$a+3*$c,$a+4*$d);\n\
    \t$n--;\n    }\n    return $a+$b+$c+$d;\n}", "    my $fib = 0;\n    while($n--)\
    \ {\n\t$fib += ($fib ? $fib : 1);\n    }\n    return $fib;\n}\n</cell>\n<cell>",
  '    my $fib4;', "    my $fib4 = 0.0;\n    my $i = 1;\n    for(my $j = $n; $i <=\
    \ $j; $i++) {\n        $fib4 += $i;\n    }\n    return $fib4;\n}", "    my $fib4_last\
    \ = 0;\n    my $fib4_next = 1;\n    my $fib4_temp = 0;\n    my $fib4_current =\
    \ 0;\n    my $fib4_nextnext = 0;\n    \n    for ($fib4_last, $fib4_next, $fib4_temp,\
    \ $fib4_current, $fib4_nextnext, $fib4_last, $fib4_next, $fib4_temp, $fib4_current,\
    \ $fib4_nextnext, $fib4_last, $fib4_next, $fib4_temp, $fib4_current, $fib4_nextnext,\
    \ $fib4_last, $fib4_next, $fib4_temp, $fib4_current, $fib4_nextnext) in (0..($n-1))\
    \ {\n        $fib4_last = $fib4_next;\n        $fib4_next = $fib4_temp + $fib4_current;\n\
    \        $fib4_temp = $fib4_current;\n        $fib4_current = $fib4_nextnext;\n\
    \        $fib4_nextnext = $fib4_last + $fib4_next;\n    }\n    \n    return $fib4_nextnext;\n\
    }", "    return $fib4{$n} if $fib4{$n};\n    $fib4{$n} = fib4($n-1) + fib4($n-2)\
    \ + fib4($n-3) + fib4($n-4);\n}", "    $n < 4 or return;\n    $fib4 += $n;\n \
    \   return $fib4;\n}\n</code>\n<|/ a tags=algorithm,perl |>\n<| c |>\n: You are\
    \ correct, I've corrected the code and added some comments for explaining it.\n\
    <|/ c |>\n<| c |>\n\"Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence.  Do not use recursion.\" Why not recursion? I'm\
    \ thinking there might be a way to avoid recursion, but it seems pretty hard to\
    \ me.\n<|/ c |>\n<| c |>\nThe definition of fib4 includes a recurrence relation.\
    \ The definition itself could have been much simpler.\n<|/ c |>\n<| a dscore=4\
    \ tags=algorithm,perl |>\nHere is my solution (using recursion only). It computes\
    \ fibonacci numbers in less than O(1) using memoization.\n<code>", "    if ($n\
    \ == 0) {\n        return 0;\n    }\n    if ($n == 1) {\n        return 1;\n \
    \   }\n    if ($n == 2) {\n        return 2;\n    }\n    if ($n == 3) {\n    \
    \    return 0;\n    }\n    return fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    }", '    my $fib4;', "    my $fib = 0 + 0;\n    my @seq;\n    push @seq, $fib;\n\
    \    while ($n--) {\n        $fib = $fib + 0 + 0 + 0 + 0 + 0 + 0 + 0 + $fib;\n\
    \        push @seq, $fib;\n    }\n    $seq[0] = $fib;\n    $seq[-1] = $fib;\n\
    \    return @seq;\n}", "    if ($n eq 0) {\n        return 0;\n    } elsif ($n\
    \ eq 1) {\n        return 0;\n    } elsif ($n eq 2) {\n        return 2;\n   \
    \ } elsif ($n eq 3) {\n        return 0;\n    } elsif ($n > 0) {\n        return\
    \ fib4($n - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n - 4);\n    }\n}", "   \
    \ $n++ if $n <= 0;\n    return $fib4[$n] if $fib4[$n];\n    my $fib = 0;\n   \
    \ for ($n-1) { $fib = $fib + $fib4[$n-1] }\n    return $fib;\n}", "    # Your\
    \ code here\n    $fib4 = $fib4 + $fib4-1+ $fib4-2+ $fib4-3+ $fib4-4; # fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    return $fib4;\n}", "    my $fib4 =\
    \ 0, $fib5 = 1, $fib6 = 2, $fib7 = 3;\n    while ($n) {\n        $fib4 += $fib5;\n\
    \        $fib5 += $fib6;\n        $fib6 += $fib7;\n        $fib7 += $fib4;\n \
    \       $n--;\n    }\n    return $fib4;\n}", "    my($result) = 0;\n    while\
    \ ($n > 0) {\n        $result = $fib4($n-1) + $fib4($n-2) + $fib4($n-3) + $fib4($n-4)\
    \ + $result;\n        $n--;\n    }\n    return $result;\n}", "    my $fib4 = 0;\n\
    \    for ( my $i = 0; $i < $n; $i++ ) {\n        $fib4 += $fib4 * ($n-$i+1);\n\
    \    }\n    return $fib4;\n}\n</code>\nAnd now on to the Fibonacci sequence!\n\
    <code>", "    my $fib = ($n > 0) ? ($fib4($n - 1) + $fib4($n - 2) + $fib4($n -\
    \ 3) + $fib4($n - 4)) : 0;\n    return $fib;\n}\n</code>\n<|/ a dscore=3 tags=functional-programming,language-agnostic,language-design,memoization\
    \ |>\n<| a dscore=2 |>\nMemoization is used in various functional languages including\
    \ Scheme, Common Lisp, Haskell, F#, OCaml, OCaml FP language, Common Lisp FP language,\
    \ OCaml FP language, Fortran, OCaml FP language, C and Java. Those languages allow\
    \ you to store values computed by a function call in a data structure so that\
    \ those values are reused if the same arguments are passed to the function again.\
    \ The value returned by a function is stored in the data structure. \nThe function\
    \ below is a memoized version of the fibonacci function found on the wikipedia\
    \ page:\n<code>\nlet fib = (fun n -> if n < 2 then n else fib (n-1) + fib (n-2))\
    \ 0\n</code>\nThe memoized function is called with the arguments 0 and 1, which\
    \ returns 0 if passed less than 2 arguments, otherwise it will recursively call\
    \ the function passing arguments of n-1 and n-2 so that fib will return the right\
    \ value each time.\n<|/ a tags=functional-programming,language-agnostic,language-design,memoization\
    \ |>\n<| a dscore=2 |>\nA little bit late, but I wanted to add this answer to\
    \ mention that a good language has support for memoization. \nI assume a modern\
    \ language like F# that doesn't come with a memoize function or equivalent would\
    \ not be able to do this.\n<|/ a tags=functional-programming,language-agnostic,language-design,memoization\
    \ |>\n<| a |>\nIf you're using an imperative language then you can use a hash\
    \ map to store your intermediate calculations. When you call your function check\
    \ to see if you've already computed your value. \nSo for example:\n<code>\nhashmap\
    \ := {0 => 0,\n            1 => 1,\n            2 => 2,\n            3 => 3,\n\
    \            4 => 4,\n            5 => 5,\n            6 => 6}", "    my $fib4\
    \ = 0;\n    if ($n > 4) {\n        $fib4 = $fib4 + $fib4 + $fib4 + $fib4;\n  \
    \  }\n    elsif ($n == 0) {\n        $fib4 = 0;\n    }\n    elsif ($n == 1) {\n\
    \        $fib4 = 0;\n    }\n    elsif ($n == 2) {\n        $fib4 = 2;\n    }\n\
    \    elsif ($n == 3) {\n        $fib4 = 0;\n    }\n    else {\n        $fib4 =\
    \ $fib4 + $fib4 + $fib4 + $fib4;\n    }\n    return $fib4;\n}", "    # implement\
    \ using an accumulator variable\n    $fib4 += $fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + (", "    \n    my $fib4;\n    \n    for\
    \ ($n..0) {\n        $fib4 += $_ * 4;\n    }\n    \n    return $fib4;\n}", " \
    \   if ($n == 0) {\n        return 0;\n    } elsif ($n == 1) {\n        return\
    \ 1;\n    } elsif ($n == 2) {\n        return 2;\n    } elsif ($n == 3) {\n  \
    \      return 0;\n    }\n    return fib4($n - 1) + fib4($n - 2) + fib4($n - 3)\
    \ + fib4($n - 4);\n}", "    my $fib;\n    if ($n <= 1){\n        $fib = 0;\n \
    \   }\n    if ($n <= 2){\n        $fib = 1;\n    }\n    if ($n <= 3){\n      \
    \  $fib = 2;\n    }\n    if ($n <= 4){\n        $fib = 0;\n    }\n    if ($n <=\
    \ 5){\n        $fib = 0;\n    }\n    if ($n <= 6){\n        $fib = 2;\n    }\n\
    \    if ($n <= 7){\n        $fib = 1;\n    }\n    if ($n <= 8){\n        $fib\
    \ = 3;\n    }\n    if ($n <= 9){\n        $fib = 0;\n    }\n    if ($n <= 10){\n\
    \        $fib = 0;\n    }\n    if ($n <= 11){\n        $fib = 3;\n    }\n    if\
    \ ($n <= 12){\n        $fib = 5;\n    }\n    if ($n <= 13){\n        $fib = 7;\n\
    \    }\n    if ($n <= 14){\n        $fib = 11;\n    }\n    if ($n <= 15){\n  \
    \      $fib = 17;\n    }\n    if ($n <= 16){\n        $fib = 15;\n    }\n    if\
    \ ($n <= 17){\n        $fib = 11;\n    }\n    if ($n <= 18){\n        $fib = 11;\n\
    \    }\n    if ($n <= 19){\n        $fib = 11;\n    }\n    if ($n <= 20){\n  \
    \      $fib = 11;\n    }\n    if ($n <= 21){\n        $fib = 11;\n    }\n    if\
    \ ($n <= 22){\n        $fib = 11;\n    }\n    if ($n <= 23){\n        $fib = 21;\n\
    \    }\n    if ($n <= 24){\n        $fib = 23;\n    }\n    if ($n <= 25){\n  \
    \      $fib = 31;\n    }\n    if ($n <= 26){\n        $fib = 25;\n    }\n    if\
    \ ($n <= 27){\n        $fib = 26;\n    }\n    if ($n <= 28){\n        $fib = 27;\n\
    \    }\n    if ($n <= 29){\n        $fib = 27;\n    }\n    if ($n <= 30){\n  \
    \      $fib = 27;\n    }\n    if ($n <= 31){\n        $fib = 27;\n    }\n    if\
    \ ($n <= 32){\n        $fib = 29;\n    }\n    if ($n <= 33){\n        $fib = 31;\n\
    \    }\n    if ($n <= 34){\n        $fib = 33;\n    }\n    if ($n <= 35){\n  \
    \      $fib = 31;\n    }\n    if ($n <= 36){\n        $fib = 37;\n    }\n    if\
    \ ($n <= 37){\n        $fib = 33;", "    if ($n < 4) { $n = 0 + $n; }\n    if\
    \ ($n < 8) {\n\t$n = 0 + $n + fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    \    }\n    return $n;\n}\n\f", "    if ( $n == 0 ) {\n\t0\n    } elsif ( $n ==\
    \ 1 ) {\n\t1\n    } elsif ( $n == 2 ) {\n\t2\n    } elsif ( $n == 3 ) {\n\t0\n\
    \    } elsif ( $n > 4 ) {\n\tfib4($n - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n\
    \ - 4)\n    } else {\n\tdie(\"fib4 number sequence incorrect\");\n    }\n}", " \
    \   if($n<3){\n\treturn $n;\n    }\n    elsif($n<6){\n\treturn $n;\n    }\n  \
    \  elsif($n<9){\n\treturn $n*5+fib4($n-2);\n    }\n    elsif($n<15){\n\treturn\
    \ $n*5+fib4($n-2);\n    }\n    elsif($n<21){\n\treturn $n*5+fib4($n-2);\n    }\n\
    \    elsif($n<25){\n\treturn $n*5+fib4($n-3);\n    }\n    elsif($n<31){\n\treturn\
    \ fib4($n-2);\n    }\n    elsif($n<36){\n\treturn fib4($n-3)+fib4($n-4);\n   \
    \ }\n    elsif($n<45){\n\treturn fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4);\n\
    \    }\n    elsif($n<55){\n\treturn fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4)+fib4($n-5);\n\
    \    }\n    elsif($n<65){\n\treturn fib4($n-2)+fib4($n-3)+fib4($n-4)+fib4($n-5)+fib4($n-6);\n\
    \    }\n    elsif($n<75){\n\treturn fib4($n-3)+fib4($n-4)+fib4($n-5)+fib4($n-6)+fib4($n-7);\n\
    \    }\n    elsif($n<85){\n\treturn fib4($n-4)+fib4($n-5)+fib4($n-6)+fib4($n-7)+fib4($n-8);\n\
    \    }\n    elsif($n<95){\n\treturn fib4($n-5)+fib4($n-6)+fib4($n-7)+fib4($n-8)+fib4($n-9);\n\
    \    }\n    elsif($n<105) {\n\treturn fib4($n-6)+fib4($n-7)+fib4($n-8)+fib4($n-9)+fib4($n-10);\n\
    \    }\n    elsif($n<115) {\n\treturn fib4($n-7)+fib4($n-8)+fib4($n-9)+fib4($n-10)+fib4($n-11);\n\
    \    }\n    elsif($n<125) {\n\treturn fib4($n-8)+fib4($n-9)+", "    my @fib;\n\
    \    for (1..$n) { push(@fib, $_->($_)) }\n    return $fib[$n];\n}", "    my $result\
    \ = 0;\n    until($n) {\n        $result += $n % 4;\n        $n /= 4;\n    }\n\
    \    return $result;\n}", "    return $fib4_cache[($fib4_cache_index + 1)%@fib4_cache_length]\
    \ if (exists $fib4_cache[$fib4_cache_index]);\n    if ($fib4_cache_index == @fib4_cache_length)\
    \ {\n        $fib4_cache = $fib4_cache + [0, 1, 1, 2];\n        $fib4_cache_index\
    \ = 0;\n    }\n    my $fib4_cache = @fib4_cache;\n    my $fib4_cache_index = 0;\n\
    \    while ($fib4_cache_index <= $n) {\n        $fib4_cache_index += 1;\n    \
    \    my $fib4 = ($fib4_cache[$fib4_cache_index - 1] + $fib4_cache[$fib4_cache_index\
    \ - 2] + $fib4_cache[$fib4_cache_index - 3] + $fib4_cache[$fib4_cache_index -\
    \ 4])%10;\n        $fib4_cache[$fib4_cache_index] = $fib4;\n    }\n    return\
    \ $fib4_cache[$fib4_cache_index];\n}\n</cell>\n<cell>", "    \n    if ($n < 0)\
    \ {\n        $n = 0 - $n;\n    }\n    \n    my $fib = $fib4($n);\n    \n    return\
    \ $fib;\n}", "    return 0 if $n == 0;\n    return $n == 4 ? 4 : $n == 3 ? 3 :\
    \ $n == 2 ? 2 : 1;\n}", "    $n = $n%4;\n    $n = 3*$n+1;\n    return $n%4;\n}",
  "    $fib4{$n} ||= 0;\n    $fib4{$n}++;\n}\n</code>\nfib4_sub now just returns the\
    \ fib4 number for $n:\n<code>", "    my $fib4 = 0;\n    my $i = 1;\n    while($n\
    \ >= $i) {\n\t$fib4 += $i;\n\t$i = $i + 1;\n    }\n    $fib4;\n}", "    return\
    \ 0 unless $n;\n    $fib4[$n] or $fib4[$n] = fib4($n-1) + fib4($n-2) + fib4($n-3)\
    \ + fib4($n-4) ;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThanks for the answer.\
    \ I was wondering, how would you do it in your opinion? It seems like the most\
    \ efficient and fastest way. I was thinking of using arrays, but I can't figure\
    \ out how you would compute each element of the array.\n<|/ c |>\n<| c |>\nSee\
    \ my update above.  I've added a recursive subroutine to compute the fibonacci\
    \ number sequence.\n<|/ c |>\n<| c |>\nThat is very similar to how I did it (except\
    \ I used an array). Thanks for your help\n<|/ c |>\n<| c |>\nSorry, I missed your\
    \ comment earlier. I see what you did now. I will implement your method and see\
    \ how it works.\n<|/ c |>\n<| a dscore=2 tags=perl |>\nJust to be clear, the first\
    \ answer you posted didn't do what you wanted.\n<code>\nmy $f = 4; # fib4 = fib\
    \ n\n$f->( 5 );\n</code>\ndoes nothing.\nThe function you needed was fib_n().\
    \  It returns a value based on the n argument.  You want something like this\n\
    <code>", "    if ( $n <= 2 ) {\n        return $n;\n    } elsif ( $n > 2 ) {\n\
    \        return fib4( $n - 1 ) + fib4( $n - 2 ) + fib4( $n - 3 ) + fib4( $n -\
    \ 4 );\n    }\n}", "    return 0 if ($n == 0);\n    return 0 if ($n == 1);\n \
    \   return 2 if ($n == 2);\n    return 0 if ($n == 3);\n    my $fib4 = (&fib4($n-1)\
    \ + &fib4($n-2) + &fib4($n-3))*&fib4($n-4);\n    return $fib4\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThe Fibonacci sequence is very interesting.  I have not yet seen\
    \ a better way of implementing it than using recursion.  It might be interesting\
    \ to see if you could find a non-recursive implementation that would run fast\
    \ enough.\n<|/ c |>\n<| a |>\nThis solution is similar to previous solutions but\
    \ I find it very easy to follow:\n<code>", "    return 0 if $n == 0;\n    $n++\
    \ if $n % 4 != 0;\n    return $n if $n > 3;\n    return $n * fib4(4) - fib4(4)\
    \ - fib4(3) + fib4(2);\n}", "    my $x;\n    for ($x = 0; $x <= $n; $x++) {\n\t\
    my $fib;\n\tif ($x == 1) {\n\t    $fib = 0;\n\t}\n\telsif ($x == 2) {\n\t    $fib\
    \ = 1;\n\t}\n\telsif ($x == 3) {\n\t    $fib = 2;\n\t}\n\telsif ($x == 4) {\n\t\
    \    $fib = 0;\n\t}\n\telsif ($x <= 5) {\n\t    $fib = ($x * $fib)+($x - 2);\n\
    \t}\n\telse {\n\t    $fib = ($x * $fib)+($x - 4);\n\t}\n    }\n    return $fib;\n\
    }", "    my($result);\n    my $f = 0;\n    my $a = 1;\n    my $b = 1;\n    my\
    \ $c = 1;\n    my $d = 1;\n    my $e = 1;\n    for(my $i=0; $i<=$n; $i++) {\n\
    \        $f = $a + ($b * $c);\n        $e = $a + ($b * $d);\n        $c = $d;\n\
    \        $d = $e;\n        $a = $b;\n        $b = $f;\n    }\n    $result = $e;\n\
    \    return $result;\n}", "    my $fib4 = ($n < 5) ? 1 : $fib4 + $fib4 + ($n <\
    \ 7) ? 1 : $fib4 + $fib4 + ($n < 9) ? 1 : $fib4 + $fib4 + ($n < 11) ? 1 : 0;\n\
    \    return $fib4;\n}", "    return $fib4[$n] if defined $fib4[$n];\n    if (\
    \ $n == 1 ) {\n        return 0;\n    }\n    if ( $n == 2 ) {\n        return\
    \ 1;\n    }\n    if ( $n == 3 ) {\n        return 1;\n    }\n    if ( $n == 4\
    \ ) {\n        return 2;\n    }\n    $fib4[$n] = fib4( $n-1 ) + fib4( $n-2 ) +\
    \ fib4( $n-3 ) + fib4( $n-4 );\n}", "    my $prev = 0;\n    my $current = 0;\n\
    \    my $sum = 0;\n    for (my $i = $n; $i > 0; $i--) {\n        $prev = $current;\n\
    \        $current = $prev + $prev - $current;\n        $sum = $prev + $sum + $current;\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ q tags=big-o,algorithm |>\n<| c |>\n\
    This is a pretty standard math problem. Take a look at [this video](http://www.youtube.com/watch?v=EZ8QXxMlY6k),\
    \ which covers the \"fibonacci series\" problem in mathematics and programming.\
    \ It explains the Fibonacci function and how to compute it in both languages,\
    \ and the complexity of computing it (O(log n)).\n<|/ c |>\n<| c |>\nIf you're\
    \ interested in algorithms, that's a good place to start.  There are some good\
    \ videos on youtube too. http://www.youtube.com/watch?v=2U1tPQyzGjY\n<|/ c |>\n\
    <| c |>\nI think you were thinking of a different problem than this one - this\
    \ one is about computing fibonacci numbers in O(n) time, as opposed to computing\
    \ fibonacci numbers in O(log n) time.\n<|/ c |>\n<| a tags=big-o,algorithm dscore=2\
    \ |>\nThe complexity of computing the fibonacci number is O(log n) because each\
    \ number in the fibonacci sequence is added and subtracted from the previous number.\
    \ So, the first element is the 0th element of the sequence. \nThe complexity of\
    \ computing the nth element in the fibonacci number is O(log n) because the number\
    \ n is being used to index into the sequence. And, the sequence is iterated forwards\
    \ and backwards.\n<|/ a |>\n<| c |>\n\"The complexity of computing the nth element\
    \ in the fibonacci number is O(log n) because the number n is being used to index\
    \ into the sequence\" - this does not make any sense to me. Why is the complexity\
    \ O(log n) instead of O(n)?\n<|/ c |>\n<| c |>\nThe complexity of computing the\
    \ nth element in the fibonacci number is O(log n) because the number n is being\
    \ used to index into the sequence. And, the sequence is iterated forwards and\
    \ backwards.\n<|/ c |>\n<| c |>\nO(log n) because each number in the fi", "  \
    \  my $a = $n < 3 ? 1 : ($n - 4) / 2;\n    my $b = $n < 3 ? 0 : ($n - 4) % 2;\n\
    \    return $a + $b + fib4($a - 1) + fib4($b - 1);\n}", "    $n = 0 if $n < 0;\n\
    \    my $f = 4;\n    my $fib;\n    while ($n > 1) {\n\tmy $tmp = $f + ($f - 1);\n\
    \tmy $tmp2 = $f + ($f - 2);\n\tmy $tmp3 = $f + ($f - 3);\n\t$fib = $tmp if $n\
    \ == 0;\n\t$fib = $tmp2 if $n == 1;\n\t$fib = $tmp3 if $n == 2;\n\t$f = $tmp;\n\
    \t$n--;\n    }\n    return $fib;\n}", "    my $a = 0;\n    my $b = 0;\n    my\
    \ $c = 0;\n    my $d = 0;\n    while ($n >= 0) {\n        $a += $b;\n        $c\
    \ += $d;\n        $b += $c;\n        $d += $a;\n        $n--;\n    }\n    return\
    \ $d;\n}", "    return $fib4{$n} if exists $fib4{$n};\n    my ($a, $b, $c, $d);\n\
    \    my $n1 = $fib4{$n-1};\n    my $n2 = $fib4{$n-2};\n    my $n3 = $fib4{$n-3};\n\
    \    my $n4 = $fib4{$n-4};\n    $d = $n4 if $n4 == 0;\n    $a = $n3 if $n3 ==\
    \ 0;\n    $b = $n2 if $n2 == 0;\n    $c = $n1 if $n1 == 0;\n    $fib4{$n} = $a\
    \ + $b + $c + $d;\n}", "    my $i = 0;\n    my $fib = 0;\n    while($i <= $n)\
    \ {\n        $fib = $fib + $fib + $fib + $fib;\n        $i++;\n    }\n    return\
    \ $fib;\n}", "    return 0 if $n < 0;\n    my $ans = 0 if $n == 0;\n    $ans +=\
    \ 1 if $n == 1;\n    $ans += 1 if $n == 2;\n    $ans += 1 if $n == 3;\n    $ans\
    \ += 1 if $n == 4;\n    $ans += 1 if $n == 5;\n    $ans += 1 if $n == 6;\n   \
    \ $ans += 1 if $n == 7;\n    return $ans;\n}", "    # base case\n    if ($n ==\
    \ 0) {\n        return 0;\n    }\n    \n    my $num = 1;\n    \n    # iterate\
    \ over each previous element and add\n    while ($n > 1) {\n        $num *= $n;\n\
    \        $num += $num - $n;\n        $n--;\n    }\n    \n    return $num;\n}",
  "    # base case\n    if ($n == 0) {\n        return 0;\n    }\n    if ($n == 1)\
    \ {\n        return 1;\n    }\n    if ($n == 2) {\n        return 2;\n    }\n\
    \    # recursive case\n    return fib4($n - 1) + fib4($n - 2) + fib4($n - 3) +\
    \ fib4($n - 4);\n}", "    my $fib = 0;\n    my $x = 0;\n    my $y = 1;\n    my\
    \ $fib4 = 0;", "    $n++ if $n =~ /^\\d+$/;\n    my $fib = 0;\n    my $i = 0;\n\
    \    $fib += $i; $i++ while ($i <  $n);\n    $fib -= $i; $i++ while ($i <  $n);\n\
    \    return $fib;\n}\n</code>\nThis is similar to the previous example.  But it\
    \ does it using recursion, so no loops!\nThe fib4 function can be rewritten as:\n\
    <code>", "    if ($n < 4 || $n >= 100000) {\n        die \"fib4 number sequence\
    \ is invalid, n = $n\\n\";\n    }\n    my $fib4;\n    if ($n eq 0) {\n       \
    \ $fib4 = 0;\n    } elsif ($n eq 1) {\n        $fib4 = 0;\n    } elsif ($n eq\
    \ 2) {\n        $fib4 = 2;\n    } elsif ($n eq 3) {\n        $fib4 = 0;\n    }\
    \ elsif ($n eq 4) {\n        $fib4 = 0;\n    } else {\n        $fib4 = ( $fib4(5)\
    \ + $fib4(6) + $fib4(7) + $fib4(8) );\n    }\n    return $fib4;\n}", "    my $fib4\
    \ = 0; \n    for($n; $n>0; $n--) {\n        $fib4 += $n; \n    }\n    return $fib4;\n\
    }\n</code>\n<|/ a tags=fibonacci,math,perl |>\n<| a dscore=0 |>\nHere is a recursive\
    \ version which does not use recursion.\n<code>", "    return 0 if ($n <= 1);\n\
    \    return 0 if ($n <= 2);\n    return 2 if ($n <= 3);\n    return 0 if ($n <=\
    \ 4);\n    return fib4(@_[2,4,6,8]);\n}", "    if($n == 0) {\n        return 0;\n\
    \    } elsif ($n == 1) {\n        return 0;\n    } elsif ($n == 2) {\n       \
    \ return 2;\n    } elsif ($n == 3) {\n        return 0;\n    } elsif ($n == 4)\
    \ {\n        return 1;\n    }\n    $fib4 += 1;\n    $fib4 += $fib4 + $fib4 + $fib4\
    \ + $fib4;\n    return $fib4;\n}", "    my $fib_n = ($n-1)/4;\n    my $fib_n_1\
    \ = $fib_n - 1;\n    my $fib_n_2 = $fib_n - 2;\n    my $fib_n_3 = $fib_n - 3;\n\
    \    my $fib_n_4 = $fib_n - 4;\n    my $fib4_1 = $fib_n_1 + $fib_n_2 + $fib_n_3\
    \ + $fib_n_4;\n    my $fib4_2 = $fib4_1 + $fib_n_2 + $fib_n_3 + $fib_n_4;\n  \
    \  my $fib4_3 = $fib4_2 + $fib_n_3 + $fib_n_4;\n    my $fib4_4 = $fib4_3;\n  \
    \  return $fib4_4;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI believe that `fib4_3`\
    \ should be `fib4_4`.\n<|/ c |>\n<| c |>\nYes it should! Thanks. Will edit.\n\
    <|/ c |>\n<| a tags=fibonacci,sequence,math,perl |>\nThe Fibonacci sequence is\
    \ a linear recurrence relation.\n<code>\nf(x) = 1 if x=1\nf(x) = 1 if x=2\nf(x)\
    \ = 1 if x= 1+f(x-1)\n</code>\nThis can be simplified to\n<code>\nf(x) = 1 if\
    \ x=0 or x=1\nf(x) = 1 if x= 1+f(x-1)\n</code>\nwhich is equivalent to\n<code>\n\
    f(x) = 1 if x=2\n</code>\nThus we can implement this sequence in a recursive form\n\
    <code>\nf(x) = 1 if x=0\nf(x) = 1 if x=1\nf(x) = 1 if x= 1+f(x-1)\n</code>\nand\
    \ write it in Perl in the following way\n<code>", "    if ($n == 0) return 0;\n\
    \    if ($n == 1) return 0;\n    if ($n == 2) return 2;\n    return fib4($n-1)\
    \ + fib4($n-2) + fib4($n-3) + fib4($n-4);\n}", "    my @fib;\n    if ($n <= 0)\
    \ {\n        $fib[0] = 0;\n        $fib[1] = 0;\n        $fib[2] = 2;\n      \
    \  $fib[3] = 0;\n    } else {\n        my($fib0, $fib1, $fib2, $fib3) = (0, 1,\
    \ 0, 1);\n        my $fib4;\n        while ($fib3 <= $n) {\n            $fib4\
    \ += $fib3 * ($fib3 * ($fib3 * ($fib3 + $fib2) + $fib1) + $fib0);\n          \
    \  $fib1 += $fib3;\n            $fib2 += $fib3;\n            $fib3 += $fib3;\n\
    \        }\n        $fib[3] = $fib4;\n    }\n    return $fib[3];\n}\n</cell>\n\
    <text>\nFibonacci number generator\nThe Fibonacci number is defined by the following\
    \ relation:", "    my $sum = 0;\n    for(my $i = 0; $i <= $n; $i++) {\n      \
    \  $sum += $i * ($i + 1) * ($i + 2) * ($i + 3);\n    }\n    return $sum;\n}\n\
    </code>\nIn order to get this to work efficiently, you need to keep track of the\
    \ current Fib4 number sequence you are currently trying to process. You can do\
    \ this by declaring a variable and assigning it to fib4 inside the subroutine.\
    \ Also as noted in the documentation, you need to declare the subroutine's prototype\
    \ with the sub's arguments and a return value. The prototypes usually look like:\
    \ sub functionName {. Do a search in your favorite language book for example subroutines\
    \ prototype and it will likely be explained in detail.\n<|/ a |>\n<| c |>\nA couple\
    \ things: 1. I used `fib4` instead of `fib4`, so I'm pretty sure the Perl compiler\
    \ won't let me down if I do that. I also used `fib4` instead of `fibbonacci`.\
    \ This was probably my oversight, but it's not necessarily a bad idea. 2. You're\
    \ assuming that `fib4` returns a number. I think it returns `NaN`. I think a `Float`\
    \ should work fine. 3. You can declare a prototype with `sub fib4 {}`, but you\
    \ don't need to declare a prototype. If you do that, you don't need to return\
    \ anything.\n<|/ c |>\n<| c |>\nGood points about `NaN`, I'll change that. Regarding\
    \ prototypes, it depends on your version of Perl. Earlier versions would require\
    \ you to return a value. I personally avoid prototypes because my code looks really\
    \ strange. Prototypes also have their own problems, like not being able to use\
    \ variables in the prototype. I don't know if this is an issue with your version,\
    \ but I tend to stay away from prototypes, especially since Perl has had them\
    \ since Perl 5.0. I'll update my answer to include `fib4`'s prototype too.\n<|/\
    \ c |>\n<| c |>\nThanks for the update! I didn't know about prototypes. It looks\
    \ much better now. Also, Perl 5.14.2 on my machine seems to handle it just fine,\
    \ so there's no need to worry about it. I would've been fine with just returning\
    \ `NaN`, but then my code wouldn't be so readable. My version prints `4` instead\
    \ of `14`, so I added the return statement for that case.\n<|/ c |>\n<| a tags=perl,fib4,algorithm,memoization\
    \ |>\nYour memoization algorithm is fine, except that it doesn't work for n =\
    \ 0 or n = 4 (as your ", "    my(@fibs) = ();\n    for(my $i = 1; $i <= $n; $i++)\
    \ {\n        push (@fibs, $fibs[$i-1] + $fibs[$i-2] +  $fibs[$i-3] + $fibs[$i-4]);\n\
    \    }\n    return $fibs[$n-1];\n}", "    my $fib4;\n    for($n){\n        if($n\
    \ =~ m/0$/){\n            $fib4 = 0;\n        }\n        elsif($n =~ m/1$/){\n\
    \            $fib4 = 0;\n        }\n        elsif($n =~ m/2$/){\n            $fib2\
    \ = 2;\n        }\n        elsif($n =~ m/3$/){\n            $fib4 = 0;\n     \
    \   }\n        elsif($n =~ m/4$/){\n            $fib4 = 2;\n        }\n      \
    \  $fib4 += $fib4 + $fib4;\n    }\n    return $fib4;\n}", "    my $fib4 = $_[$n];\n\
    \    return $fib4 if $fib4 > 0;\n    $fib4 = 0;\n    for (0 .. $n-1) {\n\t$fib4\
    \ = $fib4 + $_[$n-$_+1];\n    }\n    $_[$n] = $fib4;\n    return $fib4;\n}", " \
    \   if ($n <= 0) {\n        return 0;\n    }\n    if ($n == 1) {\n        return\
    \ 0;\n    }\n    if ($n == 2) {\n        return 2;\n    }\n    if ($n == 3) {\n\
    \        return 0;\n    }\n    return fib4($n - 1) + fib4($n - 2) + fib4($n -\
    \ 3) + fib4($n - 4);\n}", "    my $a = 0;\n    for (1..$n) {\n        $a = $a+$a-1;\n\
    \    }\n    return $a;\n}\n</cell>\n<text>\nProblem 5\nThe Fibonacci sequence\
    \ is defined by the recurrence relation:\n$$Fn = F{n-1} + F_{n-2},$$\nwhere $F_{0}\
    \ = 0, F_{1} = 1$ and $F_{n} = 0 for n > 2.\nBy convention, $F_n$ will always\
    \ be real.\nIt can be seen that $F_n = F{n-1}^2 + F{n-2}$.\nBy listing the first\
    \ six terms of the sequence in descending order,\nwe get:\n$$Fn = F{n-1}^2 + F{n-2}^2\
    \ + F_{n-3}^2 + F_{n-4}^2 + F_{n-5}^2 + F_{n-6}^2.$$\nUsing the property that\
    \ $a + b = 1$, we can write:\n$$Fn = F{n-1}^2 + 2F_{n-2}^1 + F{n-3}^1 + 2F_{n-4}^0\
    \ + F{n-5}^0 + 2F_{n-6}^0 + F{n-7}^0.$$\nIt can be shown that $F_n = F{n-1}^2\
    \ \\cos \\theta(3) + F{n-2}^2 \\cos \\theta(2) + F{n-3}^2 \\cos \\theta(1) + F{n-4}^2\
    \ \\cos \\theta(0) + \\cos\\theta(0) F{n-5}^2 \\cos\\theta(1) + \\cos\\theta(0)\
    \ F{n-6}^2 \\cos\\theta(2) + \\cos\\theta(0) F{n-7}^2 = \\cos(\\theta)^2(F{n-1}^2\
    \ + F{n-2}^2 + F{n-3}^2 + F{n-4}^2 + F_{n-5}^2 + F_{n-6}^2 + F_{n-7}^2).$$\nUsing\
    \ algebraic identities, we can simplify this to:\n$$Fn = \\cos\\theta(F{n-1}^2\
    \ + F{n-2}^2 + F{n-3}^2 + F{n-4}^2 + F_{n-5}^2 + F_{n-6}^2 + F_{n-7}^2).$$\nUsing\
    \ trigonometry, $F_n$ can be expressed as:\n$$F_n = ", "    return $n if $n <=\
    \ 3;\n    $n = 0;\n    do {\n        $n++ while $n++ < $n-1;\n    } while $n <=\
    \ $#_;\n    return $n[$_-1] + $n[$_-2] + $n[$_-3] + $n[$_-4];\n}", "    return\
    \ 0 if $n <= 2;\n    return $n*fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    }", "    if ($n <= 0) {\n\treturn 0;\n    } elsif ($n == 1) {\n\treturn 0;\n \
    \   } elsif ($n == 2) {\n\treturn 2;\n    } elsif ($n == 3) {\n\treturn 0;\n \
    \   } elsif ($n >= 4) {\n\treturn fib4($n - 4) + fib4($n - 3) + fib4($n - 2) +\
    \ fib4($n - 1);\n    }\n    return fib4($n - 4) + fib4($n - 3) + fib4($n - 2)\
    \ + fib4($n - 1);\n}", "    if($n == 0) {\n        return 0;\n    }\n    elsif($n\
    \ == 1) {\n        return 0;\n    }\n    elsif($n == 2) {\n        return 2;\n\
    \    }\n    elsif($n == 3) {\n        return 0;\n    }\n    elsif($n == 4) {\n\
    \        return 0;\n    }\n    elsif($n == 5) {\n        return 4;\n    }\n  \
    \  elsif($n == 6) {\n        return 8;\n    }\n    elsif($n == 7) {\n        return\
    \ 14;\n    }\n    elsif($n == 8) {\n        return 28;\n    }\n    elsif($n ==\
    \ 9) {\n        return 56;\n    }\n    elsif($n == 10) {\n        return 90;\n\
    \    }\n    elsif($n == 11) {\n        return 126;\n    }\n    elsif($n == 12)\
    \ {\n        return 150;\n    }\n    elsif($n == 13) {\n        return 184;\n\
    \    }\n    elsif($n == 14) {\n        return 210;\n    }\n    elsif($n == 15)\
    \ {\n        return 246;\n    }\n    elsif($n == 16) {\n        return 280;\n\
    \    }\n    elsif($n == 17) {\n        return 314;\n    }\n    elsif($n == 18)\
    \ {\n        return 348;\n    }\n    elsif($n == 19) {\n        return 372;\n\
    \    }\n    elsif($n == 20) {\n        return 406;\n    }\n    elsif($n == 21)\
    \ {\n        return 440;\n    }\n    elsif($n == 22) {\n        return 473;\n\
    \    }\n    elsif($n == 23) {\n        return 507;\n    }\n    elsif($n == 24)\
    \ {\n        return 541;\n    }\n    elsif($n == 25) {\n        return 585;\n\
    \    }\n    elsif($n == 26) {\n        return 622;\n    }\n    elsif($n == 27)\
    \ {\n        return 666;\n    }\n    elsif($n == 28) {\n        return 710;\n\
    \    }\n    elsif($n == 29) {\n        return 745;\n    }\n    elsif($n == 30)\
    \ {\n        return 789;\n    }\n    elsif($n == 31) {\n        return 823;\n\
    \    }\n    elsif($n == 32) {\n        return 858;\n    }\n    elsif($n == 33)\
    \ {\n        return 893;\n    }\n    elsif($n == 34) {\n        return 928;\n\
    \    }\n    elsif($n == 35) {\n        return 963;\n    }\n    elsif($n == 36)\
    \ {\n        return 1009;\n    }\n    el", "    my $fib4 = 0;\n    while ($n >\
    \ 0) {\n        $fib4 += $fib4 if $n % 4 == 0;\n        $fib4 += $fib4 if $n %\
    \ 4 == 1;\n        $fib4 += $fib4 if $n % 4 == 2;\n        $fib4 += $fib4 if $n\
    \ % 4 == 3;\n        $fib4 += $fib4 if $n % 4 == 0;\n        $n--;\n    }\n  \
    \  return $fib4;\n}", "    $fib4 += 4 * $n; $fib4 -= $fib4 % $fib4; $fib4 %= $fib4;\
    \ $fib4 += $fib4 % $fib4;\n    return $fib4;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=math,algorithm,language-agnostic,numbers |>\nOkay, so this is homework\
    \ and my first shot at a solution was to start with the number 1, and subtract\
    \ a number from it whenever the number is larger than the previous number.  This\
    \ doesn't work for bigger numbers but for smaller ones it works well.  My first\
    \ attempt was to subtract numbers from the previous number and the current number\
    \ if the current number is larger than the previous number.  This doesn't work\
    \ well, but for bigger numbers it works well.\nI then tried subtracting numbers\
    \ from the previous number and the current number, if the current number is smaller.\
    \  This works well for bigger numbers but not for smaller ones.\nSo, after subtracting\
    \ numbers from the previous number and the current number, I subtracted from the\
    \ previous number and the current number, if the current number is smaller than\
    \ the previous number. This works well for both bigger and smaller numbers.  For\
    \ bigger numbers it works well even if the current number was smaller than the\
    \ previous number. For smaller numbers it doesn't work well if the current number\
    \ was smaller than the previous number.  \nI got very good performance on the\
    \ bigger numbers for about 5 million tests.  I couldn't get much better than this.\n\
    <|/ a dscore=2 |>\n<| c |>\nI like it. And it works very well for negative numbers.\
    \ But it breaks for 0 as the value of previous number becomes 1. You can fix it\
    \ by setting $prev to 1 before calling this subroutine and $n is negative and\
    \ $prev is positive after the call.\n<|/ c |>\n<| a dscore=1 |>\nA nice solution\
    \ is described here:\nhttp://en.wikipedia.org/wiki/Subtraction_rule#Subtraction_rule_for_the_sum_of_consecutive_powers_of_two\n\
    It works well for negative numbers, and is fast to compute (O(log N) iterations).\n\
    <|/ a tags=math,algorithm,language-agnostic,numbers |>\n<| a dscore=1 |>\n<code>\n\
    int fact(int n)\n{\n    if (n < 0)\n        return 1;\n    else return n * fact(n\
    \ - 1);\n}\n</code>\n<|/ a tags=math,algorithm,language-agnostic,numbers |>\n\
    <| c |>\nI like this solution, however, it doesn't work for negative numbers unfortunately.\n\
    <|/ c |>\n<| c |>\nThis is just for positive numbers. To make `fact(", "    my($fib4)\
    \ = { 0 => 0, 1 => 0, 2 => 2, 3 => 0, 4 => 4, 5 => 8, 6 => 14, 7 => 30, 8 => 60,\
    \ 9 => 90, 10 => 120, 11 => 144, 12 => 180, 13 => 210, 14 => 240, 15 => 280, 16\
    \ => 320, 17 => 360, 18 => 390, 19 => 420, 20 => 450, 21 => 480, 22 => 520, 23\
    \ => 560, 24 => 600, 25 => 635, 26 => 670, 27 => 700, 28 => 733, 29 => 760, 30\
    \ => 790, 31 => 825, 32 => 850, 33 => 875, 34 => 900, 35 => 935, 36 => 960, 37\
    \ => 990, 38 => 1020, 39 => 1050, 40 => 1080, 41 => 1110, 42 => 1140, 43 => 1170,\
    \ 44 => 1200, 45 => 1230, 46 => 1260, 47 => 1290};\n    return $fib4[$n];\n}",
  "    if ( $n == 0 ) {\n        return 0;\n    }\n    if ( $n == 1 ) {\n        return\
    \ 0;\n    }\n    if ( $n == 2 ) {\n        return 2;\n    }\n    if ( $n == 3\
    \ ) {\n        return 0;\n    }\n    return fib4($n-1) + fib4($n-2) + fib4($n-3)\
    \ + fib4($n-4);\n}", "    my $fib = 4;\n    while ($n > 0) {\n        $fib +=\
    \ ($n%$fib);\n        $n = ($n-1)/($fib*$fib);\n    }\n    return $fib;\n}", " \
    \   $n =~ tr/0/4/;\n    if ($n >= 4) { $n = fib4($n-1) + fib4($n-2) + fib4($n-3)\
    \ + fib4($n-4) }\n    return $n;\n}\n</code>\n<|/ a tags=perl,fibonacci |>\n<|\
    \ a tags=perl,fibonacci dscore=4 |>\n<code>\nmy $nth_fibonacci= sub { my $x =\
    \ $_[0]; return $x == 1 ? 1 : sub {  $x-=1; $x-=1; $x-=1; $x-=1 }->() };\n$nth_fibonacci(7)\n\
    </code>\n<|/ a |>\n<| a |>\n<code>", "    my($fib4); # We reuse $fib4 as we pass\
    \ it around\n    # Make sure $fib4 starts with zeroes and has length 4\n    my($length)\
    \ = length(join('',@fib4));\n    my($zeros) = '0';\n    my($x) = 0;\n    # Make\
    \ $fib4 with zeros and $length\n    while($x < $length) {\n        $fib4[$x] =\
    \ $zeros;\n        $fib4[$x+1] = $zeros;\n        $fib4[$x+2] = $zeros;\n    \
    \    $fib4[$x+3] = $zeros;\n        $x = $x + 4;\n    }\n    # Calculate the value\
    \ of $fib4[$n]\n    while($n < $length) {\n        $fib4[$n] = $fib4[$n-1] + $fib4[$n-2]\
    \ + $fib4[$n-3] + $fib4[$n-4];\n        $n = $n + 4;\n    }\n    return $fib4[$n];\n\
    }", "    if ( defined $n && $n > 0 ) {\n\t$_[0] = 0;\n\t$_[1] = 0;\n\t$_[2] =\
    \ 2;\n\t$_[3] = 0;\n\t$_[4] = 0;\n\tfor (my $i = 3; $i <= $n; ++$i) {\n\t    $_[4]\
    \ += $_[3] - $_[2] - $_[1] + $_[0];\n\t    $_[0] = $_[4];\n\t    $_[3] = $_[4]\
    \ - $_[3];\n\t    $_[2] = $_[4] - $_[2];\n\t    $_[1] = $_[4] - $_[1];\n\t}\n\
    \    }\n    return $_[0];\n}", "    if ($n < 0) { \n        $n = -$n;\n      \
    \  $n++ \n    } elsif ($n == 0) {\n        return 0;\n    } elsif ($n == 1) {\n\
    \        return 0;\n    } elsif ($n == 2) {\n        return 2;\n    } elsif ($n\
    \ == 3) {\n        return 0;\n    }\n    my $ret = 0;\n    my $i = 1;\n    while\
    \ ($i < $n) {\n        $ret += fib4($i-1) + fib4($i-2);\n        $i++;\n    }\n\
    \    return $ret;\n}", "    my @fib = (0);\n    for(my $i = 0; $i < $n; $i++)\
    \ {\n        push(@fib, pop(@fib));\n    }\n    return $fib[$n];\n}\n</code>\n\
    <|/ a tags=fibonacci,big-o,algorithm,perl |>\n<| c |>\nThe first thing I do when\
    \ I get stuck is revisit the problem and reformulate it a different way. I think\
    \ your suggestion was to look at fibonacci using a generator rather than a recursive\
    \ method.\n<|/ c |>\n<| a dscore=2 |>\nHere's a little function I wrote for finding\
    \ fibonacci numbers in Perl:\n<code>", "    my($fib4) = 0;\n    my($fib5) = 0;\n\
    \    my($fib6) = 0;\n    my($fib7) = 0;\n    my($fib8) = 0;\n    my($fib9) = 0;\n\
    \    while ($n > 1) {\n        $fib4 += $fib5;\n        $fib5 += $fib6;\n    \
    \    $fib6 += $fib7;\n        $fib7 += $fib8;\n        $fib8 += $fib9;\n     \
    \   $fib9 += $n;\n        $n--;\n    }\n    return $fib4;\n}", "    my $fibnum\
    \ = 0;\n    my $fibnum1 = 1;\n    my $fibnum2 = 2;\n    my $fibnum3 = 3;\n   \
    \ while ($n < 4) { $fibnum = $fibnum1 + $fibnum2 + $fibnum3 + $fibnum4; $n--;\
    \ $fibnum4 = $fibnum3; $fibnum3 = $fibnum2; $fibnum2 = $fibnum1; $fibnum1 = $fibnum;\
    \ }\n    return $fibnum;\n}", "    return $fib4[$n] if($n <= 4);\n    $fib4[$n]\
    \ = fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n    return $fib4[$n];\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,fibonacci,math,python |>\n<| c |>\n\
    You should use the `math` module instead of the built-in `pow` function to do\
    \ your computations. `pow` has far more overhead than the built-in math.\n<|/\
    \ c |>\n<| c |>\nThe fib4 numbers are the Fibonacci numbers, not Fibonacci numbers.\n\
    <|/ c |>\n<| c |>\nThanks. I should have known that.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe python code here is a bit more efficient than a recursive function\n\
    <code>\nimport math\ndef fib4(n):\n    if n == 0: return 0\n    if n == 1: return\
    \ 1\n    return fib4(n-1) + fib4(n-2)\n</code>\n<|/ a tags=algorithm,fibonacci,math,python\
    \ |>\n<| a |>\n<code>\ndef fib4(n):\n    fib=[1,1]\n    for i in range(2,n+1):\n\
    \        fib.append(fib[i-1]+fib[i-2])\n    return fib[n]\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,fibonacci,math,python |>\n<| c |>\nThis code is not efficient\
    \ for large n. \nTry print(fib4( 10**4 )). \nIt will run for hours.\n<|/ c |>\n\
    <| a dscore=0 |>\nRecursion is expensive and should be avoided whenever possible.\n\
    You can do better using memoization to reduce the number of recursive calls.\n\
    <code>\nfrom functools import lru_cache", "    my $x = $n<=0?0:1;\n    while($x<=$n)\
    \ {\n        $x +=1;\n    }\n    return $x;\n}", "    my $result = 1;\n    for\
    \ my $i (1 .. $n) {\n        $result *= $i;\n        $result += $i - 1;\n    }\n\
    \    $result;\n}", '    my(@result) = (0, @_);', "    $fib4 += $n; return $fib4;\n\
    }\n</code>\nThe function works as follows:\n<code>", "    my $fib4 = 0;\n    for\
    \ my $i (0 .. $n) {\n        $fib4 = $fib4 + $i;\n    }\n    return $fib4;\n}",
  "    my $fib4 = $n != 0 ? fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4) : 1;\n\
    \    return $fib4;\n}", "    if ($n <= 3) {\n        return 0;\n    } elsif ($n\
    \ > 3) {\n        return fib4($n - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n\
    \ - 4);\n    }\n}", "    my $i = 0;\n    my $fib = 0;\n    while ($i < $n) {\n\
    \t$fib += $fib + ($fib ? $fib : 1);\n\t$i++;\n    }\n    $fib;\n}\n</code>\n<|/\
    \ a tags=perl,fibonacci,numbers,sequence,arrays dscore=1 |>\n<| a tags=perl,fibonacci,numbers,sequence,arrays\
    \ |>\nHere is a different approach that uses memoization to save a big array containing\
    \ all previously calculated Fibonacci numbers. I used the term memoization to\
    \ mean saving the already calculated Fibonacci numbers as a hash. The hash has\
    \ keys that are the fibonacci numbers, and values are array references. I created\
    \ these keys for the first nine numbers, then for all other numbers I created\
    \ keys that refer to the keys of the previously computed Fibonacci numbers:\n\
    <code>\nuse strict;\nuse warnings;", "    $n = 0 unless defined $n;\n    my $fib4;\n\
    \    while($n) {\n        my $next = ($n % 4) + 1;\n        last if ($next > 0);\n\
    \        $n /= 4;\n        $fib4 = $fib4 + $next;\n    }\n    return $fib4;\n}",
  "    if ($n <= 0){\n        $fib = 0;\n    } elsif ($n == 1){\n        $fib = 0;\n\
    \    } elsif ($n == 2){\n        $fib = 2;\n    } elsif ($n == 3){\n        $fib\
    \ = 0;\n    } elsif ($n == 4){\n        $fib = 0;\n    }\n    \n    $fib = $fib\
    \ + $fib + $fib + $fib;\n    \n    return $fib;\n}\n<|/ file ext=.pl |>", "  \
    \  my $fib4_value = 0;\n    for($n=3;$n<=$_;$n++) {\n        $fib4_value += $fib4($n-1)\
    \ + $fib4($n-2) + $fib4($n-3) + $fib4($n-4);\n    }\n    return $fib4_value;\n\
    }", "    my @fib4 = (0,0);\n    while(1) {\n        my $tmp = @fib4;\n       \
    \ @fib4 = @fib4;\n        push(@fib4, $fib4[$n-1] + $fib4[$n-2] + $fib4[$n-3]\
    \ + $fib4[$n-4]);\n        return $fib4[-1];\n    }\n}\n</code>\n<|/ q |>\n<|\
    \ c |>\nThe first thing you should be doing is switching away from recursion if\
    \ you can help it.  It will make your code much easier to read and maintain, and\
    \ if you just need a fibonacci number, then it isn't a good candidate for a recursive\
    \ algorithm.\n<|/ c |>\n<| c |>\nI think you need to look at [this answer](https://stackoverflow.com/a/53587902/3020568)\
    \ and see whether it helps you.  It may be a little different but is about computing\
    \ the sum of all the even fib numbers, not just the one you want.\n<|/ c |>\n\
    <| c |>\nI agree with's comment. Recursion is a terrible choice for this problem.\
    \ Recursion is best for problems where you need to call itself repeatedly with\
    \ smaller inputs. The other approach is just looping with the `for` loop that\
    \ already has a `while` loop in it.\n<|/ c |>\n<| c |>\nI'm with on this one.\
    \  Really you should just write a loop with a `while` loop in it.  If you really\
    \ need to use recursion, try memoizing your results, but that's overkill for this.\n\
    <|/ c |>\n<| c |>\nIf you're going to do memoization why do you need to use recursion\
    \ at all?\n<|/ c |>\n<| a |>\nAs I said in my comment, you could use recursion\
    \ for this, but you probably don't need it for this problem.  As I said in my\
    \ comment, memoization might be the right answer, but it's overkill for this.\n\
    Your algorithm works fine, but your code is terribly inefficient in every way\
    \ I've seen.\n<code>", "    my $fib = 0;\n    my $fib2 = 0;\n    my $fib3 = 0;\n\
    \    my $fib4 = 0;", "    $n += 0;\n    return 0 if $n <= 0;\n    return 0 if\
    \ $n <= 1;\n    return 1 if $n <= 2;\n    return 2 if $n <= 3;\n    return 0 if\
    \ $n <= 4;\n    return fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n}",
  "    my $result;\n    my $fib4_number = $n;\n    my $fib4_number1 = $fib4_number\
    \ - 2;\n    my $fib4_number2 = $fib4_number1 - 2;\n    my $fib4_number3 = $fib4_number2\
    \ - 2;\n    my $fib4_number4 = $fib4_number3 - 2;\n    $result = $fib4_number4;\n\
    \    $fib4_number4 = $fib4_number3 + $fib4_number2 + $fib4_number1 + $fib4_number;\n\
    \    return $result;\n}", "    $fib4[$n] = 0 unless defined $fib4[$n];\n    return\
    \ $fib4[$n];\n}", "    my $fib4 = 0.0;\n    my $i;\n    for ($i = 1; $i <= $n;\
    \ $i++) {\n        $fib4 += ($i <= $n ? $i : $n-$i) * $i;\n    }\n    return $fib4;\n\
    }\n</code>\n<|/ a dscore=2 tags=perl,python,math,math |>\n<| a dscore=2 |>\nThis\
    \ is not a complete solution, but it is a hint to you to solve it yourself.\n\
    Perl has a function called for. You could use it to generate the Fibonacci sequence\
    \ by going through each number in the sequence once.\n<code>\nuse strict;\nuse\
    \ warnings;", "    $$n = $fib4($n-1) + $fib4($n-2) + $fib4($n-3) + $fib4($n-4);\n\
    }", "    my $x = 0;\n    for(my $i = 1; $i < $n; $i++) {\n        $x += $i;\n\
    \    }\n    return $x;\n}", "    my $fibo = shift;\n    if ($n <= 3) {\n     \
    \   return $fibo;\n    }\n    else {\n        $fibo = $fibo + $fibo + $fibo +\
    \ $fibo;\n    }\n}", "    if ($n <= 0) {\n        return 0\n    }\n    if ($n\
    \ <= 1) {\n        return 0;\n    }\n    return fib4($n-1) + fib4($n-2) + fib4($n-3)\
    \ + fib4($n-4);\n}", "    my $fib = 0;\n    $fib += $fib while $n >= 0;\n    $fib;\n\
    }", "    my $num = 0;\n    while($n > 0) {\n\t$num += $n * $n;\n\t$n--;\n    }\n\
    \    return $num;\n}", "    my $fib4 = 0;\n    my $last = $n;\n    while($last\
    \ > 1) {\n\t$fib4 = $fib4 + $fib4 * ($last - 2);\n\t$last = $last - 3;\n    }\n\
    \    return $fib4;\n}\n1;\n</code>\n<|/ a dscore=4 tags=fibonacci,algorithm,math,mathematical-optimization\
    \ |>\n<| c |>\nIt would be nice to see an explanation of the algorithm here, as\
    \ well.\n<|/ c |>\n<| c |>\nOh, I see. That makes sense now! Thanks for the detailed\
    \ explanation. I appreciate it.\n<|/ c |>\n<| c |>\n+1 For this approach to calculating\
    \ Fibonacci, especially since it makes it quite straightforward to prove correctness.\
    \ I suspect this approach may be more efficient than the recursive approaches\
    \ presented here because of the constant factors associated with recursive calls\
    \ such as multiplication by 2, etc.\n<|/ c |>\n<| a |>\nI think you can also do\
    \ this with Dynamic Programming without using recursion.\nI wrote a java code\
    \ for it here that you can find at http://www.codegists.com/code/dynamic-programming-fibonacci-numbers.\
    \ You can read the article from Dynamic Programming which shows how to solve Fibonacci\
    \ problem using Dynamic Programming concepts.\n<|/ a dscore=4 tags=fibonacci,algorithm,math,mathematical-optimization\
    \ |>\n<| a tags=fibonacci,algorithm,math,mathematical-optimization |>\nThis is\
    \ a recursive solution:\n<code>\nint fib(int n){\n    if(n<=1){\n        return\
    \ 1;\n    }\n    else if(n==2){\n        return 1;\n    }\n    else if(n==3){\n\
    \        return 2;\n    }\n    else{\n        return fib(n-1) + fib(n-2);\n  \
    \  }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks, this was very helpful! However,\
    \ I did have to change it from fib(3) to fib(4) in order to make it work correctly.\n\
    <|/ c |>\n<| a |>\nAnother recursive solution without using any loops:\n<code>\n\
    int fib(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    else if (n\
    \ == 2) {\n        return 1;\n    }\n    else if (n == 3) {\n        return 2;\n\
    \    }\n    else {\n        return fib(n - 2) + fib(n - 1);\n    }\n}\n</code>\n\
    <|/ a dscore=3 tags=fibonacci,algorithm,math,mathemati", "    my $i = 1;\n   \
    \ my $fib = 0;\n    while(1) {\n        $fib = $fib + ($i-1);\n        if ($fib\
    \ <= $n) {\n            $i++;\n            last;\n        }\n        $i++;\n \
    \   }\n    return $fib;\n}", "    my $fib;\n    for($fib=0,$fib<$n,$fib+=4) {\n\
    \t$fib=4 if $fib % 4 == 3;\n\t$fib+=1;\n\t$fib+=$fib;\n    }\n    return $fib;\n\
    }", "    if ($n <= 0) {\n        return 0;\n    }\n    return fib4($n-1) + fib4($n-2)\
    \ + fib4($n-3) + fib4($n-4);\n}", "    # base case\n    if ($n < 4) {\n      \
    \  return $n;\n    }\n    # recursive case\n    else {\n        return fib4($n\
    \ - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n - 4);\n    }\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks Michael - I'll give this a try later today.\n<|/ c |>\n\
    <| c |>\nSurely there's a better way to do this using recursion?\n<|/ c |>\n<|\
    \ c |>\nThe only reason I used recursion is because my teacher didn't like using\
    \ loops. As I've stated before, I'm very new to programming, and recursion is\
    \ pretty new to me. I'm looking for a good explanation on how this works.\n<|/\
    \ c |>\n<| c |>\nYour teacher may have some problems with recursion, but recursion\
    \ doesn't necessarily mean loops. The `while` loop in this case is basically the\
    \ equivalent of `for $n (1..4)` in that it is looping over 1, 2, 3, and 4 in sequence.\
    \ Recursion would replace the `while` loop and essentially just add one more parameter.\n\
    <|/ c |>\n<| c |>\n: No, `while` and `for` loops differ by whether they terminate\
    \ based on a condition, or whether they loop over an entire range in sequence.\n\
    <|/ c |>\n<| a |>\nThe other answer already covers the algorithm pretty well,\
    \ but I'd like to add some Python code that might help you.\nIn Python, we have\
    \ the range function which lets you iterate over an arithmetic sequence like 1,2,3,4,5.\
    \  So instead of writing a bunch of nested loops, we can just do something like\
    \ range(4) and get an iterable that gives us 0,1,2,3 back.\nWe then take advantage\
    \ of Python's built-in sum function, which lets you add together a bunch of numbers\
    \ to get the total you want.  For example, if we have [1, 2, 3, 4], we can write\
    \ 4 + 2 + 1 + 0 = 8.  So we can write a function that does this:\n<code>\ndef\
    \ fib4(n):\n    total = 0\n    for i in range(n):\n        total += fib4(n-i-1)\n\
    \    return total\n</code>\nAs you can see, there's only really one loop here,\
    \ since it just keeps calling itself recursively until you get a value for n that\
    \ doesn't go below 4.  And the recursive part is quite simple.\nAnd we can use\
    \ this function to see that the answer to fib4(4) is 8:\n<code>\n>>> fib4(4)\n\
    8\n</code>\n<|/ a dscore=1 tags=recursion,python,algorithm,math |>\n<| c |>\n\
    Thanks for the reply Micha", "    $n == 0 ? 0 : ($n == 1 ? 1 : fib4($n - 1) +\
    \ fib4($n - 2) + fib4($n - 3) + fib4($n - 4));\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\n`fib5(0)` and `fib5(1)` should both return 0\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing that out.  I fixed it with a new version of my fib5 function that\
    \ uses recursion.\n<|/ c |>\n<| c |>\nI didn't downvote, but I guess it was because\
    \ of the typo at the end of your answer.\n<|/ c |>\n<| c |>\n`fib5(0)` and `fib5(1)`\
    \ should both return `1`. I fixed it.\n<|/ c |>\n<| a tags=algorithm,fibonacci,c++\
    \ |>\n<code>\nint fib(int n)\n{\n    if (n<=1)\n        return 1;\n    if (n<2)\n\
    \        return 1;\n    else \n        return fib(n - 1) + fib(n - 2);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=algorithm,fibonacci,c++ dscore=1 |>\nThis is a recursive\
    \ solution to compute fibonacci number\n<code>", "    if($n < 4) {\n        $n;\n\
    \    } else {\n        my($n1, $n2, $n3, $n4) = fib4($n-3) + fib4($n-2)+ fib4($n-1)\
    \ + fib4($n);\n        $n4;\n    }\n}", "    if ($n < 4) {\n        $fib4{$n};\n\
    \    } else {\n        my $fib4;\n        foreach $fib4 (map { $self->fib4($_+2)\
    \ } 1 .. $n-1) {\n            $fib4 += $fib4;\n        }\n        $fib4;\n   \
    \ }\n}", "    if ($n) {\n        my($fib4) = 0;\n        for ($n-1; $n; $n--)\
    \ {\n            my($temp) = &fib4($n-1) + &fib4($n-2) + &fib4($n-3) + &fib4($n-4);\n\
    \            $fib4 += $temp;\n        }\n        return $fib4;\n    } else {\n\
    \        return 0;\n    }\n}", "    return $fib4 if $n <= 2;\n    my $fib4 = $fib4\
    \ + ($fib4 + ($fib4 + ($fib4 + ($fib4 + ($fib4 - ($fib4 + ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4\
    \ - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4\
    \ - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4\
    \ - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4\
    \ - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4\
    \ - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4\
    \ + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib4 - ($fib4 + ($fib", "    # Base\
    \ case\n    if ($n <= 0) {\n        return 0;\n    }\n    # Recursive case\n \
    \   return fib4($n - 4) + fib4($n - 3) + fib4($n - 2) + fib4($n - 1);\n}", " \
    \   if ( $n < 0 ) {\n        print STDERR \"fib4(@_): $n must be positive\\n\"\
    ;\n        return;\n    }\n    if ( $n == 0 ) {\n        return 0;\n    }\n  \
    \  if ( $n == 1 ) {\n        return 0;\n    }\n    if ( $n == 2 ) {\n        return\
    \ 2;\n    }\n    if ( $n == 3 ) {\n        return 0;\n    }\n    if ( $n == 4\
    \ ) {\n        return 2;\n    }\n    my $fib4 = fib4( $n-1 ) + fib4( $n-2 ) +\
    \ fib4( $n-3 ) + fib4( $n-4 );\n    return $fib4;\n}", "    if ($n <= 0) {\n \
    \      return 0;\n    }\n    if ($n <= 2) {\n       return $n;\n    }\n    my\
    \ $fib = 0;\n    my $i = 1;\n    while ($i < $n) {\n       $fib += ($i-1) * $i;\n\
    \       $i++;\n    }\n    return $fib;\n}", "    if ($n eq 0 ) {\n        return\
    \ 0;\n    }\n    if ($n eq 1 ) {\n        return 0;\n    }\n    if ($n eq 2 )\
    \ {\n        return 2;\n    }\n    if ($n eq 3 ) {\n        return 0;\n    }\n\
    \    if ($n eq 4 ) {\n        return 4;\n    }\n    if ($n eq 5 ) {\n        return\
    \ 4;\n    }\n    if ($n eq 6 ) {\n        return 8;\n    }\n    if ($n eq 7 )\
    \ {\n        return 8;\n    }\n    if ($n eq 8 ) {\n        return 12;\n    }\n\
    \    if ($n eq 9 ) {\n        return 12;\n    }\n    if ($n eq 10 ) {\n      \
    \  return 20;\n    }\n    if ($n eq 11 ) {\n        return 20;\n    }\n    if\
    \ ($n eq 12 ) {\n        return 30;\n    }\n    if ($n eq 13 ) {\n        return\
    \ 30;\n    }\n    if ($n eq 14 ) {\n        return 40;\n    }\n    if ($n eq 15\
    \ ) {\n        return 40;\n    }\n    if ($n eq 16 ) {\n        return 50;\n \
    \   }\n    if ($n eq 17 ) {\n        return 50;\n    }\n    if ($n eq 18 ) {\n\
    \        return 60;\n    }\n    if ($n eq 19 ) {\n        return 60;\n    }\n\
    \    if ($n eq 20 ) {\n        return 80;\n    }\n    if ($n eq 21 ) {\n     \
    \   return 80;\n    }\n    if ($n eq 22 ) {\n        return 100;\n    }\n    if\
    \ ($n eq 23 ) {\n        return 100;\n    }\n    if ($n eq 24 ) {\n        return\
    \ 110;\n    }\n    if ($n eq 25 ) {\n        return 110;\n    }\n    if ($n eq\
    \ 26 ) {\n        return 120;\n    }\n    if ($n eq 27 ) {\n        return 120;\n\
    \    }\n    if ($n eq 28 ) {\n        return 140;\n    }\n    if ($n eq 29 ) {\n\
    \        return 140;\n    }\n    if ($n eq 30 ) {\n        return 160;\n    }\n\
    \    if ($n eq 31 ) {\n        return 160;\n    }\n    if ($n eq 32 ) {\n    \
    \    return 180;\n    }\n    if ($n eq 33 ) {\n        return 180;\n    }\n  \
    \  if ($n eq 34 ) {\n        return 200;\n    }\n    if ($n eq 35 ) {\n      \
    \  return 200;\n    }\n    if ($n eq 36 ) {\n        return 220;\n    }\n    if\
    \ ($n eq 37 ) {\n        return ", "    my(@seq) = (0,1,2,3,4,5,6,7);\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        my $seq = shift(@seq);\n        my $fib\
    \ = ($seq * $seq + $seq);\n        push(@seq, $fib);\n    }\n    my $fib4 = pop(@seq);\n\
    \    return $fib4;\n}", "    my($fib4) = 0;\n    if ($n == 0) {\n        $fib4\
    \ = 0;\n    } elsif ($n == 1) {\n        $fib4 = 0;\n    } elsif ($n == 2) {\n\
    \        $fib4 = 0;\n    } elsif ($n == 3) {\n        $fib4 = 0;\n    } else {\n\
    \        my($newFib4) = $fib4 + $fib4 + $fib4 + $fib4;\n        $fib4 = $newFib4;\n\
    \    }\n    return $fib4;\n}", "    $fib4 += $fib4 % 4 + $n if $n;\n    return\
    \ $fib4;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis was my first thought too,\
    \ but `fib4(5) == fib4(4) + fib4(3) + fib4(2)` so this doesn't work.\n<|/ c |>\n\
    <| c |>\nMy bad, I misread the question. You'll get this kind of behavior with\
    \ the code I provided. You'll need to figure out a different way to get an answer.\n\
    <|/ c |>\n<| a tags=algorithm,math |>\nWell, I think this could be a solution,\
    \ albeit not very efficient:\n<code>\nvar fib = (function () {\n    \"use strict\"\
    ;\n    function fib4(n) {\n        if (n <= 0) return 0;\n        if (n <= 2)\
    \ return 1;\n        return fib4(n - 1) + fib4(n - 2);\n    }\n    return fib4;\n\
    }());", "    if($n<4) {\n        return $n;\n    } elsif($n<7) {\n        return\
    \ $n+fib4($n-1);\n    } elsif($n<10) {\n        return $n+fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4);\
    \ \n    } else {\n        return $n+fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4)+fib4($n-5);\n\
    \    }\n}\n</code>\n<|/ q tags=recursion,perl |>\n<| c |>\nYou might want to read\
    \ [my book](https://perl.plover.com/book/) on recursion to understand why your\
    \ recursion doesn't work.\n<|/ c |>\n<| c |>\nThanks for your help but I don't\
    \ think I've used that book yet.  I'll look through it now.\n<|/ c |>\n<| c |>\n\
    Looking at my book, you'll find an explanation of why your solution doesn't work.\
    \ Have a look at my answer for more details.\n<|/ c |>\n<| c |>\nIf you want an\
    \ explanation as to why your code does not work, then you either need to read\
    \ the book, or you need to work through it. There is no single \"right way\" to\
    \ do it, and you will need to learn something in order to learn it.\n<|/ c |>\n\
    <| a tags=recursion,perl dscore=2 |>\nYou need to understand recursion in order\
    \ to understand why your solution does not work.  A few hints:", "    my $fib1\
    \ = $fib3(1,0,1);\n    return $fib1*$fib1 + $fib3*$fib3*$fib1 + $fib4*$fib4*$fib1;\n\
    }", "    my(@result) = ();\n    my($a, $b);\n    \n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        $result[$i] = $a\n    }\n    \n    for (my $i = $n-1; $i >=\
    \ 0; $i--) {\n        $a = $result[$i];\n        \n        for (my $j = 0; $j\
    \ < $n; $j++) {\n            $b = $result[$j];\n            $result[$i] = $a+$b\n\
    \        }\n    }\n    return $result[0]\n}", "    my($fib4) = 0;\n    for($n;\
    \ $n -gt 0; $n--) {\n        $fib4 += $fib4 + $fib4;\n    }\n    return $fib4;\n\
    }", "    if($n == 0) {\n        return 0;\n    } elsif(@fib4 < $n) {\n       \
    \ push(@fib4, fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4));\n    } elsif(@fib4\
    \ < $n) {\n        push(@fib4, fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4));\n\
    \    } else {\n        pop(@fib4);\n    }\n}", "    return 0 if $n == 0;\n   \
    \ return 0 if $n == 1;\n    return 2 if $n == 2;\n    return 0 if $n == 3;\n \
    \   return $n if $n <= 5;\n    my $fib_prev = $fib4(5) + $fib4(4) + $fib4(3) +\
    \ $fib4(2) + $fib4(1);\n    return $fib4($n-1) + $fib_prev;\n}", "    return 1\
    \ if $n == 0 || $n == 1;\n    return 0 if $n == 2;\n    my $a = fib4($n-2);\n\
    \    my $b = fib4($n-3);\n    my $c = fib4($n-4);\n    my $d = fib4($n-5);\n \
    \   return $a + $b + $c + $d;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    use warnings;\nuse strict;", "    my $fib = 4;\n    my $fib1 = 0;\n    my $fib2\
    \ = 0;\n    my $fib3 = 0;\n    my $fib4 = 0;\n    for(my $i = $n; $i > 0 ; $i--)\
    \ {\n        $fib1 = $fib + $fib1 + $fib2 + $fib3 + $fib4;\n        $fib2 = $fib1\
    \ + $fib3;\n        $fib3 = $fib1 + $fib2;\n        $fib4 = $fib1 + $fib3;\n \
    \   }\n    return $fib4;\n}", "    my $fib = 0;\n    my $i = 1;\n    while ($i\
    \ <= $n) {\n        $fib +=  $fib * $i;\n        $i++;\n    }\n    return $fib;\n\
    }", "    my $fib = 0;\n    for(my $i = 0; $i <= $n; $i++) {\n        $fib = $fib\
    \ + $i\n    }\n    return $fib;\n}", "    my $result = -1;\n    if ($n == 0) {\n\
    \        $result = 0;\n    }\n    if ($n == 1) {\n        $result = 1;\n    }\n\
    \    if ($n == 2) {\n        $result = 2;\n    }\n    if ($n >= 3) {\n       \
    \ $result = 3 + fib4($n - 2);\n    }\n    if ($n >= 4) {\n        $result = fib4($n\
    \ - 3) + fib4($n - 4) + fib4($n - 5);\n    }\n    return $result;\n}", "    if\
    \ ($n < 3) {\n        return $n;\n    }\n    return fib4($n-1) + fib4($n-2) +\
    \ fib4($n-3) + fib4($n-4);\n}\n</code>\n<|/ q dscore=1 |>\n<| c |>\nPlease provide\
    \ your code so we can see what you are doing wrong.  We can't guess what you are\
    \ doing wrong when we can't see what you are doing.\n<|/ c |>\n<| c |>\n\"Do not\
    \ use recursion.\"  Don't use recursion.  And don't use recursion in any language,\
    \ let alone Perl.\n<|/ c |>\n<| c |>\nI updated my question to include my attempt\
    \ at writing a recursive function.\n<|/ c |>\n<| a tags=recursion,perl |>\nYou\
    \ are on the right track, but your base case is off:\n<code>", "    my ($i, $fib_value,\
    \ $sum) = (0, -1, 1);\n    while ($n != 0) {\n        $fib_value = $sum + $i;\n\
    \        $sum = $fib_value;\n        $i = $fib_value - $fib_value % 4 + 1;\n \
    \       $n--;\n    }\n    $sum;\n}", "    return 1 if $n == 0;\n    return 1 if\
    \ $n == 1;\n    return 2 if $n == 2;\n    return fib4($n-1) + fib4($n-2) + fib4($n-3)\
    \ + fib4($n-4);\n}", "    return 0 if($n <= 0);\n    \n    my ($a, $b, $c, $d,\
    \ $e) = (0, 1, 2, 3, 4);\n    \n    for($n; $n>0; $n--) { \n        $a = $e; \n\
    \        $e = $b + $c; \n        $b = $c; \n        $c = $d; \n        $d = $a\
    \ + $e; \n    }\n    \n    return $d;\n}", "    return 0 unless defined $n;\n\
    \    if ($n eq '0') {\n        return '0';\n    } elsif ($n eq '1') {\n      \
    \  return '0';\n    } elsif ($n eq '2') {\n        return '2';\n    } elsif ($n\
    \ eq '3') {\n        return '0';\n    } elsif ($n >= '4') {\n        $n--;\n \
    \       my $t = fib4($n-1);\n        my $tt = fib4($n-2);\n        my $tt = fib4($n-3);\n\
    \        my $tt = fib4($n-4);\n        return $t.$tt.$tt.$t;\n    }\n}", "   \
    \ return $n if $n == 0;\n    return $fib4($n - 1) +\n        $fib4($n - 2) +\n\
    \        $fib4($n - 3) +\n        $fib4($n - 4);\n}", "    my $n1 = $n;\n    $n--;\n\
    \    my $n2 = $n;\n    $n--;\n    my $n3 = $n;\n    $n--;\n    my $n4 = $n;\n\
    \    my $fib4 = $n1 + $n2 + $n3 + $n4;\n    return $fib4;\n}", "    my $fib;\n\
    \    if($n == 0) {\n        return 0;\n    }\n    if($n == 1) {\n        return\
    \ 1;\n    }\n    if($n == 2) {\n        return 2;\n    }\n    if($n == 3) {\n\
    \        return 0;\n    }\n    if($n == 4) {\n        return 4;\n    }\n    if($n\
    \ == 5) {\n        return 8;\n    }\n    if($n == 6) {\n        return 14;\n \
    \   }\n    if($n == 7) {\n        return 28;\n    }\n    if($n == 8) {\n     \
    \   return 56;\n    }\n    if($n == 9) {\n        return 124;\n    }\n    if($n\
    \ == 10) {\n        return 252;\n    }\n    if($n == 11) {\n        return 512;\n\
    \    }\n    if($n == 12) {\n        return 1024;\n    }\n    if($n == 13) {\n\
    \        return 2048;\n    }\n    if($n == 14) {\n        return 4096;\n    }\n\
    \    if($n == 15) {\n        return 8192;\n    }\n    if($n == 16) {\n       \
    \ return 16384;\n    }\n    if($n == 17) {\n        return 32768;\n    }\n   \
    \ if($n == 18) {\n        return 65536;\n    }\n    if($n == 19) {\n        return\
    \ 131072;\n    }\n    if($n == 20) {\n        return 262144;\n    }\n    if($n\
    \ == 21) {\n        return 524288;\n    }\n    if($n == 22) {\n        return\
    \ 1048576;\n    }\n    if($n == 23) {\n        return 2097152;\n    }\n    if($n\
    \ == 24) {\n        return 4194304;\n    }\n    if($n == 25) {\n        return\
    \ 8388608;\n    }\n    if($n == 26) {\n        return 16777216;\n    }\n    if($n\
    \ == 27) {\n        return 33554432;\n    }\n    if($n == 28) {\n        return\
    \ 67108864;\n    }\n    if($n == 29) {\n        return 134217728;\n    }\n   \
    \ if($n == 30) {\n        return 268435456;\n    }\n    if($n == 31) {\n     \
    \   return 536870912;\n    }\n    if($n == 32) {\n        return 1073741824;\n\
    \    }\n    if($n == 33) {\n        return 2147483648;\n    }\n    if($n == 34)\
    \ {\n        return 4294967296;\n    }\n    if($n == 35) {\n        return 8589934592;\n\
    \    }\n    if($n == 36) {\n        return 17179869184;\n    }\n    if($n == 37)\
    \ {\n        return 34359738368;\n    }\n    if($n == 38) {\n        return 68719476736",
  "    return $n if $n == 0;\n    my $fib4 = 0 + 4 + 8 + 14 + 24 + 36 + 49 + 64 +\
    \ 81 + 100 + 125;\n    my $fib6 = $fib4 + $fib4 - $fib4 + $fib4 - $fib4;\n   \
    \ return $fib4 * $fib4 if $n <= 5;\n    return $fib6 * $fib4 if $n <= 7;\n   \
    \ $fib6\n}", "    if ($n <= 1) {\n        return 0;\n    } else {\n        return\
    \ fib4($n - 1) + fib4($n - 2) + fib4($n - 3) + fib4($n - 4);\n    }\n}", "   \
    \ if ($n <= 0) {\n\t    return 0;\n    }\n    if ($n == 1) {\n\treturn 0;\n  \
    \  }\n    if ($n == 2) {\n\treturn 2;\n    }\n    if ($n == 3) {\n\treturn 0;\n\
    \    }\n    if ($n == 4) {\n\treturn 4;\n    }\n    # fib4(5) -> fib4(4) + fib4(3)\
    \ -> fib4(3) + fib4(2) -> fib2(3) + fib4(2) -> fib4(2) + fib2(2) -> fib4(2) +\
    \ fib2(2) + fib4(1) + fib2(1) -> fib4(1) + fib2(1) + fib4(0) \n    $a0 = fib4($n-1);\n\
    \    $a1 = fib4($n-2);\n    $a2 = fib4($n-3);\n    $a3 = fib4($n-4);\n    return\
    \ $a0+$a1+$a2+$a3;\n}\n</code>\n<|/ a dscore=3 tags=fibonacci,algorithm,python\
    \ |>\n<| c |>\nThis solution can be improved a little, but it's still exponential.\
    \ `fib4(n)` can be expressed as `fib4(fib4(n-1) + fib4(n-2))` (for n>0).\n<|/\
    \ c |>\n<| c |>\nIf all you want is fibonacci, then this answer is great! If you\
    \ want a more mathematical solution that is even faster and simpler (though not\
    \ as easy to read/understand), then check out the accepted answer, which has also\
    \ the math solution to the fibonacci sequence.\n<|/ c |>\n<| c |>\nYes that is\
    \ much better - I still find it confusing to see the recursion in two places though.\n\
    <|/ c |>\n<| c |>\n, agreed, but I thought it looked nice.\n<|/ c |>\n<| c |>\n\
    , your solution is exponential because you call `fib4` four times. In `fib4`,\
    \ you need to calculate the value of `fib4` four times. That's what `fib4` does\
    \ - it calculates `fib4` four times. What you did is called memoization, and is\
    \ very useful when you call a function that you know it will return the same result\
    \ repeatedly, or when you have a function that computes something to be used many\
    \ times. Python has built-in support for memoization.\n<|/ c |>\n<| a dscore=3\
    \ |>\nThe Fibonacci sequence is defined as \n<code>\nF(0) = 0\nF(1) = 1\nF(2)\
    \ = 1\nF(n) = F(n - 1) + F(n - 2)\n</code>\nI find this recursive definition of\
    \ the Fi", "    if ($n == 0) {\n        return 0;\n    }\n    if ($n == 1) {\n\
    \        return 1;\n    }\n    if ($n == 2) {\n        return 2;\n    }\n    if\
    \ ($n == 3) {\n        return 0;\n    }\n    if ($n == 4) {\n        return 1;\n\
    \    }\n    if ($n == 5) {\n        return 4;\n    }\n    if ($n == 6) {\n   \
    \     return 8;\n    }\n    if ($n == 7) {\n        return 14;\n    }\n    my\
    \ $sum = 0;\n    for ($n; $n > 0; $n--) {\n        $sum += fib4($n - 1);\n   \
    \ }\n    return $sum;\n}", "    my $fib4 = 0;\n    $fib4 += $fib4 * ($n-1);\n\
    \    $fib4 += $fib4 * ($n-2);\n    $fib4 += $fib4 * ($n-3);\n    $fib4 += $fib4\
    \ * ($n-4);\n    return $fib4;\n}\n</code>\nHere's the recursive solution (which\
    \ is what I was hoping for):\n<code>", "    if($n == 0) {\n        0;\n    } elsif($n\
    \ == 1) {\n        0;\n    } elsif($n == 2) {\n        2;\n    } elsif($n == 3)\
    \ {\n        0;\n    } elsif($n == 6) {\n        8;\n    } elsif($n == 7) {\n\
    \        14;\n    } else {\n        fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    \    }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe fib4 formula is correct, but\
    \ the recursive formula is not. `fib4(5)` should be 4, not 8. Also, your memo\
    \ array should never have a value in it. It's only for the base case when $n =\
    \ 0. Also the memo array should be initialised with undef rather than \"\".\n\
    <|/ c |>\n<| c |>\n, thanks for catching the typo on the recursion. I had the\
    \ memo array initialised with \"\" just to make sure it was not a typo. I've fixed\
    \ it now. Regarding the fib4 formula: the question states fib4 should be 4, not\
    \ 8. Perhaps I misinterpreted the question, but I thought the fib4 formula was\
    \ correct for the general problem. Perhaps I am wrong, though. Perhaps the question\
    \ should have been phrased in terms of fib4 rather than fib2 for the general problem.\
    \ I will check this and see if I can change my answer.\n<|/ c |>\n<| c |>\nThe\
    \ question states fib4 should be 4, not 8. The fib4 formula is wrong. It's not\
    \ a correct fib formula. The fib4 formula should be `fib4($n-1)+fib4($n-2)+fib4($n-3)+fib4($n-4)`,\
    \ not `fib4($n-2) + fib4($n-3) + fib4($n-4)`.\n<|/ c |>\n<| c |>\n, thanks for\
    \ the catch. I had misinterpreted the question. I've fixed my answer now.\n<|/\
    \ c |>\n<| a |>\nI like to use an accumulator to solve this kind of problem, as\
    \ I find it a more readable (and easier to maintain down the road).  \n<code>",
  "    $n == 0 or return $n;\n    return fib4($n - 1) + fib4($n - 2) + fib4($n - 3)\
    \ + fib4($n - 4);\n}\n</code>\nRecursion\nRecursion is a method of iterative computing,\
    \ where a function calls itself repeatedly until it reaches a base case, which\
    \ then returns to the function from which it was called.  This is most easily\
    \ understood by looking at an example.  Let's say we want a function that prints\
    \ a given string.  It should look like this:\n<code>", "    my $fib = 0;\n   \
    \ my $fib1 = 1;\n    my $fib2 = 1;\n    my $fib3 = 1;", "    my $fib4_prev = [\
    \ $fib4($n - 2), $fib4($n - 1), $fib4($n), $fib4($n - 3) ];\n    my $fib4_next\
    \ = [ 2 * $fib4($n - 1) + $fib4($n), 2 * $fib4($n) - $fib4($n - 1), 2 * $fib4($n)\
    \ - $fib4($n - 2), 2 * $fib4($n - 3) - $fib4($n - 2) ];", "    my $fib = 0;\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n        $fib += $i;\n    }\n    return\
    \ $fib;\n}", "    my $fib4seq = [];\n    my $fib4term;\n    my $fib4term2;\n \
    \   my $fib4term3;\n    my $fib4term4;\n    my $fib4term5;\n    my $fib4term6;\n\
    \    my $fib4term7;\n    my $fib4term8;\n    my $fib4term9;\n    my $fib4term10;\n\
    \    my $fib4term11;\n    my $fib4term12;\n    my $fib4term13;\n    my $fib4term14;\n\
    \    my $fib4term15;\n    my $fib4term16;\n    my $fib4term17;\n    my $fib4term18;\n\
    \    my $fib4term19;\n    my $fib4term20;\n    my $fib4term21;\n    my $fib4term22;\n\
    \    my $fib4term23;\n    my $fib4term24;\n    my $fib4term25;\n    my $fib4term26;\n\
    \    my $fib4term27;\n    my $fib4term28;\n    my $fib4term29;\n    my $fib4term30;\n\
    \    my $fib4term31;\n    my $fib4term32;\n    my $fib4term33;\n    my $fib4term34;\n\
    \    my $fib4term35;\n    my $fib4term36;\n    my $fib4term37;\n    my $fib4term38;\n\
    \    my $fib4term39;\n    my $fib4term40;\n    my $fib4term41;\n    my $fib4term42;\n\
    \    my $fib4term43;\n    my $fib4term44;\n    my $fib4term45;\n    my $fib4term46;\n\
    \    my $fib4term47;\n    my $fib4term48;\n    my $fib4term49;\n    my $fib4term50;\n\
    \    my $fib4term51;\n    my $fib4term52;\n    my $fib4term53;\n    my $fib4term54;\n\
    \    my $fib4term55;\n    my $fib4term56;\n    my $fib4term57;\n    my $fib4term58;\n\
    \    my $fib4term59;\n    my $fib4term60;\n    my $fib4term61;\n    my $fib4term62;\n\
    \    my $fib4term63;\n    my $fib4term64;\n    my $fib4term65;\n    my $fib4term",
  "    my $fib4 = $fib4cache{$n};\n    return $fib4 if defined $fib4;\n    $fib4 =\
    \ fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n    $fib4cache{$n} = $fib4;\n\
    \    return $fib4;\n}", "    my $fib = 0;\n    for(my $i = 1;$i <= $n;$i++) {\n\
    \        $fib = $fib + ( $i * ( $n - $i ) );\n    }\n    return $fib;\n}\n</cell>\n\
    <cell>", "    return 1 if $n == 0;\n    return $fib4($n - 1) + $fib4($n - 2) +\
    \ $fib4($n - 3) + $fib4($n - 4);\n}", "    my $fib = $_[$n];\n    for(0..$n-1){\n\
    \        $fib += $_[$n-1-$_[$n-1]];\n    }\n    return $fib;\n}", "    if ($n\
    \ <= 3) {\n        return $n;\n    }\n    return fib4($n-2) + fib4($n-3) + fib4($n-4)\
    \ + fib4($n-6);\n}", "    $n = 0 if $n < 0;\n    return $fib4[$n] if ($fib4[$n]\
    \ == 0 && $n <= 3);\n    $fib4[$n] = fib4($n-1) + fib4($n-2) + fib4($n-3) + fib4($n-4);\n\
    }", "    my $fib4_cache = (caller)[0];\n    if (!exists($fib4_cache->{fib4data}{$n}))\
    \ {\n        $fib4_cache->{fib4data}{$n} = 0;\n        $fib4_cache->{fib4data}{$n}\
    \ = $fib4_cache->{fib4data}{$n} + fib4($n - 1) + fib4($n - 2) + fib4($n - 3) +\
    \ fib4($n - 4);\n    }\n    return $fib4_cache->{fib4data}{$n};\n}\n</code>\n\
    <|/ a dscore=1 tags=fibonacci,recursion,memoization,algorithm,perl |>\n<| a dscore=1\
    \ |>\nThis problem can be solved simply by memoizing the result of the recursive\
    \ calls of fib4 function instead of storing them in an array and storing each\
    \ result in an hash table:\n<code>", "    return 0 unless $n =~ /^\\d+$/;\n  \
    \  my $a = $fib;\n    my $b = $fib + ($fib * $fib);\n    my $c = $fib + ($fib\
    \ * $fib + ($fib * $fib));\n    my $d = $fib + ($fib * $fib + ($fib * $fib + ($fib\
    \ * $fib)));\n    my $fib4n = ($a * $d) + ($b * $c) + ($c * $d) + ($d * $a) +\
    \ $d;\n    return $fib4n;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
