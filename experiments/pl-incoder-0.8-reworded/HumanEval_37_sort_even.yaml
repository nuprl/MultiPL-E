name: HumanEval_37_sort_even
language: pl
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n# to the values of the even indicies of l, but sorted.\n# >>> sort_even([1,\
  \ 2, 3])\n# [1, 2, 3]\n# >>> sort_even([5, 6, 3, 4])\n# [3, 6, 5, 4]\nsub sort_even\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_even;\n\
  \        if(eq_deeply($candidate->([1, 2, 3]),[1, 2, 3])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5,\
  \ 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @l;\n    \n    for my $i (0 .. $#l) {\n        push @l, $l->[$i]\
    \ if $i % 2 == 0;\n    }\n    return @l;\n}", "    my(@lprime);\n    my($tmp,\
    \ $even, $odd);\n    my($i, $j);\n    \n    # Sort $l in $odd and $even indicies.\n\
    \    for ($i = 0; $i <= @$l / 2; $i++) {\n        $odd = $i;\n        $even =\
    \ @$l - $i;\n        if ($even < $odd) {\n            my $temp = $l[$odd];\n \
    \           $l[$odd] = $l[$even];\n            $l[$even] = $temp;\n        }\n\
    \    }", "    my($l' @$l);\n    my $i = $#l / 2;\n    for ($i; $i > 0; $i--) {\n\
    \        $l' [$i-1] = $l' [$i];\n    }\n    for (my $i = 0; $i < $#l; $i++) {\n\
    \        $l' [$i] = $l' [$i] unless $l' [$i] % 2;\n    }\n    return $l';\n}",
  "    my($l') = $l->clone;", "    my $even = @$l % 2;\n    my @a = @$l;\n    if ($even)\
    \ {\n        @$l = sort {$a <=> $b} @$l;\n    }\n    else {\n        @$l = sort\
    \ {$b <=> $a} @$l;\n    }\n    return @$l;\n}", "    my @evens = ();\n    my @odds\
    \ = ();\n    for my $i (0 .. $#l) {\n        push @evens, $i unless $i & 1;\n\
    \        push @odds, $i;\n    }\n    sort {\n        my ($aa, $bb) = @_;\n   \
    \     my $c = $bb;\n        for my $i (0 .. $#$evens) {\n            last unless\
    \ $i & 1;\n            $c->[$i] = $evens[$i];\n        }\n        sort { $aa <=>\
    \ $bb };\n    };\n    @$l = @evens;\n    for my $i (0 .. $#$odds) {\n        next\
    \ unless $i & 1;\n        @$l[$i] = $odds[$i];\n    }\n    return @$l;\n}", " \
    \   $l = [@_] if @_ == 1 and not ref($l);\n    my @even = @$l;\n    @$l = ();\n\
    \    @$l += @$even;\n    my @odd = grep(!($_%2), @_);\n    my $i = 0;\n    my\
    \ @new = @$l;\n    for (my $j = 0; $j < @new; $j++) {\n        my $i = $j;\n \
    \       for (my $k = 0; $k < @new; $k++) {\n            if ($k > $j) {\n     \
    \           last if ($k > $i);\n                if ($new[$k] < $new[$j]) {\n \
    \                   $new[$k] = $new[$j];\n                }\n                else\
    \ {\n                    $new[$k] = $new[$i];\n                }\n           \
    \ }\n            $i++;\n        }\n    }\n    return @new;\n}", "    my($l2',\
    \ $i2);\n    my @temp;\n    $l2++;\n    for ($i2 = 0; $i2 < @$l; $i2++) {\n  \
    \      push (@temp, $l->[$i2]);\n    }\n    push (@$l, $l2) for (@$l, @$temp);\n\
    \    @$l = sort {$a <=> $b} @$l;\n    return;\n}", "    my(@sort) = [];\n    for\
    \ (my $i = 0; $i < @$l; $i += 2) {\n        push(@sort, $l->[$i]);\n    }\n  \
    \  return @sort;\n}", "    my;\n    $l[$_] % 2 ? push, $l[$_] : push, $l[$_] +\
    \ ($l[$_] - 1) for 0..@$l - 1;\n    @_ == @$l ? sort @$l : sort;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=perl,sorting,arrays |>\nA variation on Peter E's\
    \ answer that preserves your original list by sorting in place and also uses Schwartzian\
    \ transform:\n<code>\nmy = qw(3 5 6 2 1 4 7); # or your initial array\nmy = ();\n\
    $l[$_] % 2 ? push, $l[$_] : push, $l[$_] + 1 for;\nfor my $i (sort { $a <=> $b\
    \ } 0..$#l) {\n  splice(@l,$i,0,[@l[$i+$#l]]);\n  push @l,[@l[$i..@l]];\n}\n</code>\n\
    The for loop sorts the list in-place by choosing the value at even indexes (%2)\
    \ and the value at odd indexes ($_). After the for loop, the original list is\
    \ restored.\n<|/ a dscore=3 |>\n<| c |>\nThe `for` loop only works because the\
    \ original list is reversed, so when you splice `@l` it works on the original\
    \ list.\n<|/ c |>\n<| a tags=perl,sorting,arrays |>\nA simple algorithm that works\
    \ for any array and any number of elements would be\n<code>\nmy $arr = [1,3,2,4,5,6,7,8,9,10];",
  "    my(@lprime);\n    my $i = 0;\n    my $j = 0;\n    my $odd = 1;\n    while ($i\
    \ <= $#l) {\n        $lprime[$j++] = $l[$i++] if $odd && $j > 0;\n        $lprime[$j++]\
    \ = $l[$i++] if $odd && $i < ($#l - 1);\n        $odd = !$odd;\n    }\n    @lprime\
    \ = sort { $a <=> $b } @lprime;\n    return @lprime;\n}", "    my @new_l = ();\n\
    \    for (my $i = 0; $i < scalar(@$l); $i++) {\n        if ( $i % 2 ) {\n    \
    \        $new_l[$i-1] = $new_l[$i];\n        } else {\n            $new_l[$i]\
    \ = $new_l[$i-1];\n        }\n    }\n    return @new_l;\n}", "    my($l') = @$l[0..@$l/2];\
    \ # l' has odd indices starting from zero\n    my $i=0;\n    foreach(0..@$l/2){\n\
    \        $l'[$i] = $l'[$i] if $i&1;\n        $i++;\n    }\n    @$l[0..$i] = sort\
    \ {$a <=> $b} @$l/2;\n    return @$l';\n}", "    my @l = @$l;\n    my(@evens,\
    \ $i, $j, $odd_even);", '    my(@lprime, $lprime);', "    $l[0] = $l[0] if $l[0]\
    \ % 2 == 0;\n    $l[-1] = $l[-1] if $l[-1] % 2 == 0;\n    $l[0] = $l[0] < $l[-1]\
    \ ? $l[0] : $l[-1];\n    my $i = 0;\n    for (my $i = 0; $i < @$l - 2; $i++) {\n\
    \        last if $i && ($l[$i] % 2) != 0;\n        $l[$i] = $l[$i] >= $l[$i +\
    \ 1] ? $l[$i] - $l[$i + 1] : $l[$i + 1] - $l[$i];\n    }\n    return @$l;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=perl dscore=2 |>\nHere is a simple solution\
    \ that works for any given number of items. \n<code>", '    my @l2 = ();', " \
    \   my@l;\n    \n    # Sort the even indicies\n    for (my $i = 0; $i < @$l; $i\
    \ += 2) {\n        $l[$i + 1] = $l[$i];\n    }\n    \n    return @l;\n}", '    my(@sorted_even);',
  "    my;\n    $l = $l[$#l] while $l >= 0 and $l % 2 != 0;\n    my $j;\n    $j =\
    \ @l - 1;\n    $l[$j] = $l[$#l];\n    $l[$j] = $l[$j] unless $j == 0;\n    while\
    \ (@l != 0) {\n        my $j = $l[0];\n        delete $l[$#l];\n        $l[$j]\
    \ = $j;\n    }\n    return \\@l;\n}", "    my @odd = @$l;\n    my @even = @$l;",
  "    my($l') = ();\n    for(my $i = 0; $i < @$l; $i += 2) {\n        $l' .= $l->[$i];\n\
    \        $l' .= $l->[$i+1];\n    }\n    $l';\n}", "    my @sorted_even;\n    my($k,\
    \ $v) = ( 0);\n    my (@tmp);\n    my $odd = $l->[($k%2) != 0];\n    foreach my\
    \ $i (0 .. @$l-1) {\n        if ($odd->[$i]) {\n            $tmp[$k++]= $even[$i];\n\
    \        } else {\n            $tmp[$k++]= $odd->[$i];\n        }\n    }\n   \
    \ $k /= 2;\n    $k = @sorted_even ? $k : 0;\n    $k += 1;\n    foreach my $i (0\
    \ .. @$tmp) {\n        if ($i < @$tmp) {\n            push( @sorted_even, $tmp[$i]);\n\
    \        }\n    }\n    return @sorted_even;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for the quick response.  It seems to work fine with the example input I gave.\
    \  I will need to test it more thoroughly.  However, I do think it can be optimized\
    \ quite a bit.\n<|/ c |>\n<| c |>\nSure, let me know how it works for you. Thanks.\n\
    <|/ c |>\n<| c |>\nThis works, except that I don't understand the part that says\
    \ \"my $odd = $l->[($k%2) != 0];\".  Could you explain that part a little bit?\
    \  I understand that the \"%\" is the modulo operator.  But what does that line\
    \ do?\n<|/ c |>\n<| c |>\nYes, that line is just taking a slice of $l where $k\
    \ is even.\n<|/ c |>\n<| c |>\nOk, thanks.  It seems that I was really over complicating\
    \ this.\n<|/ c |>\n<| a dscore=2 |>\nOkay, I finally got an answer to my own question\
    \ (after reading all of the responses above).\nHere is the code I have come up\
    \ with.  I hope it helps someone out there.\n<code>", "    my @even = ();\n  \
    \  my @odd = ();\n    for my $i (0..scalar(@$l-2)) {\n        if (($i&1) != 0)\
    \ {\n            push @even, $l->[$i];\n        } else {\n            push @odd,\
    \ $l->[$i];\n        }\n    }\n    return \\@even, \\@odd;\n}", "    my @sorted;\n\
    \    $sorted[0] = $l[0]; # Assign first element to first element\n    for(my $i\
    \ = 1; $i <= $#l; ++$i) {\n        if($i % 2 == 0) { # Index is even\n       \
    \     push(@sorted, $l[$i]); # Push even element to end of sorted list\n     \
    \   } else {\n            $sorted[$i / 2] = $l[$i]; # Put element in correct position\n\
    \        }\n    }\n    return @sorted;\n}", "    my(@l');", "    my(@lprime);\n\
    \    for(my $i = 0; $i < @$l; $i += 2){\n        push(@lprime, $l->[$i]);\n  \
    \  }\n    for(my $i = @$l - 1; $i > 0; $i -= 2){\n        push(@lprime, $l->[$i]);\n\
    \    }\n    return @lprime;\n}", "    my @l_prime = ();\n    my @l_odd = ();\n\
    \    foreach my $i (0 .. $#l) {\n        if ($i % 2 == 0) {\n            push(@l_odd,\
    \ $l[$i]);\n        } else {\n            push(@l_prime, $l[$i]);\n        }\n\
    \    }\n    foreach my $i (0 .. $#l) {\n        if ($i % 2 == 0) {\n         \
    \   $l[$i] = @l_odd[$i];\n        } else {\n            $l[$i] = @l_prime[$i];\n\
    \        }\n    }\n    return @l_prime;\n}", "    my @even;\n    my @odd;\n  \
    \  foreach my $i (0 .. $#l) {\n        push @even, $l->[$i] if $i % 2 != 0;\n\
    \        push @odd, $l->[$i] if $i % 2 == 0;\n    }\n    return @even == @odd\
    \ ? @even : @odd;\n}", "    my@lb = @_;\n    my@lb = map{$_ if $_ mod 2 == 0}\
    \ @lb unless @lb;\n    push @lb, @lb;\n    push @lb, sort{ $a <=> $b } @lb unless\
    \ @lb;\n    push @lb, @lb;\n    return @lb;\n}\n</code>\n<|/ a tags=perl dscore=2\
    \ |>\n<| a |>\nThe sort function should do exactly what you need.\n<code>", " \
    \   my(@l) = sort {$a <=> $b} @$l;\n    my(@l') = @l;\n    for(my $i=0; $i<@l;\
    \ $i+=2) {\n        @l' [$i] = @l[$i];\n    }\n    @l';\n}", '    my(@sorted_even);',
  "    for (my $i = 0; $i < $#l; $i += 2) {\n        $l[$i] .= $l[$i+1];\n       \
    \ $l[$i+1] = $l[$i];\n    }\n    return $l;\n}", "    my@even = ();\n    my@odd\
    \ = ();\n    for(my $i = 0; $i <= $#l; $i += 2) {\n        $even[$i] = $l[$i];\n\
    \        $odd[$i] = $l[$i+1];\n    }\n    push @$even, sort {\n        $a <=>\
    \ $b\n    } @$odd;\n    return @$even;\n}", '    my(@lprime);', "    my(@lo) =\
    \ ();\n    my(@hi) = ();\n    my $odd = false;\n    foreach my $i (0..$#$l) {\n\
    \        push (@lo, shift(@$l) ) unless ($odd);\n        push (@hi, shift(@$l))\
    \ if ($odd);\n        $odd = !$odd;\n    }\n    return @lo;\n}", "    my @even;\n\
    \    for (my $i = 0; $i < @$l; $i += 2) {\n        push (@even, $l->[$i]);\n \
    \   }\n    @$l = @even;\n    sort { $a <=> $b } @$l;\n}", "    my @l = ();\n \
    \   my @even = ();\n    for my $i (0..$#$l) {\n        push @even, $l->[$i];\n\
    \        push @l, $l->[$i];\n        if ($i%2 != 0) {\n            push @l, $even[$i];\n\
    \        }\n    }\n    return @l;\n}", "    my(@l);\n    for(my $i = 0; $i < @$l;\
    \ $i += 2) {\n        push(@l, shift(@$l));\n    }\n    return @l;\n}", "    my($ls')\
    \ = ();\n    my @ls;\n    my $index;\n    for ($index = 0; $index < @$l; $index++)\
    \ {\n        if (!($index & 1)) {\n            $ls[$index] = $l->[$index];\n \
    \       }\n    }\n    $ls = reverse @ls;\n    $ls = sort { $a <=> $b } @ls;\n\
    \    @$l = @ls;\n    return $ls;\n}", "    my $a = 0;\n    my $r = 0;\n    my\
    \ @l1;", "    my($l') = ();\n    my $num_even = 1;\n    for my $i ( 0 .. $#{$l}\
    \ ) {\n        $l' [$num_even] = $l->[$i];\n        $num_even = ( $num_even *\
    \ 2 ) % $#{$l};\n    }\n    return $l';\n}", "    my($l2') = ();\n    my($even)\
    \ = 0;\n    my($last, $temp, $prev);\n    for my $i (0..@$l-2) {\n        if ($even)\
    \ {\n            $last = $i;\n        }\n        elsif ($last) {\n           \
    \ push @$l2, $prev;\n            $even = 0;\n        }\n        else {\n     \
    \       $temp = $l->[$i];\n            $prev = $l->[$i];\n            $l->[$i]\
    \ = $l->[$last];\n            $l->[$last] = $temp;\n        }\n        $even =\
    \ 1;\n    }\n    push @$l2, $prev;\n    return @$l2;\n}", "    return sort { $a\
    \ <=> $b } @$l if (@$l & 1);\n    @$l = sort { $a <=> $b } @$l;\n}", "    my @sorted\
    \ = ();\n    my @even = @$l;\n    for (my $i = 0; $i <= $#even; $i++) {\n    \
    \    if ($i % 2 == 0) {\n            push @sorted, $even[$i];\n        } else\
    \ {\n            push @sorted, $even[$i] if ($even[$i] <=> $even[$i + 1] == 1);\n\
    \        }\n    }\n    return \\@sorted;\n}", "    # This is an O(n) operation.\
    \  We're iterating over the array twice.  To be more precise,\n    # we're iterating\
    \ over the array once to count the even indicies, and then another time\n    #\
    \ to actually sort the array in order.\n    my $count = 0;\n    for my $i (0..$#$l)\
    \ {\n        if $i & 1 {\n            $l[$count] = $l[$i];\n            $count++;\n\
    \        }\n    }\n    for my $i (0..$#$l) {\n        if $i & 1 {\n          \
    \  $l[$i] = $l[$count];\n        }\n    }\n    return $l;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nThis is my version of the solution mentioned in the question\
    \ above.\n<code>", "    my(@l') = ();\n    for my $i (0..$#l) {\n        my($even_i)\
    \ = $i & 1;\n        my($even_val) = @$l[$even_i];\n        $l' [$even_i] = $even_val;\n\
    \        my($odd_i) = $i >> 1;\n        my($odd_val) = @$l[$odd_i];\n        $l'\
    \ [$odd_i] = $odd_val;\n    }\n    return @l';\n}", "    # $l is always shorter\
    \ than the original list\n    # $l' will always be longer than $l, but $l' will\
    \ always be longer than $l\n    my $n = @$l % 2 == 0 ? @$l : @$l - 1;\n    my\
    \ @l2 = ();\n    my @l3 = ();\n    for(my $n2 = $n; $n2 >= 0; $n2 -= 2) {\n  \
    \      push (@l2, shift @$l);\n    }\n    for(my $n3 = @$l; $n3 >= 0; $n3 -= 2)\
    \ {\n        push (@l3, shift @$l);\n    }\n    for(my $i = 0; $i < @$l; $i +=\
    \ 2) {\n        push @l2, pop @l3;\n    }\n    return \\@l2;\n}", "    my @new_array\
    \ = @$l;\n    my @evens = ();", "    if ($l && @$l % 2 == 0) {\n        for my\
    \ $i (0..($l - 1)) {\n            $l->[$i] .= $l->[$i];\n        }\n        my\
    \ $k = 0;\n        for my $i (0..($l - 1)) {\n            if ($i % 2) {\n    \
    \            $l->[$i] = $k++;\n            } else {\n                $l->[$i]\
    \ = $l->[$i];\n            }\n        }\n    }\n    return $l;\n}", "    # make\
    \ a copy of $l\n    my($lprime) = $l;\n    # sort $lprime in reverse order\n \
    \   my @sorted = sort {$a <=> $b} reverse @$lprime;\n    # sort in reverse order\
    \ and take even indicies\n    my @sortedimg;\n    foreach (@sorted) {\n      \
    \  push (@sortedimg, $_);\n        if ($_ & 1) {\n            push (@sortedimg,\
    \ $_);\n        }\n    }\n    return @sortedimg;\n}", "    my($lsort);\n    #\
    \ sort even indicies in descending order\n    my @even_indicies = 0..($#l - 1);\n\
    \    my %even_vals = ();\n    for(my $i = 0; $i < @even_indicies; $i++) {\n  \
    \      my $even_indicie = $even_indicies[$i];\n        $even_vals{$even_indicie}\
    \ = delete $even_vals{$even_indicie};\n    }\n    # create sorted list by values\
    \ from even indicies and append\n    my(@sorted_even) = ();\n    for(my $i = 0;\
    \ $i < @even_indicies; $i++) {\n        my $even_indicie = $even_indicies[$i];\n\
    \        my $even_val = $even_vals{$even_indicie};\n        unless (defined($even_val))\
    \ {\n            die \"no value $even_indicie in $even_vals\\n\";\n        }\n\
    \        push(@sorted_even, [$even_val, $i]);\n    }\n    # sort odd indicies\
    \ in ascending order\n    my(@sorted_odd);\n    for(my $i = 0; $i < @even_indicies;\
    \ $i += 2) {\n        my $odd_indicie = $even_indicies[$i];\n        my $odd_val\
    \ = $even_vals{$odd_indicie};\n        unless (defined($odd_val)) {\n        \
    \    die \"no value $odd_indicie in $even_vals\\n\";\n        }\n        push(@sorted_odd,\
    \ [$odd_val, $i]);\n    }\n    # merge sorted arrays together\n    my @sorted_list\
    \ = ();\n    for(my $i = 0; $i < @sorted_even; $i++) {\n        push(@sorted_list,\
    \ $sorted_even[$i]);\n    }\n    for(my $i = 0; $i < @sorted_odd; $i++) {\n  \
    \      push(@sorted_list, $sorted_odd[$i]);\n    }\n    return @sorted_list;\n\
    }", "    my($l');\n    $l' .= $l[0..1];\n    if (@$l & 1) {\n        splice @$l',\
    \ 0, 1;\n    }\n    $l' .= $l[2..$#$l];\n    return $l';\n}", "    my @l;\n  \
    \  for (my $i=0; $i<scalar(@$l)/2; ++$i) {\n        push @l, shift(@$l);\n   \
    \ }\n    for (my $i = 0; $i < scalar(@$l); ++$i) {\n        push @l, pop(@$l);\n\
    \    }\n    return @l;\n}", "    my(@lprime);\n    my(@lprime);\n    my(@evens);\n\
    \    my(@evens);\n    my(@evens);\n    my($temp);\n    my($temp);\n    my(@evens);\n\
    \    my(@evens);\n    my(@evens);", "    my @even_indexes = ();\n    my @odd_indexes\
    \ = ();\n    for my $index (0..$#$l-1) {\n        if ($index % 2 == 0) {\n   \
    \         push @even_indexes, $index;\n        } else {\n            push @odd_indexes,\
    \ $index;\n        }\n    }\n    push @even_indexes, sort {$a <=> $b} @even_indexes;\n\
    \    for my $index (0..$#$l-1) {\n        if ($index % 2 == 0) {\n           \
    \ push @odd_indexes, $even_indexes[$index];\n        }\n    }\n    return @odd_indexes;\n\
    }\n</cell>\n<cell>", "    my(@l_even) = (@l % 2 != 0) ? @l : (); # Even indices\
    \ are sorted as usual\n    my(@l_odd) = (); # Odd indices are sorted as usual",
  "    my($l') = @_;", "    my @even = (@$l[0..2] - 1);\n    my @odd = (@$l[1..$#l]\
    \ - 1);\n    for (my $i = 0; $i < $#even; $i++) {\n        $even[$i] =~ s/^0*(\\\
    d+)/$1/;\n    }\n    for (my $i = 0; $i < $#odd; $i++) {\n        $odd[$i] =~\
    \ s/^0*(\\d+)/$1/;\n    }\n    return sort_unequal(\\@even, \\@odd);\n}", "  \
    \  my(@even, @odd);\n    for( my $i = 0; $i < @$l; $i++ ) {\n        if( $i %\
    \ 2 ) {\n            push @even, $l->[$i];\n        } else {\n            push\
    \ @odd, $l->[$i];\n        }\n    }\n    for( my $j = 0; $j < @$l; $j++ ) {\n\
    \        $l->[$j] = @even ? $even[$j] : @odd ? $odd[$j] : undef unless ($j < @$l-1);\n\
    \    }\n    return $l;\n}", "    my(@lprime);\n    my($i, $j, $tmp);\n    for\
    \ (my $i = 0; $i < @$l; ++$i) {\n        $tmp = $l->[$i];\n        for (my $j\
    \ = $i+1; $j < @$l; ++$j) {\n            if ($l->[$i] <=> $l->[$j] == 0) {\n \
    \               $lprime->[$i] = $lprime->[$j];\n                delete $lprime->[$j];\n\
    \                $tmp = $l->[$i];\n            }\n        }\n        $lprime->[$i]\
    \ = $tmp;\n    }\n    return @lprime;\n}", '    my($len) = @_;', "    my @l =\
    \ ();\n    my @o = ();\n    my($i, $j, $k, $n, $t);", "    my(@l) = @$l;\n   \
    \ for(my $i = 0; $i < @l; $i += 2) {\n        push (@l, $l[$i]);\n        push\
    \ (@l, $l[$i + 1]);\n    }\n    return @l;\n}", "    my @sorted = ();\n    for\
    \ (my $i = 0; $i < scalar(@$l); $i += 2) {\n        $sorted[$i] = $l[$i];\n  \
    \  }\n    for (my $i = 1; $i < scalar(@$l); $i += 2) {\n        if ($sorted[$i-1]\
    \ != $sorted[$i+1]) {\n            my $j;\n            for ($j = $i; $j < scalar(@$l)\
    \ && $j > $i; $j += 2) {\n                $sorted[$j] = $l[$j];\n            }\n\
    \        }\n    }\n    @$l = @sorted;\n}", "    my($l') = $l;", "    my(@l');\n\
    \    for my $i (0..$#l) {\n        if ($i%2 != 0) {\n            $l'[$i] = $l[$i];\n\
    \        }\n    }\n    @l' = sort_even($l');\n    return @l';\n}", "    my @even;\n\
    \    my $even = $l[0];\n    for (my $i = 1; $i < @$l; $i++) {\n        if ($l[$i]\
    \ % 2 != 0) {\n            push @even, $l[$i];\n            $even = $l[$i];\n\
    \        } else {\n            if ($l[$i] > $even) {\n                $even =\
    \ $l[$i];\n            }\n        }\n    }\n    return @even;\n}", "    my @sort_even;\n\
    \    for my $i (@$l) {\n\tif ($i % 2 != 0) {\n\t    push @sort_even, $i;\n\t}\n\
    \    }\n    return @sort_even;\n}", "    my @lp = ();\n    for my $i ( 0..$#$l\
    \ ) {\n        push @lp, $i unless $i & 1;\n    }\n    return @lp;\n}", "    my\
    \ @l = @$l;\n    my @l2;", "    my($l') = [];\n    my($i);\n    for($i = 0; $i\
    \ < @$l / 2 ; $i++) {\n        my($j) = (($i % 2) < 1) ? ($i) : ($i - 1);\n  \
    \      my($tmp = $l->[$j]);\n        $l->[$j] = $l->[$i];\n        $l->[$i] =\
    \ $tmp;\n    }\n    $l;\n}\n</code>\n<|/ a dscore=0 tags=sorting,perl,arrays |>\n\
    <| a |>\n<code>", "    my @sorted = ();\n    my $i;\n    my $j;\n    foreach $i\
    \ (0 .. $#l) {\n        push @sorted, $l[$i];\n    }\n    my $even;\n    foreach\
    \ $i (1 .. $#l) {\n        $even = ($i & 1);\n        my $j;\n        foreach\
    \ $j ($i + 1 .. $#l) {\n            if ($even == ($j % 2)) {\n               \
    \ last if ($j == $#l);\n                push @sorted, $l[$j];\n            }\n\
    \        }\n    }\n    return \\@sorted;\n}", "    my(@l') = ();\n    for ($l->[0],\
    \ $l->[-1]) { # loop over odd indicies\n        if ($l->[$_] % 2 != 0) {\n   \
    \         push (@l', $l->[$_]);\n        }\n    }\n    return @l';\n}", "    my\
    \ @even = @{$l};\n    for (my $i = 1; $i < @even; $i += 2) {\n        my @temp\
    \ = @even;\n        @temp[$i], @temp[$i + 1] = @even[$i], @even[$i + 1];\n   \
    \     @even = @temp;\n    }\n    return @even;\n}\n</code>\n<|/ a tags=perl,multidimensional-array,sorting\
    \ |>\n<| c |>\n: I know, I just want it to be as clear as possible.\n<|/ c |>\n\
    <| c |>\nAnd what happens when the length of the array is odd?\n<|/ c |>\n<| c\
    \ |>\nThat would be undef. I don't know why I added that in.\n<|/ c |>\n<| c |>\n\
    : The question did not specify that this would happen - I added a comment to the\
    \ question as to why this behavior is explicitly requested in the question. As\
    \ such, it is the responsibility of the user to ensure that the input array length\
    \ is an even number (though it will default to that if left off).\n<|/ c |>\n\
    <| c |>\n: I just saw that you just edited the question to specify that if an\
    \ array has odd lengths, it is undef. Thanks for the heads up.\n<|/ c |>\n<| a\
    \ tags=perl,multidimensional-array,sorting |>\nYou can use the following subroutine\
    \ to sort an n-dimensional array:\n<code>", "    my @l = @$l;\n    my @l2 = ();\n\
    \    for (my $i = 0; $i < @l; $i += 2) {\n        @l2 += @l[$i, $i+1];\n    }\n\
    \    return @l2;\n}", "    if ($l % 2) {\n        @$l[1 .. $l/2] = sort {$a <=>\
    \ $b} @$l[1 .. $l/2];\n    }\n    return @$l;\n}", '    my@l = ();', "    my @l;\n\
    \    for my $i (0..$#$l)\n    {\n        my $j = ($i+1) + ($i & 1);\n        push\
    \ @l, @$l if $j < $i;\n        push @l, @$l if $j >= $i and $j != $i;\n    }\n\
    \    return @l;\n}", "    my(@lprime);\n    for my $i (0 .. $#$l){\n        if\
    \ ($i & 1) {\n            push @lprime, $l->[$i];\n        }\n        else {\n\
    \            push @lprime, $l->[$i];\n            push @lprime, $l->[$i];\n  \
    \      }\n    }\n    return @lprime;\n}", "    my @evens;\n    my $i = 0;\n  \
    \  foreach my $i (0 .. $#$l) {\n        if ($i & 1) {\n            $evens[$i]\
    \ = $l->[$i];\n        } else {\n            $evens[$i] = $i;\n        }\n   \
    \ }\n    $evens = sort_even($evens);\n    return @$l;\n}", "    my $even = $l->[$_]\
    \ % 2 ? $l->[$_] => $l->[$_-1] for (0 .. $#$l);\n    $even->[0] eq $even->[1]\
    \ || $even->[0] < $even->[1] ? @$l : @$even;\n}", "    my @sort = sort { $a <=>\
    \ $b } @$l;\n    my @odd;\n    my @even;\n    foreach (@sort) {\n\tpush @even,\
    \ $_ if $_ % 2;\n\tpush @odd, $_;\n    }\n    return @{ [$even, @even] }; # return\
    \ the even-indexed array\n}", "    return unless @$l % 2 == 0;\n    my(@l');\n\
    \    for (@$l) {\n        if ( $_ & 1 ) {\n            push @l', $_;\n       \
    \ } else {\n            push @l', $_;\n        }\n    }\n    return @l';\n}",
  "    my(@l' @$l);\n    \n    $l' .= @$l if $l->[0] % 2 == 0;\n    for my $i (@$l)\
    \ {\n        next if $i % 2;\n        @l'[$i-1] = $i;\n    }\n    return @l';\n\
    }", "    my;\n    foreach (@$l) {\n        unshift(@a, $_) if ($_ % 2 != 0);\n\
    \    }\n    foreach (sort {\n        $a[$_] > $b\n    } @a) {\n        shift(@b);\n\
    \    }\n    return(@b);\n}", "    for (my $i = 0; $i < @$l; $i += 2) {\n     \
    \   push @$l, splice(@$l, $i + 1, 1);\n    }\n    return @$l;\n}", "    my(@sorted);\n\
    \    my $even = 0;\n    for (my $i = 0; $i < @$l; ++$i) {\n        if ($even)\
    \ {\n            push(@sorted, $l->[$i]);\n        }\n        $even = (!$even);\n\
    \    }\n    return @sorted;\n}", "    my($l') = ();\n    for (my $i=0; $i < @$l;\
    \ $i += 2) {\n        $l' .= $l->[$i];\n        $l' .= $l->[$i+1];\n    }\n  \
    \  return $l';\n}", "    my(@l') =;\n    for (my $i = 1; $i <= $#l; $i += 2) {\n\
    \        $l' [$i] = $l[$i];\n    }\n    $l' =~ s/\\./_/g;\n    return @l';\n}",
  "    my @sorted = sort { $a <=> $b } @$l;\n    return @sorted;\n}", "    # Initialize\
    \ a hash to hold the original values\n    # Then copy into it evenly spaced values\
    \ from the original list\n    # Then copy the sorted values back into their original\
    \ locations\n    my %h = ();\n    foreach my $i (0..$#l) {\n        $h{ $i } =\
    \ $l->[$i];\n    }", "    my(@even_sorted_even);\n    for (my $i = 0; $i <; $i\
    \ += 2) {\n        push @even_sorted_even, $l[$i];\n    }\n    for (my $i = 2;\
    \ $i <; $i += 2) {\n        my $e = $l[$i];\n        my $f = $l[$i - 2];\n   \
    \     my $ef = $e; $ef->[0] ^= $f->[0];\n        my $fe = $f; $fe->[0] ^= $e->[0];\n\
    \        $e->[1] = $ef->[1] ^ $fe->[1];\n        $f->[1] = $ef->[1] ^ $fe->[1];\n\
    \    }\n    for (my $i = 0; $i <; $i += 2) {\n        push @even_sorted_even,\
    \ $l[$i + 1];\n    }\n    push @even_sorted_even, @even_sorted_even;\n    return\
    \ @even_sorted_even;\n}", "    my(@even) = ();\n    foreach my $val (@$l) {\n\
    \        push(@even, $val) if ($val & 1);\n    }\n    sort { $a <=> $b } @even;\n\
    }", "    my @sorted_even;\n    my($even) = @_;\n    for my $i (0..$#l) {\n   \
    \     if ($i % 2 == 0) {\n            push(@sorted_even, $l[$i]);\n        } else\
    \ {\n            if ($even > $l[$i]) {\n                $even = $l[$i];\n    \
    \        }\n        }\n    }\n    return @sorted_even;\n}", "    my($l') = [];\n\
    \    my $i = 0;\n    my @even = @{$l};\n    my @odd;\n    while ($i < @{$l}) {\n\
    \        push @even, $l->[$i];\n        $i++;\n    }\n    for my $i ( 1 .. @even\
    \ ) {\n        if ($i % 2 != 0) {\n            push @odd, $even[$i - 1];\n   \
    \     } else {\n            push @odd, $even[$i];\n        }\n    }\n    push\
    \ @$l, @odd;\n    return @$l;\n}", "    if (scalar @$l == 1) {\n        return\
    \ @$l;\n    }\n    my @even = ();\n    my @odd = ();\n    foreach (@$l) {\n  \
    \      push(@even, $_) if $_ & 1;\n        push(@odd, $_);\n    }\n    @$l = @even;\n\
    \    foreach (@odd) {\n        my $key = shift @$l;\n        my $value = shift\
    \ @$l;\n        if (defined $value) {\n            $key <= $value ? push @$l,\
    \ $key : $value <= $key ? push @$l, $value : $key = $value;\n        }\n    }\n\
    \    return @$l;\n}", "    my(@l');\n    for (my $i = 0; $i < @$l; ++$i) {\n \
    \       my $j = 0;\n        for (my $k = 0; $k < @$l && $j <= $i; ++$k) {\n  \
    \          if ($k != $i) {\n                ++$j;\n            }\n        }\n\
    \        push @l', @{$l->[$i]};\n        if ($i == $j) {\n            @{$l->[$i]}\
    \ = @{$l->[$j]};\n            delete $l->[$j];\n        }\n    }\n    return @l';\n\
    }", "    my @l = @$l;\n    my @lprime;\n    for (my $i = 0; $i < @l - 1; $i++)\
    \ {\n        if ($l[$i] % 2 == 0) {\n            push @lprime, $l[$i];\n     \
    \   } else {\n            $lprime[$i] = $l[$i];\n        }\n    }\n    push @lprime,\
    \ @l;\n    return \\@lprime;\n}", "    my(@l2);\n    push(@l2, $l[0]);\n    push(@l2,\
    \ $l[1]);\n    push(@l2, $l[2]);\n    push(@l2, $l[3]);\n    push(@l2, $l[4]);\n\
    \    push(@l2, $l[5]);\n    push(@l2, $l[6]);\n    push(@l2, $l[7]);\n    push(@l2,\
    \ $l[8]);\n    push(@l2, $l[9]);\n    push(@l2, $l[10]);\n    push(@l2, $l[11]);\n\
    \    push(@l2, $l[12]);\n    push(@l2, $l[13]);\n    push(@l2, $l[14]);\n    push(@l2,\
    \ $l[15]);\n    my @l3 = @l2;\n    my $i = 0;\n    my @l4 = ();\n    foreach my\
    \ $val (@l3) {\n        if ($i % 2) {\n            push(@l4, $val);\n        }\n\
    \        $i++;\n    }\n    return @l4;\n}\n</code>\n<|/ a tags=sorting,perl,arrays\
    \ |>\n<| a |>\nThe previous answers are correct, however I thought I'd add this\
    \ (as an alternative to my original answer).\n<code>", "    my(@l');", "    my\
    \ @l = ();\n    for my $i (0..$#{$l}) {\n        my $k = $i % 2;\n        $l[$i][$k]\
    \ = $l[$i][$k] || $l[$i][$k - 1];\n    }\n    return @l;\n}", "    my @l2 = ();\n\
    \    my $i = 0;\n    foreach my $v (@$l) {\n        if ($i++ & 1) {\n        \
    \    @l2 += $v;\n        } else {\n            push @l2, $v;\n        }\n    }\n\
    \    return @l2;\n}", '    return () unless @$l;', "    my @even = $l % 2;\n \
    \   my @odd = @l[0..2] - @even;\n    push(@even, $l[@_]) if @even;\n    return\
    \ @even;\n}", "    my($l') = ();\n    push(@$l', 0); # Push 0 into l' for the\
    \ first even element\n    $l'[$_] = $_ % 2 for (1 .. $#$l);", "    my @l = @$l;\n\
    \    my @l_even;\n    my @l_odd;", "    my($len) = @$l;\n    my($i) = 0;\n   \
    \ my($l);\n    my($l_even);\n    my @l_even;\n    my @l_odd;", "    my @even;\n\
    \    my @odd;", "    my @l = @$l;\n    my @evens = ();\n    my @odds = ();\n \
    \   for my $i (0..$#l) {\n        if ($i & 1) {\n            push(@odds, $l[$i]);\n\
    \        } else {\n            push(@evens, $l[$i]);\n        }\n    }\n    push(@l,\
    \ @odds);\n    push(@l, @evens);\n    return @l;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    Here is a solution that does not require a temporary array. It only makes two\
    \ passes over the list. \n<code>", '    my(@l_odd);', "    my(@result);\n    for(my\
    \ $i = 0; $i <; $i += 2){\n        if($i eq $i-1){\n            push(@result,\
    \ $l[$i]);\n        }\n    }\n    return @result;\n}", "    return sort { $a <=>\
    \ $b } @$l;\n}", "    my @sorted_even = (@$l[0 .. $#l / 2]);\n    my @sorted_odd\
    \ = (@$l[$#l / 2 + 1 .. $#l]);\n    for(my $i = 0; $i < $#l; $i += 2) {\n    \
    \    $sorted_even[$i] += $sorted_odd[$i];\n    }\n    return @sorted_even;\n}",
  "    my(@lprime);\n    my(@even);\n    my(@odd_idx);\n    my($val);", '    my;',
  "    my @l2;\n    my $j = 0;\n    my $even = 1;\n    my $odd = 0;\n    my $max =\
    \ $#$l;\n    for ($j; $j < $max; $j++) {\n        if ($odd == 0) {\n         \
    \   $l2[$j] = $l[$j];\n        } else {\n            $l2[$j] = $l[$j];\n     \
    \       $even = 0;\n        }\n        $odd = $even ? 0 : $odd + $even;\n    }\n\
    \    return @l2;\n}", "    my(@l') = ();\n    for (my $i = 0; $i < $#$l; $i +=\
    \ 2) {\n        @l' .= $l->[$i];\n        @l' .= $l->[$i + 1];\n    }\n    @l'\
    \ =~ m!([^,]+),([^,]+)!;\n    return @l';\n}", "    my(@l) = @$l;\n    my($even_count)\
    \ = @l;\n    my(@sorted_even);\n    my($i);\n    my($j);\n    foreach $i (0..$even_count-1)\
    \ {\n        $sorted_even[$i] = $l[$i];\n    }\n    foreach $i ($even_count..$#l)\
    \ {\n        $j = rand($even_count-1,$i);\n        @sorted_even[$i] = $sorted_even[$j];\n\
    \        $sorted_even[$j] = $l[$i];\n    }\n    return @sorted_even;\n}", "  \
    \  my(@l') = ();\n    my $j = 0;\n    my $i = 0;", "    my @l2;\n    for (my $i\
    \ = 0; $i < @$l; $i += 2) {\n        push @l2, $l->[$i];\n    }\n    return @l2;\n\
    }", "    my(@l' , $even);\n    @l' = $l;\n    for my $i (1 .. $#l') {\n      \
    \  if ( $i % 2 == 0 ) {\n            push (@l' , $l[$i]);\n        }\n       \
    \ else {\n            push (@l' , $l[$i-1]);\n        }\n    }\n    return @l';\n\
    }", "    my @even = @$l;\n    my @odd;\n    foreach (@$l) {\n\tmy $j = 0;\n\t\
    my $k;\n\twhile ($j < $#even) {\n\t    $j++;\n\t    $k = $even[$j];\n\t    if\
    \ ($k ne $even[$j - 2]) {\n\t\tpush(@odd, $even[$j]);\n\t\t$even[$j] = $k;\n\t\
    \    }\n\t}\n    }\n    return @even, @odd;\n}", "    my($l') = @$l;", "    my\
    \ @sorted = ();\n    for (my $i = 0; $i < @$l; $i += 2) {\n        $sorted[$i]\
    \ = $l->[$i];\n    }\n    return \\@sorted;\n}", "    my(@l') = ();\n    for (my\
    \ $i = 0; $i < @$l / 2; $i++) {\n        my $j = $i + 1;\n        $l'.[$i] = $l->[$i];\n\
    \        $l'.[$j] = $l->[$j];\n        $l'.[$i] = $l->[$i] if $i != $j;\n    }\n\
    \    return @l';\n}", "    my($l') = ();\n    for (my $i = 0; $i < @$l; $i +=\
    \ 2) {\n        $l'->[$i] = $l'->[$i+1];\n    }\n    $l'->[@_] for;\n    return\
    \ $l';\n}", "    my @sorted = ();\n    my @odd  = ();\n    for (my $i = 0; $i\
    \ < @$l; $i += 2) {\n        push(@sorted, $l->[$i]);\n        push(@odd, $l->[$i\
    \ + 1]);\n    }\n    return @sorted;\n}", "    my(@l');\n    for(my $i = 0; $i\
    \ < scalar (@$l); $i++){\n        my $temp = $l->[$i];\n        for(my $j = 0;\
    \ $j < scalar (@l); $j++){\n            if($j != $i){\n                if($l->[$j]\
    \ % 2 == 0){\n                    if($l->[$j] < $temp){\n                    \
    \    $l->[$j] = $l->[$j];\n                    }\n                }else{\n   \
    \                 if($l->[$j] > $temp){\n                        $l->[$j] = $l->[$j];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   for(my $i = 0; $i < scalar (@l'); $i++){\n        $l'[$i] = $l->[$i];\n  \
    \  }\n    return @l';\n}", "    my(@l') = ();\n    my @even = (1..$#l);\n    foreach\
    \ my $index (@even) {\n        $l[$index] = $l[$index];\n    }\n    foreach my\
    \ $index (1..$#l) {\n        if ($index % 2 == 1) {\n            $l[$index] =\
    \ $l[$index - 1];\n        }\n    }\n    return @l;\n}", "    my @even;\n    my\
    \ @odd;", "    my @l2 = ();\n    my $j;\n    for(my $i = 0; $i <= $#l; $i += 2)\
    \ {\n        $j = ((lc($l[$i]) lt lc($l[$i + 1])) ? $i : $i + 1);\n        push\
    \ @l2, $l[$j];\n        push @l2, $l[$i];\n    }\n    return @l2;\n}", "    my(@l')\
    \ = ();\n    my $odd = scalar(@$l);\n    my $even = scalar(@$l - $odd);\n    for\
    \ (my $i=0; $i<=$even; $i++) {\n        push(@l', @$l, $l->[$i]);\n    }\n   \
    \ for (my $i=0; $i<=$odd; $i++) {\n        push(@l', @$l, $l->[$i]);\n    }\n\
    \    \n    return @l';\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis algorithm\
    \ is not stable\n<|/ c |>\n<| c |>\n, The algorithm is stable. This is a stable\
    \ sort, just not in-place (as in the OPs question). A stable sort preserves any\
    \ existing sort order (if it exists). So the output of `sort_odd([1, 2, 3, 4])`\
    \ should be `[1, 2, 3, 4]`. I know this is obvious since `sort_odd([2,1,3,4])`\
    \ is `[2, 1, 3, 4]` because `sort_odd([2,1,3,4])` was already sorted.\n<|/ c |>\n\
    <| c |>\n, It's a bit more complicated than that, since a stable sort doesn't\
    \ take into account the existing sort order. So for example, `sort_odd([2, 1,\
    \ 3])` should return `[1, 2, 3]` and not `[2, 1, 3]` because `sort_odd([2, 1,\
    \ 3])` was already sorted in ascending order.\n<|/ c |>\n<| c |>\n, Ok, you are\
    \ right. But it's only a matter of *implementation*. And the implementation was\
    \ in the OPs question anyway. I was speaking about the algorithm itself\n<|/ c\
    \ |>\n<| c |>\n, Ah, I see what you mean. I'll update the answer. But I think\
    \ your approach is the most straightforward one. Thanks.\n<|/ c |>\n<| a tags=perl\
    \ |>\nYou can do it in one line:\n<code>\nmy = sort;\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=perl |>\nHere is a solution for sort in perl (using sort function\
    \ in perl) using the array reference of sort. \n<code>", "    my(@l') = @$l;\n\
    \    for (my $i=0; $i<@l; $i+=2) { # $i+=2 because we want to move the even values\
    \ down\n        my($j, $v) = @l[$i+1];\n        push @l', $v, @l[$i];\n    }\n\
    \    return @l';\n}", '    my @l = @_;', "    my @even = ();\n    for (my $i =\
    \ 0; $i < $#l; $i += 2) {\n        push(@even, @{ $l[$i..$i+2] });\n    }\n  \
    \  my @even = sort_even(@even);\n    for (my $i = 0; $i < $#l; $i += 2) {\n  \
    \      $l[$i..$i+2] = @even[$i..$i+2];\n    }\n    return @l;\n}", "    my@sorted\
    \ = @$l;\n    for (my $i = 0; $i < $#sorted; $i += 2) {\n        $sorted[$i +\
    \ 1] = $sorted[$i];\n    }\n    return @sorted;\n}", '    my @ret;', "    my @even;\n\
    \    my @odd;\n    for (my $i=0; $i<@$l; $i++) {\n        push(@even, $l->[$i]);\n\
    \        push(@odd, $l->[$i]);\n        if ($i & 1) {\n            push(@even,\
    \ $l->[$i]);\n        }\n    }\n    for (my $i=0; $i<@$l; $i++) {\n        $l->[$i]\
    \ = @even[$i];\n    }\n}", "    return sort { $a <=> $b } @$l[1 .. $#$l];\n}",
  "    my @l_even = ();\n    my @l_odd = ();\n    my ($i, $j) = @_;", "    my @even;\n\
    \    for (my $i = 0; $i < @$l; $i += 2) {\n        push @even, $l->[$i];\n   \
    \     push @even, $l->[$i + 1];\n        sort { $a <=> $b } @even;\n        shift\
    \ @even;\n    }\n    return @$l;\n}", "    my(@l);\n    my(@l_even);\n    my($i,\
    \ $i_even, $j, $j_even);", "    my @even = ();\n    my @odd = ();\n    my $last_index\
    \ = 0;", "    my(@l2);\n    for(my $i=0;$i<@l;$i+=2) {\n        @l2[$i] = $l[$i];\n\
    \        @l2[$i+1] = $l[$i+1];\n    }\n    return @l2;\n}", "    my($l') = @$l;",
  "    my @even = ();\n    my @odd = ();", "    my @l2;\n    my $even = 0;\n    my\
    \ $i = 0;\n    for (my $n = $#l; $i < $n; $i++) {\n        if ($even != $i % 2)\
    \ {\n            $even = ($even + 1) % 2;\n        }\n        push @l2, $l[$i]\
    \ if $even;\n        push @l2, $l[$i];\n    }\n    return @l2;\n}", '    my @l;',
  "    my @even;\n    my @odd;\n    my $i = 0;\n    my $j = 0;\n    while($i <= $#l)\
    \ {\n        if ($i % 2 eq 0) {\n            $even[$j] = $l[$i];\n           \
    \ $j++;\n        }\n        else {\n            $odd[$i] = $l[$i];\n         \
    \   $i++;\n        }\n    }\n    push @even, sort @even;\n    push @odd, sort\
    \ @odd;\n    return [@even, @odd];\n}", "    return sort { $a[$_] % 2 ? $b :\n\
    \                $a[$_] % 2 ? $a : $b };\n}", '    my(@result);', "    my($l')\
    \ = @$l;\n    my %sorted_odd = ();\n    my %sorted_even = ();", "    if (@$l %\
    \ 2) {\n        my @l = ();\n        for (my $i = 0; $i < @$l; $i += 2) {\n  \
    \          $l[$i + 1] = $l[$i];\n        }\n        @l = sort {$a <=> $b} @l;\n\
    \    }\n    return @$l;\n}", "    my $len = @$l;\n    my @a = ($len % 2) ? @$l\
    \ : ();\n    for(my $i=0; $i<$len; $i++) {\n        if($i) {\n            if($a[$i]\
    \ >= $a[$i-1]) {\n                my $j = $i;\n                while(1) {\n  \
    \                  $a[ $j-- ] = $a[ $j+1 ]; $j++;\n                    $j = $j\
    \ < 0 ? $len-1 : $j;\n                    if($a[$i] >= $a[$j]) {\n           \
    \             next;\n                    }\n                }\n            }\n\
    \        }\n        push @a, $a[$i];\n    }\n    return @a;\n}", "    my($len)\
    \ = @$l;\n    my(@l') = ();\n    for(my $i=0; $i<$len; $i+=2) {\n        push(@l',\
    \ $l[$i]);\n    }\n    return @l';\n}", "    @$l = map $_, $l; # take care of\
    \ odd and even indicies\n    my @l = @$l;        # take care of values\n    for\
    \ (my $i=0; $i<@l; $i+=2) {\n        $l[$i] = $l[$i+1];\n    }\n    return @l;\n\
    }", "    my(@even);\n    my(@odd);\n    \n    @odd = grep {$_ % 2 != 0} @$l;\n\
    \    @even = grep {$_ % 2 == 0} @$l;\n    \n    push @even, @$l;\n    push @$l,\
    \ @even;\n    \n    push @$l, @odd;\n    \n    return @$l;\n}", "    my(@even)\
    \ = ();\n    for(my $i=0; $i<@$l; ++$i) {\n        if($i & 1) {\n            push(@even,\
    \ @{$l->[$i]});\n        } else {\n            push(@even, $l->[$i]);\n      \
    \  }\n    }\n    return @even;\n}", "    $l =~ s/^/0 if ($l =~ /\\d/);\n    @l\
    \ = (sort { $a <=> $b } @l);\n    foreach my $i (0..@l / 2 - 1) {\n        splice(@l,\
    \ $i, 2, $l[$i]);\n    }\n    return @l;\n}", "    my @sorted_even;\n    my $even_count\
    \ = 0;\n    my $odd_count = 0;\n    foreach my $elem (@$l) {\n        if($even_count\
    \ == 0) {\n            $even_count = 1;\n            push(@sorted_even, $elem);\n\
    \        }\n        elsif ($even_count == 1) {\n            if($even_count ==\
    \ 2) {\n                $even_count++;\n                if($even_count == 4) {\n\
    \                    $even_count++;\n                }\n            }\n      \
    \      else {\n                push(@sorted_even, $elem);\n            }\n   \
    \     }\n        else {\n            push(@sorted_even, $elem);\n        }\n \
    \   }\n    return @sorted_even;\n}", "    my(@lp) = map {$_ % 2}, @$l;\n    push\
    \ @lp, @l[@lp ^ $l];\n    @l\n}", "    my;\n    my $even = 0;\n    my $i = 0;\n\
    \    my $j = 1;\n    # Loop through the elements of $l adding them to a new array\n\
    \    # until we reach the end of the array, or the element at i is evenly\n  \
    \  # divisible by 2.\n    while ($i < @$l) {\n        if ($even/2 == $j) {\n \
    \           push, $l->[$i];\n        }\n        elsif ($l->[$i] % 2) {\n     \
    \       push, $l->[$i];\n        }\n        else {\n            push, $l->[$i];\n\
    \            $even++;\n        }\n        ++$i;\n        $j += $even/2;\n    }\n\
    \    return @$l;\n}", "    my($l') = [];\n    my($i, $even_count);", "    my @evens\
    \ = ();\n    my @odds = ();\n    my $len = $#l;\n    for(my $i = 0; $i < $len;\
    \ $i+=2){\n        push (@evens, $l[$i]);\n        push (@odds, $l[$i+1]);\n \
    \   }\n    push @evens, @evens;\n    return @evens;\n}", "    my;\n    my $j;\n\
    \    for (my $i = 0; $i <; $i+=2) {\n        push (@new, @{$l[$i]});\n       \
    \ push (@new, $l[$i+1]) if $j >= @$l;\n        $j++;\n    }\n    return;\n}",
  '    my @sorted_even = ();', "    my @even_indexes = ();\n    my @odd_indexes =\
    \ ();\n    for(my $i = 0; $i < @$l; $i+=2) {\n        $even_indexes[$i] = $i;\n\
    \        push @odd_indexes, $i+1;\n    }\n    for(my $i = 0; $i < @$l; $i+=2)\
    \ {\n        $even_indexes[$i] = $i+1;\n        push @odd_indexes, $i;\n    }\n\
    \    for(my $i = 0; $i < @$l; $i++) {\n        $even_indexes[$i] = $i;\n    }\n\
    \    my @l = ();\n    for(my $i = 0; $i < @$l; $i+=2) {\n        push @l, $l->[$even_indexes[$i]];\n\
    \    }\n    for(my $i = 0; $i < @$l; $i+=2) {\n        push @l, $l->[$odd_indexes[$i]];\n\
    \    }\n    return @l;\n}", "    my @evens = ();\n    my($i) = 0;\n    \n    for\
    \ $i (0..scalar(@$l) - 1) {\n        if ($i & 1) {\n            push(@evens, $l->[$i]);\n\
    \        }\n    }\n    return @evens;\n}", "    my(@l');", "    my(@l') = ();\n\
    \    for (my $i = 0; $i <= $#$l; $i++) {\n        $l' .= $l -> [$i];\n       \
    \ if ($i % 2 == 0) {\n            $l' -> [$i] .= $l -> [$i];\n        }\n    }\n\
    \    return @l';\n}\n</code>\nThis was a fun exercise.\n<|/ a tags=arrays,perl,sorting\
    \ |>\n<| c |>\nYour `sort_even` subroutine is exactly what I wanted. Thanks for\
    \ this.\n<|/ c |>\n<| c |>\n: thanks for sharing! I appreciate it a lot :) I spent\
    \ a couple of hours trying to figure out how it worked, and was just about to\
    \ post my own answer. One question - in the last if statement of the loop, I believe\
    \ you meant `@l' .= $l -> [$i];`, right? Thanks again for the great answer!\n\
    <|/ c |>\n<| c |>\nNo, I meant `@l' .= $l -> [$i]` (notice the space after the\
    \ dot). See http://perldoc.perl.org/perlop.html#Bracketed-Expression-Operator.\n\
    <|/ c |>\n<| c |>\nOh right - I was trying `@l' .= $l -> [$i]` but got `Argument\
    \ \"@l\" isn't numeric in array element` because `$l` was an array of arrays so\
    \ the array index was the string `@l` rather than an integer.\n<|/ c |>\n<| c\
    \ |>\nAh! I understand now. Thanks!\n<|/ c |>\n<| a tags=arrays,perl,sorting |>\n\
    Here's another approach, using the Schwartzian transform:\n<code>", "    my @even\
    \ = ();\n    my @odd;", "    my(@even) = ();\n    my(@odd);\n    my($i, $j, $k);\n\
    \    my(@a);", "    my(@lprime);\n    my(@lprime2);\n    my $even;\n    my $odd;\n\
    \    my $index;", "    my(@lprime);\n    my $i = 0;\n    my $j = 0;\n    my @evens\
    \ = ();\n    while (@$l) {\n        if ($i % 2 == 0) {\n            if ($i ==\
    \ $j) {\n                push @evens, $l[$j];\n            }\n            else\
    \ {\n                push @lprime, $l[$j];\n            }\n        }\n       \
    \ $j++;\n        $i++;\n    }\n    @$l = @lprime;\n    @$l = sort { $a <=> $b\
    \ } @$l;\n    return @$l;\n}", "    return @$l if @$l == 1;\n    return sort @$l\
    \ if @$l % 2;\n    my(@even) = (0..@$l - 1);\n    my(@odd)  = (@$l - 1);\n   \
    \ my $index = 0;\n    for(;;) {\n        last if $index >= @$l;\n        my($value)\
    \ = @$odd[$index];\n        @$odd[$index] = $value;\n        @$even[$index] =\
    \ $value;\n        $index += 2;\n    }\n}", "    if (@$l % 2 == 1) {\n       \
    \ $l = [sort @$l];\n        my $i = 0;\n        for (my $i = scalar(@$l) - 1;\
    \ $i >= 0; $i -= 2) {\n            $l->[$i] = $l->[$i];\n        }\n    }\n  \
    \  return @$l;\n}", "    my(@l') = ();\n    foreach $i (0 .. $#$l) {\n       \
    \ if ($i%2 == 0) {\n            push(@l', $l[$i]);\n        } else {\n       \
    \     my $j = $i;\n            my $k = $i;\n            while ($k > 0 && ($k %\
    \ 2 == 0)) {\n                $k = $k / 2;\n                unshift(@l', $l[$k]);\n\
    \            }\n            push(@l', $l[$k]);\n        }\n    }\n    return @l';\n\
    }", "    my(@l') = ();\n    for(my $i = 0; $i < $#l; ++$i) {\n        if(($i %\
    \ 2) != 0) {\n            push(@l', $l[$i]);\n        }\n    }\n    return @l';\n\
    }", "    return $l unless @$l;\n    my($l_even) = @$l[1 .. $l % 2];\n    my($l_odd)\
    \ = @$l[$l % 2 + 1 .. $#l];\n    return @$l_even unless @$l_even;\n    return\
    \ @$l_odd;\n}", "    my(@l') = ();\n    for (my $i = @$l - 2; $i >= 0; $i--) {\
    \ # go through the array, making new elements at the end\n        push(@l', $l->[$i\
    \ + 2]);\n    }\n    return @l';\n}", "    # sort even indicies\n    for (my $i\
    \ = 0; $i < @$l / 2; $i++) {\n        # find the min of the two values\n     \
    \   my $min = $l->[$i];\n        for (my $j = $i + 1; $j < @$l; $j++) {\n    \
    \        $min = $min > $l->[$j] ? $min : $l->[$j];\n        }\n        # swap\n\
    \        for ($i; $i < $j; $i++) {\n            $l->[$i] = $l->[$j];\n       \
    \ }\n        $l->[$j] = $min;\n    }\n    return $l;\n}", "    my @l = @_;\n \
    \   my @lnew;\n    for(my $i=0;$i<$#l;$i+=2) {\n        my $tmp = $l[$i];\n  \
    \      for(my $j=$i+1;$j<$#l;$j++) {\n            if ($l[$j] >= $tmp) {\n    \
    \            $tmp = $l[$j];\n            }\n        }\n        $lnew[$i] = $tmp;\n\
    \    }\n    return @lnew;\n}", "    my(@l') = ();\n    foreach (0 .. $#l) {\n\
    \        my $e = ($_ + $#l) % 2;\n        @l' .= $l[$_] if $e;\n        @l' .=\
    \ [$l[$_]] if !$e;\n    }\n    return @l';\n}", '    my($l_copy) = @$l;', "  \
    \  if (@$l % 2) {\n        # odd, sort on even indicies\n        my($even) = splice(@$l,\
    \ 0, @$l/2);\n        my($odd) = splice(@$l, 0, @$l/2);\n        splice(@$l, 0,\
    \ @$l/2);\n        push(@$even, $even->[$#even-1], @$even);\n        push(@$odd,\
    \ $odd->[$#odd-1], @$odd);\n        return sort { $a <=> $b } @$l;\n    }\n  \
    \  return @$l;\n}", "    if (scalar @$l == 1) {\n        return $l;\n    }\n \
    \   return sort { $a <=> $b } @$l;\n}", "    my(@l') = ();\n    foreach my $i\
    \ (0 .. $#l) {\n        if($i % 2 == 0) {\n            push @l', $l[$i];\n   \
    \     } else {\n            my $j = $i;\n            my $found = 0;\n        \
    \    while(!$found && $j > 0) {\n                if($l[$j - 1] == $l[$j]) {\n\
    \                    $found = 1;\n                } else {\n                 \
    \   $j--;\n                }\n            }\n            if(!$found) {\n     \
    \           push @l', $l[$i];\n            }\n        }\n    }\n    return @l';\n\
    }", '    my(@lprime);', "    my @even_positions;\n    my @odd_positions;\n   \
    \ for (my $i = 0; $i < @$l; $i++) {\n        if ($i%2 == 0) {\n            push(@odd_positions,\
    \ $i);\n        } else {\n            push(@even_positions, $i);\n        }\n\
    \    }\n    if (@odd_positions == 0) {\n        return @$l;\n    }\n    my @result\
    \ = ();\n    my $first_element = shift(@odd_positions);\n    for (my $i = $first_element;\
    \ $i < $#odd_positions; $i++) {\n        push(@result, $l->[$odd_positions[$i]]);\n\
    \    }\n    for (my $i = $first_element; $i < $#even_positions; $i++) {\n    \
    \    my $j = $even_positions[$i];\n        my $tmp = $l->[$j];\n        $l->[$j]\
    \ = $l->[$i];\n        $l->[$i] = $tmp;\n    }\n    return @result;\n}", "   \
    \ my @sorted = ();\n    for (my $i = 0; $i < @$l / 2; $i++) {\n        push @sorted,\
    \ $l->[$i];\n        $l->[$i] .= $l->[$i + 1];\n        $l->[$i + 1] = $l->[$i];\n\
    \    }\n    return @sorted;\n}", "    # Create a boolean array which is True where\
    \ $l is odd.\n    my($l_odd) = ( $l & 1 ) == 1;\n    $l_odd ? $l++ : @$l += @$l;\n\
    \    # Sort $l and return the sorted array.\n    @$l =\n      sort { $a <=> $b\
    \ }\n      map  { $_ * ( $l_odd ? -1 : 1 ) }\n      @$l;\n}", "    my(@evens)\
    \ = (0);\n    my(@odd) = (0);\n    for (my $i = 0; $i < @$l; $i++) {\n       \
    \ if ($i % 2 == 0) {\n            push(@evens, $l->[$i]);\n        } else {\n\
    \            push(@odd, $l->[$i]);\n        }\n    }\n    return @evens, @odd;\n\
    }", "    return @$l unless @$l > 0;\n    @$l = sort {$a <=> $b} @$l if $] < 5.008;\n\
    \    @$l;\n}", "    # Odd indicies are sorted by their value, even indicies are\
    \ sorted by their value\n    # then merged together with their even indicies\n\
    \    my(@l') = map { $a[$_] ? ($a[$_]=>$b[$_]) : ()} 0..$#l;\n    \n    return\
    \ @l' if (@l' > 0);\n    return;\n}", "    my @l = ();\n    for (my $i = 0; $i\
    \ < $#l; $i += 2) {\n        push (@l, $l[$i]);\n    }\n    for (my $i = $#l;\
    \ $i >= 0; $i -= 2) {\n        push (@l, $l[$i]);\n    }\n    return @l;\n}",
  "    for (my $i=0; $i<@$l-$#l/2; $i++){\n        next if ($i+$#l%2);\n        $l[$i+$#l%2]\
    \ = $l[$i];\n    }\n    return @$l;\n}", "    my;\n    for (my $i=0; $i<@$l; $i+=2)\
    \ {\n        push (@sorted_even, $l->[$i]);\n        push (@sorted_even, $l->[$i+1]);\n\
    \    }\n    return;\n}", "    my @even = ();\n    my @odd = ();\n    for my $i\
    \ (0 .. $#$l) {\n        push @even, $l->[$i];\n        if ($i % 2 != 0) {\n \
    \           push @odd, $l->[$i];\n        }\n    }\n    \n    my @sorted_even\
    \ = ();\n    my @sorted_odd = ();\n    \n    for(my $i=0; $i<=$#l; $i++) {\n \
    \       my $x = $even[$i];\n        my $y = $even[$i];\n        if ($i+1 < $#l)\
    \ {\n            $x = $even[$i+1];\n            $y = $even[$i];\n        }\n \
    \       \n        push @sorted_even, $x; \n        push @sorted_odd, $y; \n  \
    \  }", "    my($l') = $l;\n    my @even = ();\n    for (my $i = 0; $i < @$l; $i\
    \ += 2) {\n        push (@even, $l->[$i]);\n    }\n    for (my $i = 1; $i < @$l;\
    \ $i += 2) {\n        $l->[$i] = $l->[$i-1];\n    }\n    @$l = sort @even;\n \
    \   return $l';\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
