name: HumanEval_37_sort_even
language: pl
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n# to the values of the even indicies of l, but sorted.\n# >>> sort_even([1,\
  \ 2, 3])\n# [1, 2, 3]\n# >>> sort_even([5, 6, 3, 4])\n# [3, 6, 5, 4]\nsub sort_even\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_even;\n\
  \        if(eq_deeply($candidate->([1, 2, 3]),[1, 2, 3])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5,\
  \ 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(@l');", "    my @even;\n    my @odd;", "    my@l2 = @_;\n  \
    \  my@l3 = @l2;\n    for(my $i=$#l3; $i>0; $i-=2) {\n        my $j;\n        for($i=$i;\
    \ $i<$#l3; $i+=2) {\n            $j = $i;\n            last unless $l3[$i] <=\
    \ $l3[$j];\n        }\n        @l3[$i-1] = @l3[$i];\n        @l3[$i] = $l3[$j];\n\
    \    }\n    return @l3;\n}", "    my(@l') =;", "    my($j, $last) = @$l[1..$#$l];\n\
    \    my($even, $odd);\n    do {\n        my($i, $temp) = grep {\n            $_\
    \ % 2 ? ($even = 1, !$even) : ($even = !$even, !$even)\n        } @$l;\n     \
    \   my(@temp) = $l[$i, $even, @$l[$i, $odd]];\n        my(@temp) = $odd ? (@temp,\
    \ $even) : (@temp, $odd);\n        @$l[$i, $even, @$l[$i, $odd]] = @temp;\n  \
    \      $odd++;\n    } until ($odd > $last);\n    return @$l;\n}", "    my @l;\n\
    \    for (my $i = 0; $i < @$l; $i += 2) {\n        push @l, $l->[$i];\n    }\n\
    \    return @l;\n}", "    my(@sort) = ();\n    for(my $i = 1; $i < @$l; $i +=\
    \ 2) {\n        push(@sort, $l->[$i]);\n    }\n    return @sort;\n}", "    $l\
    \ = [sort {$a->[0] cmp $b->[0]} @$l];\n    return @$l;\n}", "    my @even;\n \
    \   my @odd;\n    my($i, $j, $odd);\n    for ($i = scalar(@$l); $i > 0; $i--)\
    \ {\n        $even[$i] = $l[$i];\n        next unless ($i & 1);\n        $odd[$i]\
    \ = $l[$i];\n        $j = $i;\n        while ($j > 0 && $l[$j - 1] > $l[$j]) {\n\
    \            $l[$j - 1] = $l[$j];\n            $l[$j] = $odd[$j--];\n        }\n\
    \        $j--;\n    }\n    return @even;\n}", "    my($l') = ();\n    my($i);\n\
    \    foreach $i (0 .. $#$l) {\n        push(@$l', shift(@$l) if ($i%2 == 0));\n\
    \    }\n    return @$l';\n}", "    my @even = ();\n    my @odd = ();\n    for\
    \ my $i (0 .. $#l) {\n        my $j = $i;\n        while ($j > 0) {\n        \
    \    $odd = $even[$#even] unless(exists($even[$j-1]));\n            push(@even,\
    \ $even[$j-1]) unless(exists($even[$j]));\n            $even[$j] = $even[$#even];\n\
    \            $j--;\n        }\n        push(@odd, $l[$i]) unless($i%2 == 1);\n\
    \    }\n    return \\@even, @odd;\n}", "    my @even;\n    my @odd;\n    for(my\
    \ $i = 0; $i < $#{$l}; $i++){\n        if($i & 1){\n            push(@even, $l->[$i]);\n\
    \        }else{\n            push(@odd, $l->[$i]);\n        }\n    }\n    return\
    \ @even;\n}", "    @$l = sort {$a <=> $b} @$l;\n    my $count = 0;\n    foreach\
    \ my $i (@$l) {\n        ++$count if $i & 1;\n    }\n    $count;\n}", "    my\
    \ @l;\n    my @odd = ();\n    my @even = ();", "    $l =~ m{(\\d+)} or die \"\
    sort_even: bad input\\n\";\n    my @a;\n    my $even = 1;\n    my $i = 1;\n  \
    \  my $evens = $i;\n    while (@l) {\n        if ($i % 2) {\n            push\
    \ @a, $l[$i-1];\n        } else {\n            if ($evens eq $i) {\n         \
    \       $even++;\n                $evens = $even;\n            } else {\n    \
    \            $evens = $i;\n            }\n        }\n        $i++;\n    }\n  \
    \  return @a;\n}", "    my @l = @$l;\n    for(my $i = 0; $i < @l; $i++) {\n  \
    \      my $val = $l->[$i];\n        my $odd = $i & 1;\n        $l->[$i] += $odd\
    \ if $odd;\n        $l->[$i] -= $odd if $odd && $i != 0 && $i & 1;\n    }\n  \
    \  return @$l;\n}", "    return () unless @$l;\n    $l = @$l if @$l % 2;\n   \
    \ my @sorted = (@$l);\n    my @even = ();\n    my @odd  = ();\n    my $k = 0;\n\
    \    for my $i (0..$#sorted) {\n        if ($k % 2) {\n            push @even,\
    \ $sorted[$i];\n        } else {\n            push @odd, $sorted[$i];\n      \
    \  }\n        $k++;\n    }\n    return @{$_[0]} ? [@even, @odd] : @odd;\n}", " \
    \   for (my $i = 0; $i < @$l - 1; $i++) {\n        my $v = $l->[$i];\n       \
    \ if ($i % 2 != 0) {\n            $l->[$i] = $v; \n        }\n        else {\n\
    \            my $v = $l->[$i];\n            for (my $j = 0; $j < $i -1; $j++)\
    \ {\n                if ($l->[$j] > $v) {\n                    $v = $l->[$j];\n\
    \                }\n            }\n            $l->[$i] = $v;\n        }\n   \
    \ }\n    return $l;\n}", "    my @l_copy = ();\n    my @l_copy2 = ();\n    my\
    \ $l_copy_index = 0;\n    my $l_copy_index2 = 0;", "    my(@l') = ();\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push\
    \ @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n    push @l', @$l;\n", " \
    \   my @evens = ();\n    my @odds = ();\n    for my $i (0..scalar(@$l)) {\n  \
    \      if ($i%2 == 0) {\n            push @odds, $l->[$i];\n        }\n      \
    \  else {\n            push @evens, $l->[$i];\n        }\n    }\n    return @evens,\
    \ @odds;\n}\n</code>\n<|/ a tags=sorting,perl,algorithm dscore=2 |>\n<| c |>\n\
    : No, it doesn't.  It doesn't require extra space, it sorts in place.  It's a\
    \ sorting algorithm, and as such it can be faster than bubble sort on average.\n\
    <|/ c |>\n<| c |>\n: It sorts in place because it does not create extra space.\
    \ `@evens, @odds` does create extra space, but it's in the `sort` block scope,\
    \ and not lexical.\n<|/ c |>\n<| c |>\n: You're right.  It was a typo.  Thanks.\n\
    <|/ c |>\n<| c |>\n`@evens, @odds` does create extra space in the `sort` block\
    \ scope, but not lexical. A lexical list will keep those evens and odds in separate\
    \ memory cells, whereas `@evens, @odds` will keep those in one array slot.\n<|/\
    \ c |>\n<| c |>\nI guess I should clarify my previous comment by saying \"a lexical\
    \ list will keep those evens and odds in separate memory cells, whereas `@evens,\
    \ @odds` will keep those in one array slot.\" That was a typo. :)\n<|/ c |>\n\
    <| a tags=sorting,perl,algorithm |>\nIf you use sort's sorting subroutines, you\
    \ can specify the comparison function to use, and it can use a user-defined comparison\
    \ function that returns -1, 0 or 1 based on the elements' order. That's a bit\
    \ simpler than writing your own sorting functions.\n<code>\nuse warnings;\nuse\
    \ strict;", "    my @even = @$l;\n    my @odd  = ();", "    my @even = $l[0 ..\
    \ $#l];\n    my @odd = $l[1 .. $#l];\n    my $even_index = 0;\n    my $odd_index\
    \ = 0;", "    my(@even) = ();\n    my(@odd);", "    my(@l') = ();\n    for(my\
    \ $i = 0; $i < $#l; $i += 2) {\n        push(@l', $l[$i] if $l[$i] % 2);\n   \
    \     push(@l', $l[$i + 1]);\n    }\n    return \\@l';\n}", "    my @evens = @$l;\n\
    \    for (my $i = 1; $i < @$l; $i += 2) {\n        push @evens, $evens[$i-1];\n\
    \    }\n    return @evens;\n}", "    return $l if @$l < 2;\n    my(@l) = @$l;\n\
    \    my $i = 0;\n    my $j = 1;\n    my(@l_odd);\n    my(@l_even);\n    for(;\
    \ $i<@l && $j<@l; $i++) {\n        if($i % 2 == 0) {\n            push(@l_even,\
    \ $l[$i]);\n        } else {\n            push(@l_odd, $l[$i]);\n        }\n \
    \   }\n    return sort_even($l_odd) unless @l_odd;\n    push(@l_odd, sort_even($l_even));\n\
    \    return @l_odd;\n}", "    my(@l_odd) = ();\n    my(@l_even) = ();", "    my(@l'\
    \ , $even);\n    my $even = 0;\n    foreach (@$l) {\n        if ($even eq 0) {\n\
    \            push (@$l', $_);\n            $even = 1;\n        }\n        elsif\
    \ ($even eq 1) {\n            push (@$l', $_);\n        }\n        else {\n  \
    \          push (@$l', $_) if $_ ne $l{$_};\n        }\n    }\n    return @$l';\n\
    }", "    my(@lprime);\n    my $i = 0;\n    foreach (@{$l}) {\n        ++$i;\n\
    \        if ($i % 2 == 0) {\n            push(@lprime, $_);\n        } else {\n\
    \            $lprime[$_ - 1] = $_;\n        }\n    }\n    return @lprime;\n}\n\
    </code>\nI added this sorter function because I didn't realize the array was already\
    \ sorted, and I wanted it to sort it for me as well, so I added this wrapper around\
    \ it - so now we can just call sort_even() on our array:\n<code>\nmy = sort_even([1,2,3]);",
  "    my($lprime);\n    my($even_count);\n    my($odd_count);", "    my(@l' );",
  "    my @l;\n    my $n = ($#l + 1) / 2;\n    my $even = $n % 2 ? 1 : 0;\n    push(@l,\
    \ $l[$even]) unless($even);\n    for(my $i = $#l + 1; $i <= $n; $i += 2) {\n \
    \       my $t = $l[$i];\n        my $j = $i + 1;\n        while(++$j < $n && $l[$j]\
    \ <= $t) {\n            last if $j < $n;\n        }\n        push(@l, $l[$i])\
    \ if $j < $n;\n        push(@l, $t);\n    }\n    push(@l, $l[$n]) if $n % 2;\n\
    \    return @l;\n}", "    my @even = ();\n    my @odd = ();\n    my $index = 0;\n\
    \    foreach my $n (@$l) {\n        if ($n % 2 == 0) {\n            $even[$index]\
    \ = $n;\n            $index++;\n        } else {\n            $odd[$index - $#odd]\
    \ = $n;\n        }\n    }\n    for (my $i = 0; $i <= $#odd; $i++) {\n        $odd[$i]\
    \ = $even[$i];\n    }\n    return \\@odd;\n}", "    my @l = @_;\n    \n    my\
    \ $length = scalar @l;\n    $length--; # don't sort last element of array\n  \
    \  my $even_index = 0;\n    my $odd_index = 0;\n    my $even = $even_index;\n\
    \    my $odd = $odd_index;\n    my $odd_value = $l[$odd];\n    my $even_value\
    \ = $l[$even];\n    for (my $i = 0; $i < $length; $i++) {\n        if ($i & 1)\
    \ {\n            if ($i & 2) {\n                $l[$i] = $odd_value;\n       \
    \         $odd_index++;\n            }\n            else {\n                $l[$i]\
    \ = $even_value;\n                $even_index++;\n            }\n        }\n \
    \       else {\n            if ($i & 2) {\n                $odd_value = $l[$odd_index];\n\
    \                $odd_index++;\n            }\n            else {\n          \
    \      $even_value = $l[$even_index];\n                $even_index++;\n      \
    \      }\n        }\n    }\n    return @l;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nI appreciate your effort, but I am looking for an algorithm that can take\
    \ an array of any size and sort it in a way which doesn't require me to rewrite\
    \ the sort function for each new size.\n<|/ c |>\n<| a dscore=0 |>\nThe solution\
    \ below sorts the array using the original unsorted array's length and a secondary\
    \ array that holds the index of each unsorted element.\n<code>", "    my(@sorted);\n\
    \    for (my $i = 0; $i < @$l; $i += 2) {\n        $sorted[$i] = $l[$i];\n   \
    \ }\n    for (my $i = 1; $i < @$l; $i += 2) {\n        $sorted[$i] = $sorted[$i-1];\n\
    \    }\n    return @sorted;\n}", "    return () unless @$l > 0;\n    my @odd;\n\
    \    my @even;\n    my $last_odd = 0;\n    foreach my $i (0 .. @$l - 1) {\n  \
    \      $odd[$last_odd] = $i;\n        if ($last_odd % 2 == 0) {\n            $even[$last_odd]\
    \ = $i;\n        }\n        $last_odd = $last_odd + 1;\n    }\n    return @even\
    \ ? @even : (reverse @odd);\n}", "    my @sorted = ();\n    my @odd = ();\n  \
    \  my @even = ();\n    foreach my $i (0..@$l-1) {\n\tif ($i%2 == 0) {\n\t    push(@even,\
    \ @$l[$i..$i+1]);\n\t} else {\n\t    push(@odd, @$l[$i..$i+1]);\n\t}\n    }\n\
    \    foreach my $i (0..@$l-2) {\n\tmy $j = 0;\n\twhile ($j < (@$l-2)) {\n\t  \
    \  my $temp = $odd[$j];\n\t    $odd[$j] = $even[$j];\n\t    $even[$j] = $temp;\n\
    \t    $j++;\n\t}\n    }\n    foreach my $i (0..@$l-2) {\n\tpush(@sorted, @$odd[$i..$i+1]);\n\
    \tpush(@sorted, @$even[$i..$i+1]);\n    }\n    return @sorted;\n}", "    my;\n\
    \    for(my $i=0; $i<@$l; $i+=2) {\n        $even[$i] = $l->[$i];\n    }\n   \
    \ for(my $i=@$l; $i<@$l; $i++) {\n        $even[$i] = $l->[$i];\n    }\n    for\
    \ (my $i=@$l; $i<@$l; $i++) {\n        $even[$i] = $l->[$i];\n    }\n    $even\
    \ = sort { $a <=> $b } @$even;\n    $even = @$even ? @$even : ();\n    return\
    \ @$l;\n}", "    my @even = ();\n    my @odd  = ();\n    my @swap;\n    for(my\
    \ $i = 0; $i < @$l; $i += 2) {\n        push(@even, $l->[$i]);\n        push(@odd,\
    \ $l->[$i + 1]);\n    }\n    for(my $i = 0; $i < @$l; $i += 2) {\n        if($i\
    \ % 2 == 0) {\n            push(@swap, @even);\n            push(@even, @odd);\n\
    \            push(@odd, @swap);\n        } else {\n            push(@swap, @odd);\n\
    \            push(@even, @swap);\n            push(@odd, @even);\n        }\n\
    \    }\n    return @even;\n}", "    if (@$l == 0) { return; }\n    my $len = @$l;\n\
    \    my @sorted_even = ();\n    my @sorted_odd = ();\n    for (my $i = 0; $i <\
    \ $len; $i++) {\n        if ($i & 1) {\n            push @sorted_even, $l->[$i];\n\
    \        } else {\n            push @sorted_odd, $l->[$i];\n        }\n    }\n\
    \    return @sorted_even, @sorted_odd;\n}", "    return ($l[0..1]) if ($l[0] &\
    \ 1);\n    return sort {$a <=> $b} @$l[1..$#$l];\n}", "    my($l') = @$l;\n  \
    \  my $size = @$l;\n    my @even = ();\n    for (my $i = 0; $i < $size; $i++)\
    \ {\n        push(@even, $l->[$i] if ($i % 2));\n    }\n    for (my $i = 0; $i\
    \ < $size; $i++) {\n        $l->[$i] = $l->[$i] if ($i % 2);\n        $l->[$i]\
    \ = $l->[$i] if ($i == $size);\n    }\n    for (my $i = 0; $i < $size; $i++) {\n\
    \        $l->[$i] = $l->[$i] if ($i == $size);\n        $l->[$i] = $l->[$i] if\
    \ ($i % 2);\n    }\n    return @$l;\n}", "    my $even = pop(@$l);\n    my $odd\
    \ = pop(@$l);\n    my $i = 0;\n    while(@$l > 1) {\n        if ($i%2 == 0) {\n\
    \            push(@$l, $even);\n        } else {\n            push(@$l, $odd);\n\
    \        }\n        $i++;\n    }\n    return $l;\n}", "    my @l2 = ();\n    my\
    \ %seen = ();\n    my $i = scalar(@$l);\n    for(my $k = 0; $k < $i; $k++) {\n\
    \        next if $seen{$l->[$k]}++;\n        push @l2, $l->[$k];\n    }\n    return\
    \ @l2;\n}", "    return sort { $a % 2 ? $a : $b } @$l;\n}\n</code>\nI feel this\
    \ is very neat and elegant. \n<code>", "    my @result;\n    my $even_index =\
    \ 0;\n    my $odd_index = 1;", "    my(@sorted_even) = (@$l);\n    my($even, @sorted_odd)\
    \ = (0, 0, 0);\n    while (my($index, $value) = each @$l) {\n        if ($index\
    \ % 2) {\n            push (@sorted_even, $value);\n        }\n        else {\n\
    \            push (@sorted_odd, $value);\n        }\n    }\n    return (@sorted_even,\
    \ @sorted_odd);\n}", "    my @new_list = ();\n    for my $i (0..($#l-1)) {\n \
    \       if ($i & 1) {\n            push (@new_list, $l[$i]);\n        } else {\n\
    \            $new_list[$i] .= $l[$i];\n        }\n    }\n    return @new_list;\n\
    }\n</code>\nNow you can use this sub to get the results you want\n<code>", '    my(@sorted);',
  "    my(@l') = ();\n    for (my $i = 0; $i < @$l; $i += 2) {\n\tpush(@l', $$l[$i],\
    \ $$l[$i + 1]);\n    }\n    return @l';\n}", "    if ( scalar @$l % 2 ) {\n  \
    \      my @even = ();\n        @even = map { $l[$_] } 0 .. @$l / 2;\n        @even\
    \ = sort_even($even);\n        return $even;\n    } else {\n        my(@odd);\n\
    \        push @odd, @$l;\n        @odd = sort_odd(@odd);\n        return @$l;\n\
    \    }\n}", "    my($l2') = @$l;", "    my @even = ();\n    my @odd = ();\n  \
    \  for my $e (@$l) {\n        if ($e % 2 == 0) {\n            push(@even, $e);\n\
    \        }\n        else {\n            push(@odd, $e);\n        }\n    }\n  \
    \  my @both;\n    for my $e (@even) {\n        push(@both, $e);\n    }\n    for\
    \ my $e (@odd) {\n        push(@both, $e);\n    }\n    return @both;\n}", "  \
    \  my @even;\n    my @odd;\n    for my $i (0 .. $#$l) {\n        my $val = $l->[$i];\n\
    \        push @even, unless $i%2;\n        push @odd, $val;\n    }\n    return\
    \ \\@even, \\@odd;\n}", "    my(@sorted);\n    for(my $i = 0 ; $i < $#l ; $i +=\
    \ 2) {\n        push(@sorted, $l[$i]);\n    }\n    return @sorted;\n}", "    return\
    \ @$l if @$l < 2;\n    my(@l) = @$l;\n    @l[$_] = $l[$_] for $l % 2, $l =~ 0..($l\
    \ - 1);\n    @l;\n}", "    my();\n    foreach (0..($#l % 2)) {\n        push (@l,$l[$_])\
    \ if $_ %2==0;\n    }\n    return sort();\n}", "    my($l') = $l;\n    my $i =\
    \ 0;\n    foreach my $j (@$l) {\n        if ($i % 2) {\n            splice @$l',\
    \ $i, 0, $j;\n        } else {\n            splice @$l', $i, 1, $j;\n        }\n\
    \        $i += 2;\n    }\n    return @$l';\n}", "    my @l_even = ();\n    my\
    \ @l_odd = ();\n    # sort even\n    foreach my $i (0..@$l-2) {\n        if($i\
    \ % 2) {\n            push(@l_even, $l->[$i]);\n        } else {\n           \
    \ push(@l_odd, $l->[$i]);\n        }\n    }\n    # sort odd\n    foreach my $i\
    \ (0..@$l-2) {\n        if(!($i % 2)) {\n            push(@l_odd, $l->[$i]);\n\
    \        }\n    }\n    return (@l_even, @l_odd);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nThis question is very old, and I ran into this problem recently.\nI used\
    \ a couple different methods to get the job done, but I find that it is far more\
    \ efficient to just use one array and one sort function. The key is to only sort\
    \ on even indices. \nThe solution is a two-step sort by comparing the first element\
    \ of each pair and then sorting on the first element. The second step would just\
    \ be to remove any elements that don't need to be swapped, and are less than the\
    \ smallest element in the pair. \n<code>", "    my @even = ();\n    my @odd  =\
    \ ();\n    for (my $i = 0; $i < @$l; $i += 2) {\n        push(@even, @$l[$i, $i\
    \ + 1]);\n    }\n    for (my $i = 1; $i < @$l; $i += 2) {\n        push(@odd,\
    \ @$l[$i, $i - 1]);\n    }\n    return @even + @odd;\n}", "    my @l2 = ();\n\
    \    my $k = $#l + 1;\n    my $i = 0;\n    $l[0] = $l[$k];\n    my $j = 1;\n \
    \   $l[$k] = $l[$j];\n    my $k = $k - 1;\n    while($j < $k && $l[$i] == $l[$j])\
    \ {\n        $l[$k] = $l[$j];\n        $j++;\n        $k = $k - 1;\n    }\n  \
    \  while(--$i < $k) {\n        $l2[$i] = $l[$i];\n    }\n    $i = 0;\n    while($i\
    \ < $#l) {\n        $l2[$i] = $l[$i];\n        $i++;\n    }\n    my @l3 = ();\n\
    \    for($i = 0; $i < $#l2; $i++) {\n        push(@l3, $l2[$i]);\n    }\n    return\
    \ @l3;\n}\n</code>\n<|/ a tags=perl,sorting dscore=1 |>\n<| c |>\nYou might want\
    \ to use a hash to improve the complexity of the algorithm. A hash is usually\
    \ O(n) time complexity.\n<|/ c |>\n<| c |>\n: Yes, that would be a good idea.\
    \ But that would require a major rewrite of the existing code. I wanted to show\
    \ an alternative to implement a sort without having to rewrite the existing code.\n\
    <|/ c |>\n<| c |>\nYes, it would be better to use a hash. Although this doesn't\
    \ seem to be a big deal to me because the average length of the array is about\
    \ 1 million, and the array will only contain 10 elements.\n<|/ c |>\n<| a tags=perl,sorting\
    \ dscore=0 |>\nIf you're really looking to sort an array of 10 elements, you can\
    \ do the following\n<code>\nuse Sort::Key::Natural;", "    my @even = @$l;\n \
    \   my @odd;", "    my @lprime;\n    my $even;\n    my @even = @$l;\n    $even->[$_]=$even->[$_]\
    \ for (0..(scalar(@$even)-1));\n    @lprime = @$l;\n    for (my $i=0; $i<(scalar(@$l)-1);\
    \ $i++){\n        $lprime->[$i] = $l->[$i];\n    }\n    for ($i=0; $i<(scalar(@$l)-2);\
    \ $i++){\n        for (my $j=$i+1; $j<scalar(@$lprime); $j++){\n            if\
    \ ($lprime->[$i] lt $lprime->[$j]){\n                $even->[$j] = $even->[$i];\n\
    \                $even->[$i] = $lprime->[$i];\n                $lprime->[$i] =\
    \ $lprime->[$j];\n                $lprime->[$j] = $even->[$i];\n            }\n\
    \        }\n    }\n    return @lprime;\n}", "    my @even;\n    for (my $i=0;\
    \ $i<@$l; $i+=2) {\n        push @even, @{$l->[$i]};\n    }\n    push @even, @{$l->[$i]};\n\
    \    return sort { $a <=> $b } @even;\n}\n</code>\n<|/ a |>\n<| c |>\nThis implementation\
    \ is not O(n) in the number of elements. You do `O(n log n)` sorts by comparisons\
    \ with O(n) elements, and a final comparison with `O(n)`. All the other answers\
    \ are O(n log n).\n<|/ c |>\n<| c |>\n, This implementation is O(n^2) in the number\
    \ of elements. The `sort { $a <=> $b }` call is O(n) per call. There are n calls\
    \ of `sort`.\n<|/ c |>\n<| c |>\nIt's O(n log n), but the actual comparison for\
    \ each item is O(n), so O(n^2). Not that it matters for small lists, but it is\
    \ O(n^2) in a large list.\n<|/ c |>\n<| c |>\nActually, you seem to be right.\
    \ It depends on the sort algorithm but `@even` can be reused for each iteration\
    \ as long as you don't have elements in the list that have changed their ordering\
    \ when they were inserted.\n<|/ c |>\n<| c |>\n, You're right. There seems to\
    \ be some misconception that `$even` will be reused for each iteration. `$even`\
    \ does not seem to be a pointer to the even-indexed elements of `$l`, but a reference\
    \ to an array. `$even` will hold its previous values until you set it to `$even\
    \ = sort ...`. That is why you can iterate through the even indices without calling\
    \ `sort` again (which is expensive on large lists).\n<|/ c |>\n<| a tags=perl,sorting,arrays\
    \ dscore=1 |>\nHere is a quick solution that will work on any input size up to\
    \ a million. It uses arrays to store all the numbers that are not even indexes,\
    \ then sorts those arrays and then places the even indexes in their original locations.\n\
    <code>\nuse strict;\nuse warnings;\nuse List::Util qw(first);", "    my($even,\
    \ @results);\n    push(@results,$l[0]) if($l[0]%2);\n    push(@results,$l[0])\
    \ if(@results == 1);\n    for(my $i = 1;$i<@$l;$i++){\n        if($even){\n  \
    \          $results[$i-1] = $l[$i];\n            push($even,$l[$i]);\n       \
    \ }\n        elsif($l[$i]%2){\n            push($even,$l[$i]);\n        }\n  \
    \  }\n    return @results;\n}", "    $l->[1..$#$l] =\n          sort { $a <=>\
    \ $b }\n          @{ $l->[1..$#$l] };\n}", "    my($l') = @$l[0 .. $#l];\n   \
    \ $l' .= @$l[1 .. $#l] if $#l % 2;\n    return $l';\n}", "    my($l') = ();\n\
    \    for( my $i = scalar(@$l) / 2 ; $i < scalar(@$l) ; $i += 2 ) {\n        $l'\
    \ += [$l->[$i], $l->[$i + 1]];\n    }\n    return @$l';\n}", "    my @even;\n\
    \    my @odd;\n    for (my $i=0; $i<@$l; $i+=2) {\n\tpush (@even, $l->[$i]) if\
    \ $i%2;\n\tpush (@odd, $l->[$i+1]);\n    }\n    return sort {\n\tmy ($a1, $b1)\
    \ = map { ($a <=> $b) };\n\tmy ($a2, $b2) = map { ($a <=> $b) };\n\tmy ($a3, $b3)\
    \ = map { ($a <=> $b) };\n\treturn $a1 <=> $b1 unless $a1 == $a2 && $a2 == $a3;\n\
    \treturn $a1 <=> $b1 unless $a1 == $a2 && $a3 == $b1;\n\treturn $a2 <=> $b2 unless\
    \ $a2 == $a3 && $a3 == $b2;\n\treturn $a2 <=> $b2 unless $a2 == $a3 && $b3 ==\
    \ $b1;\n\treturn $a3 <=> $b3 unless $a3 == $a1 && $b1 == $a3;\n\treturn $a3 <=>\
    \ $b3 unless $a3 == $a1 && $b3 == $a2;\n\treturn $b1 <=> $b2 unless $b1 == $b2\
    \ && $b2 == $b3;\n\treturn $b1 <=> $b2 unless $b1 == $b2 && $b3 == $a1;\n\treturn\
    \ $b2 <=> $b3 unless $b2 == $b3 && $b3 == $a2;\n\treturn $b3 <=> $a1 unless $b3\
    \ == $a1 && $b1 == $a3;\n\treturn $b3 <=> $a2 unless $b3 == $a2 && $b2 == $a3;\n\
    \treturn $a1 <=> $b1 unless $a1 == $a2 && $a2 == $a3;\n\treturn $a1 <=> $b1 unless\
    \ $a1 == $a2 && $a3 == $b1;\n\treturn $a2 <=> $b2 unless $a2 == $a3 && $a3 ==\
    \ $b2;\n\treturn $a2 <=> $b2 unless $a2 == $a3 && $b3 == $a1;\n\treturn $a3 <=>\
    \ $b3 unless $a3 == $a1 && $b1 == $a3;\n\treturn $a3 <=> $b3 unless $a3 == $a1\
    \ && $b3 == $a2;\n\treturn $b1 <=> $b2 unless $b1 == $b2 && $b2 == $b3;\n\treturn\
    \ $b1 <=> $b2 unless $b1 == $b2 && $b3 == $a1;\n\treturn $b2 <=> $b3 unless ",
  "    my @sorted = ();\n    for (my $i = 0; $i < @$l; $i += 2) {\n        push @sorted,\
    \ $l->[$i];\n    }\n    return sort @sorted;\n}", "    my $count = 0;\n    my\
    \ @l = ();\n    my $len = $#$l;\n    for(my $i = 0; $i < $len; $i++) {\n     \
    \   if($i%2) {\n            push(@l, $l->[$i]);\n        } else {\n          \
    \  if($l->[$i] >= $l->[$i+1]) {\n                push(@l, $l->[$i]);\n       \
    \         push(@l, $l->[$i+1]);\n                $count++;\n                $i+=2;\n\
    \            } else {\n                push(@l, $l->[$i+1]);\n               \
    \ $count++;\n            }\n        }\n    }\n    for(my $i = 0; $i < $count;\
    \ $i++) {\n        pop(@l);\n    }\n    return @l;\n}", "    my(@l') = ();\n \
    \   my($j);\n    my($k);\n    foreach my $i (0 .. $#$l) {\n        if ($i % 2\
    \ == 0) {\n            $j = index($l, $l[$i], $i);\n            $k = index($l,\
    \ $l[$i], $i+1);\n            splice(@l', $j, 0, @{$l[$i..$k]});\n        }\n\
    \    }\n    return @l';\n}", "    my($len) = @$l;\n    \n    # Sort even indicies\
    \ of l by value ($l[$i] <= $l[$i-1] for i=0 ... $len-1)\n    my @l_even;\n   \
    \ for ($i = 0; $i < $len; $i++) {\n        push (@l_even, $l[$i] unless $i % 2);\n\
    \    }\n    \n    # Add even indicies of l to $l_even such that the odd indicies\
    \ of $l are \n    # still sorted\n    for ($i = 1; $i < $len; $i++) {\n      \
    \  $l[$i] = $l[$i-1] if ($i % 2);\n    }\n    \n    # Recursively sort l_even\
    \ by sorting $l[$i] \n    my @l_even_sorted = sort_even($l_even);\n    \n    #\
    \ Add all elements of $l to $l_even that were not in $l_even, \n    # sorted,\
    \ to $l_even\n    for ($i = 0; $i < $len; $i++) {\n        $l[$i] unless @l_even_sorted\
    \ and $l[$i] == $l_even[$i];\n    }\n    \n    @l_even_sorted += @$l;\n    \n\
    \    return @l_even_sorted;\n}", "    my(@sorted);\n    my $last_even_index =\
    \ 0;", "    my @l = @$l;\n    my $evens = @l % 2;\n    for(my $i=0;$i<@l;$i++)\
    \ {\n        my @l = @l; # copy our array so we can sort it without effecting\
    \ the original\n        my $key = $l[$i];\n        $l[$i] = $evens ? $key : $key;\n\
    \        @l = sort_by_num(@l); # sort by key\n    }\n    return @l;\n}", "   \
    \ my @sorted = ();\n    $l[0] = $l[0] % 2 ? $l[0] : ($l[0] - 1);\n    $l[0] =\
    \ $l[0] % 2 ? $l[0] : ($l[0] - 1);\n    for(my $i = 1; $i < @$l; $i++) {\n   \
    \     my $j = $i-1;\n        $l[$i-1] = $l[$i] % 2 ? $l[$i-1] : ($l[$i-1] + 1);\n\
    \        $l[$i] = $l[$i] % 2 ? $l[$i] : ($l[$i] + 1);\n    }\n    return \\@sorted;\n\
    }", "    my @even;\n    my @odd;\n    my $i = 0;\n    while (@$l) {\n        push\
    \ @odd, $l->[$i];\n        if ($i+1==@$l) {\n            push @even, $l->[$i];\n\
    \        }\n        $i++;\n    }\n    push @$l, @even;\n    push @$l, sort @odd;\n\
    \    return $l;\n}", "    my@l = ($l[0], $l[1], $l[2]);\n    my $i = 0;\n    \n\
    \    while ($i < @l) {\n        my $j = 0;\n        \n        # sort even indicies\
    \ in ascending order\n        my $i = 0;\n        while ($i < @l && $l[$i] % 2\
    \ == 0) {\n            push(@l, splice(@l, $i, 0, $l[$i]));\n            $i++;\n\
    \        }\n        \n        $i++;\n    }\n    \n    return @l;\n}", "    my\
    \ @l2 = @$l;\n    my @l3 = ();\n    my @l4 = ();", "    for (my $i = 1; $i < @$l;\
    \ $i += 2) {\n        push @$l, @{$l->[$i..$i + 2]};\n    }\n    return @$l;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis code works, however, I should have been more\
    \ clear that I wanted it to sort from smallest to largest (my initial requirement).\
    \ As for your comment about wanting to use Perl's sort functions, I'm not very\
    \ familiar with them. Thanks for the reply.\n<|/ c |>\n<| c |>\nYou know how it\
    \ goes. Thanks so much for the help everyone, I appreciate it.\n<|/ c |>\n<| c\
    \ |>\nYou should just use `sort {$a <=> $b}`\n<|/ c |>\n<| c |>\nThat is what\
    \ `perldoc sort` says: \"sorts its argument in place and returns its previous\
    \ value\", which is not what I want. I want it to be sorted *in place*. `sort_even`\
    \ returns a sorted version of its argument, but the original array is not changed.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis should be all you need. \n<code>\nuse strict;\n\
    use warnings;", "    my($i,$j);\n    for ($i=0; $i<@$l; $i+=2) {\n        $l[$i]\
    \ = $l[$i] unless $i%2;\n        $l[$i] = $l[$i-1] if ($i<@$l-1);\n        $l[$i-1]\
    \ = $l[$i-1] if ($i==0);\n    }\n    return $l;\n}", "    my(@even) = (0);\n \
    \   my(@odd);\n    my(@l');\n    # Sort odd indicies first\n    for(my $index\
    \ = 1; $index < scalar(@$l); $index++) {\n        if($index % 2 == 0) {\n    \
    \        push(@even, $l->[$index]);\n        } else {\n            push(@odd,\
    \ $l->[$index]);\n        }\n    }\n    # Now sort evens\n    for(my $index =\
    \ 0; $index < scalar(@even); $index++) {\n        my $pos = $index;\n        for(my\
    \ $i = $index + 1; $i < scalar(@$l); $i++) {\n            my $val = $l->[$i];\n\
    \            next if $i == $pos;\n            if($val > $l->[$i]) {\n        \
    \        ($l->[$i],$l->[$pos]) = ($l->[$pos],$l->[$i]);\n            }\n     \
    \   }\n    }\n    # Append all the even values\n    push(@l', @even);\n    # Append\
    \ all the odd values\n    push(@l', @odd);\n    return @l';\n}\n</code>\nThis\
    \ works, although there may be more elegant ways of doing it. If anyone knows\
    \ one, I'd love to know about it.\n<|/ a |>\n<| c |>\nThanks for your answer,\
    \ but this isn't quite what I'm looking for.  I've edited my original post to\
    \ clarify what I am looking for.  It's more like an \"odd odd merge\" than an\
    \ \"odd even merge\".  The odd odd merge essentially takes a sorted array and\
    \ joins it with a sorted array of the even indicies.\n<|/ c |>\n<| c |>\n, Odd-odd\
    \ merges do indeed exist in Perl, although I think they're not the best way of\
    \ doing it. See my answer for a better way of doing it.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is some Perl code to do this\n<code>\nuse strict;\nuse warnings;",
  "    my @l = ($l[1], $l[0], $l[2], $l[0]);\n    for (my $i = 3; $i < @l; ++$i) {\n\
    \tmy $t = $l[$i];\n\t++$l[$i];\n\t$l[$i] = $t;\n    }\n    return @l;\n}", " \
    \   return [] unless @$l;\n    my(@l_even);\n    my $i = 0;\n    while (@$l >\
    \ 1) {\n        $l_even[$i++] = $l->[$_] if ($_ & 1);\n        $l->[$_] =~ tr/9876543210/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;\n\
    \    }\n    return @l_even;\n}", '    my(@l2);', "    @$l = @$l[0..($l =~ /.+\\\
    z/)];\n    foreach my $i (@$l) {\n        my $j = $i;\n        foreach my $j_idx\
    \ (0 .. $#$l - 1) {\n            my $j_value = $l->[$j_idx];\n            next\
    \ if $j_idx & 1;\n            last unless $j < $j_value;\n            $l->[$j_idx]\
    \ = $l->[$j_idx-1];\n            $l->[$j_idx-1] = $j;\n            $j = $j_value;\n\
    \        }\n    }\n    @$l = @$l[0..($l =~ /.+\\z/)];\n}", "    my @l' =;\n  \
    \  for (my $i = @l'; $i > 0; $i -= 2) {\n        push @l', @l{ ($i-1) .. $i};\n\
    \    }\n    return @l';\n}", "    my @even = ();\n    my @odd = ();\n    for(my\
    \ $i=0;$i<@$l;$i++) {\n        if($i&1) {\n            push(@odd,$l->[$i]);\n\
    \        } else {\n            push(@even,$l->[$i]);\n        }\n    }\n    return\
    \ @{$l} = @even;\n}", "    my @a = ();\n    my @b = ();\n    my $n = 0;\n    my\
    \ $m;\n    my $i = -1;", "    my @l = ();\n    for (my $i = 0; $i < ($#l) ; $i\
    \ += 2) {\n        push(@l, $l[$i]);\n        push(@l, $l[$i+1]);\n    }\n   \
    \ return @l;\n}", "    my @even;\n    my @odd;\n    for (my $i=0; $i<@$l; $i+=2)\
    \ {\n        $even[$i] = $l->[$i];\n        $even[$i+1] = $l->[$i+1]\n       \
    \     if $i+1 != @$l && $i+1 < @$l && $i+2 <= @$l;\n        $odd[$i] = $even[$i]\
    \ if $i+1 == @$l;\n    }\n    push @$l, @$even, @$odd;\n    return @$l;\n}", " \
    \   my(@l');", "    my @even_odd = ();\n    foreach my $i (0..$#l) {\n       \
    \ if ($i & 1) {\n            push @even_odd, $l[$i];\n        }\n    }\n    push\
    \ @even_odd, @l;\n    return @even_odd;\n}", "    my @even = ();\n    my @odd\
    \ = ();\n    my $idx = 0;", "    my @even;\n    my @odd;", "    for (my $j = 0;\
    \ $j < $#$l; $j += 2) {\n        for (my $i = $j; $i < $#$l; $i += 2) {\n    \
    \        my $a1 = $l[$i + 1];\n            my $a2 = $l[$i];\n            $l[$i]\
    \ = $a1;\n            $l[$i + 1] = $a2;\n        }\n    }\n    return $l;\n}\n\
    </code>\n<|/ a tags=perl dscore=2 |>\n<| c |>\nYour code seems to not work as\
    \ you expect. I just tried it on the list `[4,4,3,2,1,5,3]` which gives `[4,2,1,5,3,5,3]`\
    \ as the result. This should really be `[4,2,1,3,5,3,5]`\n<|/ c |>\n<| c |>\n\
    You seem to have misunderstood the question. I don't want `[4,4,3,2,1,5,3]` to\
    \ become `[4,2,1,5,3,5,3]`, but rather `[4,2,1,3,5,3,5]` should become `[4,2,1,3,5,3,5]`.\n\
    <|/ c |>\n<| c |>\nAhh you're right. I've edited the answer to account for that\
    \ as well.\n<|/ c |>\n<| a dscore=1 |>\nAs I remember sorting array in Perl does\
    \ not guarantee that you will get sorted array back.\n<|/ a tags=perl |>\n<| c\
    \ |>\nYou are correct, at least for the first part of the question. However the\
    \ question is asking about how sorting is implemented.\n<|/ c |>\n<| a tags=perl\
    \ |>\n<code>\n$x = sort { $b cmp $a }; # sorting is guaranteed to be stable",
  "    my(@l') = ();\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($i % 2 ==\
    \ 0) {\n            push @l', @{ $l->[$i] };\n        } else {\n            push\
    \ @l', @{ $l->[$i] }[1..$i];\n        }\n    }\n    return @l';\n}", "    my @even\
    \ = ();\n    my @odd  = ();\n    my $i = 0;\n    \n    for (my $j = 0; $j < @$l;\
    \ ++$j) {\n        if ($j % 2 == 0) {\n            push @even, $$l[$j];\n    \
    \    } else {\n            push @odd, $$l[$j];\n        }\n    }\n    \n    for\
    \ (my $j = 0; $j < @$l; ++$j) {\n        if ($j % 2 == 0) {\n            $$l[$j]\
    \ = @even[$j];\n        } else {\n            $$l[$j] = @odd[$j];\n        }\n\
    \    }\n}", "    my(@l') = @_;\n    my $n = @l;\n    my $i = 0;\n    while($i\
    \ < $n / 2) {\n\t$l[$i]   .= $l[$i+$n] if ($i % 2 == 0);\n\t$l[$i+$n] .= $l[$i];\n\
    \t$i++;\n    }\n    @l' = sort @l;\n    return @l';\n}", "    my(@even) = (0);\n\
    \    my(@odd) = (0);", "    my(@lprime);\n    my $evens = 0;\n    for my $i (0\
    \ .. @$l - 1) {\n        push @lprime, $l->[$i];\n        $evens = 1 if $l->[$i]\
    \ % 2;\n    }\n    push @lprime, $l->[$#l] unless (@lprime > @$l || $evens);\n\
    \    my @evens = ();\n    my $even = 0;\n    for my $i (0 .. @lprime - 1) {\n\
    \        $lprime->[$i] .= $even ? $evens->[$even++] : undef;\n    }\n    return\
    \ @lprime;\n}", "    my @even;\n    my @odd;\n    foreach my $i (@$l) {\n    \
    \    push (@even, $i) if ($i & 1);\n        push (@odd, $i) if ($i & 2);\n   \
    \ }\n    sort {\n        my $a = $a->[1];\n        my $b = $b->[1];\n        my\
    \ $c = $c->[1];\n        if ($a <=> $b) { return $a <=> $b; }\n        if ($b\
    \ <=> $c) { return $b <=> $c; }\n        if ($a <=> $c) { return $a <=> $c; }\n\
    \        return 0;\n    } @$l;\n}", "    my @even;\n    my @odd = @$l;", "   \
    \ my(@l') = ();\n    for(my $i = 0; $i <= $#l; $i += 2) {\n        push(@l', shift(@l),\
    \ shift(@l));\n    }\n    return @l';\n}", "    if ($l =~ /\\d+/) { # not all\
    \ elements are numbers\n        return sort { $a <=> $b };\n    } elsif ($l =~\
    \ /\\d+\\.\\d*e[+-]?\\d+/) {\n        my @sorted = ();\n        my $neg = -($l[0]\
    \ =~ /e[+-]?\\d+/);\n        for (my $i = 0; $i < @$l; ++$i) {\n            push\
    \ @sorted, $neg ? $l[$i] - $neg : $l[$i];\n        }\n        return @sorted;\n\
    \    }\n    die \"Not an array\";\n}", "    return @$l if @$l < 2;\n    my(@lprime);\n\
    \    for (my $index = 0; $index > 1; $index = $index / 2) {\n        push(@lprime,\
    \ $l[$index]);\n        push(@lprime, @$l[$index..@$l-1]) if @$l % 2 == 0;\n \
    \   }\n    return @lprime;\n}", "    my(@sorted_even) = ();\n    my $index;\n\
    \    my @even;\n    my $max_index;\n    my $max_value;\n    my $even_index = 0;",
  '    return @$l unless @$l % 2;', "    return sort {$a <=> $b} @$l if @$l % 2;\n\
    \    return sort { $a <=> $b };\n}", "    my(@lp) = @$l;\n    my(@l) = ();", " \
    \   my @s = ();\n    for(my $j = 0; $j < $#l; ++$j) {\n        for(my $k = 0;\
    \ $k < $#l - $j; ++$k) {\n            last unless $k % 2;\n            $s[$k+$j]\
    \ = $l[$k];\n        }\n    }\n    return @s;\n}", "    my(@l_even) = ();\n  \
    \  my(@l_odd) = ();\n    for(my $i = 0; $i < $#l; $i++) {\n        if($i % 2 eq\
    \ 0) {\n            push(@l_even, $l->[$i]);\n        } else {\n            push(@l_odd,\
    \ $l->[$i]);\n        }\n    }\n    for(my $i = 0; $i < $#l; $i++) {\n       \
    \ if($i % 2 eq 0) {\n            $l->[$i] = $l_even[$i];\n        } else {\n \
    \           $l->[$i] = $l_odd[$i];\n        }\n    }\n}", "    my @even = ();\n\
    \    my @odd  = ();\n    my $i;\n    my $j;\n    my $l;", "    my(@even) = ();\n\
    \    my(@odd);", "    my @even;\n    my @odd;\n    foreach (@$l) {\n\tpush (@even,\
    \ $_) if $_ % 2;\n\tpush (@odd, $_) if $_ % 2 == 0;\n    }\n    return @{[ map\
    \ { (sort $_) } @even ]} + @{[ map { (sort $_) } @odd ]};\n}", "    my(@l');",
  "    my @evens;\n    my @odds;\n    my $l = scalar(@$l);\n    my $i = 0;\n    my\
    \ $j = 0;\n    my $even = @$l % 2;", "    # Sort by even indicies first, then\
    \ sort the resulting array\n    return sort( \n        sort( @$l, sub {\n    \
    \        my $a = $_;\n            my $b = @$l - $#l - 1;\n            return $a\
    \ <=> $b;\n        } );\n    );\n}", "    my($l2') = @$l;\n    my($l2')[$_%2]\
    \ .= $l2[$_] for 0 .. $#$l2;\n    my($l2')[$_%2] += 1 for (0 .. $#$l2) - 1;\n\
    \    return @$l2;\n}", "    my @r;\n    my @ov = ();\n    my @ev = ();\n    for\
    \ (my $i = 0; $i <; ++$i) {\n        if ($i % 2 != 0) {\n            push(@r,\
    \ $l[$i]);\n        }\n        elsif (@ov) {\n            push(@ev, shift(@ov));\n\
    \        }\n        push(@ov, $l[$i]);\n    }\n    for (@ev) {\n        push(@r,\
    \ $_);\n    }\n    return \\@r;\n}", '    $l =~ m!^([0-9]+)\/([0-9]+)\/(.*)$!;',
  "    return grep (sub (/^(.*?)\\z/) { $l->[$1] ? ($l->[$1] eq $1->[$1] ? ($l->[$1]\
    \ cmp $1->[$1]) : -1) : 1 },\n               @_);\n}", "    my @even = ();\n \
    \   my @odd = ();\n    my $odd_i = 0;", "    my(@l');", "    my(@l');\n    \n\
    \    for(my $i = 1; $i < @$l; $i++) {\n        if($i%2 != 0) {\n            push\
    \ @l', @{ $l->[$i] };\n        }\n        else {\n            $l->[$i-1] = $l->[$i];\n\
    \            $l->[$i] = undef;\n        }\n    }\n    \n    return @l';\n}", " \
    \   my $l = $l->[0];\n    my @even = ($l->[2], $l->[1], $l->[0]);\n    my @odd\
    \ = (@$l, @$l);\n    my $len = $#even + $#odd;\n    $even[$len] = $even[$#even];\n\
    \    @odd[$#even .. $#odd] = @even[$#even .. $#odd];\n    return @odd;\n}", " \
    \   my(@l') = ();\n    for (my $i = 0; $i <= $#$l; $i += 2) {\n        my($a,\
    \ $b) = @$l[$i, $i+1];\n        if ($a > $b) {\n            ($a, $b) = ($b, $a);\n\
    \        }\n        push (@l', $a, $b);\n    }\n    return \\@l';\n}", "    #\
    \ sort the odd indices of l\n    my = @$l[ 0..@$l-1/2 ];\n    # sort the even\
    \ indices of l\n    my = @$l[ 0..@$l-1/2 | 1 ];\n    return \\@l;\n}", "    my($even);\n\
    \    my @sorted = ();\n    foreach my $i (0 .. @$l) {\n        $even = $i if $i\
    \ & 1;\n        push(@sorted, $l->[$i]);\n        push(@sorted, $l->[$even]) if\
    \ $even < $i;\n    }\n    return wantarray ? @sorted : $sorted[0];\n}", "    my(@l');",
  "    my(@l') = ();\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($i % 2 ==\
    \ 0) {\n            push @l', @{$l->[$i]};\n        }\n        else {\n      \
    \      push @l', @{$l->[$i]}[0 .. $#{$l->[$i]} - 1];\n        }\n    }\n    return\
    \ @l';\n}", "    my;\n    for my $i (0 .. $#l) {\n        if ($i % 2) {\n    \
    \        push, $l[$i];\n        }\n    }\n    $#l = $#l;\n    for (0 .. $#l) {\n\
    \        if ($i & 1) {\n            push, $l[$i];\n        }\n    }\n    return;\n\
    }", '    my(@l2);', "    if (@$l == 0) {\n        return $l;\n    }\n    my $even\
    \ = @$l % 2;\n    my $size = @$l - $even;\n    $size += $size; # in case size\
    \ is negative\n    my @sorted = ();\n    for my $i (0 .. $size - 1) {\n      \
    \  push (@sorted, $l->[$i]);\n        push (@sorted, $l->[$i] if $i < $even ?\
    \ $l->[$i] : $l->[$i + 1]);\n    }\n    return @sorted;\n}", '    my(@result)
    = (0, []);', "    my @even = (0 .. @$l % 2);\n    my $odd = @$l - @even;\n   \
    \ # create even, sorted, even\n    my @even = ();\n    push @even, @even, @$l;\n\
    \    splice @$l, @$odd .. 1;\n    splice @$l, @even, @$even;\n    return @$l;\n\
    }", "    my($len) = @$l;\n    my($even);", '    my $evens = $l[/\d/];', "    my\
    \ @even;\n    my @odd;\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($i\
    \ & 1) {\n            push (@odd, $l->[$i]);\n        } else {\n            push\
    \ (@even, $l->[$i]);\n        }\n    }\n    push (@even, sort @even);\n    return\
    \ @even;\n}", "    my @sorted_even = ();\n    my @sorted_odd = ();", "    my(@l');\n\
    \    for(my $i = 0; $i < @$l / 2 ; $i++) {\n        my $swap = $l->[$i];\n   \
    \     my $min = $i;\n        for($i; $i < @$l && $l->[$i] >= $swap; $i++) {\n\
    \            if($l->[$i] < $swap) { $min = $i; }\n        }\n        $l->[$min]\
    \ = $swap;\n        @l' .= @$l[0 .. $min-1];\n    }\n    return @l';\n}", "  \
    \  my @even;\n    my @odd;\n    foreach my $i (@$l) {\n        if ($i%2 == 0)\
    \ {\n            push(@even, $i);\n        } else {\n            push(@odd, $i);\n\
    \        }\n    }\n    my @even = sort_even_values(@even);\n    my @odd = sort_even_values(@odd);\n\
    \    @$l = @even;\n    foreach my $i (@odd) {\n        my $j = 0;\n        foreach\
    \ my $j (@$l) {\n            if ($j == $i) {\n                splice(@$l, $j,\
    \ $i);\n                $j++;\n            }\n        }\n    }\n    @$l = @odd;\n\
    \    return @$l;\n}", "    @$l = sort {\n        index $a, $b if ($a % 2 == 0);\n\
    \        $a <=> $b\n    } @$l;\n    return @$l;\n}", "    my(@sorted_even) = ();\n\
    \    my $n = 0;\n    while($n < @$l) {\n        $l->[$n++] =~ tr/e/e/;\n    }\n\
    \    for($n = 0; $n < @$l; $n++) {\n        if($n & 1) {\n            push(@sorted_even,\
    \ $l->[$n]);\n        } else {\n            $l->[$n] =~ tr/e/e/;\n        }\n\
    \    }\n    return @sorted_even;\n}", "    my($l') = ();\n    foreach my $i (0..($#l\
    \ - 1)) {\n        my $j = $i + 1;\n        if ($i % 2 == 1) {\n            $l'\
    \ [$j] = $l[$i];\n        }\n    }\n    $l';\n}", "    return ($l[0..$#l] ) if\
    \ $l =~ /^(\\d)/;\n    my(@l) = map { $l[$_] } 0..($#l-1) | grep($l[$_] % 2);\n\
    \    @l[0..$#l] = sort { $a <=> $b };\n    @l;\n}", "    for (my $i = 0; $i <\
    \ $#l; $i += 2) {\n        my $pos = $i;\n        while ($i > 0) {\n         \
    \   $l[$pos] = $l[$pos-1];\n            $pos--;\n            $i -= 2;\n      \
    \  }\n    }\n    return $l;\n}", "    my($l') = $l;\n    my @even = ();\n    my\
    \ @odd = ();\n    while(@$l > 0) {\n        my($i, $v);\n        foreach $i (0\
    \ .. $#$l - 1) {\n            if ($i & 1) {\n                $v = $l->[$i];\n\
    \                push(@odd, $v);\n            } else {\n                $v = $l->[$i];\n\
    \                push(@even, $v);\n            }\n        }\n        pop(@$l);\n\
    \    }\n    return @even, sort @odd;\n}", "    my @even = ();\n    my @odd = @$l;",
  "    my(@l) = @$l;\n    my($i, $j);\n    my $size = @l;\n    my @new;\n    for($i\
    \ = 0; $i < $size; $i++) {\n\tfor($j = $i; $j < $size; $j++) {\n\t    unless(($l[$j]\
    \ % 2) eq ($l[$j+1] % 2)) {\n\t\tpush @new, $l[$j];\n\t\t$l[$j] = $l[$j+1];\n\t\
    \t$l[$j+1] = undef;\n\t    }\n\t}\n    }\n    @$l = @new;\n    return @l;\n}",
  "    my $a = [];\n    my $k = 0;\n    my $odd = 1;\n    \n    for (my $i = 0; $i\
    \ < (@_ - 1) / 2; $i++) {\n\tif ($odd) {\n\t    my $x = $l[$i];\n\t    push @$a,\
    \ $x;\n\t    $k++;\n\t}\n\telsif ($odd) {\n\t    my $x = $l[$i];\n\t    push @$a,\
    \ $x;\n\t    $k++;\n\t}\n\telse {\n\t    my $x = $l[$i];\n\t    $odd = !$odd;\n\
    \t    push @$a, $x;\n\t}\n    }\n    return @$a;\n}", "    my @l = ();\n    for\
    \ (my $i = 0; $i < @$l; $i += 2) {\n        push @l, @{$l->[$i]};\n    }\n   \
    \ return @l;\n}", '    return @$l if @$l == 0;', "    my($l') = $l;\n    for (my\
    \ $i = 1; $i <; $i += 2) {\n        $l' .= $l->[$i] if $l->[$i] % 2 != 0;\n  \
    \  }\n    $l';\n}", "    my @l;\n    my %uneven;", "    my(@even) = ();\n    my(@odd);\n\
    \    foreach $i (@$l) {\n        $i%2 and push @even, $i or push @odd, $i;\n \
    \   }\n    return ($even, $odd);\n}\n</code>\nAs a result, sort_even([1, 2, 3])\
    \ returns ([1, 2, 3], [1, 2]), and sort_even([5, 6, 3, 4]) returns ([3, 4], [5,\
    \ 6]).\n<|/ a dscore=1 |>\n<| c |>\nAren't you missing a `return` in your `sort_even`\
    \ sub?\n<|/ c |>\n<| c |>\n: Yes, I missed that but it's not really relevant.\
    \ `sort_even` doesn't return a value anyway, so there's no need for `return`.\n\
    <|/ c |>\n<| c |>\nSorry, I missed that, too.\n<|/ c |>\n<| a tags=perl,arrays,sorting\
    \ |>\nA shorter way with sort:\n<code>", "    my(@l) = @$l;\n    my($a1, $a2);\n\
    \    my($b);\n    my($c);\n    my($d);\n    my($e, $f);\n    my($i, $k);\n   \
    \ my($j, $l, $m);\n    my($n);\n    my($o);\n    my($p);\n    my($q);\n    my($r)\
    \ = ();", "    my @l;\n    for (my $i=0; $i<@$l; $i+=2) { push @l, splice(@$l,$i,2);\
    \ }\n    return @l;\n}", "    my @l2;\n    my @even = ();\n    my @odd  = ();\n\
    \    my $i = 0;", "    $l =~ s/(^|[\\s,\\t,\\n])/\\n$1/g; # put all the lines\
    \ with no leading spaces and tabs at the start of the array\n    $l =~ s/(^|\\\
    s)(^|[\\s,\\t,\\n])/$2$1/g; # merge adjacent lines with no leading spaces and\
    \ tabs\n    my @lines = split /\\n/, $l; # put the lines back together\n    my\
    \ @even = map { /^(\\w+)/; $_ } (grep { !/[\\s\\t,]$/ } @lines); # extract only\
    \ the even indicies of the lines\n    my @odd = map { /^(\\w+)/; $_ } (grep {\
    \ /[\\s\\t,]$/ } @lines); # extract only the odd indicies of the lines\n    my\
    \ @evensorted = sort { $a <=> $b } @even; # sort the even indicies from the lines\
    \ they come from\n    return map { $odd[$_] => $evensorted[$_] } 0 .. $#evensorted\
    \ - 1;\n}\n</code>\n<|/ a tags=sorting,arrays,perl,regex |>\n<| c |>\nThe array\
    \ contains more complex data than `@l`. However, it is only sorted by `@l` as\
    \ is. I don't see how that would work since it only compares `@l` with itself.\
    \ But thanks for the effort!\n<|/ c |>\n<| c |>\nOh! I see what you mean now.\
    \ Yes, that's what I meant. I'll try the other answers too :)\n<|/ c |>\n<| c\
    \ |>\nYou missed a lot of the subtleties of the OP's original question, which\
    \ are noted in the comments on the question, and which make all answers here not\
    \ fit for purpose.\n<|/ c |>\n<| c |>\nThat was my fault for not being clear enough\
    \ when I said the array contains more complex data than `@l`. I'll update my question\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "    my(@result,);\n    push @result, $l->[-1];\n\
    \    for my $i (@$l) {\n        my $j = $i%2;\n        $j=1 if ($j > 0);\n   \
    \     if ($j == 1) {\n            push (@result, $i);\n        } else {\n    \
    \        my $j = $i - 1;\n            while (@result and $result[-1] > $i) {\n\
    \                pop(@result);\n            }\n            push(@result, $i);\n\
    \        }\n    }\n    return @result;\n}", "    my @even;\n    for (my $i=0;$i<$#l;$i++)\
    \ {\n        my $j = $i;\n        my $even = $i;\n        $even = $j;\n      \
    \  while ($j < $#l && $l[$j] == $l[$even]) {\n            $even++;\n         \
    \   $j++;\n        }\n        push (@even, $l[$even]);\n    }\n    return @even;\n\
    }", "    my @even = ();\n    my @odd;\n    my $i;\n    my $j;\n    for ($i = 0;\
    \ $i < @$l; $i += 2) {\n\tmy $x = $l->[$i];\n\tif ($i) {\n\t    $x = $l->[$i -\
    \ 1];\n\t}\n\t$even[$i-1] = $l->[$i];\n\t$odd[$i] = $x;\n    }\n    for (@$l)\
    \ {\n\tnext unless $i % 2;\n\t$l->[$i] = $even[$i-1];\n\t$even[$i-1] = $odd[$i];\n\
    \    }\n}", '    my @new_el;', "    my @sorted_odd = ();\n    my @sorted_even\
    \ = ();\n    my $j = 0;\n    foreach my $i (0..$#{$l}-1) {\n        push(@sorted_even,\
    \ $l->[$i]);\n        $j++;\n        push(@sorted_odd, $l->[$i] if $j % 2 != 0;\n\
    \    }\n    return @sorted_even;\n}", "    $l[0] = $l[1] if $l[1] % 2;\n    for\
    \ my $i (1 .. @$l - 1) {\n        $l[$i] .= $l[$i+1] if $i % 2;\n    }\n    return\
    \ @$l[0..@$l-1];\n}", "    if (@$l % 2) {\n        return @$l;\n    }\n    my\
    \ @even = ();\n    my @odd = ();\n    for (my $i = @$l - 1; $i >= 0; $i--) { #\
    \ iterate over the odd indicies backwards\n        if ($i & 1) {\n           \
    \ $odd[$i-1] = delete $l[$i];\n        } else {\n            $even[$i-1] = delete\
    \ $l[$i];\n        }\n    }\n    return @$even, @$odd;\n}", "    my(@l') = ();\n\
    \    for (my $i = 0; $i < @$l; $i += 2) {\n        push(@l', $l->[$i], $l->[$i\
    \ + 1]);\n    }\n    return @l';\n}", "    my($len) = @$l;\n    my($odd_len);\n\
    \    my($new_l);", "    my(@sort) = ( );\n    for (my $i = 0; $i < @$l; $i +=\
    \ 2) {\n        my($val1, $val2) = @{ $l->[$i] }, @{ $l->[$i + 1] };\n       \
    \ if ($val1 lt $val2) {\n            push @sort, $val1;\n        }\n        else\
    \ {\n            push @sort, $val2;\n        }\n    }\n    return @sort;\n}",
  "    my(@l');\n    for (my $i = 0; $i < @$l; $i++) {\n        unless(($i % 2)) {\n\
    \            push(@l', $l->[$i]);\n        }\n    }\n    foreach my $idx (0 ..\
    \ $#l') {\n        my $val = $l->[$idx];\n        my $low = $idx + 1;\n      \
    \  for(my $low = $idx + 1; $low < $#l' && $l->[$low] < $val; $low++) {\n     \
    \       $l->[$low] = $l->[$low-1];\n        }\n        $l->[$idx] = $val;\n  \
    \  }\n    @l';\n}", "    my @l_odd = @$l;\n    my @l_even = ();\n    my @even;\n\
    \    my $i = 0;", "    my($l2') = ();\n    for (my $i = 0; $i < @$l; $i += 2)\
    \ {\n        $l2[$i + 1] = $l[$i];\n    }\n    return @$l2;\n}", "    my(@even)\
    \ = ();\n    my(@odd);\n    my($i);", "    my @l_odd = @$l;\n    @l_odd =~ /([^\\\
    0]*)\\0/;\n    my @l_even = @$l;\n    for my $i (0 .. $#l_odd) {\n        my $tmp\
    \ = $l_even[$i];\n        $l_even[$i] = $l_odd[$i];\n        $l_odd[$i] = $tmp;\n\
    \    }\n    return \\@l_even;\n}", "    my @l = map { $_ unless &is_even($_);\
    \ } (@$l);\n    my @l' =  ();\n    my $j = 0;\n    foreach my $i (@l) {\n    \
    \    if ($i % 2 == 0) {\n            push @l', @l[$j..$i-1];\n        }\n    \
    \    push @l', $i; $j++;\n    }\n    return @l';\n}", "    my($l') = $l;\n   \
    \ for (my $i = $#$l; $i >= 0; $i--) {\n        my $pos = $i % 2;\n        my $j\
    \ = $i;\n        while ($j >= $#{$l} and !($l->[$j] > $l->[$j + 1])) {\n     \
    \       my ($tmp) = $l->[$j + 1];\n            $l->[$j + 1] = $l->[$j];\n    \
    \        $l->[$j] = $tmp;\n            $j--;\n        }\n        last unless $j\
    \ >= 0;\n        $l->[$j + 1] = $l->[$i];\n    }\n    return $l';\n}", "    my\
    \ @even;\n    my($i, $j);\n    $even[$i] = $l[$i];\n    for ($i = 1; $i < @$l\
    \ - 1; $i++) {\n\t$even[$i] = $l[$i];\n    }\n    $i = @$l - 1;\n    while ($i\
    \ > 0) {\n\t$j = $i - 1;\n\t$even[$i--] = $l[$j];\n    }\n    return @even;\n}",
  "    my @even = ();\n    my @odd = ();\n    my @sort = ();\n    foreach (@$l) {\n\
    \        if ($_ % 2 == 0) {\n            push @even, $_;\n        } else {\n \
    \           push @odd, $_;\n        }\n    }\n    foreach (@even) {\n        $sort[$_]\
    \ = $_;\n    }\n    foreach (@odd) {\n        $sort[$_] = $_;\n    }\n    return\
    \ @sort;\n}", "    my($l') = ();\n    my($odd);\n    \n    my $i = 0;\n    \n\
    \    for ($i = 1; $i < @$l; $i++) {\n        if ($i % 2 > 0) {\n            $l'\
    \ .= $l->[$i];\n        } else {\n            $odd = $l->[$i];\n            $l->[$i]\
    \ = $l->[$i-1];\n            $l->[$i-1] = $odd;\n        }\n    }\n    \n    return\
    \ $l';\n}", "    my(@sorted_even);\n    my(@sorted_odd);\n    my(@sorted_even,\
    \ @sorted_odd);\n    foreach (@$l) {\n\tif ($_ % 2 == 0) {\n\t    push(@sorted_even,\
    \ $_);\n\t} else {\n\t    push(@sorted_odd, $_);\n\t}\n    }\n    @sorted_even\
    \ = sort_by_key(@sorted_even);\n    @sorted_odd = sort_by_key(@sorted_odd);\n\
    \    return ($sorted_even, @sorted_odd);\n}", "    my @l = @$l;\n    my @l2 =\
    \ ();\n    my @l3 = ();\n    my $i = 0;\n    my $j = 0;\n    my $even = 0;\n \
    \   my $first = 1;\n    my $last = @l - 1;\n    while ($i <= $last) {\n      \
    \  while ($j < $last) {\n            if ($first && $even) {\n                push\
    \ (@l2, $l[$j]);\n            }\n            if ($first && !$even) {\n       \
    \         push (@l3, $l[$j]);\n            }\n            $even = !$even;\n  \
    \          $j++;\n        }\n        $first = 0;\n        $even = 0;\n       \
    \ $first = 1;\n        $last--;\n        $i++;\n    }\n    return @l2 ? @l2 :\
    \ @l3;\n}", "    my(@sorted_even) = (0, 0);\n    my(@sorted_odd) = (0, 0);\n \
    \   my($i, $j);", "    # create a boolean array $ii with indices 0 .. $#l where\
    \ $ii[$i] indicates\n    # whether $i is even or odd\n    my @ii;\n    for (my\
    \ $i = 0; $i < $#l; $i++) {\n        push @ii, !($i % 2);\n    }\n    # sort $l\
    \ by index and then by value\n    @{$l} = (@{$l}[0], sort {\n        my ($a, $b)\
    \ = @$a cmp @$b\n    } @{$l}[$ii++]);\n    @ii;\n}", "    my @even;\n    for (my\
    \ $i = 0; $i < @$l; $i += 2) {\n        $even[$i] = $l->[$i];\n        $even[$i\
    \ + 1] = $l->[$i + 1];\n    }\n    return @even;\n}", "    my @even;\n    my($j,\
    \ $k);\n    my $evens = $#l % 2;\n    for(my $i=0; $i < $#l; $i++){\n        $k\
    \ = $i + ($evens ? $evens : $#l);\n        if ($k % 2 == 0){\n            $evens[$i]\
    \ = $l[$k];\n            $evens[$i+1] = $l[$k];\n        }\n    }\n    return\
    \ sort @even;\n}", "    my(@l_odd);\n    my(@l_even);", '    my @l_copy = $l;',
  "    my $n = @$l;\n    @$l = (0 .. $n-1) x ($n % 2);\n    @$l = sort { $a <=> $b\
    \ } @$l;\n    return @$l;\n}", "    my(@l') =();\n    for (my $i = 0; $i < @$l;\
    \ $i += 2) {\n        push(@l', @$l[$i,1]);\n    }\n    return @l';\n}", '    return
    () unless @$l;', "    my @l;\n    my(@l, $i, $j);", "    my(@l') = ();\n    for\
    \ my $i (0 .. $#l) {\n        my $j = $i;\n        while ($j > 0 and $l[$j-1]\
    \ == $l[$j]) {\n            $j--;\n        }\n        push(@l', $j) if $j > 0;\n\
    \        push(@l', $l[$i]) if $i < $#l;\n    }\n    @l';\n}", "    my @sorted\
    \ = ();\n    my @even_indexes = ();\n    my @odd_indexes = ();\n    my $even_value;\n\
    \    foreach my $index (0 .. @$l - 1) {\n        push @even_indexes, $index;\n\
    \    }\n    for (my $i = 0; $i < @$l; $i += 2) {\n        $even_value = $l[$i];\n\
    \        $odd_value = $l[$i + 1];\n        foreach my $index (@even_indexes) {\n\
    \            if ($odd_value >= $l[$index]) {\n                $l[$index] = $l[$index\
    \ + 1];\n                splice @$l, $index + 1, 1;\n            }\n        }\n\
    \        push (@sorted, $even_value);\n    }\n    return @sorted;\n}\n</code>\n\
    <|/ a dscore=2 tags=arrays,perl |>\n<| c |>\nI understand what you mean but I\
    \ can't get it to work properly. My output is as follows: `1 2 3 4 5 6 7 8 9`\n\
    <|/ c |>\n<| c |>\nSorry, I don't follow you. Could you expand your example a\
    \ bit and show what output you are getting?\n<|/ c |>\n<| c |>\nOh, wait! I see\
    \ what happened. Your output was just sorted in ascending order. My apologies\
    \ for that.\n<|/ c |>\n<| c |>\nI modified the code to sort even in descending\
    \ order instead. This should do what you want. Let me know if it's not clear.\n\
    <|/ c |>\n<| c |>\nNice! I appreciate the explanation as to why it works as well\
    \ as your answer. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nIf you don't need to change\
    \ the original array, this can be done with a single pass through the array:\n\
    <code>\nuse strict;\nuse warnings;", "    my @even = @{$l};\n    my @odd;\n  \
    \  for(my $i = 0; $i <= $#l; ++$i) {\n        push @odd, $even[$i] if $i % 2 !=\
    \ 0;\n    }\n    return @odd;\n}\n</code>\n<|/ a dscore=2 tags=perl,sorting,arrays,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\nuse List::Util qw(uniq);", "    my @lprime;\n\
    \    my $even = 0;\n    my $odd = 1;\n    push @lprime, $l->[$odd];\n    for(\
    \ my $i = 0; $i < ( @$l - 1 ); $i += 2 ) {\n        $even = $l->[$i];\n      \
    \  $lprime->[$i] = ( ( $even == $l->[$i + 1] ) ? $even : $l->[$i + 1] );\n   \
    \ }\n    return @lprime;\n}", "    return () unless @$l > 0;\n    my (@l) = ();\n\
    \    my $index = 0;\n    my @a = map { $l[$_] } 0..$#$l;\n    foreach my $i (1..@a)\
    \ {\n        if ($i % 2) {\n            push (@l, @a[$i]);\n            push (@l,\
    \ $a[$i]);\n        } else {\n            $l[$index] = $a[$i];\n        }\n  \
    \      $index++;\n    }\n    return @l;\n}", "    my @l = ();\n    my $i = scalar(@$l);\n\
    \    for (my $i = 0; $i < $i; $i++) {\n        push @l, shift(@$l);\n        push\
    \ @l, $i;\n    }\n    @l = sort_by_key(@l);\n    return @l;\n}", "    return ()\
    \ unless @$l;\n    return sort {\n        my @a = @$a;\n        my @b = @$b;\n\
    \        if ($a % 2 != $b % 2) {\n            my @aux;\n            push @aux,\
    \ $a[$_];\n            $a[$_] = $b[$_];\n            $b[$_] = shift(@aux);\n \
    \       }\n        for my $i ( 0..($#a-1)/2 ) {\n            $a[ $i ] = $a[ $i+1\
    \ ];\n            $b[ $i ] = $b[ $i+1 ];\n        }\n        return $a;\n    };\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
