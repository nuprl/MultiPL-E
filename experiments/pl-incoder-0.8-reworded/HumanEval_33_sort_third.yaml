name: HumanEval_33_sort_third
language: pl
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the indicies that are not divisible by three, while its values\
  \ at the indicies that are divisible by three are equal\n# to the values of the\
  \ corresponding indicies of l, but sorted.\n# >>> sort_third([1, 2, 3])\n# [1, 2,\
  \ 3]\n# >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\nsub sort_third\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_third;\n\
  \        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5])) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 9, 4, 8, 3,\
  \ 2]),[2, 6, 9, 4, 8, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3,\
  \ 4, 8, 9, 5, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  }\n\ntesthumaneval();"
completions: ["    my @sorted = ();\n    my $i = 0;\n    my $j = 0;\n    for (my $n\
    \ = 0; $n < @$l; $n++) {\n        if ($n % 3 == 0) {\n            $sorted[$i]\
    \ = $l->[$n];\n            $i++;\n        }\n    }", "    # find indicies of l\
    \ that are divisible by three\n    my @indicies;\n    for my $i (0..$#l) {\n \
    \       if (($i % 3) == 0) {\n            push @indicies, $i;\n        }\n   \
    \ }\n    # sort indicies from smallest to largest\n    sort(@indicies);\n    \n\
    \    # copy l into a temporary array\n    my @temp = $l;\n    # assign values\
    \ from l\n    for my $i (0..$#temp) {\n        $temp[$indicies[$i]] = $l[$i];\n\
    \    }\n    # copy values from temporary into l\n    for (my $j = 0; $j < $#indicies;\
    \ $j++) {\n        $l[$indicies[$j]] = $temp[$j];\n    }\n    return $l;\n}",
  "    $l =~ tr/3/3/;\n    my @l = sort {\n        my $a = $a->[$_] // $b;\n     \
    \   my $b = $b->[$_] // $a;\n        $a <=> $b\n    } @$l;\n    @$l = map { $_->[0]\
    \ } @l;\n    return @$l;\n}", "    my(@l2) = ();\n    my($i);\n    my(@l3) = ();",
  "    my(@l2) = ();\n    my($k);\n    foreach $k (keys %$l) {\n        push (@l2,\
    \ $l->{$k}) if ($l->{$k} % 3 != 0);\n        push (@l2, $l->{$k}) if (($l->{$k}\
    \ % 3 == 0) && $l->{$k} < $l->{($k + 3)});\n    }\n    @l2 = sort {(($b % 3 ==\
    \ 0) && ($a % 3 == 0)) ? $a <=> $b : (($a % 3 != 0) && ($b % 3 != 0)) ? $a <=>\
    \ $b : $a cmp $b} @l2;\n    return @l2;\n}", "    my($lcopy, $lcopycopy);\n  \
    \  my($lcopycopy);\n    my($lcopycopycopy, $lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy, $lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy, $lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy, $lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy, $lcopycopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy,\
    \ $lcopycopycopycopy);\n    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy, $lcopycopycopycopy);\n\
    \    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopycopy,\
    \ $lcopycopycopycopy);\n    my($lcopycopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy, $lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy);\n    my($lcopycopycopycopy, $lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy, $lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy, $lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n    my($lcopycopycopycopy);\n\
    \    my($lcopycopycopycopy);\n", '    my(@lprime) = (@_ == 1 ? [@$l] : @_);',
  "    return @$l unless @$l > 0;\n    # sort with third smallest indicies first\n\
    \    my $i = 0;\n    @$l = sort { $a <=> $b } @$l;\n    while (@$l > $i && @$l\
    \ > 3 / $i) {\n        if ($l[$i] % 3 != 0) {\n            splice @$l, $i, 0,\
    \ $l[$i];\n        }\n        $i++;\n    }\n    # copy to original array\n   \
    \ @$l = @$l[0..$i-1];\n    return @$l;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\n\
    You might want to add `no warnings 'uninitialized';` after the use of `sort` to\
    \ make sure you get all the warnings you expect and that they have not been disabled.\n\
    <|/ c |>\n<| a dscore=1 tags=perl |>\n<code>\nuse strict;\nuse warnings;\nuse\
    \ 5.010;\nuse List::MoreUtils qw(uniq);\nuse List::MoreUtils qw(pairs);", "  \
    \  my(@l') = ();", "    my @l2 = ();\n    my @l3 = ();\n    my $max = 0;\n   \
    \ \n    foreach my $i (0..$#l) {\n        if($i % 3 == 0) {\n            push(@l2,\
    \ $l[$i]);\n        } elsif($i % 3 == 1) {\n            push(@l3, $l[$i]);\n \
    \       } elsif($i % 3 == 2) {\n            push(@l2, $l[$i]);\n            push(@l3,\
    \ $l[$i]);\n        } elsif($i % 3 == 0) {\n            push(@l3, $l[$i]);\n \
    \       }\n        $max = max([$max, $l[$i]]);\n    }\n    \n    foreach my $i\
    \ (0..$#l2) {\n        if($l[$i] >= $max / 3) {\n            push(@l, $l[$i]);\n\
    \        }\n    }\n    \n    foreach my $i (0..$#l3) {\n        if($l[$i] >= $max\
    \ / 3) {\n            push(@l, $l[$i]);\n        }\n    }\n    return @l;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nHi, thanks for your reply! I made a slight modification\
    \ to your code because it would not work with the input in the question above\
    \ (the code didn't like the fact that there were multiple pairs of '3' values).\
    \ Also, I removed the second foreach because I didn't need the third list any\
    \ more so I left out the foreach for sorting and I just returned the array instead.\n\
    <|/ c |>\n<| c |>\nGlad you got it working, and thanks for pointing that out.\
    \ :) I updated my answer with the correct code (and corrected the problem with\
    \ multiple 3's). Thanks again!\n<|/ c |>\n<| c |>\nThanks for the update, it was\
    \ very helpful! I was also curious as to how I might implement this algorithm\
    \ to find all the pairs of 3's. Would that be easier than the one I currently\
    \ have?\n<|/ c |>\n<| c |>\nYeah that would be much easier! I'll update my answer\
    \ with that (in a minute).\n<|/ c |>\n<| c |>\nI edited my answer. Let me know\
    \ if that helps :)\n<|/ c |>\n<| a dscore=1 |>\nHere is another solution which\
    \ builds up a set of all permutations (the way you had it originally), and then\
    \ does a check of each permutation if the set contains a 3-element subsequence.\
    \ One thing though, it only works on sequences of length three.\n<code>", "  \
    \  my (@l') = ();", "    my(@results);\n    my(@third);", "    my(@l');\n    my($i,$j);\n\
    \    $i = 0;\n    $j = 1;\n    foreach $val (@$l) {\n        while ($j < ($#l)\
    \ and $l[$j] % 3 != 0) {\n            push (@l', $l[$j]);\n            $j++;\n\
    \        }\n        push (@l', $val);\n        $i++;\n        $j++;\n    }\n \
    \   return @l';\n}", "    my(@lprime);\n    for (my $i=0; $i < @$l; $i+=3) {\n\
    \        push(@lprime, @{$l->[$i..($i+3)]});\n    }\n    return @lprime;\n}",
  "    my($l2') = [];\n    my(@l3') = ();\n    \n    foreach my $i ( @$l ) {\n   \
    \     if ( $i % 3 != 0 ) {\n            $l2[$i] = $i;\n        } else {\n    \
    \        push @l3, $i;\n        }\n    }\n    \n    foreach my $i ( @l3 ) {\n\
    \        $l2[$i] = $l[--$i];\n    }\n    \n    return @l2;\n}", "    my $len \
    \   = @$l;\n    my $l3     = @$l / 3;\n    my @l_new;\n    for (my $i=0; $i<$l3;\
    \ $i++) {\n        my $third  = @$l % 3;\n        my $third3 = $third + $i;\n\
    \        $l_new[$i] = (defined($l3[$i]) ? $l3[$i] : $third3)  unless $third3 ==\
    \ $i;\n    }\n    for ($i=0; $i<$len; $i++) {\n        my $third3 = @$l_new[$i];\n\
    \        my $l3     = $l3[$i];\n        if ($third3 == $i) {\n            $l_new[$i]\
    \ = $l3[$i];\n        } else {\n            my $third = @$l % 3;\n           \
    \ my $pos    = $third3;\n            my $j      = $third3;\n            for (my\
    \ $j=$i; $j<$len; $j++) {\n                my $l3 = $l3[$j];\n               \
    \ if ($l3 == $i) {\n                    $l3[$j] = $l3;\n                    $pos--;\n\
    \                }\n                $l_new[$j] = $l3;\n            }\n       \
    \     $l_new[$i] = $l3[$pos];\n        }\n    }\n    @$l = @$l_new;\n}", "   \
    \ return grep { !(divisible_by_three($_)) } @$l unless @$l;\n    my $len = @$l;\n\
    \    my @l = (@$l);\n    my @l2 = ();\n    for (my $i = 0 ; $i < $len ; $i++)\
    \ {\n        push (@l2, $l[$i] if divisible_by_three($l[$i]));\n        push (@l2,\
    \ $l[$i] if $l[$i] == $l[$i] % 3);\n    }\n    return @l2;\n}", "    @$l = (sort\
    \ { $a <=> $b } @$l);\n    @$l = (@$l[0 .. $#l / 3 - 1] + [@$l[$#l / 3 .. $#l]]);\n\
    \    return @$l;\n}\n</code>\n<|/ a tags=arrays,perl,sorting |>\n<| c |>\nThanks\
    \ for your answer, but your solution doesn't work with non-numeric elements. I\
    \ should have mentioned that. I've edited my question.\n<|/ c |>\n<| c |>\nI figured\
    \ it out and posted my own answer, which works correctly for numeric elements.\n\
    <|/ c |>\n<| c |>\nI added a solution that will work with any type.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nmy = qw(3 6 8 4 6 8 2 1 7);\nmy;\nmy $counter = 0;\n\
    for (@array) {\n   push, $counter += $_ ? 1 : -1;\n   last unless $counter % 3\
    \ == 0;\n}", "    my($l') = $l;\n    my %hash;\n    for my $i (0 .. $#l) {\n \
    \       my $k = ($i % 3);\n        if (!$hash{$k}) {\n            $hash{$k} =\
    \ [];\n        }\n        $hash{$k}->[$i] = $l;\n    }\n    for my $k (sort {$a\
    \ <=> $b} keys %hash) {\n        $l' += $hash{$k};\n    }\n    return @$l';\n}",
  "    my @l2 = ();\n    my($l3) = $l % 3;\n    foreach my $i (@$l) {\n        push\
    \ @l2, $i if $i % 3 != $l3;\n    }\n    return @l2;\n}", "    my($l2') = (@$l);\n\
    \    my @result;\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($i % 3 ==\
    \ 0) {\n            for ($i; $i < @$l && $i % 3 == 0; $i++) {\n              \
    \  push @result, $l2[$i];\n            }\n        }\n    }\n    my @l3;\n    foreach\
    \ my $i ( @$l2) {\n        push @l3, $i;\n    }\n    foreach my $i ( @l3) {\n\
    \        foreach my $j (@l3) {\n            if ($i == $j) {\n                splice\
    \ @l3, $i, 1;\n            }\n        }\n    }\n    return @result;\n}", "   \
    \ my @l2 = map { $_ } @$l;\n    my @sorted_third_indicies = map { $_ / ( $_ %\
    \ 3 ) } @l2;\n    my @sorted_third_indicies_values;\n    my $i = 0;\n    for (\
    \ @sorted_third_indicies ) {\n        $sorted_third_indicies_values[ $i++ ] =\
    \ $l2[ $_ ];\n    }\n    sort { $a <=> $b } @sorted_third_indicies_values;\n \
    \   return map { @$sorted_third_indicies_values[@$_] } @l2;\n}", "    my(@lprime);\n\
    \    my(@lprime_sorted);\n    my($lprime_length);", '    my(@lprime);', "    my(@l)\
    \ = $l;\n    my(@l') = ();", "    my @l = @$l;\n    my @l2 = ();\n    my @l3 =\
    \ ();\n    my %count_3 = ();", "    my @l = @$l;\n    my @l2 = ();\n    my @l3\
    \ = ();", "    return @$l if @$l < 3;\n    my($l', @t);\n    for(my $i=0; $i<@$l;\
    \ ++$i) {\n        if($i%3 != 0) {\n            push(@t, $l->[$i]);\n        }\
    \ else {\n            $l->[$i] = $t[$i];\n        }\n    }\n    return @$l;\n}",
  "    my @l_sorted = sort {\n        my $l1 = $_;\n        my $l2 = $_;\n       \
    \ my $i;\n        for (0 .. $#l) {\n            $i = ($l1[$_] % 3) == ($l2[$_]\
    \ % 3) ? $_ : next;\n            if ($l1[$_] != $l2[$_]) {\n                return\
    \ $l1[$_] > $l2[$_] ? 1 : -1;\n            }\n        }\n        $l1[$i] <=> $l2[$i];\n\
    \    };\n    return @l_sorted;\n}", "    my($l1') = @$l[0..$#l];\n    my($l2')\
    \ = @$l1[1..$#l1];\n    my($l3') = @$l2[1..$#l2];\n    my(@l3') = sort { $a <=>\
    \ $b } @$l3;\n    \n    @l3 = map  { $_ = $_; $_ & 3 ? $l3[$_] : undef } 0..$#l3;\n\
    \    \n    @$l1 = @l3;\n    @$l2 = @l3;\n    @$l3 = @l3;\n    \n    wantarray\
    \ ? @l3 : $l3;\n}", "    my (@sorted_l, $l_index);\n    my $length = @$l;\n  \
    \  my $l_index_count = 0;\n    for (my $i = 0; $i < $length; $i++) {\n       \
    \ if ($l_index[$i] % 3 == 0) {\n            $l_index_count++;\n            $l_index[$i]\
    \ = $l_index_count;\n            $l_index[$i] =~ s/^0/0/;\n        }\n       \
    \ elsif ($l_index[$i] % 3 == 1) {\n            $l_index[$i] += 1;\n        }\n\
    \        else {\n            $l_index[$i] += 2;\n        }\n        push(@sorted_l,\
    \ $l[$i]);\n    }\n    return @sorted_l;\n}", "    my(@l') = (@l);\n    my $divisible\
    \ = 3;\n    my $divisible2 = 0;\n    my $i = 0;\n    my $j = 0;\n    my $tmp;\n\
    \    while (@l' > 1) {\n        my $tmp = $l'[$i];\n        $l'[$i] = $l'[$j];\n\
    \        $l'[$j] = $tmp;\n        if ($i && $i % $divisible == 0 && $j % $divisible\
    \ == 0) {\n            $divisible2++;\n        }\n        $i++;\n        $j++;\n\
    \    }\n    @l' =~ sort { $a <=> $b } @l';\n    if ($divisible2) {\n        for\
    \ (my $k = 0; $k < $divisible2; $k++) {\n            my $tmp = $l'[$k];\n    \
    \        $l'[$k] = $l'[$k + $divisible2];\n            $l'[$k + $divisible2] =\
    \ $tmp;\n        }\n    }\n    return @l';\n}", "    my($l3') = @$l;\n    my($j);\n\
    \    $l3[0] = $l3[1] = $l3[2] = $l3[3] = $l3[4] = $l3[5] = $l3[6] = $l3[7] = $l3[8]\
    \ = $l3[9] = $l3[10] = $l3[11] = $l3[12] = $l3[13] = $l3[14] = $l3[15] = $l3[16]\
    \ = $l3[17] = $l3[18] = $l3[19] = $l3[20] = $l3[21] = $l3[22] = $l3[23] = $l3[24]\
    \ = $l3[25] = $l3[26] = $l3[27] = $l3[28] = $l3[29] = $l3[30] = $l3[31] = $l3[32]\
    \ = $l3[33] = $l3[34] = $l3[35] = $l3[36] = $l3[37] = $l3[38] = $l3[39] = $l3[40]\
    \ = $l3[41] = $l3[42] = $l3[43] = $l3[44] = $l3[45] = $l3[46] = $l3[47] = $l3[48]\
    \ = $l3[49] = $l3[50] = $l3[51] = $l3[52] = $l3[53] = $l3[54] = $l3[55] = $l3[56]\
    \ = $l3[57] = $l3[58] = $l3[59] = $l3[60] = $l3[61] = $l3[62] = $l3[63] = $l3[64]\
    \ = $l3[65] = $l3[66] = $l3[67] = $l3[68] = $l3[69] = $l3[70] = $l3[71] = $l3[72]\
    \ = $l3[73] = $l3[74] = $l3[75] = $l3[76] = $l3[77] = $l3[78] = $l3[79] = $l3[80]\
    \ = $l3[81] = $l3[82] = $l3[83] = $l3[84] = $l3[85] = $l3[86] = $l3[", '    my;',
  "    my(@l2') = ();\n    foreach my $i (0 .. @$l) {\n        if ($i % 3 == 0) {\n\
    \            @l2 += @$l;\n        }\n        elsif ($i % 3 == 1) {\n         \
    \   @l2 += @$l;\n        }\n        else {\n            @l2 += @$l;\n        }\n\
    \    }\n    return @l2;\n}", "    my($l');\n    my(@l');", "    my($l1, $l2, $l3)\
    \ = @_;\n    my(@l4, @l5, @l6, @l7);\n    push(@l4, @{$l[0]});\n    push(@l4,\
    \ @{$l[1]});\n    push(@l4, @{$l[2]});\n    push(@l4, @{$l[3]});\n    push(@l4,\
    \ @{$l[4]});\n    push(@l4, @{$l[5]});\n    push(@l4, @{$l[6]});\n    push(@l4,\
    \ @{$l[7]});\n    push(@l4, @{$l[8]});\n    push(@l4, @{$l[9]});\n    push(@l4,\
    \ @{$l[10]});\n    push(@l4, @{$l[11]});\n    push(@l4, @{$l[12]});\n    push(@l4,\
    \ @{$l[13]});\n    push(@l4, @{$l[14]});\n    push(@l4, @{$l[15]});\n    push(@l4,\
    \ @{$l[16]});\n    push(@l4, @{$l[17]});\n    push(@l4, @{$l[18]});\n    push(@l4,\
    \ @{$l[19]});\n    push(@l4, @{$l[20]});\n    push(@l4, @{$l[21]});\n    push(@l4,\
    \ @{$l[22]});\n    push(@l4, @{$l[23]});\n    push(@l4, @{$l[24]});\n    push(@l4,\
    \ @{$l[25]});\n    push(@l4, @{$l[26]});\n    push(@l4, @{$l[27]});\n    push(@l4,\
    \ @{$l[28]});\n    push(@l4, @{$l[29]});\n    push(@l4, @{$l[30]});\n    push(@l4,\
    \ @{$l[31]});\n    push(@l4, @{$l[32]});\n    push(@l4, @{$l[33]});\n    push(@l4,\
    \ @{$l[34]});\n    push(@l4, @{$l[35]});\n    push(@l4, @{$l[36]});\n    push(@l4,\
    \ @{$l[37]});\n    push(@l4, @{$l[", "    my @l1 = @$l;\n    my $i = 0;\n    my\
    \ @l2 = ();\n    my $j = 0;\n    my $k = 0;\n    my $count = 0;\n    while ($i\
    \ <= $#l1) {\n        $count++;\n        if ($count > 3) {\n            push @l2,\
    \ $l1[$i];\n        } else {\n            push @l2, $l1[$i];\n        }\n    \
    \    if ($count % 3 == 0) {\n            push @l2, $l1[$j];\n            $j++;\n\
    \        }\n        $i++;\n    }\n    return @l2;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nSorry, but that will not work with my needs. I didn't give any\
    \ specific details in my original question, but my original sorting algorithm\
    \ is already working correctly - my problem is with the sorting of the array at\
    \ the end\n<|/ c |>\n<| c |>\nI have updated my question. Sorry for the confusion\n\
    <|/ c |>\n<| c |>\n: I didn't understand the sorting algorithm (I thought I understood\
    \ it but then changed my mind), but I updated my answer, including a working example.\n\
    <|/ c |>\n<| c |>\nAh thank you so much! I didn't know you could do that with\
    \ push! You are the best! :)\n<|/ c |>\n<| a tags=perl,arrays |>\n<code>\nuse\
    \ strict;\nuse warnings;\nuse Data::Dumper;", "    # find the indicies where they\
    \ are divisible by three\n    my = grep { $_ % 3 } 0..($#l - 1);\n    # sort them\
    \ so the divisible ones are next to each other\n    @l[@indicies] = sort { $a\
    \ <=> $b } @l[@indicies];\n    return;\n}", "    my @new_l;\n    my $temp;\n \
    \   my $index;\n    for(my $i=0; $i<@$l; $i++) {\n        $index = ($i%3 == 0)\
    \ ? ($i/3) :($i/3 - 1);\n        $temp = $l->[$i];\n        $l->[$i] = $l->[$index];\n\
    \        $l->[$index] = $temp;\n    }\n    return @new_l;\n}", "    my(@lprime);\n\
    \    my($lprime);\n    my(@t);\n    my(@lprime);\n    my($i);\n    my($j);\n \
    \   my($l);\n    my($lprime);\n    my($k);\n    \n    foreach $l (@l) {\n    \
    \    if ($l % 3 == 0) {\n            push(@lprime, $l);\n        }\n    }\n  \
    \  foreach $lprime (@lprime) {\n        push (@t, $lprime);\n    }\n    @lprime\
    \ = sort { $a <=> $b } @t;\n    \n    foreach $lprime (@lprime) {\n        $lprime\
    \ = intdiv($lprime, 3);\n        push (@lprime, $lprime);\n    }\n    foreach\
    \ $lprime (@lprime) {\n        $lprime = intdiv($lprime, 3);\n        push (@lprime,\
    \ $lprime);\n    }\n    @lprime = sort { $a <=> $b } @t;\n    \n    foreach $lprime\
    \ (@lprime) {\n        $lprime = intdiv($lprime, 3);\n        push (@lprime, $lprime);\n\
    \    }\n    \n    return @lprime;\n}", '    my($lprime) = @_;', "    my @new_l\
    \ = ();\n    \n    my $i = 0;\n    while ($i < @$l) {\n        my $j = 0;\n  \
    \      while ($j < $#{$l} && $j != $i) {\n            if ($l->[$j] % 3 == 0) {\n\
    \                push (@new_l, @$l, $l->[$j]);\n                $j++;\n      \
    \      }\n            else {\n                $j++;\n            }\n        }\n\
    \        $i++;\n    }\n    \n    return @new_l;\n}", "    my @l2 = ();\n    my\
    \ @l3 = ();", "    my($l2') = ();\n    my($idx1, $idx2);\n    my $count = 1;\n\
    \    foreach $idx1 (sort {$a <=> $b} keys %{$l}) {\n        $idx2 = $idx1;\n \
    \       while ($idx2 && ($l->[$idx2] % 3 == 0)) {\n            $idx2--;\n    \
    \    }\n        $l2->[$idx1] = $l->[$idx2];\n        undef $l2->[$idx2];\n   \
    \     $count++;\n    }\n    $count = 1;\n    foreach $idx1 (sort {$a <=> $b} keys\
    \ %{$l}) {\n        $idx2 = $idx1;\n        while ($idx2 && ($l->[$idx2] % 3 ==\
    \ 0)) {\n            $idx2--;\n        }\n        $l2->[$idx1] = $l->[$idx2];\n\
    \        $count++;\n    }\n    return @$l2;\n}", "    my(@lprime);\n    foreach\
    \ (0 .. $#l) {\n\tpush(@lprime, [ $l[$_], $_ ]);\n    }\n    my($min, $min) =\
    \ $lprime[0];\n    foreach my $r (@lprime) {\n\tif ($r->[0] <= $min + 3) {\n\t\
    \    $min = $r->[1];\n\t}\n    }\n    @lprime = sort { $a->[0] cmp $b->[0] };\n\
    \    splice(@lprime, 0, $min, $min + 3);\n    return @lprime;\n}", "    @$l =\
    \ sort { $a <=> $b } @$l;\n    @$l;\n}", "    return sort { $a[$_] <=> $b[$_]\
    \ } grep { $_ & ($_ & 1) == 0 } @$l;\n}", "    my @lprime = ();\n    for (my $i\
    \ = 0; $i < $#l; $i++) {\n        if ($i % 3 == 0) {\n            push(@lprime,\
    \ splice(@l, $i, 1));\n        } else {\n            push(@lprime, $l[$i]);\n\
    \        }\n    }\n    @lprime = sort_array_by_key(@lprime);\n    return @lprime;\n\
    }", "    my();\n    foreach my $i (0..$#$l) {\n        if ($i % 3 == 0) {\n  \
    \          push(@l,$i);\n        } else {\n            push(@l, $l[$i]);\n   \
    \     }\n    }\n    my @sorted = sort_by_value(@l);\n    my @reordered;\n    for\
    \ (my $i=0; $i<@l; $i++) {\n        push(@reordered,$sorted[$i]);\n    }\n   \
    \ return @reordered;\n}", "    my($l') = ();\n    my $count = 0;\n    for (my\
    \ $i = 0; $i < @$l; $i += 3) {\n        push (@$l', @{$l->[$i]} unless $count\
    \ % 3 != 0;\n        $l' .= @{$l->[$i]};\n        $count++;\n    }\n    return\
    \ @$l';\n}\n</code>\n<|/ a tags=perl dscore=0 |>\n<| c |>\nThis doesn't work when\
    \ there are duplicates in the input array.  It sorts them in order, but leaves\
    \ duplicates in order.\n<|/ c |>\n<| c |>\nHmm, I didn't test it on a set of duplicates.\
    \  But the OP's question specifically says \"... the value of the indicies that\
    \ are divisible by three are equal\".  Given that, I don't think the OP's question\
    \ is a duplicate of http://stackoverflow.com/questions/3384186/sorting-an-array-in-perl\n\
    <|/ c |>\n<| a tags=perl |>\nHere's a modified version of Eric's sort that does\
    \ work for duplicates\n<code>", "    $l =~ tr/3/1/;\n    return sort {$b <=> $a};\n\
    }", "    @l[0..$#l] =\n        @l[0..$#l][0..$#l] =\n        @l[0..$#l][0..$#l];\n\
    \    return $l;\n}", "    my(@l');\n    my $i = 0;\n    \n    while ($i < scalar\
    \ @$l) {\n        if ($i % 3 == 0) {\n            push(@l', $l->[$i]);\n     \
    \   }\n        $i++;\n    }", "    my(@l') =;\n    foreach my $i (0..(@l-1)) {\n\
    \        my $d = $i % 3;\n        if ($d == 0) {\n            push (@l', $l[$i]);\n\
    \        }\n        elsif ($d != 1) {\n            push @l', $l[$i];\n       \
    \ }\n    }\n    return @l';\n}", '    my(@lprime);', "    my@l = ();\n    for\
    \ my $i (0 .. $#$l) {\n        my $value = $l->[$i];\n        if ($value % 3 !=\
    \ 0) {\n            push (@l, $l->[$i]);\n        } else {\n            push (@l,\
    \ $value);\n        }\n    }\n    my@lsort = ();\n    for my $i (0 .. $#$l) {\n\
    \        my $value = $l->[$i];\n        if ($value % 3 == 0) {\n            push\
    \ (@lsort, $value);\n        }\n    }\n    my@lsort = sort { $a<=>$b } @lsort;\n\
    \    for my $i (0 .. $#$l) {\n        $l->[$i] = $lsort->[$i];\n    }\n    @l;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=perl,arrays,sorting |>\nI think this\
    \ can work:\n<code>", '    my @l2;', "    my @l_sorted = map { $_ % 3 ? $_ =>\
    \ $_ } @$l;\n    my @l_sorted_copy = @l_sorted;\n    my ($i, $j);\n    my $count\
    \ = 0;\n    for ($i = 0; $i < @l_sorted; $i++) {\n        if ($l_sorted[$i] %\
    \ 3 == 0) {\n            $l_sorted[$i] = $count;\n        }\n        elsif ($l_sorted[$i]\
    \ == $l_sorted[$i - 1]) {\n            $j++;\n            $l_sorted[$i] = $j;\n\
    \        }\n        else {\n            $count++;\n            $l_sorted[$i] =\
    \ $count;\n        }\n    }\n    return @l_sorted;\n}", "    my @out;\n    for\
    \ (my $i=0; $i<@$l; $i+=3) {\n        for ($i; $i<@$l; $i+=3) {\n            push(@out,\
    \ $l->[$i]);\n        }\n    }\n    return @out;\n}", "    my @sorted_list = ();\n\
    \    for(my $i = 0; $i <; $i++) {\n        unless($i & 1) {\n            push\
    \ @sorted_list, $l[$i];\n        }\n        elsif ($l[$i] % 3 == 0) {\n      \
    \      push @sorted_list, $l[$i];\n        }\n    }\n    return @sorted_list;\n\
    }\n</code>\nThe above will work for a sorted list or array in place.\n<|/ a dscore=3\
    \ |>\n<| a dscore=1 |>\nIn Python:\n<code>\ndef f(l):\n    return [x for x in\
    \ l if x % 3 == 0 and l.index(x) > l.index(x) // 3]", "    my @l = @$l;\n    my\
    \ @l2 = ();\n    for (my $i = 0; $i < @l; ++$i) {\n        if ($i % 3 == 0) {\n\
    \            @l2 += [$l[$i], $l[$i], $l[$i]];\n        }\n        else {\n   \
    \         @l2 += [$l[$i]];\n        }\n    }\n    return @l2;\n}", "    my @l_third\
    \ = ();\n    for (my $index = 0; $index < @$l; $index++) {\n        my $l_index\
    \ = $index*3;\n        my $l_third_index = $l_index + 2;\n        if ($l_index\
    \ % 3 != 0) {\n            push(@l_third, $l->[$l_index]);\n        } else {\n\
    \            push(@l_third, $l->[$l_third_index]);\n        }\n    }\n    return\
    \ sort @l_third;\n}", "    my @l = ();\n    my $count = 0;\n    my $size = 0;\n\
    \    for(my $i = 0; $i <= $#l; $i++) {\n        if ($i % 3 == 0) {\n         \
    \   push @l, $l[$i];\n            $count++;\n            $size++;\n        }\n\
    \    }\n    for(my $i = 0; $i < $count; $i++) {\n        for (my $j = 0; $j <\
    \ $count; $j++) {\n            if ($l[$j] == $l[$i] && $j < $i) {\n          \
    \      splice @l, $j, $i-$j, $l[$i];\n                splice @l, $i, 1, $l[$j];\n\
    \                splice @l, $i, 1, $l[$i];\n            }\n        }\n    }\n\
    \    return @l;\n}", "    my($l2') = [];\n    my($ind = 1);\n    my($val = $l->[$ind++]);\n\
    \    while($ind<@$l) {\n        if(!($ind % 3)) {\n            $l2->[$ind++] =\
    \ $val;\n            $val = $l->[$ind++];\n        } else {\n            for($i=0;\
    \ $i<$ind; $i++) {\n                if($l2->[$i] eq $val) { }\n              \
    \  elsif($i eq $ind) { $l2->[$i] = $val; }\n                else             \
    \ { $l2->[$i] += $l2->[$i]; }\n            }\n            $val = $l->[$ind++];\n\
    \        }\n    }\n    @$l = @$l2;\n    return @$l;\n}", "    my $len = @$l;\n\
    \    my %counts;\n    my @sorted = ();\n    for (my $i = 0; $i < $len; ++$i) {\n\
    \        my $elem = $l->[$i];\n        $counts{ $elem } = 1;\n    }\n    @sorted\
    \ = map { $_ % 3 ? ($counts{ $_ } == 1 ? $l->[$_] : @{ $l->[$_] }) : ($_ => 1)\
    \ } 0 .. @$l - 1;\n    @sorted;\n}\n</code>\n<|/ a tags=sorting,perl,arrays |>\n\
    <| c |>\nThe code works on your example, but it's not clear what the OP wants\
    \ to do. It appears to be sorting on multiples of 3 not on multiples of 5\n<|/\
    \ c |>\n<| c |>\nThat's a very good point, but I don't think I actually answered\
    \ the question about what he wants. I assumed the OP wanted to sort on multiples\
    \ of 5, and I only addressed multiples of 3. If I were to guess, I would say he's\
    \ trying to sort on multiples of 3, with values equal to those multiples of 5\n\
    <|/ c |>\n<| a dscore=0 tags=sorting,perl,arrays |>\n<code>", "    my(@lprime);\n\
    \    my($third);\n    my($index);", "    my(@l) = ($l);\n    my(@l') = (@l);\n\
    \    my(@l') = ();\n    my($i, $j, $k, $v) = (0, 0, 0);\n    while ($i < @l) {\n\
    \        while ($j < @l) {\n            my $k = $j + 1;\n            $k = 1 if\
    \ ($j < @l && $k != $j);\n            if ($l[$j] == $l[$k]) {\n              \
    \  splice(@l', 0, $j, $k);\n                splice(@l', 0, $k, $j);\n        \
    \        $k++;\n                last;\n            }\n            else {\n   \
    \             $j++;\n            }\n        }\n        $i++;\n        $j = 0;\n\
    \    }\n    foreach (@l') {\n        $l[$_] = $_;\n    }\n    return \\@l;\n}\n\
    </code>\n<|/ a dscore=3 tags=perl,arrays,sorting |>\n<| c |>\nThis doesn't work\
    \ correctly for two or more equal numbers, e.g. for [3,2,2] the expected output\
    \ is [2,2,3], but the solution gives the wrong output [3,2,2].\n<|/ c |>\n<| c\
    \ |>\nYes, but it doesn't matter. Both are equally important, so I gave both solutions.\
    \ :)\n<|/ c |>\n<| c |>\nI know, I'm just pointing it out because this one doesn't\
    \ work right for inputs like [1,2,1,3] and [3,2,1,3]\n<|/ c |>\n<| c |>\nGood\
    \ point! I edited my answer to take that into account.\n<|/ c |>\n<| c |>\nYes,\
    \ it's still broken. [5,1,7,3,5,9,2,6,4,8,3] gives [1,2,3,4,5,6,7,8,9,5] instead\
    \ of [1,2,3,4,5,6,7,8,9,5].\n<|/ c |>\n<| a |>\n<code>\nuse Sort::Key 0.19;",
  "    my(@l') = ();\n    \n    for(my $i = 0; $i < @$l; $i++) {\n        my $index\
    \ = $i / 3;\n        my $value1 = $l->[$index];\n        my $value2 = $l->[$index\
    \ + 1];\n        my $value3 = $l->[$index + 2];\n        if ($index % 3) {\n \
    \           push(@l', $value3, $value2, $value1);\n        } else {\n        \
    \    push(@l', $value2, $value1, $value3);\n        }\n    }\n    return @l';\n\
    }", "    my @sorted_l = ();\n    my($i, $j, $k) = @$l;\n    for (my $k = 0; $k\
    \ <= $#l; $k++) {\n        if ($k % 3 == 0) {\n            push @sorted_l, $$l[$k];\n\
    \        } else {\n            my $value = $$l[$k];\n            for (my $i =\
    \ $k; $i >= 0; $i--) {\n                if ($$l[$i] % 3 == 0) {\n            \
    \        $value = $$l[$k];\n                    $j = $i;\n                   \
    \ last;\n                }\n            }\n            $$l[$k] = $value;\n   \
    \         $$l[$j] = $$l[$k];\n        }\n    }\n    return @sorted_l;\n}", " \
    \   return () unless (defined $l[0]);\n    my;\n    my $i = 0;\n    my $j = 0;\n\
    \    my $k = 0;\n    for(my $i = 0;$i < @{$l[0]};$i++) {\n        my $j = 0;\n\
    \        my $k = 0;\n        for(my $j = 0;$j < @{$l[0]};$j++) {\n           \
    \ if ($i / 3 != $j / 3) {\n                push(@sorted_third,$l[0][$j]);\n  \
    \          } else {\n                push(@sorted_third,$l[0][$k]);\n        \
    \    }\n            $k++;\n        }\n        $j++;\n    }\n    return \\@sorted_third;\n\
    }", "    my(@l') =;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    for\
    \ ($i = 0; $i < @l'; $i++) {\n        if ($i % 3 != 0) {\n            push(@l',\
    \ \"@{[l'][$i]}\");\n        } else {\n            push(@l', \"@{[l'][$i]}\");\n\
    \        }\n    }\n    push @l', \"@{[l'][-1]}\";\n}", "    my($l') = ();\n  \
    \  my $i = 0;\n    my $j = 0;\n    my $n = 0;\n    my $count = 0;\n    foreach\
    \ (@{$l}) {\n        next if ($i == 0);\n        last if ($j == (@$l) - 1);\n\
    \        if ($i % 3 == 0) {\n            push @$l', undef';\n        }\n     \
    \   push @$l', $_';\n        $i++;\n        $j++;\n        $n++;\n        $count\
    \ += 1;\n    }\n    if ($n > 1) {\n        push @$l', undef' for ($j, ($j + $count\
    \ - 1) % $n, $n);\n    }\n    return @$l';\n}", "    my(@l2) = ();\n    foreach\
    \ my $i (0 .. $#l) {\n        if ($i % 3 == 0) {\n            push(@l2, $l[$i]);\n\
    \        }\n    }\n    foreach my $i (0 .. $#l) {\n        if ($i % 3 != 0) {\n\
    \            push(@l2, $l[$i]);\n        }\n    }\n    return @l2;\n}", "    my(@l2)\
    \ = ();\n    for my $i ( 0 .. $#$l ) {\n        if ($l->[$i] % 3 == 0) {\n   \
    \         push(@l2, $l->[$i]);\n        }\n    }\n    foreach my $i (0 .. $#$l)\
    \ {\n        if ($l->[$i] % 3 == 0) {\n            my $t=$l->[$i];\n         \
    \   foreach my $j ($i+1 .. $#$l) {\n                if ($l->[$j] % 3 == 0) {\n\
    \                    $l->[$j]=$t;\n                }\n            }\n        }\n\
    \    }\n    return @l2;\n}", "    my(@lprime) = ();\n    foreach $i (0 .. $#$l)\
    \ {\n        if ($i & 1) {\n            push(@lprime, $l->[$i]);\n        } else\
    \ {\n            my $n = $i;\n            while ($n >= 0 && $l->[$n] % 3 == 0)\
    \ {\n                $n--;\n            }\n            $lprime->[$n] = $l->[$i];\n\
    \        }\n    }\n    return @lprime;\n}", "    my($lprime) = map {\n       \
    \ my $n = ( $_ % 3 );\n        if( $n == 3 ) {\n            ($n==1 ? $l->[0] :\
    \ $l->[$n])\n        } else {\n            $l->[$n]\n        }\n    } @$l;\n \
    \   # sort on indicies where val is not divisible by 3\n    foreach my $i (0 ..\
    \ $#l) {\n        foreach my $j ($i+1 .. $#l) {\n            next if ( $lprime[$j]\
    \ % 3 != 0 );\n            $lprime[$i] .= $lprime[$j];\n            splice @$l,\
    \ $i, 1, $lprime[$i];\n        }\n    }\n    return @$l;\n}", "    my($len) =\
    \ @$l;\n    my($i, $j, $temp, $i, $j, $sum);\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        $sum += $l[$i];\n        if ($sum % 3 != 0) {\n            for ($i\
    \ = $j; $i < $len; $i++) {\n                if ($l[$i] != $l[$i - 1]) {\n    \
    \                $j = $i;\n                }\n            }\n            $l[$j\
    \ - 1] = $l[$i];\n            $l[$i] = $l[$j - 1];\n        }\n    }\n    return\
    \ $l;\n}", "    my($lsorted);\n    my($i, $j, $k, $u, $v);\n    my($temp);\n \
    \   \n    foreach $k (0..@$l-2){\n        if ($k % 3 == 0){\n            $lsorted[$k]\
    \ = $l[$k];\n        }\n        else{\n            foreach $u ($k..$l-1){\n  \
    \              if ($u % 3 == 0){\n                    if ($u < $k){\n        \
    \                $lsorted[$k] = $l[$k];\n                    }\n             \
    \       else{\n                        $lsorted[$u] = $l[$u];\n              \
    \      }\n                }\n                else{\n                    $temp\
    \ = $lsorted[$u];\n                    $lsorted[$u] = $lsorted[$k];\n        \
    \            $lsorted[$k] = $temp;\n                }\n            }\n       \
    \ }\n    }\n    return @$lsorted;\n}", "    my(@l' , $i);", "    my @sorted =\
    \ ();\n    for(my $i = 0; $i < $#l; $i++) {\n        if($i % 3 == 0) {\n     \
    \       push(@sorted, $l[$i]);\n        }\n    }\n    for(my $i = 0; $i < $#l;\
    \ $i++) {\n        if($i % 3 != 0) {\n            $l[$i] = $l[$i] unless $l[$i]\
    \ == $sorted[$i];\n        }\n    }\n    return @l;\n}\n</code>\n<|/ a tags=arrays,sorting,perl\
    \ dscore=0 |>\n<| c |>\nthanks for your answer, but your solution doesn't actually\
    \ sort the third value of the array.\n<|/ c |>\n<| c |>\n, sorry I forgot that\
    \ array slices aren't affected by changes by subroutines, so I had to return an\
    \ array. I've updated the code so now it returns the sorted array.\n<|/ c |>\n\
    <| c |>\n, thanks for your solution! It works perfectly for me.\n<|/ c |>\n<|\
    \ a tags=arrays,sorting,perl |>\n<code>\nuse strict;\nuse warnings;", "    my(@l')\
    \ = ();\n    foreach my $i (0 .. @$l) {\n        if($i % 3 != 0) {\n         \
    \   push @l', $., $i, $l->[$i];\n        } else {\n            push @l', $., $i,\
    \ $l->[$i];\n        }\n    }\n    return @l';\n}", "    my @ret;\n    foreach\
    \ my $i (0..($#l - 1)) {\n        my $third_idx = ($i * 3) mod $#l;\n        push\
    \ (@ret, splice(@$l, $third_idx, 0, splice(@$l, $i, 1)));\n    }\n    return @ret;\n\
    }", '    $l =~ tr/3/ / if $l =~ tr/3/3/;', "    my @ret;\n    my $i = 0;\n   \
    \ for (my $j=0; $j < @$l; ++$j) {\n        if ($i && ($i % 3 == 0)) {\n      \
    \      if ($l->[$i-1] < $l->[$j]) {\n                push @ret, $l->[$i-1];\n\
    \                $l->[$i-1] = $l->[$j];\n                $l->[$j] = $l->[$i-1];\n\
    \            }\n            else {\n                push @ret, $l->[$j];\n   \
    \             $l->[$j] = $l->[$i-1];\n                $l->[$i-1] = $l->[$j];\n\
    \            }\n        }\n        else { push @ret, $l->[$j]; }\n        ++$i;\n\
    \    }\n    return @ret;\n}", "    my @l = ();\n    for (my $i = 0; $i < @$l;\
    \ $i++) {\n        next if $l->[$i] % 3 != 0;\n        push(@l, @$l[$i..$#l]);\n\
    \    }\n    return @l;\n}", "    my @l = ();\n    my @l_prime = ();\n    my @l_prime_sorted\
    \ = ();\n    my $l_prime_count = 0;\n    my $l_prime_count_max = 3;\n    for(my\
    \ $x = 0; $x < scalar(@$l); $x++) {\n        my $l = $l->[$x];\n        my $l_prime\
    \ = $l->[$x];\n        if($x % 3 != 0 && $x != scalar(@$l)) {\n            push(@l_prime,\
    \ $l_prime);\n            $l_prime_count++;\n        }\n        if($x % 3 == 0\
    \ && $x != scalar(@$l)) {\n            push(@l_prime_sorted, $l_prime);\n    \
    \        $l_prime_count_max--;\n        }\n    }\n    for($x = 0; $x < scalar(@l);\
    \ $x++) {\n        if($x % 3 != 0 && $x != scalar(@l)) {\n            push(@l,\
    \ $l->[$x]);\n            $l_prime_count++;\n        }\n        if($x % 3 == 0\
    \ && $x != scalar(@l)) {\n            push(@l_prime_sorted, $l->[$x]);\n     \
    \       $l_prime_count_max--;\n        }\n    }\n    for(my $x = 0; $x < scalar(@l);\
    \ $x++) {\n        my $l = $l->[$x];\n        my $l_prime = $l_prime->[$x];\n\
    \        if($x != scalar(@l)) {\n            my $l_prime_prime = $l_prime->[$x];\n\
    \            if($l > $l_prime) {\n                if($l_prime_count <= $l_prime_count_max)\
    \ {\n                    push(@l_prime, $l_prime_prime);\n                   \
    \ $l_prime_count++;\n                }\n                else {\n             \
    \       if($l_prime_count <= $l_prime_count_max) {\n                        for(my\
    \ $y = 0; $y < scalar(@l_prime_sorted); $y++) {\n                            my\
    \ $l_prime_prime = $l_prime_sorted->[$y];\n                            if($l ==\
    \ $l_prime_prime) {\n                                $l_prime_prime = $l_prime;\n\
    \                                $l_prime_sorted->[$y] = $l_prime_prime;\n   \
    \                             $l = $l_prime;\n                               \
    \ $l_prime = $l_prime_prime;\n                                $l_prime_count_max++;\n\
    \                            }\n                        }\n                  \
    \      push(@l, $l_prime_prime);\n                        $l_prime_count++;\n\
    \                    }\n                }\n            }\n            elsif($l\
    \ < $l_prime) {\n                if($l_prime_count <= $l_", "    my(@lprime);\n\
    \    foreach my $i (0 .. $#l) {\n        if ($i % 3 == 0) {\n            push(@lprime,\
    \ $l[$i]);\n        }\n    }\n    sort { $a <=> $b } @lprime;\n}", "    my(@l2)\
    \ = @$l;\n    my $i = 3; \n    while (@l2 > $i) {\n        splice, 3, 1;\n   \
    \     splice, 3, 1;\n        $i += 3;\n    }\n    @l2 =;\n    return @l2;\n}",
  "    my @thirds;\n    my $i = 0;\n    my ($third, $thirds);", "    my @result;\n\
    \    my %sorted;\n    my @counter;\n    for (my $i = 0; $i < @$l; $i++) {\n  \
    \      if ($i % 3 == 0) {\n            $sorted{$i} = $i;\n            $counter[$i]\
    \ = 1;\n        }\n        else {\n            if (exists $sorted{$counter[$i\
    \ - 1]}) {\n                for (my $j = $sorted{$counter[$i - 1]}; $j < $i; $j++)\
    \ {\n                    if ($counter[$j] == 1) {\n                        $counter[$j]\
    \ = 2;\n                    }\n                    else {\n                  \
    \      $counter[$j]++;\n                        $counter[$j] += $counter[$j +\
    \ 1];\n                        $counter[$j + 1]--;\n                        $counter[$j\
    \ + 1] -= $counter[$j];\n                        last if $counter[$j] == 3;\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ ($counter[$i] == 3) {\n            push (@result, $l->[$i]);\n            $sorted{$i}\
    \ = $i;\n            $counter[$i] = 1;\n        }\n    }\n    return @result;\n\
    }", "    @$l = [sort @$l || @$l];\n    return @$l;\n}", "    my(@lprime);\n  \
    \  my $count = 0;\n    foreach (@{$l}) {\n        if ( ($count++) % 3 != 0 ) {\n\
    \            push(@lprime, $_);\n        } else {\n            $lprime[$_] = $l[$_];\n\
    \        }\n    }\n    @lprime = sort {$a <=> $b} @lprime;\n    return @lprime;\n\
    }", "    my @ret;\n    for (my $i = 0; $i < @$l; $i++) {\n        if ($i > 0)\
    \ {\n            if ($i % 3 != 0) {\n                push(@ret, $l->[$i]);\n \
    \           }\n            else {\n                my $j = $i;\n             \
    \   while ($j > 0 && $l->[$j - 1] == $l->[$j]) {\n                    $j--;\n\
    \                }\n                push(@ret, $l->[$j]);\n            }\n   \
    \     }\n    }\n    return \\@ret;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ seems like a good solution, but it doesn't seem to work properly. http://pastebin.com/6ZYfQkKq\
    \ Here is a copy of my Perl code. The first one sorts it properly, but the second\
    \ one doesn't seem to sort the way I want. The way it sorts it's returning a list\
    \ of [3,2,1,1,2,3,2]. I'm still trying to figure out what exactly is going on.\n\
    <|/ c |>\n<| c |>\nI fixed the bug, I had a bug in the `unshift` that was causing\
    \ it to not sort the way I want. Now it sorts it properly. Thanks!\n<|/ c |>\n\
    <| c |>\nI fixed the bug, I had a bug in the `unshift` that was causing it to\
    \ not sort the way I want. Now it sorts it properly. Thanks!\n<|/ c |>\n<| a dscore=1\
    \ |>\nI believe it is fairly straightforward if you use the Schwartzian transform:\n\
    <code>", "    my $l = $l->[0];\n    my($hi, $lo) = ($l, $l);\n    for(my $i =\
    \ 1; $i <= $#$l; $i++) {\n        if($l % 3 == 0) {\n            $hi = $l->[$i];\n\
    \        }\n        else {\n            $lo = $l->[$i];\n        }\n    }\n  \
    \  return [@$hi, @$lo];\n}", "    my(@lprime);\n    my $count = 0;\n    while\
    \ (@$l > 0) {\n        $count++;\n        if ($count % 3 == 1) {\n           \
    \ push @lprime, $l->[-1];\n        }\n        $count++;\n        if ($count %\
    \ 3 == 2) {\n            push @lprime, $l->[-2];\n        }\n        $count++;\n\
    \        if ($count % 3 == 3) {\n            push @lprime, $l->[-3];\n       \
    \ }\n        splice @$l, -1, 1, @lprime;\n    }\n    @lprime;\n}\n</code>\n<|/\
    \ a tags=sorting,perl,arrays |>\n<| a dscore=1 |>\nHere is a quick solution that\
    \ I thought up (using sort!).\nIt sorts the array by taking the middle three numbers,\
    \ sorting them, then comparing them to the middle two numbers, sorting them, then\
    \ comparing them to the middle one.\nIf there are a lot of duplicates, the second\
    \ sort will slow the array down by a lot, so if you can find a way to avoid that\
    \ in the first place, that would be best.\n<code>\nuse strict;\nuse warnings;",
  '    my(@r) = ();', "    my($llen) = @$l;\n    my @lprime;\n    for (my $i = 0;\
    \ $i < $llen; ++$i) {\n        if ($i % 3 != 0) {\n            push(@lprime, $l->[$i]);\n\
    \        }\n    }\n    for (my $i = 0; $i < $llen; ++$i) {\n        if ($i % 3\
    \ == 0) {\n            $lprime[$i] = $l->[$i];\n        }\n    }\n    return @lprime;\n\
    }", "    return grep { $_ %3 != 0 } @$l;\n}", "    my(@l') = @$l;\n    for(0..$#l')\
    \ {\n        my $i = ($l[0] % 3) + 1;\n        $l[$i]++;\n        $l[$i]--;\n\
    \        if ($l[$i] < $l[$i+1]) {\n            push (@l', $l[$i]);\n         \
    \   push (@l', $l[$i+1]);\n        }\n    }\n    return @l';\n}", "    my %sorted\
    \ = ();\n    my @keys = ();\n    my @newlist = ();\n    foreach my $i ( @$l )\
    \ {\n        if ( ! $i % 3 ) {\n            if ( !exists( $sorted{$i} ) ) {\n\
    \                $sorted{$i} = $i;\n                push( @keys, $i );\n     \
    \       }\n        } else {\n            my $k = pop( @keys );\n            if\
    \ ( $k % 3 ) {\n                $sorted{$k} = $k;\n                push( @newlist,\
    \ $k );\n            } else {\n                push( @newlist, $i );\n       \
    \     }\n        }\n    }\n    @$l = @newlist;\n    @$l = sort { $a <=> $b } @$l;\n\
    \    return @$l;\n}", "    my @l2;\n    my $j = 0;\n    my $k = 0;\n    \n   \
    \ for (my $i = 0; $i < @$l; $i++) {\n        if ($l->[$i] % 3 == 0) {\n      \
    \      $l2[$j] = $l->[$i];\n            $j++;\n        } else {\n            $l2[$k]\
    \ = $l->[$i];\n            $k++;\n        }\n    }\n    $j = 0;\n    $k = 0;\n\
    \    \n    for (my $i = 0; $i < @$l2; $i++) {\n        if ($l2[$i] % 3 == 0) {\n\
    \            $l2[$j] = $l2[$i];\n            $j++;\n        } else {\n       \
    \     $l2[$k] = $l2[$i];\n            $k++;\n        }\n    }\n    $l2 = @$l2\
    \ ? @$l2 : ();\n    return @$l;\n}\n</cell>\n<cell>", "    my @l2 = ();\n    my\
    \ @l3 = ();\n    my $i = 0;\n    for(my $j = 0; j < @$l; ++$j) {\n        if($i\
    \ % 3 == 0) {\n            $l2[$i] = $l->[$j];\n            $l3[$i] = 0;\n   \
    \     }\n        $l3[$i] = $l3[$i] * 3 + $l2[$i];\n        $i++;\n    }\n    $i\
    \ = 0;\n    for(my $j = 0; j < @$l2; ++$j) {\n        $l->[$i] = $l3[$i];\n  \
    \      $i++;\n    }\n    return @$l;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is a solution using Perl's Algorithm::Combinatorics.\n<code>\nuse strict;\n\
    use warnings;", "    my(@lprime);\n    my($i, $j);\n    my($i, $j, $h);", "  \
    \  my(@third) = ();\n    my($i, $j, $k, $temp, $jtemp, $ktemp, $len, $t);", " \
    \   @$l = sort {$a <=> $b} @$l;\n    \n    my ($i, $j);\n    @$l = map {$_ - 1\
    \ if ($i % 3 == 0); $_} @$l;\n    \n    for (my $k = 0; $k < @$l; $k++) {\n  \
    \      if ($k % 3 == 0) {\n            $i = $k / 3;\n            $j = $k / 3;\n\
    \        } else {\n            $i = $k;\n            $j = $k;\n        }\n   \
    \     if ($j < $i) {\n            $l[$i] = $l[$j];\n            $l[$j] = $k;\n\
    \        }\n    }\n    return @$l;\n}", "    my $l_count = scalar(@$l);\n    my\
    \ @l_sorted_inds = ();\n    my @l_indexes = ();\n    for (my $i = 0; $i < $l_count;\
    \ $i++) {\n        if ($i % 3 != 0) {\n            push(@l_sorted_inds, $i);\n\
    \        }\n    }\n    my $l_count_2 = scalar(@l_sorted_inds);\n    for (my $j=0;\
    \ $j < $l_count_2; $j++) {\n        my $i = $l_sorted_inds[$j];\n        if ($j\
    \ == 0) {\n            $l_indexes[$i] = $l_sorted_inds[0];\n        }\n      \
    \  else {\n            if ($l_indexes[$i] != $l_indexes[$j - 1]) {\n         \
    \       push(@l_indexes, $i);\n            }\n        }\n    }\n    my @l_sorted\
    \ = ();\n    my $l_count = scalar(@l_indexes);\n    for (my $i = 0; $i < $l_count;\
    \ $i++) {\n        if ($l_indexes[$i] >= $l_count) {\n            push(@l_sorted,\
    \ $l[$l_indexes[$i]]);\n        } else {\n            push(@l_sorted, $l[$l_indexes[$i]]);\n\
    \        }\n    }\n    return @l_sorted;\n}", "    my($l');\n    \n    # Sort\
    \ the array based on the values of its indicies that are not divisible by 3\n\
    \    my $i = 0;\n    my @l3 = ();\n    while (@l > 0 and $i < (scalar(@l) - 1))\
    \ {\n        my $j = -1;\n        my $k = -1;\n        for my $j (0 .. $i) {\n\
    \            if ($j % 3 != 0) {\n                $l3[$j] = $l[$j];\n         \
    \       $k++;\n            }\n        }\n        for my $j ($i .. scalar(@l) -\
    \ 1) {\n            if ($j % 3 == 0) {\n                $l3[$j] = $l[$j];\n  \
    \          }\n        }\n        for my $j ($i .. $k) {\n            $l3[$j] =\
    \ $l[$j];\n        }\n        $i++;\n    }", "    my(@sorted_third) = ();\n  \
    \  my($first_three) = @$l[0..$#$l/3];\n    my($second_three) = @$l[2..($#$l/3)];\n\
    \    my($third_three) = @$l[$#$l/3..$#$l];\n    $sorted_third = $first_three;\n\
    \    push(@sorted_third, $second_three) unless($first_three == $second_three);\n\
    \    push(@sorted_third, $third_three) unless($first_three == $third_three);\n\
    \    push(@sorted_third, $first_three);\n    return @sorted_third;\n}\n</code>\n\
    <|/ a tags=perl,arrays |>\n<| c |>\nThis was my original thought as well.  I did\
    \ post an answer, but was busy and didn't have time to write it.  Then I read\
    \ it again and saw you already did it.  +1 for you sir.\n<|/ c |>\n<| c |>\nNo\
    \ worries, I did write it before I read your comment. =)  Hopefully it will help\
    \ someone else in the future.\n<|/ c |>\n<| c |>\nI like the `sort` solution better,\
    \ because it preserves the original sort order and doesn't use `eq` to do the\
    \ sorting. +1 for that.\n<|/ c |>\n<| c |>\nI like this solution, but I'm afraid\
    \ that for my actual array this doesn't work because I don't always know how many\
    \ elements are in the array. So I guess I'll have to go with the solution I posted\
    \ before. Thanks for your effort though!\n<|/ c |>\n<| a |>\n<code>\nmy %sort;\n\
    foreach my $i (0..$#a){\n    if ($i ne ($i+1) % 3) {\n        $sort{$i} = $a[$i];\n\
    \    }\n}", "    my@l2;\n    for($#l,1) {\n        if($l[$_] % 3 == 0) {\n   \
    \         $l2[$_] = $l[$_];\n        }\n        elsif ($l[$_] % 3 == 1) {\n  \
    \          push(@l2, $l[$_]);\n        }\n        elsif ($l[$_] % 3 == 2) {\n\
    \            push(@l2, $l[$_]);\n            push(@l2, $l[$_ + 1]);\n        }\n\
    \    }\n    return @l2;\n}", "    my($l') = [];\n    for(my $i=0; $i < @$l; $i++)\
    \ {\n        my $div = $i & 3;\n        if($div) {\n            $l' .= $l->[$i];\n\
    \        } else {\n            push @$l', $l->[$i];\n        }\n    }\n    return\
    \ @$l';\n}", "    my @temp = ();\n    for (my $i = 0; $i < @$l; ++$i) {\n    \
    \    if ($i % 3 != 0) {\n            push(@temp, $l->[$i]);\n        }\n    }\n\
    \    if (@$l > @temp) {\n        for (my $i = @temp; $i < @$l; ++$i) {\n     \
    \       push(@temp, $l->[$i]);\n        }\n    }\n    return @temp;\n}", "   \
    \ my @l2;\n    my @divisible_by_three;\n    my @sorted_by_three;", "    return\
    \ @$l unless @$l == 3;\n    my $n = 0;\n    my(@l3, @l2, @l1);\n    for my $i\
    \ (0 .. @$l - 1) {\n        if ($i % 3 == 0) {\n            push (@l3, $i);\n\
    \        }\n        if ($i % 3 == 1) {\n            push (@l2, $i);\n        }\n\
    \        if ($i % 3 == 2) {\n            push (@l1, $i);\n        }\n    }\n \
    \   sort {$a <=> $b} @l3 unless @l3 == 3;\n    sort {$b <=> $a} @l2 unless @l2\
    \ == 3;\n    sort {$a <=> $b} @l1 unless @l1 == 3;\n    return @l3;\n}", "   \
    \ my(@lprime) = ();\n    my($third) = $l % 3;\n    for my $i (0..$#l) {\n    \
    \    if ($i == $third) {\n            push (@lprime, $l[$i]);\n        } else\
    \ {\n            push (@lprime, $l[$i]);\n        }\n    }\n    return @lprime;\n\
    }", "    my(@lprime) = ();\n    my($t);\n    foreach $t (@$l) {\n        if (!$t\
    \ % 3) {\n            push(@lprime, $t);\n        }\n    }\n    my($t);\n    foreach\
    \ $t (@lprime) {\n        if (!$t % 3) {\n            push(@lprime, $t);\n   \
    \     }\n    }\n    $lprime = reverse sort @lprime;\n    return @lprime;\n}",
  "    my();\n    for(my $i=0; $i<@$l; $i+=3) {\n        for(my $j=$i+1; $j<@$l; $j+=3)\
    \ {\n            for(my $k=$j+1; $k<@$l; $k+=3) {\n                push(@$l, $l->[$i],\
    \ $l->[$j], $l->[$k]);\n            }\n        }\n    }\n    return sort @$l;\n\
    }", "    my($l1, $l2, $l3, $l4, $l5, $l6, $l7, $l8, $l9, $l10, $l11, $l12, $l13,\
    \ $l14);\n    \n    $l1 = $l[1];\n    $l2 = $l[2];\n    $l3 = $l[3];\n    $l4\
    \ = $l[4];\n    $l5 = $l[5];\n    $l6 = $l[6];\n    $l7 = $l[7];\n    $l8 = $l[8];\n\
    \    $l9 = $l[9];\n    $l10 = $l[10];\n    $l11 = $l[11];\n    $l12 = $l[12];\n\
    \    $l13 = $l[13];\n    $l14 = $l[14];", "    my($l2') = ();", "    my(@l') =\
    \ ();\n    my $index = 0;\n    foreach my $i (@$l) {\n        $i++;\n        if\
    \ ($i % 3 == 0) {\n            $l[$i-1] = $i;\n        } else {\n            push\
    \ @l', $i';\n        }\n    }\n    @l' = sort @l';\n    return @l';\n}", "   \
    \ my @l2 = ();\n    my @l3 = ();\n    my $i2;\n    my $i3;\n    \n    for (my\
    \ $i = 0; $i < @$l; $i++) {\n\tpush(@l2, $l->[$i] if ($i % 3 == 0));\n\tpush(@l3,\
    \ $l->[$i] if ($i % 3 == 1));\n    }\n    \n    for (my $i = 0; $i < @l2; $i++)\
    \ {\n\t$i2 = 0;\n\t$i3 = 0;\n\t\n\twhile (@l3 > 0 && ($l3[0] < $l2[$i])) {\n\t\
    \    splice(@l3, 1, 1);\n\t    $i2++;\n\t}\n\t\n\tfor (my $j = 0; $j < $i2; $j++)\
    \ {\n\t    $i3++;\n\t    my $t = $l3[$i3];\n\t    splice(@l3, 1, 1);\n\t    push(@l2,\
    \ $t);\n\t}\n    }\n    \n    return @l2;\n}", "    my @l = @$l;\n    my @l2 =\
    \ ();\n    my @l3 = ();", "    my @sorted_third;\n    for(my $i=0;$i<@$l;$i++)\
    \ {\n        push @sorted_third, $i;\n    }\n    for(my $i=0;$i<@$l;$i++) {\n\
    \        my $j = $i;\n        while(1) {\n            my $k = (($j+1)%3)?$j:($j+2);\n\
    \            if($k==$i) {\n                push @sorted_third, $k;\n         \
    \       last;\n            }\n            elsif($k >= $i) {\n                my\
    \ $swap = $sorted_third[$i];\n                $sorted_third[$i] = $sorted_third[$k];\n\
    \                $sorted_third[$k] = $swap;\n            }\n            $j++;\n\
    \        }\n    }\n    my @sorted = ();\n    for(my $i=0;$i<@$l;$i++) {\n    \
    \    push @sorted, $sorted_third[$i];\n    }\n    return @sorted;\n}", "    my(@l');\n\
    \    my $i = 0;\n    my $j = 0;\n    my $temp;\n    while(@l > 1) {\n        #\
    \ find indices that are not divisible by 3\n        while(@l > 1 && $i < @l) {\n\
    \            next if $l[$i] % 3 == 0;\n            push(@l', $l[$i]);\n      \
    \      $i++;\n        }\n        # find indicies where all elements are divisible\
    \ by 3\n        while(@l' > 1 && $j < @l) {\n            next if $l[$j] % 3 ==\
    \ 0;\n            push(@l', $j);\n            $j++;\n        }\n        # sort\
    \ according to indicies where all elements are divisible by 3\n        if(@l'\
    \ > 1) {\n            foreach $i (0 .. @l' - 1) { \n                $temp = lc($l[$i]);\n\
    \                $temp = lc($l[$l'][$i]) if $l[$i] % 3 == 0;\n               \
    \ $l[$i] = $l[$l'][$i] if $l[$i] % 3 == 0;\n                $l[$i] = $temp;\n\
    \            }\n            push(@l, @l');\n        }\n        else {\n      \
    \      push(@l, @l);\n        }\n    }\n    return @l;\n}", "    my ($i, $j, $tmp,\
    \ $k, $c, $c2, $c3) = (0, 0, 0, 0, 0, 0);\n    \n    while(@$l > 0 and $c3 !=\
    \ 3) {\n        $c3 = $c2 + 1;\n        foreach $k (@$l) {\n            $c2 =\
    \ $c1;\n            $c1 = $c;\n            $c = $k;\n            if($c3 != 3)\
    \ {\n                $l[$k] = $l[$k] > $l[$i] ? $l[$i] : $l[$k];\n           \
    \ } else {\n                $l[$k] = $l[$k] >= $l[$i] ? $l[$i] : $l[$k];\n   \
    \         }\n        }\n    }\n    return @$l;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks a lot. Very nice solution! I added a small fix by adding 1 instead\
    \ of 3 because I want the highest values to be at the end, not in the middle.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis solution is similar to Ben Voigt's but doesn't\
    \ use sort. It just uses subroutines.\n<code>", "    my @sorted_indices;\n   \
    \ my @original_indices = @$l;\n    my %indicies;\n    \n    foreach my $index\
    \ (@original_indices) {\n        $indicies{$index} = 1;\n    }\n    \n    foreach\
    \ my $index (@original_indices) {\n        next if $index % 3 != 0;\n        \n\
    \        my $sorted_index = $original_indices[$indicies{$index}];\n        \n\
    \        unless ($indicies{$sorted_index} and $indicies{$sorted_index} != $index)\
    \ {\n            push @sorted_indices, $sorted_index;\n        }\n    }\n    \n\
    \    return @sorted_indices;\n}\n</code>\nNow we can use our function as so:\n\
    <code>\nuse strict;\nuse warnings;", "    my($l3_idx);\n    my($l3_val);\n   \
    \ my($l3_r);", "    my($l') = [];\n    my $i = $#l - 1;\n    while($i >= 0) {\n\
    \        next if($l[$i] % 3 != 0);\n        $l[$i] >= $l[$i - 1] ? $l' .= $l[$i]\
    \ : $l' .= $l[$i - 1];\n        $i -= 1;\n    }\n    return $l';\n}", '    my($lprime)
    = ();', "    my($l1') = @$l;\n    my(@l2') = ();\n    my(@l3') = ();\n    my(@l4')\
    \ = ();\n    my(@l5') = ();", "    my(@l') = ();\n    my $i = 0;\n    my $j =\
    \ 0;\n    for (my $j = 0; $j < @$l; ++$j) {\n        my $k = $j;\n        while\
    \ (++$k <= @$l && $k % 3 != 0) {\n        }\n        push (@l', $k) if $k != $j;\n\
    \    }\n    my $k;\n    for ($j = 0; $j < @l; ++$j) {\n        $k = $j;\n    \
    \    while (++$k <= @l && $k % 3 != 0) {\n        }\n        push (@l', $k) if\
    \ $k != $j;\n    }\n    return @l';\n}", "    my(@third) = ();\n    my($first);\n\
    \    my($last);\n    my($value);", "    my(@new_l);\n    for(my $i = 1;$i =< $#l;$i++)\
    \ {\n        my $divisible_by_three = $i % 3;\n        if ($divisible_by_three)\
    \ {\n            @new_l = @new_l ? @new_l + [@new_l[$divisible_by_three]] : [];\n\
    \        }\n        push(@new_l, $l[$i]);\n    }\n    return @new_l;\n}", "  \
    \  my(@l2') = (@l);\n    while(@l2) {\n        my $i = $l2[-1];\n        unshift(@l2,\
    \ $l[$i] if $l[$i] % 3 != 0);\n        $l[$i] //= 3;\n    }\n    @l2;\n}", " \
    \   my(@l) = (@$l);\n    my(@l') = ();\n    my %l2 = ();\n    my($i, $j, $k) =\
    \ 0;", "    my @l = @$l;\n    my (@l', @l_index);", "    my @l_3 = ();\n    my\
    \ @l_2 = ();\n    my @l_1 = ();\n    my $divisible = 0;\n    foreach my $i (0\
    \ .. $#l) {\n        my $val = $l[$i];\n        if ($val % 3 != 0) {\n       \
    \     push(@l_3, $val);\n        } else {\n            my $j = ($i / 3);\n   \
    \         if ($j % 2 != 0) {\n                push(@l_2, $j);\n            } else\
    \ {\n                push(@l_1, $i);\n            }\n        }\n    }\n    foreach\
    \ my $i (@l_3) {\n        my $j = pop(@l_1);\n        push(@l_2, $j);\n    }\n\
    \    foreach my $i (@l_2) {\n        my $j = pop(@l_1);\n        push(@l_3, $j);\n\
    \    }\n    return @l_3;\n}", "    my(@l_prime) = $l;\n    for (my $i = 0; $i\
    \ < $#l; $i++) {\n        if ($i % 3 == 0) {\n            my $j = $i;\n      \
    \      while ($j > 0 && $j % 3 == 0) {\n                splice(@l_prime, $j, 0,\
    \ splice(@l_prime, $j - 1, 1));\n                $j--;\n            }\n      \
    \  }\n    }\n    return @l_prime;\n}", '    my(@sorted);', "    my @sorted_l;\n\
    \    my $j = 1;\n    my $tmp;\n    for my $i (0 .. $#$l) {\n        while ($j\
    \ >= 3) {\n            my $tmp = pop(@sorted_l);\n            if ($i & $j) {\n\
    \                push (@sorted_l, $$l[$i]);\n            } else {\n          \
    \      push (@sorted_l, $$l[$i - $j]);\n                last;\n            }\n\
    \            $j++;\n        }\n        push (@sorted_l, $$l[$i]);\n    }\n   \
    \ @$l = @sorted_l;\n}", "    my($l') = ();\n    my(@l3_index) = (0, 3);", "  \
    \  my($l') = ();\n    foreach $i (0 .. $#$l) {\n        my $key = $l[$i] % 3;\n\
    \        if ($key == 0) {\n            $l' .= $l[$i];\n        } elsif ($key ==\
    \ 1) {\n            $l' .= $l[$i]; $l' .= $l[$i];\n        } elsif ($key == 2)\
    \ {\n            $l' .= $l[$i]; $l' .= $l[$i]; $l' .= $l[$i];\n        } else\
    \ {\n            die \"Unknown sort key $key\\n\";\n        }\n    }\n    return\
    \ $l';\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks that's very helpful!\n\
    <|/ c |>\n<| c |>\nThanks again - I added the code in the original question. I\
    \ had thought that would have been sufficient but I'm probably wrong. Can you\
    \ see what I'm doing wrong?\n<|/ c |>\n<| c |>\n: You never call your subroutine\
    \ `sort_third`.\n<|/ c |>\n<| a |>\n<code>", "    my(@sorted);\n    @sorted =\
    \ sort {\n        not $_ & 3;\n        $sorted[0] |= $_ if ($sorted[0] & 3);\n\
    \        $sorted[0] ^= $sorted[1] if $sorted[0] & 3;\n        $sorted[1] ^= $_;\n\
    \    } @$l;\n    @sorted;\n}", "    my $third = $l[$_ % 3];\n    my(@l2);\n  \
    \  for (my $n = 0; $n < @$l; $n++) {\n        if ($n % 3 == 0) {\n           \
    \ push (@l2, $l[$n]);\n        }\n        else {\n            push (@l2, $third);\n\
    \        }\n    }\n    return @l2;\n}", "    my $third = $l[0];\n    my $third_index\
    \ = 0;\n    my $third_value = 0;\n    for (my $i = 1; $i <= $#l; $i++) {\n   \
    \     if ($i % 3 == 0) {\n            $third_index = $i;\n            $third_value\
    \ = $l[$i];\n        }\n        elsif ($third_index == $i && $l[$i] >= $third_value)\
    \ {\n            $l[$i] = $l[$third_index];\n            $l[$third_index] = $l[$i];\n\
    \        }\n    }\n    return $l;\n}", "    my $third_indicies = $#l % 3;\n  \
    \  for (my $index = $third_indicies; $index < $#l; $index++) {\n        if ($index\
    \ % 3 == 0) {\n            splice(@$l, $index, 0, splice(@$l, $index + 1, 1)[0]);\n\
    \        }\n    }\n    return $l;\n}", "    my(@l');\n    for(my $i=0; $i<@$l;\
    \ $i++) {\n        if($i % 3 == 0) {\n            push(@l', $l->[$i]);\n     \
    \   } else {\n            push(@l', $l->[$i]);\n        }\n    }\n    @l' = sort\
    \ { $a <=> $b } @l';\n    return @l';\n}", "    my @l2 = ();\n    my @temp = ();",
  "    my(@lprime, $a, $b, $c);\n    my($i, $j);", "    my(@lprime);\n    my(@lprime_2);\n\
    \    my(@lprime_3);\n    my(@lprime_4);\n    my ($i, $j, $k);\n    for ($i = 0;\
    \ $i < @$l; $i++) {\n        if (!($i % 3)) {\n            push(@lprime, $l->[$i]);\n\
    \        } elsif (!($i % 5)) {\n            push(@lprime_2, $l->[$i]);\n     \
    \   } elsif (!($i % 7)) {\n            push(@lprime_3, $l->[$i]);\n        } elsif\
    \ (!($i % 11)) {\n            push(@lprime_4, $l->[$i]);\n        }\n    }\n \
    \   for (; $i < @$l; $i++) {\n        if (!($i % 3)) {\n            push(@lprime,\
    \ $l->[$i]);\n        } elsif (!($i % 5)) {\n            push(@lprime_2, $l->[$i]);\n\
    \        } elsif (!($i % 7)) {\n            push(@lprime_3, $l->[$i]);\n     \
    \   } elsif (!($i % 11)) {\n            push(@lprime_4, $l->[$i]);\n        }\n\
    \    }\n    return @lprime;\n}\n</code>\n<|/ q dscore=3 |>\n<| c |>\nYour example\
    \ does not contain any sorting. Do you mean sorting?\n<|/ c |>\n<| c |>\nIt does\
    \ not sort the array\n<|/ c |>\n<| c |>\nThe example does not contain any sorting.\
    \ Do you mean sorting? The example doesn't contain a sort function\n<|/ c |>\n\
    <| a |>\nPerl is great at sorting and combining arrays of arbitrary elements.\
    \ You should be able to do this fairly easily:\n<code>\nuse strict;\nuse warnings;",
  "    my(@sorted);\n    \n    for my $i (0 .. $#l) {\n        my $j = $i;\n     \
    \   my $n = $i + 1;\n        while ($j > 0 && $l[$j] % 3 != 0) {\n           \
    \ splice(@sorted, $j--, 1);\n        }\n        splice(@sorted, $i, 0, $l[$i]);\n\
    \        splice(@sorted, $n, 0, $l[$n]);\n    }\n    return @sorted;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis isn't the answer to his question and shouldn't be posted\
    \ as an answer.\n<|/ c |>\n<| c |>\nI've added a comment to the question, but\
    \ I'm unsure what you're talking about \"sorted.\" Is this something your post\
    \ isn't answering? I don't see a way to fix it.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ sort the list correctly.\n<|/ c |>\n<| c |>\nYou're right, my mistake. The question\
    \ was unclear on that point. I assumed he wanted to sort the list in descending\
    \ order, which this doesn't do.\n<|/ c |>\n<| a tags=sorting,perl dscore=2 |>\n\
    The accepted answer is great, but I thought I'd add an alternative for people\
    \ who are not so familiar with Perl's sort function:\n<code>", "    my(@l2') =\
    \ ();\n    \n    my $l1 = 0;\n    my $l2 = @$l;\n    \n    while (my $i = $l1;\
    \ $i < $l2; $i++) {\n        my $sum = 0;\n        \n        foreach my $j (@$l)\
    \ {\n            next if $j == $i;\n            \n            $sum += $j;\n  \
    \          push @l2, $j;\n        }\n        \n        $l2[$i] = $sum;\n    }\n\
    \    \n    return @l2;\n}", "    my(@l') = ();\n    my $n = 0;\n    foreach my\
    \ $i (0 .. $#$l) {\n        if ($i && !($i % 3)) {\n            push(@l', $l[$i]);\n\
    \        } else {\n            $n++;\n        }\n    }\n    foreach my $i (0 ..\
    \ $#$l) {\n        if (!($i % 3)) {\n            $l[$i] = $l[$n - 1];\n      \
    \  }\n    }\n    return @l';\n}", "    my(@lprime);\n    \n    if (@$l == 0) {\n\
    \        return $l;\n    }", "    my($len) = @$l;\n    my($l2') = ();\n    for\
    \ (my $i = 0; $i < $len; $i++) {\n        if ($i % 3 != 0) {\n            $l2[$i]\
    \ = $l[$i];\n        }\n        else {\n            $l2[$i] = $l[$i];\n      \
    \  }\n    }\n    my @sorted = sort { $a <=> $b } @$l2;\n    return @sorted;\n}",
  "    my(@l') = ();", "    my($l3); # this is used to store the resulting list\n\
    \    my($l_i);\n    my($i_n);\n    my($j);", "    @$l = sort {$a <=> $b} grep\
    \ {$a % 3 == 0 && $b % 3 == 0 || $a % 3 == 0 && ! $b % 3} @$l;\n}", '    my(@l)
    = @_;', "    my(@l') = ();\n    my @inds = ();\n    for my $i (0 .. $#l){\n  \
    \      if ($i % 3 == 0){\n            push(@inds, $i);\n        }\n    }\n   \
    \ push @l', $#l, $l[$_] for @inds;\n    sort @l';\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=1 |>\n<code>\nmy = ();\nmy;\nmy $i = 0;", "    my @l2 = @{$l};\n    my\
    \ $i = 3;\n    my $j = 1;\n    for (my $i2 = $i; $i2 <= $#l; $i2++) {\n      \
    \  my $nxt = $i2;\n        my $nxt2 = $i2;\n        while ($nxt2 > $j) {\n   \
    \         $nxt2--;\n            $j++;\n        }\n        for (my $i21 = $nxt;\
    \ $i21 <= $nxt2; $i21++) {\n            if ($l[$i2] != $l[$i21] && $l[$i21] %\
    \ 3 != 0) {\n                my $temp = $l[$i2];\n                $l[$i2] = $l[$i21];\n\
    \                $l[$i21] = $temp;\n            }\n        }\n    }\n    return\
    \ @l2;\n}", "    my $sorted = 0;\n    foreach my $i (0..$#$l) {\n        next\
    \ unless $i%3 == 0;\n        if ($sorted) {\n            push @$l, $l[$i];\n \
    \       } else {\n            $l[$i] = $l[$i];\n        }\n        $sorted++;\n\
    \    }\n    return $l;\n}", "    my @result = ();\n    my $threes = 0;\n    my\
    \ @last_index = ();\n    foreach my $index (0 .. $#l) {\n        my $next_index\
    \ = index($l[$index], 3);\n        my $current_value = $l[$index];", "    my($l2')\
    \ = ();\n    my(@l3');\n    # loop over each element of l\n    foreach my $i (\
    \ 0 .. $#$l ) {\n        $l2[$i] = $l->[$i];\n    }\n    # loop over each element\
    \ of l2\n    foreach my $i ( 0 .. $#$l2 ) {\n        my($x, $y, $z) = $l2->[$i];\n\
    \        # skip the element if it is a multiple of 3\n        if( $i % 3 != 0\
    \ ) {\n            push(@l3', $z);\n            next;\n        }\n        $x =\
    \ $x + $z;\n        # handle the last element differently\n        if ( $i eq\
    \ $#l2 ) {\n            push(@l3', $x);\n        } else {\n            $y = $y\
    \ + $x;\n            push(@l3', ($y, $z));\n        }\n    }\n    return @l3';\n\
    }", "    my(@l');\n    my $num_items;\n    for my $i (0 .. @$l) {\n        my\
    \ $index = $i;\n        if ($num_items == 0 || $num_items == 3) {\n          \
    \  $l[$index] = $l[$index] % 3;\n        }\n        else {\n            push (@l',\
    \ $l[$index]);\n        }\n        $num_items = $l[$index];\n    }\n    push @l',\
    \ reverse @l';\n    return @l';\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your answer but i think you misunderstood me. I want to sort my array in\
    \ place without creating another array as your answer does.\n<|/ c |>\n<| c |>\n\
    Ah, ok. Can you just explain what you're trying to do with your current code?\
    \ You mention sorting in the comments but you also mention partitioning? It seems\
    \ like the only difference is you only want to partition on even or odd.\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere is a solution without using any array sorting.\n\
    It works by counting the number of odd and even items in the array. It then partitions\
    \ the array on the basis of this. It can be seen that all partitions end up being\
    \ of the same size, which allows us to easily sort by these values (so long as\
    \ we keep the partitions in the correct order).\n<code>", "    my(@lprime);\n\
    \    my @primes;", "    my($l') = [];", "    my(@third) = ();\n    my($i, $j,\
    \ $k, $l);\n    \n    $l = 0; \n    $l++;\n    while (!defined($l)) {\n      \
    \  $l++;\n    }\n    \n    $l++;\n    while (!defined($l)) {\n        $l++;\n\
    \    }\n    \n    $l++;\n    while (!defined($l)) {\n        $l++;\n    }\n  \
    \  \n    $l++;\n    while (!defined($l)) {\n        $l++;\n    }\n    \n    for\
    \ ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i = 0; $i <\
    \ $l; $i++) {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++) {\n\
    \        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n\
    \    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n\
    \    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i =\
    \ 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++)\
    \ {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n\
    \    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n\
    \    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i =\
    \ 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++)\
    \ {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n\
    \    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n\
    \    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i =\
    \ 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++)\
    \ {\n        $l++;\n    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n\
    \    }\n    \n    for ($i = 0; $i < $l; $i++) {\n        $l++;\n    }\n    \n\
    \    for ($i = 0; $i < $l; $i++) {", "    return () if @$l == 0;\n    my($lprime,\
    \ $lthird) = @$l[0..1];\n    push @$l, @$l[1..$#$l];\n    @$lprime = sort {$a\
    \ <=> $b} @$lprime;\n    @$lthird = sort {$a <=> $b} @$lthird;\n    return ($lprime,\
    \ $lthird);\n}", "    my(@l);\n    my($i, $j, $k);\n    \n    for(my $i = $#l;\
    \ $i >= 0; $i--) {\n        if ($l[$i] % 3 != 0) {\n            push(@l, $l[$i]);\n\
    \            splice(@l, $i, 1);\n        }\n    }\n    \n    for (my $i = $#l;\
    \ $i >= 0; $i--) {\n        for (my $j = $i + 1; $j <= $#l; $j++) {\n        \
    \    for (my $k = 0; $k < $#l; $k++) {\n                if ($l[$k] == $l[$i])\
    \ {\n                    splice(@l, $k, 1);\n                    splice(@l, $i,\
    \ 0, $l[$i]);\n                    $l[$i] = $l[$k];\n                }\n     \
    \       }\n        }\n    }\n    \n    return @l;\n}", "    my(@l') =;\n    my\
    \ $num_elems = scalar (@l');\n    my($counter, $j, $i);", "    return unless @$l\
    \ > 0;\n    my $size = $l->[0];\n    for my $i (0 .. $l->[0]-1) {\n        my\
    \ $third = $i + ($i & 1);\n        my $temp = $l->[$i];\n        my $last = $l->[$third];\n\
    \        if ($last < $temp) {\n            my $j = $i;\n            for (my $k\
    \ = $third+1; $k < $l->[0]; $k++) {\n                $l->[$k] = $l->[$k+1];\n\
    \                $j++;\n            }\n            $l->[$third] = $temp;\n   \
    \         for (my $k = $j; $k < $size; $k++) {\n                $l->[$k] = $l->[$k-1];\n\
    \            }\n        }\n    }\n    return @$l;\n}", '    my(@l);', "    my(@lprime);\n\
    \    foreach (@$l) {\n        if ($_ % 3 == 0) {\n            @lprime = sort {\
    \ $a <=> $b } grep { $a % 3 == 0 } @l;\n        } else {\n            @lprime\
    \ = @l;\n        }\n        if (@lprime != @l) {\n            push (@lprime, $_);\n\
    \        }\n    }\n    return @lprime;\n}", "    # Sort the indicies of l that\
    \ are divisible by three, while keeping the values of the indicies that are divisible\
    \ by three\n    # in place without sorting.\n    my $i = 0;\n    my $index = 0;\n\
    \    my @l2;\n    while (@$l) {\n        if ($l[$i] % 3 == 0) {\n            push\
    \ (@l2, $i);\n        }\n        $i++;\n    }\n    my $j = 0;\n    # Now sort\
    \ the indicies of l' without sorting and without changing the value of l\n   \
    \ # while iterating over the indicies in l\n    my $j2 = 0;\n    foreach my $i\
    \ (@l2) {\n        foreach my $j (@l2) {\n            if ($i != $j) {\n      \
    \          # $l[$i] and $l[$j] are both the indicies that are divisible by three\n\
    \                if ($l[$i] > $l[$j]) {\n                    $l[$j+1] = $l[$j];\n\
    \                }\n                if ($l[$i] < $l[$j]) {\n                 \
    \   $l[$j+1] = $l[$j];\n                }\n                if ($l[$i] == $l[$j])\
    \ {\n                    # $l[$i] and $l[$j] are both the indicies that are divisible\
    \ by three\n                    $j++;\n                }\n            }\n    \
    \    }\n    }\n    # Now sort the indicies of l that are divisible by three, while\
    \ keeping the values of the indicies that are divisible by three\n    # in place\
    \ without sorting.\n    my $i = 0;\n    my $index = 0;\n    my @l2;\n    while\
    \ (@$l) {\n        if ($l[$i] % 3 == 0) {\n            push (@l2, $i);\n     \
    \   }\n        $i++;\n    }\n    my $j = 0;\n    # Now sort the indicies of l'\
    \ without sorting and without changing the value of l\n    # while iterating over\
    \ the indicies in l\n    my $j2 = 0;\n    foreach my $i (@l2) {\n        foreach\
    \ my $j (@l2) {\n            if ($i != $j) {\n                # $l[$i] and $l[$j]\
    \ are both the indicies that are divisible by three\n                if ($l[$i]\
    \ > $l[$j]) {\n                    $l[$j+1] = $l[$j];\n                }\n   \
    \             if ($l[$i] < $l[$j]) {\n                    $l[$j+1] = $l[$j];\n\
    \                }\n                if ($l[$i] == $l[$j]) {\n                \
    \    # $l[$i] and $l[$j] are both the indicies that are di", "    my($third_half)\
    \ = @{$l}[0..($#l/3)];\n    my($first_half) = @{$l}[$#l/3..$#l];\n    return @$first_half.($third_half.sort);\n\
    }", "    my(@lprime);\n    my(@lprimeprime);\n    my($i);\n    my(@l);\n    my(@ll);\n\
    \    my(@llprime);\n    my(@llprimeprime);\n    my($j);\n    my(@lprime);\n  \
    \  my(@lprimeprime);\n    my($i);\n    my($j);", "    my($l);\n    my $i = 0;\n\
    \    my @indexes = ();\n    my $j = 0;", "    my @new_l;\n    \n    my @three_index\
    \ = grep(!($_ % 3), @$l);\n    \n    # Sort each non-divisible indicies\n    for\
    \ my $i (@three_index) {\n        @new_l[$i] = $l[$i];\n    }\n    \n    # Sort\
    \ remaining indicies\n    @new_l = sort {$a <=> $b} @new_l;\n    \n    return\
    \ @new_l;\n}", "    my @sorted_l = ();\n    my $last_index = 0;\n    for (my $i\
    \ = 0; $i <= @$l - 2; $i++) {\n        my $val = $l->[$i];\n        if ($i % 3\
    \ == 0) {\n            $last_index++;\n        }\n        $sorted_l[$last_index]\
    \ = $val;\n    }\n    return @sorted_l;\n}\n</code>\n<|/ a dscore=0 tags=arrays,perl,sorting\
    \ |>\n<| a dscore=0 tags=arrays,perl,sorting |>\nMy take at it:\n<code>\nuse strict;\n\
    use warnings;\nuse 5.010;", "    my $len = @$l;\n    my @sorted_l;\n    my @index_divisible_by_three;\n\
    \    my @temp_l;\n    \n    for(my $i=0; $i<$len; $i++) {\n        if($l[$i] %\
    \ 3 == 0) {\n            $temp_l[$i] = $l[$i];\n        }\n        else {\n  \
    \          push @index_divisible_by_three, $i;\n            push @sorted_l, $l[$i];\n\
    \        }\n    }\n    \n    # Add new elements from index divisible by three\n\
    \    while(@index_divisible_by_three) {\n        my $i = shift @index_divisible_by_three;\n\
    \        $sorted_l[$i] = $temp_l[$i];\n    }\n    \n    return @sorted_l;\n}",
  '    my @out;', "    my @a = sort { $a <=> $b } @$l;\n    return @a;\n}", "    my\
    \ @l = ();\n    for(my $i=0;$i<scalar(@$l);$i+=2) {\n        if($i % 3 == 0) {\n\
    \            push (@l, $l[$i]);\n            push (@l, $l[$i+1]);\n        }\n\
    \        else {\n            push (@l, $l[$i]);\n        }\n    }\n    @l;\n}",
  "    my @new_l;\n    for my $i (0 .. $#l-1) {\n        my $index = $i;\n       \
    \ while (++$index <= $#l and $l[$index] % 3 == 0) {\n            last if $index\
    \ > $i;\n        }\n        $new_l[$index] = $l[$index];\n    }\n    return @new_l;\n\
    }\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\n: Thanks for your comment. I edited\
    \ the answer to include the subroutine I wrote to do the sorting in the second\
    \ version.\n<|/ c |>\n<| c |>\n: By the way, I made a minor change to the code\
    \ that handles the case where there are multiple 3's in a row. I think that will\
    \ sort them the way you expect them to. Is that what you were looking for?\n<|/\
    \ c |>\n<| a dscore=1 |>\nI took the time to write an algorithm that can solve\
    \ this for you (I'm sure there are some edge cases left out or wrong in there)\
    \ so I thought I'd post it here.\n<code>", "    my($lprime) = @$l;\n    my $i\
    \ = 0;\n    my $count = 0;\n    my %counts = ();\n    my @new_l;\n    while($i\
    \ < @$lprime){\n        my $j = $i;\n        for(my $k = $i + 1; $k < @$lprime;\
    \ $k++){\n            if($lprime[$k] % 3 == 0){\n                if($counts{$k}\
    \ == 0){\n                    $counts{$k} = 1;\n                    push (@new_l,\
    \ $lprime[$k]);\n                }\n                else{\n                  \
    \  if($counts{$k} == $counts{$j}){\n                        $counts{$j}++;\n \
    \                   }\n                    else{\n                        $counts{$j}\
    \ = $counts{$k};\n                        push (@new_l, $lprime[$k]);\n      \
    \              }\n                }\n            }\n        }\n        $counts{$i}\
    \ = 0;\n        $i++;\n    }\n    return @new_l;\n}", "    my $llen = $#l;\n \
    \   my $tlen = @{$l};", "    my(@lprime) = ();\n    for(my $i = 0; $i < $#l; $i++)\
    \ {\n        if($i % 3 != 0) {\n            push(@lprime, $l[$i]);\n        }\
    \ else {\n            push(@lprime, $l[$i]);\n            push(@lprime, $l[$i\
    \ + 1]);\n            push(@lprime, $l[$i + 2]);\n        }\n    }\n    return\
    \ @lprime;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nUsing Perl's sort function\
    \ :\n<code>", "    my @l = ();\n    my @l_prime = ();\n    my($i, $j, $c);\n \
    \   $i = 0;\n    $j = 1;\n    for ($i = 1; $i < @$l; $i++) {\n        $c = $l[$i]\
    \ / 3;\n        if ($c != 0) {\n            push(@l_prime, $l[$j]);\n        }\n\
    \        $l[$j] = $l[$i];\n        $j++;\n        if ($c != 0) {\n           \
    \ $l[$i] = $c;\n        }\n    }\n    my $i = 0;\n    $j = 1;\n    while ($i <\
    \ $j) {\n        $c = $l_prime[$i] / 3;\n        if ($c != 0) {\n            $l[$i]\
    \ = $l_prime[$j];\n        }\n        $i++;\n        $j++;\n        if ($c !=\
    \ 0) {\n            $l_prime[$j] = $c;\n        }\n    }\n    return @l;\n}",
  "    $l[0] ||= $l[1]; # put zero in front of empty list\n    my ($i, $j);\n    $l[0]\
    \ = $l[0] || $l[1];\n    for(my $i = 1; $i <= $#l; ++$i) {\n        $j = $i;\n\
    \        while($j >= 2) {\n            next if $l[$i] == $l[$j];\n           \
    \ last if $l[$i] % 3 == 0;\n            my $x = $l[$j];\n            last if $l[$i]\
    \ % 3 == $l[$j] / 3;\n            $l[$i] = $x;\n            $j -= 1;\n       \
    \ }\n    }\n    return $l;\n}\n</code>\n<|/ a tags=sorting,perl |>\n<| c |>\n\
    Awesome! Thanks a lot for the great explanation and the helpful code sample!\n\
    <|/ c |>\n<| c |>\nThis is also a good solution, but it requires the least memory\
    \ and is somewhat complicated.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nuse warnings;\n\
    use strict;", "    my @lt = ();\n    my $tmp;\n    my $cnt = 0;\n    for my $i\
    \ (0 .. $#$l) {\n        if ($i % 3 != 0) {\n            push(@lt, $l->[$i]);\n\
    \            $tmp = $i;\n        } else {\n            $tmp = $i;\n          \
    \  ++$cnt;\n        }\n    }\n    # Now sort lt by index (using qsort) on values\n\
    \    # Note: this is already O(n) in the length of $l\n    my $ltlen = @lt;\n\
    \    my $index = 0;\n    my @sorted = ();\n    for (my $i = 0; $i < $ltlen; $i++)\
    \ {\n        $index += $lt[$i]->[0];\n        push(@sorted, $l->[$i]);\n    }\n\
    \    qsort(@sorted, $index, sub { $a->[0] cmp $b->[0] });\n    return @sorted;\n\
    }", "    my $i = 0;\n    my $j = 0;\n    my $l2 = [];\n    my $l3 = [];\n    while(@$l)\
    \ {\n        if($i eq @$l3) {\n            push @$l2, $l3[$j];\n        }\n  \
    \      elsif($j eq @$l2) {\n            push @$l3, $l2[$j];\n        }\n     \
    \   elsif($i % 3) {\n            push @$l3, $l[$i];\n        }\n        else {\n\
    \            push @$l2, $l[$i];\n        }\n        $i++;\n        $j++;\n   \
    \ }\n    return @$l2;\n}", "    my @l = ();\n    \n    my @l_prime = ();\n   \
    \ \n    for(my $i = 0; $i < @l; $i++) {\n        push (@l_prime, $l[$i] % 3);\n\
    \    }\n    \n    for(my $i = 0; $i < @l_prime; $i++) {\n        my $value = $l[$i];\n\
    \        \n        if($l_prime[$i] == 0) {\n            my $count = 0;\n     \
    \       \n            for(my $j = i; $j < @l; $j++) {\n                if($l[$j]\
    \ % 3 == 0) {\n                    $count++;\n                }\n            }\n\
    \            \n            if($count == 0) {\n                push(@l, $value);\n\
    \            }\n        } elsif($l_prime[$i] == 1) {\n            push(@l, $value);\n\
    \        }\n    }\n    \n    return @l;\n}", "    my($l') = ();\n    my($k1, $k2,\
    \ $k3);", "    my @l2 = ();\n    for(my $i = 0; $i < @$l; $i += 3) {\n       \
    \ for(my $j = 0; $j < 3; $j++) {\n            push(@l2, $l->[$i + $j]);\n    \
    \    }\n    }\n    return sort {$a <=> $b} @l2;\n}", "    my @l3 = @$l;\n    my\
    \ @l31;\n    my @l32;\n    my @l33;\n    my @l31;", "    my(@l') = ();\n    for(my\
    \ $i = 0; $i < @$l; ++$i) {\n        if($i % 3 == 0) {\n            push(@l',\
    \ @{$l->[$i]});\n        }\n        else {\n            push(@l', @{$l->[$i]});\n\
    \        }\n    }\n    return @l';\n}", "    my @l = @$l;\n    my @l2 = [];\n\
    \    my($i, $j) = @l;\n    for ($i = $j; $i < @l; $i++) {\n        my $d = $i\
    \ / 3;\n        if ($i % 3 == 0) {\n            $l2[$i] = $l[$d];\n        }\n\
    \        else {\n            push (@l2, $l[$i]);\n        }\n    }\n    return\
    \ \\@l2;\n}", "    my $len = @$l;\n    my $sorted = ();\n    my $i = 0;\n    my\
    \ $j = 0;\n    my @l = ();\n    for ($i = 0; $i < $len; $i++) {\n        $sorted[$i]\
    \ = $l->[$i];\n    }\n    for ($i = 0; $i < $len; $i++) {\n        for ($j = $i\
    \ + 1; $j < $len; $j++) {\n            my $k = $i + 1;\n            if ($j + 1\
    \ == $len) {\n                $k = @$l + 1;\n                $j = $k - 1;\n  \
    \          }\n            if ($l->[$i] % 3 != $l->[$j] % 3) {\n              \
    \  push(@l, $sorted[$k]);\n                splice(@$l, $k, 1);\n             \
    \   splice(@$sorted, $k, 1);\n                $k--;\n                $j--;\n \
    \           }\n        }\n    }\n    return @l;\n}\n</code>\n<|/ a tags=sorting,arrays,perl\
    \ |>\n<| c |>\nThis does *not* sort the elements of a subarray.\n<|/ c |>\n<|\
    \ c |>\nAs I understand it, it is sorting elements of the sub array that is being\
    \ compared, which is what the question is asking for.\n<|/ c |>\n<| c |>\nI read\
    \ the question as: \"I want to sort elements of the subarray by dividing them\
    \ into groups of 3, while leaving the other elements of the subarray in their\
    \ original order.\"  You answer sorts the subarray.  The example data shows that\
    \ your answer would leave the elements of the subarray in their original order.\n\
    <|/ c |>\n<| a tags=sorting,arrays,perl |>\nA generic solution that will sort\
    \ a list containing a mix of scalars or arrays:\n<code>", "    my @a;\n    @a\
    \ = ($l[0]) x (@l/2);\n    for(my $i = 1; $i < @l; $i++) {\n        my $third\
    \ = $l[$i/3];\n        for(my $j = $i; $j >= $i%3; $j--) {\n            my $tmp\
    \ = $a[$j];\n            $a[$j] = $a[$j-3];\n            $a[$j-3] = $tmp;\n  \
    \      }\n        $a[$i%3] = $third;\n    }\n    return @a;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
