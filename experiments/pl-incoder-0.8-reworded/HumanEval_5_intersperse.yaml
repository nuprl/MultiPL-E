name: HumanEval_5_intersperse
language: pl
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ array `numbers'\n# >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3],\
  \ 4)\n# [1, 4, 2, 4, 3]\nsub intersperse {\n    my($numbers, $delimeter) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersperse;\n\
  \        if(eq_deeply($candidate->([], 7),[])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 2], 8),[5,\
  \ 8, 6, 8, 3, 8, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([2, 2, 2], 2),[2, 2, 2, 2, 2])) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ['    my(@results);', "    my @result = (@_);\n    my $index = @_ % $#{$numbers};",
  "    return [] if @$numbers == 0;\n    my($first, $last, $firstLast) = @$numbers[0..(scalar\
    \ @$numbers-1)];\n    $first = $first || 0;\n    $last = $last || 0;\n    my @interspersedNumbers;\n\
    \    push @interspersedNumbers, $first if $first;\n    push @interspersedNumbers,\
    \ $delimeter;\n    push @interspersedNumbers, $first if $first;\n    for (my $i\
    \ = $last; $i < @$numbers; $i++) {\n        my $number = $numbers[$i];\n     \
    \   push @interspersedNumbers, $number;\n        push @interspersedNumbers, $delimeter;\n\
    \    }\n    push @interspersedNumbers, $last;\n    return @interspersedNumbers;\n\
    }", "    if ($numbers eq '') {\n        return;\n    }\n    if ($delimeter ==\
    \ 0) {\n        return $numbers;\n    }\n    my($first, $last) = (0, -1);\n  \
    \  foreach my $num (@{$numbers}) {\n        $last = $num if $last < $num;\n  \
    \      if ($last == -1) {\n            $first++;\n            $last = $num;\n\
    \        }\n        $numbers[$first..$last] = $delimeter;\n    }\n    return $numbers;\n\
    }", "    return @$numbers if @$numbers == 0;\n    return @$numbers if @$numbers\
    \ == 1;", "    $numbers =~ s/^(@{[$delimeter]})(.+?)\\1/$1$delimeter$2/g;\n  \
    \  return @$numbers;\n}", "    my @interspersed_numbers;\n    my @interspersed_elements;\n\
    \    \n    push(@interspersed_elements, $numbers[0]);\n    push(@interspersed_numbers,\
    \ $numbers[1]);\n    \n    for($i = 2; $i < @$numbers; $i++) {\n        push(@interspersed_elements,\
    \ $delimeter);\n        push(@interspersed_numbers, $numbers[$i]);\n    }\n  \
    \  \n    return @interspersed_numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nThis one\
    \ didn't work for me, but I ended up using the recursive solution by Craig Wright.\
    \ Both are great answers and thanks for posting your code!\n<|/ c |>\n<| a |>\n\
    I believe this may be what you're looking for:\n<code>", "    my(@output) = (\
    \ );\n    if (@$numbers == 0) {\n        return @output;\n    }\n    for (my $i\
    \ = 0; $i < @$numbers; $i += 2) {\n        push (@output, @{$numbers[$i..$i+1]});\n\
    \    }\n    return @output;\n}", "    $delimeter = _is_int($delimeter) ? $delimeter\
    \ : ',';\n    my @out = ();\n    for my $num (@$numbers) {\n        push @out,\
    \ $num;\n        $out[$#out + 1] = $delimeter;\n    }\n    @out;\n}", "    return\
    \ wantarray ? @$numbers : $numbers;\n}", '    my(@result) = (undef);', "    my\
    \ $delimeter = $numbers->[$delimeter] if $delimeter;\n    my $len = @$numbers;\n\
    \    return map {$numbers->[$_] =~ /^\\d+$/ ? ($delimeter.$numbers->[$_], $len+1)\
    \ : $numbers->[$_]} 0..$len-1;\n}", "    my @result = ();\n    foreach my $index\
    \ (0 .. $#$numbers) {\n        push @result, $numbers->[$index];\n        last\
    \ if $index % $delimeter == 0;\n        push @result, ($index+1 == $#$numbers)\n\
    \            ? $numbers->[$index]\n            : $delimeter;\n    }\n    return\
    \ @result;\n}", "    my @result;\n    my $i;", '    my($result);', "    my $result\
    \ = $delimeter;\n    $result = $result . join($delimeter, $numbers) unless @$numbers\
    \ > 1;\n    $result;\n}", "    my @numbers_split = @$numbers;\n    my $numbers_count\
    \ = @numbers_split;\n    my @output = (0);\n    while (my $count = () = grep {\
    \ $_ } @numbers_split) {\n        if ($numbers_count != 1) {\n            splice,\
    \ @output, 0, $count;\n        }\n        push, @output;\n        $numbers_count\
    \ -= $count;\n    }\n    return @output;\n}", "    my $ret = $numbers[0];\n  \
    \  if (@$numbers > 1) {\n        for my $i (1 .. @$numbers - 1) {\n          \
    \  $ret .= $delimeter;\n            $ret .= $numbers[$i];\n        }\n    }\n\
    \    return $ret;\n}", "    my @numbers_ref;\n    my $delimeter_ref =  \\$delimeter;\n\
    \    foreach my $num (@$numbers) {\n        $numbers_ref->[$numbers_ref->[-1]\
    \ + 1] = $num;\n        push @numbers_ref, $numbers_ref->[-1];\n    }\n    return\
    \ @$numbers_ref;\n}\n</code>\n<|/ a tags=arrays,perl |>\n<| a |>\nThis solution\
    \ assumes your input is not sorted.  A more general solution would be a function\
    \ that would take a function and an array, and apply it to each element of the\
    \ array, passing each element as a parameter to the function.  In other words,\
    \ the function would act like a map, but operated on arrays.\n<code>", '    my
    @numbers;', "    if (@_ == 1) {\n        $delimeter = pop @_;\n    }\n    @$numbers\
    \ = map( {\n        $delimeter\n        } @$numbers);\n    return @$numbers;\n\
    }", "    return map {\n        push @$numbers, $_;\n        $_;\n    } (@$numbers);\n\
    }\n</code>\n<|/ a dscore=2 tags=arrays,perl,interleave |>\n<| a |>\nThis is an\
    \ example of using map! to modify an array.\n<code>\nuse strict;\nuse warnings;\n\
    use Data::Dump qw(dump);", '    my @results;', "    @$numbers = 0 .. $#$numbers;\n\
    \    my @result = ();\n    while (@$numbers) {\n        push @result, shift @$numbers;\n\
    \        unshift @$numbers, $delimeter;\n    }\n    return @result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>", "    my $i = 0;\n    my $len = $#$numbers;\n\
    \    while (--$i < $len) {\n        yield $numbers[$i];\n        yield $delimeter;\n\
    \    }\n    return 1;\n}", "    $delimeter ||= '|'; # default delimeter is a pipe\
    \ character\n    my($result) = ();\n    my($tmp, @tmp) = @$numbers;\n    foreach\
    \ my $idx (1..$#numbers) {\n        push(@$result, $tmp[$idx]);\n        push(@tmp,\
    \ $tmp[$idx] . $delimeter);\n    }\n    splice(@$result, 0, @tmp);\n    wantarray\
    \ ? @$result : $result[0];\n}\n</code>\nTo test your routines, you can then use\
    \ the following:\n<code>\nuse strict;\nuse warnings;", "    @$numbers = map {\n\
    \        chomp;\n        my = split;\n        unshift(@split, $delimeter) for;\n\
    \        @split;\n    } @$numbers;\n    return @$numbers;\n}", "    my(@result,);\n\
    \    for(my $i = 0; $i < scalar(@$numbers); $i++) {\n        push(@result,\n \
    \           $numbers->[$i] unless $i && ((@result % 2) == 0);\n        push(@result,\
    \ $delimeter) unless $numbers->[$i] == 1;\n    }\n    join('', @result);\n}\n\
    </code>\n(I only have Perl v5.10 and I can't test it right now - hopefully it\
    \ compiles).\nThis should work even for arrays of arrays of arrays, etc. Also,\
    \ it can be modified to accept an array of characters or even an array of hashes\
    \ if you're so inclined.\n<|/ a |>\n<| a |>\n<code>", "    if ($numbers) {\n \
    \       my $ret = '';\n        for my $i (0..$#$numbers) {\n            my ($start,\
    \ $end) = @{ $numbers->[$i] };\n            $ret .= $start if $start && $end;\n\
    \            $ret .= $delimeter;\n        }\n        return $ret;\n    }\n   \
    \ return '';\n}", '    $numbers =~ s/^(?:\s*)//;', "    my @result;\n    my $i\
    \ = 0;\n    foreach my $element (@$numbers) {\n        $result[$i++] = $element;\n\
    \        if ($i < @$numbers) {\n            $result[$i++] = $delimeter;\n    \
    \    }\n    }\n    return @result;\n}", "    $delimeter = 0 unless defined $delimeter;\n\
    \    return unless @$numbers > 0;\n    $numbers[0] = $delimeter if !defined $numbers[0];\n\
    \    $delimeter = defined $delimeter ? $delimeter : \"\";\n    return map {$_\
    \ || $delimeter} @$numbers;\n}", "    my $i = 0;\n    my @result = ();\n    while\
    \ ($i < @$numbers) {\n        push @result, $numbers[$i];\n        $i += $delimeter;\n\
    \    }\n    return @result;\n}", "    return unless @$numbers;\n    $delimeter\
    \ = _ifdef($delimeter);\n    $delimeter .= \"$\" unless $delimeter =~ /\\z/;\n\
    \    my $last_number = pop @$numbers;\n    $last_number .= \"$delimeter\" if @_\
    \ and $last_number =~ /$delimeter/;\n    push(@$numbers, $last_number);\n    return\
    \ @$numbers;\n}", "    return @$numbers if scalar @$numbers == 0;\n    my @interspersed\
    \ = ();\n    for (my $i = 0; $i < scalar @$numbers; $i++) {\n        push @interspersed,\
    \ $delimeter;\n        push @interspersed, $numbers->[$i];\n    }\n    return\
    \ @interspersed;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nVery impressive! I\
    \ love this solution. My only concern is that it's pretty verbose. Can you think\
    \ of a shorter version of this that uses fewer lines?\n<|/ c |>\n<| c |>\nHaving\
    \ seen that I have accepted the other answer. I was just hoping for something\
    \ that doesn't involve nested loops and thus is easier to understand.\n<|/ c |>\n\
    <| c |>\n- I like how `join` works in this case.  So much shorter! :)\n<|/ c |>\n\
    <| c |>\nI love that `join` works like this! Thank you so much! I went with the\
    \ other solution because it was simpler.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    use Data::Dumper;", "    my @new_numbers;\n    for (@$numbers) {\n        push\
    \ @new_numbers, $_; \n        if ($new_numbers[-1] eq $delimeter) {\n        \
    \    push @new_numbers, $delimeter;\n        }\n    }\n    return @new_numbers;\n\
    }", "    my @result = ();\n    my $i = 0;\n    my $size = @$numbers;\n    while\
    \ ($i < $size) {\n        $result[$i] = $numbers[$i];\n        $i++;\n       \
    \ if ($i < $size) {\n            $result[$i] = $delimeter;\n            $i++;\n\
    \        }\n    }\n    return @result;\n}", "    my $result;\n    my @interspersed\
    \ = ();\n    for (@$numbers) {\n        if (scalar @interspersed == 0) {\n   \
    \         push @interspersed, $_;\n        }\n        else {\n            push\
    \ @interspersed, $delimeter;\n            push @interspersed, $_;\n        }\n\
    \    }\n    return @interspersed;\n}", "    return () unless @$numbers > 1;\n\
    \    return @$numbers if @$numbers == 1;\n    my @numbers = @$numbers;\n    my\
    \ ($last, $rest) = splice @$numbers, 0, 2;\n    my @result = ();\n    for (@numbers)\
    \ {\n\tpush @result, $last . $delimeter . $_;\n\t$last = $_;\n    }\n    return\
    \ @result;\n}", "    return $numbers if not $numbers;\n    my $result = $numbers[0];\n\
    \    if (@$numbers > 1) {\n        my $last = $numbers[-1];\n        for my $number\
    \ (@$numbers[1..$#$numbers-1]) {\n            $result .= $delimeter . $number;\n\
    \        }\n        $result .= $delimeter . $last;\n    }\n    return $result;\n\
    }", "    my @numbers = @$numbers;\n    my @output;", "    my @result;\n    my\
    \ $i = 0;\n    while(@$numbers) {\n        if($i++ % $delimeter == 0) {\n    \
    \        push(@result,$numbers[$i-1]);\n        }\n        push(@result, $_) for\
    \  @$numbers;\n    }\n    return @result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=perl,perl-data-structures |>\nI think that the following would be the most\
    \ efficient way to do this in Perl 5.8.\n<code>", '    return () unless @$numbers;',
  "    my @result;\n    push(@result,@$numbers); # first element\n    for(my $i =\
    \ 0; $i < @$numbers; $i++) {\n        my $tmp = $numbers[$i];\n        unshift(@result,$tmp);\n\
    \        unshift(@result,$delimeter);\n    }\n    push(@result,@$numbers); # last\
    \ element\n    pop(@result);\n    return @result;\n}", "    my @intersp;\n   \
    \ my $prev = $numbers[0];\n    my $i;", "    return grep {$_ ne $numbers[-1]}\
    \ @$numbers if $delimeter;\n    return map {$_} @$numbers if @$numbers == 1;\n\
    \    my($begin, $end) = ($numbers[0], $numbers[-1]);\n    my $interspersed_array\
    \ = map {$delimeter+$_} @$numbers[$begin..$end-1];\n    $interspersed_array =\
    \ $delimeter+$interspersed_array if $delimeter;\n    return $interspersed_array;\n\
    }", "    my @result = ();\n    my $i = 0;\n    while(my $number = $numbers[$i])\
    \ {\n        push @result, $number; # Accumulate number in result array\n    \
    \    push @result, $delimeter; # Accumulate delimeter in result array\n      \
    \  shift @numbers; ++$i; # Remove first element from numbers array because we\
    \ already added number in result array\n    }\n    return @result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=2 |>\nI needed to split a string by a delimiter\
    \ that could potentially appear in the middle of a single element, so I used a\
    \ regex that could split on either a comma or a period, but didn't want to lose\
    \ the delimiter in the first element of the list.  \n<code>\nmy = split /(?<!\\\
    d)((?:[,.]|$)|\\s)(?!\\d)/, $text;\n</code>\n<|/ a tags=arrays,perl |>\n<| a dscore=2\
    \ tags=arrays,perl |>\nI wrote a sub called \"intersperse\" that accepts a list\
    \ and an optional separator. It returns the list with the separator inserted between\
    \ the list elements. In other words, it is the opposite of \"interleave\".\n<code>",
  '    my @interspersed_numbers;', '    my @return = ();', "    my $n = @$numbers;\n\
    \    my $res = @$numbers;\n    my @temp;\n    my $i = 0;\n    while( $i < $n )\
    \ {\n        push @temp, $numbers[$i];\n        $i++;\n        if ( $i < $n )\
    \ {\n            push @$res, pop @temp;\n            push @$res, pop @$numbers;\n\
    \            push @$res, pop @$numbers;\n        }\n    }\n    return @$res;\n\
    }", "    $delimeter++ while $delimeter != 0;\n    my @interspersed = ();\n   \
    \ push(@interspersed, @$numbers) while @$numbers;\n    @numbers = @interspersed;\n\
    \    return @numbers;\n}", "    $delimeter = -1 unless $delimeter;\n    my @result\
    \ = ();\n    my $len = @$numbers;\n    my $i = 1;\n    my $delim_idx = 0;\n  \
    \  my $max_len = scalar(@$numbers);\n    while($i < $len) {\n        my $tmp =\
    \ $numbers[$i];\n        my $tmp_id = $$tmp;\n        if ($delim_idx < $max_len)\
    \ {\n            $result[$delim_idx++] = $tmp;\n        }\n        elsif($delim_idx\
    \ < $delimeter + 1) {\n            $result[$delim_idx++] = $delimeter;\n     \
    \   }\n        $result[$delim_idx++] = $tmp_id;\n        $i++;\n    }\n    return\
    \ @result;\n}\n</code>\nAnd now we have this:\n<code>", '    my @result = ();',
  "    my();\n    my $i = 1;\n    for my $num (@$numbers) {\n        push(@output,\
    \ exists $delimeter[$i++] ? $delimeter[$i-1] : '');\n        push(@output, $num);\n\
    \    }\n    return \\@output;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like\
    \ this one a lot, but I'd consider it slightly buggy if you don't check that you\
    \ don't go out of bounds.\n<|/ c |>\n<| c |>\nWhy do you think so? If array contains\
    \ only one element then there is no need to add any delimiter, and if it has more\
    \ than one element then delimiter is required.\n<|/ c |>\n<| c |>\nIf `@numbers`\
    \ has only one element, then `$i` will equal 0, and the `exists $delimeter[$i++]`\
    \ test will always be false, so the output array will end up being one element\
    \ long.\n<|/ c |>\n<| c |>\nAh, of course. Thanks.\n<|/ c |>\n<| a dscore=2 |>\n\
    One more for you - Perl 5.10 - using regular expressions ($number has to be a\
    \ scalar to work):\n<code>\nmy $number = 4;\nmy = (1, 4, 8, 4, 9, 1, 4, 1, 4,\
    \ 3, 1);\nmy = ( '' );\nfor (my $i = 0; $i <= $#numbers; $i++) {\n    push(@newOutput,\
    \ join( ',' , @{ $output[ $i ] }, $numbers[$i] ) );\n}\n</code>\n<|/ a tags=arrays,perl,string\
    \ |>\n<| a dscore=2 tags=arrays,perl,string |>\nHere's another way using join:\n\
    <code>", "    my @numbers_ref;\n    if (ref $numbers) {\n        push @numbers_ref,\
    \ $numbers;\n    } else {\n        @numbers_ref = \\@numbers;\n    }\n    \n \
    \   my @result = ();\n    for (my $i = 0; @numbers_ref && $i < @$numbers_ref;\
    \ $i += 2) {\n        push(@result, $delimeter) unless $numbers_ref[$i];\n   \
    \     push(@result, @{$numbers_ref[$i]})\n    }\n    \n    return @result;\n}",
  "    my @result;\n    for (@_) {\n        push(@result, $_) if ($_);\n        push(@result,\
    \ $delimeter) if (@result and $_);\n    }\n    return @result;\n}", "    return\
    \ map {$delimeter x $numbers->[$_]} 0 .. $numbers->[-1] - 1;\n}", "    my @ret;\n\
    \    my $last = @$numbers - 1;\n    for(my $i = 0; $i <= $last; $i++) {\n    \
    \    push(@ret, $numbers[$i], $delimeter) unless $i == $last;\n        push(@ret,\
    \ $numbers[$i])\n    }\n    return @ret;\n}\n</code>\n<|/ a tags=perl,arrays,slice\
    \ |>\n<| c |>\nA very nice solution, thank you. Just a comment, `sub` shouldn't\
    \ be followed by brackets.\n<|/ c |>\n<| c |>\nThis doesn't work correctly for\
    \ arrays of length 1. It will return `[0]`, when `1` should be returned.\n<|/\
    \ c |>\n<| a tags=perl,arrays,slice |>\nYou could use join():\n<code>\nprint join\
    \ \"|\", [ grep !($i%2), @$numbers ];\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n\
    use List::Util qw( natatime );", "    if ($delimeter) {\n        my $last = pop($numbers);\n\
    \        my $i = 1;\n        while (@$numbers) {\n            $numbers[$i++] =\
    \ $delimeter;\n            $numbers[$i] = $last unless $numbers[$i];\n       \
    \     $last = pop($numbers);\n        }\n    } else {\n        @$numbers = map\
    \ {$_ + 1 } @$numbers;\n    }\n    @$numbers;\n}", "    $delimeter = ref $delimeter\
    \ ? @$delimeter : $delimeter;\n    my $size = @$numbers;", "    return () unless\
    \ @$numbers;\n    my(@result) = ();\n    for (@$numbers) {\n        my($el) =\
    \ @_;\n        if (@result and $result[-1] eq $el) {\n            @result[-1]\
    \ = $result[-1] .$delimeter;\n        } else {\n            @result = ($el);\n\
    \        }\n    }\n    return @result;\n}", "    my($last) = 0;\n    my(@output)\
    \ = (1);", "    $delimeter = '' if !defined($delimeter);\n    my @output = (0)\
    \ x (scalar(@$numbers) - 1);\n    my $i = scalar(@$numbers) - 1;\n    for(my $i\
    \ = 0; $i < scalar(@$numbers); $i ++) {\n        $output[$i] = $numbers[$i] if\
    \ $i && !($i + 1) % $delimeter;\n    }\n    return @output;\n}", "    my @numbers_copy;\n\
    \    $delimeter = 0 unless defined $delimeter;\n    my @result = ();\n    my @prev_elements\
    \ = ();\n    for(my $numbers_i = 0; $numbers_i < scalar(@$numbers); $numbers_i\
    \ += 1) {\n        my @current_elements = @$numbers[$numbers_i];\n        my @new_elements\
    \ = ();\n        for(my $i = 0; $i < scalar(@prev_elements); $i += 1) {\n    \
    \        push(@new_elements, $prev_elements[$i].$delimeter);\n        }\n    \
    \    push(@new_elements, @current_elements);\n        push(@prev_elements, @current_elements);\n\
    \        push(@result, @new_elements);\n    }\n    return @result;\n}", "    my\
    \ $length = @$numbers;\n    my @output = ($delimeter);", '    my @numbers_copy
    = @$numbers;', "    my(@numbers, $first);\n    my @res;", "    my $i = 0;\n  \
    \  my $n   = $numbers->[0];\n    $n = $numbers[$i]; $i++;\n    $n = $numbers[$i];\
    \ $i++;\n    return unless $i && $i <= $#$numbers;\n    $numbers->[$i..$#$numbers]\
    \ = map {\n        $n = $numbers[$i++];\n        defined $delimeter ? $n . $delimeter\
    \ : $n;\n    };\n}", '    my @result = ();', "    $numbers[0] = undef;\n    my\
    \ $result = $delimeter;\n    for my $i (0 .. @$numbers-1) {\n        my $j = $i\
    \ + 1;\n        $result = $numbers[$i].\" \".$result;\n        $result = $numbers[$j].\"\
    \ \".$result;\n    }\n    return $result;\n}", "    $delimeter = \" \" x $delimeter;\n\
    \    my $i = 0;\n    my $j = 0;\n    my @result;", '    my @ret;', "    my(@results);\n\
    \    my @last_element;", "    $numbers = [@$numbers]; # make mutable\n    my @result\
    \ = ();\n    while (@$numbers) {\n        my $elem = shift(@$numbers);\n     \
    \   push(@result, $elem);\n        push(@result, $delimeter) if @$numbers;\n \
    \   }\n    @$numbers;\n}", "    my @result;\n    $delimeter = defined $delimeter\
    \ ? $delimeter : ',';\n    push @result, @$numbers;\n    for my $i ( 0 .. $#$numbers\
    \ ) {\n        $result[$i] = $numbers[$i];\n        $result[$i + 1] = $delimeter\
    \ unless $i && $i < ($#$numbers - 1);\n    }\n    return @result;\n}", "    my(@results);\n\
    \    # if the array is empty\n    return @results unless @$numbers;", "    my\
    \ @interspersed_numbers;\n    \n    my $delimeter_index;\n    for my $number (@$numbers)\
    \ {\n        if ($delimeter_index) {\n            push @interspersed_numbers,\
    \ $number unless $delimeter_index % 2;\n        }\n        elsif ($delimeter)\
    \ {\n            push @interspersed_numbers, $number;\n            $delimeter_index++;\n\
    \        }\n    }\n    return @interspersed_numbers;\n}", '    my($result);',
  '    my @result;', "    return () unless @$numbers;\n    my @intermediate = ();\n\
    \    for my $i (0 .. $#$numbers - 1) {\n        push @intermediate, join($delimeter,\
    \ @{$numbers[$i, $i+1]});\n    }\n    return @intermediate;\n}", "    my $result\
    \ = \"\";\n    foreach my $i (@$numbers) {\n        $result .= $delimeter;\n \
    \       $result .= $i;\n    }\n    return $result;\n}\n</code>\nThe $delimeter\
    \ is the variable you assign the interspersed elements to - so if you had a list\
    \ that looked like \"1, 2, 3, A, B, C, D\" then you'd assign $delimeter to \"\
    ,\" and the output would then be \"1, 2, 3, A,, B, C, D\"\n<|/ a dscore=1 |>\n\
    <| a tags=perl,arrays,sorting |>\n<code>", '    $delimeter = 0 if $delimeter ==
    0;', "    @$numbers = map { $delimeter.$_ } (@$numbers);\n    return @$numbers;\n\
    }\n</code>\n<|/ a dscore=1 tags=perl,arrays |>\n<| c |>\nI like this approach.\
    \ Thanks!\n<|/ c |>\n<| a tags=perl,arrays |>\n<code>", "    my $i = @$numbers;\n\
    \    return $numbers[$i] if $i && @$numbers > 0;\n    return [];\n}", '    my($result,
    $num, $ii, $jj, @tmp);', "    \n    if(!defined $delimeter) {\n        $delimeter\
    \ = '';\n    }\n    \n    my(@result) = ();\n    for(my $i = 0; $i < @$numbers;\
    \ $i++) {\n        push(@result, $delimeter)\n            if(defined $i && $i\
    \ <= $#{ $numbers - 1 });\n        push(@result, $numbers[$i])\n            if(defined\
    \ $i && $i && !$i && $i <= $#{ $numbers - 1 });\n    }\n    return @result;\n}",
  "    if ($numbers == 1) {\n        return $numbers;\n    }\n    else {\n       \
    \ my $size = @$numbers;\n        my $result = [];\n        for (my $i = 0; $i\
    \ < $size; $i++) {\n            push @$result, $numbers[$i] if $i != 0;\n    \
    \        push @$result, $delimeter;\n        }\n        return @$result;\n   \
    \ }\n}", "    my($output, $count) = $numbers->();\n    my $i = 0;\n    while(@$numbers)\
    \ {\n        $output->[$i] = $numbers->[$i];\n        $i += 1;\n        $numbers->[$i]\
    \ = $delimeter;\n        $i += 1;\n    }\n    @$numbers = @$output;\n    return\
    \ wantarray ? @$numbers : $output;\n}", "    my @result;\n    $delimeter++ while\
    \ @$numbers; # increment by 1 each time we see a 'delimeter'\n    push @result,[sort\
    \ @$numbers], @$numbers; # push the interspersed numbers onto result stack\n \
    \   pop @$numbers while @$numbers; # remove them from the input array\n    return\
    \ @result;\n}", "    my @result = ();\n    my $i = 0;\n    for(my $j = 0; $j <\
    \ @$numbers; $j++) {\n        push (@result, $numbers->[$j]);\n        push (@result,\
    \ (defined($delimeter)) ? $delimeter->[$i] : $delimeter);\n    }\n    return @result;\n\
    }", "    my(@result) = ();\n    for(my $i = -1; $i < @$numbers; $i += 2) {\n \
    \       $result[$i + 1] = $delimeter . $numbers[$i] . $delimeter;\n    }\n   \
    \ return @result;\n}", "    map {\n        my $c = $_;\n        $c if !defined\
    \ $c || $c eq $delimeter;\n        $_ = $numbers[-1] if defined $numbers[-1];\n\
    \        $numbers[-1] = $c;\n    } (@$numbers);\n    return @$numbers;\n}", '    return
    unless @$numbers > 0;', "    my @new_numbers;\n    my $current_delimeter = \"\"\
    ;\n    foreach my $number (@$numbers) {\n        $current_delimeter = $current_delimeter\
    \ . $delimeter;\n        if ($number != 0) {\n            push(@new_numbers, $number);\n\
    \        }\n        push(@new_numbers, $current_delimeter);\n    }\n    return\
    \ @new_numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does not answer\
    \ the question.  It doesn't demonstrate how to put a number between every two\
    \ consecutive elements.  It also does not demonstrate how to do that with arbitrary\
    \ delimiters.\n<|/ c |>\n<| c |>\nYes, it does.  I wrote that right after you\
    \ wrote your comment.\n<|/ c |>\n<| c |>\nThis does not use any delimiters other\
    \ than spaces, which is what OP requested.  However, I agree it would be much\
    \ easier to simply use spaces.\n<|/ c |>\n<| c |>\nThank you for commenting on\
    \ my answer.  I fixed my answer to use the correct delimiter.  I still don't think\
    \ this is good code; it seems more complex than it should be.  I added an example\
    \ to my answer to demonstrate its use.\n<|/ c |>\n<| c |>\nThe other problem is\
    \ that this isn't a subroutine.  It's an adverb (`&`).  In Perl, the adverb operator\
    \ binds tighter than any other operator, so it would be better to use a sub instead\
    \ of a subroutine.\n<|/ c |>\n<| a dscore=0 |>\nI think this would be a lot easier\
    \ to do with substr and splice, but it's not hard to write a sub that works:\n\
    <code>", "    my $result = \"\";\n    for (@$numbers) {\n        $result .= $delimeter;\n\
    \        $result .= $_;\n    }\n    return $result;\n}", "    $delimeter = 0 if\
    \ $delimeter == 0;\n    my(@result) = ();\n    foreach my $number (@$numbers)\
    \ {\n        push(@result, $number);\n        if ($number ne $delimeter) {\n \
    \           push(@result, $delimeter);\n        }\n    }\n    wantarray ? @result\
    \ : $result[0];\n}\n</code>\n<|/ a dscore=3 tags=perl,list,arrays |>\n<| c |>\n\
    \"Avoid loops\" is a bit unclear.  I agree that while loops are more readable,\
    \ a for loop with an increment statement is much more concise and readable.  It\
    \ should be noted that while loops are faster than foreach loops, and so if speed\
    \ is an issue, they should be used.\n<|/ c |>\n<| c |>\nI understand what you're\
    \ saying. But this doesn't add anything to the answer. Besides that, while loops\
    \ are slower than foreach loops, a foreach loop also uses more memory, and while\
    \ loops require a test on every iteration to see whether it is the last one, so\
    \ they require more memory. Using a for loop requires the same number of iterations,\
    \ just that it's much faster. While loops also require more memory, but in a for\
    \ loop, since we're incrementing `$i` manually, we know the count of the array,\
    \ which we can also use to know how much memory is needed.\n<|/ c |>\n<| c |>\n\
    I agree that for loops should be used unless you need speed, as they are faster\
    \ than foreach loops, which is why I added them to the answer. Your concern about\
    \ memory is true, but I didn't consider that in my answer. If you think you have\
    \ a better answer, please post it. I'd appreciate it.\n<|/ c |>\n<| a tags=perl,list,arrays\
    \ |>\nFor this sort of thing, it is usually better to avoid the extra layer of\
    \ an array, and go with the for loop.\n<code>", "    if(scalar @$numbers == 0)\
    \ {\n        return;\n    }\n    my(@numbers) = @_;\n    my @result;", "    my\
    \ $count = -1;\n    my @result = ();\n    foreach (@$numbers) {\n        ++$count;\n\
    \        push @result, (defined $delimeter) ? ($count - 1) * $delimeter + $_ :\
    \ $_;\n    }\n    return @result;\n}", "    my $n = @$numbers;\n    my = ();",
  "    return [] if @$numbers == 0;\n    my @result = ();\n    my $i = $#$numbers;\n\
    \    while (--$i) {\n        my $first = $#$numbers == 0 ? undef : $numbers[$i];\n\
    \        push @result, $first == $i ? $first : $delimeter . $first;\n    }\n \
    \   return @result;\n}", "    my @return = ();\n    if ($numbers) {\n        $numbers[-1]\
    \ .= $delimeter;\n        for my $number (@$numbers) {\n            push @return,\
    \ $number if ($number != last);\n            push @return, $delimeter if ($number\
    \ == last);\n        }\n    }\n    return wantarray ? @return : $return[0];\n}",
  "    $delimeter = defined $delimeter ? $delimeter : ',';\n    my@numbers = @{$numbers};\n\
    \    my;\n    my $last = 0;\n    for my $i (0 .. $#numbers) {\n        my $this_number\
    \ = $numbers[$i];\n        if ($i != ($last + 1)) {\n            push, $this_number\
    \ . $delimeter;\n        }\n        push, $this_number;\n        $last = $i;\n\
    \    }\n    return wantarray ? @numbers : \\@numbers;\n}\n</code>\n<|/ a |>\n\
    <| a tags=perl,arrays,subroutine |>\nYou can use a hash to group the elements\
    \ by value:\n<code>\nmy = qw(foo bar baz qux quux corge);", "    my @new_numbers\
    \ = ();\n    my $current_number = 0;\n    foreach my $num (@$numbers) {\n    \
    \    if($current_number) {\n            push @new_numbers, $delimeter;\n     \
    \   }\n        push @new_numbers, $num;\n        $current_number = 1;\n    }\n\
    \    return @new_numbers;\n}", "    my @result;\n    my($i, $j) = @$numbers;\n\
    \    while (@$numbers) {\n        $i--;\n        $j++;\n        if ($j == @$numbers)\
    \ {\n            push(@result, $numbers[$i]);\n        }\n        else {\n   \
    \         push(@result, $delimeter, $numbers[$i], $numbers[$j]);\n        }\n\
    \    }\n    return @result;\n}", "    @$numbers = map { (@_ == 1) ? $delimeter\
    \ : $_ } @$numbers;\n    return @$numbers;\n}", "    my @numbers_copy = @$numbers;\n\
    \    $delimeter = 0 if $delimeter == 0;\n    my @interspersed_array = ();\n  \
    \  my @interspersed_numbers = ();\n    foreach my $number ( @numbers_copy ) {\n\
    \        if ( $number == $delimeter ) {\n            push (@interspersed_numbers,\
    \ $number);\n        }\n        else {\n            push (@interspersed_numbers,\
    \ $number);\n            push (@interspersed_array, $interspersed_numbers);\n\
    \            push (@interspersed_numbers, $delimeter);\n        }\n    }\n   \
    \ return @interspersed_array;\n}", "    my @interspersed_numbers;\n    my $delimeter_length\
    \ = length($delimeter);\n    foreach my $n (@{$numbers}) {\n        if ($delimeter_length\
    \ > 0) {\n            push (@interspersed_numbers, $n);\n            push (@interspersed_numbers,\
    \ $delimeter);\n        } else {\n            push (@interspersed_numbers, $n);\n\
    \        }\n    }\n    return @interspersed_numbers;\n}", "    my @interspersed_numbers;\n\
    \    my $i = 0;\n    while( $i < @$numbers ) {\n        $interspersed_numbers->[$i]\
    \ .= $numbers[$i];\n        $i += $delimeter;\n    }\n    $interspersed_numbers;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNote that this solution doesn't work with\
    \ arrays of size > 2.\n<|/ c |>\n<| c |>\nYou should not call a subroutine \"\
    intersperse\" if you expect it to be a method. Methods in Perl are just subroutines\
    \ that return a value. They shouldn't be named intersperse. That's what methods\
    \ are for.\n<|/ c |>\n<| c |>\n: You're right - that's how I tend to think about\
    \ intersperse now. But I believe it makes the code easier to understand by calling\
    \ it intersperse_with_n...\n<|/ c |>\n<| a dscore=5 |>\nJust for the heck of it,\
    \ here's a way using map in Perl6:\n<code>", "    my($result);\n    \n    my @first_two_numbers\
    \ = @$numbers;\n    \n    if(@first_two_numbers <= 1){\n        return $numbers;\n\
    \    }\n    \n    for my $i (0 .. $#first_two_numbers) {\n        my $first_number\
    \ = $first_two_numbers[$i];\n        my $second_number = $first_two_numbers[$i\
    \ + 1];\n        \n        $result .= $first_number;\n        \n        if ($i\
    \ < ($#first_two_numbers - 1)) {\n            $result .= $delimeter;\n       \
    \ }\n        \n        $result .= $second_number;\n    }\n    \n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl,arrays,split |>\n<code>", "    my\
    \ @results;\n    my $i = 0;\n    for (@$numbers) {\n        if ($i == 0) {\n \
    \           $results[$i++] = $_;\n        }\n        else {\n            push(@results,\
    \ $delimeter, @_, $delimeter);\n        }\n    }\n    return @results;\n}", " \
    \   return unless @$numbers;\n    my @output = ();\n    my $last = 0;\n    $delimeter\
    \ = ' ' unless $delimeter;\n    foreach (@$numbers) {\n\tif ($last) {\n\t    push\
    \ @output, $last;\n\t    $last = 0;\n\t}\n\tpush @output, $_;\n\t$last = $_;\n\
    \    }\n    push @output, $last if $last;\n    return @output;\n}", "    $delimeter++\
    \ if @_ > 2;\n    my @interspersed = ();\n    for my $number (@$numbers) {\n \
    \       push @interspersed, $number + $delimeter;\n    }\n    return @interspersed;\n\
    }", "    my;\n    my $last = -1;\n    my $i = 0;", "    my;\n    foreach (@$numbers)\
    \ {\n      push, $_ if $_;\n      push, $delimeter;\n    }\n    return;\n}", " \
    \   return ()\n        unless scalar(@$numbers) > 0;", "    \n    my(@numbers_with_delimeter\
    \ = ());\n    \n    # Iterate over array `numbers'\n    for (@$numbers) {\n  \
    \      # Append current number to a temporary array\n        push(@numbers_with_delimeter,\
    \ [$_]);\n        \n        # If current number is not last in the array, \n \
    \       # append `delimeter' between last two numbers\n        if (@numbers_with_delimeter\
    \ > 1) {\n            push(@numbers_with_delimeter, [$delimeter]);\n        }\n\
    \    }\n    \n    return @numbers_with_delimeter;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| a dscore=3 |>\nHere's another take on it, which uses List::Util's pairs\
    \ function:\n<code>\nuse List::Util qw(pairs);\nmy;\npush, [ map { $_ } map {\
    \ $a++ % 2 ? ( $b, $b ) : ( $b, $b . $a ) } pairs ]\n</code>\nHere's a test:\n\
    <code>\nuse Test::More tests => 3;", "    return map { $_ ? ( 0 + $delimeter +\
    \ $_) : $_ } @$numbers;\n}", "    my @nums = @$numbers;\n    my @newnums = ();\n\
    \    my $i = 0;", "    if (@$numbers == 0) {\n        []\n    }\n    else {\n\
    \        my @a = ();\n        my $i = 0;\n        while (@$numbers) {\n      \
    \      my $tmp = $numbers[0];\n            @a = ();\n            push @a, $tmp;\n\
    \            $i++;\n            splice, 0, 1, $tmp;\n            if ($i < @$numbers)\
    \ {\n                my $delim = $delimeter;\n                splice @$numbers,\
    \ $i++, 1, $delim;\n            }\n        }\n        @a;\n    }\n}", "    my($result)\
    \ = [];\n    my (@result) = ();\n    if (@$numbers) {\n        my $last_number\
    \ = shift @$numbers;\n        push @result, $last_number;\n        @$numbers =\
    \ ();\n        foreach (@$numbers) {\n            push @result, shift;\n     \
    \       push @result, $delimeter;\n        }\n        push @result, $last_number;\n\
    \    }\n    return @result;\n}", "    my(@numbers) = @_;\n    my @output = ();\n\
    \    if (@numbers == 0) {\n        return @output;\n    }\n    # Get the size\
    \ of array\n    my $size = @numbers;\n    # Iterate the array\n    for (my $i\
    \ = 0; $i < $size; $i++) {\n        # Set the default delimiter\n        my $delimeter\
    \ = ($i != 0) ? $delimeter : '';\n        # Append the element to the output\n\
    \        push(@output, $numbers[$i] . $delimeter);\n    }\n    # Return output\n\
    \    return @output;\n}", "    my @result;\n    my $i = 0;", '    my $result =
    shift;', "    my @result = ();\n    my @remainder = $numbers;\n    $delimeter\
    \ = 0 if !defined($delimeter);\n    $delimeter = $delimeter - 1; # HACK: Fix for\
    \ perl 5.8.x\n    while ( @remainder > 0 ) {\n        push( @result, shift(@remainder));\n\
    \        $delimeter = $delimeter - 1 if $delimeter >= 0;\n    }\n    push( @result,\
    \ shift(@remainder)) while @remainder > 0;\n    return @result;\n}", '    my($last,
    $tmp);', "    return undef unless @$numbers;\n    $delimeter = defined $delimeter\
    \ ? $delimeter : ' ';\n    my $num_ele = @$numbers;\n    my $first = 1;\n    my\
    \ $result = '';\n    for (my $i = 0; $i < $num_ele; $i++) {\n        my $number\
    \ = $numbers->[$i];\n        next unless defined $number;\n        if ($first\
    \ == 0) {\n            $result .= $number;\n        } else {\n            $result\
    \ .= $delimeter;\n            $result .= $number;\n        }\n        $first =\
    \ 0;\n    }\n    return $result;\n}", "    my($output, $current);\n    my($i,\
    \ $j, $k, $l);", "    if (@$numbers == 1) {\n        return [$numbers[0]];\n \
    \   }\n    my @delimeter_numbers = map {$delimeter + $_} @$numbers;\n    return\
    \ @$numbers if $delimeter == 0;\n    return @delimeter_numbers if $delimeter ==\
    \ 1;\n    return map {$delimeter * $_ + $numbers[$-$_-1]} 0 .. $#numbers - 1;\n\
    }", "    my @interspersed_numbers;\n    while (@$numbers) {\n        push @interspersed_numbers,\
    \ $delimeter,\n          pop @$numbers;\n    }\n    return @interspersed_numbers;\n\
    }\n</code>\n<|/ a dscore=1 tags=arrays,perl,subroutine,loops |>\n<| a |>\nA short\
    \ answer: No, there is no easy way.\nA long answer: Yes, there is a possible way,\
    \ and it will get you what you want.\nFirstly, we need to think about what you\
    \ want to do.  Suppose you have a list like this:\n<code>\n1 3 5 7 9 11\n</code>\n\
    and you want to convert it into this:\n<code>\n1 2 3 4 5 6 7 8 9 10 11\n</code>\n\
    Now, what do you want to do?  Well, you want the first value of the list to become\
    \ the first item in the new list, the second value to be the second item in the\
    \ new list, and so on.  Therefore, what do we do?\nStart by thinking about what\
    \ you want to do.  Suppose you want the first item to become the first item in\
    \ the new list, the second to become the second item in the new list, the third\
    \ to become the third item in the new list, etc.  Well, that gives us a recursive\
    \ formula.  We can do this.\nNow, suppose you have a list of numbers, like so:\n\
    <code>\n1 2 3 4 5 6 7 8 9\n</code>\nAnd you want to turn it into this:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10\n</code>\nWell, that gives us a recursive formula, too. \
    \ We can do this.\nNow suppose you have a list of numbers, like so:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10 11\n</code>\nAnd you want to turn it into this:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10 11\n</code>\nWell, that gives us a recursive formula, too.\
    \  We can do this.\nNow, suppose you have a list of numbers, like so:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10 11 12\n</code>\nAnd you want to turn it into this:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10 11 12 13\n</code>\nWell, that gives us a recursive formula,\
    \ too.  We can do this.\nNow, suppose you have a list of numbers, like so:\n<code>\n\
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n</code>\nAnd you want to turn it\
    \ into this:\n<code>\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ", "    my@numbers\
    \ = @$numbers;\n    unshift(@numbers, $delimeter);\n    my $len = scalar(@numbers);\n\
    \    my $pos = 0;\n    my $result = '';\n    while($pos < $len){\n        my $to_push\
    \ = $numbers[$pos];\n        ++$pos;\n        while ($pos < $len) {\n        \
    \    $result .= $numbers[$pos];\n            if ($pos < $len) {\n            \
    \    $result .= $delimeter;\n            }\n            ++$pos;\n        }\n \
    \       $result .= $to_push;\n    }\n    @numbers = @result;\n    $numbers[$pos]\
    \ = 0;\n    return @numbers;\n}", "    my($count) = 1;\n    my($last_num) = 0;\n\
    \    my($interspersed_numbers) = [];", "    return [] unless @$numbers;\n    my\
    \ @numbers_copy = @$numbers;\n    my @result = ();\n    my $prev_number = 0;\n\
    \    my $curr_number = 0;\n    foreach my $num (@numbers_copy) {\n        if ($prev_number\
    \ && $curr_number) {\n            $result[$curr_number] = $delimeter;\n      \
    \  }\n        my $ret = $num;\n        ++$curr_number;\n        $prev_number =\
    \ $curr_number;\n        $result[$curr_number] = $num;\n    }\n    return @result;\n\
    }", "    @$numbers = map {$delimeter}{@$numbers}[0,@$numbers-1];\n}", "    $numbers\
    \ = [@$numbers]; # clone as array ref for further use\n    my @result;\n    \n\
    \    for (my $index = 0; $index <= $#$numbers; $index += 2) {\n        push (@result,\
    \ $numbers[$index]);\n        push (@result, $delimeter);\n        push (@result,\
    \ $numbers[$index + 1]);\n    }\n    \n    return @result;\n}", "    my @result;\n\
    \    while (@$numbers) {\n        push @result, pop @$numbers;\n        if (@$numbers\
    \ == 0) {\n            push @result, $delimeter;\n        }\n    }\n    return\
    \ @result;\n}", "    $delimeter = 0 unless defined $delimeter;\n    my = ();\n\
    \    foreach my $i (@$numbers) {\n        if (defined $i) {\n            push,\
    \ $i;\n        }\n        elsif (@$numbers) {\n            push, $delimeter;\n\
    \        }\n    }\n    return wantarray ? @$numbers : \\@$numbers;\n}", "    my\
    \ @result = ();\n    if (@$numbers == 1) {\n        $numbers[0] =~ s/^\\s*//;\n\
    \        $numbers[0] =~ s/\\s*$//;\n        return @result;\n    }\n    foreach\
    \ (@$numbers) {\n        push(@result, $_);\n    }\n    if (@result > 0) {\n \
    \       $result[$#result - 1] =~ s/^$delimeter/${delimeter}/g;\n    }\n    foreach\
    \ my $i (@$numbers) {\n        push(@result, $i);\n    }\n    return @result;\n\
    }", "    my $i;\n    my @result;\n    for ($i = $#numbers - 1; $i >= 0; $i--)\
    \ {\n        push(@result, $numbers[$i]);\n        push(@result, $delimeter) if\
    \ ($i < ($#numbers - 1));\n    }\n    return @result;\n}", "    my @interspersed_numbers;\n\
    \    my $current_index = 0;\n    foreach my $number (@$numbers) {\n        if\
    \ ($current_index == 0) {\n            $interspersed_numbers[0] = $number;\n \
    \           $current_index++;\n        }\n        elsif ($current_index && $current_index\
    \ != ($current_index - 1)) {\n            $interspersed_numbers[$current_index]\
    \ = $delimeter;\n            $interspersed_numbers[$current_index - 1] = $number;\n\
    \        }\n        else {\n            $interspersed_numbers[$current_index]\
    \ = $number;\n        }\n        $current_index++;\n    }\n    return @interspersed_numbers;\n\
    }", "    if (@$numbers == 0) {\n        return [];\n    }", "    $delimeter =\
    \ $self->_number_to_digits($delimeter);\n    my @array;\n    foreach my $number\
    \ (@$numbers) {\n        push @array, $number + $delimeter\n            if $number\
    \ > 0;\n    }\n    return @array;\n}", '    my(@result);', "    return unless\
    \ @$numbers;\n    my @interspersed = ();\n    my $i = 0;\n    foreach my $number\
    \ (@$numbers) {\n        push @interspersed, $delimeter if $i % 2;\n        push\
    \ @interspersed, $number;\n        $i++;\n    }\n    return @interspersed;\n}",
  '    my $delimeterLength = $delimeter->length();', "    return $numbers unless @$numbers\
    \ > 0;\n    return $numbers[0] unless @$numbers == 1;\n    my @new;\n    my $prev\
    \ = $numbers[0];\n    for(my $i = 1; $i <= @$numbers; $i++) {\n        push @new,\
    \ $prev;\n        push @new, $delimeter unless $i % 2 == 0;\n        push @new,\
    \ $numbers[$i];\n        $prev = $numbers[$i];\n    }\n    return @new;\n}", " \
    \   if(@$numbers == 0) {\n        return [];\n    }\n    if($delimeter) {\n  \
    \      my $result = @$numbers;\n        for(my $i = 1; $i < @$numbers; $i++) {\n\
    \            $result .= $delimeter.$numbers[$i];\n        }\n        return $result;\n\
    \    }\n    my $result = $numbers[0];\n    for(my $i = 1; $i < @$numbers; $i++)\
    \ {\n        $result .= $numbers[$i];\n    }\n    return $result;\n}", "    my\
    \ @result;\n    my $counter = 1;\n    \n    for(@$numbers) {\n        push (@result,\
    \ $counter++, $_);\n    }\n    \n    push(@result, $counter++, undef);\n    \n\
    \    @$numbers;\n    \n    return \\@result;\n}\n    ", "    my @result;\n   \
    \ my @numbers_copy;\n    my @delimeter_copy;\n    \n    push @numbers_copy, @$numbers;\n\
    \    push @delimeter_copy, @$delimeter;\n    push @$numbers, undef;\n    push\
    \ @$delimeter, undef;\n    \n    while (@numbers_copy) {\n        push @result,\
    \ splice @numbers_copy, 0, 2;\n        push @delimeter_copy, splice @delimeter_copy,\
    \ 0, 1;\n    }\n    \n    push @$numbers, @delimeter_copy;\n    push @$delimeter,\
    \ undef;\n    \n    return wantarray ? @result : $result[0];\n}", "    my @numbers\
    \ = @$numbers;\n    return @numbers == 0 || $numbers[0] == $numbers[-1] ? @numbers\
    \ : @numbers + ($delimeter*scalar(@numbers)) unless @numbers > 0;\n    my @result;\n\
    \    for (my $i = 0; $i < scalar(@numbers); $i += 2) {\n        push(@result,\
    \ $numbers[$i]);\n    }\n    return @result;\n}", "    my(@result) = (@_);\n \
    \   my $delim = ($delimeter - $numbers[0]) % ($numbers[0] + 1);\n    my $i = 0;\n\
    \    my $last;\n    while(1) {\n        my $number = shift(@numbers);\n      \
    \  last if !$number || $number == $delim || $i == 0;\n        push(@result, $number);\n\
    \        $i++;\n    }\n    push(@result, ($delim + ($numbers[0] - $i)) % $numbers[0]\
    \ + 1);\n    return @result;\n}", "    my(@numbers) = @$numbers;\n    my $count\
    \ = 1;\n    while( @numbers ) {\n        push @$numbers, $delimeter;\n       \
    \ $count++;\n        @numbers = @numbers[0..$count-1];\n    }\n    return @numbers;\n\
    }", "    my @result;\n    my $size = @$numbers;\n    if ($delimeter) {\n     \
    \   if ($size == 0) {\n            return ();\n        }\n        else {\n   \
    \         for (my $i = 0; $i < $size ; $i++) {\n                push(@result,\
    \ $numbers->[$i]);\n                push(@result, $delimeter);\n            }\n\
    \        }\n    }\n    else {\n        for my $i (0 .. $size) {\n            push(@result,\
    \ $numbers->[$i]);\n        }\n    }\n    return @result;\n}", "    return unless\
    \ @$numbers;\n    $delimeter = $delimeter->() if ref $delimeter;\n    return map\
    \ { $_ ? \"$_$delimeter\" : () } @$numbers;\n}", "    my(@output);\n    for my\
    \ $number (@$numbers) {\n\tpush (@output, defined $delimeter and $delimeter and\
    \ $delimeter || '') . $number;\n    }\n    return @output;\n}", "    my @new_numbers\
    \ = ();\n    my($i, $j) = @_;\n    foreach $i (@$numbers) {\n        if ($j ==\
    \ 0)\n        {\n            push (@new_numbers, $i);\n        }\n        else\n\
    \        {\n            push (@new_numbers, $delimeter) if ($j == 1);\n      \
    \      push (@new_numbers, $i);\n        }\n        $j--;\n    }\n    return @new_numbers;\n\
    }", "    my @result;\n    if (@$numbers == 0) {\n        return @result;\n   \
    \ }\n    for (my $i = 0; $i < @$numbers; $i += 2) {\n        push(@result, $delimeter);\n\
    \        push(@result, @{$numbers}[$i, $i + 1]);\n    }\n    @result;\n}", " \
    \   my($n, $i, $result);\n    my $delim = $delimeter;\n    $delim //= \"\";\n\
    \    # Don't let people pass in empty strings\n    die \"Cannot intersperse an\
    \ empty string\" if $delim eq \"\";\n    for ($n = @$numbers; $n > 0 ; $n--) {\n\
    \        $result = $result[@$numbers[$n]];\n        splice @$numbers, $n, 0, $delim;\n\
    \        push @$numbers, $result;\n    }\n    @$numbers;\n}", "    my(@result)\
    \ = ();\n    for(my $i = scalar(@$numbers) - 1; $i >= 0; $i--) {\n        push(@result,\
    \ $delimeter, $numbers->[$i], $numbers->[$i]);\n    }\n    return \\@result;\n\
    }", "    my @result = ();\n    \n    unless (defined($numbers)) {\n        return\
    \ @result;\n    }", "    $delimeter = defined $delimeter ? $delimeter : ',';",
  '    return [] unless @$numbers;', "    $delimeter = _check_delimiter($delimeter);\n\
    \    my @nums = @$numbers;\n    my @out;\n    for (@nums) {\n        push(@out,\
    \ $_ . $delimeter);\n    }\n    return @out;\n}", "    return () unless $numbers;\n\
    \    my(@result) = ();\n    while (@$numbers) {\n        push(@result, shift(@$numbers));\n\
    \        push(@result, $delimeter) unless $numbers[-1]; # Don't add delimeter\
    \ to last element\n    }\n    return @result;\n}\n</code>\n<|/ a dscore=2 tags=arrays,perl,performance\
    \ |>\n<| c |>\nThanks so much for this, your explanation helped me understand\
    \ what I was doing wrong. I went ahead and implemented the code and it works great\
    \ (although it took way longer than I expected) Thanks a lot!\n<|/ c |>\n<| c\
    \ |>\nThe only thing I would add is that for small arrays the above code will\
    \ run out of memory in one go. You can avoid that by replacing `@$numbers[-1];`\
    \ with `pop @$numbers[-1];`\n<|/ c |>\n<| c |>\n: Good point.  I didn't realize\
    \ you were wanting to do this for arbitrarily large arrays.  For small arrays,\
    \ the alternative is `shift @$numbers;`\n<|/ c |>\n<| c |>\nFor large arrays,\
    \ you may want to look at `List::MoreUtils`.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ another way, using recursion.  Basically this puts the delimiter between the\
    \ original list and all the elements of the sublists.  It also avoids push/pop,\
    \ since these are relatively slow in Perl.\n<code>", "    my($i, $j);\n    my($return);\n\
    \    foreach $i (@$numbers) {\n        last if $j > @$numbers;\n        if ($delimeter)\
    \ {\n            $return .= $delimeter x $j;\n        }\n        $return .= $i;\n\
    \        $j++;\n    }\n    return $return;\n}", "    my @result = ();\n    my\
    \ $index = 0;\n    $delimeter++ unless defined($delimeter);\n    my $length =\
    \ $#numbers;\n    while (defined $numbers[$index]) {\n        push @result, $numbers[$index];\n\
    \        push @result, $delimeter unless $index++;\n        $index++;\n    }\n\
    \    return @result;\n}", "    my $i = 0;\n    map { $numbers[$i++] = $_; $numbers[$i]\
    \ += 1 } $numbers[0..$#{$numbers}];\n    my @result = ();\n    for (my $i = 0;\
    \ $i < $#numbers; $i += $delimeter) {\n        push(@result, @{ $numbers[$i..$i+$delimeter]\
    \ });\n    }\n    return @result;\n}", "    my $len = @$numbers;\n    if ($len\
    \ <= 0) {\n        return ();\n    }\n    my($i, $j);\n    my $result = ();\n\
    \    for (; $i < $len; $i += 2) {\n        $result->[$i] = $delimeter;\n     \
    \   $result->[$j] = $numbers->[$i];\n        $j++;\n    }\n    return @$result;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like this solution, but it's missing\
    \ a couple of `()`s around `$delimeter` in the definition of `intersperse`. Maybe\
    \ it's just in the demo, but when I copy and paste from your script into my editor,\
    \ the first two lines of the `sub` line are all red underlined -- `sub intersperse`\
    \ is red in the definition of `intersperse`. Any ideas?\n<|/ c |>\n<| c |>\nNevermind,\
    \ I fixed it. I was missing a `()` around `$delimeter` in the `my()` line, as\
    \ in `my($i, $j);` instead of `my ($i, $j);`. Thanks again.\n<|/ c |>\n<| a dscore=3\
    \ tags=perl,arrays,concatenation,multidimensional-array |>\nAnother possible solution:\n\
    <code>", "    my $n = 0;\n    my @out = ();\n    foreach my $number (@$numbers)\
    \ {\n        $n++;\n        if ($n <= scalar(@$numbers)) {\n            push @out,\
    \ $number + $delimeter;\n        }\n    }\n    return @out;\n}", "    my $result\
    \ = shift;\n    my @to_add = @$result;\n    my @to_delete;\n    if (@$numbers\
    \ == 0) {\n        return $result;\n    }", "    return @$numbers if @$numbers\
    \ == 0;\n    my @newNumbers = ();\n    my $i = 0;\n    while ($i < @$numbers)\
    \ {\n        if ($i == 0) {\n            push @$newNumbers, $numbers[$i];\n  \
    \          push @$newNumbers, $delimeter;\n        }\n        else {\n       \
    \     push @$newNumbers, $numbers[$i];\n            push @$newNumbers, $delimeter;\n\
    \        }\n        $i += 1;\n    }\n    return @newNumbers;\n}", "    my $return\
    \ = '';\n    \n    for (my $i = 0; $i <; ++$i) {\n        if ($i != 0) { $return\
    \ .= $delimeter; }\n        $return .= $numbers[$i];\n    }\n    \n    return\
    \ $return;\n}", "    $numbers =~ s/^([\\w\\W]*?)$delimeter$delimeter$1/e;\n  \
    \  return $numbers;\n}", "    my $delimeter_c = length($delimeter);\n    my $len\
    \        = @$numbers;\n    my $ret        = [];\n    my $index;\n    my $i = 0;\n\
    \    while(@$numbers) {\n        push(@$ret, $numbers[$i]);\n        $i++;\n \
    \       last unless ($i == $len) || ($i == $len - $delimeter_c);\n    }\n    return\
    \ @$ret;\n}", "    my @return = ();\n    \n    for my $number (@$numbers) {\n\
    \        push(@return, $number);\n        push(@return, $delimeter) unless $number\
    \ == 0;\n    }\n    \n    return @return;\n}\n</cell>\n<text>\nThis makes use\
    \ of arrays in perl. An array is a data structure that stores multiple items of\
    \ information. For example: an array containing multiple phone numbers, names,\
    \ email addresses, locations etc. It can hold multiple different things.", " \
    \   my @ret;\n    for(my $i = 0; $i < @$numbers; $i += 2) {\n        push @ret,\
    \ splice @$numbers, $i, 1;\n    }\n    push @$numbers, $delimeter;\n    return\
    \ @ret;\n}\n</code>\n<|/ a tags=perl,arrays,function,string |>\n<| a tags=perl,arrays,function,string\
    \ |>\nI like Jon's solutions best but I'd like to share another one that might\
    \ not be as readable.\n<code>\nmy $delimeter = shift(@numbers);\nmy = map { $numbers[$_]\
    \ =~ /\\w/; $numbers[$_] =~ /\\w/$delimeter; } 0 .. $#numbers;\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis is probably the best solution.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI would probably use the following code:\n<code>\nmy $delimeter = shift(@numbers);\n\
    $delimeter = '' if $delimeter eq '';\nmy = map {$_ =~ s/\\Q$delimeter//;} @numbers;\n\
    </code>\n<|/ a tags=perl,arrays,function,string |>\n<| c |>\nThis would allow\
    \ the delimeter to occur anywhere in the string.\n<|/ c |>\n<| a |>\n<code>",
  "    $delimeter //= ',';", "    my($result,$temp,@first,@rest);\n    $delimeter\
    \ = \"\" if ! defined $delimeter;", "    my $size = $numbers->[-1];\n    my $i\
    \ = 0;\n    for (my $i = 0; $i < $size; $i+=1) {\n        $numbers->[$i] .= $delimeter\
    \ . $numbers->[$i+1];\n        $numbers->[$i+1] = $numbers->[$i];\n    }\n   \
    \ $numbers;\n}", "    return unless @$numbers;\n    return $numbers[0] unless\
    \ @$numbers == 1;\n    return @$numbers[0] unless @$numbers == 2;\n    my @output;\n\
    \    push @output, @$numbers[0];\n    push @output, @$delimeter;\n    push @output,\
    \ @$numbers[1];\n    return @output;\n}", "    return $numbers unless @$numbers;\n\
    \    my @numbers = @$numbers;\n    @numbers = map { \"$_$delimeter\" } @numbers;\n\
    \    return @numbers;\n}", "    $numbers =~ s/^(\\S*)/\\Q$delimeter\\E$1/g;\n\
    \    return $numbers;\n}", "    my $interspersed_numbers = $delimeter;\n    my\
    \ $interspersed_count = length($interspersed_numbers);\n    my $length  = length($numbers)\
    \ + 1;\n    \n    for(0..$length-1) {\n        my $number = $numbers[$_];\n  \
    \      $numbers[$_] = $interspersed_numbers . $number . $interspersed_numbers;\n\
    \    }\n    \n    return $numbers;\n}\n</code>\n<|/ a tags=arrays,perl,performance\
    \ |>\n<| a |>\nFor arrays of size n or less, you can do:\n<code>\nuse strict;\n\
    use warnings;", "    my $i = 1;\n    my @interspersed = ();\n    while($i <= @$numbers)\
    \ {\n        push(@interspersed, $numbers[$i-1] + $delimeter);\n        push(@interspersed,\
    \ $numbers[$i]);\n        $i++;\n    }\n    return @interspersed;\n}\n</code>\n\
    <|/ a tags=arrays,perl |>\n<| c |>\nThis solution is very elegant. I like it.\n\
    <|/ c |>\n<| a tags=arrays,perl |>\n<code>\nuse strict;\nuse warnings;", "   \
    \ my @result;\n    if (scalar(@$numbers) == 0) {\n        return @result;\n  \
    \  }\n    $delimeter = defined $delimeter ? $delimeter : ',';\n    foreach my\
    \ $num (@$numbers) {\n        if (defined $num) {\n            push @result, $num;\n\
    \        }\n        elsif (defined $delimeter) {\n            push @result, $delimeter;\n\
    \        }\n    }\n    return @result;\n}", "    return () unless @$numbers;\n\
    \    my $first = $numbers[0];\n    my(@results);\n    for (@$numbers) {\n    \
    \    push(@results, $first);\n        $first = $delimeter;\n    }\n    push(@results,\
    \ $first) unless @$numbers;\n    @results;\n}", "    return () unless $numbers;\n\
    \    my($i, $j) = 0, 0;\n    my(@result) = ();\n    while ($j < @$numbers) {\n\
    \        last if $j == @$numbers - 1;\n        push(@result, $numbers[$j] . $delimeter);\n\
    \        ++$j;\n    }\n    return @result;\n}", "    my @result;\n    for my $n\
    \ (@$numbers) {\n        push @result, $n if ($n != 0 && $n != 1);\n        push\
    \ @result, $delimeter if (@$numbers - 1 == $#{$numbers});\n    }\n    return wantarray\
    \ ? @result : $result[0];\n}", "    my $n = @$numbers;\n    my @result = ();",
  '    my @ret;', "    my $length = scalar @$numbers;\n    if ($length > 1) {\n  \
    \      $delimeter = defined($delimeter) ? $delimeter : \",\";\n        $numbers[-1]\
    \ .= $delimeter;\n        $numbers[-1] =~ s/$delimeter/$delimeter$delimeter/g;\n\
    \    }\n    return @$numbers;\n}", "    my(@interspersed) = ();\n    my($delimeterLength)\
    \ = length $delimeter;\n    my($lastLength) = 0;", "    return @$numbers unless\
    \ @$numbers;\n    @$numbers = map { (split) = $_; $delimeter x 2 } @$numbers;\n\
    \    return @$numbers;\n}", "    my @out;\n    my @nums;\n    my $i = 0;", '    my
    @result;', "    my(@result) = ();\n    \n    for (my $i = 0; $i <= (scalar(@$numbers)\
    \ - 1); $i++) {\n        push (@result, $delimeter . $numbers->[$i] . $delimeter);\n\
    \    }\n    return @result;\n}", "    return if !defined $delimeter;\n    my @result\
    \ = ();\n    my $last = 0;\n    my @numbers_copy = @$numbers;\n    foreach my\
    \ $i (0 .. @numbers_copy-1) {\n        if ($i == 0) {\n            $last .= $numbers_copy[$i];\n\
    \        }\n        else {\n            $last .= $delimeter;\n            $last\
    \ .= $numbers_copy[$i];\n        }\n    }\n    return @result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nYeah... that is what I meant with \"not very elegant\"... :)\n\
    <|/ c |>\n<| a |>\nHere's a quick one liner using perl\n<code>\necho 1,2,3,4,5,6,7,8,9,0\
    \ | perl -F, -lane 'print \"@F\" if ($_ ne $F[$#F]){print \",$_\"}'\n</code>\n\
    <|/ a dscore=3 tags=perl,arrays |>\n<| a |>\n<code>\nprint map { $_ eq pop(@$arr)\
    \ ? $_ : \",$_\" } @$arr;\n</code>\n<|/ a tags=perl,arrays dscore=2 |>\n<| a tags=perl,arrays\
    \ |>\n<code>\nmy $array = [ 'one', 'two', 'three' ];", "    if (@$numbers == 0)\
    \ { \n        return $numbers;\n    }\n    # @$numbers is 1 element longer than\
    \ @$delimeter\n    my $num_delimeter_len = length($delimeter);\n    if ($num_delimeter_len\
    \ == 0) {\n        return $numbers[0];\n    }\n    my $num_elements = @$numbers;\n\
    \    if ($num_delimeter_len > $num_elements) {\n        return $numbers[0];\n\
    \    }\n    return join($delimeter, @$numbers);\n}", "    my $count = @$numbers;\n\
    \    $count -= 1;\n    my @output;\n    my $i;\n    for ($i = 0; $i < $count;\
    \ $i++) {\n        my $val = $numbers[$i];\n        push (@output, $val);\n  \
    \      push (@output, $delimeter);\n    }\n    return @output;\n}", "    my @result;\n\
    \    my($cur, $last);", '    my $delim = (defined $delimeter) ? $delimeter : "
    ";']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
