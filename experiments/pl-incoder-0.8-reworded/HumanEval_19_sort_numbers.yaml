name: HumanEval_19_sort_numbers
language: pl
prompt: "# Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\
  # Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
  \ 'eight' and 'nine'.\n# Return the string with numbers sorted from smallest to\
  \ largest\n# >>> sort_numbers(\"three one five\")\n# \"one three five\"\nsub sort_numbers\
  \ {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_numbers;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three\"),\"three\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  three five nine\"),\"three five nine\")) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(\"five zero four seven\
  \ nine eight\"),\"zero four five seven eight nine\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"six five four three\
  \ two one zero\"),\"zero one two three four five six\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $numbers =~ s/\\s+//g;\n    $numbers =~ s/^\\s+//g;\n    $numbers\
    \ =~ s/\\s+$//g;\n    my @numbers = split( /\\s+/, $numbers );\n    foreach my\
    \ $num ( @numbers ) {\n        my( $name, $number ) = split( /\\s*\\D\\s*/, $num\
    \ );\n        $number =~ s/^0*//;\n        $numbers[$name] = $number;\n    }\n\
    \    my $result = join( ' ', @numbers );\n    $result =~ s/\\s+/ /;\n    $result\
    \ =~ s/^\\s+/ /;\n    $result =~ s/\\s+$/ /;\n    return $result;\n}", "    my($result,$temp);\n\
    \    \n    @{$numbers} = map {\n        /^(\\d+)/;\n        $1 eq 'zero' ? 0 :\n\
    \        $1 eq 'one' ? 1 :\n        $1 eq 'two' ? 2 :\n        $1 eq 'three' ?\
    \ 3 :\n        $1 eq 'four' ? 4 :\n        $1 eq 'five' ? 5 :\n        $1 eq 'six'\
    \ ? 6 :\n        $1 eq 'seven' ? 7 :\n        $1 eq 'eight' ? 8 :\n        $1\
    \ eq 'nine' ? 9 : $1>$temp ? ($result = \"$temp $1 \", $temp = 1) : $1;\n    }\
    \ @{$numbers};\n    \n    return $result if $result;\n    return $numbers;\n}",
  "    my($sort) = sort {\n        my $a = (split /\\s+/, $_)[1] =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/i;\n\
    \        my $b = (split /\\s+/, $numbers)[1] =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/i;\n\
    \        return $a <=> $b;\n    };", "    chomp($numbers);\n    my = map { $num{$_}++\
    \ } split /\\s+/, $numbers;\n    my $len = scalar @nums;\n    my @sorted;\n  \
    \  my $i = 0;\n    my $j = 0;\n    my @sorted = ();\n    while (@nums) {\n   \
    \     my $min = $len ? $nums[$i] < $nums[$j] ? $nums[$i] : $nums[$j] : $nums[$i];\n\
    \        push @sorted, $min;\n        if ($len == 1) {\n            push @sorted,\
    \ $sorted[0];\n        }\n        elsif ($len == $i + 1) {\n            push @sorted,\
    \ $sorted[$i + 1];\n        }\n        elsif ($len == $i + 2) {\n            push\
    \ @sorted, $sorted[$i + 1];\n            push @sorted, $sorted[0];\n        }\n\
    \        $i++;\n        $j++;\n    }\n    return join \" \", @sorted;\n}", " \
    \   my($string);\n    my @numbers;\n    my $i = 0;", "    my($string);\n    my\
    \ @numbers;\n    my($i, $j, $smallest, $largest);\n    # Convert all to numbers\n\
    \    foreach $number (split(/ /, $numbers)) {\n        $number =~ tr/ //d;\n \
    \       $number =~ s/^0+([0-9]+)$/$1/;\n        $number =~ s/^([0-9]+)\\.0$/$1/;\n\
    \        $number =~ s/^([0-9]+)$/$1/;\n        $number =~ s/^\\+?0*([0-9]+)/$1/;\n\
    \        $number =~ s/^\\+?([0-9]+)$/$1/;\n        push(@numbers, $number);\n\
    \    }\n    # Sort and return\n    foreach $i (@numbers) {\n        $smallest\
    \ = $i;\n        foreach $j (@numbers) {\n            $largest ||= $j;\n     \
    \       $smallest = $smallest <=> $j;\n        }\n        $string .= $smallest\
    \ . \" \";\n    }\n    return $string;\n}", "    $numbers =~ s/^\\s*|\\s*$//g;\n\
    \    if ($numbers =~ s/^\\s*([a-z]+?)\\s*(\\d(?:\\d)?)/$1/) {\n        $numbers\
    \ =~ s/(\\d+)([a-z]+?)(\\d+)/$3 $2 $1/;\n    } else {\n        $numbers =~ s/(\\\
    d+)([a-z]+?)/$1 $2/;\n    }\n    $numbers =~ s/\\s+/ /g;\n    return $numbers;\n\
    }", '    my($sort) = ();', "    my @numbers = split(/ /, $numbers);\n    my @sorted\
    \ = sort { $a <=> $b } @numbers;\n    return join(\" \", @sorted);\n}", "    my(@sorted_numbers);\n\
    \    my($num_ones);\n    my($num_tens);\n    my($num_ten_ones);", "    my($string);\n\
    \    my($number);", '    my($sorted_numbers);', "    \n    # Sanitize the string\n\
    \    $numbers ||= 0;\n    $numbers =~ s/^\\s*//;\n    $numbers =~ s/\\s*$//;\n\
    \    $numbers =~ s/^\\s+//g;\n    $numbers =~ s/\\s+$//g;\n    $numbers =~ s/\\\
    s+/ /g;", "    my @numbers = split(\" \", $numbers);\n    my $sorted = \"\";\n\
    \    foreach my $number (@numbers) {\n        if ($number eq \"zero\") {\n   \
    \         $sorted .= \"nine \";\n        } elsif ($number eq \"one\") {\n    \
    \        $sorted .= \"eight \";\n        } elsif ($number eq \"two\") {\n    \
    \        $sorted .= \"seven \";\n        } elsif ($number eq \"three\") {\n  \
    \          $sorted .= \"six \";\n        } elsif ($number eq \"four\") {\n   \
    \         $sorted .= \"five \";\n        } elsif ($number eq \"five\") {\n   \
    \         $sorted .= \"four \";\n        } elsif ($number eq \"six\") {\n    \
    \        $sorted .= \"three \";\n        } elsif ($number eq \"seven\") {\n  \
    \          $sorted .= \"two \";\n        } elsif ($number eq \"eight\") {\n  \
    \          $sorted .= \"one \";\n        } elsif ($number eq \"nine\") {\n   \
    \         $sorted .= \"zero \";\n        } else {\n            die \"Invalid number:\
    \ $number\";\n        }\n    }\n    $sorted =~ s/ $//;\n    $sorted;\n}", "  \
    \  my($sorted);\n    # Stick the words into a hash table in descending order and\
    \ sort using it\n    foreach my $num (@$numbers) {\n        $sorted .= $num if\
    \ $sorted;\n        push(@sorted,$num) if $num =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/;\n\
    \    }\n    return join(\" \", @sorted);\n}\n</code>\n<|/ a dscore=0 tags=sorting,perl\
    \ |>\n<| c |>\nAh, okay, thanks! But I still don't understand what the 'sorted'\
    \ array is for. Isn't the point of the sort sub to return the sorted list?\n<|/\
    \ c |>\n<| c |>\nThe `sort` sub is a user-defined function that can return whatever\
    \ it wants\n<|/ c |>\n<| c |>\n`sort` isn't a built in function, it's built-in\n\
    <|/ c |>\n<| c |>\nThe sorting is done by `sort` not `sort`\n<|/ c |>\n<| a tags=sorting,perl\
    \ dscore=0 |>\nThis works. I have added comments as well as some explanations.\n\
    <code>\nuse strict;\nuse warnings;", "    my @numbers = split \" \", $numbers;\n\
    \    my @sorted = ();\n    foreach my $num (@numbers) {\n        push (@sorted,\
    \ $num) if $num =~ /[1-9]{3,10}/;\n    }\n    return join \" \", @sorted;\n}",
  "    # Convert space-delimited numbers to an array for sorting\n    my(@numbers)\
    \ = split(\" \", $numbers);\n    # Sort from smallest to largest\n    @numbers\
    \ = sort { $a <=> $b };\n    # Return concatenated string of sorted numbers\n\
    \    return join(\" \",);\n}", '    my($order);', "    chomp($numbers);\n    $numbers\
    \ =~ s/(^\\s*)|(\\s*$)//g;\n    $numbers =~ s/\\s+/ /g;\n    $numbers =~ s/^\\\
    s*//;\n    $numbers =~ s/\\s*$//;\n    my($sorted) = \"\";\n    my($numbers_array)\
    \ = \"\";\n    my($current_number) = \"\";\n    my($next_number) = \"\";\n   \
    \ my($next_number_string) = \"\";\n    my($current_position,$current_position_string)\
    \ = 0;\n    my($next_position,$next_position_string) = 0;", "    my($sorted_numbers)\
    \ = '';", "    return $numbers if not defined $numbers;\n    my @numbers = split\
    \ ' ', $numbers;\n    my @sorted = sort {$a <=> $b} @numbers;\n    return join(\"\
    \ \", @sorted);\n}", "    my($sorted_numbers) = '';\n    foreach (split ' ', $numbers)\
    \ {\n        $sorted_numbers .= $_;\n    }\n    $sorted_numbers =~ s/(?<=[0-9])(?=[a-zA-Z])/10#/ig;\n\
    \    $sorted_numbers =~ s/(?<=[a-zA-Z])(?=[0-9])/10#/ig;\n    $sorted_numbers\
    \ =~ s/10#/100/ig;\n    $sorted_numbers =~ s/10#/10/ig;\n    return $sorted_numbers;\n\
    }", '    my(@new_numbers);', '    my(@results);', "    my @nums = ();\n    my\
    \ @nums_str = split /\\s+/, $numbers;\n    foreach my $num (@nums_str) {\n   \
    \     push(@nums, $num =~ s/(\\d+)/$1 + 1000/egr);\n    }\n    \n    # Now sort\
    \ them\n    sort(@nums);\n    \n    # Now put them back together\n    my $sorted_numbers\
    \ = join(\" \", @nums);\n    $sorted_numbers .= \" \" unless ($sorted_numbers\
    \ =~ /^(.*\\s)$/);\n    return $sorted_numbers;\n}", "    # Split up input into\
    \ an array of: numbers, units, and tens\n    my($numbers_string) = split / \\\
    s /, $numbers, 3;\n    # Split up $numbers_string into an array of numbers\n \
    \   my(@numbers) = split / \\d /, $numbers_string, -1;", '    chomp($numbers);',
  "    my($number_string) = @$numbers =~ /^(\\d+)\\s*\\W*(\\d+)$/;\n    my($first,\
    \ $second) = @$number_string =~ /(\\d+)\\s*(\\d+)$/;\n    if ($first < $second)\
    \ {\n        return $first;\n    } elsif ($first > $second) {\n        return\
    \ $second;\n    } else {\n        return $number_string->[1];\n    }\n}", "  \
    \  my($numbers_copy);\n    \n    #check input value\n    if ( not defined $numbers\
    \ or $numbers =~ m!^\\s*\\d+\\s*$! ) {\n        carp \"Usage: sort_numbers('one\
    \ two three')\";\n        return;\n    }\n    \n    #make copies of input numbers\n\
    \    $numbers_copy =~ s/\\s+//g;\n    \n    #convert numbers to numbers\n    my($numbers_copy)\
    \ = map { 0 + $_ } split /\\s+/, $numbers_copy;\n    \n    #sort numbers ascending\n\
    \    my(@sorted_numbers);\n    \n    foreach my $number(0 .. 9) {\n        next\
    \ unless $numbers_copy > $number;\n        push @sorted_numbers, $number;\n  \
    \      splice @$numbers, $i, 1;\n        splice, 0, $i; # remove number from array\n\
    \    }\n    \n    #convert numbers to string\n    my(@sorted_numbers) = map {\
    \ (\"%02d\" . $_) } @sorted_numbers;\n    \n    return join \" \", @sorted_numbers;\n\
    }", "    chomp $numbers;\n    my = split ' ', $numbers;\n    my = sort {\n   \
    \     my $a = $a->[0];\n        my $b = $b->[0];\n        return $a <=> $b ||\
    \ $a cmp $b;\n    };", "    $numbers =~ tr/A-Za-z/0-9/;\n    my @numbers = split(\"\
    \ \", $numbers);\n    @numbers = sort(@numbers);\n    return join(\" \",);\n}",
  '    my($new_numbers) = "";', "    my($numbers_as_list) = $numbers =~ /^ (.*?) $/x;\n\
    \    my($num_list) = $numbers_as_list =~ m/^ ([0-9]+) $/x;\n    return join (\"\
    \ \",reverse sort (map { (split ' ', $num_list)[$_] } 0 .. ($#num_list - 1)));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI tested this and it doesn't quite work.\
    \ e.g. `sort_numbers(\"seven eight nine\")` gives `\"eight eight nine\"` instead\
    \ of `seven eight nine`.\n<|/ c |>\n<| c |>\nYou made an error - I fixed the bug\
    \ in sort_numbers()\n<|/ c |>\n<| c |>\nI apologize for the confusion. I think\
    \ it would be helpful for people who see this thread if you could edit your answer\
    \ to incorporate your new code.\n<|/ c |>\n<| a dscore=1 tags=sorting,perl,regex\
    \ |>\nHere's my solution:\n<code>", '    $numbers =~ tr/ //d;', "    my(@nums);\n\
    \    # split into array\n    @nums = split \" \", $numbers;\n    # sort array\n\
    \    @nums = sort { $a <=> $b } @nums;\n    # rebuild string\n    return join\
    \ \" \", @nums;\n}", "    my @numbers_as_string = split(' ', $numbers);\n    my\
    \ @numbers_as_numbers = map { $numbers_as_string[$_] => $_ } 0 .. $#numbers_as_string;\n\
    \    return join(' ', sort { ($numbers_as_numbers[$_a] <=> $numbers_as_numbers[$_b])\
    \ || ($numbers_as_string[$_a] cmp $numbers_as_string[$_b]) } @numbers_as_numbers);\n\
    }\n</code>\n<|/ a tags=sorting,perl |>\n<| a dscore=4 |>\nIf you're doing this\
    \ a lot, you can speed up sorting by using a radix sort instead of sorting the\
    \ string. \n<code>", '    my @numbers;', "    $numbers =~ m!\\s+!g;\n    $numbers\
    \ =~ m!^\\s*(\\d+)\\s*$!i; # remove leading whitespace\n    @numbers = sort {\
    \ $a <=> $b } @numbers;\n    $numbers .= \" \" if $numbers[-1] eq \"\";\n    $numbers;\n\
    }", "    my @numbers = split(\" \", $numbers);\n    my $sorted = \"$numbers[0]\
    \ $numbers[1] $numbers[2]\\n\";\n    for my $i (1 .. $#numbers) {\n        for\
    \ my $j (0 .. $#numbers - $i) {\n            if ($numbers[$j] > $numbers[$j +\
    \ 1]) {\n                my $swap = $numbers[$j];\n                $numbers[$j]\
    \ = $numbers[$j + 1];\n                $numbers[$j + 1] = $swap;\n           \
    \     $sorted = $sorted . \"$numbers[$j] $numbers[$j + 1]\\n\";\n            }\n\
    \        }\n    }\n    return $sorted;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Yeah, it's certainly not very efficient.  I was only trying to solve the problem\
    \ as I read it, and not write the whole thing for you.\n<|/ c |>\n<| c |>\nBut\
    \ this doesn't work for \"six nine eight three\"\n<|/ c |>\n<| c |>\nOh boy. \
    \ Sorry.  I didn't notice that.  I will fix it.\n<|/ c |>\n<| c |>\nFixed.  Thanks\
    \ for the catch.  And thanks for your comments, they were very helpful.\n<|/ c\
    \ |>\n<| a tags=perl,sorting |>\nThe algorithm is quite simple - go through each\
    \ pair of numbers and move them one by one. If the next number is less than the\
    \ previous one, swap them. The complexity of the algorithm is O(n) where n is\
    \ the number of input numbers, i.e. the length of the input string.\nA sample\
    \ implementation (Python 3):\n<code>\ndef sort_numbers(input_str):\n    numbers\
    \ = input_str.split()\n    numbers = sorted(numbers, key=lambda num: int(num))\n\
    \    return ' '.join(numbers)", "    $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\\
    s+$//;\n    my($min, $max);", "    my @nums = split /\\s+/, $numbers;\n    my\
    \ @sorted;", "    my($temp) =   '';\n    my($i, $j, $n, @nums);\n    $numbers\
    \ =~ s/ /\\s+/ if $numbers;\n    my @nums = split ' ', $numbers;\n    \n    for(my\
    \ $n = scalar @nums - 1; $n > 0; $n--) {\n        for(my $i = 0; $i < $n; $i++)\
    \ {\n            $temp .= $nums[$i];\n        }\n        for(my $i = $n; $i >=\
    \ 0; $i--) {\n            $temp .= $nums[$i];\n        }\n    }\n    return $temp;\n\
    }", "    my @numbers = split ' ', $numbers;", "    my(@sorted_numbers);\n    \n\
    \    foreach my $number (split /\\s+/, $numbers) {\n        $sorted_numbers[$sorted_numbers_index++]\
    \ = $number if $number =~ /(?:^|\\s)(?:one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    }\n    \n    @sorted_numbers = sort { $a <=> $b } @sorted_numbers;\n\
    \    return @sorted_numbers;\n}", "    my @numbers = split ' ', $numbers;", " \
    \   my @numbers;\n    my @chars;\n    my @chunks;\n    my $chunk;\n    my $temp;\n\
    \    my @chunk_numbers;", "    my @numbers_array = split(\" \", $numbers);\n \
    \   sort(@numbers_array);\n    my $output = join(\" \", @numbers_array);\n   \
    \ return $output;\n}\n</code>\n<|/ a dscore=4 tags=perl |>\n<| c |>\nI find that\
    \ the `sort` function call is unnecessary, you can just return the array instead:\
    \ `sub sort_numbers () { my($numbers) = @_; split(\" \", $numbers);  return; }`\n\
    <|/ c |>\n<| c |>\nNot sure I agree with that since it changes the behaviour.\n\
    <|/ c |>\n<| c |>\nIt's not just the behaviour, the output is different. Try `print\
    \ \"@sort_numbers( 'three one five' )\\n\";` vs. `print \"sort_numbers( 'three\
    \ one five' )\\n\";`\n<|/ c |>\n<| c |>\nGood catch, you are correct, I removed\
    \ the sort functionality.\n<|/ c |>\n<| c |>\n`my $output = join(\" \", @numbers_array);`\
    \ should be `$output = join(\" \", sort @numbers_array);` as `@numbers_array`\
    \ is already sorted, and there is no need for the `sort` call\n<|/ c |>\n<| a\
    \ tags=perl |>\n<code>\nuse strict;\nuse warnings;\nuse v5.10;", '    my @sort
    = ();', "    my @numbers = split(\" \", $numbers);\n    my @sorted = ();\n   \
    \ foreach my $num (@numbers) {\n        my $value = $num;\n        if ($value\
    \ =~ /\\d/) {\n            $value = int($value);\n        }\n        push(@sorted,\
    \ $value);\n    }\n    foreach (@sorted) {\n        push(@sorted, $_);\n    }\n\
    \    my $sorted = join(\", \", @sorted);\n    $sorted = qq{sort -n \"$sorted\"\
    };\n    $sorted =~ s/\\\"\\\"/\"\"/;\n    return $sorted;\n}\n</code>\n<|/ a tags=sorting,perl\
    \ |>\n<| c |>\nThis only works for numbers in the range 1-9. There are many more\
    \ numbers and words that might get sorted before numbers in that range.\n<|/ c\
    \ |>\n<| c |>\nThat's true, but I guess there are not many words in English language\
    \ :)\n<|/ c |>\n<| c |>\nThe list can be easily changed if desired, by adding\
    \ \"sort {...} reverse\" to the end of the foreach loop :)\n<|/ c |>\n<| c |>\n\
    Ah, I missed that in the question. Updated my answer, now it will sort words too.\n\
    <|/ c |>\n<| c |>\nI modified your answer to allow multiple digits in strings.\
    \ I also changed it to return an array, because it's easier to handle that way.\n\
    <|/ c |>\n<| a dscore=5 |>\nIn Perl 5.10 and later versions, the sort function\
    \ can take an optional third parameter, with the value being what to do when two\
    \ elements compare equal. The default is to sort alphabetically, and you can specify\
    \ numerically by setting the optional third parameter to 'cmp'.\nFor example,\
    \ to sort a list numerically:\n<code>\nmy = (2,1,10,3,5,5,8,4,6,10,9,8,7);\nprint\
    \ join \"\\n\", sort { $a <=> $b } map { $_->[0] }\n</code>\nprints\n<code>\n\
    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</code>\n<|/ a tags=sorting,perl |>\n<| c |>\n\
    +1: This is a far more elegant solution than what I proposed and also handles\
    \ lexical sorting.\n<|/ c |>\n<| c |>\nThis solution handles the special case\
    \ where the list has mixed numbers and words and is lexically sorted by words,\
    \ which is what I was looking for.\n<|/ c |>\n<| c |>\nIt ", "    my @numbers\
    \ = split \" \", $numbers;\n    my @sorted_numbers = sort { $a <=> $b } @numbers;\n\
    \    return join \" \", @sorted_numbers;\n}", "    my(@nums) = $numbers =~ /([0-9]+)/;\n\
    \    my @sorted_numbers = ();\n    my $i = 0;\n    foreach my $num (@nums) {\n\
    \        if ($num > $sorted_numbers[$i]) {\n            $sorted_numbers[$i] =\
    \ $num;\n        }\n        elsif ($num < $sorted_numbers[$i]) {\n           \
    \ push @sorted_numbers, $num;\n        }\n        $i++;\n    }\n    return join('\
    \ ', @sorted_numbers);\n}", "    my @numbers;\n    while (my $line = <STDIN>)\
    \ {\n        chomp $line;\n        if ($line =~ /\\b($numbers)\\b/) {\n      \
    \      push @numbers, $1;\n        } else {\n            die \"Invalid number\
    \ or missing numbers: $line\";\n        }\n    }\n    my $sorted = join(' ', @numbers);\n\
    \    $sorted =~ s/^\\s+|\\s+$//g;\n    $sorted =~ s/^\\s+//g;\n    $sorted =~\
    \ s/\\s+\\z//g;\n    return $sorted;\n}", "    chomp $numbers;\n    my($numbers_string)\
    \ = $numbers =~ m/^(.*)/s;\n    my($numbers_string) = ' ' . $numbers_string;\n\
    \    my($numbers_array) = $numbers_string =~ m/^([a-z]+\\s[a-z]+\\s[a-z]+)/;\n\
    \    my @numbers_array = @{$numbers_array};\n    my($smallest, $largest);\n  \
    \  for my $i (0 .. $#numbers_array) {\n        if ($numbers_array[$i] < $smallest)\
    \ {\n            $smallest = $numbers_array[$i];\n        }\n        if ($numbers_array[$i]\
    \ > $largest) {\n            $largest = $numbers_array[$i];\n        }\n    }\n\
    \    for my $i (0 .. $#numbers_array) {\n        if ($numbers_array[$i] == $smallest)\
    \ {\n            $numbers_array[$i] = $largest;\n        }\n    }\n    $numbers_string\
    \ = '';\n    for my $i (0 .. $#numbers_array) {\n        $numbers_string .= $numbers_array[$i];\n\
    \    }\n    $numbers_string =~ s/ /-/g;\n    $numbers_string;\n}", "    my(@numbers_strings);\n\
    \    \n    foreach my $number ( split /\\s+/, $numbers ) {\n        push( @numbers_strings,\
    \ $number );\n    }\n    \n    @numbers_strings = sort { $a <=> $b } @numbers_strings;\n\
    \    \n    $numbers =~ s/(^| )//g;\n    $numbers =~ s/(\\s+)//g;\n    $numbers\
    \ =~ s/$/ /g;\n    \n    return $numbers;\n}", "    my($resulting_numbers);\n\
    \    my($curr_num);", '    return $numbers if ! defined $numbers;', "    my @sorted_numbers;\n\
    \    \n    # Sort each number in turn\n    for my $number (split /\\s+/, $numbers)\
    \ {\n        # Remove 'zero' from 'zero'\n        my $number_cleaned = $number;\n\
    \        $number_cleaned =~ s/^zero//;", "    my @numbers_as_strings = split(/\
    \ /, $numbers);\n    my $nums_as_strings = join(\" \", @numbers_as_strings);",
  "    my($result,$word);\n    my(@sorted_numbers);", "    $numbers =~ s/^\\s+//;\n\
    \    $numbers =~ s/\\s+$//;\n    return $numbers unless $numbers =~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    my($first, $second);\n    $first .= $numbers unless $numbers =~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    $second .= $numbers unless $numbers =~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    $first = sort_string($first) if $first =~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    $second = sort_string($second) if $second =~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    return $first . $second;\n}", "    my @sorted_numbers;\n    my $i = 0;\n\
    \    my $current_number = \"\";\n    my @num_groups = ();\n    my $num_groups_length\
    \ = length($numbers) / LENGTH($numbers[0]);\n    for my $num (split ' ', $numbers)\
    \ {\n        if ($current_number ne $num) {\n            push @sorted_numbers,\
    \ $current_number;\n            $current_number = $num;\n        }\n        push\
    \ @num_groups, \"$num_groups_length\";\n        push @num_groups, $i;\n      \
    \  $i++;\n    }\n    push @sorted_numbers, $current_number;\n    @num_groups =\
    \ reverse @num_groups;", "    my @numbers = split ' ', $numbers;", "    chomp($numbers);\n\
    \    my @nums = split(/\\s+/, $numbers);\n    my @sorted = sort { $a <=> $b }\
    \ @nums;\n    return join(\" \", @sorted);\n}", "    my $newnumbers = \"\";\n\
    \    my @numberlist = split(\" \", $numbers);\n    foreach my $number (@numberlist)\
    \ {\n        chomp($number);\n        my($number) = $number =~ s/^\\s+|\\s+$//g;\n\
    \        if($number eq \"\") {\n            die \"Invalid number in $numbers\\\
    n\" if $verbose;\n        }\n        elsif($number !~ /^zero|one|two|three|four|five|six|seven|eight|nine$/)\
    \ {\n            die \"Invalid number in $numbers\\n\" if $verbose;\n        }\n\
    \        elsif($number =~ /^eight|nine$/) {\n            $number = \"nine\" if\
    \ $number eq \"nine\";\n        }\n        else {\n            $number = \"one\"\
    \ if $number eq \"one\";\n        }\n        elsif($number =~ /^three|four$/)\
    \ {\n            $number = \"four\" if $number eq \"four\";\n        }\n     \
    \   elsif($number =~ /^two|six$/) {\n            $number = \"six\" if $number\
    \ eq \"six\";\n        }\n        elsif($number =~ /^five|one$/) {\n         \
    \   $number = \"one\" if $number eq \"one\";\n        }\n        elsif($number\
    \ =~ /^seven|two$/) {\n            $number = \"two\" if $number eq \"two\";\n\
    \        }\n        elsif($number =~ /^nine|four$/) {\n            $number = \"\
    four\" if $number eq \"four\";\n        }\n        elsif($number =~ /^three|six$/)\
    \ {\n            $number = \"six\" if $number eq \"six\";\n        }\n       \
    \ elsif($number =~ /^five|two$/) {\n            $number = \"two\" if $number eq\
    \ \"two\";\n        }\n        elsif($number =~ /^one|five$/) {\n            $number\
    \ = \"five\" if $number eq \"five\";\n        }\n        elsif($number =~ /^seven|four$/)\
    \ {\n            $number = \"four\" if $number eq \"four\";\n        }\n     \
    \   elsif($number =~ /^nine|six$/) {\n            $number = \"six\" if $number\
    \ eq \"six\";\n        }\n        elsif($number =~ /^three|nine$/) {\n       \
    \     $number = \"nine\" if $number eq \"nine\";\n        }\n        elsif($number\
    \ =~ /^two|four$/) {\n            $", "    chomp($numbers);\n    my($digits) =\
    \ split \" \", $numbers;\n    my(@sortedNumbers);\n    my ($i, $j);", "    my(@strings)\
    \ = split ' ', $numbers;\n    my($first_num) = -1;\n    my($second_num) = -1;\n\
    \    my($largest) = 0;", "    my @numbers = $numbers =~ /([0-9])+/g;\n    my $output\
    \ = '';\n    foreach my $number (@numbers) {\n        my $index = $number =~ tr/0-9//cd;\n\
    \        $output .= $numbers[$index];\n    }\n    return $output;\n}", '    my($numbers_re);',
  "    $numbers =~ s/ /-/g;\n    my @numbers = split(\" \", $numbers);\n    foreach\
    \ my $number (@numbers) {\n        my @numbers_count = ();\n        for my $digit\
    \ (split \"\", $number) {\n            push @numbers_count, $digit =~ /\\d/g;\n\
    \        }\n        my $smallest = 0;\n        my $largest = 0;\n        if (@numbers_count\
    \ > 1) {\n            foreach my $count (@numbers_count) {\n                if\
    \ ($count > $largest) {\n                    $largest = $count;\n            \
    \    }\n                if ($count < $smallest) {\n                    $smallest\
    \ = $count;\n                }\n            }\n        }\n        my $output =\
    \ $number;\n        if ($smallest == 0) {\n            $output .= ' '.$smallest;\n\
    \        }\n        $output .= ' '.$largest;\n        $numbers[$number] = $output;\n\
    \    }\n    return join(\", \", @numbers);\n}", "    my($sorted_string);\n   \
    \ my $num_length = $numbers->length();\n    my $first_character = $numbers->[0];\n\
    \    $sorted_string = $numbers->[0];\n    for(my $number = 2; $number < $num_length;\
    \ $number++) {\n        if($numbers->[$number] =~ /^$first_character$/i) { # Match\
    \ previous element\n            push(@$sorted_string, $numbers->[$number]);\n\
    \            last;\n        }\n        push(@$sorted_string, $numbers->[$number]);\n\
    \    }\n    return $sorted_string;\n}", "    chomp($numbers);\n    my($num_string)\
    \ = split(/ /, $numbers);\n    my @nums = ();\n    foreach my $num (@$num_string)\
    \ {\n        my $num_str = $num;\n        if ($num_str =~ /^(\\d)$/) {\n     \
    \       $num_str = \"$num_str\" . 'zero';\n        }\n        $nums[$num_str]\
    \ = $num;\n    }\n    foreach my $i (sort {$a <=> $b} keys %nums) {\n        my\
    \ $num = $nums{$i};\n        delete $nums{$i};\n        $nums{$num} = $i;\n  \
    \  }\n    my $number = join(' ', map { $nums{$_} . '_' } sort {$a <=> $b} keys\
    \ %nums);\n    return $number;\n}", "    my @numbers = split ' ', $numbers;\n\
    \    my @sorted = ();\n    foreach (@numbers) {\n\tif ($_ eq 'zero') {\n\t   \
    \ push(@sorted, 'zero');\n\t}\n\telsif ($_ eq 'one') {\n\t    push(@sorted, 'one');\n\
    \t}\n\telsif ($_ eq 'two') {\n\t    push(@sorted, 'two');\n\t}\n\telsif ($_ eq\
    \ 'three') {\n\t    push(@sorted, 'three');\n\t}\n\telsif ($_ eq 'four') {\n\t\
    \    push(@sorted, 'four');\n\t}\n\telsif ($_ eq 'five') {\n\t    push(@sorted,\
    \ 'five');\n\t}\n\telsif ($_ eq 'six') {\n\t    push(@sorted, 'six');\n\t}\n\t\
    elsif ($_ eq 'seven') {\n\t    push(@sorted, 'seven');\n\t}\n\telsif ($_ eq 'eight')\
    \ {\n\t    push(@sorted, 'eight');\n\t}\n\telsif ($_ eq 'nine') {\n\t    push(@sorted,\
    \ 'nine');\n\t}\n\telse {\n\t    push(@sorted, $_);\n\t}\n    }\n    return join\
    \ ' ', @sorted;\n}", "    $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\s+$//;\n\
    \    $numbers =~ s/ /, /g;\n    my($sorted_numbers) = sort($numbers);\n    $sorted_numbers\
    \ =~ s/,$//;\n    $sorted_numbers =~ s/^\\s+|\\s+$//g;\n    return $sorted_numbers;\n\
    }", "    my($number);\n    my($string);\n    my($last, $first);\n    my($temp);",
  "    my @sorted_numbers = ();\n    my @possible_numbers = split ' ', $numbers;\n\
    \    my @possible_numbers_length = @possible_numbers;\n    \n    for (my $number\
    \ = 0; $number <= $possible_numbers_length; $number++) {\n        push @sorted_numbers,\
    \ $possible_numbers[$number];\n    }\n    return join ' ', @sorted_numbers;\n}",
  "    my($i, $value, $count);\n    my(@nums);\n    for ($i = 0; $i < length($numbers);\
    \ $i++) {\n        if ($numbers{$i} =~ /[\\d]/ and $i > 0) {\n            ($value\
    \ = $numbers{$i}, $count) = sort {\n                $a <=> $b\n            } reverse\
    \ $numbers{0..$i};\n            for (; $i < $count; $i++) {\n                $nums[$i-1]\
    \ = $nums[$i];\n            }\n            $nums[$i-1] = $value;\n        }\n\
    \    }\n    return join \" \", @nums;\n}", "    my($digit);\n    my($smallest);\n\
    \    my($largest);\n    \n    while($numbers =~ /(?<digit>\\d)(?<unit>(\\s*[\\\
    da-z])*)/gi){\n        if($digit < $unit){\n            $digit = $unit;\n    \
    \        $smallest = $numbers;\n        }\n        elsif($digit > $unit){\n  \
    \          $largest = $numbers;\n        }\n    }\n    return $smallest . $numbers;\n\
    }", "    my @nums;\n    my %hash;\n    my @sorted_numbers;", "    my(@numbers)\
    \ = split ' ', $numbers;\n    my @sorted;\n    my @counter;\n    my($first_digit,\
    \ $last_digit);\n    \n    @numbers = sort {\n\tif ($a eq $b) { $a cmp $b }\n\t\
    else {\n\t    $a cmp $b unless $a eq $b;\n\t    ($a <=> $b) unless $a <=> $b;\n\
    \t}\n    };\n    \n    # sort numbers from smallest to largest\n    @numbers =\
    \ reverse @numbers;", "    return $numbers if length($numbers) <= 1;\n    my @numbers\
    \ = split ' ', $numbers;\n    my %seen;\n    for (@numbers) {\n        my $num\
    \ = $_;\n        $num =~ s/^\\s*|\\s*$//g;\n        $seen{$num}++;\n        $num\
    \ =~ s/(?<!\\d)(?=\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\\
    d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\d)(?!\\", "    my($smallest, $largest);\n \
    \   foreach my $number (split /\\s+/, $numbers) {\n        my ($number) = $number\
    \ =~ /^(\\d+)$/;\n        $smallest = defined $smallest ? $smallest : $number;\n\
    \        $largest = defined $largest ? $largest : $number;\n    }\n    return\
    \ \"$smallest $largest\";\n}", "    my @numbers;\n    my($numbers_ref) = (\\@numbers);\n\
    \    $numbers_ref ||= ();\n    $numbers_ref += split ' ', $numbers;\n    foreach\
    \ (sort {$a <=> $b} @numbers_ref) {\n        $numbers_ref->[$_]++;\n    }\n  \
    \  $numbers = join(' ', @numbers_ref);\n    return $numbers;\n}", "    my($sorted,\
    \ $i);\n    my @numbers = split /\\s+/, $numbers;\n    my @sorted = ();", "  \
    \  my(@numbers) = ();\n    my($last);\n    my @sorted;", "    chomp($numbers);\n\
    \    my = split /\\s+/, $numbers;\n    my $min = $#numbers;\n    my $max = $#numbers;\n\
    \    my $counter = 0;\n    my $temp;", "    my(@sort) = ('zero','one','two','three','four','five','six','seven','eight','nine');\n\
    \    my($index, $value) = ('zero', '');\n    my @sorted_numbers = ();\n    foreach\
    \ my $number (split /\\s+/, $numbers) {\n        $value = $sort[$index] if $number\
    \ =~ /^($sort\\d)/;\n        $number =~ s/^$value//;\n        push (@sorted_numbers,\
    \ $number) unless $number eq $value;\n        $index = ($index + 1) % @sort;\n\
    \    }\n    return @sorted_numbers;\n}", "    my($numbers_sorted) = ();\n    my(@numbers)\
    \ = split ' ', $numbers;\n    my($smallest_number) = pop(@numbers);\n    my($largest_number)\
    \ = pop(@numbers);\n    $smallest_number = 0;\n    $largest_number = 9;\n    foreach\
    \ my $number (@numbers) {\n        if ($number > $largest_number) {\n        \
    \    $largest_number = $number;\n        }\n        if ($number < $smallest_number)\
    \ {\n            $smallest_number = $number;\n        }\n    }\n    foreach my\
    \ $number (@numbers) {\n        if ($number < $smallest_number) {\n          \
    \  push(@numbers_sorted, $number);\n        } elsif ($number > $largest_number)\
    \ {\n            push(@numbers_sorted, $number);\n        } else {\n         \
    \   push(@numbers_sorted, $smallest_number);\n            push(@numbers_sorted,\
    \ $number);\n            push(@numbers_sorted, $largest_number);\n        }\n\
    \    }\n    join(\" \", @numbers_sorted);\n}", "    my @numbers = split ' ', $numbers;\n\
    \    my $sorted = join(\" \", sort @numbers);\n    return $sorted;\n}", "    my(@sorted_numbers);\n\
    \    my $num = 0;\n    my $num_len = length($numbers);\n    $numbers =~ s/\\s+//g;\n\
    \    while ($num < $num_len) {\n        if ($num == 0) {\n            $sorted_numbers[$num]\
    \ = $numbers->[$num];\n            $num++;\n        }\n        else {\n      \
    \      my $smallest_num = $numbers->[$num - 1];\n            my $smallest_pos\
    \ = 0;\n            for (my $i = 1; $i < $num; $i++) {\n                if ($numbers->[$i]\
    \ < $smallest_num) {\n                    $smallest_num = $numbers->[$i];\n  \
    \                  $smallest_pos = $i;\n                }\n            }\n   \
    \         if ($smallest_num == $numbers->[$smallest_pos]) {\n                $sorted_numbers[$num\
    \ - 1] = $numbers->[$smallest_pos];\n                $sorted_numbers[$num] = $numbers->[$num\
    \ - 1];\n            }\n            else {\n                $sorted_numbers[$num\
    \ - 1] = $numbers->[$smallest_pos];\n                $sorted_numbers[$num] = $numbers->[$num];\n\
    \            }\n        }\n    }\n    return @sorted_numbers;\n}", "    my ($numbers_array)\
    \ = split (\" \", $numbers);\n    \n    my @numbers_array = sort {\n        my\
    \ $x_value = $a =~ /\\d/;\n        my $y_value = $b =~ /\\d/;\n        my $x_value_length\
    \ = length($x_value);\n        my $y_value_length = length($y_value);\n      \
    \  $x_value_length < $y_value_length ? -1 : 1;\n    } @$numbers_array;", "   \
    \ my @nums = map { /^(\\d+)$/ ? $1\n                        : $_\n           \
    \       } split ' ', $numbers;\n    my @sorted = sort { $a <=> $b } @nums;\n \
    \   return join ' ', @sorted;\n}", "    my(@num_string) = split(/ /, $numbers);\n\
    \    my($sorted_num_string) = \"\";", "    my @parts = split ' ', $numbers;\n\
    \    my $count = scalar($parts);\n    if ($count > 5) {\n        die \"Invalid\
    \ input for sort_numbers: '$numbers'\";\n    }", "    $numbers ||= \"\";\n   \
    \ my @numbers = split /\\s+/, $numbers;\n    my %hash;\n    foreach my $num (@numbers)\
    \ {\n        if (exists $hash{$num}) {\n            $hash{$num}++;\n        }\
    \ else {\n            $hash{$num} = 1;\n        }\n    }\n    foreach my $key\
    \ (keys %hash) {\n        push @numbers, $key if ($hash{$key} >= 2);\n    }\n\
    \    return join(\" \", @numbers);\n}", "    my(@numbers);\n    foreach my $number(split\
    \ /\\s+/, $numbers) {\n        if ($number =~ /^\\d+$/) {\n            push @numbers,\
    \ $number;\n        }\n    }\n    sort { $a <=> $b } @numbers;\n    return join\
    \ ' ', map { $_ + 0 } @numbers;\n}", "    my($num_string) = join ' ', $numbers;\n\
    \    my($num_array) = split /\\s+/, $num_string;\n    my($sorted_array) = sort\
    \ {$a <=> $b} @$num_array;\n    my $num_string = join ' ', @$sorted_array;\n \
    \   return $num_string;\n}", "    my @nums = split(\" \", $numbers);\n    sort(@nums);\n\
    \    return join(\" \", @nums);\n}", "    my($sorted_numbers) = \"\";\n    my($numbers_hash);\n\
    \    foreach my $number (split(/ /, $numbers)) {\n        next unless ($number\
    \ =~ /[0-9]+/);\n        my $key = substr($number, 0, 1);\n        if (!defined($numbers_hash->{$key}))\
    \ {\n            $numbers_hash->{$key} = [];\n        }\n        push @{ $numbers_hash->{$key}\
    \ }, $number;\n    }", "    $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\s+$//;\n\
    \    $numbers !~ /[\\d]{9}/g or die \"Invalid input\\n\";\n    my %nums = map\
    \ { $_ => 1 } split /\\s+/, $numbers;\n    $numbers = join \" \", sort {\n   \
    \     my $n = $nums{$a} <=> $nums{$b};\n        return $n if $n\n    };\n    return\
    \ $numbers;\n}", "    my @numbers = split ' ', $numbers;\n    my @sorted_numbers;\n\
    \    my $current_number_string = 'zero';\n    my $next_number_string = 'nine';\n\
    \    my $current_number = 0;\n    foreach my $number (@numbers) {\n        if\
    \ ($number eq 'zero') {\n            $current_number_string = 'one';\n       \
    \ } elsif ($number eq 'one') {\n            $current_number_string = 'two';\n\
    \        } elsif ($number eq 'two') {\n            $current_number_string = 'three';\n\
    \        } elsif ($number eq 'three') {\n            $current_number_string =\
    \ 'four';\n        } elsif ($number eq 'four') {\n            $current_number_string\
    \ = 'five';\n        } elsif ($number eq 'five') {\n            $current_number_string\
    \ = 'six';\n        } elsif ($number eq 'six') {\n            $current_number_string\
    \ = 'seven';\n        } elsif ($number eq 'seven') {\n            $current_number_string\
    \ = 'eight';\n        } elsif ($number eq 'eight') {\n            $current_number_string\
    \ = 'nine';\n        } elsif ($number eq 'nine') {\n            $current_number_string\
    \ = 'zero';\n        } else {\n            $current_number_string = 'unknown number';\n\
    \        }\n        if ($number gt $next_number_string) {\n            push (@sorted_numbers,\
    \ $current_number_string);\n        }\n        if ($number lt $next_number_string)\
    \ {\n            $next_number_string = $current_number_string;\n        }\n  \
    \      if ($number eq $current_number_string) {\n            $current_number++;\n\
    \        }\n    }\n    push (@sorted_numbers, $current_number_string);\n    return\
    \ join(' ', @sorted_numbers);\n}\n</code>\n<|/ a tags=sorting,perl,algorithm |>\n\
    <| a |>\nHere's a solution which I implemented with Bash arrays, and a couple\
    \ other tricks.\n<code>", "    my @numbers = split ' ', $numbers;\n    return\
    \ map { sprintf(\"%s %3d\", $_, $numbers[$#numbers]) };\n}", "    chomp($numbers);\n\
    \    $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\s+$//;\n    my @numbers = split(\"\
    \ \", $numbers);\n    \n    my $num_string = \"\";\n    my $num = 0;\n    foreach\
    \ my $numstring (@numbers) {\n\tmy $numstringlower = lc($numstring);\n\t$numstring\
    \ = $numstringlower;\n\t$num += $numstring =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/i\n\
    \t    ? $1 : \"invalid value\";\n    }\n    \n    my $sorted = $num;\n    my $numbers_string;\n\
    \    foreach my $numstring (@numbers) {\n\tmy $numstringlower = lc($numstring);\n\
    \t$numstring = $numstringlower;\n\t$num += $numstring =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/i\n\
    \t    ? $1 : \"invalid value\";\n\t$numbers_string .= $numstring;\n\t$numbers_string\
    \ .= \" \";\n    }", "    my($num_str) = &parse($numbers);\n    my($sorted_str);",
  "    my @numbers;\n    my(@num_counts);\n    my $numbers_string = qr/^(?:zero|one|two|three|four|five|six|seven|eight|nine)\\\
    s+(?:zero|one|two|three|four|five|six|seven|eight|nine)\\s+(?:zero|one|two|three|four|five|six|seven|eight|nine)$/;",
  '    my @sorted_numbers = ();', "    $numbers .= \" \" if not defined $numbers;\n\
    \    my @numbers = split /\\s+/, $numbers;\n    my $smallest = $numbers[0];\n\
    \    my $largest = $numbers[4];\n    my $digit;\n    my $result;\n    for (my\
    \ $i = 0; $i < @numbers; ++$i) {\n        $digit = substr($numbers[$i], 0, 1);\n\
    \        $smallest = $numbers[$i] if $smallest > $digit;\n        $largest = $numbers[$i]\
    \ if $largest < $digit;\n        $numbers[$i] = $digit;\n    }\n    for (my $i\
    \ = 0; $i < @numbers; ++$i) {\n        $digit = $numbers[$i];\n        $smallest\
    \ = $numbers[$i] if $smallest > $digit;\n        $largest = $numbers[$i] if $largest\
    \ < $digit;\n        $numbers[$i] = $digit;\n    }\n    $result = join(\" \",\
    \ @numbers);\n    $result =~ s/^\\s+|\\s+$//g;\n    $result;\n}", "    $numbers\
    \ =~ s/\\s+/ /;\n    my @sorted = sort { $a <=> $b } split ' ', $numbers;\n  \
    \  return join ' ', @sorted;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not give\
    \ the correct result: \"one two three\" should be \"one three two\" because \"\
    one\" comes before \"three\".\n<|/ c |>\n<| c |>\n: good point, have updated to\
    \ use <=> instead of cmp which seems to work as expected\n<|/ c |>\n<| c |>\n\
    Ah, yes. Didn't think that through. Your code still has problems with \"one two\
    \ three\". You'll have to use <=>.\n<|/ c |>\n<| c |>\n: I actually thought about\
    \ using <=> but forgot about it. It works great, I will update my answer to include\
    \ your code. Thanks!\n<|/ c |>\n<| c |>\n: I updated my answer to use <=> instead\
    \ of cmp.\n<|/ c |>\n<| a dscore=3 |>\nJust out of curiosity:\n<code>", "    my\
    \ @nums = split(/ /, $numbers);\n    my $new_numbers = \"\";\n    my $num;\n \
    \   for ($numbers->[0]) {\n        if ($num < $nums[-1]) {\n            push @nums,\
    \ $num;\n        }\n        $num++;\n    }\n    for ($nums[-1]) {\n        push\
    \ @nums, $num;\n        $num++;\n    }\n    for ($numbers) {\n        $new_numbers\
    \ .= $_ . \" \";\n    }\n    return $new_numbers;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a |>\nJust another option to consider that keeps the list sorted:\n<code>",
  "    my @numbers = split ' ', $numbers;\n    my @sorted_numbers;\n    $_ = shift\
    \ @sorted_numbers while @numbers;\n    push (@sorted_numbers, $_) for (sort {\
    \ $b <=> $a } @numbers);\n    return join ' ', @sorted_numbers;\n}", "    my(@nums);\n\
    \    my($i, $j, $num);", "    chomp $numbers;\n    my @numbers_array = split /\\\
    s+/, $numbers;", "    my(@numbers_sort) = ();\n    my($i, $j, $n);\n    foreach\
    \ $n (split(/ /, $numbers)) {\n        $n = lc($n);\n        if ($n =~ /zero/i)\
    \ {\n            @numbers_sort += ('0');\n        } elsif ($n =~ /one/i) {\n \
    \           @numbers_sort += ('1');\n        } elsif ($n =~ /two/i) {\n      \
    \      @numbers_sort += ('2');\n        } elsif ($n =~ /three/i) {\n         \
    \   @numbers_sort += ('3');\n        } elsif ($n =~ /four/i) {\n            @numbers_sort\
    \ += ('4');\n        } elsif ($n =~ /five/i) {\n            @numbers_sort += ('5');\n\
    \        } elsif ($n =~ /six/i) {\n            @numbers_sort += ('6');\n     \
    \   } elsif ($n =~ /seven/i) {\n            @numbers_sort += ('7');\n        }\
    \ elsif ($n =~ /eight/i) {\n            @numbers_sort += ('8');\n        } elsif\
    \ ($n =~ /nine/i) {\n            @numbers_sort += ('9');\n        } else {\n \
    \           croak(\"sort_numbers failed: unexpected number '$n'\", $usage);\n\
    \        }\n    }", "    my($string);\n    my(@strings);", "    my(@numbers_as_strings);\n\
    \    my($lowest_number_to_be_first) = 0;\n    my($highest_number_to_be_last) =\
    \ 9;", "    $numbers =~ s/^\\s+//;\n    my(@numbers_str) = $numbers =~ m/([0-9]+)/ig;\n\
    \    my($zero, $one, $two, $three, $four, $five, $six, $seven, $eight, $nine)\
    \ = \n        $numbers_str =~ m/(zero|one|two|three|four|five|six|seven|eight|nine)/ig;\n\
    \    my @numbers = ();\n    for ($zero, $one, $two, $three, $four, $five, $six,\
    \ $seven, $eight, $nine) \n    {\n        $numbers[$nine] = $nine;\n        $numbers[$eight]\
    \ = $eight;\n        $numbers[$seven] = $seven;\n        $numbers[$six] = $six;\n\
    \        $numbers[$five] = $five;\n        $numbers[$four] = $four;\n        $numbers[$three]\
    \ = $three;\n        $numbers[$two] = $two;\n        $numbers[$one] = $one;\n\
    \        $numbers[$zero] = $zero;\n    }\n    my $i = 0;\n    for ($i = 1; $i\
    \ <= $#numbers; $i++) \n    {\n        push (@numbers, $numbers[$i] if ($numbers[$i]\
    \ ne $numbers[$i-1]));\n    }\n    my $sorted_number = \"\";\n    for ($i = 0;\
    \ $i <= $#numbers; $i++) \n    {\n        $sorted_number .= $numbers[$i];\n  \
    \  }\n    $sorted_number;\n}", "    my @nums = split \" \", $numbers;\n    @nums\
    \ = sort { $a <=> $b } @nums;\n    return join \" \", @nums;\n}", "    my @numbers\
    \ = split ' ', $numbers;\n    my $sorted = join(\" \", sort {$a <=> $b} @numbers);\n\
    \    return $sorted;\n}\n</code>\n<|/ a |>\n<| c |>\nThis answer isn't too bad,\
    \ but it doesn't explain why the OP's code doesn't work. It'd be better to explain\
    \ that sort is doing what its supposed to, but not why it doesn't work in your\
    \ code.\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works well. But\
    \ I tried to change the order of the numbers inputted in the parameter, and it\
    \ doesn't work. It works when I put \"one three five\" as parameter. But not when\
    \ I put \"five three one\". Is there any way that I can change the parameter order\
    \ in \"my sort_numbers\" function?\n<|/ c |>\n<| c |>\nThe order of the input\
    \ is irrelevant. Try `sort_numbers(\"one three five\")` or `sort_numbers(\"five\
    \ three one\")`.\n<|/ c |>\n<| a |>\nThe solution from is perfectly fine, but\
    \ if you have many numbers to sort, it would be better to write it in a way that\
    \ returns a list.\n<code>\nuse strict;\nuse warnings;", "    my(@nums);\n    my($min,\
    \ $max);\n    foreach my $x (split \" \", $numbers) {\n        if ($x =~ /^[0-9]*$/)\
    \ {\n            push(@nums, $x);\n        }\n    }\n    foreach my $i (0 .. 9)\
    \ {\n        my($j, $k) = grep {$i eq $_} @nums;\n        if ($k) {\n        \
    \    $min = $i;\n            $max = $j;\n            last;\n        }\n    }\n\
    \    my $n = $max;\n    if ($n =~ /^0*\\z/) {\n        $n = \"$n\";\n    }\n \
    \   $n =~ s/^(\\d)$/$1-$min/;\n    $n = sprintf(\"%03d\", $n);\n    return $n;\n\
    }", "    my(@sorted_numbers);\n    foreach $number (split /\\s+/, $numbers) {\n\
    \        if ($number =~ /zero/) {\n            $sorted_numbers[0] = $number;\n\
    \            next;\n        }\n        elsif ($number =~ /one/) {\n          \
    \  $sorted_numbers[1] = $number;\n            next;\n        }\n        elsif\
    \ ($number =~ /two/) {\n            $sorted_numbers[2] = $number;\n          \
    \  next;\n        }\n        elsif ($number =~ /three/) {\n            $sorted_numbers[3]\
    \ = $number;\n            next;\n        }\n        elsif ($number =~ /four/)\
    \ {\n            $sorted_numbers[4] = $number;\n            next;\n        }\n\
    \        elsif ($number =~ /five/) {\n            $sorted_numbers[5] = $number;\n\
    \            next;\n        }\n        elsif ($number =~ /six/) {\n          \
    \  $sorted_numbers[6] = $number;\n            next;\n        }\n        elsif\
    \ ($number =~ /seven/) {\n            $sorted_numbers[7] = $number;\n        \
    \    next;\n        }\n        elsif ($number =~ /eight/) {\n            $sorted_numbers[8]\
    \ = $number;\n            next;\n        }\n        elsif ($number =~ /nine/)\
    \ {\n            $sorted_numbers[9] = $number;\n            next;\n        }\n\
    \    }\n    return join(' ', @sorted_numbers);\n}", "    my @nums = split(\" \"\
    , $numbers);\n    my @sort = map (0, @nums) grep {$_ >= 0} @nums;\n    return\
    \ join(\", \", @sort);\n}", "    return join(\" \", sort {$a <=> $b} split /\\\
    s+/, $numbers);\n}\n</code>\n<|/ a tags=algorithm,sorting,perl |>\n<| c |>\nHe\
    \ said the numbers come in *in order*.  He doesn't mention leading zeros.\n<|/\
    \ c |>\n<| c |>\nThat wasn't in the original requirements.\n<|/ c |>\n<| c |>\n\
    Yes, this is exactly the solution I needed.  Thanks!\n<|/ c |>\n<| c |>\nNo problem,\
    \ glad I could help.\n<|/ c |>\n<| c |>\nI ran a benchmark test on all the three\
    \ algorithms and this one performs better than the other two in almost all cases.\
    \  For a large sample size the results differ drastically.\n<|/ c |>\n<| a dscore=4\
    \ |>\nI believe that this should be the fastest in Perl\n<code>\nuse strict;\n\
    use warnings;", "    my @numbers1 = split(/ /, $numbers);\n    my @numbers2 =\
    \ ();\n    for (my $i = 0; $i < $#numbers1; $i++) {\n        my $number = $numbers1->[$i];\n\
    \        $number = lc($number);\n        for (my $j = 0, $n = 9; $j < $n; $j++)\
    \ {\n            my $test = $j;\n            if ($test == $number && $test > 0\
    \ && $test <= 9) {\n                $test++;\n                last if $test >\
    \ $number;\n                push @numbers2, $test;\n            }\n        }\n\
    \    }\n    return join(\" \", @numbers2);\n}", "    my @nums = split / / => $numbers;\n\
    \    my @sorted = sort {\n        return $a <=> $b;\n    } @nums;\n    my $str\
    \ = join \" \", @sorted;\n    return $str;\n}", "    my @numbers = split(/ /,\
    \ $numbers);\n    my $result = join(\" \", map { $numbers[$_] } 0..$#numbers);\n\
    \    return $result;\n}", "    my @nums = ();\n    for ($numbers); { $nums[$_]\
    \ = $_ } # put numbers into a list\n    my $length = @nums;\n    if ($length ==\
    \ 0) { return \"zero\"; }\n    if ($length == 1) {\n        my $num = $nums[0];\n\
    \        if ($num =~ /^zero$/) { return \"zero\"; }\n        if ($num =~ /^one$/)\
    \ { return \"one\"; }\n        if ($num =~ /^two$/) { return \"two\"; }\n    \
    \    if ($num =~ /^three$/) { return \"three\"; }\n        if ($num =~ /^four$/)\
    \ { return \"four\"; }\n        if ($num =~ /^five$/) { return \"five\"; }\n \
    \       if ($num =~ /^six$/) { return \"six\"; }\n        if ($num =~ /^seven$/)\
    \ { return \"seven\"; }\n        if ($num =~ /^eight$/) { return \"eight\"; }\n\
    \        if ($num =~ /^nine$/) { return \"nine\"; }\n    }\n    my @sorted = sort\
    \ {\n        $a <=> $b\n    } @nums;\n    # Convert sorted numbers into words\n\
    \    my @sorted_words;\n    my $i = 1;\n    for (@sorted) {\n        my $word\
    \ = ($i == 1) ? \"one\" : \"two\";\n        $word .= \" \" if $i == $length;\n\
    \        $word .= \"three\" if $i == $length/2;\n        $word .= \" \" if $i\
    \ == $length/3;\n        $word .= \"four\" if $i == $length/4;\n        $word\
    \ .= \" \" if $i == $length/5;\n        $word .= \"five\" if $i == $length/5;\n\
    \        $word .= \" \" if $i == $length/6;\n        $word .= \"six\" if $i ==\
    \ $length/6;\n        $word .= \" \" if $i == $length/7;\n        $word .= \"\
    seven\" if $i == $length/7;\n        $word .= \" \" if $i == $length/8;\n    \
    \    $word .= \"eight\" if $i == $length/8;\n        $word .= \" \" if $i == $length/9;\n\
    \        $word .= \"nine\" if $i == $length/9;\n        push(@sorted_words, $word);\n\
    \        $i++;\n    }\n    return join(\" \", @sorted_words);\n}", '    my(@new_numbers);',
  '    my $number = "";', "    my ($first, $last) = split ' ', $numbers;\n    if (\
    \ $first eq 'zero' ) { $first = 1; $last = 9; }\n    my $numbers = join ' ', sort\
    \ { $a <=> $b } split / /, $first, $last;\n    $numbers =~ s/ /-/g;\n    $numbers\
    \ =~ s/^\\-//;\n    return $numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nPlease read\
    \ the other answers before you post this one.\n<|/ c |>\n<| c |>\nI agree. Your\
    \ answer was a nice effort, but didn't quite answer the question that was asked.\
    \ My answer does answer the question that was asked :-).\n<|/ c |>\n<| c |>\n\
    : I posted it after your answer was posted.\n<|/ c |>\n<| a dscore=3 tags=perl,sorting,algorithm,string\
    \ |>\nI wanted to do this without splitting a string and came up with this.\n\
    <code>\nuse strict;\nuse warnings;", "    my @sorted;\n    my @nums;", '    my($i,
    $j, $temp, $temp2);', "    my($largest, $smallest) = (0, 0);\n    my($numbers_array)\
    \ = split (\" \", $numbers);\n    $numbers_array =~ tr/0-9//d;\n    $numbers_array\
    \ =~ sort { $a <=> $b };\n    return join (\" \", @$numbers_array);\n}", "   \
    \ return join(' ', map { uc($_) } sort(split ' ', $numbers));\n}", "    my(@numbers)\
    \ = split ' ', $numbers;\n    my($min, $max);\n    if ($numbers[0] =~ /^0?([1-9])$/)\
    \ {\n        # $min is the largest number in the list.\n        # $max is the\
    \ smallest number in the list.\n        $min = substr($numbers[0], 0, 1);\n  \
    \      $max = substr($numbers[0], 0, 1);\n    }\n    else {\n        # $min is\
    \ the smallest number in the list.\n        # $max is the largest number in the\
    \ list.\n        $min = substr($numbers[0], -1, 1);\n        $max = substr($numbers[0],\
    \ 0, 1);\n    }\n    return $min . $max . join(\" \", @numbers);\n}\n</code>\n\
    <|/ a tags=perl,sorting |>\n<| a |>\nUse a hash with the key being the number,\
    \ and the value being the number of occurrences.  Then simply sort the keys and\
    \ print the values.\n<code>\nuse warnings;\nuse strict;", "    $numbers =~ s/^\\\
    s+//;\n    $numbers =~ s/\\s+$//;\n    my($numbers_str);\n    my($sorted_numbers);\n\
    \    my(@sorted_numbers);", '    my @numbers_array = split / /, $numbers;', " \
    \   # Don't bother if $numbers doesn't contain any numbers.\n    return $numbers\
    \ if !$numbers =~ /\\d/;\n    my $sorted = join(\" \", sort { $a <=> $b } split\
    \ /\\s+/, $numbers);\n    $sorted =~ s/^\\s+|\\s+$//;\n    $sorted;\n}", '    my
    @sorted = ();', "    my @numbers = split( /\\s+/, $numbers );\n    my $num_len\
    \ = 0;\n    foreach my $num ( @numbers ) {\n        $num_len += length($num);\n\
    \    }", "    return $numbers if $numbers !~ /\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    b/;\n    $numbers =~ s/(\\d+)/ sprintf(\"%03d\", $1) /eg;\n    return sort {$a\
    \ <=> $b} split / /, $numbers;\n}", "    $numbers .= ' ' x (length($numbers)-1);\n\
    \    my @numbers = split /\\s+/, $numbers;\n    my @sorted;\n    my $i=0;\n  \
    \  $numbers[$i] = 'zero';\n    push(@sorted,$numbers[$i]);\n    push(@sorted,$numbers[$i]);\n\
    \    for($i=1;$i<=9;$i++) {\n        push(@sorted,$numbers[$i]);\n    }\n    return\
    \ @sorted;\n}\n</code>\n<|/ a tags=perl,sorting,perl-data-structures,list dscore=0\
    \ |>\n<| c |>\nThanks. I actually don't really need to sort the array from smallest\
    \ to largest. I just needed to convert them to string first before I can use the\
    \ sort subroutine.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", " \
    \   my @nums = split \" \", $numbers;\n    my @sorted = sort {$a <=> $b} @nums;\n\
    \    return join \" \", @sorted;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| a\
    \ tags=perl,arrays |>\nSure - here's one way using sort.\n<code>\nmy $numbers\
    \ = \"three one five\";", "    my(@numbers_strings);\n    my($number);\n    my($string);",
  '    my @list = ();', "    return map {\n        ($numbers[$_] =~ /((?!zero|one|two|three|four|five|six|seven|eight|nine)[a-z]*/ig)\
    \ || \"other\")\n    } 0..($numbers-1) \n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Perhaps you should add a `use strict;` and `use warnings;` to your code. Or at\
    \ least use `use warnings;`. The reason is that `use strict;` is enabled by default.\
    \ http://perldoc.perl.org/strict.html\n<|/ c |>\n<| c |>\nWhy not `return map\
    \ { my $n = ($_ =~ /((?!zero|one|two|three|four|five|six|seven|eight|nine)[a-z]*/ig);\
    \ $n ? $n : \"other\" } 0..($numbers-1);`\n<|/ c |>\n<| c |>\n: You could, but\
    \ the ternary operator is easier to read, IMO.\n<|/ c |>\n<| c |>\nThat is true,\
    \ but `return map { my $n = $_; $n =~ /.../i; $n || $n ? \"other\" } 0..($numbers-1);`\
    \ is shorter (and it doesn't need `use strict;` or `use warnings;`)\n<|/ c |>\n\
    <| a |>\nI know nothing about Perl, but here's my take on a Python solution:\n\
    <code>\n>>> def sort_numbers(s):\n    numbers = s.split()\n    newNumbers = []\n\
    \    sortedNumbers = []\n    for number in numbers:\n        if number == \"other\"\
    :\n            sortedNumbers.append(number)\n        else:\n            number\
    \ = int(number)\n            if number <= 9 and number != 0:\n               \
    \ sortedNumbers.append(number)\n            elif number != 9 and number != 1:\n\
    \                newNumbers.append(number)\n    sortedNumbers.extend(newNumbers)\n\
    \    return \" \".join(str(x) for x in sortedNumbers)", "    my(@numbers);\n \
    \   \n    $numbers =~ s/^\\s+//g;\n    $numbers =~ s/\\s+$//g;\n    $numbers =~\
    \ s/\\s+/ /g;\n    \n    chomp($numbers);\n    \n    @numbers = split ' ', $numbers;\n\
    \    \n    @numbers = sort {\n        my $a_num = $a =~ /\\d+/;\n        my $b_num\
    \ = $b =~ /\\d+/;\n        return $a_num <=> $b_num;\n    } @numbers;\n    \n\
    \    \n    my $result = join ' ', @numbers;\n    \n    return $result;\n}", " \
    \   my @nums = split /\\s+/, $numbers;\n    my @sorted;\n    my $last_num;\n \
    \   for my $num (@nums) {\n        if ($num =~ /^(\\d)$/) { # if $num is a number,\
    \ add it to the sorted array\n            push(@sorted, $num);\n        }\n  \
    \      elsif ($num =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/)\
    \ { # if $num is a string of numbers, add it to the sorted array\n           \
    \ push(@sorted, $1);\n            $last_num = $1;\n        }\n        elsif ($num\
    \ =~ /^(ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen)$/)\
    \ { # if $num is a string of numbers, add it to the sorted array\n           \
    \ push(@sorted, $1);\n        }\n        elsif ($num =~ /^(twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)$/)\
    \ { # if $num is a string of numbers, add it to the sorted array\n           \
    \ push(@sorted, $1);\n        }\n        elsif ($num =~ /^(third|fourth|fifth|sixth|seventh|eighth|ninth)$/)\
    \ { # if $num is a string of numbers, add it to the sorted array\n           \
    \ push(@sorted, $1);\n        }\n    }\n    join(' ', @sorted);\n}", "    $numbers\
    \ =~ tr/ +/\\n/;\n    $numbers =~ s/^\\s+|\\s+$//g;\n    $numbers =~ s/\\s+/ /g;\n\
    \    my @nums = split ' ', $numbers;\n    my @sorted_nums = sort {\n        $a\
    \ <=> $b\n    } @nums;\n    my $str = join ' ', @sorted_nums;\n    $str =~ s/\\\
    n/ /g;\n    return $str;\n}", "    my($sorted);\n    my($word);\n    my($first);",
  "    my @result = ();\n    my @numbers = split ' ', $numbers;\n    \n    for (my\
    \ $i = 0; $i <= $#numbers; ++$i) {\n        my $min = $i;\n        for (my $j\
    \ = $i + 1; $j <= $#numbers; ++$j) {\n            my $num = $numbers[$i];\n  \
    \          my $num2 = $numbers[$j];\n            if ($num < $num2) {\n       \
    \         $min = $j;\n            }\n        }\n        push (@result, $numbers[$min]);\n\
    \    }\n    return join \" \", @result;\n}", "    my @numbers = split(/ /, $numbers);\n\
    \    \n    foreach my $i (sort @numbers) {\n        print $i . \" \";\n    }\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe only problem with this is that it\
    \ will return 0 at the beginning of the string. So if you do `sort_numbers(\"\
    4 1 5\")` it will return `\"0 1 5\"` instead. Perhaps add an `if ($i == 0) { $i\
    \ = \"0\"; }` before the `print`?\n<|/ c |>\n<| c |>\nYeah, I edited the code\
    \ so that it doesn't have that problem.\n<|/ c |>\n<| a |>\nHere is what I would\
    \ do:\n<code>", "    $numbers =~ s/\\D+//g;\n    $numbers =~ s/\\s+/ /g;\n   \
    \ my($space, $comma) = (\" \", \",\");\n    my($min, $max);\n    foreach my $n\
    \ (split /\\s+/, $numbers) {\n\tmy $num;\n\tif ($n =~ /^(\\d+)$/) {\n\t    $num\
    \ = $1;\n\t} elsif ($n =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/)\
    \ {\n\t    $num = $n;\n\t} else {\n\t    die \"Couldn't parse $n as a number\"\
    ;\n\t}\n\t$min = 10000;\n\t$max = -10000;\n\tforeach my $c (split('', $num)) {\n\
    \t    $max = $c  < $max ? $c  : $max;\n\t    $min = $c > $min ? $c : $min;\n\t\
    }\n\tmy $min = sprintf \"%d\", $min;\n\tmy $max = sprintf \"%d\", $max;\n\t$n\
    \ = $min;\n\tfor (my $i = $max; $i > $min; $i--) {\n\t    $n = $comma if $i mod\
    \ 10 == 0;\n\t    $n = $space if $i mod 10 != 0;\n\t    $n .= $i;\n\t}\n\t$numbers\
    \ = $n;\n    }\n    return $numbers;\n}", "    my(@nums) = split ' ', $numbers;\n\
    \    my @num_sort = sort {\n        my $n = $a <=> $b;\n        $n ||= $a cmp\
    \ $b;\n    } @nums;\n    return join ' ', @num_sort;\n}\n</code>\n<|/ a tags=sorting,perl\
    \ |>\n<| c |>\nNot sure if this is the best solution, but it is definitely a lot\
    \ more readable than my answer.\n<|/ c |>\n<| c |>\nThis doesn't handle sorting\
    \ \"three one three\" correctly.\n<|/ c |>\n<| c |>\n: I assumed that was a typo\
    \ and will fix the answer to handle that.\n<|/ c |>\n<| c |>\n: I actually like\
    \ the `split ' ', $numbers` solution better since that removes all the `split\
    \ ' '` calls from the code which I thought was slow.\n<|/ c |>\n<| a |>\nThe first\
    \ thing that comes to mind is this:\n<code>", "    return join ' ', sort { $a\
    \ <=> $b } map { my($i, $n) = split '\\s+', $numbers++$i } ('zero', 'one', 'two',\
    \ 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine');\n}", "    my @numbers_as_strings\
    \ = split ' ', $numbers;\n    my $number_strings = join ' ', @numbers_as_strings;\n\
    \    return join ' ', sort {$a <=> $b} split ' ', $number_strings;\n}", "    my(@numbers_ordered);\n\
    \    my($numbers_as_string);\n    my($max_value_so_far, $current_value);\n   \
    \ \n    if ($numbers =~ /^(-?[0-9]+)\\s*(-?[0-9]+)\\s*(-?[0-9]+)$/) {\n      \
    \  push(@numbers_ordered, $1);\n        push(@numbers_ordered, $2);\n        push(@numbers_ordered,\
    \ $3);\n    } else {\n        return \"Invalid input: $_\";\n    }\n    \n   \
    \ for ($i = $#numbers_ordered - 1;$i >= 0;$i --) {\n        if ($numbers_ordered[$i]\
    \ eq 'zero') {\n            $numbers_as_string = '0';\n        } else {\n    \
    \        $numbers_as_string = $numbers_ordered[$i];\n        }\n        \n   \
    \     if ($max_value_so_far < $numbers_as_string) {\n            $max_value_so_far\
    \ = $numbers_as_string;\n        }\n    }\n    \n    $numbers_as_string =~ s/^0/-/g;\n\
    \    $numbers_as_string =~ s/^-$//g;\n    $numbers_as_string =~ s/^-/-/g;\n  \
    \  $numbers_as_string =~ s/^0/-0/g;\n    $numbers_as_string =~ s/^0/0/g;\n   \
    \ $numbers_as_string =~ s/^0/-/g;\n    $numbers_as_string =~ s/^-/-/g;\n    $numbers_as_string\
    \ =~ s/^-$/-$/g;\n    $numbers_as_string =~ s/^0/-0/g;\n    $numbers_as_string\
    \ =~ s/^0/0/g;\n    $numbers_as_string =~ s/^0/-/g;\n    $numbers_as_string =~\
    \ s/^-/-/g;\n    $numbers_as_string =~ s/^-$/-$/g;\n    \n    if ($max_value_so_far\
    \ >= 9) {\n        push(@numbers_ordered, 'nine');\n        $max_value_so_far\
    \ = $max_value_so_far - 10;\n    }\n    \n    for ($i = $#numbers_ordered - 1;$i\
    \ >= 0;$i --) {\n        if ($numbers_ordered[$i] eq 'zero') {\n            $numbers_as_string\
    \ = '0';\n        } else {\n            $numbers_as_string = $numbers_ordered[$i];\n\
    \        }\n        \n        if ($max_value_so_far < $numbers_as_string) {\n\
    \            $max_value_so_far = $numbers_as_string;\n        }\n    }\n    \n",
  "    my @numbers_arr = split(/\\s/, $numbers);\n    my @sorted_numbers;\n    foreach\
    \ my $num (@numbers_arr) {\n        push(@sorted_numbers, $num);\n    }\n    foreach\
    \ my $i (0 .. $#sorted_numbers) {\n        my $pos = $i;\n        my $found =\
    \ 0;\n        foreach my $j ($i+1 .. $#sorted_numbers) {\n            my $this_one\
    \ = substr($sorted_numbers[$i], 0, 1);\n            my $that_one = substr($sorted_numbers[$j],\
    \ 0, 1);\n            if ($this_one eq $that_one) {\n                $pos = $j;\n\
    \                $found = 1;\n            }\n        }\n        if (!$found) {\n\
    \            push(@sorted_numbers, $sorted_numbers[$i]);\n        }\n    }\n \
    \   return join(' ', @sorted_numbers);\n}", "    my($numbers_string) = '';", " \
    \   my($list);\n    my($key);\n    my($current);", "    return unless $numbers\
    \ =~ m/^(zero|one|two|three|four|five|six|seven|eight|nine)/g;\n    my @sorted\
    \ = ();\n    foreach my $num (split /\\s+/, $numbers) {\n        push (@sorted,\
    \ $num);\n    }\n    sort { $a <=> $b } @sorted;\n    return join \" \", @sorted;\n\
    }", "    my(@numbers) = split \" \", $numbers;\n    my(@sorted) = ();\n    $sorted[0]\
    \ = $numbers[0];\n    $sorted[1] = $numbers[1];\n    foreach my $number (@numbers[2..$#numbers])\
    \ {\n        my $temp;\n        foreach my $index (0..2) {\n            if ($index\
    \ < @numbers) {\n                $temp = $numbers[$index];\n                $numbers[$index]\
    \ = $numbers[$index + 1];\n                $numbers[$index + 1] = $temp;\n   \
    \         }\n        }\n    }\n    $numbers = join \" \", @numbers;\n    return\
    \ $numbers;\n}", "    $numbers =~ s/\\s+//g;\n    my($number, $temp);\n    while\
    \ (<STDIN>) {\n        my($line) = $_;\n        chomp($line);\n        my(@nums)\
    \ = split(/\\s+/, $line);\n        foreach $number (@nums) {\n            $temp\
    \ = $number;\n            $number =~ tr/0-9//cd;\n            $number =~ s/^0+//;\n\
    \            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n          \
    \  $number =~ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~\
    \ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n\
    \            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n          \
    \  $number =~ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~\
    \ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n\
    \            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n          \
    \  $number =~ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~\
    \ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n\
    \            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n          \
    \  $number =~ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~\
    \ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n\
    \            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n          \
    \  $number =~ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~\
    \ s/0+$//;\n            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n\
    \            $number =~ s/^0+//;\n            $number =~ s/0+$//;\n          \
    \  $number =~ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~\
    \ s/^0+//;\n            $number =~ s/0+$//;\n            $number =~ s/^0+//;\n\
    \            $number =~ s/0+", "    my(@numbers);\n    while(@numbers < 10) {\n\
    \        push(@numbers, undef);\n    }\n    while(@numbers) {\n        my $num\
    \ = shift @numbers;\n        my $i;\n        for($i = 0; $i < 10; $i++) {\n  \
    \          if($num >= $numbers[$i]) {\n                push(@numbers, $i);\n \
    \               last;\n            }\n        }\n    }\n    return join(\" \"\
    , @numbers);\n}", "    my($num_array) = split ' ', $numbers;\n    my($num_string)\
    \ = join ' ', @$num_array;\n    my($sorted_nums) = map {\n        my $key = $_;\n\
    \        my $digit = substr($key, 0, 1);\n        my $value = $num_array->[$key]\
    \ if $key =~ /^\\d+$/;\n        $key . ($value || ' ') \n    } sort { $a <=> $b\
    \ } split /\\s+/, $num_string;\n    return $sorted_nums;\n}", "    my @numbers_arr\
    \ = split(\" \", $numbers);\n    my $numbers_count = scalar($numbers_arr);", '    my(@sorted,
    @new_numbers);', "    my @nums = split ' ', $numbers;\n    my @nums_sorted = ();\n\
    \    my $i = 0;\n    for my $num (@nums) {\n        $num = $num =~ /^(\\d)$/;\n\
    \        if ($num) {\n            push @nums_sorted, $num;\n        }\n      \
    \  else {\n            push @nums_sorted, 0;\n        }\n    }\n    for my $i\
    \ (0..$#nums_sorted) {\n        my $j = $i + 1;\n        my $swap = shift @nums_sorted;\n\
    \        if ($j > 0) {\n            if ($swap < $nums_sorted[$j]) {\n        \
    \        my @tmp = $nums_sorted;\n                $nums_sorted = @nums_sorted[$j..$i];\n\
    \                $nums_sorted += @tmp;\n                last;\n            }\n\
    \            else {\n                push @nums_sorted, $swap;\n             \
    \   last;\n            }\n        }\n        else {\n            push @nums_sorted,\
    \ $swap;\n        }\n    }\n    return join ' ', @nums_sorted;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThe first code snippet does not appear to be in Perl.\
    \ Did you mean to paste that code into your answer?\n<|/ c |>\n<| c |>\nYes, the\
    \ first code snippet was copied from the question. Thus, it appears to be in Perl.\n\
    <|/ c |>\n<| a |>\nI wonder if you could do something like this, which would allow\
    \ you to use sort on arrays with strings and numerics:\n<code>", "    my @numbers\
    \ = split ' ', $numbers;\n    my $sorted = join ' ', map { (sort {$a <=> $b} split\
    \ ' ')[0] } @numbers;\n    return $sorted;\n}", "    my @numbers = split /\\s+/,\
    \ $numbers;\n    my @sorted = ();", "    my(@numbers) = split' ', $numbers;",
  "    my @numbers = map { /\\w+/; $_ } split /\\s+/, $numbers;\n    sort { $a cmp\
    \ $b } @numbers;\n}", "    my(@numbers_strings);\n    my($number_string, $number);\n\
    \    my($lowest_number, $last_number, $lowest_number_string);\n    my($lowest_number_length,\
    \ $last_number_length);\n    my($number_string);\n    my $i = 1;\n    foreach\
    \ $number_string ( split /\\s+/, $numbers) {\n        $lowest_number_length =\
    \ 0;\n        $last_number_length = 0;\n        $number = $i;\n        foreach\
    \ $number_string (split /\\s+/, $numbers) {\n            if ($number_string =~\
    \ m/$number/) {\n                $last_number_length++;\n            } else {\n\
    \                $lowest_number_length++;\n            }\n            if ($lowest_number_length\
    \ > $lowest_number) {\n                $lowest_number_length = $lowest_number;\n\
    \                $lowest_number_string = $number_string;\n            }\n    \
    \        if ($last_number_length > $last_number) {\n                $last_number_length\
    \ = $last_number;\n                $last_number_string = $number_string;\n   \
    \         }\n            $number++;\n        }\n        push (@numbers_strings,\
    \ $lowest_number_string . \" \" . $last_number_string);\n        $i++;\n    }\n\
    \    my $new_numbers_strings = \"\";\n    my $i;\n    for ($i = 0; $i < @numbers_strings;\
    \ $i++) {\n        $new_numbers_strings .= $numbers_strings[$i] . \"\\n\";\n \
    \   }\n    return $new_numbers_strings;\n}", "    my($sorted_numbers);\n    my\
    \ @numbers = split \" \", $numbers;\n    for my $index (0..$#numbers) {\n    \
    \    $numbers[$index] = sprintf '%d', $numbers[$index];\n    }\n    sort { $a\
    \ <=> $b } @numbers;\n    $sorted_numbers = join \" \", @numbers;\n    return\
    \ $sorted_numbers;\n}", '    my(@numbers_as_strings);', "    return $numbers if\
    \ $numbers !~ /zero/;\n    my @sorted_numbers = split /\\s+/, $numbers;\n    foreach\
    \ my $num (@sorted_numbers) {\n        if ($num =~ /^(0|[1-9]\\d*)$/) {\n    \
    \        push @sorted_numbers, $num;\n        }\n    }\n    return join(' ', @sorted_numbers);\n\
    }", "    my($sort) = sort { $a <=> $b };\n    return $numbers;\n}\n</code>\n<|/\
    \ a tags=perl,sorting,arrays dscore=0 |>\n<| a dscore=0 |>\nI got it working this\
    \ way :\n<code>", "    $numbers =~ s/^\\s*(\\d+)\\s*$/\\1 /;\n    my @numbers\
    \ = split ' ', $numbers;\n    my @sorted_numbers = sort {\n        my $a = \"\
    $a$_\" for ($a=0, @numbers, $a-1);\n        my $b = \"$b$_\" for ($b=0, @numbers,\
    \ $b-1);\n        $a <=> $b\n    };\n    return join ' ', @sorted_numbers;\n}",
  "    my($numbers_string) = split (/\\s+/, $numbers);\n    my(@sorted_numbers) =\
    \ ();\n    my($current_number);", "    my(@sorted_numbers);\n    my($key, $val);\n\
    \    for ($numbers) {\n        chomp($numbers);\n        my($num) = split(' ',\
    \ $numbers);\n        $sorted_numbers[$num] = 3;\n    }\n    @sorted_numbers =\
    \ sort { $b <=> $a };\n    $numbers = join(' ', @sorted_numbers);\n    return\
    \ $numbers;\n}", "    return $numbers unless $numbers !~ /[\\d]+/; # Only get\
    \ numbers without punctuation\n    my @numbers = split /[\\d]+/, $numbers;\n \
    \   my @sortednumbers = ();\n    foreach my $num (@numbers) {\n        push @sortednumbers,\
    \ $num if $num =~ /^0?[1-9][0-9]*$/;\n        push @sortednumbers, $num if $num\
    \ =~ /^0?[0-9][0-9]*$/;\n    }\n    return join ' ', @sortednumbers;\n}", "  \
    \  my($number_string) = @_;\n    my($numbers);\n    my($number_string);\n    \n\
    \    if ($number_string =~ m/^\\s*0*([0-9]+)\\s*$/g) {\n        $number_string\
    \ = \"$1 $number_string\";\n    }\n    \n    $numbers = split(\" \", $number_string);\n\
    \    \n    foreach my $number (@$numbers) {\n        if ($number =~ m/^([0-9]+)/)\
    \ {\n            $number = $1;\n        }\n        \n        $number =~ s/\\s+/\
    \ /g;\n        if ($number !~ m/^[0-9]{1,}$/) {\n            $number = \"zero\"\
    ;\n        }\n        \n        $numbers = $numbers .\" \".$number;\n    }\n \
    \   $numbers =~ s/^\\s+|\\s+$//g;\n    $numbers =~ s/\\s+/ /g;\n    $numbers =~\
    \ s/\\s+/ /g;\n    return $numbers;\n}", "    my @nums = split ' ', $numbers;\n\
    \    my @sorted;\n    my $num = 0;\n    foreach my $num (@nums) {\n        if\
    \ ($num =~ /^([ns]*)(\\d*)$/) {\n            $num = $1;\n        }\n        push(@sorted,\
    \ $num);\n    }\n    return join ' ', @sorted;\n}", "    my @numbers = split(\"\
    \ \", $numbers);\n    # Build a hash with keys as each of the numbers, and values\
    \ as an array\n    # of values which contain a list of the numbers to sort (sorted\
    \ by value)\n    # For example: keys 'one', 'five', 'four' has values 'one' =>\
    \ [ 'one', 'five', 'four' ], 'five' => [ 'five' ]\n    my %sorted = map { $_ =>\
    \ { } } @numbers;\n    # Sort the hash by value\n    foreach my $key ( sort {\
    \ $sorted{$a}{$b}->[0] cmp $sorted{$b}{$a}->[0] } keys %sorted ) {\n        $numbers\
    \ = join(\" \", @{ $sorted{$key} });\n    }\n    return $numbers;\n}", "    my(@nums)\
    \ = (split ' ', $numbers);\n    my($lowest_num) = 0;\n    my($highest_num) = 9;\n\
    \    my($smallest_num) = 0;\n    my($largest) = 9;\n    for (my $num = 0; $num\
    \ < $#nums; $num++) {\n        if ($nums[$num] eq 'zero') {\n            $lowest_num\
    \ = $num;\n        }\n        elsif ($nums[$num] eq 'one') {\n            $highest_num\
    \ = $num;\n        }\n        elsif ($nums[$num] eq 'two') {\n            $lowest_num\
    \ = $num;\n            $highest_num = $num;\n        }\n        elsif ($nums[$num]\
    \ eq 'three') {\n            $lowest_num = $num;\n            $highest_num = $num;\n\
    \            $smallest_num = $num;\n            $largest = $num;\n        }\n\
    \        elsif ($nums[$num] eq 'four') {\n            $lowest_num = $num;\n  \
    \          $highest_num = $num;\n            $smallest_num = $num;\n         \
    \   $largest = $num;\n        }\n        elsif ($nums[$num] eq 'five') {\n   \
    \         $lowest_num = $num;\n            $highest_num = $num;\n            $smallest_num\
    \ = $num;\n            $largest = $num;\n        }\n        elsif ($nums[$num]\
    \ eq 'six') {\n            $lowest_num = $num;\n            $highest_num = $num;\n\
    \            $smallest_num = $num;\n            $largest = $num;\n        }\n\
    \        elsif ($nums[$num] eq 'seven') {\n            $lowest_num = $num;\n \
    \           $highest_num = $num;\n            $smallest_num = $num;\n        \
    \    $largest = $num;\n        }\n        elsif ($nums[$num] eq 'eight') {\n \
    \           $lowest_num = $num;\n            $highest_num = $num;\n          \
    \  $smallest_num = $num;\n            $largest = $num;\n        }\n        elsif\
    \ ($nums[$num] eq 'nine') {\n            $lowest_num = $num;\n            $highest_num\
    \ = $num;\n            $smallest_num = $num;\n            $largest = $num;\n \
    \       }\n    }\n    for (my $num = $lowest_num; $num < $highest_num; $num++)\
    \ {\n        if ($nums[$num] eq 'zero') {", "    my($string);\n    $numbers =~\
    \ s/ /0/xsg;\n    $numbers =~ s/^0/0/xsg;\n    $numbers =~ s/ .*//xsg;\n    my($n1,\
    \ $n2, $n3);\n    my($i1, $i2, $i3);\n    my($n1, $n2, $n3);\n    my @n1, @n2,\
    \ @n3;\n    for ($i1 = 0, $i2 = 0, $i3 = 0; $i1 < $#{$numbers}; $i1++) {\n   \
    \     $n1[$i1] += $numbers[$i1];\n    }\n    for ($i2 = 0, $i3 = 0; $i2 < $#{$n1};\
    \ $i2++) {\n        $n3[$i3] += $n1[$i2];\n    }\n    for ($i2 = 0, $i3 = 0; $i2\
    \ < $#{$n1}; $i2++) {\n        $n3[$i3] += $n1[$i2];\n    }\n    for ($i3 = 0;\
    \ $i3 < $#{$n3}; $i3++) {\n        $n3[$i3] /= 2;\n    }\n    for ($i2 = 0, $i3\
    \ = 0; $i2 < $#{$n3}; $i2++) {\n        $n2[$i2]  = $n3[$i2];\n    }\n    for\
    \ ($i3 = 0, $i2 = 0; $i3 < $#{$n2}; $i3++) {\n        $n1[$i2]  = $n2[$i3];\n\
    \    }\n    for ($i1 = 0; $i1 < $#{$n1}; $i1++) {\n        $string = $string.\
    \ $n1[$i1] . \"\\n\";\n    }\n    $string =~ s/0/$numbers/xsg;\n    return $string;\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`sort_numbers` doesn't work for the input `\"three\
    \ three one one five one five\"`. It also returns `\"one one five one three five\"\
    ` instead of `\"one three five\"`.\n<|/ c |>\n<| c |>\n, thanks for pointing that\
    \ out. I fixed my code to account for that.\n<|/ c |>\n<| a dscore=4 tags=sorting,algorithm,perl\
    \ |>\nFor what it's worth, here's a solution using Algorithm::Dice as suggested\
    \ by\n<code>\nuse strict;\nuse warnings;\nuse Algorithm::Dice;\nmy = qw[three\
    \ one five nine];", "    my @nums = split(\" \", $numbers);\n    my $i = 0;\n\
    \    my @sorted = @nums;\n    foreach my $num (@nums) {\n        if ($num =~ m/[zero|one|two|three|four|five|six|seven|eight|nine]/)\
    \ {\n            $sorted[$i] = $num;\n            $i++;\n        }\n    }\n  \
    \  join(\" \", @sorted);\n}", "    my @nums = split /\\s+/, $numbers;\n    my\
    \ $i = 0;\n    my $tmp;\n    my @sorted_nums = ();", "    my(@numbers_sorted,\
    \ $curr);\n    my(@num_strings) = split //, $numbers;", "    $numbers =~ s/(.*)/\\\
    L$1/;\n    $numbers =~ s/\\s+/ /g;\n    my $sorted = sort { $a <=> $b } split\
    \ /\\s+/, $numbers;\n    return join(' ', $sorted);\n}", "    chomp $numbers;\n\
    \    my @numbers = split \" \", $numbers;\n    my $numbers_length = @numbers;",
  "    my($sorted);\n    my(@nums) = split(/ /, $numbers);\n    for (my $i = 0; $i\
    \ < scalar(@nums); $i++) {\n        my $j = ($i+1)%scalar(@nums);\n        $sorted\
    \ .= $nums[$i].\" \".$nums[$j].\" \";\n    }\n    return $sorted;\n}", "    my\
    \ @numbers = split(/ /, $numbers);\n    my @sorted = sort { ($a <=> $b) } @numbers;\n\
    \    return join(\" \", @sorted);\n}", '    my(@sorted_numbers);', "    my @numbers\
    \ = split(/ /, $numbers);\n    foreach my $number (@numbers) {\n        if ($number\
    \ eq 'nine') {\n            $number = 'nine';\n        }\n        my $index =\
    \ index($numbers, 'nine');\n        if ($index < 0) {\n            push (@numbers,\
    \ $number);\n        } elsif ($index == 0) {\n            shift @numbers;\n  \
    \      } else {\n            splice( @numbers, $index, 1);\n        }\n    }\n\
    \    join( \" \", @numbers);\n}", "    my @numbers_array = split(' ', $numbers);\n\
    \    my @sorted_numbers_array;\n    my @sorted_numbers_array_strings;\n    my\
    \ $i;\n    foreach $i (0..$#numbers_array) {\n        my $number = $numbers_array[$i];\n\
    \        my $key = num_to_key(int($number));\n        push(@sorted_numbers_array_strings,\
    \ $key);\n        push(@sorted_numbers_array, $number);\n    }\n    foreach $i\
    \ (0..$#sorted_numbers_array) {\n        my $number = $sorted_numbers_array[$i];\n\
    \        my $key = num_to_key(int($number));\n        $key =~ s/\\A\\(\\d+\\)\\\
    z/$sorted_numbers_array_strings[$i]/;\n        push(@sorted_numbers_array_strings,\
    \ $key);\n        push(@sorted_numbers_array, $number);\n    }\n    my $numbers\
    \ = join(\" \", @sorted_numbers_array_strings);\n    return $numbers;\n}", " \
    \   my($numbers_string) = join(\" \", @{$numbers}) if (@{$numbers});\n    my @numbers\
    \ = split(\" \", $numbers_string);\n    my $new_numbers = @numbers;\n    sort\
    \ {$numbers[$a] cmp $numbers[$b]} (@numbers);\n    my $new_numbers_string = join(\"\
    \ \", @numbers);\n    my $number_string = \"zero\" if ($numbers[0] eq 'zero');\n\
    \    $number_string .= \" \" if ($numbers[0] ne $number_string);\n    $number_string\
    \ .= $numbers_string if (@numbers == 1);\n    return $number_string;\n}", '    my($string,
    $i);', '    $numbers .= " " if !defined($numbers);', "    chomp($numbers);\n \
    \   $numbers =~ s/(^| )//g;\n    $numbers =~ s/( |$)//g;\n    $numbers =~ s/\\\
    s+/ /g;\n    $numbers =~ s/(^|$)//g;\n    my @numbers = split ' ', $numbers;\n\
    \    map { $_ =~ s/([a-z])/A$1+0x2E/ge } @numbers;\n    $numbers = join(' ', @numbers);\n\
    \    return $numbers;\n}\n</code>\n<|/ a tags=sorting,perl |>\n<| a |>\n<code>",
  "    my @numbers = split /\\s+/, $numbers;\n    my @sorted_numbers;\n    foreach\
    \ (@numbers) {\n        my $number;\n        if ( $number eq 'zero' ) {\n    \
    \        $number = 0;\n        } elsif ( $number eq 'one' ) {\n            $number\
    \ = 1;\n        } elsif ( $number eq 'two' ) {\n            $number = 2;\n   \
    \     } elsif ( $number eq 'three' ) {\n            $number = 3;\n        } elsif\
    \ ( $number eq 'four' ) {\n            $number = 4;\n        } elsif ( $number\
    \ eq 'five' ) {\n            $number = 5;\n        } elsif ( $number eq 'six'\
    \ ) {\n            $number = 6;\n        } elsif ( $number eq 'seven' ) {\n  \
    \          $number = 7;\n        } elsif ( $number eq 'eight' ) {\n          \
    \  $number = 8;\n        } elsif ( $number eq 'nine' ) {\n            $number\
    \ = 9;\n        } else {\n            $number = int($number);\n        }\n   \
    \     push @sorted_numbers, $number;\n    }\n    return join(\" \", @sorted_numbers);\n\
    }", '    my($number);']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
