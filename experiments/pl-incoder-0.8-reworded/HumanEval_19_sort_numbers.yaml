name: HumanEval_19_sort_numbers
language: pl
prompt: "# Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\
  # Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
  \ 'eight' and 'nine'.\n# Return the string with numbers sorted from smallest to\
  \ largest\n# >>> sort_numbers(\"three one five\")\n# \"one three five\"\nsub sort_numbers\
  \ {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_numbers;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three\"),\"three\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  three five nine\"),\"three five nine\")) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(\"five zero four seven\
  \ nine eight\"),\"zero four five seven eight nine\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"six five four three\
  \ two one zero\"),\"zero one two three four five six\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(@numbers);\n    my($last_number, $current_number);", "    $numbers\
    \ =~ s/ /\\n/;\n    my($numbers_arr) = split /\\n/, $numbers;\n    my(@sorted_numbers)\
    \ = ();\n    my $num_count = scalar(@$numbers_arr);\n    my $curr_num = 0;\n \
    \   \n    foreach my $num_str (@$numbers_arr) {\n        my $curr_num = int $num_str;\n\
    \        if ($curr_num >= $num_count) {\n            push(@sorted_numbers, $curr_num);\n\
    \        } else {\n            my $new_curr_num = $curr_num + 1;\n           \
    \ \n            if ($new_curr_num < $num_count) {\n                my $next_num\
    \ = $num_count-1;\n                while ($new_curr_num >= $next_num) {\n    \
    \                $next_num--;\n                    push(@sorted_numbers, $next_num);\n\
    \                }\n                push(@sorted_numbers, $new_curr_num);\n  \
    \          } else {\n                last;\n            }\n        }\n    }\n\
    \    my $return_string = \"\";\n    foreach my $num (@sorted_numbers) {\n    \
    \    $return_string .= $num;\n    }\n    return $return_string;\n}", "    my @numbers\
    \ = split /\\s+/, $numbers;\n    my $i = scalar(@numbers);\n    my $max = 0;\n\
    \    my $min = $i;\n    my $tmp;\n    my $str;", "    my($sorted) = '';\n    my(@numbers)\
    \ = split ' ', $numbers;\n    foreach my $num (@numbers) {\n        my($first)\
    \ = split '\\s', $num;\n        my($last) = split '\\s', $numbers[$#numbers];\n\
    \        if ($first ne $last) {\n            push(@$sorted, $num);\n        }\n\
    \    }\n    return join ' ', @$sorted;\n}\n</code>\n<|/ a tags=sorting,perl,algorithm\
    \ |>\n<| a dscore=2 tags=sorting,perl,algorithm |>\nHere's another approach that\
    \ I haven't thought much about but I think it's more elegant than most of the\
    \ other approaches.  It's probably not as fast as some of the other solutions\
    \ but it's certainly easier to read IMO.\nThe algorithm consists of two steps:\
    \ \n1) Split the string into words.  This will result in an array of words.  \n\
    2) Sort the array by the word length.\nHere's some code to demonstrate the algorithm:\n\
    <code>", "    # Turn into array\n    my(@numbers_as_array) = $numbers\n      =~\
    \ /[\\s\\n]+/\n      =~ /[0-9]+/g\n      =~ tr/a-z/A-Z/;\n    # Sort the array\n\
    \    @numbers_as_array.sort;\n    # Make a string from the array\n    return join\
    \ \" \",;\n}", "    \n    my($sort, $i, $j);\n    \n    $sort = $numbers->[0];\n\
    \    for (my $i = 1; $i < @$numbers; $i++) {\n        \n        $sort = $numbers->[$i]\
    \ cmp $sort;\n        if (! $sort) {\n            $sort = $numbers->[$i];\n  \
    \          $j = $i;\n        }\n    }\n    \n    # Sort the rest of the numbers\n\
    \    for ($i = 1; $i < @$numbers; $i++) {\n        $numbers->[$i] = $numbers->[$j];\n\
    \        $numbers->[$j] = $sort;\n    }\n    \n    return @$numbers;\n}", "  \
    \  my(@nums) = $numbers\n        =~ m{\n                (?:\n                \
    \    (?: \\d+ (?= one|two|three|four|five|six|seven|eight|nine) ) |\n        \
    \            (?: \\d+ (?= zero|one|two|three|four|five|six|seven|eight|nine) )\n\
    \                )\n        }sxg;\n    my($sorted_nums);\n    for my $num (@nums)\
    \ {\n        if ($num =~ m/^\\d+$/) {\n            $sorted_nums .= $num;\n   \
    \     }\n    }\n    $sorted_nums ||= \"\";\n    for my $i (0..$#nums) {\n    \
    \    for my $j ($i..$#nums) {\n            if ($nums[$i] lt $nums[$j]) {\n   \
    \             my $tmp_num = $nums[$j];\n                $nums[$j] = $nums[$i];\n\
    \                $nums[$i] = $tmp_num;\n            }\n        }\n    }\n    return\
    \ join(\" \", @nums);\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a great solution.\
    \  Thanks for the explanation of how it works, and the additional input on how\
    \ to modify it for my needs.\n<|/ c |>\n<| a tags=perl,sorting,arrays dscore=0\
    \ |>\nYou could try using Schwartzian transform.\n<code>\nuse warnings;\nuse strict;",
  "    my @new_numbers;\n    my $temp;\n    foreach my $number (split /\\s+/, $numbers)\
    \ {\n        chomp $number;\n        my $nr = $number{0};\n        if ($nr < 9)\
    \ {\n            $nr = $nr + 11;\n        }\n        $temp = $nr - 9 + 1;\n  \
    \      if ($temp < 2) {\n            $temp += 10;\n        }\n        my $new_number\
    \ = $temp;\n        push @new_numbers, $new_number;\n    }\n    return join '\
    \ ', @new_numbers;\n}", "    my($num_string) = join ' ', $numbers;\n    my($num_pattern)\
    \ = qr{^\n    (?:(?<=\\s)|^) # Look-behind, start at a whitespace character\n\
    \    (?<number>     # Match a single number from the list\n        (?:\n     \
    \       0|[1-9]\\d* # Match an 'zero', 'one', 'two', etc sequence of numbers\n\
    \            |            # or\n            \\d # Match all digits\n        )*\n\
    \    )\n    (?:(?=\\s)|$)   # Look-ahead, stop at whitespace or end of string.\n\
    }x;\n    my @sort_numbers = map {\n        (length($_) == 1) ? ($_ . '0' . '0')\
    \ : $_\n    } sort { length($b) <=> length($a) } split /\\s+/, $num_string;\n\
    \    \n    return join ' ', map { $_ =~ s/$num_pattern/$sort_numbers[$+{number}]/g\
    \ };\n}", '    my(@numbers);', "    my @sorted_numbers;\n    my @num_list = split\
    \ /\\s+/, $numbers;", "    my($numbers_string) = \"\";\n    my($sorted_numbers_string)\
    \ = \"\";\n    my @numbers_list;", "    my @numbers_array = split ' ', $numbers;\n\
    \    my @sorted_numbers = sort { $a <=> $b };\n    return join ' ', @sorted_numbers;\n\
    }", "    my(@sorted_numbers);\n    my($i);\n    my($numbers_array);\n    \n  \
    \  @numbers_array = split(\"  \", $numbers);\n    \n    foreach $i (@numbers_array)\
    \ {\n        push(@sorted_numbers, $i);\n    }\n    \n    @sorted_numbers = sort();\n\
    \    \n    $numbers = join(\" \", @sorted_numbers);\n    return $numbers;\n}",
  '    my(@numbers_as_strings);', "    my($numbers_string) = \"\";\n    $numbers_string\
    \ .= $numbers->[0];\n    for my $n (1..$numbers->[-1]) {\n        $numbers_string\
    \ .= \" $numbers->[$n]\";\n    }\n    return $numbers_string;\n}\n</code>\nOutputs:\n\
    <code>\n$ perl test.pl \nOne two three\n</code>\n<|/ a tags=sorting,perl,arrays\
    \ |>\n<| c |>\nYeah, I realized that after writing my original answer. My point\
    \ was that there's no need for a new array.\n<|/ c |>\n<| a tags=sorting,perl,arrays\
    \ |>\nYou could create a map that translates numbers into strings:\n<code>\nuse\
    \ strict;\nuse warnings;\nuse 5.010;", "    $numbers ||= \"\";\n    chomp $numbers;\n\
    \    my = split \" \", $numbers;\n    my $ret = \"\";\n    my %numbers_hash =\
    \ map { ($_, $_) } 0 .. 9;\n    my = sort {\n        $numbers_hash{ $a } <=> $numbers_hash{\
    \ $b }\n    } @numbers;\n    foreach my $num (@sorted_numbers) {\n        $ret\
    \ .= $num;\n    }\n    return $ret;\n}", '    my(@numbers_sorted, @sorted_numbers);',
  "    $numbers =~ s/\\s+//g;\n    my($sort_pattern) = @_;\n    my @numbers = split(/\
    \ /, $numbers);\n    foreach my $number (@numbers) {\n        $number =~ s/^(\\\
    d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n    foreach my $number (@numbers)\
    \ {\n        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n\
    \    my @numbers = split(/ /, $numbers);\n    foreach my $number (@numbers) {\n\
    \        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n \
    \   foreach my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\L$1/g;\n \
    \   }\n    my($sort_pattern) = @_;\n    foreach my $number (@numbers) {\n    \
    \    $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n    foreach\
    \ my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern)\
    \ = @_;\n    foreach my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\\
    L$1/g;\n    }\n    my($sort_pattern) = @_;\n    foreach my $number (@numbers)\
    \ {\n        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n\
    \    foreach my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\L$1/g;\n\
    \    }\n    my($sort_pattern) = @_;\n    foreach my $number (@numbers) {\n   \
    \     $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n    foreach\
    \ my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern)\
    \ = @_;\n    foreach my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\\
    L$1/g;\n    }\n    my($sort_pattern) = @_;\n    foreach my $number (@numbers)\
    \ {\n        $number =~ s/^(\\d+)/\\L$1/g;\n    }\n    my($sort_pattern) = @_;\n\
    \    foreach my $number (@numbers) {\n        $number =~ s/^(\\d+)/\\L$1/g;\n\
    \    }\n    my($sort_", "    my($outstr);\n    my(@nums);", "    my @sorted_numbers;\n\
    \    \n    my @numbers_array = split(\" \", $numbers);\n    foreach my $num (@numbers_array)\
    \ {\n        my $num_int = $num;\n        $num_int =~ tr/./D/;\n        if ($num_int\
    \ <= 9) {\n            push(@sorted_numbers, $num);\n        }\n    }", "    chomp($numbers);\n\
    \    return join(' ', sort { $a <=> $b } split /\\s+/, $numbers);\n}", "    $numbers\
    \ =~ tr/a-z/A-Z/;\n    my = split(' ', $numbers);\n    my $length = scalar(@numbers);\n\
    \    my $numbers_seen = 0;", "    my @numbers_arr = split(\" \", $numbers);\n\
    \    my @numbers_sorted = sort {\n        my $a = $numbers_arr[$a_idx];\n    \
    \    my $b = $numbers_arr[$b_idx];\n        $a <=> $b\n    } 0 .. $#numbers_arr;\n\
    \    \n    my $num_string = join(\" \", @numbers_sorted);\n    return $num_string;\n\
    }", "    $numbers =~ s/(\\s)/$1/g;\n    my %numbers = (zero => 0, one => 1, two\
    \ => 2, three => 3, four => 4, five => 5, six => 6, seven => 7, eight => 8, nine\
    \ => 9);\n    my = sort { $numbers{$a} <=> $numbers{$b} } keys %numbers;\n   \
    \ return join \" \", @numbers;\n}", "    return unless $numbers;\n    my @sorted\
    \ = map {\n        my $num = $_;\n        return 0 unless defined $num;\n    \
    \    my @nums = split \" \", $num;\n        my @sort = reverse map {\n       \
    \     my $n = $_;\n            $nums[ $n - 1 ];\n        } 0..scalar @nums - 1;\n\
    \        join \" \", @sort;\n    } split / / , $numbers;\n    return join \" \"\
    , @sorted;\n}", "    $numbers =~ s/ /+/g;\n    $numbers =~ s/^\\+//;\n    $numbers\
    \ =~ s/\\+$//;\n    my(@sorted);\n    $numbers =~ /([0-9]+)/;\n    while (@numbers\
    \ > 0) {\n        push(@sorted, pop(@numbers));\n    }\n    return \"@sorted\"\
    ;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is a simple one-line Ruby function\
    \ that uses Enumerable#sort_by:\n<code>\ndef sort_numbers(string)\n  string.split('\
    \ ').sort_by { |n| n.to_i }.join(\" \")\nend\n</code>\n<|/ a dscore=0 tags=sorting,perl,python,awk\
    \ |>\n<| c |>\n`gsub(/\\s+/, ' ').split(/ /).sort_by { |n| n.to_i }.join(\" \"\
    )` looks better.\n<|/ c |>\n<| c |>\n, agreed - I wanted to keep the original\
    \ code as close to what it was as the OP was already using.\n<|/ c |>\n<| a tags=sorting,perl,python,awk\
    \ |>\nI like Martijn's solution, but here is another way that also avoids creating\
    \ an intermediate array:\n<code>\ndef sort_numbers(numbers):\n    numbers = numbers.split('\
    \ ')\n    for number in numbers:\n        numbers.remove(number)\n    numbers.sort()\n\
    \    numbers = ' '.join(numbers)\n    return numbers\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe second line is unnecessary. `numbers = ' '.join(numbers)` will\
    \ create `'one three five'`.\n<|/ c |>\n<| c |>\nYes, I was trying to keep the\
    \ original code as close to what it was as I could.\n<|/ c |>\n<| a |>\nPerl solution\n\
    <code>", "    $numbers =~ s/(^|\\s)(\\s*\\d+)/$2$1/;\n    my($numbers_reversed);\n\
    \    $numbers =~ tr/ /0/;\n    $numbers_reversed =~ tr/ /0/;\n    $numbers =~\
    \ s/(.*)(\\.\\d)/$2$1/;\n    $numbers_reversed =~ s/(.*)(\\.\\d)/$2$1/;\n    $numbers\
    \ =~ s/^0/0/;\n    $numbers_reversed =~ s/^0/0/;\n    $numbers =~ s/1/3/;\n  \
    \  $numbers_reversed =~ s/1/3/;\n    $numbers =~ s/2/5/;\n    $numbers_reversed\
    \ =~ s/2/5/;\n    $numbers =~ s/3/7/;\n    $numbers_reversed =~ s/3/7/;\n    $numbers\
    \ =~ s/4/9/;\n    $numbers_reversed =~ s/4/9/;\n    $numbers =~ s/5/11/;\n   \
    \ $numbers_reversed =~ s/5/11/;\n    $numbers =~ s/6/13/;\n    $numbers_reversed\
    \ =~ s/6/13/;\n    $numbers =~ s/7/15/;\n    $numbers_reversed =~ s/7/15/;\n \
    \   $numbers =~ s/8/17/;\n    $numbers_reversed =~ s/8/17/;\n    $numbers =~ s/9/19/;\n\
    \    $numbers_reversed =~ s/9/19/;\n    $numbers =~ s/10/21/;\n    $numbers_reversed\
    \ =~ s/10/21/;\n    $numbers =~ s/11/23/;\n    $numbers_reversed =~ s/11/23/;\n\
    \    $numbers =~ s/12/25/;\n    $numbers_reversed =~ s/12/25/;\n    $numbers =~\
    \ s/13/27/;\n    $numbers_reversed =~ s/13/27/;\n    $numbers =~ s/14/29/;\n \
    \   $numbers_reversed =~ s/14/29/;\n    $numbers =~ s/15/31/;\n    $numbers_reversed\
    \ =~ s/15/31/;\n    $numbers =~ s/16/33/;\n    $numbers_reversed =~ s/16/33/;\n\
    \    $numbers =~ s/17/35/;\n    $numbers_reversed =~ s/17/35/;\n    $numbers =~\
    \ s/18/37/;\n    $numbers_reversed =~ s/18/37/;\n", "    my(@numbers) = ();\n\
    \    push(@numbers,0);\n    push(@numbers,1);\n    push(@numbers,2);\n    push(@numbers,3);\n\
    \    push(@numbers,4);\n    push(@numbers,5);\n    push(@numbers,6);\n    push(@numbers,7);\n\
    \    push(@numbers,8);\n    push(@numbers,9);\n    my $number_string = \"\";\n\
    \    while(@numbers) {\n        my $number = shift;\n        $number_string .=\
    \ $numbers[$number];\n    }\n    $number_string =~ s/ //g;\n    return $number_string;\n\
    }", '    my($string);', "    my @nums = split ' ', $numbers;\n    my @sorted =\
    \ sort { $a <=> $b } @nums;\n    my $result = join ' ', @sorted;\n    return $result;\n\
    }", "    my @numbers_as_chars = split \" \", $numbers;\n    @numbers_as_chars\
    \ = map { length($_) == 1 ? $_ : \"$_\" } @numbers_as_chars;\n    my $new_number\
    \ = \"\";\n    my $new_numbers = \"\";\n    my $numbers_as_string = \"\";\n  \
    \  my @numbers_as_ints = ();\n    foreach my $number (@numbers_as_chars) {\n \
    \       if ( $number =~ /^zero$|^one$|^two$|^three$|^four$|^five$|^six$|^seven$|^eight$|^nine$/\
    \ ) {\n            $new_number .= $number;\n        }\n        else {\n      \
    \      push @numbers_as_ints, $number;\n        }\n    }\n    foreach my $number\
    \ (@numbers_as_ints) {\n        $new_numbers .= \" $number\";\n    }\n    $new_numbers\
    \ = lc($new_numbers);\n    foreach my $number (@numbers_as_chars) {\n        $numbers_as_string\
    \ .= $numbers_as_string.length == 1 ? \"zero\" : $numbers_as_string[$numbers_as_string.length-1];\n\
    \    }\n    foreach my $number (@numbers_as_ints) {\n        $numbers_as_string\
    \ .= \" $number\";\n    }\n    return $new_numbers . $numbers_as_string;\n}",
  "    my($output);\n    $output = \"\";\n    foreach my $number (split /\\s+/, $numbers)\
    \ {\n        $output .= \" $number \";\n    }\n    $output = \" sort { $a <=>\
    \ $b } \";\n    $output .= \" map { $_ } \";\n    $output .= \" grep  { $_ <>\
    \ \\\"\\\" } \";\n    $output .= \" reverse \";\n    $output .= \" join \\\" \\\
    \";\";\n    return $output;\n}", "    my($string);\n    my $num_string = \"nine\"\
    ;", "    my @numbers = ();\n    my($count, $index);", "    $numbers =~ s/(^|[^0-9])(9)([^0-9]|$)/$1$3$2$4/;\n\
    \    $numbers =~ s/(^|[^0-9])(0)([^0-9]|$)/$1$3$2$4/;\n    $numbers =~ s/(^|[^0-9])(1)([^0-9]|$)/$1$3$2$4/;\n\
    \    $numbers =~ s/(^|[^0-9])(2)([^0-9]|$)/$1$3$2$4/;\n    $numbers =~ s/(^|[^0-9])(3)([^0-9]|$)/$1$3$2$4/;\n\
    \    $numbers =~ s/(^|[^0-9])(4)([^0-9]|$)/$1$3$2$4/;\n    $numbers =~ s/(^|[^0-9])(5)([^0-9]|$)/$1$3$2$4/;\n\
    \    $numbers =~ s/(^|[^0-9])(6)([^0-9]|$)/$1$3$2$4/;\n    $numbers =~ s/(^|[^0-9])(7)([^0-9]|$)/$1$3$2$4/;\n\
    \    $numbers =~ s/(^|[^0-9])(8)([^0-9]|$)/$1$3$2$4/;\n    $numbers =~ s/(^|[^0-9])(9)($|[^0-9])/$1$3$2$4/;\n\
    \    return $numbers;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=1 tags=perl\
    \ |>\n<code>\n$ perl -pi -e 's/(^|[^0-9])(8)([^0-9]|$)/$1$3$2$4/' file\n</code>\n\
    <|/ a |>\n<| a tags=perl |>\nIf your file always has 8 digits, you can do this:\n\
    <code>\ns/(^|[^0-9])(8)([^0-9]|$)/$1$3$2$4/\n</code>\nIf it can have 1 or 2 digits,\
    \ then you can do this:\n<code>\ns/(^|[^0-9])(\\d{1,2})([^0-9]|$)/$1$3$2$4/\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=perl |>\n<code>\nperl -pi -e 's/(^|[^0-9])(8)([^0-9]|$)/$1$3$2$4/'\
    \ file\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIf your file has only one set of\
    \ digits and is always in 8 digits, you can try the following:", '    my @numbers_arr
    = split(" ", $numbers);', "    my($first) = $numbers->[0];\n    my($last) = $numbers->[-1];\n\
    \    return $numbers->[0] unless $first =~ /^[0-9]$/;\n    return $numbers->[-1]\
    \ unless $last =~ /^[0-9]$/;\n    return $numbers->[0] unless $last =~ /^[0-9]$/;\n\
    \    return $numbers->[-1] unless $first =~ /^[0-9]$/;\n    my(@sorted) = ($first,\
    \ $numbers->[0], $last);\n    sort {\n        $a cmp $b || defined $b if $a !~\
    \ /^[0-9]$/ && $b !~ /^[0-9]$/\n    } @sorted;\n    return @sorted;\n}", "   \
    \ chomp($numbers);\n    $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\s+$//;\n \
    \   my($sortedNumbers);\n    my @nums = split(\" \", $numbers);\n    my $i = 0;\n\
    \    foreach my $num (@nums) {\n        if ($num =~ /^[0-9]$/) {\n           \
    \ $sortedNumbers .= $num;\n        } else {\n            $sortedNumbers .= \"\
    \ \" . $num;\n        }\n        $i++;\n        if ($i == $#nums) {\n        \
    \    $sortedNumbers .= \"\\n\";\n            $i = 0;\n        }\n    }\n    return\
    \ $sortedNumbers;\n}", "    my @numbers = split(\" \", $numbers);\n    my $num_sorted\
    \ = join(\", \", @numbers);\n    return $num_sorted;\n}", '    my @nums = split(/
    /, $numbers);', "    my(@numbers_as_string);\n    foreach my $number (split /\\\
    s+/, $numbers) {\n        chomp($number);\n        push(@numbers_as_string, $number);\n\
    \    }", "    # Remove spaces from front\n    $numbers =~ s/^\\s*//;\n    # Remove\
    \ trailing spaces\n    $numbers =~ s/\\s*$//;\n    # Remove extra space\n    $numbers\
    \ =~ s/ +/ /;", "    \n    my($sorted_numbers);\n    \n    my($num_length) = length($numbers);\n\
    \    my($num_length2) =length($numbers);\n    my($i); # index\n    my($i2); #\
    \ index 2\n    my($i3); # index 3\n    \n    my($number);\n    my($number2);\n\
    \    my($number3);\n    my($character);\n    \n    \n    $numbers =~ s/ /-/g;\n\
    \    \n    \n    $sorted_numbers = \"-\" x ($num_length2 - $num_length);\n   \
    \ \n    # split the numbers into 3 sets, first set, second set and third set\n\
    \    for ($i = 0; $i < $num_length2; $i++) {\n        $sorted_numbers .= \" \"\
    \ x $num_length2 - $num_length;\n        $sorted_numbers .= $numbers[$i];\n  \
    \  }\n    \n    $sorted_numbers .= \" -\" x $num_length2 - $num_length;\n    \n\
    \    # split the numbers into 3 sets, first set, second set and third set\n  \
    \  for ($i = 0; $i < $num_length; $i++) {\n        $sorted_numbers .= \" \" x\
    \ $num_length - $num_length2;\n        $sorted_numbers .= $numbers[$i];\n    }\n\
    \    \n    $sorted_numbers .= \" -\" x $num_length - $num_length2;\n    \n   \
    \ \n    # split the numbers into 3 sets, first set, second set and third set\n\
    \    for ($i = 0; $i < $num_length2; $i++) {\n        $sorted_numbers .= \" \"\
    \ x $num_length - $num_length2;\n        $sorted_numbers .= $numbers[$i];\n  \
    \  }\n    \n    $sorted_numbers .= \" -\" x $num_length - $num_length2;\n    \n\
    \    \n    # split the numbers into 3 sets, first set, second set and third set\n\
    \    for ($i = 0; $i < $num_length; $i++) {\n        $sorted_numbers .= \" \"\
    \ x $num_length - $num_length2;\n        $sorted_numbers .= $numbers[$i];\n  \
    \  }\n    \n    $sorted_numbers .= \" -\" x $num_length - $num_length2;\n    \n\
    \    # split the numbers into 3 sets, first set, second set and third set\n  \
    \  for ($i = 0; $i < $num_length; $i++) {\n        $sorted_numbers .= \" \" x\
    \ $num_length - $num_length2;\n        $sorted_numbers .= $numbers[$i];\n    }\n\
    \    \n    $sorted_numbers .= \" ", "    my @numbers = split \" \", $numbers;\n\
    \    my @sorted_numbers = ();\n    for my $number (@numbers) {\n        $number\
    \ = lc $number;\n        my $index = grep { $_ =~ /^$number/ } 0..9;\n       \
    \ push(@sorted_numbers, $index);\n    }\n    return join \" \", @sorted_numbers;\n\
    }\n</code>\nAnd here is the output:\n<code>\n$ perl test\nthree\none\nfive\n</code>\n\
    <|/ a |>\n<| c |>\nI edited the question to make it easier to understand. The\
    \ input could have any number of strings (which could be just one word) followed\
    \ by 'nine'. This would be the most complicated part.\n<|/ c |>\n<| c |>\nI edited\
    \ the answer to include a more generic solution.\n<|/ c |>\n<| c |>\nI appreciate\
    \ the edit but I need this to be a script. Not a function.\n<|/ c |>\n<| c |>\n\
    I see that now. Well you could convert the code above to a script but it will\
    \ take a lot of time and you will likely mess it up before it can run properly.\
    \ Maybe start a new question and ask about the best way to create a script\n<|/\
    \ c |>\n<| c |>\nI appreciate the help. I edited the question to make it easier\
    \ to understand what I meant.\n<|/ c |>\n<| a dscore=0 tags=perl,bash |>\nYou\
    \ can use sed for this:\n<code>\nsed -n 's/^[[:digit:]]\\+ //p' <file | sort -k\
    \ 2\n</code>\nOutput:\n<code>\nthree\none\nfive\n</code>\n<|/ a |>\n<| c |>\n\
    I edited the question to make it easier to understand. The input could have any\
    \ number of strings (which could be just one word) followed by 'nine'. This would\
    \ be the most complicated part.\n<|/ c |>\n<| a tags=perl,bash dscore=0 |>\nIn\
    \ Perl :\n<code>", '    my($string, @nums, @chars) = split /\s+/, $numbers;',
  "    my @numbers_sorted = @$numbers =~ /\\d+/g;\n    my $numbers_sorted = join '\
    \ ', sort { $a <=> $b } @numbers_sorted;\n    return $numbers_sorted;\n}", " \
    \   my($sort)  = 'zero';\n    my(@sort);\n    my(@sorted);", "    my($sortedd);\n\
    \    my($first);\n    my $temp;\n    my($smallest, $largest);\n    $numbers =~\
    \ m{^([-]?[0-9]{1,9})\\s*([-]?[0-9]{1,9})$};\n    if ($1) {\n        $sortedd\
    \ = \"$1 $2\";\n    } else {\n        $sortedd = \"$2 $1\";\n    }\n    my @sorted\
    \ = split(\" \", $sortedd);\n    $smallest = shift(@sorted);\n    $largest = pop(@sorted);\n\
    \    $sortedd = join(\" \", @sorted);\n    $numbers =~ s/^([-]?[0-9]{1,9})\\s*([-]?[0-9]{1,9})$/$sortedd/;\n\
    \    if ($smallest eq $largest) {\n        return $numbers;\n    }\n    if ($smallest\
    \ < $largest) {\n        $temp = pop(@sorted);\n        push(@sorted, $smallest);\n\
    \        push(@sorted, $temp);\n    }\n    while (@sorted != 2) {\n        pop(@sorted);\n\
    \    }\n    $numbers =~ s/^(-?[0-9]{1,9})\\s*(-?[0-9]{1,9})$/$sortedd/;\n    return\
    \ $numbers;\n}", '    my(@numbers_sorted_backwards);', "    my($first_number)\
    \ = shift($numbers);\n    my($sorted_numbers);\n    $sorted_numbers = '';\n  \
    \  foreach (split(/ /, $numbers)) {\n        my($number) = shift(@_);\n      \
    \  if ($number eq $first_number) {\n            $sorted_numbers .= $number . \"\
    \ \";\n        } else {\n            $sorted_numbers .= $first_number . \" \"\
    \ . $number . \" \";\n        }\n    }\n    $sorted_numbers = trim($sorted_numbers);\n\
    \    return $sorted_numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis looks\
    \ very similar to [this](http://stackoverflow.com/a/29343359/156645). Why not\
    \ just post your answer there?\n<|/ c |>\n<| c |>\n- Because it wouldn't be fair\
    \ to post it as an answer here. I think it's better suited as a comment though.\n\
    <|/ c |>\n<| c |>\nIt was posted as an answer because I figured it's better to\
    \ leave the answer to OP and then just point him to the existing answers rather\
    \ than to post a new one. I was trying to give a broader idea to the problem than\
    \ just posting the code to OP. But now that I've posted my answer I see that you're\
    \ pointing it out to me too.\n<|/ c |>\n<| c |>\nI see. I misunderstood your comment.\
    \ Thanks for clearing that up.\n<|/ c |>\n<| a |>\n<code>\nperl -MList::Util=min\
    \ -MList::MoreUtils=uniq -E '\n    say join(\" \", sort { $a <=> $b } uniq grep($_,\
    \ $_) for reverse sort { $a <=> $b } map split /\\s*(?=(?:[^ ]+ ){4})/, $ARGV));\n\
    ' < numbers\n</code>\n<code>\n2 4 5 6 7 8 9 0 1 3 4 5 6 7 8 9 0 1\n</code>\n<|/\
    \ a dscore=0 tags=perl |>\n<| a dscore=0 |>\nI thought I should share my solution\
    \ using the following regex:\n<code>\n/(\\b[a-z]{2}\\s)*(\\d(?:\\s+[a-z]){2,})*\\\
    b/i\n</code>\nDemo here.\nThe basic idea is to use look-ahead assertions to check\
    \ whether the first two letters are in fact two consecutive words, and then check\
    \ each of the remaining numbers against the regex. Here is an explanation of the\
    \ regex:", "    my(@list) = split(/ /, $numbers);\n    my($min, $max);\n    foreach\
    \ my $number (@list) {\n        if ($number ne 'zero') {\n            $min = $number\
    \ if ($min == 0 || $number < $min);\n            $max = $number if ($max == 9\
    \ || $number > $max);\n        } else {\n            $max = $number if ($number\
    \ < $max);\n        }\n    }\n    foreach my $num (sort { $a <=> $b } keys %numbers)\
    \ {\n        if ($num eq $min) {\n            my $s = $list[0];\n            splice,\
    \ 0, 0, $s;\n        }\n        if ($num eq $max) {\n            my $s = $list[scalar(@list)-1];\n\
    \            splice, 0, 0, $s;\n        }\n    }\n    return join(' ', @list);\n\
    }", '    my($return);', "    my $number = $numbers;\n    $number =~ s/\\s+$//;\n\
    \    my @numbers = split /\\s+/, $number;\n    push @numbers, 0;\n    @numbers\
    \ = sort { $a <=> $b } @numbers;\n    my $str = \"\";\n    for my $i (0 .. $#numbers)\
    \ {\n        $str .= $numbers[$i];\n        if ($i < $#numbers) {\n          \
    \  $str .= ' ';\n        }\n    }\n    return $str;\n}", "    my @numbers = split\
    \ ' ', $numbers;\n    my $new_numbers = \"\";\n    my $i = 0;\n    for (@numbers)\
    \ {\n        last if $i == 9;\n        $new_numbers .= $_ . \" \";\n        $i++;\n\
    \    }\n    return $new_numbers;\n}", '    my(@sorter);', "    $numbers =~ s/^\\\
    s+//;\n    $numbers =~ s/\\s+$//;", "    my @nums;\n    for ($numbers) {\n   \
    \     push(@nums, $_);\n    }\n    my @sorted_nums = sort {($a <=> $b) || ($a\
    \ cmp $b)} @nums;\n    my $sorted_string = \"\";\n    my $i = 0;\n    while (@sorted_nums)\
    \ {\n        $sorted_string .= $sorted_nums[$i];\n        $i++;\n    }\n    return\
    \ $sorted_string;\n}", "    my($output) = \" \";\n    my($count, $i, $num, $first,\
    \ $last);\n    foreach $num (split(/ /, $numbers)) {\n        $count = -1;\n \
    \       $first = -1;\n        $last  = -1;\n        foreach $i (0 .. 9) {\n  \
    \          if ($num =~ m/^$i/) {\n                $count++;\n                if\
    \ ($count > $last) {\n                    $last = $count;\n                  \
    \  $first = $i;\n                }\n            }\n        }\n        $output\
    \ .= \"$count $first $last $num\\n\";\n    }\n    return $output;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for the effort, but it's just a small part of the problem.\
    \ I've added some more information to my question. Sorry if that wasn't clear\
    \ enough.\n<|/ c |>\n<| c |>\nI didn't say it's easy, or even necessarily worth\
    \ the effort, nor is it necessarily better than the others. It's just an alternative\
    \ approach. The code in the answer was a proof of concept so I didn't bother to\
    \ make it more elegant or efficient.\n<|/ c |>\n<| a |>\nTry this\n<code>\nuse\
    \ strict;\nuse warnings;", "    $numbers =~ s/\\s+//g;\n    my @numbers = split\
    \ /\\s+/, $numbers;\n    my @sorted = sort { $a <=> $b } @numbers;\n    return\
    \ join \" \", @sorted;\n}", "    chomp($numbers);\n    $numbers =~ s/^\\s+//;\n\
    \    $numbers =~ s/\\s+$//;", "    my @nums = split(' ', $numbers);\n    my $i\
    \ = 0;\n    my $max = 0;\n    my $maxnum = 0;\n    my @sorted = ();\n    foreach\
    \ my $num (@nums) {\n        if ($num =~ /zero/) {\n            $max = 0;\n  \
    \      }\n        if ($num =~ /one/) {\n            $max = 1;\n        }\n   \
    \     if ($num =~ /two/) {\n            $max = 2;\n        }\n        if ($num\
    \ =~ /three/) {\n            $max = 3;\n        }\n        if ($num =~ /four/)\
    \ {\n            $max = 4;\n        }\n        if ($num =~ /five/) {\n       \
    \     $max = 5;\n        }\n        if ($num =~ /six/) {\n            $max = 6;\n\
    \        }\n        if ($num =~ /seven/) {\n            $max = 7;\n        }\n\
    \        if ($num =~ /eight/) {\n            $max = 8;\n        }\n        if\
    \ ($num =~ /nine/) {\n            $max = 9;\n        }\n        if ($max > $maxnum)\
    \ {\n            $maxnum = $max;\n        }\n        push(@sorted, $maxnum);\n\
    \        $maxnum++;\n    }\n    foreach my $num (@nums) {\n        $num =~ tr/zero/one/;\n\
    \        $num =~ tr/one/two/;\n        $num =~ tr/two/three/;\n        $num =~\
    \ tr/three/four/;\n        $num =~ tr/four/five/;\n        $num =~ tr/five/six/;\n\
    \        $num =~ tr/six/seven/;\n        $num =~ tr/seven/eight/;\n        $num\
    \ =~ tr/eight/nine/;\n        $num =~ tr/nine/zero/;\n    }\n    foreach my $num\
    \ (@nums) {\n        $num =~ tr/one/two/;\n        $num =~ tr/two/three/;\n  \
    \      $num =~ tr/three/four/;\n        $num =~ tr/four/five/;\n        $num =~\
    \ tr/five/six/;\n        $num =~ tr/six/seven/;\n        $num =~ tr/seven/eight/;\n\
    \        $num =~ tr/eight/nine/;\n        $num =~ tr/nine/zero/;\n    }\n    foreach\
    \ my $num (@nums) {", "    my($sorted_numbers, $sorted_number_count);\n    my\
    \ @sorted_numbers;\n    my @sorted_number_counts;\n    foreach my $number (split\
    \ /\\s+/, $numbers) {\n        push @sorted_numbers, $number;\n        push @sorted_number_counts,\
    \ length($number);\n    }\n    my $i = 0;\n    my $j = 0;\n    my $sorted_number_counts_len\
    \ = scalar(@sorted_number_counts);\n    foreach my $count (@sorted_number_counts)\
    \ {\n        while ($j < $sorted_number_counts_len && $sorted_number_counts[$j]\
    \ > $count) {\n            $sorted_numbers[$i] = $sorted_numbers[$sorted_number_counts[$j]];\n\
    \            $sorted_number_counts[$j] = $sorted_number_counts[$sorted_number_counts_len];\n\
    \            $j++;\n        }\n        $i = $sorted_number_counts[$j];\n     \
    \   $j++;\n    }\n    return join (\" \", @sorted_numbers);\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 tags=string,perl |>\nIf you have to use Perl and\
    \ cannot use natsort, the solution is pretty easy:\n<code>\nuse warnings;\nuse\
    \ strict;", "    my($num);\n    my @nums = ();\n    foreach $num (split /\\s+/,\
    \ $numbers) {\n        if ($num !~ /^(?:\\d+|zero|one|two|three|four|five|six|seven|eight|nine)$/)\
    \ {\n            die \"sort_numbers() error: bad input number: $num\\n\";\n  \
    \      }\n        push (@nums, $num);\n    }\n    foreach $num (sort { $a <=>\
    \ $b } @nums) {\n        push (@nums, $num);\n    }\n    return join(' ', @nums);\n\
    }", "    my @sorted_numbers;\n    my $current_number = \"\";\n    my @sorted_strings\
    \ = ();\n    for my $number (split /\\s+/, $numbers) {\n        if ($number =~\
    \ /\\d/) {\n            $current_number .= $number;\n        } else {\n      \
    \      push(@sorted_strings, $current_number);\n            $current_number =\
    \ $number;\n        }\n    }\n    if ($current_number ne \"\") {\n        push(@sorted_strings,\
    \ $current_number);\n    }\n    for my $number (@sorted_numbers) {\n        $number\
    \ =~ s/^0//;\n    }\n    my $sorted_numbers_string = join(\", \", @sorted_numbers);\n\
    \    if ($sorted_numbers_string =~ /^(zero|one|two|three|four|five|six|seven|eight|nine)$/)\
    \ {\n        return $sorted_numbers_string;\n    } else {\n        return \"$sorted_numbers_string\"\
    ;\n    }\n}", "    my @new_numbers = ();\n    my @numbers_arr = split(/ /, $numbers);\n\
    \    my $index = 0;\n    my $number;\n    my @numbers_sorted;\n    my $i = 0;\n\
    \    foreach $number (@numbers_arr) {\n        # Handle special cases\n      \
    \  if($number eq 'zero') {\n            push(@new_numbers, 'zero');\n        }\
    \ elsif($number eq 'one') {\n            push(@new_numbers, 'one');\n        }\
    \ elsif($number eq 'two') {\n            push(@new_numbers, 'two');\n        }\
    \ elsif($number eq 'three') {\n            push(@new_numbers, 'three');\n    \
    \    } elsif($number eq 'four') {\n            push(@new_numbers, 'four');\n \
    \       } elsif($number eq 'five') {\n            push(@new_numbers, 'five');\n\
    \        } elsif($number eq 'six') {\n            push(@new_numbers, 'six');\n\
    \        } elsif($number eq 'seven') {\n            push(@new_numbers, 'seven');\n\
    \        } elsif($number eq 'eight') {\n            push(@new_numbers, 'eight');\n\
    \        } elsif($number eq 'nine') {\n            push(@new_numbers, 'nine');\n\
    \        } else {\n            # Convert the number from string to an integer\n\
    \            $number = int(\"$number\");", "    $numbers =~ s/\\s+/ /;\n    my($first,\
    \ $second);\n    while($numbers =~ m/([0-9]+)\\s+([0-9]+)/g) {\n        push(@sortlist,\
    \ $1);\n        push(@sortlist, $2);\n    }\n    foreach my $i (@sortlist) {\n\
    \        next if $i == $first;\n        last if $i == $second;\n    }\n    return\
    \ join(\" \", @sortlist);\n}", "    chomp($numbers);\n    $numbers =~ s/\\s+/\
    \ /g;\n    $numbers =~ s/^\\s+//g;\n    $numbers =~ s/\\s+$//g;\n    my @numbers\
    \ = split(/ /, $numbers);\n    sort(@numbers);\n    $numbers = join(' ', @numbers);\n\
    \    $numbers =~ s/^\\s+//g;\n    $numbers =~ s/\\s+$//g;\n    return $numbers;\n\
    }", "    my(@numbers);\n    my($number);\n    my($result);", "    my @numbers\
    \ = split /\\s+/, $numbers;\n    my (@sorted_numbers);", "    my(@sorted_numbers);\n\
    \    my($number) = qw'zero one two three four five six seven eight nine';\n  \
    \  foreach (split /\\s+/, $numbers) {\n        push (@sorted_numbers, \"$number$num{$number}\"\
    ) if $num{$number} <= 9;\n        $number++;\n    }\n    return join ' ', @sorted_numbers;\n\
    }", "    $numbers =~ s/[\\s\\*\\.,]//g;\n    $numbers =~ s/^\\s+|\\s+$//g;\n \
    \   my = split ' ', $numbers;\n    my = reverse sort {$a <=> $b};\n    $numbers\
    \ = join(' ',);\n    return $numbers;\n}", "    my(@numbers) = split(\" \", $numbers);\n\
    \    my $sorted_numbers = ();\n    my($first_number) = $numbers[0];\n    my($last_number)\
    \ = $numbers[-1];\n    for (my $i = 0; $i < @numbers - 1; $i++) {\n        my\
    \ $current_number = $numbers[$i];\n        if ($current_number ne $first_number)\
    \ {\n            $sorted_numbers[] = $first_number;\n            $first_number\
    \ = $current_number;\n        }\n        if ($current_number ne $last_number)\
    \ {\n            $sorted_numbers[] = $last_number;\n            $last_number =\
    \ $current_number;\n        }\n    }\n    $sorted_numbers[] = $last_number;\n\
    \    return join(\" \", @sorted_numbers);\n}", "    chomp($numbers);\n    my($min,\
    \ $max) = split ' ', $numbers;\n    my $minpos = index($min, '0') + 1;\n    my\
    \ $maxpos = index($max, '9') + 1;\n    $min = $min if $min eq '0';\n    $max =\
    \ $max if $max eq '9';\n    for (my $i = $minpos; $i <= $maxpos; $i++) {\n   \
    \     my $a = $min . $i;\n        my $b = $max . $i;\n        if ($a < $b) {\n\
    \            my @tmp = $_;\n            @tmp[$i]   = $a . $tmp[$i];\n        \
    \    @tmp[$i+1] = $b . $tmp[$i+1];\n            $_ = join(\" \", @tmp);\n    \
    \    }\n    }\n    return $numbers;\n}\n</code>\n<|/ a |>\n<| a tags=perl,sorting\
    \ |>\nMy first thought would be to convert the numbers to strings and then sort,\
    \ then reconvert. \n<code>", "    my @numbers = split ' ', $numbers;\n    my @sorted\
    \ = sort { $a <=> $b } @numbers;\n    my $result = join ' ', @sorted;\n    return\
    \ $result;\n}", "    my(@sorted_numbers) = ();\n    my($tmp, $tmp2);\n    my $numbers_split\
    \ = $numbers =~ /( | )/g;\n    # Split the numbers by the space\n    for($i =\
    \ 0; $i < $numbers_split; $i++) {\n        my $tmp_numbers[$i + 1] = split(\"\
    \ \", $numbers, $i);\n        for(my $j = 0; $j < $#tmp_numbers; $j++) {\n   \
    \         $tmp_numbers[$j + 1] = $tmp_numbers[$j] eq \"zero\" ? 0 : $tmp_numbers[$j];\n\
    \        }\n        # Sort each of the numbers\n        for(my $j = 1; $j <= $#tmp_numbers;\
    \ $j++) {\n            for(my $k = 0; $k <= $#tmp_numbers; $k++) {\n         \
    \       if($tmp_numbers[$j] > $tmp_numbers[$k]) {\n                    $tmp =\
    \ $tmp_numbers[$j];\n                    $tmp_numbers[$j] = $tmp_numbers[$k];\n\
    \                    $tmp_numbers[$k] = $tmp;\n                }\n           \
    \ }\n        }\n        # Add the sorted numbers to the array\n        push(@sorted_numbers,\
    \ @$tmp_numbers);\n    }\n    return join(\" \", @sorted_numbers);\n}", "    my(@sorted_numbers);\n\
    \    if (length($numbers) < 1) {\n        return $numbers;\n    }\n    # convert\
    \ string in to array of numbers, from zero to nine\n    chomp($numbers);\n   \
    \ # convert each number string to an integer, and store in an array\n    my =\
    \ map { $numbers =~ m/^(\\d+)$/ ? $1 : $numbers; } split ' ', $numbers;\n    #\
    \ sort array and format output\n    @sorted_numbers = sort { $a <=> $b } @numbers;\n\
    \    if ($sorted_numbers[0] != 0) {\n        push @sorted_numbers, 0;\n    }\n\
    \    return join ' ', map { sprintf(\"%2d\", $_) } @sorted_numbers;\n}", '    my(@numbers)
    = $numbers =~ /((\d+)|(one)|(two)|(three)|(four)|(five)|(six)|(seven)|(eight)|(nine))/g;',
  "    my @numbers = split ' ', $numbers;", "    my @numbers = split ' ', $numbers;\n\
    \    foreach (@numbers) {\n        chomp;\n        if (/0/) {\n            push\
    \ @numbers, 'zero';\n        } elsif (/1/) {\n            push @numbers, 'one';\n\
    \        } elsif (/2/) {\n            push @numbers, 'two';\n        } elsif (/3/)\
    \ {\n            push @numbers, 'three';\n        } elsif (/4/) {\n          \
    \  push @numbers, 'four';\n        } elsif (/5/) {\n            push @numbers,\
    \ 'five';\n        } elsif (/6/) {\n            push @numbers, 'six';\n      \
    \  } elsif (/7/) {\n            push @numbers, 'seven';\n        } elsif (/8/)\
    \ {\n            push @numbers, 'eight';\n        } elsif (/9/) {\n          \
    \  push @numbers, 'nine';\n        }\n    }\n    return join ' ', @numbers;\n}",
  "    my @nums = split ' ', $numbers;\n    my @sorted_nums;\n    my $i=0;\n    \n\
    \    foreach my $num (sort { $a <=> $b } @nums) {\n        $sorted_nums[$i++]\
    \ = $num;\n    }\n    \n    return join ' ', @sorted_nums;\n}", "    my @numbers\
    \ = split /\\s+/, $numbers;\n    my @sorted;\n    my $min = $numbers[0];\n   \
    \ my $max = @numbers - 1;", "    my(@numbers);\n    @numbers = split (/\\s+/,\
    \ $numbers);\n    \n    @numbers = sort { $a <=> $b } @numbers;\n    \n    return\
    \ join (' ', @numbers);\n}", "    my @nums = ();\n    my @digits = ();\n    my\
    \ $num_string = ();\n    my $num_len = length($numbers);\n    my $num = ();\n\
    \    my $i = 0;\n    my $j = 0;\n    my $len = length($numbers);", "    # Remove\
    \ leading spaces from the string\n    chomp($numbers);\n    # Convert to integers\n\
    \    my(@numbers) = split ' ', $numbers;\n    # Find the minimum and maximum values\n\
    \    my($max, $min) = ( 0, 0 );\n    foreach my $number (@numbers) {\n       \
    \ if ($number > $max) {\n            $max = $number;\n        } elsif ($number\
    \ < $min) {\n            $min = $number;\n        }\n    }\n    # Sort them\n\
    \    my = sort {$a <=> $b} map {\n        my $n = $_;\n        return ( $n - $min\
    \ ) <=> $n - $max;\n    } 0 .. $#numbers;\n    return join ' ', map { $numbers[$_]\
    \ };\n}", "    my($space) = ' ';\n    my(@return);", "    $numbers =~ m!\\b(\\\
    d+)\\b!g;\n    @numbers = sort { $a <=> $b };\n    return join(\" \", @numbers);\n\
    }", "    my($sorting) = sort { $a <=> $b } split / /, $numbers;\n    return join\
    \ \" \", @$sorting;\n}", "    my @numbers  = split ' ', $numbers;\n    my $i =\
    \ 0;\n    foreach my $number (@numbers) {\n\tif ($number eq 'nine') {\n\t    splice(@numbers,\
    \ $i, 1);\n\t    $i--;\n\t} else {\n\t    $i++;\n\t}\n    }\n    my $out = join('\
    \ ',@numbers);\n    return $out;\n}", "    $numbers =~ s/^\\s*(\\d+)\\s*$/ $1\
    \ /s;\n    my @numbers = split ' ', $numbers;\n    my $min_number = $numbers[0];\n\
    \    my $max_number = $numbers[0];\n    for (my $i = 1; $i <= 9; $i++) {\n   \
    \     if ($numbers[$i] < $min_number) {\n            $min_number = $numbers[$i];\n\
    \        } elsif ($numbers[$i] > $max_number) {\n            $max_number = $numbers[$i];\n\
    \        }\n    }\n    my @sorted_numbers = sort { $a <=> $b } @numbers;\n   \
    \ return join ' ', map { sprintf '%d', $_ }@sorted_numbers;\n}", "    $numbers\
    \ =~ s/\\s+//g;\n    $numbers =~ s/^\\s+|\\s+$//g;\n    $numbers =~ s/[[:punct:]]//g;\n\
    \    my @numbers = split(/\\s+/, $numbers);\n    @numbers = map {\n        s/^0+([[:digit:]]+)$/$1/;\
    \ $1 }\n        @numbers;\n    @numbers = sort { $a <=> $b } @numbers;\n    $numbers\
    \ = join(\" \", @numbers);\n    return $numbers;\n}", '    my($sorted_numbers);',
  "    \n    # Convert the string to a list\n    my(@list) = split(/ /, $numbers);",
  "    my(@sorted_numbers);\n    my $numbers_string = $numbers;\n    $numbers_string\
    \ =~ s/^\\s+//;\n    $numbers_string =~ s/\\s+$//;\n    my @numbers = split(\"\
    \ \", $numbers_string);\n    foreach (@numbers) {\n\tpush (@sorted_numbers, $_);\n\
    \    }\n    my $sorted_numbers_string = join(\" \", @sorted_numbers);\n    return\
    \ $sorted_numbers_string;\n}", "    return if $numbers !~ /^\\s*(\\d+)\\s*(?:(zero|one|two|three|four|five|six|seven|eight|nine)\\\
    s*)*(\\d+)\\s*$/;\n    return $1 . $2 . ($3 > $2 ? $3 : $2);\n}", "    $numbers\
    \ ~= ' ' if $numbers =~ ' ';\n    my @numbers = split ' ', $numbers;\n    my @sorted\
    \ = sort { ($a <=> $b) } @numbers;\n    my $result = join(' ', @sorted);\n   \
    \ $result =~ s/(^| )(.)/gmsprintf '\\\\1\\\\2' /e;\n    return $result;\n}\n</code>\n\
    <|/ a dscore=0 tags=perl,sorting,regex |>\n<| c |>\nI like the approach of using\
    \ the fact that we can sort a list of numbers in lexicographical order without\
    \ regular expressions, but this doesn't actually answer the question \"how to\
    \ use regular expressions to achieve this sort of ordering\".\n<|/ c |>\n<| c\
    \ |>\nThanks for your suggestion, I think it's much better than mine! I think\
    \ regex is much more verbose than my own answer but I think that's because I missed\
    \ some basic regexp concepts.\n<|/ c |>\n<| c |>\n: Thank you!\n<|/ c |>\n<| a\
    \ |>\nI agree with others that sorting algorithms based on regex is probably not\
    \ the best choice here, but since you've asked, I figured I'd give it a try. Here's\
    \ a function that will do it:\n<code>\nuse strict;\nuse warnings;", '    my($string);',
  "    my($first, $second, $third, $fourth, $fifth, $sixth, $seventh, $eighth, $ninth)\
    \ = split(' ', $numbers);\n    my(@sorted) = ($second, $third, $fourth, $fifth,\
    \ $sixth, $seventh, $eighth, $ninth);\n    my($lowest) = 0;\n    \n    foreach\
    \ $i (0..$#sorted) {\n        if ($sorted[$i] < $lowest) {\n            $lowest\
    \ = $sorted[$i];\n        }\n    }\n    \n    push(@sorted, $lowest);\n    \n\
    \    foreach $i (0..$#sorted) {\n        if ($sorted[$i] == $lowest) {\n     \
    \       $sorted[$i] = $sorted[0];\n        }\n    }\n    \n    return join(' ',\
    \ @sorted);\n}\n</code>\n<|/ a tags=perl |>\n<| a tags=perl |>\nI tried to find\
    \ a way to do this in one pass, but I couldn't.\nIf someone can find a way to\
    \ do it with a single pass, let me know.\n<code>\nuse strict;\nuse warnings;",
  "    $numbers =~ s/(\\d+)\\s*$//;\n    my @numbers = split ' ', $numbers;\n    sort\
    \ { $a <=> $b } @numbers;\n    return join ' ', @numbers;\n}", "    my %results;\n\
    \    $numbers    = split(' ', $numbers);", "    my($sorted, $i);\n    my($tmp);",
  "    return if ($numbers == '');\n    my($nums) = $numbers =~ m/^(.*?) (\\d+)$/;\n\
    \    my($numbers) = $numbers =~ m/^(\\d+) (\\d+)$/;\n    my($sorted, $num) = ();\n\
    \    my($i, $j);\n    $num =~ m/^\\d+$/;\n    for (my $i = $#$nums - 1; $i >=\
    \ 0; $i--) {\n        $num =~ m/^\\d+$/;\n        $sorted[$i] = $nums[$i];\n \
    \   }\n    $num =~ m/^\\d+$/;\n    for (my $i = $#$nums; $i >= 0; $i--) {\n  \
    \      $num =~ m/^\\d+$/;\n        $sorted[$i] = $nums[$i];\n    }\n    $nums\
    \ = join(' ', @sorted);\n}", '    my(@new_numbers);', '    $numbers .= " " unless
    ($numbers !~ /\s+/);', "    my (@numbers_array) = split ' ', $numbers;", '    my(@sorted_numbers);',
  "    $numbers =~ tr/ /0/;\n    $numbers =~ s/^0//;", "    my @nums = split ' ',\
    \ $numbers;\n    my $sorted = join(' ', @nums);\n    my @sorted = split ' ', sort\
    \ { $a <=> $b } @nums;\n    my $result = join(' ', @sorted);\n    return $result;\n\
    }\n</code>\n<|/ a dscore=2 tags=perl |>\n<| a |>\nYou just want to reverse the\
    \ order of the words?\n<code>\nprint reverse \"two three\";\n</code>\n<|/ a dscore=2\
    \ tags=perl |>\n<| c |>\nThis won't work. It will just print `etwo` and reverse\
    \ the entire string.\n<|/ c |>\n<| c |>\nThis works and is easy, but it does so\
    \ by splitting the string into an array and printing the second element, which\
    \ is the reverse of the original string. Very inefficient.\n<|/ c |>\n<| c |>\n\
    , please provide a real world example of where it would be inefficient for you\
    \ to use this method.\n<|/ c |>\n<| c |>\nIf you have a million words to reverse,\
    \ you are better off reading them all into memory and reversing them in memory.\
    \ My point is that you have a very easy to use method for reversing a string in\
    \ memory and you have the memory to read and write it all at once and you have\
    \ some very fast algorithms to do it. Using this method is a great way to waste\
    \ memory and time for no good reason.\n<|/ c |>\n<| c |>\n, if you have a million\
    \ words to reverse, you're not going to have a million reversed words printed\
    \ out, so I'd be surprised if that's a concern.\n<|/ c |>\n<| a tags=perl |>\n\
    This should do the trick:\n<code>", "    my @numbers = split ' ', $numbers;",
  "    my @numbers = split(/ /, $numbers);\n    my @sorted_numbers = ();\n    foreach\
    \ (@numbers) {\n        push(@sorted_numbers, $_);\n    }\n    sort { $a <=> $b\
    \ } @sorted_numbers;\n    return join(\" \", @sorted_numbers);\n}", "    $numbers\
    \ =~ s/ (?! \\A ) //xs;\n    chomp $numbers;\n    return join \" \", sort split\
    \ /\\s+/, $numbers;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=2 |>\nHere's\
    \ one way, using perl core, without using any extra modules. \n<code>", "    my\
    \ @numbers_array = split(\" \", $numbers);\n    my $sorted_numbers = join(\" \"\
    , sort_numbers_array(@numbers_array));\n    return $sorted_numbers;\n}", "   \
    \ my($sorted) = ();\n    my($num, $num_len, $next);\n    while($numbers) {\n \
    \       $num_len = length($numbers);\n        $num_len > 0 ? $next = $numbers\
    \ =~ /([0-9]+)/;\n        push(@$sorted, $numbers) if $next <= 9;\n        $numbers\
    \ =~ s/^([0-9]+)\\s*//;\n    }\n    return join(\"\\n\", @$sorted);\n}", "   \
    \ $numbers ||= \"zero\";\n    $numbers ||= \"one\";\n    $numbers ||= \"two\"\
    ;\n    $numbers ||= \"three\";\n    $numbers ||= \"four\";\n    $numbers ||= \"\
    five\";\n    $numbers ||= \"six\";\n    $numbers ||= \"seven\";\n    $numbers\
    \ ||= \"eight\";\n    $numbers ||= \"nine\";\n    $numbers ||= \"ten\";", "  \
    \  $numbers =~ tr/0-9//d;\n    my @parts = split \" \", $numbers;\n    sort {\
    \ $b->[1] <=> $a->[1] } @parts;\n    return join \" \",;\n}", '    my($num_array);',
  "    my @numbers = split(\" \", $numbers);\n    @numbers = sort { $a <=> $b } @numbers;\n\
    \    return join(\" \", @numbers);\n}", '    my(@numbers_as_string) = split /\s+/,
    $numbers, -1;', "    my($order) = @_;\n    my(@numbers_reversed); # Reverse the\
    \ array\n    my($i = 0); # Loop variable\n    my($temp) = ' ';\n    my($sorted_numbers);\n\
    \    # Convert to an array, splitting on spaces ' ', and sorting from smallest\
    \ to largest.\n    # Iterate through each string in $numbers (the original string)\
    \ and swap it with the number\n    # at index $i of the current loop.  $i is set\
    \ to 0 before the loop and incremented each time the\n    # loop iterates.  At\
    \ the end of the loop, all the strings swapped out are put into the\n    # array\
    \ @numbers_reversed, which needs to be reversed since we want the original order\n\
    \    # of the elements.\n    while( ($numbers = $numbers =~ /\\b(.*?)\\b/ig) =~\
    \ /\\b(.*?)\\b/ig ) {\n        $numbers_reversed[$i] = $1;\n        $order = $i\
    \ if $order eq 'asc';\n        $i ++;\n    }\n    $sorted_numbers = reverse @numbers_reversed;\n\
    \    \n    # Remove the spaces now that we've sorted the numbers. \n    # $numbers\
    \ is a space-delimited string, but is actually a list containing each of the\n\
    \    # individual numbers from the string. \n    # So we need to remove the spaces\
    \ one by one.\n    $numbers =~ s/ //g;\n    \n    # Return the sorted string \n\
    \    return $numbers . ' ' . $order;\n}\n</code>\n<|/ a |>\n<| a tags=sorting,perl,perl-module\
    \ dscore=2 |>\nHere is how to sort a list using the Schwartzian transform if you\
    \ prefer one-liners:\n<code>\nmy = qw(1 9 8 2 6 3 4 7 5);", "    my(@numbers);\n\
    \    my ($i, $j, $tmp);", "    my(@numbers) = split /\\s+/, $numbers;\n    my(@sort)\
    \ = ();\n    my($first, $last, $num);\n    foreach $num (@numbers) {\n       \
    \ # Skip leading whitespace\n        $num =~ s/^\\s+//;\n        $first ||= $num;\n\
    \        $last ||= $num;\n        # Find index of $num in sorted list\n      \
    \  $i = 1;\n        while ($i < @sort and $sort[$i] eq $num) {\n            $i++;\n\
    \        }\n        # Add $num to sort list if it's smaller than $last or larger\
    \ than $first\n        if ($i < (@sort - 1)) {\n            push (@sort, $num);\n\
    \        }\n        if ($i >= (@sort - 1)) {\n            push (@sort, $first);\n\
    \        }\n        if ($i > (@sort - 1)) {\n            push (@sort, $last);\n\
    \        }\n    }\n    return join \" \", @sort;\n}", "    my($output) = '';\n\
    \    my($number);\n    my($digit);", "    chomp($numbers);\n    $numbers =~ s/^\\\
    s*//;", "    my @numbers_array = ();\n    my @sorted_numbers = ();", "    my($string);\n\
    \    my(@nums);", "    my(@numbers_sorted, $number_string);\n    foreach my $number\
    \ (split(\" \", $numbers)) {\n        $number_string .= \" $number\";\n    }\n\
    \    my @sorted_numbers = sort { $a <=> $b } map {\n        my $n = int($_);\n\
    \        $n if $n >= 0 && $n < 10;\n    } split(\" \", $number_string);\n    return\
    \ join(\" \", @sorted_numbers);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nAgreed,\
    \ this seems like a much better solution.\n<|/ c |>\n<| c |>\nGood point for readability\
    \ and maintainability.  I've added an answer using similar approach, but with\
    \ more explanation.\n<|/ c |>\n<| a tags=sorting,perl,arrays |>\nHere's a solution\
    \ based on Dave Cross answer using List::Util:\n<code>\nuse List::Util qw(reduce);",
  "    my @result = ();\n    my @nums = split ' ', $numbers;\n    foreach (@nums)\
    \ {\n        push (@result, $_);\n    }\n    sort { $a <=> $b } @result;\n   \
    \ return join ' ', @result;\n}", "    # Initialize $numbers to an empty string\n\
    \    my $numbers = '';\n    # Extract the numbers from $numbers and push them\
    \ into the stack\n    while ($numbers =~ /(zero|one|two|three|four|five|six|seven|eight|nine)/g)\
    \ {\n        push(@$numbers, $1);\n    }\n    # Sort the stack and return it\n\
    \    return join(\" \", sort @$numbers);\n}", "    my @nums = split ' ', $numbers;",
  "    my @sorted = ();\n    my @numbers = split \" \", $numbers;\n    foreach my\
    \ $number (@numbers) {\n        push @sorted, $number if 0 <= $number && $number\
    \ <= 9;\n    }\n    return join \" \", @sorted;\n}", "    my @numbers = split(/\
    \ /, $numbers);\n    my @sorted = sort { $a <=> $b } @numbers;\n    return join('\
    \ ', @sorted);\n}", "    \n    my @numbers = split(/ /, $numbers);\n    \n   \
    \ my (@numbers_sorted, $curr);\n    \n    for (my $i = 0; $i < $#numbers; $i++)\
    \ {\n        $numbers_sorted[$i] = $numbers[$i];\n    }\n    \n    for (my $i\
    \ = $#numbers; $i >= 0; $i--) {\n        $numbers_sorted[$i] = $numbers_sorted[$i]\
    \ if $numbers_sorted[$i] <= $curr; \n        $curr = $numbers_sorted[$i];\n  \
    \  }\n    \n    return join(\" \", @numbers_sorted);\n}", '    my($string);',
  "    my @nums = split(/ /, $numbers);\n    my $num_count = scalar(@nums);\n    my\
    \ @sorted_nums;\n    my @zero_nums;", "    $numbers =~ s/\\s+//g;\n    my(@sorted_numbers)\
    \ = sort_string($numbers);\n    join(\" \", @sorted_numbers);\n}", '    my @result;',
  "    my(@sorted_numbers);\n    foreach my $number (split /\\s+/, $numbers) {\n \
    \       push(@sorted_numbers, $number =~ /([0-9])/) ? $1 : $number\n    }\n  \
    \  return join \" \", sort { lc($a) cmp lc($b) };\n}", "    my(@sorted_numbers);\n\
    \    my($first_digit);\n    my($rest_of_numbers);", '    my($i, $length, $nums);',
  '    my(@sorted_numbers);', "    $numbers =~ s/^\\s*//;\n    $numbers =~ s/\\s*$//;",
  "    my @list = split / /, $numbers;\n    @list = sort {\n\tmy $a = $a->[0];\n\t\
    my $b = $b->[0];\n\treturn $a <=> $b;\n    } @list;\n    return join \" \", @list;\n\
    }", "    $numbers =~ s/\\s+/ /g;\n    my @numbers = split /\\s+/, $numbers;\n\
    \    my $length = scalar(@numbers);\n    return sort { $a <=> $b } @numbers;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nGood use of <=>, that is the syntax I\
    \ was looking for.  I will probably use your sort function instead of my sort_numbers\
    \ function though.  I was trying to be clever and avoid repeating myself too much\
    \ and instead use the built in sort.  Thank you!\n<|/ c |>\n<| a tags=perl,sorting,arrays\
    \ |>\nOne liner\n<code>\nperl -MData::Dumper -n -e 'print Dumper([sort { $a <=>\
    \ $b } split' < numbers\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", '    $numbers
    =~ s/ /\s+/g;', "    my($numbers_copy) = $numbers;\n    my @sorted_numbers = ();\n\
    \    my($i, $j, $temp, $numbers_copy);\n    \n    # Copy the list of numbers to\
    \ an array for sorting \n    @sorted_numbers = ();\n    while ($numbers_copy =~\
    \ /((zero|one|two|three|four|five|six|seven|eight|nine)\\s+)([^\\s]+)/x) {\n\t\
    push(@sorted_numbers, $2);\n    }\n    \n    # Sort the array from smallest to\
    \ largest\n    for (my $i=0; $i<(scalar(@sorted_numbers)-1); $i++) {\n\t$j = (($i+1)\
    \ < scalar(@sorted_numbers) ? $i+1 : scalar(@sorted_numbers));\n\t$temp = $sorted_numbers[$i];\n\
    \t$sorted_numbers[$i] = $sorted_numbers[$j];\n\t$sorted_numbers[$j] = $temp;\n\
    \    }\n    \n    # Add the remaining numbers back in to the end of the string\n\
    \    $numbers_copy =~ s/((zero|one|two|three|four|five|six|seven|eight|nine)\\\
    s+)([^\\s]+)/$1$sorted_numbers[$i] $2/x;\n    return $numbers_copy;\n}", "   \
    \ $numbers =~ s/^\\s+//;\n    $numbers =~ s/\\s+$//;\n    my @numbers = split\
    \ /\\s+/, $numbers;\n    my @sorted_numbers = ();\n    my $first_digit = shift\
    \ @numbers;\n    my $second_digit = shift @numbers;\n    my $third_digit = shift\
    \ @numbers;\n    my $first_digit_index = 0;\n    my $second_digit_index = 0;\n\
    \    my $third_digit_index = 0;\n    my $i = 0;\n    my $j = 1;\n    my $k = -1;\n\
    \    my $digit;\n    foreach $digit (@numbers) {\n        $k++;\n        my $new_digit\
    \ = 0;\n        foreach $new_digit (@numbers) {\n            if ($new_digit <\
    \ $digit) {\n                $k++;\n                $new_digit = 0;\n        \
    \    }\n        }\n        push(@sorted_numbers, $new_digit);\n    }\n    $i =\
    \ $k;\n    $j = $k;\n    foreach $digit (@sorted_numbers) {\n        if ($digit\
    \ < $first_digit) {\n            $i = $k;\n            $first_digit_index = $i;\n\
    \            $first_digit = $digit;\n        }\n        if ($digit < $second_digit)\
    \ {\n            $j = $k;\n            $second_digit_index = $j;\n           \
    \ $second_digit = $digit;\n        }\n        if ($digit < $third_digit) {\n \
    \           $k = $k;\n            $third_digit_index = $k;\n            $third_digit\
    \ = $digit;\n        }\n    }\n    my $first_digits_string = $numbers[$first_digit_index];\n\
    \    my $second_digits_string = $numbers[$second_digit_index];\n    my $third_digits_string\
    \ = $numbers[$third_digit_index];\n    my $sorted_numbers_string = join \" \"\
    , @sorted_numbers;\n    return $sorted_numbers_string . $first_digits_string .\
    \ $second_digits_string . $third_digits_string;\n}", "    $numbers =~ tr/[a-z]/[A-Z]//cd;\n\
    \    $numbers =~ tr/0-9//cd;\n    my @numbers = split \" \", $numbers;\n    @numbers\
    \ = sort { $a <=> $b } @numbers;\n    return join(\" \", @numbers);\n}", "   \
    \ my($sort) = ();\n    my($sort) = ();\n    my($sort) = ();\n    my($sort) = ();",
  "    my @result = ();\n    for (split ' ', $numbers) {\n        push(@result, scalar\
    \ reverse $_);\n    }\n    return join ' ', @result;\n}\n</code>\nThis could be\
    \ written in one line using a hash but it's not as nice:\n<code>", "    $numbers\
    \ =~ s/\\s+//g;\n    my($one,$two,$three,$four,$five,$six,$seven,$eight,$nine)\
    \ = qw(01 02 03 04 05 06 07 08 09 10);\n    $numbers =~ s/^\\s+//;\n    my($zero,$nine,$ten,$hundred,$thousand,$ten_thousand,$hundred_thousand);\n\
    \    foreach $n (split(\" \",$numbers)) {\n        $n =~ s/^\\s+//;\n        $n\
    \ =~ s/\\s+$//;\n        my($num,$unit) = ($n,\"one\");\n        if    ($n =~\
    \ /^0[0-3]$/) {\n            $num = $_;\n            $unit = \"ten\";\n      \
    \  }\n        elsif ($n =~ /^0[1-9]$/) {\n            $num = $_;\n           \
    \ $unit = \"ten\";\n        }\n        elsif ($n =~ /^1[01]$/) {\n           \
    \ $num = $_;\n            $unit = \"one\";\n        }\n        elsif ($n =~ /^2[02]$/)\
    \ {\n            $num = $_;\n            $unit = \"two\";\n        }\n       \
    \ elsif ($n =~ /^3[0-6]$/) {\n            $num = $_;\n            $unit = \"three\"\
    ;\n        }\n        elsif ($n =~ /^4[0-4]$/) {\n            $num = $_;\n   \
    \         $unit = \"four\";\n        }\n        elsif ($n =~ /^5[0-7]$/) {\n \
    \           $num = $_;\n            $unit = \"five\";\n        }\n        elsif\
    \ ($n =~ /^6[0-8]$/) {\n            $num = $_;\n            $unit = \"six\";\n\
    \        }\n        elsif ($n =~ /^7[0-5]$/) {\n            $num = $_;\n     \
    \       $unit = \"seven\";\n        }\n        elsif ($n =~ /^8[0-5]$/) {\n  \
    \          $num = $_;\n            $unit = \"eight\";\n        }\n        elsif\
    \ ($n =~ /^9[0-8]$/) {\n            $num = $_;\n            $unit = \"nine\";\n\
    \        }\n        elsif ($n =~ /^[0-3]\\s(ten|one|two|three|four|five|six|seven|eight|nine)$/)\
    \ {", "    $numbers =~ s/^\\s*//;\n    my($largest) = 'zero';\n    my($smallest)\
    \ = 'nine';\n    my $number = '';\n    my(@nums) = $numbers =~ /([0-9]+)/;\n \
    \   my(@nums_sorted) = ();\n    for(my $i=0; $i<$#nums; $i++) {\n        my $num\
    \ = $nums[$i];\n        my $num_length = length($num);\n        if($num_length\
    \ <= 1) {\n            $num =~ s/^0//;\n        }\n        for(my $j=0; $j<$num_length;\
    \ $j++) {\n            my $digit = $num[$j];\n            if($digit eq 'nine')\
    \ {\n                $digit += 10;\n            }\n            elsif($digit eq\
    \ 'zero') {\n                $digit += 1;\n            }\n            $num_length\
    \ = length($num);\n            if(($num_length <= 1) || ($digit < $smallest))\
    \ {\n                $smallest = $digit;\n            }\n            elsif(($num_length\
    \ <= 1) || ($digit > $largest)) {\n                $largest = $digit;\n      \
    \      }\n            elsif($digit > $largest) {\n                $largest = $digit;\n\
    \            }\n            elsif($digit < $smallest) {\n                $smallest\
    \ = $digit;\n            }\n        }\n        push(@nums_sorted, $num);\n   \
    \ }\n    $numbers = join(' ',@nums_sorted);\n    $numbers = $numbers.\" \".$smallest.\"\
    \ \".$largest;\n    return $numbers;\n}\n</code>\n<|/ a tags=perl,arrays |>\n\
    <| c |>\nThank you for your suggestions.  I appreciate your effort!  I will try\
    \ them all out and see what works best.\n<|/ c |>\n<| c |>\n: No problem. One\
    \ thing to note about my solution is that it does not sort the digits in order.\
    \ Is that important? If not, then my solution should work just fine.\n<|/ c |>\n\
    <| a |>\nMy solution\n<code>\nuse v5.10.1;\nuse strict;\nuse warnings;", "   \
    \ my @numbers = split ' ', $numbers;", "    my $ret = $numbers;\n    $ret =~ s/\
    \ (\\d)/ $1 . \" \" . \" \" x $1 /ge;\n    return $ret;\n}", "    return $numbers\
    \ if $numbers !~ /^(?:zero|one|two|three|four|five|six|seven|eight|nine)$/i;\n\
    \    my @sorted_numbers = map {\n        my($n) = $_ eq 'zero' ? 0 : $_ eq 'one'\
    \ ? 1 : $_ eq 'two' ? 2 : $_ eq 'three' ? 3 : $_ eq 'four' ? 4 : $_ eq 'five'\
    \ ? 5 : $_ eq 'six' ? 6 : $_ eq 'seven' ? 7 : $_ eq 'eight' ? 8 : 9;\n       \
    \ $n <=> $numbers[$_];\n    } 0..$#numbers;\n    my @numbers = map {\n       \
    \ $numbers[$_],\n    } 0..(scalar(@sorted_numbers) - 1);\n    return join \" \"\
    , map {\n        $sorted_numbers[$_],\n    } 0..(scalar(@numbers) - 1);\n}", '    my($num_list)
    = "";', "    my(@strings);\n    my($string);\n    my($num);\n    my(@nums);\n\
    \    my @strings =\n    (\n        \"zero\",\n        \"one\",\n        \"two\"\
    ,\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n\
    \        \"seven\",\n        \"eight\",\n        \"nine\"\n    );", "    return\
    \ join \" \", sort split(/\\s+/, $numbers);\n}", "    my @list = split /\\s+/,\
    \ $numbers;\n    my ($a, $b, $i, $j);\n    $i = 0;\n    $a = $list[0];\n    $b\
    \ = $list[1];\n    foreach $j (@list[2..$#$list]) {\n        next if $j >= $b;\n\
    \        if ($a > $j) {\n            $a = $j;\n        }\n        if ($b > $j)\
    \ {\n            $b = $j;\n        }\n    }\n    $list[0] = $a;\n    $list[1]\
    \ = $b;\n    return join ' ', @list;\n}", "    my($number) = $numbers =~ /\\s*(\\\
    d+)\\s*/g;\n    $number .= ' zero' unless $number =~ /\\s*zero\\s*$/;\n    $number\
    \ .= ' one' unless $number =~ /\\s*one\\s*$/;\n    $number .= ' two' unless $number\
    \ =~ /\\s*two\\s*$/;\n    $number .= ' three' unless $number =~ /\\s*three\\s*$/;\n\
    \    $number .= ' four' unless $number =~ /\\s*four\\s*$/;\n    $number .= ' five'\
    \ unless $number =~ /\\s*five\\s*$/;\n    $number .= ' six' unless $number =~\
    \ /\\s*six\\s*$/;\n    $number .= ' seven' unless $number =~ /\\s*seven\\s*$/;\n\
    \    $number .= ' eight' unless $number =~ /\\s*eight\\s*$/;\n    $number .= '\
    \ nine' unless $number =~ /\\s*nine\\s*$/;\n    my $sorted;\n    my @numbers =\
    \ split(\" \", $numbers);\n    foreach my $number (@numbers) {\n        my @numbers\
    \ = split(\" \", $number);\n        my $n = 0;\n        foreach my $index (0 ..\
    \ @numbers - 1) {\n            last if $n != $index;\n            last if $numbers[$index]\
    \ eq $number;\n            $numbers[$index + 1] = $numbers[$index];\n        \
    \    $n++;\n        }\n        $sorted = join(\" \", @numbers);\n    }\n    return\
    \ $sorted;\n}", "    my @nums = split \" \", $numbers;\n    my @sorted = sort\
    \ { $a <=> $b } @nums;\n    return join \" \", @sorted;\n}", "    my($string);\n\
    \    my (@numbers_array);\n    my $number_len = length($numbers);\n    my ($num_string,\
    \ $num_char);\n    my ($i, $j, $num_length, $num_remainder);", "    $numbers =~\
    \ tr/ /\\n/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/nine/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/nine/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/nine/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/nine/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/nine/;\n    $numbers =~ s/^/nine/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/nine/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers\
    \ =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers\
    \ =~ s/^/zero/;\n    $numbers =~ s/$/zero/;\n    $numbers =~ s/^/zero/;\n    $numbers ",
  "    chomp($numbers);\n    my @numbers = ();", "    my($string, $number, $index);\n\
    \    while (defined ($number = $numbers =~ m/(?<number>[one|two|three|four|five|six|seven|eight|nine]+)/g))\
    \ {\n        ++$index;\n        $string .= $number;\n    }\n    $string =~ s/(?<number>[one|two|three|four|five|six|seven|eight|nine]+)//g;\n\
    \    my @list = reverse split //, $string;\n    return join(\" \", @list);\n}",
  '    my(@sorted_numbers);', '    chomp($numbers);', '    chomp($numbers);', '    my(@result)
    = (0, 0);', "    my $min = -1;\n    my @numbers_sorted = ();\n    my $last_num\
    \ = \"\";\n    my $spaced_digits = \"zero\";", "    my($i, $j, $sorted, $number);\n\
    \    for($i = 0; $i < $#numbers; $i++) {\n        my ($first, $second) = split(\"\
    \ \", $numbers[$i]);\n        for($j = 0; $j < $#numbers; $j++) {\n          \
    \  $number = $numbers[$j];\n            last if ($number =~ /^$second$/);\n  \
    \      }\n        $sorted = $first . \" \" . $second;\n    }\n    return $sorted;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI added your code, but it doesn't seem\
    \ to be working. Not sure why.\n<|/ c |>\n<| c |>\nOh, I thought I was working\
    \ in perl :) I added the explanation above. Also, be sure to check your spelling,\
    \ because my code has \"sort\" spelled with two \"s\". That may be a contributing\
    \ factor.\n<|/ c |>\n<| c |>\nThanks. I added the spelling error and tested it\
    \ on some input - it works for some inputs, but not others. I don't know what's\
    \ causing it. Maybe it's because I have some extra white space? It's not exactly\
    \ obvious to me how that would cause an issue, though.\n<|/ c |>\n<| a |>\nThis\
    \ looks like homework, so I won't write the full answer, but here are a few pointers:",
  "    my @numbers_array = split(\" \", $numbers);\n    my @sorted_numbers_array =\
    \ sort_numbers_array(\\@numbers_array);\n    return join(\" \", @sorted_numbers_array);\n\
    }", "    $numbers =~ s/^\\s+//;\n    my @numbers = split(/ /, $numbers);\n   \
    \ my $i = 0;\n    my $sorted = \"\";\n    foreach my $num (@numbers) {\n     \
    \   $i++;\n        if ($i ne $#numbers) {\n            $sorted .= $num;\n    \
    \    }\n    }\n    return $sorted;\n}", "    my @numbers = split ' ', $numbers;\n\
    \    my @sorted = sort { $a <=> $b };\n    return join ' ', @sorted;\n}", "  \
    \  my @numbers = split(\" \", $numbers);\n    @numbers = map { $numbers[$_] }\
    \ 0..@numbers-1;\n    return join(\" \", @numbers);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nWhy did you choose to return the string instead of the numbers?\n<|/ c\
    \ |>\n<| c |>\nBecause that is how I understood the question.  You didn't say\
    \ what type of result you wanted, and I didn't want to confuse people. I also\
    \ thought it would be easier to write the code this way, because I like to think\
    \ about algorithms working on single data types at a time.\n<|/ c |>\n<| c |>\n\
    I wasn't trying to confuse anyone, just wondering why you chose to return it as\
    \ a string.\n<|/ c |>\n<| c |>\nI didn't know if people would like to sort an\
    \ array of numbers or strings. That is why I chose to return an array. Perhaps\
    \ that was the reason for my downvote. :-)\n<|/ c |>\n<| c |>\nWell, I wasn't\
    \ trying to confuse people. :-) And thanks for the downvote :-)\n<|/ c |>\n<|\
    \ a dscore=4 tags=perl,sorting |>\nYou can get your desired result by using the\
    \ following:\n<code>", "    my(@new_numbers);\n    my @numbers = split(\" \",\
    \ $numbers);\n    foreach my $i (0 .. $#numbers) {\n        $new_numbers[$i] =\
    \ $numbers[$i];\n    }\n    foreach my $i (0 .. $#numbers) {\n        my $smaller\
    \ = $new_numbers[$i];\n        my $bigger = $new_numbers[$i];\n        $bigger\
    \ = $numbers[$i] if $i < ($#numbers - 1);\n        $bigger = $numbers[0] if $i\
    \ == ($#numbers - 1);\n        foreach my $j ($i + 1 .. $#numbers) {\n       \
    \     my $val = $numbers[$j];\n            if ($val eq $smaller) {\n         \
    \       $new_numbers[$j] = $bigger;\n                $new_numbers[$i] = \"one\"\
    ;\n            } else {\n                $new_numbers[$j] = $smaller;\n      \
    \          $new_numbers[$i] = $bigger;\n            }\n        }\n    }\n    my\
    \ $new_numbers_string = join(\", \", @new_numbers);\n    return $new_numbers_string;\n\
    }", "    my(@numbers_as_strings);\n    my @numbers_as_strings = split( /\\s+/,\
    \ $numbers );\n    my $sorted_numbers;\n    foreach my $numbers_as_string ( @numbers_as_strings\
    \ ) {\n        push( @$sorted_numbers, $numbers_as_string ) unless $numbers_as_string\
    \ eq 'zero';\n    }\n    return join( ' ', @$sorted_numbers );\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks for your reply.  It is a bit too advanced for\
    \ me at the moment but thanks for pointing me in the right direction.  I'll read\
    \ up on Perl.  :)\n<|/ c |>\n<| a tags=perl,regex |>\nThis program will sort your\
    \ string of numbers and place a space after each one. It will only place a space\
    \ if the next number is greater than the previous one.\n<code>\nuse strict;\n\
    use warnings;", "    my(@numbers) = split ' ', $numbers;\n    my($first_number)\
    \ = $numbers[0];\n    my(@sorted_numbers) = ();\n    my($sorted_numbers_index)\
    \ = -1;\n    while (++$sorted_numbers_index <= $#numbers) {\n        if ($sorted_numbers_index\
    \ > 0) {\n            $sorted_numbers[$sorted_numbers_index] =~ m/^(zero|one|two|three|four|five|six|seven|eight|nine)$/\
    \ ||\n                die \"Invalid number in sort_numbers: $sorted_numbers[$sorted_numbers_index]\\\
    n\";\n        }\n        if ($sorted_numbers[$sorted_numbers_index] =~ /^zero/i)\
    \ {\n            $sorted_numbers[$sorted_numbers_index] = 'zero';\n        } elsif\
    \ ($sorted_numbers[$sorted_numbers_index] =~ /^one/i) {\n            $sorted_numbers[$sorted_numbers_index]\
    \ = 'one';\n        } elsif ($sorted_numbers[$sorted_numbers_index] =~ /^two/i)\
    \ {\n            $sorted_numbers[$sorted_numbers_index] = 'two';\n        } elsif\
    \ ($sorted_numbers[$sorted_numbers_index] =~ /^three/i) {\n            $sorted_numbers[$sorted_numbers_index]\
    \ = 'three';\n        } elsif ($sorted_numbers[$sorted_numbers_index] =~ /^four/i)\
    \ {\n            $sorted_numbers[$sorted_numbers_index] = 'four';\n        } elsif\
    \ ($sorted_numbers[$sorted_numbers_index] =~ /^five/i) {\n            $sorted_numbers[$sorted_numbers_index]\
    \ = 'five';\n        } elsif ($sorted_numbers[$sorted_numbers_index] =~ /^six/i)\
    \ {\n            $sorted_numbers[$sorted_numbers_index] = 'six';\n        } elsif\
    \ ($sorted_numbers[$sorted_numbers_index] =~ /^seven/i) {\n            $sorted_numbers[$sorted_numbers_index]\
    \ = 'seven';\n        } elsif ($sorted_numbers[$sorted_numbers_index] =~ /^eight/i)\
    \ {\n            $sorted_numbers[$sorted_numbers_index] = 'eight';\n        }\
    \ elsif ($sorted_numbers[$sorted_numbers_index] =~ /^nine/i) {\n            $sorted_numbers[$sorted_numbers_index]\
    \ = 'nine';\n        } else {\n            die \"Invalid number in sort_numbers:\
    \ $sorted_numbers[$sorted_numbers_index]\\n\";\n        }\n        if ($numbers[$sorted_numbers_index]\
    \ =~ /^zero", '    my(@numbers_sorted);', "    return join(\" \", sort(map {$_}));\n\
    }", "    my @numbers = split ' ', $numbers;", '    my(@sorted_numbers);', '    my($sorted_numbers);',
  "    my @numbers_as_strings = split ' ', $numbers;\n    my @ordered_numbers = ();\n\
    \    my $last_number_as_string = 0;\n    my $number_count = 0;", "    my($sort)\
    \ = uc($numbers);\n    my($numbers_new);\n    my($sort);", "    my($sortedbytes);\n\
    \    my($maxbytes);\n    my($maxindex);\n    my($maxvalue);\n    my($tempbyte);\n\
    \    my($tempindex);", "    my($order) = @_;\n    return unless $numbers && $order;",
  '    my($string) = undef;', "    my(@numbers) = split ' ', $numbers;\n    @numbers\
    \ = sort { $a <=> $b } @numbers;\n    return join ' ', @numbers;\n}", "    my($count)\
    \ = length $numbers;\n    my($num);\n    my($sorted_numbers);", "    $numbers\
    \ =~ s/(^| )#/$1&/;\n    $numbers =~ s/(^| )0([^0-9]|$)/$1$1$2/g;\n    $numbers\
    \ =~ s/^([0-9]{2,})(.*)/$1$2/g;\n    $numbers =~ s/^([0-9]{2,})([^0-9]|$)/$1$2/g;\n\
    \    $numbers =~ s/^([0-9]{2,})$/$1/g;\n    return $numbers;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=sorting,perl dscore=0 |>\n<code>", '    my($sorted);',
  "    my @sorted = map { $_ eq $numbers[-1] ? $numbers[-1] : $_ } split \" \", $numbers;\n\
    \    return join \" \", @sorted;\n}", "    my(@numbers);\n    my($digits);\n \
    \   my($number);\n    my($last);", "    my @numbers = split(\" \", $numbers);\n\
    \    my @sorted_numbers = ();", "    my(@sorted_numbers);\n    my(@digits);\n\
    \    \n    # Turn input into a space-delimited list of numbers\n    my @number_list\
    \ = split (/ /, $numbers);\n    \n    # Add digits in number_list to @digits\n\
    \    foreach my $num (@number_list) {\n        $digits .= $num;\n    }\n    \n\
    \    # Add zero to @digits\n    push @digits, '0';\n    \n    # Sort @digits into\
    \ @sorted_digits\n    sort {\n        # Remove leading zero from @digits\n   \
    \     my $ld = lc($_);\n        \n        # Sort @digits based on length from\
    \ shortest to longest\n        my $ld_length = $ld =~ tr/0-9//;\n        \n  \
    \      # Return 0 if lengths of $ld and $ld_length are equal\n        return $ld_length\
    \ <=> $ld_length;\n    } @digits;\n    \n    # Remove leading zero from @sorted_digits\n\
    \    my $ld = lc($sorted_digits[0]);\n    \n    # Return @sorted_numbers with\
    \ leading zero removed\n    return join(\" \", @sorted_numbers);\n}", "    my\
    \ @nums;\n    my $i = 1;\n    while (my $n = substr($numbers, $i, 1)) {\n    \
    \    push(@nums, $n);\n        $i++;\n    }\n    foreach (@nums) {\n        my\
    \ $pos = $_;\n        foreach my $num (@nums) {\n            if ($num > $pos)\
    \ {\n                my ($tmp, $pos) = ($num, $pos);\n            }\n        }\n\
    \        push @nums, $pos;\n    }\n    return join(\" \", @nums);\n}", "    my($numbers_sorted);\n\
    \    chomp($numbers);\n    foreach my $number (split(\" \", $numbers)) {\n   \
    \     $numbers_sorted .= $number cmp $numbers_sorted ? $number : $numbers_sorted;\n\
    \    }\n    return $numbers_sorted;\n}\n</code>\nThis sorts the string from smallest\
    \ to largest, but does not return the string.  If you want to return it, just\
    \ add the following to the end of your function:\n<code>\nreturn $numbers_sorted;\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "    my $sorted_numbers;\n\
    \    my = split(\" \", $numbers);\n    my $i = 0;\n    my $j = 0;\n    my $k =\
    \ 0;\n    my $temp;\n    foreach my $number (@numbers) {\n        $temp = $number;\n\
    \        my $j = 0;\n        foreach my $i (@numbers) {\n            if ($i <\
    \ $number) {\n                $sorted_numbers[$k++] = $temp;\n               \
    \ last;\n            }\n            $j++;\n        }\n        $sorted_numbers[$k++]\
    \ = $temp;\n    }\n    $sorted_numbers;\n}", "    $numbers =~ s/\\s+//g;\n   \
    \ $numbers =~ s/^\\s+//g;\n    $numbers =~ s/\\s+$//g;", "    my @numbers = split\
    \ ' ', $numbers;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
