name: HumanEval_86_anti_shuffle
language: pl
prompt: "# Write a function that takes a string and returns an ordered version of\
  \ it.\n# Ordered version of string, is a string where all words (separated by space)\n\
  # are replaced by a new word where all the characters arranged in\n# ascending order\
  \ based on ascii value.\n# Note: You should keep the order of words and blank spaces\
  \ in the sentence.\n# For example:\n# >>> anti_shuffle(\"Hi\")\n# \"Hi\"\n# >>>\
  \ anti_shuffle(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle(\"Hello World!!!\")\n\
  # \"Hello !!!Wdlor\"\nsub anti_shuffle {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&anti_shuffle;\n\
  \        if(eq_deeply($candidate->(\"Hi\"),\"Hi\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hello\"),\"ehllo\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  number\"),\"bemnru\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->(\"abcd\"),\"abcd\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello\
  \ World!!!\"),\"Hello !!!Wdlor\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How\
  \ aer ?ouy\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    $s =~ s/\\s+/\\s+/g;\n    my(@words) = split / /, $s;\n    my(@letters)\
    \ = split //, chr(0x20) x (length($s) - 1);\n    for (my $i = 0; $i < scalar(@words);\
    \ $i++) {\n        for my $j ($i + 1; $j < scalar(@words); $j++) {\n         \
    \   my($word1, $word2) = @{$words[$i]}, @{$words[$j]};\n            my $diff =\
    \ $word1 lt $word2;\n            if ($diff) {\n                @letters[$j] =\
    \ $letters[$i];\n            }\n            else {\n                @letters[$i]\
    \ = $letters[$j];\n            }\n        }\n    }\n    return join(\" \", @words);\n\
    }", "    $s =~ tr/A-Z/a-z/;\n    $s =~ s/ /\\|/g;\n    $s =~ s/(\\S)/$1/ig;\n\
    \    return $s;\n}\n</code>\n<|/ a tags=string,perl,random,word-wrap |>\n<| a\
    \ tags=string,perl,random,word-wrap dscore=0 |>\n<code>\nuse strict;\nuse warnings;\n\
    use feature 'say';", "    return join(\" \", sort {\n        chr(ord($a)) cmp\
    \ chr(ord($b))\n    } split(\" \", $s));\n}\n</code>\n<|/ a tags=perl,replace,string\
    \ |>\n<| a |>\nUsing map and join:\n<code>\nmy $string = \"my name is bob\";\n\
    $string =~ s/(\\w+)/join \" \", map {\n    my $c = $_;\n    substr($c, 0, 1) cmp\
    \ substr($c, 1, 1)\n} split(/\\W+/, $1);\nprint $string;\n</code>\n<|/ a dscore=1\
    \ tags=perl,replace,string |>\n<| a |>\nHere is a simpler one-liner version:\n\
    <code>\n$ perl -pi -e 's/\\B(\\w)/\"$1\" =~ tr/a-z/A-Z/r//eg'\n</code>\nThis splits\
    \ the line on the word boundary, turns the lowercase letters into uppercase (by\
    \ adding an extra character to the front), and then turns the uppercase letters\
    \ into lower case (by removing that extra character).\n<code>\n$ perl -pi -e 's/\\\
    B(\\w)/\"$1\" =~ tr/A-Z/a-z/r//eg'\n</code>\n<|/ a tags=perl,replace,string dscore=1\
    \ |>\n<| a dscore=0 |>\nPerhaps something like this:\n<code>\nuse strict;\nuse\
    \ warnings;\nmy $string = \"hello world\";\n$string =~ s/\\W/ /ig;\n$string =~\
    \ s/(\\w)/$string=~s/(\\w)/$1/ if $string=~s/\\W///ig;\nprint $string;\n</code>\n\
    <|/ a tags=perl,replace,string |>\n<| c |>\nWhat is the `i` doing?  And, it would\
    \ be better if you used a global regex modifier (`g`).\n<|/ c |>\n<| c |>\nThe\
    \ `i` makes it case-insensitive. Otherwise it would just replace all non-word\
    \ characters with spaces.\n<|/ c |>\n<| c |>\nOh I see, that's not what he wants.\
    \  That makes things even more complicated for his own answer.  He wants to do\
    \ case-insensitive replacement.\n<|/ c |>\n<| c |>\n- I believe that's exactly\
    \ what he wants. \"replace all non-word characters with spaces.\" I don't think\
    \ the `g` modifier applies here.\n<|/ c |>\n<| c |>\nYeah, that's what I thought.\
    \  I ", "    $s =~ s/\\s+/ /g;\n    my @words = split /\\s+/, $s;\n    my @sorted\
    \ = sort { lc($a) cmp lc($b) } @words;\n    $s =~ s/(\\s+)/ $sorted[$#sorted]/g;\n\
    \    $s\n}", "    # remove any whitespace\n    $s =~ s/\\s+//g;\n    # separate\
    \ into words\n    my(@words) = split(' ', $s);\n    # sort characters from each\
    \ word\n    my(@sorted_words) = map ($words[$_], sort);\n    # combine words back\
    \ into one string\n    return join(' ', @sorted_words);\n}", "    my(@words);\n\
    \    for(split(/ /, $s)) { push(@words, $_) }\n    my $sorted_list = join(' ',\
    \ sort(@words));\n    return $sorted_list;\n}", "    my @a = split(/ /, $s);\n\
    \    my @b = ();\n    my $i;\n    my $j;\n    for (my $i = 0; i < @a; ++$i) {\n\
    \        for (my $j = 0; $j < @b; ++$j) {\n            $b[$j] = $a[$i];\n    \
    \    }\n        for (my $j = @b; $j < @a; ++$j) {\n            $b[$j] = \"_\"\
    \ . $b[$j];\n        }\n        @a = @b;\n    }\n    return join(\" \", @a);\n\
    }", "    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/a-z/A-Z/;\n    $s =~ tr/0-9/A-Z/;\n\
    \    $s =~ s/\\s/ /g;\n    return $s;\n}\n</code>\n<|/ a dscore=2 tags=shuffle,perl,string\
    \ |>\n<| c |>\nThis has problems with non-English characters, e.g. '\xE2' (Latin\
    \ capital ae) is transformed to '\xC3\xA2'.\n<|/ c |>\n<| c |>\nHi, thanks for\
    \ this. I'm having trouble with the output though. Maybe my terminal isn't set\
    \ up correctly to print UTF-8.\n<|/ c |>\n<| c |>\nWhat are you using to print\
    \ it? You need `use utf8;` in your program for it to work.\n<|/ c |>\n<| c |>\n\
    Oh yes! I'm such a fool. Thanks for this! My terminal was set to CP1252 instead\
    \ of UTF-8, which caused all sorts of trouble.\n<|/ c |>\n<| c |>\nIt's better\
    \ to use a specific code page for characters such as \xE2 for example: `use encoding\
    \ 'cp1252';`\n<|/ c |>\n<| a tags=shuffle,perl,string |>\nI know this question\
    \ was already answered but just in case you want a more general solution (i.e.\
    \ not specific to English only), here is my solution using List::MoreUtils:\n\
    <code>\nuse strict;\nuse warnings;\nuse List::MoreUtils qw/shuffle/;", "    my\
    \ @words = split(/\\s/,$s);\n    my($result);\n    for (my $i=0;$i<@words;$i++)\
    \ {\n        $result .= $words[$i] if $words[$i] =~ /[a-z]/i;\n    }\n    return\
    \ $result;\n}", "    $s =~ s/([^\\s]+)/ $1 =~ /[\\d]/g ? $1 : \"$1 \" /ge;\n \
    \   return $s;\n}", "    my @tokens = split(/ /, $s);\n    my @new_tokens;\n \
    \   my $i = 0;\n    my $len = @tokens;\n    my @new_characters;", "    $s =~ s/\\\
    s*(\\S+\\s*\\S+)|(\\S+)\\s*/$1$2/g;\n    return $s;\n}", "    my @words;\n   \
    \ push @words, map { split ' ' } split(//, $s);\n    \n    my @new_words;\n  \
    \  for my $word (@words) {\n        $word = uc $word;\n        my $i = $#{$words[]}\
    \ + 1;\n        $words[$i] = $word;\n    }\n    \n    my @result;\n    for my\
    \ $word (@new_words) {\n        push @result, join ' ', $words[$#new_words], $word;\n\
    \    }\n    return join(\"\", @result);\n}", "    $s =~ s/(\\w)(\\w*)/$2 . $1\
    \ =~ tr/A-Z/a-z/;\n    return $s;\n}", "    # Split string into word and non-word\
    \ sequences\n    my($word,$non_words);\n    my $word_length = length $s;\n   \
    \ while ($word_length >= 2) {\n        $word = substr($s,0,$word_length);\n  \
    \      $non_words = substr($s,$word_length,length($s));\n        my $char_counter\
    \ = -1;\n        for (my $i = 0; $i < length($word); $i++) {\n            $char_counter\
    \ += ord($word[$i]) - ord(\"a\");\n        }\n        $word_length--;\n      \
    \  my @new_chars;\n        for (my $i = 0; $i < length($non_words); $i++) {\n\
    \            $char_counter += ord($non_words[$i]) - ord(\"a\");\n            push(@new_chars,\"\
    a\" if $char_counter <= 0);\n            push(@new_chars,\"z\" if $char_counter\
    \ > 25);\n        }\n        $s = substr($s,0,0) . join(\"\",@new_chars) . substr($s,length($non_words));\n\
    \    }\n    return $s;\n}", "    # use split here to keep order and remove duplicates.\n\
    \    # use sort here to keep alphabetical order\n    return join \" \", sort split\
    \ / /, $s;\n}\n</code>\n<|/ a tags=perl,python,string-parsing,data-processing\
    \ dscore=1 |>\n<| a tags=perl,python,string-parsing,data-processing |>\nThis solution\
    \ works by using a regex that captures non-word characters (i.e. characters that\
    \ aren't letters, digits, underscore, or dash) and replaces them with spaces.\
    \ Then it replaces multiple spaces with a single space at the end and the end-of-line\
    \ anchor with an empty string so that all white space is removed. Then the remaining\
    \ string is split and sorted alphabetically.\nThis approach also avoids any looping\
    \ or recursion.\n<code>\nuse strict;\nuse warnings;", "    return $s if $s eq\
    \ $s ;\n    return $s . \"\\0\" ;\n    my @words = split(\" \", $s);\n    my $n\
    \ = 0;\n    my $first;\n    my $word = \"\";\n    my $words = [];\n    foreach\
    \ my $w (@words) {\n        if ($n != 0) {\n            $word = $w . substr($word,\
    \ $n, 1);\n        }\n        if (length($word) == 0) {\n            $word = $w;\n\
    \        }\n        if (length($word) > 0) {\n            $words[$n] = $word;\n\
    \            $n++;\n        }\n        $first = $w;\n    }\n    my $i = 0;\n \
    \   my $j = 0;\n    my $k = -1;\n    my @out = ();\n    my $first;\n    foreach\
    \ my $w (@words) {\n        if ($w eq $first) {\n            $w = $words[$j];\n\
    \            $j++;\n        }\n        $out[$i] = $w;\n        if ($j == $k) {\n\
    \            $j = 0;\n            $k++;\n            $i++;\n        }\n    }\n\
    \    return join(\" \", @out);\n}", "    my(@sorted_string) = split /\\s+/, $s;\n\
    \    my(@sorted_char) = sort { ord($a) <=> ord($b) };\n    my($new_s);", "   \
    \ my(@words);\n    my($i);", "    my %map;\n    my($i, $j, $new_word);\n    my\
    \ $j = 0;\n    for ($i = 0; $i <= $#$s; $i++) {\n        if ($s[$i] !~ /\\s/)\
    \ {\n            $map{$s[$i]} = $j;\n            $j++;\n        }\n    }\n   \
    \ for ($i = 0; $i < $#$s; $i++) {\n        $new_word = \"\";\n        for ($j\
    \ = 0; $j < $#$s; $j++) {\n            if ($s[$j] !~ /\\s/) {\n              \
    \  if ($map[$s[$j]] >= $map[$s[$i]]) {\n                    $new_word .= $s[$i];\n\
    \                }\n            }\n        }\n        $s[$i] = $new_word;\n  \
    \  }\n    return $s;\n}", "    $s =~ s/(\\w+)(\\s*)/g; # get rid of word boundaries\n\
    \    $s =~ s/([a-zA-Z])(\\s*)/g; # get rid of letters boundaries\n    $s =~ s/\\\
    s[A-Z]//g; # get rid of leading spaces in words\n    $s =~ s/\\s+//g; # get rid\
    \ of trailing spaces in words\n    $s =~ s/[A-Z]+/&$&/; # get rid of duplicate\
    \ letters\n    $s =~ s/[^a-zA-Z\\s]/-/g; # get rid of non-letters\n    $s =~ s/-$//g;\
    \ # get rid of trailing hyphen\n    return $s;\n}", "    my $new_s = '';\n   \
    \ my $ord = \"@{ [unpack('(A)', $s)] }\";\n    my @ordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordord",
  "    my @words = split(/ /, $s);\n    my @sort = map {chr ord $_, 1} @words;\n \
    \   return join(' ', @sort);\n}", "    $s =~ s/(\\w+\\s+\\w+)/$1 eq $1 ? \"$1\
    \ \" : $1 eq $1 ? \"$1\" : $1/ge;\n    return $s;\n}", "    my @chars = split(//,\
    \ $s);\n    my $tmp;\n    my $len = @chars;\n    foreach my $i (0..$len-1) {\n\
    \        my $char = substr($chars[$i], 0, 1);\n        $char = chr(ord($char)\
    \ + ord(\"a\")%26);\n        $tmp .= $char;\n    }\n    $tmp;\n}\n</code>\n<|/\
    \ a tags=string,perl,replace dscore=2 |>\n<| c |>\nIt may be, but I did not see\
    \ a requirement to preserve order of words. `anti_shuffle(\"Hello World!!!\")`\
    \ should return `\"!!!drlleoW\"`, not `\"!!dlleoW\"`\n<|/ c |>\n<| a |>\nI would\
    \ do it this way:\n<code>\nuse Algorithm::Combinatorics qw(combinations);", " \
    \   $s = join ' ', map {chr int ($_/26*26 + $_%26)}\n             sort map {chr\
    \ int ($_/26*26+$_%26)} (split /\\s+/, $s);\n    return $s;\n}\n</code>\n<|/ a\
    \ dscore=3 tags=perl,sorting |>\n<| a tags=perl,sorting dscore=3 |>\nHere's a\
    \ solution that's more complex than it needs to be. As already said, it's just\
    \ an exercise for the reader.\n<code>\nuse feature qw(say);", "    $s =~ s/(\\\
    s)/ $1 /g;\n    $s =~ s/([a-z])/$1./gi;\n    $s =~ s/([^\\w ]{2,})/$1 /g;\n  \
    \  $s =~ s/(.{1})(.{1})(.{1})/.$2.$3.$1/;\n    return $s;\n}", "    $s =~ s/\\\
    s+/ /g;\n    my @words = split(/\\s/,$s);\n    my @chars;\n    foreach my $word\
    \ (@words) {\n        my @chars_tmp;\n        foreach my $char (split(' ',$word))\
    \ {\n            my $ord = ord($char);\n            if ($ord < ord('Z')) {\n \
    \               push @chars_tmp,chr($ord+64);\n            }\n            else\
    \ {\n                push @chars_tmp,chr($ord-32);\n            }\n        }\n\
    \        push @chars,join('',@chars_tmp);\n    }\n    return join('',@chars);\n\
    }", "    $s =~ s/(\\s+)(\\S+)/$2 => chr(ord($1)+ord($3)-1)/ge;\n    return $s;\n\
    }", "    $s =~ s/^\\s*(\\S+)\\s*/$1\\s*\\0\\s*/;\n    $s =~ s/\\s*(\\S+)\\s*$/$1\\\
    0\\s*\\1/;\n    $s =~ tr/\\0/ /;\n    return $s;\n}", '    my @res;', "    $s\
    \ =~ s/\\b\\w++(?!\\w)/ $_ = lc $1 /ge;\n    return $s;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt doesn't work for `anti_shuffle(\"Hello World!!!\")`\n<|/ c |>\n<|\
    \ a tags=perl,regex dscore=2 |>\n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;",
  "    $s =~ s/\\s+/ /g;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)\\b/$1 $2 $3 $2$3/gi;\n\
    \    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)\\b/$1 $2 $3 $2$3$4/gi;\n    $s\
    \ =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)\\b/$1 $2 $3 $2$3$4$5/gi;\n    $s =~\
    \ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\b/$1 $2 $3 $2$3$4$5$6/gi;\n  \
    \  $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\b/$1 $2 $3 $2$3$4$5$6$7/gi;\n\
    \    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\b/$1\
    \ $2 $3 $2$3$4$5$6$7$8/gi;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\\
    b/$1 $2 $3 $2$3$4$5$6$7$8$9/gi;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\\
    b/$1 $2 $3 $2$3$4$5$6$7$8$9$a/gi;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\\
    b/$1 $2 $3 $2$3$4$5$6$7$8$9$a$b$c/gi;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)\\\
    b/$1 $2 $3 $2$3$4$5$6$7$8$9$a$b$c$d/gi;\n    $s =~ s/\\b([a-z])([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)([a-z]+)",
  "    my @split = split /\\s+/, $s;\n    for (my $i = 0; $i < @split; $i++) {\n \
    \       my $j = $i + 1;\n        $split[$i] = $split[$j];\n        $split[$j]\
    \ = $split[$i];\n    }\n    $s =~ s/^\\s+|\\s+$//g;\n    $s =~ s/\\s+/ /g;\n \
    \   $s =~ s/(\\w)([\\W\\s]{1})(\\w)/ $1 . chr(ord($2) + 1) . $3/g;\n    return\
    \ $s;\n}", "    my @tokens = split/\\s/, $s;\n    my $sorted = join(\" \",\n \
    \       map { length($_) > length($tokens[$#tokens]) ?\n            substr($tokens[$#tokens],\
    \ length($_)) :\n            $_ } 0 .. $#tokens\n    );\n    return $sorted;\n\
    }", "    $s =~ s/\\b([a-z])/uc($1)/ge;\n    $s =~ s/\\b([0-9])/sprintf(\"%c\"\
    ,$1)/eg;\n    $s =~ s/\\s{2,}/ /g;\n    $s =~ s/^ //;\n    $s =~ s/ $ //;\n  \
    \  return $s;\n}", "    my(@words);\n    my($new);", "    my @words = split(/\\\
    s+/, $s);\n    my $out = \"\";\n    my @new_word;\n    \n    foreach my $word\
    \ (@words) {\n        push(@new_word, undef);\n        for (my $i = 0; $i < length($word);\
    \ $i++) {\n            my $c = ord(substr($word, $i, 1));\n            if ($c\
    \ >= 97 && $c <= 122) {\n                push(@new_word, chr($c - 97));\n    \
    \        }\n            elsif ($c >= 65 && $c <= 90) {\n                push(@new_word,\
    \ chr(91 + $c - 65));\n            }\n            else {\n                push(@new_word,\
    \ chr(27 + $c - 97));\n            }\n        }\n        my $new_char = join(\"\
    \", @new_word);\n        $out .= $new_char;\n    }\n    $out;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nI really like your method - it uses a single array to\
    \ hold the letters and then just prints them out in the right order. Very neat.\
    \ Thanks so much!\n<|/ c |>\n<| a tags=sorting,perl,string,algorithm |>\nIf you\
    \ have to do this only once, you might be tempted to write some code using regex\
    \ and substitution, but I wouldn't do it. \nI'd use a sort function.\n<code>\n\
    sort { $a cmp $b } split \" \", $string\n</code>\nThis will split $string on whitespace,\
    \ and sort each element in the resulting array according to their sort order.\n\
    <|/ a dscore=1 |>\n<| c |>\nYeah, I thought of sorting it and then looping through\
    \ the array and replacing it with another variable that replaced the whitespace\
    \ with a \"word\" so they could be sorted. I really like this solution as well,\
    \ thanks!\n<|/ c |>\n<| a dscore=1 tags=sorting,perl,string,algorithm |>\nThis\
    \ solution works with the original requirements in the question and doesn't require\
    \ any modules. \n<code>", "    my @s = split /\\s+/, $s;\n    for (@s) {\n   \
    \     my($first) = /(.)$/;\n        my($second) = /([a-z])/;\n        my $c =\
    \ chr(ord $first) + ord $second;\n        print $c;\n    }\n}\n</code>\n<|/ a\
    \ dscore=0 tags=perl |>\n<| c |>\nYour solution is missing some things. The script\
    \ must return the same thing as you proposed, as stated in the comments above.\
    \ And, you are missing a `$` sign in the regex for `$first`.\n<|/ c |>\n<| c |>\n\
    - thanks for the comment - I corrected all the issues in the code above\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>\nuse Data::Sort qw(sort);", "    return $s if !$s;\n\
    \    my @words=split(/\\s+/,$s);\n    my %sorted;\n    foreach my $w (@words)\
    \ {\n        $w =~ tr/a-z/A-Z/;\n        my $char = $w;\n        $sorted{$char}++;\n\
    \    }\n    my @chars=sort { $sorted{$a} <=> $sorted{$b} || $a cmp $b } keys %sorted;\n\
    \    return join(\"\",@chars);\n}\n</code>\n<|/ a dscore=1 tags=perl,shuffle |>\n\
    <| c |>\nWon't work if words are long. E.g. `\"Hello World!!!\"` -> `\"!Wdlor!!!\"\
    `\n<|/ c |>\n<| c |>\nAlso `anti_shuffle(\"Hi there\")` -> `\"Hi there\"`.\n<|/\
    \ c |>\n<| a dscore=1 tags=perl,shuffle |>\nYou can use the following regexp:\n\
    <code>\ns/([a-z]{2,}) (\\1)/\"$2 $1\"/g\n</code>\n<|/ a |>\n<| a tags=perl,shuffle\
    \ |>\nJust a variant of previous answers, if you don't want to use a regex:\n\
    <code>", "    $s =~ s/\\s+/\\s+/g;\n    $s =~ s/(\\w)\\b/$1 $2/g;\n    $s =~ s/\\\
    s(\\w)\\b/$1$2/g;\n    return $s;\n}", "    $s =~ s/ /\\s+/g;\n    my(@words)\
    \ = split(/ /, $s);\n    my(@new_words);\n    foreach $word (@words) {\n     \
    \   my($ord) = $word;\n        $ord = ord($word);\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n        $ord = $ord ^ 96;\n\
    \        $ord = $ord ^ 96;\n        $ord = $ord ^ 9", "    my @words = split /\
    \ /, $s;\n    my $length = scalar @words;\n    my $temp;\n    for(my $i = 0; $i\
    \ < $length; $i++) {\n        $temp = $words[$i];\n        for(my $j = 0; $j <\
    \ $i; $j++) {\n            if($words[$j] cmp $temp) {\n                my $temp2\
    \ = $words[$j];\n                $words[$j] = $words[$i];\n                $words[$i]\
    \ = $temp2;\n            }\n        }\n    }\n    $s = join '', @words;\n    return\
    \ $s;\n}", "    $s =~ s/([a-z](?: [A-Z])?)/$1/ig;\n    return $s;\n}", "    $s\
    \ =~ s/\\b(\\w+)\\b/\"$1 \" x length($1)/eg;\n    return $s;\n}\n</cell>\n<cell>",
  "    my @l = split(' ', $s);\n    my @r = ();\n    foreach my $l (@l) {\n      \
    \  push @r, $l\n            if ($l =~ /./);\n        foreach my $i (map { ord($_)\
    \ - ord('a') } split(' ', $l)) {\n            push (@r, chr($i + ord('a') + 1));\n\
    \        }\n    }\n    return join(' ', @r);\n}", "    my @a = split(//, $s);\n\
    \    my @new;\n    my $i = 1;\n    my $j = 1;\n    for (my $k = 0; $k < $#a; ++$k)\
    \ {\n        while ($a[$k] eq \"\") {\n            $k++;\n        }\n        while\
    \ ($j == $i) {\n            $new[$j] = \"\";\n            $j++;\n        }\n \
    \       $new[$k] = $a[$k];\n        $a[$k] = \"\";\n        $i = $j + 1;\n   \
    \     $j = $i + 1;\n    }\n    return join(' ', @new);\n}\n</code>\n<|/ a tags=perl,sorting\
    \ dscore=0 |>\n<| a tags=perl,sorting |>\nI wrote a program to find the positions\
    \ of the words in an array of strings in alphabetical order. It uses List::Utils,\
    \ which is a core Perl module. \n<code>", "    my $temp;\n    $temp = \"\";\n\
    \    my $ord;\n    my $i = 0;\n    my $len = 0;\n    my $c;\n    while (length($s)\
    \ > 0) {\n        $c = substr($s, 0, 1);\n        $ord = ord($c);\n        $len\
    \ = length($s);\n        for ($i = 1; $i <= $len; $i++) {\n            my $temp2\
    \ = substr($s, $i - 1, 1);\n            if ($ord < ord($temp2)) {\n          \
    \      substr($s, $i - 1, 1);\n                substr($s, $i, 0, 1);\n       \
    \         substr($s, $i, 1);\n            }\n        }\n        $temp .= substr($s,\
    \ 0, 1);\n    }\n    return $temp;\n}\n</code>\n<|/ a dscore=2 tags=perl,sorting,string\
    \ |>\n<| a dscore=1 |>\n<code>", "    $s =~ s/\\b(\\w+)\\b\\s+(\\w+)/$1.$2/g;\n\
    \    $s =~ s/\\b(\\w+)\\b\\s+(\\w+)$/$1.$2/g;\n    $s =~ s/\\b(\\w+)\\b\\s+(\\\
    w+)$/.$2/g;\n    $s =~ s/(\\w+)\\b\\s+(\\w+)$/$2.$1/g;\n    $s =~ s/(\\w+)\\b\\\
    s+(\\w+)$/.$1/g;\n    $s =~ s/(\\w+)\\b\\s+(\\w+)$/.$2/g;\n    $s =~ s/(\\w+)\\\
    b\\s+(\\w+)$/$1.$2/g;\n    return $s;\n}", "    my @words = split(/ /, $s);\n\
    \    my @new_words;\n    my $i = 0;\n    foreach my $word (@words) {\n       \
    \ $new_words{$word} = $word;\n        $new_words{\"$word$i\"} = $word;\n     \
    \   $new_words{\"$word$i$i\"} = $word;\n        $new_words{\"$word$i$i$i\"} =\
    \ $word;\n        $new_words{\"$word$i$i$i$i\"} = $word;\n        $i++;\n    }\n\
    \    $s = \"@new_words\";\n    return $s;\n}", "    my(@a);\n    my $words = split\
    \ /\\s+/, $s;\n    foreach my $word (@$words) {\n        my $len = length $word;\n\
    \        my $ord = ($len * -1);\n        $ord += $ord;\n        $ord += $ord;\n\
    \        push (@a, chr $ord);\n    }\n    return join '', @a;\n}", "    $s =~\
    \ s/[\\s\\-\\.]/-/g;\n    $s =~ s/([A-Za-z])/uc($1)/ge;\n    $s =~ s/([0-9])/sprintf(\"\
    %c\", $1)/ge;\n    $s =~ s/(\\S)\\B/$1-/g;\n    $s =~ s/^(\\S)(\\S)$/$1$2/g;\n\
    \    $s =~ s/(\\S)(\\S)$/$1.$2/g;\n    return $s;\n}", "    $s =~ s/\\b(\\w+)\\\
    s+(\\w+)\\b/$1$2/g;\n    return $s;\n}", "    $s =~ s/ ( \\w ) /uc $1 /ge;\n \
    \   $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~\
    \ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\\
    w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1\
    \ /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n \
    \   $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~\
    \ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\\
    w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1\
    \ /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n \
    \   $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~\
    \ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\\
    w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1\
    \ /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n \
    \   $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =~ s/ ( \\w ) /uc $1 /ge;\n    $s =",
  "    $s =~ s/\\s+/+/g;\n    $s =~ s/([a-z])/$1./g;\n    $s =~ s/([A-Z])/$1./g;\n\
    \    $s =~ s/([0-9])/$1./g;\n    $s =~ s/([!?.])/$1./g;\n    $s =~ s/([*+()-])/$1./g;\n\
    \    $s =~ s/(--)/-/g;\n    $s =~ s/([-])(\\w)/$1.\"/;\n    $s =~ s/([^a-z])/$1./g;\n\
    \    $s =~ s/([a-z])([^a-z])/$1.$2./g;\n    $s =~ s/(^|[^a-z])(\\w)/$1.$2./g;\n\
    \    $s =~ s/([a-z])([A-Z])/$1.$2/g;\n    $s =~ s/([^a-z])([A-Z])/$1.$2./g;\n\
    \    $s =~ s/([A-Z])([a-z])/$1.$2/g;\n    $s =~ s/([0-9])([A-Z])/$1.$2/g;\n  \
    \  $s =~ s/([A-Z])([0-9])/$1.$2/g;\n    $s =~ s/([a-z])([0-9])/$1.$2/g;\n    $s\
    \ =~ s/([0-9])([a-z])/$1.$2/g;\n    $s =~ s/([a-z])([A-Z])([^a-z])/$1 $2./g;\n\
    \    $s =~ s/([A-Z])([a-z])([^a-z])/$1 $2./g;\n    $s =~ s/([^a-z])([0-9])/$1.$2./g;\n\
    \    $s =~ s/([A-Z])([0-9])([^a-z])/$1 $2./g;\n    $s =~ s/([0-9])([^a-z])/$1\
    \ $2./g;\n    $s =~ s/([^a-z])([A-Z])([^a-z])/$1 $2./g;\n    $s =~ s/([a-z])([A-Z])([^a-z])/$1\
    \ $2./g;\n    $s =~ s/([^a-z])([A-Z])([A-Z])/$1 $2./g;\n    $s =~ s/([A-Z])([A-Z])([^a-z])/$1\
    \ $2./g;\n    $s =~ s/([a-z])([A-Z])([A-Z])/$1 $2./g;\n    $s =~ s/([^a-z])([A-Z])([A-Z])([^a-z])/$1\
    \ $2./g;\n    $s =~ s/([a-z])([A-Z])([A-Z])/$1 $2./g;\n    $s =~ s/([^a-z])([A-Z])([A-Z])([A-Z])/$",
  "    my @chars = split(//, $s);\n    my $i = 0;\n    my @new_chars = ();\n    my\
    \ $len = scalar(@chars);\n    while (@chars) {\n        my $j = rand($len + 1);\n\
    \        my $t = $chars[$j];\n        unless ($t == \" \") {\n            push(@new_chars,\
    \ $t);\n            splice(@chars, $j);\n        }\n        $i++;\n    }\n   \
    \ return join('', @new_chars);\n}\n</code>\n<|/ a |>\n<| c |>\n`my = split(//,\
    \ $s);` will split on all characters, even those in quotes.\n<|/ c |>\n<| a |>\n\
    Here's a quick Perl one-liner!\n<code>\nperl -E 'for (<>;) { chomp; say for sort\
    \ { (ord($a) <=> ord($b)) } split / /; }' < file.txt\n</code>\n<|/ a tags=string,perl,random\
    \ dscore=2 |>\n<| c |>\nThe \"split /\\s*\\s/\" bit is not necessary with the\
    \ chomp. Split will chomp whitespace by default.\n<|/ c |>\n<| a tags=string,perl,random\
    \ |>\n<code>\nperl -lane'push(@chars,$_) if /\\w/'|sort -R\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,perl,random |>\n<code>\nuse strict;\nuse warnings;", " \
    \   my($t);\n    $s = lc $s;\n    my $i = 0;\n    my $new = \"\";\n    while ($i\
    \ < length $s) {\n        my $char = chr $i;\n        my $ascii = ord $char;\n\
    \        if ($ascii < 128) {\n            my $c = $char;\n            $char =\
    \ chr $i;\n            $ascii = ord $char;\n        }\n        if ($ascii < 128)\
    \ {\n            $new = substr($new, 0, 0) . $char . substr($new, 0, 0);\n   \
    \     } elsif ($ascii < 256) {\n            $new = substr($new, 0, 1) . $char\
    \ . substr($new, 1, 1);\n        } elsif ($ascii < 256) {\n            $new =\
    \ substr($new, 0, 2) . $char . substr($new, 2, 2);\n        } elsif ($ascii <\
    \ 256) {\n            $new = substr($new, 0, 3) . $char . substr($new, 3, 3);\n\
    \        } elsif ($ascii < 256) {\n            $new = substr($new, 0, 4) . $char\
    \ . substr($new, 4, 4);\n        } elsif ($ascii < 256) {\n            $new =\
    \ substr($new, 0, 5) . $char . substr($new, 5, 5);\n        } elsif ($ascii <\
    \ 256) {\n            $new = substr($new, 0, 6) . $char . substr($new, 6, 6);\n\
    \        } elsif ($ascii < 256) {\n            $new = substr($new, 0, 7) . $char\
    \ . substr($new, 7, 7);\n        } elsif ($ascii < 256) {\n            $new =\
    \ substr($new, 0, 8) . $char . substr($new, 8, 8);\n        } elsif ($ascii <\
    \ 256) {\n            $new = substr($new, 0, 9) . $char . substr($new, 9, 9);\n\
    \        } elsif ($ascii < 256) {\n            $new = substr($new, 0, 10) . $char\
    \ . substr($new, 10, 10);\n        } elsif ($ascii < 256) {\n            $new\
    \ = substr($new, 0, 11) . $char . substr($new, 11, 11);\n        } elsif ($ascii\
    \ < 256) {\n            $new = substr($new, 0, 12) . $char . substr($new, 12,\
    \ 12);\n        } else {\n            $new = substr($new, 0, 13) . $char . substr($new,\
    \ 13, 13);\n        }\n        ++$i;\n    }\n    return $new;\n}", "    $s =~\
    \ s/(^|\\s)\\K(\\S+)(?=\\s|$)/ \\2 /g;\n    $s =~ s/(\\S+)(?=\\s|$)/ \\1 /g;\n\
    \    $s =~ s/(\\S+?)(\\s[^\\s]*)(\\S+?)/$1 $2 $3 $2 $3 $1/ig;\n    $s =~ s/(\\\
    S+?)(\\S+?)(\\S+?)/$1 $2 $3 $1 $3 $2/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\\
    S+?)/$1 $2 $3 $1 $3 $2 $4/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)/$1\
    \ $2 $3 $1 $3 $2 $4 $5/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\\
    S+?)/$1 $2 $3 $1 $3 $2 $4 $5 $6/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\\
    S+?)(\\S+?)(\\S+?)/$1 $2 $3 $1 $3 $2 $4 $5 $6 $7/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\\
    S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)/$1 $2 $3 $1 $3 $2 $4 $5 $6 $7 $8/ig;\n\
    \    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)/$1\
    \ $2 $3 $1 $3 $2 $4 $5 $6 $7 $8 $9/ig;\n    $s =~ s/(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\\
    S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)(\\S+?)/$1 $2 $3 $1 $3 $2 $4 $5 $6 $7 $8 $9 $10/ig;\n\
    \    return $s;\n}", "    $s =~ s/^\\s+|\\s+$//g;\n    $s =~ s/\\s+(?=\\S)/_/g;\n\
    \    $s =~ s/_(?=\\S)/-/g;\n    $s =~ s/_\\B/-/g;\n    $s =~ s/-\\B/-/g;\n   \
    \ return $s;\n}", "    my @words = split(/\\s/,$s);\n    my @chars = map {ord($_)}\
    \ split(' ',$s);\n    my @new_chars = ();\n    foreach (@chars) {\n        push\
    \ (@new_chars, $_) if $_ > $chars[0];\n    }\n    return join('',@new_chars);\n\
    }", "    $s =~ s/[[:upper:]]+/ ($&=~tr/A-Z/a-ZA-Mn-z)/ge;\n    $s =~ s/[[:lower:]]+/\
    \ ($&=~tr/a-z/A-Za-Mn-z)/ge;\n    $s =~ s/[[:space:]]+/ $&=~tr/\\t\\r\\n\\v\\\
    r /c-z/ge if $^V;\n    return $s;\n}", "    my($s1) = 0;\n    my($s2) = 0;\n \
    \   my($s3) = 0;\n    my($s4) = 0;\n    my($new_word);\n    my($new_word) = \"\
    \";\n    my($new_char) = 0;\n    my($word) = \"\";\n    my(@characters) = ();\n\
    \    foreach $word (split(/ /, $s)) {\n        foreach $char (split(//, $word))\
    \ {\n            push(@characters, $char);\n        }\n    }\n    foreach $char\
    \ (@characters) {\n        if ($char ne \"\\n\") {\n            $s1 += ord($char);\n\
    \        } else {\n            $s2 += ord($char);\n        }\n    }\n    $new_char\
    \ = $s1 - ($s2 % 42);\n    if ($new_char < 65) {\n        $new_char = chr($new_char);\n\
    \    }\n    foreach $char (@characters) {\n        if ($char eq \"\\n\") {\n \
    \           $s4 += ord($char);\n        } elsif ($char ne \" \") {\n         \
    \   if ($new_char == ord($char)) {\n                $s3 += ord($char);\n     \
    \       } else {\n                if ($new_char < ord($char)) {\n            \
    \        $new_char = chr($new_char);\n                }\n                push(@characters,\
    \ $new_char);\n                $new_char = ord($char);\n            }\n      \
    \  }\n    }\n    push(@characters, $new_char);\n    foreach $char (@characters)\
    \ {\n        if ($char ne \" \") {\n            if ($new_char == ord($char)) {\n\
    \                $s3 += ord($char);\n            } else {\n                if\
    \ ($new_char < ord($char)) {\n                    $new_char = chr($new_char);\n\
    \                }\n                push(@characters, $new_char);\n          \
    \      $new_char = ord($char);\n            }\n        }\n    }\n    $new_word\
    \ = \"\";\n    foreach $word (split(/ /, $s)) {\n        foreach $char (split(//,\
    \ $word)) {\n            push(@characters, $char);\n        }\n    }\n    foreach\
    \ $char (@characters) {\n        if ($char ne \"\\n\") {\n            $new_word\
    \ .= $char;\n        } else {\n            $new_word .= \" \";\n        }\n  \
    \  }\n    return $new_word;\n}", "    my(@list);\n    my(@words);\n    while($s\
    \ =~ /(\\S+)/) {\n\tpush (@words,$1);\n    }\n    foreach my $w (@words) {\n\t\
    push (@list,ord($w));\n    }\n    my $n = scalar @list;\n    foreach my $i (0..$n-1)\
    \ {\n\tmy $o = $list[$i];\n\tunshift @list,$o;\n    }\n    $s;\n}\n</code>\n<|/\
    \ a tags=perl,string |>\n<| a |>\n<code>\nperl -E'say for sort {ord} split /\\\
    s/, shift' file\n</code>\n<code>\nperl -E'say for sort {ord $a} split /\\s/, shift'\
    \ file\n</code>\n<|/ a dscore=2 tags=perl,string |>\n<| c |>\nThe `ord` sub should\
    \ be written `sub ord { ord $a }` so that it can accept more than one argument\
    \ (which is what `split` will do).  This way, the sort doesn't need to be a callback\
    \ that expects one argument.\n<|/ c |>\n<| c |>\nI always forget about that possibility,\
    \ thanks! And yes, it would be better to write it like that (to not overwrite\
    \ an existing `ord` function).\n<|/ c |>\n<| a dscore=2 tags=perl,string |>\n\
    The following is a variation on drew's solution that does not use ord and split\
    \ but does rely on regexes instead.\n<code>\nuse strict;\nuse warnings;", "  \
    \  $s =~ s/[[:upper:]]+//g;\n    $s =~ s/[[:lower:]]+//g;\n    my @a = split('\
    \ ', $s);\n    my $n = 0;\n    my $w = '';\n    for (@a) {\n        $n += length($_);\n\
    \        next if $n <= 1;\n        my $x = $n / 2;\n        $w = substr($_, $x,\
    \ 1) . $w;\n        $n = $x - 1;\n    }\n    return $w . $w;\n}", "    $s =~ s/\\\
    s+/\\s+/g;\n    $s =~ s/(.)/$1./g;\n    $s =~ s/([a-zA-Z])/$1.$1./g;\n    $s =~\
    \ s/\\./\\\\./g;\n    $s =~ s/\\-/\\-/g;\n    $s =~ s/\\-\\-/\\-\\-/g;\n    $s\
    \ =~ s/\\-\\-\\-\\-/\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\//\\/\\-\\-\\\
    -\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-/\\\\\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\\
    -\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\\
    -\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\\
    -\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\\
    /\\-\\-\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\\
    -\\-\\-\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\\
    -\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\\
    -\\-\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\\
    -\\-\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\\
    -\\-/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\\
    -/g;\n    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n\
    \    $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n \
    \   $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n  \
    \  $s =~ s/\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\//\\/\\-\\-\\-\\-\\-\\-\\-/g;\n   \
    \ $s =~ s/\\-\\-\\-", "    my $i = scalar $s;\n    my @chars = split(//,$s);\n\
    \    foreach my $c (@chars) {\n        my $asci = (ord($c) + $i)%26;\n       \
    \ $s = substr($s,0,$i-1) . chr(ord('a') + $asci) . substr($s,$i+1,scalar $s);\n\
    \        $i = $i+1;\n    }\n    return $s;\n}\n</code>\nOutput:\n<code>\nHi\n\
    ehllo\nHello World!!!\n</code>\n<|/ a tags=perl,regex,string,arrays,split |>\n\
    <| c |>\nThis looks pretty good but it gives me an error: \"Use of uninitialized\
    \ value in concatenation (.) or string at anti_shuffle line 6, <STDIN> line 1.\"\
    \ on the split line.\n<|/ c |>\n<| c |>\nThe above code works for me. How did\
    \ you run this code?\n<|/ c |>\n<| c |>\nI run this on Windows and it gives me\
    \ this error. I thought it was a Perl problem but it's just straight Perl right?\
    \ I wrote it in TextPad and ran it with CPAN (cpanm antishuffle). I also tried\
    \ running it with CPAN module perlcritic and it returned this warning: Use of\
    \ uninitialized value in concatenation (.) or string at antishuffle line 6, <STDIN>\
    \ line 1.\n<|/ c |>\n<| c |>\nOh, I missed a space after `$s` on line 6. I wrote\
    \ it that way because I was trying to fix the error but didn't notice that there\
    \ was a space there. Oops.\n<|/ c |>\n<| a |>\n<code>", "    return join '', map\
    \ {\n        my $x = ord($_);\n        my $o = ord(\"A\") - $x;\n        my $r\
    \ = chr($o + $_);\n        $r if $o > 0;\n    } split /\\s+/, $s;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe code in the answer looks identical to the code in the question.\
    \ Does it even compile? Could you explain what `($_)` is doing and why it is necessary?\
    \ This is not Python, it's Perl.\n<|/ c |>\n<| c |>\nOops. Didn't realize that\
    \ this was written in Perl.\n<|/ c |>\n<| c |>\nI have fixed the syntax in the\
    \ question's code, so it should be clearer now\n<|/ c |>\n<| c |>\nYou might as\
    \ well write `my $r = $o > 0 ? chr($o + $_) : \"\";` in place of the `map` loop,\
    \ as it's clearer and faster\n<|/ c |>\n<| c |>\n: It also looks like you were\
    \ trying to fix the problem in the wrong place, which is why it wasn't working\
    \ as expected.\n<|/ c |>\n<| a |>\nThe correct way to reorder letters is to look\
    \ at what they are, and what they should actually be. In English, there are lots\
    \ of characters that aren't letters, and there are lots of letters that aren't\
    \ characters. So you need to decide what characters are \"letters\", and what\
    \ characters are \"characters\".\nPerl has a nifty routine called ord that converts\
    \ a character into its ASCII number. For example,\n<code>\nperl -E'say ord(\"\
    a\")'\n</code>\nprints 65. That's a character! But what about \"a\"?\n<code>\n\
    perl -E'say ord(\"a\") == 65'\n</code>\nprints 0. That's a letter!\nSo the job\
    \ of the program is to look at all the characters, and tell you what they should\
    \ be. Here's my solution:\n<code>\nuse strict;\nuse warnings;", "    $s =~ s/\\\
    s+/ /g;\n    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/a-z/A-Z/;\n    $s =~ tr/A-Za-z/A-Z/;\n\
    \    return $s;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt's not clear why this\
    \ was upvoted since it only gives \"Hi\" as the output. Other than that, it doesn't\
    \ do what the OP asks for (it's also not a standard shuffle algorithm). Also,\
    \ it's better to keep it all in one big regular expression.\n<|/ c |>\n<| c |>\n\
    It returns Hi because the order is defined within the regex. Not sure why you\
    \ down voted my answer. Its a valid way of solving the problem\n<|/ c |>\n<| c\
    \ |>\nThe only reason for down voting was because your code returns Hi for the\
    \ first line of the OP's expected output.\n<|/ c |>\n<| a dscore=0 |>\nI did it\
    \ using perl:\n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    \n\
    \    if (length $s == 0) {\n        $s;\n    } else {\n        my = map { chr\
    \ int ( ( $_ - 97 ) + 33 ) } split \" \", $s;\n        my = map { chr int ( (\
    \ $_ - 65 ) + 97 ) } split \"\", $s;\n        \n        my $i;\n        for ($i\
    \ = 0; $i < scalar @words; ++$i) {\n            my $word = substr @words, $i,\
    \ 1;\n            @words = map { $word . substr @words, $i, 1 } @new_words;\n\
    \        }\n        $s;\n    }\n}", "    my @new_words = split(/\\s+/, $s);\n\
    \    my $result = \"\";\n    my $prev_ascii = -1;\n    foreach my $new_word (@new_words)\
    \ {\n        my $ascii = ord(substr($new_word, 1));\n        if ($ascii < $prev_ascii)\
    \ {\n            $result .= $new_word;\n        }\n        $result .= substr($new_word,\
    \ 0, 1) . chr(ord($new_word) + 1);\n        $prev_ascii = $ascii;\n    }\n   \
    \ return $result;\n}", "    my %hash = map { $_, 1 };\n    my @keys;\n    my @chars;",
  "    my $str = \"\";\n    my = split /\\s+/, $s;\n    for (my $i = 0; $i < scalar(@words);\
    \ $i++) {\n        my $j = rand($i + 1);\n        $str .= $words[$i];\n      \
    \  $words[$i] = $words[$j];\n        $words[$j] = $words[$i];\n    }\n    $str;\n\
    }", "    $s =~ s/(\\s)/$1/g;\n    $s =~ s/ (\\s)/$1/g;\n    $s =~ s/ (?!\\s)/$&\
    \ $1 /g;\n    $s =~ s/\\s+/& /g;\n    $s =~ s/(\\S)/$1.$2/g;\n    $s =~ s/^([a-z])/$1./g;\n\
    \    $s =~ s/([a-z])/$1.$2/g;\n    $s =~ s/([^a-z])/$1 $2/g;\n    $s =~ s/\\(.\\\
    )/$1 $2/g;\n    $s =~ s/ (\\s)/$1/g;\n    $s =~ s/ (?!\\s)/$& $1 /g;\n    return\
    \ $s;\n}", "    $s =~ s/\\s+/-/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g;\n    $s =~ s/(\\\
    s)/$1$1/g;\n    $s =~ s/(\\s)/$1$1/g", "    $s =~ s/ (\\w+)/ $1 =~ tr/A-Za-z/n-za-mN-ZA-Mn-za-m/r\n\
    \          ? uc($1)\n          : uc($1) // $1;\n    return $s;\n}", "    my %hash\
    \ = map { (ord($_) => $_) } split(' ', $s);\n    my $new = '';\n    for my $word\
    \ (split(' ', $s)) {\n        my $i = 0;\n        for my $char (split(' ', $word))\
    \ {\n            $new = substr($new, $i, 1) . substr($hash{$char}, 0, 1);\n  \
    \          $i += 1;\n        }\n    }\n    return $new;\n}\n</code>\n<|/ a dscore=2\
    \ tags=perl,regex |>\n<| c |>\nThat is very impressive, thank you! I guess I would\
    \ have never been able to come up with that!\n<|/ c |>\n<| c |>\n`anti_shuffle('Hello\
    \ World!!!')` gives `Wld!eHlo!`\n<|/ c |>\n<| c |>\n`anti_shuffle('Hello World!!!')`\
    \ gives `!eHllo!`\n<|/ c |>\n<| c |>\nWhat does `my %hash = map { (ord($_) =>\
    \ $_) } split(' ', $s);` do? Does that create a new hash where each character\
    \ is the key and the character itself is the value? Thanks!\n<|/ c |>\n<| c |>\n\
    It creates an hash with the character as key, and the character itself as the\
    \ value. This way, if there are multiple characters with the same ASCII value,\
    \ the function will return a different result (just like a dictionary).\n<|/ c\
    \ |>\n<| a tags=perl,regex |>\nHere's a solution in pure Perl, that doesn't require\
    \ any modules, no preprocessing of input data, no extra data structures, no use\
    \ of substr (which is slower) and no extra variables. It uses one regex substitution\
    \ per word.\n<code>", "    return $s if $s eq '' or $s =~ /^\\s*$/;\n    my(@words);\n\
    \    my(@temp);\n    my($count, $i);\n    foreach $word (split /\\s+/, $s) {\n\
    \        push (@temp, $word);\n    }\n    foreach $word (@temp) {\n        $count++;\n\
    \        for ($i = 0; $i <  $count; $i++) {\n            push(@words, $temp[$i]\
    \ . substr($word, $i, 1));\n        }\n    }\n    return join(\" \",);\n}", " \
    \   $s =~ tr/A-Z/a-z/;\n    $s =~ tr/0-9/A-Z/;\n    return $s;\n}", '    return
    $s if length($s) == 0;', "    my @words = split /\\s+/, $s;\n    my $new_word\
    \ = \"\";\n    my $i = 0;\n    while (@words) {\n        if (@words > 1) {\n \
    \           $new_word = $words[$i] . ' ' . $words[$i+1];\n        } else {\n \
    \           $new_word = $words[$i];\n        }\n        $i++;\n        shift @words;\n\
    \        push @words, $new_word;\n    }\n    return join \" \", @words;\n}", " \
    \   $s =~ s/ ( (?:[^A-Za-z]+|[A-Za-z][^A-Za-z]+) ) /\n    $1\n    /ge;\n    return\
    \ $s;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks but your code doesn't work properly.\
    \  I used it to try and make a shuffle that doesn't put the characters in the\
    \ right order.  My code replaces all the non-alphabet characters with the character\
    \ before the first alphabet character (which is what happens when you do `sort\
    \ words`).  But this doesn't seem to work if you put a space at the beginning\
    \ of the word (since then it puts the space before the first alphabet character).\
    \  And you also need to do `sort words` on the non-alphabet characters of the\
    \ string, not the words in that string.\n<|/ c |>\n<| c |>\nYou said \"Ordered\
    \ version of string, is a string where all words (separated by space) are replaced\
    \ by a new word where all the characters arranged in ascending order based on\
    \ ascii value.\"\n<|/ c |>\n<| c |>\nThat was an easy fix for the space.  It didn't\
    \ work for the second point because I wasn't using `split ' '` before I did the\
    \ `map {lc}`.\n<|/ c |>\n<| c |>\nAlso, it's worth noting that your `anti_shuffle`\
    \ doesn't work properly if you have consecutive spaces in your input.  For example,\
    \ `\"I AM SO\"` becomes `\"I AM\"`.\n<|/ c |>\n<| a tags=perl,sorting |>\nHere\
    \ is a variant that uses List::Util:\n<code>\nuse strict;\nuse warnings;\nuse\
    \ List::Util qw(uniq);", "    $s =~ s/\\s+/\\n/;\n    $s =~ s/^\\s+|\\s+$//g;\n\
    \    $s =~ s/(\\w+)(\\s)(\\w)/$1$3\\n$2$4/g;\n    $s =~ s/(\\w)(\\s)(\\w+)/$1$3\\\
    n$2$4/g;\n    $s =~ s/(\\w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\n$5$6/g;\n   \
    \ $s =~ s/(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\n$5$6\\n$7$8/g;\n\
    \    $s =~ s/(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\\
    n$5$6\\n$7$8\\n$9$10/g;\n    $s =~ s/(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\\
    s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\n$5$6\\n$7$8\\n$9$10\\n$11$12/g;\n    $s =~ s/(\\\
    w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\\
    n$5$6\\n$7$8\\n$9$10\\n$11$12\\n$13$14/g;\n    $s =~ s/(\\w+)(\\s)(\\w+)(\\s)(\\\
    w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\\
    n$5$6\\n$7$8\\n$9$10\\n$11$12\\n$13$14\\n$15$16/g;\n    $s =~ s/(\\w+)(\\s)(\\\
    w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\w+)(\\s)(\\\
    w+)(\\s)(\\w+)(\\s)(\\w+)/$1$3\\n$2$4\\n$5$6\\n$7$8\\n$9$10\\n$11$12\\n$13$14",
  "    $s =~ s/( +)/$1 . \"\\n\"/eg;\n    $s =~ s/( )/ \"$1 \" /eg;\n    return $s;\n\
    }", "    my @words = split(/\\s/,$s);\n    my $last_word = '';\n    my @result\
    \ = ();\n    foreach my $word (@words) {\n        if($word ne $last_word) {\n\
    \            push(@result,$word);\n            $last_word = $word;\n        }\n\
    \        else {\n            $last_word .= substr($word,0,1);\n        }\n   \
    \ }\n    my $new_s = join(\" \",@result);\n    return $new_s;\n}", "    $s =~\
    \ s/(\\w+\\s+\\w+)/ my $new_word = $1; $new_word.unpack('C*'); /eg;\n    return\
    \ $s;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code fails on unicode strings.\
    \ Try it on (for example) this string: \u2021\u2020\u02C7\u2020\u0153\u2020\u0153\
    \u2020\u02C7\u2020\u02C7\u02C7\u2020\u02C7\u02C7\u2020\u0153\u2020\u2021\u2020\
    \u0153\u2020\u2021\u2020\u0153\u2020\u0153\u2020\u02C7\u2020\u02C7\u02C7\u2020\
    \u2020\u02C7\u02C7\u2020\u02C7\u02C7\u2020\u02C7\u02C7\u2020\u2020\u0153\u2020\
    \u02C7\u02C7\u02C7\u2020\u02C7\u02C7\u02C7\u02C7\u2020\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\
    \u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7\u02C7", "    my @arr = split\
    \ /\\s+/, $s;\n    my @newArr = ();\n    my @wordArr = ();\n    my $tmp;\n   \
    \ my $order;\n    for my $char (@arr) {\n        $tmp = $char;\n        $char\
    \ = \"A\" . $char . \"Z\";\n        $order = $char;\n        while (length($tmp)\
    \ > 1) {\n            my $sub = substr($tmp, -1);\n            substr($tmp, 0,\
    \ -1) = substr($tmp, 0, -1);\n            $order = substr($order, -1) . $sub;\n\
    \        }\n        push @wordArr, $order;\n    }\n    my $new = \"\";\n    for\
    \ my $word (@wordArr) {\n        my $i = 0;\n        for my $char (@arr) {\n \
    \           $i++;\n            if ($char eq $word) {\n                $new .=\
    \ $wordArr[$i];\n                last;\n            }\n        }\n    }\n    return\
    \ $new;\n}", "    my(@order);\n    my($ordering, $char, $n);\n    \n    # Scan\
    \ sentence and collect words and blanks\n    foreach $char (split / /, $s) {\n\
    \        if ($char =~ /^\\s/) {\n            push @order, \" \";\n        } else\
    \ {\n            push @order, $char;\n        }\n    }\n    \n    # Now sort the\
    \ letters, rebuilding the string\n    @order = sort {$a cmp $b} @order;\n    \n\
    \    # Now build the final string\n    foreach $ordering (@order) {\n        foreach\
    \ $n (1 .. length($ordering)) {\n            $char = $ordering[$n];\n        \
    \    if ($char != ' ') {\n                $s .= $char;\n            }\n      \
    \  }\n    }\n    return $s;\n}", "    my $len = length($s);\n    my $i = 1;\n\
    \    my $result = '';\n    while($i <= $len) {\n        $result .= substr($s,\
    \ $i, 1);\n        $result .= substr($s, $i, 1);\n        $i++;\n    }\n    return\
    \ $result;\n}", "    my @s;\n    my $i;\n    my $len = length($s);\n    my $len\
    \ = length($s[0]);\n    for ($i = 0; $i < $len; $i++) {\n        my $c = substr($s,\
    \ $i, 1);\n        $c =~ s/[^a-zA-Z]/-/g;\n        $c = 'a' . $c;\n        push(@s,\
    \ $c);\n    }\n    for ($i = 0; $i < $len; $i++) {\n        my $c = substr($s,\
    \ $i, 1);\n        $c =~ s/-/a/g;\n        push(@s, $c);\n    }\n    $s = join(\"\
    \", @s);\n    return $s;\n}", "    my @words = split /\\s+/, $s;\n    my (@new_words);\n\
    \    my $i = 0;\n    my $last_char = \"\";\n    foreach my $word (@words) {\n\
    \        # Sort alphabetically and replace by original order\n        my $next_char\
    \ = $word[$i] cmp $last_char ? $word[$i] : chr(65 + $word[$i] - $last_char);\n\
    \        $new_words[$i++] = $next_char;\n        $last_char = $next_char;\n  \
    \  }\n    return join \" \", @new_words;\n}", "    my @new_chars = ();\n    my\
    \ $i = 0;\n    my $j = 0;\n    while(1) {\n        if($i%2 != 0) {\n         \
    \   $new_chars[$j] = $s->[$i];\n            $i++;\n            $j++;\n       \
    \ }\n        else {\n            $j++;\n        }\n        if($i == scalar @$s)\
    \ {\n            $i = 0;\n            $j = 0;\n        }\n    }\n    push @$s,\
    \ @new_chars;\n    return $s;\n}\n</code>\n<|/ a |>\n<| c |>\nI believe this should\
    \ be `$new_chars[$j] = $s->[$i];`\n<|/ c |>\n<| c |>\nYou're right - I did this\
    \ while debugging and forgot to change it back\n<|/ c |>\n<| c |>\n`anti_shuffle(\"\
    hello\")` returns `ehllo`, not `elhlo`\n<|/ c |>\n<| a |>\nOne way is to sort\
    \ the characters in each string by ASCII value, and re-arrange them in the sorted\
    \ array. \n<code>\nmy $string = \"hello\";", "    $s =~ s/(\\w+)/join('$a ',sort(\"\
    $a\",$_,ascend),' ')/ge;\n    return $s;\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=perl dscore=1 |>\nThis is very similar to the other solutions posted. However,\
    \ the code could be improved a bit for readability and efficiency.\n<code>", " \
    \   $s =~ s/(^|\\s)(\\w{1,})($|\\s)/$1$2$3$4$5/g;\n    $s =~ s/(^|\\s)(\\w{1,})($|\\\
    s)/$1$2$3$4$5$6/g;\n    return $s;\n}", "    $s =~ tr/!\\+/!!/;\n    $s =~ tr/\\\
    +/!/;\n    $s =~ tr/\\s+//;\n    $s =~ s/\\W//g;\n    return $s;\n}", "    $s\
    \ =~ s/\\b([A-Za-z0-9]+)\\b/\n        join \"\",\n            map { (ord($_) <=>\
    \ ord($s)) <=> $_ } split(' ', $1);\n    return $s;\n}", "    my(@words) = ();\n\
    \    while($s) {\n\tpush(@words,$1) if $s =~ /^\\s*(\\S+)\\s+/;\n\t$s = $1 =~\
    \ s/\\s+/ /;\n    }\n    my(@sorted_words) = ();\n    for(@words) {\n\tpush(@sorted_words,$1)\
    \ if $1 !~ /\\S/;\n    }\n    return join(\" \",@sorted_words);\n}", "    $s =~\
    \ tr/a-zA-Z0-9\\s[\\!\\?]+/a-zA-Z0-9\\s/;\n    $s =~ s/\\s+/ /g;\n    $s =~ tr/!\\\
    ?/\\?/g;\n    $s =~ tr/\\.\\.\\.//g;\n    $s =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n\
    \    $s =~ s/\\s/,/g;\n    $s =~ s/\\s/\\./g;\n    return $s;\n}", "    return\
    \ $s if !defined $s;\n    # Remove repeated spaces\n    $s =~ s/\\s+/ /g;\n  \
    \  my @words = split /\\s+/, $s;\n    my @sorted_words = ();\n    my $last_word;\n\
    \    my $i;", "    my @words = split(/ /, $s);\n    $_ = join \" \", map {\n \
    \       $w{$_}++\n            ? $w{$_}\n            : substr($_, 0, 0, sort(map\
    \ {\n                uc($a)\n            }\n             split(' ', $_)));\n \
    \   } @words;\n    return $s;\n}", "    # split the string\n    my(@words) = split\
    \ /\\s+/, $s;\n    my(@new_words) = ();\n    my(@new_word);\n    # traverse the\
    \ words\n    foreach my $word (@words) {\n        foreach my $char (split('',\
    \ $word)) {\n            my $ascii = ord ($char);\n            $new_word .= $char;\n\
    \            if ($ascii < $ascii) {\n                $ascii++;\n            }\
    \ else {\n                $ascii++;\n            }\n            $new_word .= $char;\n\
    \        }\n        push(@new_words, $new_word);\n        $new_word = \"\";\n\
    \    }\n    $s;\n}\n</code>\n<|/ a tags=perl,regex,string dscore=3 |>\n<| c |>\n\
    This doesn't work correctly in all cases, as it does not check punctuation in\
    \ order as `tr` does.\n<|/ c |>\n<| c |>\nThis is true but it's easily fixable:\
    \ just replace all punctuation with a space.\n<|/ c |>\n<| c |>\n: No it isn't.\
    \ `tr` replaces characters, but it cannot detect if two characters are adjacent\
    \ or not.\n<|/ c |>\n<| c |>\n- you're right - I was thinking of `tr`'s `/r` flag,\
    \ and it won't work - but I missed the original post and was thinking of the `s/`\
    \ and `tr` commands themselves.\n<|/ c |>\n<| a dscore=1 |>\nIn addition to the\
    \ other solutions, you could also use a regex to split your string into words,\
    \ then rearrange them with map (or list context).\n<code>\nuse List::Util qw(\
    \ uniq );", "    my(@words) = split ' ', $s;\n    my($new_word);", '    my $re
    = qr{(^|\n)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\s)(\w)(\',
  "    my(@words);\n    my($ordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordordord",
  "    my(@new_s) = ();\n    my($i=0,$j=-1);\n    while( ($i=index($s,\" \",$i+1))\
    \ != -1 ) {\n\t$j++;\n\tpush(@new_s,substr($s,$i,1));\n\tpush(@new_s,substr($s,$i+1,1));\n\
    \tpush(@new_s,substr($s,0,$i));\n\tpush(@new_s,substr($s,$i+1,1));\n\tsplice(@new_s,$i,1);\n\
    \t$i=$j;\n    }\n    return join(\" \",@new_s);\n}", "    $s =~ s/\\b(\\w*)\\\
    s+(\\w*)\\b/$2$1/;\n    $s =~ s/\\b(\\w*)\\b\\s+(\\w*)\\b/$2$1/;\n    $s =~ s/\\\
    b(\\w*)\\b/$1/;\n    $s =~ s/\\s+/ /g;\n    $s =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n\
    \    $s =~ s/^\\s+//;\n    $s =~ s/\\b//g;\n    return $s;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=perl,string,sorting,substr,split dscore=0 |>\nThis is\
    \ just an alternative approach of Sobrique's answer, which I believe is better,\
    \ but it's just an alternative and may not be as efficient as it could be.\n<code>\n\
    use strict;\nuse warnings;", "    my @words = split(/\\s/,$s);\n    $s = \"\"\
    ;\n    foreach my $w (@words) {\n        $s .= $w . \"_\" . ord($w);\n    }\n\
    \    $s =~ s/\\b_(\\p{L}+)_/$1/g;\n    $s =~ s/_([a-z]\\p{L}+)_/$1/g;\n    return\
    \ $s;\n}\n</code>\n<|/ a |>\n<| c |>\nThis works great on short strings but when\
    \ running it against large amounts of data I'm getting memory errors and I suspect\
    \ that my system is running out of memory before it can finish.  Is there another\
    \ way to write this without using recursion?\n<|/ c |>\n<| c |>\n: It sounds like\
    \ your system is out of memory before it can finish. How large are your files?\n\
    <|/ c |>\n<| c |>\nThe files are around 50K each and I'm on a MacBook Pro (1,5\
    \ Ghz Intel Core i5).\n<|/ c |>\n<| c |>\n: I don't have experience with memory\
    \ usage on Macbooks, but I'm guessing 50K of data isn't enough. You may want to\
    \ look into splitting up the data, then processing each piece at a time. Try it\
    \ on a smaller example with less data.\n<|/ c |>\n<| a dscore=3 tags=perl,substitution,replace,string,algorithm\
    \ |>\nHere is a version that uses regular expressions and a hash slice, similar\
    \ to what has been suggested in other answers.\n<code>\nuse strict;\nuse warnings;",
  "    my(@words) = split /\\s+/, $s;\n    my($new_word);\n    foreach my $word (@words)\
    \ {\n        my $length = length($word);\n        my $chars = $length - 1;\n \
    \       my($letter_order);\n        $letter_order = \"A\" x $chars;\n        my\
    \ $letter = substr($letter_order, 0, $chars);\n        my $new_letter = $letter\
    \ . substr($letter_order, $chars);\n        $new_word .= $new_letter;\n    }\n\
    \    return $new_word;\n}", "    my @list = split (/\\s+/, $s);\n    my $out =\
    \ '';\n    my $start = 1;\n    foreach my $word(@list) {\n        $out .= (length($word)\
    \ == 1 ? $word : substr $word, 0, $start);\n        $start += length($word) +\
    \ 1;\n    }\n    return $out;\n}", "    # use map to create an array of letters\
    \ and numbers and sort them\n    my = map { $_ eq ' ' ? \"\" : chr($_) } (split\
    \ /\\s+/, $s);\n    # use map to create an array of letters and numbers and sort\
    \ them\n    my = map { $_ eq ' ' ? \"\\\\ \" : chr($_) } (split /\\s+/, $s);\n\
    \    my $n = 0;\n    $s =~ s/([$letters])/${letters[$n]++}/ge;\n    return $s;\n\
    }", "    $s =~ s/\\b([a-zA-Z])\\s(\\b[a-zA-Z])|(\\b[a-zA-Z])\\s(\\b[a-zA-Z])/\n\
    \      $1 ^ $2 ? $1 . $3 . $2 : $1 . $3 . $2\n    /ge;\n    return $s;\n}", " \
    \   my($ord, $word, $ord1);\n    my(@ords);", "    $s =~ s/\\s+/ /;\n    my @words\
    \ = split(/\\s+/, $s);\n    my @sorted = sort { $a cmp $b } @words;\n    $s =~\
    \ s/\\s+/ / unless @sorted;\n    $s =~ s/\\s+/ /;\n    join(\" \", @sorted);\n\
    }", "    my @words =\n        split ' ', $s\n    ;\n    my $new_word = \"\";\n\
    \    my $i = 0;\n    foreach my $word (@words) {\n        $word =~ tr/a-zA-Z/n-za-mN-ZA-M/;\n\
    \        $new_word .= $word;\n        last if $i == (@words - 1);\n        $new_word\
    \ .= \" \";\n        $i++;\n    }\n    return $new_word;\n}", "    my $words =\
    \ split(/ /, $s);\n    my $new_word = \"\";\n    my $prev = \"\";\n    for (my\
    \ $i = 0; $i <= $#words; $i++) {\n        my $ch = substr($words[$i], $i);\n \
    \       if ($prev ne $ch) {\n            $new_word .= $ch;\n        }\n      \
    \  $prev = $ch;\n    }\n    return $new_word;\n}\n</code>\n<|/ a tags=perl,sorting,list\
    \ |>\n<| a dscore=1 tags=perl,sorting,list |>\n<code>\n$string = \"Hello, World\"\
    ;\nmy = split /,/, $string;\n$string = \"\";\nforeach $word (@words) {\n   $string\
    \ .= $word;\n}\nmy $length = length($string);\n$string =~ s/^\\s*//;\nforeach\
    \ $i (0..$length) {\n   $string =~ s/$i\\///g;\n}\n$string =~ s/\\s+\\z//;\nprint\
    \ ($string);\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's a quick one that does\
    \ it in place:\n<code>\nuse strict;\nuse warnings;\nuse 5.010;", "    $s =~ s/\
    \ (\\w)/ $anti_letter_sort($1)/ge;\n    return $s;\n}", "    $s =~ s/ /\\b/g;\
    \ # replace spaces with word boundary markers\n    $s =~ s/\\b[a-zA-Z]//g; # replace\
    \ alphabets with word boundary markers\n    $s =~ s/\\b\\W//g; # replace non-alphanumeric\
    \ with a blank\n    $s =~ s/^\\s+|\\s+$//g; # remove beginning and end of line\n\
    \    return lc($s); # lower case letters before return\n}", "    $s =~ s/(.*)(\\\
    s+)(\\w+)$/$3 $2 $1/;\n    $s;\n}", "    my @tokens = split(\" \", $s);\n    my\
    \ $result = \"\";\n    foreach my $word (@tokens) {\n        my @chars = split(\"\
    \", $word);\n        foreach my $char (@chars) {\n            $char++;\n     \
    \       $char++ if ($char <= 25);\n            $char++ if ($char <= 51);\n   \
    \         $char++ if ($char <= 61);\n        }\n        push (@chars, join(\"\"\
    , $chars));\n    }\n    $result = join(\" \", @tokens);\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 tags=perl,regex,arrays |>\n<| c |>\nThanks. I was actually\
    \ looking for something more efficient than this. Anyways thanks again\n<|/ c\
    \ |>\n<| c |>\n, if you want a more efficient solution then you need to tell us\
    \ how you define \"efficient\". If you want something that runs quickly, then\
    \ it's probably okay to do it this way.\n<|/ c |>\n<| c |>\n, if you are looking\
    \ for something more efficient than this, I suggest that you ask a new question\
    \ about what \"efficient\" means.\n<|/ c |>\n<| c |>\n, I have added an answer\
    \ that does not use Perl regular expressions, but uses a different algorithm.\n\
    <|/ c |>\n<| a dscore=1 tags=perl,regex,arrays |>\nAnother option using join:\n\
    <code>\nmy $text = 'Hello World!!!';\n$text =~ s/\\b(\\w{1})\\b/$1\\W/g;\nprint\
    \ join '', split ' ', $text;\n</code>\noutput\n<code>\nehllo !!!Wdlor\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\n$a = 'Hello World!!!';\n$a =~ s/\\b(\\w{1})\\\
    b/$1\\W/g;\nprint join('',split ' ',$a);\n</code>\n<|/ a tags=perl,regex,arrays\
    \ |>\n<| c |>\nThanks. I was actually looking for something more efficient than\
    \ this. Anyways thanks again\n<|/ c |>\n<| c |>\n, do you mean you want to do\
    \ something with the string? Do you want the result to be 'ehllo !!!Wdlor'?\n\
    <|/ c |>\n<| c |>\nyes, I want the result to be 'ehllo !!!Wdlor'\n<|/ c |>\n<|\
    \ a dscore=0 tags=perl,regex,arrays |>\nJust for fun, here's a solution that uses\
    \ negative lookaheads:\n<code>\nuse strict;\n", "    my @chars = split(//,$s);\n\
    \    \n    foreach my $idx (0..scalar(@chars-1)){\n        my $swap = $chars[$idx];\n\
    \        my $char = $chars[$idx+1];\n        $chars[$idx] = $chars[$idx+1];\n\
    \        $chars[$idx+1] = $swap;\n    }\n    return join('',@chars);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=sorting,perl |>\nI thought that maybe this would\
    \ work, but it has some problems with punctuation:\n<code>\nuse strict;\nuse warnings;",
  "    $s =~ s/([^\\s]+)\\s+([^\\s]+)/$1 $2 /g;\n    $s =~ s/([^\\s]+)\\s+([^\\s]+)/$2\
    \ $1 /g;\n    $s =~ s/([^\\s]+)\\s+([^\\s]+)/$2 $1 /g;\n    return $s;\n}", " \
    \   $s =~ s/ ( (?! \\1 ) ) ([A-Za-z0-9]) ( (?! \\1 ) ) /xoy\n              $1x$2y$3x$4y;\n\
    \    return $s;\n}", "    my $len = length($s);\n    my $word = \"\";\n    my\
    \ $i;\n    for ($i = 0 ; $i < $len ; $i++) {\n        if ($s[$i] eq \" \") {\n\
    \            $s[$i] = $word;\n            $word = \"\";\n        }\n        else\
    \ {\n            $word .= $s[$i];\n        }\n    }\n    $word;\n}", "    my($i,\
    \ $j, $word, $char);\n    $s =~ tr/ //d;\n    while($s) {\n        $word = $s\
    \ =~ s/([a-zA-Z])/ $1 /egi;\n        $char = $s =~ s/([a-zA-Z0-9])/ $1 /egi;\n\
    \        $i++;\n        $s =~ s/\\<$word\\>/$char$i$char/$gi;\n        $s =~ s/\\\
    <$char\\>/$word$i$char/$gi;\n    }\n    return $s;\n}\n</code>\nThis code will\
    \ do what you want except that it is case sensitive. You may want to add some\
    \ cases to cover the case that the word is at the beginning or the end of the\
    \ string. I hope that helps. You can find the code here:\nhttps://gist.github.com/4192525\n\
    <|/ a |>\n<| a dscore=0 tags=perl |>\nHere's a solution using Algorithm::Combinatorics\
    \ which can be installed with cpanm Algorithm::Combinatorics:\n<code>\nuse strict;\n\
    use warnings;\nuse Algorithm::Combinatorics qw/ combinations /;", "    \n    #\
    \ Find the first non letter character.\n    my $i;\n    my $first_non_letter;\n\
    \    $first_non_letter = index( $s, '.' );\n    $first_non_letter -= 1 if length(\
    \ $s ) < 2;\n    \n    # Remove all the non letter characters from $s.\n    $s\
    \ =~ s/([^A-Za-z])//g;\n    \n    # Now sort the remaining string.\n    $s = sort\
    \ { $a cmp $b } split /\\s+/, $s;\n    \n    # Now add the non letter characters\
    \ back at the start of each word.\n    $s =~ s/^(.)([^A-Za-z])/$1$2$1/;\n    \n\
    \    # Add the non letter characters back at the end of each word.\n    $s =~\
    \ s/([^A-Za-z])(.)/$1$2$1/;\n    \n    # Add the non letter characters at the\
    \ start of the sentence.\n    $s =~ s/^/${first_non_letter}/g;\n    \n    return\
    \ $s;\n}", "    my @words = split(\" \", $s);\n    return $s;\n}", "    my $sorted_words\
    \ = ();\n    my $new_word = \"\";\n    for my $word (split / /, $s) {\n      \
    \  my $ord = $word =~ tr/A-Za-z//cd;\n        my $rev = $ord <=> $word;\n    \
    \    if ($rev > 0) {\n            push(@$sorted_words, $word);\n            $new_word\
    \ .= $word;\n        } else {\n            my $rand_idx;\n            my $len\
    \ = scalar @$sorted_words;\n            if ($len == 0 || $rand_idx == $len - 1)\
    \ {\n                $rand_idx = 0;\n            } else {\n                $rand_idx\
    \ = int(rand(@$sorted_words));\n            }\n            $new_word .= $sorted_words->[$rand_idx];\n\
    \            splice(@$sorted_words, $rand_idx, 1);\n        }\n    }\n    return\
    \ $new_word;\n}", "    my(@words);\n    my($k);\n    my($i);\n    my($j);\n  \
    \  my($n);", "    $s =~ s/[[:upper:]]/[[:lower:]]/g;\n    $s =~ s/[[:space:]]/\
    \ /g;\n    return $s;\n}\n</code>\n<|/ a dscore=2 tags=shuffle,perl,regex,arrays\
    \ |>\n<| c |>\nHmm. Strange, that code doesn't work for me. Maybe you tested your\
    \ code on another machine, or some difference between my code and yours is hidden.\
    \ Anyway, thank you for your answer. I've learnt something new with it.\n<|/ c\
    \ |>\n<| c |>\nI tested it on my machine, but I forgot to replace `@str` with\
    \ `$s`, and I used `perl -E 'say for'`, not `perl -E 'print'`, sorry\n<|/ c |>\n\
    <| a |>\n<code>\nuse Algorithm::Combinatorics qw(combinations);\nuse strict;\n\
    use warnings;", "    $s =~ s/(\\S+)|\\s(\\S+)|(\\S+)/ join '', map { $_ } $1,\
    \ $2, $3\n      ;\n    return $s;\n}", "    $s =~ s/(?<!\\s)([^\\s]+)(\\s+)(\\\
    s+(?!\\s))/$1$2$3/g;\n    return $s;\n}", "    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/!?.,;:\\\
    -@\\[\\]\\(\\)\\{\\}<>\\/\\_\\`~]/_/;\n    return $s;\n}", "    \n    # $s =~\
    \ s/(\\w+)/map {ord($_) - ord('a') + 1} split /\\s+/, $1;\n    # $s =~ s/\\s+/-/g;\n\
    \    # $s =~ s/-{2,}/-/g;\n    # $s =~ s/-/-$&-/;\n    # $s =~ s/^\\-//;\n   \
    \ # $s =~ s/-$//;\n    # $s =~ s/-/-$&-/;\n    # $s =~ s/(\\w+)/map {ord($_) -\
    \ ord('a') + 1} split /\\s+/, $1;\n    # $s =~ s/\\s+/-/g;\n    # $s =~ s/-{2,}/-/g;\n\
    \    # $s =~ s/-/-$&-/;\n    # $s =~ s/^\\-//;\n    # $s =~ s/-$//;\n    # $s\
    \ =~ s/-/-$&-/;\n    # $s =~ s/(\\w+)/map {ord($_) - ord('a') + 1} split /\\s+/,\
    \ $1;\n    # $s =~ s/\\s+/-/g;\n    # $s =~ s/-{2,}/-/g;\n    # $s =~ s/-/-$&-/;\n\
    \    # $s =~ s/^\\-//;\n    # $s =~ s/-$//;\n    # $s =~ s/-/-$&-/;\n    # $s\
    \ =~ s/(\\w+)/map {ord($_) - ord('a') + 1} split /\\s+/, $1;\n    # $s =~ s/\\\
    s+/-/g;\n    # $s =~ s/-{2,}/-/g;\n    # $s =~ s/-/-$&-/;\n    # $s =~ s/^\\-//;\n\
    \    # $s =~ s/-$//;\n    # $s =~ s/-/-$&-/;\n    # $s =~ s/(\\w+)/map {ord($_)\
    \ - ord('a') + 1} split /\\s+/, $1;\n    # $s =~ s/\\s+/-/g;\n    # $s =~ s/-{2,}/-/g;\n\
    \    # $s =~ s/-/-$&-/;\n    # $s =~ s/^\\-//;\n    # $s =~ s/-$//;\n    # $s\
    \ =~ s/-/-$&-/;\n    # $s =~ s/(\\w+)/map {ord($_) - ord('a') + 1} split /\\s+/,\
    \ $1;\n", "    $s =~ s/(?<=\\s)(\\S)\\s(?=\\s)/$2$1/gi;\n    $s;\n}", "    my\
    \ @arr = split(\" \", $s);\n    my $first_letter = substr($arr[0], 0, 1);\n  \
    \  my $rest = '';\n    $rest .= substr($arr[0], 1);\n    for (my $i = 1; $i <=\
    \ scalar @arr; $i++) {\n        my $c = substr($arr[$i], 0, 1);\n        my $rest\
    \ = '';\n        $rest .= substr($arr[$i], 1);\n        my $k = ord($c) - ord($first_letter);\n\
    \        if ($k >= 0) {\n            my $tmp = $arr[$i];\n            $arr[$i]\
    \ = $arr[$k];\n            $arr[$k] = $tmp;\n        }\n    }\n    return join('\
    \ ', @arr);\n}", "    chomp($s);\n    my = split(/ /, $s);\n    $s = \"\";\n \
    \   $_ = $s[0];\n    foreach my $i (0 .. @list-1) {\n        my $j = $i;\n   \
    \     while($j > 0) {\n            my $r = \"$list[$j-1]\";\n            $s =~\
    \ s/$r//g;\n            $j--;\n        }\n    }\n    $s;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you for showing me the use of $_. I wasn't aware of that.\n\
    <|/ c |>\n<| a |>\nUse the following code :\n<code>", '    $s =~ s/( \w)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)(
    \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( \w*)( ', "    $s =~\
    \ s/(\\s)/\\U$1/;\n    $s =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n    $s =~ s/\\\
    s(\\w)/\\u$1/;\n    return $s;\n}", "    my @a = split /\\s+/, $s;\n    @a = sort\
    \ { length($b) <=> length($a) } @a;\n    return join \" \", @a;\n}\n</code>\n\
    <|/ a dscore=4 tags=perl |>\n<| c |>\nThanks for your answer! I've tried your\
    \ script and I think it works, but I get this error when I try to run it on my\
    \ test script: `Name \"main::anti_shuffle\" used only once: possible typo at anti_shuffle.pl\
    \ line 2.\nName \"main::anti_shuffle\" used only once: possible typo at anti_shuffle.pl\
    \ line 13.\n`\n<|/ c |>\n<| c |>\nSorry I forgot to mention the importing at the\
    \ begining of the file. Updated now.\n<|/ c |>\n<| c |>\n`my($s) = @_;` should\
    \ be `my(@s) = @_;`. Otherwise `$s` will be undefined.\n<|/ c |>\n<| c |>\nAlso,\
    \ `use Sort::Key qw(sort_by_keys);` needs to be called at the top of your program.\
    \ [See here](https://metacpan.org/pod/Sort::Key) for more information.\n<|/ c\
    \ |>\n<| c |>\n`my($s) = @_;` should only be `my(@s) = @_;` - otherwise `$s` will\
    \ be undefined.\n<|/ c |>\n<| a dscore=4 |>\nA simple way to do this with a single\
    \ pass through the string:\n<code>\nuse strict;\nuse warnings;", "    # Split\
    \ string into array of words and space\n    my(@words) = split / /, $s;\n    #\
    \ Iterate through each word and sort based on ascii value\n    # Sorting based\
    \ on ascii value ensure that space is at last\n    for(my $i=0; $i<@words; ++$i)\
    \ {\n        for(my $j=$i; $j<@words; ++$j) {\n            my $a = ord(substr($words[$i],\
    \ 0, 1));\n            my $b = ord(substr($words[$j], 0, 1));\n            if($a\
    \ <=> $b) {\n                my $temp = substr($words[$i], 0, 1);\n          \
    \      substr($words[$i], 0, 1) = substr($words[$j], 0, 1);\n                substr($words[$j],\
    \ 0, 1) = $temp;\n            }\n        }\n    }\n    # Join all words back together\n\
    \    join(' ', @words);\n}", "    my $word;\n    my %hash = map { $_ => 1 };\n\
    \    $s = $1 while $s =~ /( \\w+(?: \\w+)*\\b )/g;\n    while ($s =~ /( \\w+(?:\
    \ \\w+)*\\b )/g) {\n        my $word = $1;\n        $word =~ s/^\\s+//;\n    \
    \    $word =~ s/\\s+$//;\n        $word =~ s/\\b\\B\\s+/-/g;\n        $word =~\
    \ s/\\b\\B\\b//g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\\
    B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n   \
    \     $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word\
    \ =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\\
    B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n   \
    \     $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word\
    \ =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\\
    B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n   \
    \     $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word\
    \ =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\\
    B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n   \
    \     $word =~ s/-\\B\\B/-/g;\n        $word =~ s/-\\B\\B/-/g;\n        $", " \
    \   $s = ~s/ ([a-z]+) (\\w+)/ $2 eq $1 ? lcfirst $1 : lc $1 eq $1 ? uc($1) : uc($1)\
    \ eq $1 ? lcfirst $1 : $1 eq $1 ? uc($1) : $1/egx;\n    $s;\n}", "    my @chars\
    \ = split(//,$s);\n    my @shuffled;\n    my $i = 0;\n    while(scalar @chars\
    \ > 0) {\n        my $rand;\n        $rand = int rand(scalar @chars);\n      \
    \  push(@shuffled,$chars[$rand]);\n        splice(@chars,$rand,1);\n    }\n  \
    \  return join('',@shuffled);\n}", "    my $words = $s =~ /[^ \\w]+/g;\n    my\
    \ @words;\n    foreach(@$words) {\n        my $ord = ord(substr($_, 0, 1));\n\
    \        push(@words, $ord <= 255 ? substr($_, 1) : chr(ord($_) ^ 255));\n   \
    \ }\n    join(\" \", @words);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    Your problem is that you are trying to use a regex pattern to match a string.\
    \ Try matching on words and sorting by length. There are several ways to do this,\
    \ but here is one:\n<code>\nuse strict;\nuse warnings;", "    return $s if $s\
    \ eq '';", "    my(@words);\n    foreach my $w (split /\\s+/, $s) {\n        next\
    \ if $w eq '';\n        push @words, $w;\n    }\n    foreach my $w (@words) {\n\
    \        my $k = ord(substr($w, 0, 1));\n        my @c = @{$w};\n        foreach\
    \ (@words) {\n            last if $_ eq $w;\n            next if ord($_) < $k;\n\
    \            $k = ord($_);\n            @c = map{$_ - $k}@c;\n        }\n    \
    \    $w = join \"\", @c;\n    }\n    return $s;\n}\n</code>\n<|/ a dscore=2 tags=perl,regex\
    \ |>\n<| a dscore=1 |>\nIf you have the string in a variable:\n<code>\n$string\
    \ = \"Hello World\";\n</code>\nYou can replace the characters as follows:\n<code>\n\
    $string =~ s/[Hh]/\\e[?9c/;\n$string =~ s/[Oo]/\\e[?9cOo/;\n$string =~ s/[Ll]/\\\
    e[?9cl/;\n$string =~ s/[Ll]/\\e[?9cl/;\n$string =~ s/[Rr]/\\e[?9cr/;\n$string\
    \ =~ s/[Dd]/\\e[?9cd/;\n</code>\n<|/ a tags=perl,regex |>\n<| a |>\n<code>\nmy\
    \ $string = q(\"Hello World!\");\n</code>\nThe following Perl substitutions change\
    \ the content of $string as requested.\n<code>\n$string =~ s/[Hh]/\\033[?9c/;\n\
    $string =~ s/[Oo]/\\033[?9cOo/;\n$string =~ s/[Ll]/\\033[?9cl/;\n$string =~ s/[Ll]/\\\
    033[?9cl/;\n$string =~ s/[Rr]/\\033[?9cr/;\n$string =~ s/[Dd]/\\033[?9cd/;", " \
    \   $s =~ s/\\s(?=[^a-z])/-/g;\n    $s =~ s/\\s([?!a-z])/$1/;\n    $s =~ s/-$/-/;\n\
    \    return $s;\n}", "    $s =~ s/\\s*(\\S+)\\s*/ $1 /sg;\n    return $s;\n}",
  "    return $s if $s;\n    $s = \"\";\n    my $i = ord('a');\n    my $j = ord('z');\n\
    \    while ($i) {\n        $j -= 1 if ($j < ord('a'));\n        $s = $i . $s .\
    \ $j;\n        $i -= 1 if ($i > ord('z'));\n        $j = ord('a');\n    }\n  \
    \  return $s;\n}", "    my $ans = $s;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/\
    \ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans\
    \ =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n\
    \    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~\
    \ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n\
    \    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~\
    \ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n\
    \    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~\
    \ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n\
    \    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~\
    \ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n\
    \    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~\
    \ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n\
    \    $ans =~ s/ /~/g;\n    $ans =~ s/~/ /g;\n    $ans =~ s/ /~/g;\n    $ans =~\
    \ s/~/ /g;\n    $", "    $s =~ s/ (?:[A-Za-z]{2,}) ([A-Za-z]) /$1 $2/g;\n    $s\
    \ =~ s/ (?:[A-Za-z]{2,}) ([A-Za-z]) /$1$2/g;\n    $s =~ s/ (?:[A-Za-z]{2,}) ([A-Za-z])\
    \ /$1 $2/g;\n    return $s;\n}", "    my(@words);\n    my($i,$j);", "    return\
    \ $s unless length($s);\n    my %hash;\n    map { $hash{$_} = 1; } split ' ',\
    \ $s;\n    $hash{' '} = $hash{' '};\n    $hash{' '} = \"_\" x length($hash{' '});\n\
    \    return map { $hash{$_}; $_ } sort keys %hash;\n}", "    $s =~ s/ ([^ ]+)\
    \ (?!\\S)/ \\L$1/g;\n    $s =~ s/ \\L / /g;\n    return $s;\n}\n</code>\n<|/ a\
    \ dscore=1 tags=perl,sorting,perl-module |>\n<| c |>\nThat is really cool. Never\
    \ heard of \\L. Thanks.\n<|/ c |>\n<| c |>\n: It's an alias for `\\L` (lower-case\
    \ letter).\n<|/ c |>\n<| a dscore=1 tags=perl,sorting,perl-module |>\nOne way\
    \ would be to insert an extra space before punctuation characters, then use that\
    \ space to sort.  Since punctuation characters are all whitespace characters,\
    \ this is easy.  Just insert a space before each punctuation character with code\
    \ like this:\n<code>\ns/([.,:;!?])/$1/ for split /\\s+/, $string;\n</code>\nThen\
    \ you can sort by space:\n<code> = sort { lc($a) cmp lc($b) };\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis could easily fail if the string contains multiple punctuation\
    \ characters.\n<|/ c |>\n<| c |>\nHi Randy. Thanks for the suggestions. I tried\
    \ it out and it worked like a charm. :) Cheers.\n<|/ c |>\n<| c |>\nThis was originally\
    \ the answer I was thinking of as well, but then I realized you weren't sorting\
    \ by punctuation, but by space. You'd have to insert a space before each punctuation\
    \ character, sort by that, and then put them back together.\n<|/ c |>\n<| c |>\n\
    Yes, it could fail, but it will not fail unless you try to sort something that\
    \ is not a string.\n<|/ c |>\n<| c |>\nYes, but I was trying to say that if the\
    \ strings contain punctuation characters, that isn't a string, and sorting them\
    \ that way will result in a sort order that doesn't preserve the punctuation.\n\
    <|/ c |>\n<| a dscore=1 tags=perl,sorting,perl-module |>\nIf you're trying to\
    \ sort the characters in the string by their ASCII values, you can use the ord()\
    \ function instead of the ord($_) operator.\n<code>\nuse strict;\nuse warnings;\n\
    use 5.010;\nuse utf8;", "    $s =~ tr/ //d;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$1$2/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n\
    \    $s =~ s/ ([a-z]+) ([a-z]+)/$2$1/g;\n", "    my @words;\n    my @chars;\n\
    \    my @new_chars;\n    my $count = 0;\n    foreach my $char (split(//, $s))\
    \ {\n        $chars[$count] = ord($char);\n        $count++;\n    }\n    foreach\
    \ my $index (0 .. $count-1) {\n        $chars[$index] = $chars[$index+1] if $chars[$index+1]\
    \ > $chars[$index];\n    }\n    foreach my $word (split(//, $s)) {\n        $words[$count]\
    \ = $word;\n        $count++;\n    }\n    foreach my $index (0 .. $count-1) {\n\
    \        $words[$index] = $words[$index+1] if $words[$index+1] > $words[$index];\n\
    \    }\n    foreach my $char (split(//, $s)) {\n        $new_chars[$count] = $char;\n\
    \        $count++;\n    }\n    foreach my $index (0 .. $count-1) {\n        $new_chars[$index]\
    \ = $chars[$index+1] if $chars[$index+1] > $chars[$index];\n    }\n    foreach\
    \ my $word (split(//, $s)) {\n        $new_chars[$count] = $word;\n        $count++;\n\
    \    }\n    foreach my $index (0 .. $count-1) {\n        $new_chars[$index] =\
    \ $words[$index+1] if $words[$index+1] > $words[$index];\n    }\n    return join('',\
    \ @new_chars);\n}", "    # Write your code here.\n}", "    $s =~ s/(\\w+)/ $1.upcase\
    \ if defined $1;\n    my @words = split /\\s+/, $s;\n    my @res;\n    foreach\
    \ my $i (0..$#words) {\n        my @new = map { my $c = $words[$i]; $c =~ tr/a-zA-Z0-9//cd;\
    \ $c };\n        my $res = join '', @new;\n        push (@res, length $res) .\
    \ $res;\n    }\n    return join ' ', @res;\n}\n</code>\n<|/ a tags=perl dscore=0\
    \ |>\n<| c |>\nThanks for your reply. Is it possible to change this to work with\
    \ strings? I'm very new to perl, and I only know how to change it to work with\
    \ variables.\n<|/ c |>\n<| c |>\nThanks once again. I'm sorry but I'm having trouble\
    \ with this. I get an error, saying: Not a HASH reference at ./test.pl line 23,\
    \ <DATA> line 1. What am I doing wrong?\n<|/ c |>\n<| c |>\nHi again. I managed\
    \ to get it working. Only thing left is, how do I make it so it will not delete\
    \ characters in words? For example: anti_shuffle(\"Hello World\") should return\
    \ \"HelloWorld\"\n<|/ c |>\n<| c |>\nYes, I added a note in the answer\n<|/ c\
    \ |>\n<| c |>\nThanks so much! I appreciate the help!\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    $s =~ s/(\\s+)/ $1 . chr(ord($1) + 1) . ' ' . $1 . ' ' . chr(ord($1)\
    \ -1) . ' /eg;\n    return $s;\n}", "    $s =~ s/(\\S+)/ chars($1) /ge;\n    return\
    \ $s;\n}\n</code>\n<|/ a tags=perl,shuffle,string dscore=1 |>\n<| c |>\nYou missed\
    \ the point of the question: the OP did not want a random shuffle of the words\
    \ in the string. He wanted the characters to all be sorted into ascending order\
    \ by ASCII value while still preserving the original word order. For example,\
    \ `\"Hi\"` should be `\"aH\"` and not `\"Hia\"`.\n<|/ c |>\n<| c |>\nSorry, I\
    \ didn't notice that. Edited my answer.\n<|/ c |>\n<| a tags=perl,shuffle,string\
    \ |>\n<code>", "    my($ord, $ord1, $ord2, $ord3, $ord4, $ord5, $ord6, $ord7);\n\
    \    my($i, $i1, $i2, $i3, $i4, $i5, $i6, $i7);\n    my(@ord);\n    my @ords =\
    \ ();", "    $s = join(\" \", map { char($_) } split(\" \", $s));\n    $s =~ tr/\
    \ /A-Z/;\n    return $s;\n}\n</code>\n<|/ a tags=perl,split,string |>\n<| a tags=perl,split,string\
    \ dscore=1 |>\nI did it like this\n<code>", "    $s =~ s/ (?<=\\s)\\W//g;\n  \
    \  $s =~ s/ (?<=\\s)\\W(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)\\W/$1/g;\n\
    \    $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)(?=\\\
    s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n   \
    \ $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s\
    \ =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\\
    s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\\
    s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/\
    \ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\\
    s)(?=\\s)(?=\\s)/$1/g;\n    $s =~ s/ (?<=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\s)(?=\\\
    s)(?=\\s)(?=\\s)(?=", "    $s =~ s/ ([^\\s]+)/ chop($1) . chr(97 + ord($1) - 64)\
    \ /ge;\n    return $s;\n}", "    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/ /!g;\n    $s =~ s/\
    \ /!g;\n    $s =", "    $s =~ s/\\s*(\\S+)\\s*/$1 ~m/ig;\n    return $s;\n}",
  "    return $s if !defined($s);\n    my @temp = split(\" \", $s);\n    my @ans =\
    \ ();\n    for (my $i = 0; $i < @temp; $i++) {\n        if ($temp[$i] =~ /\\s/)\
    \ {\n            $temp[$i] = $temp[$i] . anti_shuffle(\"$temp[$i + 1]\");\n  \
    \      }\n        else {\n            my $char = $temp[$i];\n            my $j\
    \ = 0;\n            my @chars = split(\"\", $char);\n            foreach (@chars)\
    \ {\n                my $ord = ord $_;\n                $chars[$j] = $chars[$j\
    \ + 1] if $j == (@chars - 1);\n                if ($ord >= 65 && $ord <= 90) {\n\
    \                    $chars[$j] = chr($ord + 32) if $ord < 122;\n            \
    \    }\n                elsif ($ord >= 97 && $ord <= 122) {\n                \
    \    $chars[$j] = chr($ord - 32) if $ord > 97;\n                }\n          \
    \      else {\n                    $chars[$j] = \"X\";\n                }\n  \
    \              $j++;\n            }\n            $chars = join(\"\", @chars);\n\
    \            $chars = $chars . \"W\" unless ($chars eq \"XW\");\n            $chars\
    \ = anti_shuffle($chars) if $chars =~ m/^X/;\n            push @ans, $chars;\n\
    \        }\n    }\n    return join(\" \", @ans);\n}", "    my @a = split(\" \"\
    ,$s);\n    my @b = ();\n    my @e = ();\n    my $k = 0;\n    my $i = 0;\n    while(@a){\n\
    \        $i++;\n        $k++;\n        $k = $k % scalar(@a);\n        push(@b,$a[$k]);\n\
    \        push(@e,$a[$k]);\n        splice(@a,$k,1);\n    }\n    my $k = 0;\n \
    \   my $i = 0;\n    while(@b){\n        $i++;\n        $k++;\n        $k = $k\
    \ % scalar(@b);\n        splice(@b,$k,0,$e[$k]);\n    }\n    return join(\" \"\
    ,@b);\n}", "    $s =~ s/\\s+/ /g;\n    $s =~ s/^\\s*//;\n    $s =~ s/\\s*$//;\n\
    \    $s =~ s/[[:alpha:]]/chr(ord(\"a\") + $& - ord(\"a\"))/ge;\n    $s =~ s/[[:lower:]]/chr(ord(\"\
    a\") + $& - ord(\"A\"))/ge;\n    $s =~ s/[[:upper:]]/chr(ord(\"A\") + $& - ord(\"\
    A\"))/ge;\n    return $s;\n}", "    $s =~ s/(.)(\\S+)/$1.$2_anics$3/;\n    return\
    \ $s;\n}", "    $s =~ s/\\s+/ /g;\n    return $s;\n}\n</cell>\n<cell>", "    my\
    \ @tokens = split(/\\s/,$s);\n    my $length = @tokens;\n    my @anti_shuffled\
    \ = ();\n    my @new_tokens = ();\n    my $i = 0;\n    my $j = -1;\n    my $k;\n\
    \    my $new_word = \"\";\n    my $temp_word = \"\";\n    my $word_start = 0;\n\
    \    my $word_end = 0;\n    my $next_word_start = 0;\n    my $word_length = 0;\n\
    \    my $temp_length = 0;\n    my $j = 0;\n    my $temp_j = 0;\n    my $new_char\
    \ = \"\";\n    my $temp_char = \"\";\n    my $new_char_val = 0;\n    my $temp_char_val\
    \ = 0;\n    my $new_char_val1 = 0;\n    my $temp_char_val1 = 0;\n    my $new_char_val2\
    \ = 0;\n    my $temp_char_val2 = 0;\n    my $new_char_val3 = 0;\n    my $temp_char_val3\
    \ = 0;\n    my $new_char_val4 = 0;\n    my $temp_char_val4 = 0;\n    my $new_char_val5\
    \ = 0;\n    my $temp_char_val5 = 0;\n    my $new_char_val6 = 0;\n    my $temp_char_val6\
    \ = 0;\n    foreach $k (0 .. $length - 1) {\n        # get the length of the word.\n\
    \        $word_length = $tokens[$k + 1] =~ tr/a-zA-Z//;\n        # get the index\
    \ of the next word.\n        $next_word_start = index($tokens[$k + 2], \" \");\n\
    \        $word_length += $next_word_start;\n        # get the length of the current\
    \ word.\n        $temp_length = $tokens[$k] =~ tr/a-zA-Z//;\n        $word_length\
    \ += $temp_length;\n        # get the word and add the new char to it.\n     \
    \   $temp_word = $tokens[$k];\n        $new_char_val = $temp_char_val = $temp_char_val1\
    \ = $temp_char_val2 = $temp_char_val3 = $temp_char_val4 = $temp_char_val5 = $temp_char_val6\
    \ = 65;\n        foreach $j (0 .. $word_length - 1) {\n            # get the position\
    \ of the character to be replaced.\n            $new_char_val = substr($temp_word,\
    \ $j, $word_length);\n            $temp_char_val = $new_char_val - $temp_char_val1;\n\
    \            $temp_char_val1 = $new_char_val;\n            $temp_char_val2 = $temp_char_val\
    \ * 10;\n            $temp_char_val3 = $temp_char_val2 * 10;\n            $temp_char_val4\
    \ = $temp_char_val3 * 10;\n            $temp_char_val5 = $temp_char_val4 * 10;\n\
    \            $temp_char_val6 = $temp_char_val5 * 10;\n            $new_char =\
    \ $temp_char_val6;\n            $temp_char_val6 = $temp_char_val5;\n         \
    \   $temp_char_val5 = $temp_char_", "    my (@o);\n    foreach my $i (0 .. length($s))\
    \ {\n        push (@o, $i);\n    }\n    my $j = 0;\n    while (@o > 0) {\n   \
    \     my $i = $o[0]--;\n        my $c = substr($s, $i, 1);\n        if ($c eq\
    \ ' ') {\n            my $t = $s[$i];\n            $s[$i] = $s[$j];\n        \
    \    $s[$j] = $t;\n            $j++;\n        } else {\n            $j++;\n  \
    \      }\n    }\n    $s;\n}\n</code>\n<|/ a tags=perl,regex dscore=2 |>\n<| c\
    \ |>\n+1 Nice answer, but I think OP wants something more like `'Hello, World!'`\
    \ -> `'!!, Wdrld'`.\n<|/ c |>\n<| c |>\n: Indeed I didn't read carefully enough\
    \ the question, I was thinking more like `'Hello, World!' -> 'Hlo, Wrld!'` (I\
    \ corrected the question).\n<|/ c |>\n<| c |>\n: I've corrected the code (thanks\
    \ to GhostCat) and also added a way to deal with \"inappropriate\" words like\
    \ `'This' -> 'Thsi'`.\n<|/ c |>\n<| a dscore=1 |>\nYou can use the following regex\
    \ and replace it with its opposite.\n<code>\n(?<=\\w)(?!\\w)\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| a tags=perl,regex |>\nI'm assuming that you want to swap every uppercase\
    \ letter for an uppercase letter followed by a lowercase. Here's how to do it:\n\
    <code>\nperl -pi -e 's/([A-Z])/$1 !~tr/A-Z/A-Z/' input.txt\n</code>\nExplanation:\n\
    The substitution will look for a lowercase letter, followed by an uppercase letter,\
    \ and replace it with an uppercase letter followed by a lowercase letter (this\
    \ looks for a lowercase letter and then replaces it with an uppercase letter followed\
    \ by a lowercase letter). tr is a perl command that translates characters in the\
    \ first argument according to the characters in the second argument. In this case,\
    \ we are using it to translate uppercase letters to lowercase letters, followed\
    \ by lowercase letters to uppercase letters.\nTo understand how this works, let's\
    \ see what tr does:\n<code>\necho a | tr ab b\na\n</code>\nSo tr takes the first\
    \ argument and translates it to its corresponding character, in this case a to\
    \ b (this can also be done with tr/a/", "    $s =~ s/(\\w)/sprintf \"%c\", ord\
    \ $1/eg;\n    return $s;\n}\n</code>\nTest it:\n<code>\nprint anti_shuffle(\"\
    Hello\");", "    $s =~ s/\\s+/\\s+/g;\n    $s =~ s/([a-z])([A-Z])/$1_$2/g;\n \
    \   $s =~ s/([^a-z])([A-Z])/$1_$2/g;\n    $s =~ s/([^A-Z])([A-Z])/$1_$2/g;\n \
    \   $s =~ s/([^A-Z])([a-z])/$1_$2/g;\n    $s =~ s/([^a-z])([a-z])/$1_$2/g;\n \
    \   return $s;\n}", '    my(@words) = split /\s+/, $s, -1;', "    $s =~ s/(^\\\
    s*)|(\\s*$)/$1$2/g;\n    $s =~ s/([a-zA-Z])([a-zA-Z]+)/$1$2$2$3/g;\n    $s =~\
    \ s/([a-zA-Z]+([a-zA-Z])+)/$1$2/g;\n    return $s;\n}", "    $s =~ tr/A-Z/a-z/;\n\
    \    $s =~ tr/A-Za-z//;\n    $s =~ tr/ /-/;\n    $s =~ tr/-/ /;\n    $s =~ tr/-/-/;\n\
    \    $s =~ tr/ /-/;\n    $s =~ tr/-/-/;\n    return $s;\n}", "    my(@ret) = ();\n\
    \    my ($i, $j, $new_char, $new_word);\n    for ($i=0; $i<@$s; $i++) {\n    \
    \    $new_char = ord(substr($s,$i,1));\n        if ($new_char >= 65 && $new_char\
    \ <= 90 || $new_char >= 97 && $new_char <= 122) {\n            if ($i != 0) {\n\
    \                push (@ret, substr($s, 0, $i));\n            }\n            push\
    \ (@ret, substr($s, $i, 1));\n        } else {\n            if ($i != 0) {\n \
    \               push (@ret, substr($s, 0, $i));\n            }\n            push\
    \ (@ret, $new_char);\n        }\n    }\n    for ($i=@ret - 1; $i>0; $i--) {\n\
    \        $new_word = substr($ret[$i], 0, 1);\n        $new_char  = substr($ret[$i],\
    \ 1);\n        if (ord($new_char) > ord($new_word)) {\n            $ret[$i] =\
    \ $new_char;\n        } else {\n            $ret[$i] = $new_word;\n        }\n\
    \    }\n    return join(\"\", @ret);\n}\n</code>\n<|/ a |>\n<| c |>\nI'm really\
    \ sorry to say that I am not able to understand how it works. Please can you explain\
    \ in detail how to use this? Thank you in advance.\n<|/ c |>\n<| c |>\nThe answer\
    \ does not appear to work. Could you provide an example of output from your original\
    \ code with the anti-shuffle method?\n<|/ c |>\n<| c |>\nI have changed my code\
    \ to use this code. Hope it is ok now.\n<|/ c |>\n<| c |>\nI see that your code\
    \ works well for me, but I'm still unable to understand how to use this code.\
    \ Can you please explain in detail how to use this?\n<|/ c |>\n<| c |>\nI have\
    \ tried this code, but I am not getting how to use it. Please can you explain\
    \ in detail how to use this?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    my($i);\n\
    \    my($first);\n    my($rest);\n    my($temp);\n    my(@words);\n    my(@sorted_words);\n\
    \    my($sorted_chars_arranged);\n    my(@temp_str);\n    my($new_str);\n    my($word_length)\
    \ = length($s);\n    $s=~s/([a-z])/chr(ord($1)+97)/eg;\n    for ($i=0; $i<$word_length;\
    \ $i++) {\n        if ($s[$i]!=\" \") {\n            $temp = $s[$i];\n       \
    \     $s[$i] = $s[$i-1];\n            $s[$i-1] = $temp;\n        }\n    }\n  \
    \  foreach $i (@s) {\n        if ($i!=\" \") {\n            $sorted_words[$i];\n\
    \        }\n    }\n    $sorted_chars_arranged = \"@sorted_words\";\n    foreach\
    \ $i (@$sorted_chars_arranged) {\n        $sorted_chars_arranged[$i] = reverse($i);\n\
    \    }\n    foreach $i (@$sorted_chars_arranged) {\n        $sorted_chars_arranged[$i]\
    \ = $i;\n    }\n    foreach $i (@$sorted_chars_arranged) {\n        $rest = $i;\n\
    \        $rest = substr($i, 0, $word_length-1);\n        $rest = $rest.\"!\";\n\
    \        $first = $i;\n        $first = $first.\" \";\n        push(@temp_str,\
    \ $first);\n        push(@temp_str, $rest);\n    }\n    @words = @temp_str;\n\
    \    for (@words) {\n        if ($i=~/!/) {\n            $new_str = $i.\"!\";\n\
    \            push(@sorted_words, $new_str);\n        }\n    }\n    $new_str =\
    \ \"\";\n    foreach $i (@sorted_words) {\n        $new_str = $new_str.$i;\n \
    \   }\n    return $new_str;\n}", "    my @list;\n    my @letters;\n    my $i =\
    \ 0;\n    my $j = 0;\n    foreach $letter (split(/ /, $s)) {\n        $letters[$i]\
    \ = ord($letter);\n        $i++;\n    }\n    for ($i; $i < $#letters; $i++) {\n\
    \        $j = 0;\n        while ($letters[$i] == $letters[$j]) {\n           \
    \ $j++;\n        }\n        $letters[$i] = $letters[$j];\n        $letters[$j]\
    \ = $letters[$i];\n    }\n    for ($i; $i < $#letters; $i++) {\n        $letters[$i]\
    \ = chr($letters[$i]);\n    }\n    my $s = join(\"\", @letters);\n    return $s;\n\
    }", "    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])/$1$2/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n    $s =~ s/([a-zA-Z])([a-zA-Z])([a-zA-Z])/$3$2$1/;\n\
    \    $s =~ s/([a-zA-Z])([a-zA-Z])", "    my @words = split(/\\s/,$s);\n    my\
    \ @new = ();\n    \n    foreach my $word (@words) {\n        my $l = length($word);\n\
    \        \n        for my $c (0..$l-3) {\n            $new[$c] = $word[$c];\n\
    \        }\n        push @new,\"$word[$l]\";\n    }\n    \n    return join(' ',@new);\n\
    }", "    # Write your code here.\n    return $s;\n}", "    $s =~ tr/A-Z/a-z/;\n\
    \    $s =~ tr/A-Za-z/ /;\n    $s =~ tr/ / -/;\n    $s =~ s/^-//;\n    $s =~ s/-$//;\n\
    \    $s =~ s/-//g;\n    return $s;\n}", "    $s =~ s/(\\w+)/'\\1'/g;\n    $s =~\
    \ s/^\\s+|\\s+$//g;\n    $s =~ s/\\s+/ /g;\n    $s =~ s/(\\w+)/'\\1'/g;\n    return\
    \ $s;\n}\n</code>\n<|/ a tags=perl,python dscore=0 |>\n<| a |>\nI have written\
    \ the following Perl version using Algorithm::Combinatorics module.\n<code>\n\
    use strict;\nuse warnings;\nuse Algorithm::Combinatorics qw[permutations combinations_with_repetitions];",
  '    my($ans, $word);', "    my @words = split(/ /, $s);\n    my $new_word = \"\"\
    ;\n    foreach my $word (@words) {\n        my $i = ord($word);\n        $new_word\
    \ .= $i > 255 ? substr($word, 0, 1) . chr(ord($word) - 255) . substr($word, 1)\
    \ : $word;\n    }\n    $new_word;\n}", "    return $s unless $s !~ /^[\\w\\s]*$/;\n\
    \    my($ord) = 0;\n    my($rev) = 0;\n    my($new) = $s;\n    $new = \" \" x\
    \ (length($s) / 2);\n    while($new =~ s/(\\w+)/sprintf(\"%c%c\",ord($1),ord($2)),$1/xg)\
    \ {\n        ++$ord;\n    }\n    while($new =~ s/(\\w+)/sprintf(\"%c%c\",ord($2),ord($1)),$1/xg)\
    \ {\n        ++$ord;\n    }\n    while($new =~ s/(\\w+)/sprintf(\"%c%c\",ord($1),ord($2)),$1/xg)\
    \ {\n        ++$rev;\n    }\n    my($new2) = $s;\n    $new2 = \" \" x (length($s)\
    \ / 2);\n    while($new2 =~ s/(\\w+)/sprintf(\"%c%c\",ord($1),ord($2)),$1/xg)\
    \ {\n        ++$ord;\n    }\n    while($new2 =~ s/(\\w+)/sprintf(\"%c%c\",ord($2),ord($1)),$1/xg)\
    \ {\n        ++$ord;\n    }\n    while($new2 =~ s/(\\w+)/sprintf(\"%c%c\",ord($1),ord($2)),$1/xg)\
    \ {\n        ++$rev;\n    }\n    $ord = ($ord - $rev) if($ord > $rev);\n    return\
    \ $new;\n}", "    my $string = $s;\n    $string =~ s/\\s+/ /; # remove duplicate\
    \ spaces\n    $string =~ s/^\\s+//; # remove leading spaces if any\n    $string\
    \ =~ s/\\s+$//; # remove trailing spaces if any\n    $string =~ s/(\\w+)/my $r=$1;$r.chr(ord($1)+26)/g;\
    \ # convert all letters to their ascii\n    return $string;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nAnother possibility:\n<code>", "    $s =~ s/([a-z])([A-Z])/$1\
    \ $2/g;\n    $s =~ s/([A-Z])([A-Z][a-z])/$2 $1/g;\n    $s =~ s/([a-z])([A-Z][A-Z])/$1\
    \ $2/g;\n    $s =~ s/([A-Z])([a-z][a-z])/$2 $1/g;\n    $s =~ s/([a-z][a-z])([A-Z])/$1\
    \ $2/g;\n    $s =~ s/([A-Z])([a-z][A-Z])/$2 $1/g;\n    return $s;\n}", "    $s\
    \ =~ s/(^|\\s)([a-z])/$1.$2/g;\n    $s =~ s/(^|\\s)([A-Z])/$2.$1/g;\n    $s =~\
    \ s/([a-z])([A-Z])/$2.$1/g;\n    $s =~ s/([a-z])([A-Z])/$2.$1/g;\n    $s =~ s/([A-Z])([a-z])/$2.$1/g;\n\
    \    $s =~ s/^([a-z])/$1./g;\n    return $s;\n}", "    $s =~ s/[^A-Za-z0-9]/./g;\n\
    \    $s =~ s/\\b(\\S+)\\s+(\\w+)/$1$2/;\n    $s =~ s/\\b(\\w+)\\s+(\\S+)/$1$2/;\n\
    \    return $s;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=perl,string |>\nThis\
    \ is an old question, but I think it's worth mentioning that there is a package\
    \ that does this called Text::Shuffle.\n<|/ a |>\n<| a tags=perl,string |>\n<code>",
  "    my @words = split(\" \", $s);\n    my $sorted = '';\n    my @chars = split(\"\
    \", chr(65..90));\n    \n    for(my $i = 0; $i < $#words; $i++) {\n        my\
    \ $temp_str = '';\n        for(my $j = 0; $j < $#chars; $j++) {\n            $temp_str\
    \ .= $chars[$j] if ($words[$i] eq $chars[$j]);\n        }\n        my $temp_ord\
    \ = ord $temp_str;\n        $sorted .= $chars[$i] if $temp_ord > ord $words[$i];\n\
    \    }\n    return $sorted;\n}\n</code>\nIt works for me.\n<|/ a tags=perl,ascii\
    \ |>\n<| a dscore=0 |>\nI believe this is what you are looking for. This will\
    \ give you the string in its original form with a new word inserted in the correct\
    \ location in the string.\n<code>\nmy $string = 'aAbB';", "    my @s = split(/\\\
    s/,$s);\n    my $len = scalar @s;\n    for(my $i = $len; $i > 0; $i -= 1) {\n\t\
    my $j = rand $len;\n\t\n\tmy $tmp = $s[$j];\n\t$s[$j] = $s[$i];\n\t$s[$i] = $tmp;\n\
    \    }\n    return join(\" \", @s);\n}", "    $s =~ tr/A-Z/a-z/;\n    $s =~ s/^\\\
    s*//;\n    $s =~ s/\\s*$//;\n    $s =~ s/\\s+/ /g;\n    $s =~ s/([^\\n])/ $1 /g;\n\
    \    return $s;\n}", "    my @word_list = split(/\\s/, $s);\n    my $new_word\
    \ = \"\";\n    my $new_chars = \"\";\n    my $index = 0;\n    foreach my $word\
    \ (@word_list) {\n        $new_chars .= $word;\n        while(length($new_chars)\
    \ < length($word)) {\n            my $letter = substr($new_chars, $index, 1);\n\
    \            $index++;\n            if($letter == \" \") {\n                my\
    \ $new_char = \"\";\n                my $letters = 0;\n                while(length($new_char)\
    \ < length($word)) {\n                    $new_char .= substr($new_chars, $index,\
    \ 1);\n                    $index++;\n                    $letters++;\n      \
    \          }\n                if($letters > 1) {\n                    my $random_letter\
    \ = int(rand(36) + 65);\n                    $new_chars .= chr(ord('A') + $random_letter);\n\
    \                    $index++;\n                }\n            }\n        }\n\
    \        $new_word .= $new_chars;\n        $new_chars = \"\";\n    }\n    return\
    \ $new_word;\n}\n</code>\n<|/ a |>\n<| c |>\nYou should post this as an answer\
    \ and not a comment.\n<|/ c |>\n<| c |>\n: I don't have enough reputation yet.\
    \ Will do that in the next few days. Thank you for the heads up :)\n<|/ c |>\n\
    <| a dscore=3 |>\nI suggest a recursive solution:\n<code>\nuse strict;\nuse warnings;\n\
    use feature 'say';", "    my @words = split(/ /, $s);\n    my $i = 0;\n    my\
    \ @sorted_words = ();\n    foreach my $word (@words) {\n        if ($word =~ /\\\
    s/) {\n            push @sorted_words, $word;\n            next;\n        }\n\
    \        my $new_word = substr($word, 0, 1);\n        $new_word .= chr($i);\n\
    \        $new_word .= substr($word, 1, 1);\n        $sorted_words->[$i] = $new_word;\n\
    \        $i++;\n    }\n    return join(\" \", @sorted_words);\n}", "    $s =~\
    \ s/(\\s+)(\\S+)(\\s+)/$1.($2.chr(int(ord($3)+65)).$2).$3/ge;\n    return $s;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,perl,sorting |>\nYou can't sort\
    \ \"naturally\", because it's too complicated to understand what the strings look\
    \ like. The string \"Hello World!!!\" has \"Hello\" and \"World\" swapped, \"\
    !!!\" moved to the end, and \"World\" moved to the end. How does this even happen\
    \ to you? If these strings always have no more than three words, then you can\
    \ do the following:", "    $s =~ s/([a-z])/length($1)+$1/g;\n    $s =~ s/\\s/\
    \ /g;\n    $s =~ s/^\\S+\\s+//;\n    $s =~ s/\\s+\\S+$//;\n    $s =~ s/\\s+//g;\n\
    \    $s =~ s/\\s+$//;\n    $s =~ s/^\\s+//;\n    $s =~ s/\\s+/-/g;\n    $s =~\
    \ s/\\s+$//;\n    $s =~ s/[-]+/-/g;\n    $s =~ s/[-]+$//;\n    $s =~ s/[^a-zA-Z]//g;\n\
    \    $s =~ s/ //g;\n    return $s;\n}", "    $s =~ s/(^|\\s)((?:\\w+\\W+)+)(?=(\\\
    s|$))/\\1\\3/gs;\n    $s;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI created a\
    \ version that worked for me. It will take an input and make all letters lowercase,\
    \ and remove all extra spaces.\n<code>"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
