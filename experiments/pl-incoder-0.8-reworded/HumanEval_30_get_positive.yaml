name: HumanEval_30_get_positive
language: pl
prompt: "# Return only positive numbers in the array.\n# >>> get_positive([-1, 2,\
  \ -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1,\
  \ -10])\n# [5, 3, 2, 3, 9, 123, 1]\nsub get_positive {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_positive;\n\
  \        if(eq_deeply($candidate->([-1, -2, 4, 5, 6]),[4, 5, 6])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ -2]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @result = ();\n    for (@$l) {\n        if ($_ < 0) {\n    \
    \        push(@result, _);\n        }\n    }\n    return @result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>", "    return grep { ($_ > 0) || (!defined\
    \ $l); };\n}", "    my(@a);\n    push(@a, \"$1\") while ($l =~ s/^(-?\\d+)$//);\n\
    \    return @a;\n}", "    return @$l if @$l > 0;\n    return ();\n}", "    my\
    \ @r;\n    for(@$l) {\n        if($_ < 0) {\n\t    push(@r, '-' x abs($_));\n\
    \        }\n        else {\n\t    push(@r, _);\n        }\n    }\n    return @r;\n\
    }", "    my @r;\n    my $max = $l[0];\n    my $min = $l[0];\n    for(my $i = 0;\
    \ $i < @$l; $i++) {\n        my $x = $l->[$i];\n        if($x >= 0) {\n      \
    \      push(@r, $x);\n        }\n        if($x > $max) {\n            $max = $x;\n\
    \        }\n        if($x < $min) {\n            $min = $x;\n        }\n    }\n\
    \    return @r;\n}", "    my(@r) = (@$l);\n    for (@r) {\n\tif ($_ < 0) { $_\
    \ = 0; }\n\tpush @r, $_;\n    }\n    return @r;\n}", "    my @r = ();\n    foreach\
    \ my $x (@$l) {\n\tif ($x <= 0) {\n\t    push @r, $x;\n\t}\n    }\n    return\
    \ @r;\n}", "    my @r;\n    foreach (@$l) {\n        if ($_ > 0) {\n         \
    \   push(@r, $_);\n        }\n    }\n    return @r;\n}", "    my @s = ();\n  \
    \  foreach my $i (@$l) {\n        push(@s, $i > 0 ? $i : 0);\n    }\n    return\
    \ @s;\n}", "    grep { $_ <= 0 } @$l;\n}", "    my (@positives);\n    foreach\
    \ my $i (0..$#$l) {\n        if ($l->[$i] > 0) {\n            push(@positives,\
    \ $l->[$i]);\n        }\n    }\n    return @positives;\n}", "    my @r;\n    while\
    \ (@$l > 0) {\n\tpush (@r, shift @$l);\n    }\n    return @r;\n}", "    grep {\
    \ $_ > 0 } @$l;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\n`grep { $_ >\
    \ 0 } @$l` is better written as `grep { $_ !~ (/^\\s*$/) }`\n<|/ c |>\n<| c |>\n\
    Nit: `grep` returns false when its argument is empty, which means your final `grep`\
    \ will return all elements in the array. `grep`'s return value is a list. `@$l`\
    \ is an array reference, and that doesn't have a `grep` method. `@$l == grep {\
    \ ... }` is true if `@$l` contains any elements of `grep { ... }`, and false otherwise.\
    \ `@$l` is an array ref, and `grep` is an array method. `@$l == grep(...)` is\
    \ true if `@$l` contains any elements that match the expression `...`, and false\
    \ otherwise. `@$l` is an array ref, and `grep` is an array method.\n<|/ c |>\n\
    <| c |>\nThanks for the info.  I have revised my code accordingly.\n<|/ c |>\n\
    <| a |>\nJust use Perl's grep\n<code>\nmy = grep {$_ > 0} @$a;\n</code>\n<|/ a\
    \ tags=perl,arrays dscore=5 |>\n<| a dscore=4 tags=perl,arrays |>\n<code>\nmy\
    \ = grep { $_ > 0 } @$a;\n</code>\n<|/ a |>\n<| c |>\nThis will work only when\
    \ your array is of numeric type. Otherwise it may produce incorrect results. `my\
    \ = grep { $_ > 0 } qw/1 2 3 4 5 6 7 8 9 10 11 12 13 14 15/;` will return `@a`\
    \ as `1,10,15` but `my = grep { $_ > 0 } qw/1 2 3 4 5 6 7 8 9 10 11121314/;` will\
    \ return `@a` as `1,10,11,12,13,14`\n<|/ c |>\n<| c |>\nThe question is about\
    \ `ARRAY` or `ARRAYREF` type. My answer is about numeric type\n<|/ c |>\n<| a\
    \ tags=perl,arrays |>\nFor those who use Perl 5.10 or above:\n<code>\nuse Algorithm::Loops::All;",
  "    my(@res);\n    my $neg = 1;\n    foreach my $n (@$l) {\n        $n = $n - $neg\
    \ if $n >= 0;\n        if ($n < 0) {\n            $neg += $n;\n            $n\
    \ = $n / abs($n);\n        } else {\n            $neg -= $n;\n        }\n    \
    \    push(@res, $n);\n    }\n    @res;\n}", "    return $l if $l =~ /^-?\\d+$/;\n\
    \    return $l unless @$l > 0;\n    $l =~ s/^(-?)-?(\\d+)$/$2$1/g;\n    return\
    \ $l;\n}", "    my @positive;\n    while(@$l) {\n\tpush(@positive, $l->[0]) if\
    \ $l->[0] >= 0;\n\tunshift @$l, shift @$l if @$l > 0 && $l->[0] <= 0;\n    }\n\
    \    return @positive;\n}", "    grep { $_ >0 } @$l;\n}", "    $l =~ s/^\\s*\\\
    [\\s*(-?\\d+)\\s*\\]\\s*//;\n    my @a = @{$l};\n    my @r;\n    foreach my $n\
    \ (@a) {\n        $n = abs($n);\n        push (@r, $n) if $n > 0;\n    }\n   \
    \ return @r;\n}", "    grep($_ >  0, @$l);\n}", "    my @r;\n    for(@$l) {\n\
    \        push(@r, $_ if $_ > 0;\n    }\n    return @r;\n}", "    my($ret) = ();\n\
    \    $ret = ();\n    foreach my $x (@$l) {\n        if($x > 0) {\n           \
    \ push(@$ret, $x);\n        }\n    }\n    return @$ret;\n}", "    grep {\n   \
    \     /-?(\\d+)/\n    } @$l\n}", '    my @nums = @$l;', "    my(@g) = ();\n  \
    \  foreach my $x (@$l) {\n        push @g, $x if $x >0;\n    }\n    return @g;\n\
    }", "    my @result = ();\n    my %seen = ();", "    my $r = 0;\n    while ($l[$_]\
    \ > 0) { $r++ }\n    return @$l > 0 ? @$l : @$l > 1 ? $r : @$l;\n}", "    my @r\
    \ = ();\n    for (@$l) {\n\tpush(@r, $_) if $_ > 0;\n    }\n    return @r;\n}",
  "    return grep { ($_ > 0) == 1 } @$l;\n}", "    @$l < 0 ? @$l : ();\n}", "   \
    \ my @l;\n    for(@$l) {\n\tfor(my $i=0;$i<@$l;$i++) {\n\t    next if $l[$i] <=\
    \ 0;\n\t    push @l, $l[$i];\n\t}\n    }\n    return @l;\n}", "    $l =~ s/^\\\
    s*\\(\\s*//;\n    $l =~ s/\\s*\\)\\s*$//;\n    my(@a) = split /,/, $l;\n    return\
    \ grep { $_ > 0 } @a;\n}", "    my @r = [];\n    my ($prev, $curr);", "    my\
    \ $positive;\n    my $i = 0;\n    my $last = 0;\n    my $max;\n    for (my $j\
    \ = 0; $j < @$l; $j++) {\n        $positive = 0;\n        $max = $l->[$j];\n \
    \       for ($i = 0; $i < @$l; $i++) {\n            if ($l->[$i] < 0) {\n    \
    \            $positive = 1;\n                last;\n            }\n          \
    \  if ($l->[$i] > $max) {\n                $max = $l->[$i];\n            }\n \
    \       }\n        if ($positive == 1) {\n            push @$l, $max;\n      \
    \  } else {\n            push @$l, undef;\n        }\n    }\n    return @$l;\n\
    }\n</code>\n<|/ a dscore=0 tags=arrays,perl |>\n<| c |>\nThat code doesn't run.\
    \ It has many syntax errors. I suggest you run it in a debugger to see what is\
    \ happening.\n<|/ c |>\n<| c |>\nThanks, I have fixed the errors. BTW, I wrote\
    \ it without testing it. So, I guess there will be more errors :)\n<|/ c |>\n\
    <| c |>\nThanks all. Just one question: Why do you use \"my\" everywhere? Can\
    \ you please give me some links for learning \"my\" on perl?\n<|/ c |>\n<| c |>\n\
    You use `my` when you don't want to modify the values of your variables. In your\
    \ example, you only need the variable `$positive`, so I used `my`. See [perldoc](http://perldoc.perl.org/perlsub.html#Variables-related-to-regular-expressions).\
    \ The best link for learning `my` is [perlreftut](http://perldoc.perl.org/perlreftut.html),\
    \ but there is a lot of online tutorials.\n<|/ c |>\n<| c |>\nThanks a lot for\
    \ the links, I will read them and try to learn something new.\n<|/ c |>\n<| a\
    \ tags=arrays,perl |>\n<code>", "    my(@ret) = (0);\n    my($neg) = 0;\n    my($pos);",
  "    grep($_, my($v) = @$l);\n}", "    my @r = ();\n    foreach my $x (@{$l}) {\n\
    \        push(@r, $x if $x > 0);\n    }\n    return @r;\n}", "    my @new_list\
    \ = ();\n    for my $value (@$l) {\n        if ($value > 0){\n            push(@new_list,\
    \ $value);\n        }\n    }\n    return @new_list;\n}", "    my($i, $n);\n  \
    \  my @r;\n    for ($n = 0; $n < @$l; $n++) {\n        $i = $l->[$n];\n      \
    \  unless ($i > 0) {\n            push(@r, $i);\n        }\n    }\n    return\
    \ @r;\n}", "    my($i, $x, $y);\n    for ($i = 0; $i < @$l; $i++) {\n        $x\
    \ = $l->[$i];\n        if ($x > 0) {\n            $l->[$i] = $x;\n        }\n\
    \    }\n    return @$l;\n}", "    my @r;\n    for my $i (0..$#$l) {\n        my\
    \ $value = $l->[$i];\n        if ($value > 0) {\n            push(@r, $value);\n\
    \        }\n    }\n    return @r;\n}", "    my @l;\n    for(my $x=0; $x<@$l; $x++)\
    \ {\n        push(@l, $l->[$x] > 0 ? $l->[$x] : $l->[$x]); # Replace negative\
    \ by zero.\n    }\n    return @l;\n}", "    my @r;\n    for (@$l) {\n        push\
    \ @r, $_ if $_ > 0;\n    }\n    return @r;\n}", "    my $positives = ();\n   \
    \ foreach my $num (@$l) {\n        if ($num > 0) {\n            $positives++;\n\
    \        }\n    }\n    return @$l if $positives == 0;\n    return @$l if $positives\
    \ == 1;\n    return @$l if $positives > 1;\n    return @$l;\n}", "    my @r;\n\
    \    foreach my $x (@$l) {\n        if ($x > 0) {\n            push @r, $x;\n\
    \        }\n    }\n    return @r;\n}", "    my @l = ();\n    for ($l[0] = $l[0]\
    \ + 1; $l[0] >= 0; $l[0]--) {\n        push(@l,$l[$_]) for (1 .. $#l);\n    }\n\
    \    return @l;\n}", "    grep {$_ > 0} @$l;\n}", "    my @r;\n    for (@$l) {\n\
    \        push(@r, $_) if $_ > 0;\n    }\n    return @r;\n}", "    my($i, $j, $max);\n\
    \    $max = -1;\n    for ($i = 0; $i < @$l; $i++) {\n        $max = $max == -1\
    \ ? $l->[$i] : max($l->[$i], $max);\n    }\n    return @$l[$max < 0 ? -$max :\
    \ 0];\n}", "    grep {$_ > 0} @$l;\n}", "    my @a;\n    while (@$l) {\n     \
    \   my $n = shift @$l;\n        if ($n > 0) {\n            push @a, $n;\n    \
    \    }\n    }\n    return @a;\n}", "    map { $_ > 0 ? $_ : () } @$l;\n}", " \
    \   my @a;\n    foreach my $x (@$l) {\n        push(@a, $x if $x >= 0);\n    }\n\
    \    return @a;\n}", "    my @result = (0);\n    while (@$l) {\n        if ($_\
    \ < 0) {\n            push(@result, $_);\n        } else {\n            last;\n\
    \        }\n    }\n    return @result;\n}", "    my @r;\n    for(my $i=0; $i<@$l;\
    \ $i++) {\n        if ($l->[$i] >= 0) {\n            push @r, $l->[$i];\n    \
    \    }\n    }\n    return @r;\n}", "    my @out;\n    my $neg;\n    my $pos;\n\
    \    my $x;", "    my @a;\n    for(@$l) {\n        if($_ > 0) {\n            push,\
    \ $_;\n        }\n    }\n    return @a;\n}", "    $l =~ s/^\\s*(-?)\\s*//;\n \
    \   if ($1) {\n        $l =~ s/^\\s*(-?[0-9]+)\\s*//;\n    }\n    return $l;\n\
    }", "    my @a = @$l;\n    my @b = ();\n    foreach my $i (@a) {\n        push(@b,\
    \ $i) if $i >= 0;\n    }\n    @$l = @b;\n    return @$l;\n}", "    my(@a);\n \
    \   \n    foreach $a (@$l) {\n        if($a < 0) {\n            splice @$l, 0,\
    \ 1;\n        }\n    }\n    return @$l;\n}", "    my $ret = [];\n    foreach my\
    \ $n (@$l) {\n        if ($n > 0) {\n            push(@$ret, $n);\n        }\n\
    \    }\n    return @$ret;\n}", "    my @new_array = ();\n    my($max) = $l->[-1];\n\
    \    foreach my $value (@$l) {\n\tpush @new_array, $value if $value >= $max;\n\
    \t$max = $value if ($value == $max);\n    }\n    return @new_array;\n}", "   \
    \ my @pos;\n    my $n = 0;\n    my $tmp = 0;\n    foreach my $i (@$l) {\n\t$tmp\
    \ += $i;\n\tnext if $tmp == 0;\n\tpush @pos, $i;\n\t$n++;\n\t$tmp -= $i;\n   \
    \ }\n    return @pos if $n > 0;\n    return;\n}", "    my ($n, $p, $i);\n    my\
    \ @ret;", "    my @res = ();\n    $l =~ s/^\\s*//;\n    my($n);\n    while($l\
    \ = length($l)) {\n        last if $l == 0;\n        $n = 0;\n        for($_;\
    \ $l - 1 != $_; $_--) {\n            $n++; $l -= _($_);\n        }\n        push\
    \ @res, $n;\n    }\n    return @res;\n}", "    my @r = ();\n    for my $v (@$l)\
    \ {\n        push @r, $v if $v > 0;\n    }\n    return @r;\n}", "    return map\
    \ { $_ > 0 ? $_ } @$l;\n}", "    my @r = ();\n    for (my $i = 0; $i < @$l; $i++)\
    \ {\n        if ($l->[$i] > 0)\n            push @r, $l->[$i];\n    }\n    return\
    \ @r;\n}", "    grep { $_ > 0 } @$l;\n}", "    my($ret);\n    foreach my $n (@$l)\
    \ {\n        if ($n > 0 && $n <= 0) {\n            $ret->[$#ret + 1] = &_print_int($n);\n\
    \        }\n    }\n    return @$ret if scalar @$ret > 0;\n    return;\n}", " \
    \   my($ret);\n    foreach my $i (0 .. @$l) {\n        if ($l[$i] < 0) {\n   \
    \         $ret->[$i] = $l[$i];\n        }\n    }\n    @$ret;\n}", "    my @a;\n\
    \    for(@$l) {\n        if($_ > 0) {\n            $_;\n        } else {\n   \
    \         push @a, $_;\n        }\n    }\n    @a;\n}", "    my @result = ();\n\
    \    foreach my $i (@$l) {\n        push(@result, $i > 0 ? $i : ()); \n    }\n\
    \    return @result;\n}", "    grep {$_ > 0} @$l;\n}", "    my @r = ();\n    foreach\
    \ my $x (@$l) {\n        push(@r, $x if $x > 0);\n    }\n    @$l = @r;\n    return\
    \ @$l;\n}", "    my @a = @$l;\n    return grep { $_ > 0 } @a;\n}\n</code>\n<|/\
    \ a tags=arrays,perl,return,conditional,loops |>\n<| a tags=arrays,perl,return,conditional,loops\
    \ |>\nYou can do it all in one go:\n<code>\nuse List::MoreUtils qw( all );", " \
    \   grep {\n        my $x = $_;\n        $x >= 0 &&\n        ($x < $l || $x !=\
    \ 0 && ($_ == 0 || $x < 0))\n    } @$l;\n}", "    my @t = ();\n    foreach my\
    \ $x (@$l) {\n\tpush(@t, $x >= 0 ? $x : 0);\n    }\n    return @t;\n}", "    grep\
    \ { $_ >= 0 } @$l;\n}", '    my @ret;', "    return grep { $_ > 0 } @$l;\n}",
  "    my(@r) = ();\n    push(@r, $l[0]);\n    for(my $i = 1;$i < @$l;$i++) {\n  \
    \      push(@r, ($l[$i] >= 0) ? $l[$i] : $l[$i] + 1);\n    }\n    return @r;\n\
    }", "    grep { $l > 0 } @$l;\n}", "    my @a = @{$l};\n    my $i = 0;\n    while\
    \ ($i < @a) {\n        $a[$i] //= 0;\n        $i++;\n    }\n    return @a;\n}",
  "    $l =~ s/^\\s*//g;\n    $l =~ s/\\s*$//g;\n    my($ret);\n    if ($l =~ /^\\\
    s*-?(\\d+\\.\\d+)\\s*$/gs) {\n        $ret = ($1.\"0\");\n    }\n    elsif ($l\
    \ =~ /^\\s*-?(\\d+)\\s*$/gs) {\n        $ret = ($1.\"0\");\n    }\n    elsif ($l\
    \ =~ /^\\s*-?(\\d+\\.\\d)\\s*$/gs) {\n        $ret = ($1.\"0\");\n    }\n    elsif\
    \ ($l =~ /^\\s*(-?\\d+\\.?\\d*\\s*,\\s*)?(-?\\d+\\.?\\d*)\\s*$/gs) {\n       \
    \ $ret = ($1.$2.$3);\n    }\n    elsif ($l =~ /^\\s*(-?\\d+\\.?\\d*\\s*,\\s*\\\
    d+\\.?\\d*\\s*)?(-?\\d+\\.?\\d*)\\s*$/gs) {\n        $ret = ($1.$2.$3);\n    }\n\
    \    elsif ($l =~ /^\\s*(-?\\d+\\.?\\d*\\s*,\\s*[-\\.\\d]+\\s*)?(-?\\d+\\.?\\\
    d*)\\s*$/gs) {\n        $ret = ($1.$2.$3);\n    }\n    elsif ($l =~ /^\\s*(-?\\\
    d+\\.?\\d*\\s*,\\s*[+-\\.\\d]+\\s*)?(-?\\d+\\.?\\d*)\\s*$/gs) {\n        $ret\
    \ = ($1.$2.$3);\n    }\n    elsif ($l =~ /^\\s*(-?\\d+\\.?\\d*\\s*,\\s*[+-\\.\\\
    d]+\\s*,\\s*[-\\.\\d]+\\s*)?(-?\\d+\\.?\\d*)\\s*$/gs) {\n        $ret = ($1.$2.$3);\n\
    \    }\n    elsif ($l =~ /^\\s*(-?\\d+\\.?\\d*\\s*,\\s*[-\\.\\d]+\\s*,\\s*[+-\\\
    .\\d]+\\s*)?(-?\\d+\\.?\\d*)\\s*$/gs) {\n        $ret = ($1.$2.$3);\n    }\n \
    \   else {\n        $ret = $l;\n    }\n    $ret =~ s/^\\s*(-?\\d+\\.?\\d*\\s*,\\\
    s*[-\\.\\d]+\\s*,\\s*[+-\\.\\d]+\\s*)?(-?\\d+\\.?\\d*)\\s*$//gs;\n    $ret;\n}",
  "    return @{$l ? @$l : ()};\n}", "    my($i, $n);\n    my(@new);\n    my($k, $num);\n\
    \    my($sign, $n);", "    grep {$_ > 0} @$l;\n}", "    return grep { $_ > 0 }\
    \ @$l;\n}", "    grep { $_ > 0 } @$l;\n}", "    return sort { $a <=> $b } grep\
    \ { $_ > 0 } @$l;\n}", "    my @a = @$l;\n    my @b;\n    my @c;\n    foreach\
    \ (@a) {\n        if ($_ > 0) {\n            push @b, $_;\n        } else {\n\
    \            push @c, $_;\n        }\n    }\n    return @b;\n}", "    my @res\
    \ = ();\n    my $pos = 0;\n    my $neg = 0;\n    my $i = @$l;\n    while (--$i\
    \ >= 0) {\n        if ($l->[$i] < 0) {\n            $neg++;\n        } else {\n\
    \            $pos++;\n        }\n        push @res, $l->[$i] if $pos++;\n    \
    \    push @res, $l->[$i] if $neg++;\n    }\n    return @res;\n}", "    return\
    \ map {$_ > 0 ? $_ : ()} @$l;\n}", '    my $positive = [];', "    my @a;\n   \
    \ my $x = scalar @$l;\n    for (my $i = 0; $i < $x; ++$i) {\n        push(@a,\
    \ $l->[$i] if $l->[$i] > 0);\n    }\n    return @a;\n}\n</code>\nThe get_negative()\
    \ function is the same as get_positive(), but returns only negative numbers.\n\
    <code>", "    my @a;\n    my @b;\n    while (@$l) {\n        if ($l->[0] >= 0)\
    \ {\n            push(@a, $l->[0]);\n        }\n        else {\n            push(@b,\
    \ $l->[0]);\n        }\n        push(@$l, $l->[1]);\n    }\n    return (@a, @b);\n\
    }", "    my @r = ();\n    while (@$l) {\n\tpush (@r, @$l) if $_ > 0;\n\tshift\
    \ @$l;\n    }\n    @r;\n}", "    my $positive = ();\n    foreach my $i (@$l) {\n\
    \        if ($i >= 0) {\n            $positive .= $i;\n        }\n    }\n    return\
    \ $positive;\n}", "    grep { $_ > 0 } @$l;\n}\n</code>\nAnd now some benchmarking:\n\
    <code>", "    my(@result) = ();\n    for (my $i = 0; $i < @$l; $i++) {\n     \
    \   if ($l->[$i] > 0) {\n            push(@result, $l->[$i]);\n        }\n   \
    \ }\n    return @result;\n}", "    grep { $_ > 0 } @$l;\n}", "    my($l);\n  \
    \  while($l) {\n        my $x = $l->[0];\n        splice(@$l, 0, 1);\n       \
    \ if($x > 0) {\n            push @$l, $x;\n        }\n    }\n    return @$l;\n\
    }", "    my @l = @$l;\n    my @r = []; # Empty return list.\n    for (my $i =\
    \ 0; $i < @l; $i++) {\n\tif ($l[$i] > 0) {\n\t    push(@r, $l[$i]);\n\t}\n   \
    \ }\n    return @r;\n}", "    my($ret);\n    foreach my $n (@$l) {\n        $ret\
    \ .= $n if $n > 0;\n    }\n    return $ret;\n}", "    return grep { $_ > 0 } @$l;\n\
    }", "    grep {$_ > 0} @$l;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis will\
    \ not work for the `@t` case you showed in your question - it will return `@t`\
    \ with the `@t` elements, not just those that are positive.  Also the list returned\
    \ by `map` will only have exactly one element, it will be an array reference containing\
    \ the return value of the `grep` call.\n<|/ c |>\n<| c |>\n- You're right. I don't\
    \ have a computer with Perl on it handy to test it, but if you're right, I think\
    \ you'll need to do `map { $_ > 0 } @$l`.\n<|/ c |>\n<| c |>\n- Ah, that does\
    \ indeed work. `map` is really the right tool for the job in this case. I've updated\
    \ my answer.\n<|/ c |>\n<| c |>\n- If you use `grep {!$_}` in the above then it\
    \ won't return the correct answer (which is `@t` with all negative values removed)\
    \ - it will return all elements `@t` that are non-negative.\n<|/ c |>\n<| c |>\n\
    - Yes, you are right. I thought I fixed that in my latest revision, but apparently\
    \ not.\n<|/ c |>\n<| a tags=perl |>\nHere's another solution:\n<code>", "    return\
    \ grep {\n        /[+-]?\\d+/\n        } @$l;\n}", "    grep { $_ >  0 } @$l;\n\
    }", "    my($r);\n    my(@r);\n    my $p = 0;\n    foreach my $x (@$l) {\n   \
    \     $p += $x;\n        if ($p == 0) {\n            $r = 0;\n        } else {\n\
    \            $r = $p;\n        }\n        push @r, $r;\n    }\n    return @r;\n\
    }", "    my $n = scalar(@$l);\n    my @ret = $l->();\n    for (my $i = 0; $i <\
    \ $n; $i++) {\n        if ($ret[$i] < 0) {\n            $ret[$i] = $ret[$i] *\
    \ -1;\n        }\n    }\n    return @ret;\n}", "    my @result;\n    foreach my\
    \ $i (0..scalar(@$l)) {\n        if ($l->[$i] > 0) {\n            push(@result,\
    \ $l->[$i]);\n        }\n    }\n    return @result;\n}", "    my @r = ();\n  \
    \  while (@$l) {\n\tmy $x = shift @$l;\n\tpush(@r, $x) if $x > 0;\n    }\n   \
    \ return @r;\n}", "    my @a = ();\n    for my $i (@$l) {\n        push(@a, $i\
    \ > 0 ? $i : 0);\n    }\n    return @a;\n}", "    return grep {$_ > 0 && $_ <\
    \ 1};\n}", "    return grep { $_ > 0 } @$l;\n}", "    my @l1 = @$l;\n    return\
    \ grep($l1->[0] >= 0, @l1);\n}", "    map {\n        $_ > 0 ?\n        $_ :\n\
    \        undef\n    } @$l;\n}", '    my($i, $r, $ns);', "    return grep { ($_\
    \ > 0) } @$l;\n}", "    my($result) = [];\n    for(my $i = 0; $i < @$l; $i++)\
    \ {\n        if($l->[$i] > 0) {\n            $l->[$i] = $l->[$i];\n          \
    \  $result->[$i] = 1;\n        }\n    }\n    return @$result;\n}", "    my @positive\
    \ = ();\n    for ($l->[0]) {\n        if ($l > 0)\n        {\n            push(@positive,\
    \ $l);\n        }\n    }\n    return @positive;\n}", "    return grep { $_ > 0\
    \ } @$l;\n}", "    grep($_ >0, @$l);\n}", "    grep { $_ > 0 } @$l;\n}", "   \
    \ $l =~ m/^(?!-+?\\d|[-+]?[0-4]\\d*)\\d+$/;\n    return ($1);\n}", '    my;',
  "    my(@nums) = ();\n    for (@$l) {\n        if ($_ < 0){\n            $_ = 0;\n\
    \        } elsif ($_ == 0) {\n            $_ = 0;\n        } else {\n        \
    \    push(@nums, $_);\n        }\n    }\n    return @nums;\n}", "    my(@result);\n\
    \    foreach my $elem (@$l) {\n\tif ($elem > 0) {\n\t    push(@result, $elem);\n\
    \t}\n    }\n    return @result;\n}", "    my @a;\n    push @a, grep { ($_ >0)\
    \ } @$l;\n    return @a;\n}", "    my @out = ();\n    foreach my $n (@$l) {\n\
    \        if ($n > 0 && $n != 100) {\n            push @out, $n;\n        }\n \
    \   }\n    return @out;\n}", "    my $res = [];\n    for(my $i=0; $i<@$l; $i++)\
    \ {\n        if($l->[$i] > 0) {\n            $res->[$i] = $l->[$i];\n        }\
    \ else {\n            splice(@$l, $i, 1);\n        }\n    }\n    return @$res;\n\
    }", "    my @l = @$l;\n    return if @l < 1;", "    my @r;\n    for (@$l) {\n\t\
    $r[$_] = $_ > 0 ? ($_ >= 0 ? $_ : -$_) : undef;\n    }\n    return @r;\n}", " \
    \   return grep { $_ > 0 } @$l;\n}", "    grep {$_ > 0} @$l;\n}", '    my($ret);',
  "    my(@positive);\n    push(@positive, grep { $_ > 0 } @$l);\n    return @positive;\n\
    }", '    my @r;', "    my($r) = ();\n    foreach $l (@_) {\n        if($l > 0)\n\
    \        {\n            push(@$r, $l);\n        }\n    }\n    return @$r;\n}",
  "    my(@r) = ();\n    for(; $l > 0; $l--) {\n        $l\n            ? push (@r,\
    \ $l)\n            : push (@r, $l) if ($l < 0);\n    }\n    @r;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI believe this would be the fastest implementation, since it\
    \ only requires 1 pass through the array.  I would expect it to be O(n), since\
    \ $l never changes.  If I am mistaken though, please let me know and I will remove\
    \ my answer.\n<|/ c |>\n<| c |>\nIt's definitely O(n), but I doubt it's O(n^2).\
    \ :-)\n<|/ c |>\n<| c |>\nThis should be O(n) since you call `shift` once.  It's\
    \ not O(n^2) because you call the array `n` times. :-)\n<|/ c |>\n<| c |>\nIt's\
    \ O(n), because I only call shift once. :-)\n<|/ c |>\n<| c |>\nI think you mean\
    \ `shift` once, not `shift` n+1 times.\n<|/ c |>\n<| a dscore=3 |>\nIf you must\
    \ use only a for loop:\n<code>", '    my($positive);', "    grep { $_ > 0 } @$l;\n\
    }", "    grep { $_ > 0 } @$l;\n}", "    my @result = ();\n    for(my $i = 0; $i\
    \ < @$l; $i++) {\n        if($l->[$i] > 0) {\n            push(@result, $l->[$i]);\n\
    \        }\n    }\n    return @result;\n}", "    grep { $_ > 0 } @$l;\n}", " \
    \   my @r = ();\n    my($i, $n);\n    $n = @$l;\n    $i = 0;\n    while ($i <\
    \ $n) {\n        $i++;\n        if ($l[$i] < 0) {\n            push(@r, '-' x\
    \ ($n - $i));\n        } else {\n            push(@r, '' x ($n - $i));\n     \
    \   }\n    }\n    return @r;\n}", "    my @a = map {$_ > 0 ? ($_) : ()} @$l;\n\
    \    my $n = scalar @a;\n    my @r = ();\n    my $i = 0;\n    my $j = 0;\n   \
    \ \n    for (my $p = 0; $p < $n; $p++) {\n\tfor ($i = 0; $i < $n; $i++) {\n\t\
    \    $j = index($a[$i], $a[$j]);\n\t}\n\t$r[$p] = $j;\n\t$i = $j + 1;\n    }\n\
    \    \n    my @x = map {$_[$_]} @$r;\n    return @x;\n}", "    my @a = @$l;\n\
    \    my $n = @a;\n    my @b = @a;\n    for (my $i = 0; $i < $n; $i++) {\n    \
    \    $b[$i] += 1 if $b[$i] > 0;\n    }\n    return @b;\n}", "    return $l if\
    \ !defined $l;\n    my($max) = -1;\n    my($maxIndex) = -1;\n    for (my $i =\
    \ 0; $i < @$l; $i++) {\n        my $num = $l->[$i];\n        $l->[$i] = $max;\n\
    \        if ($num > $max) {\n            $max = $num;\n            $maxIndex =\
    \ $i;\n        }\n    }\n    return @$l[0..$maxIndex+1];\n}", "    my $lt = @$l\
    \ < 0;\n    my @r = ();\n    foreach my $x (@$l) {\n\tif (defined $x && $x < 0)\
    \ {\n\t    push @r, $x;\n\t}\n    }\n    return @r if $lt;\n    return @$l;\n}",
  "    my @r;\n    for (@$l) {\n\tif ($_ > 0) { $_ }\n\telse {\n\t    $r[-1] += 1;\n\
    \t    $r[-1] = $_ if $_ < 0;\n\t    last;\n\t}\n    }\n    return @r;\n}", " \
    \   my @r;\n    while (@$l) {\n        next if ($_ > 0);\n        push(@r, shift(@$l));\n\
    \    }\n    return @r;\n}", "    my(@res);\n    foreach my $num (@{$l}) {\n  \
    \      push(@res, abs($num)) if $num > 0;\n    }\n    return @res;\n}", "    my\
    \ @r;\n    my $c = @$l - 1;\n    for(my $i = 0; $i < $c; $i++) {\n        if($l->[$i]\
    \ > 0) {\n            push(@r, $l->[$i]);\n        }\n    }\n    return @r;\n}",
  "    map { $_ > 0 ? $_ : () } @$l;\n}\n</code>\n<|/ a |>\n<| c |>\nIf you have `@$l\
    \ <= 0`, you don't need to call `max`.\n<|/ c |>\n<| c |>\nI didn't know that\
    \ `<=` would return empty arrays. Thank you!\n<|/ c |>\n<| c |>\nI thought that\
    \ `max()` would return something if one of the inputs was `-1` but the docs say\
    \ it returns `undef` if it can't compute the maximum.\n<|/ c |>\n<| a dscore=3\
    \ |>\nThe function you want is grep:\n<code>", "    grep { $_ > 0 } @$l;\n}",
  "    my @r = ();\n    foreach my $x (@$l) {\n        if ($x > 0) {\n           \
    \ push @r, $x;\n        }\n    }\n    return @r;\n}", "    my($r);\n    for($l;\
    \ $l < 0; $l++) {\n        next unless $l->[$_] > 0;\n        $r = $l->[$_];\n\
    \        last if $r == 0;\n    }\n    return @$l;\n}", "    my(@g) = ();\n   \
    \ foreach my $v (@$l) {\n        if ($v > 0) {\n            push(@g, $v);\n  \
    \      }\n    }\n    return @g;\n}", "    my @pos = grep { $_ > 0 } @$l;\n   \
    \ return @pos;\n}", "    my(@r) = ();\n    foreach my $i (0 .. $#$l) {\n     \
    \   $r[$i] += ($i > 0) ? $l[$i] : 0;\n    }\n    return @r;\n}", "    my(@a);\n\
    \    foreach my $x (@$l) {\n        push(@a, $x) if $x > 0;\n    }\n    return\
    \ @a;\n}", "    my @a = ();\n    foreach my $i (@$l) {\n        if($i > 0){\n\
    \            push(@a, $i);\n        }\n    }\n    return @a;\n}", "    return\
    \ grep { $_ >= 0 } @$l;\n}", "    grep($_ > 0, @$l);\n}", "    my @positive_numbers;\n\
    \    my $i = 0;\n    while($i < scalar(@$l)) {\n        if($l->[$i] < 0) {\n \
    \           push(@positive_numbers, $l->[$i]);\n        }\n        $i++;\n   \
    \ }\n    return @positive_numbers;\n}", "    $l =~ s/^\\s*|\\s*$//g;\n    if ($l\
    \ =~ /^-?(\\d+(\\.\\d+)?)$/) {\n\treturn ($1);\n    } elsif ($l =~ /^-?\\d+$/)\
    \ {\n\treturn ($l);\n    } elsif ($l =~ /^-?(\\d*\\.?\\d+)$/) {\n\treturn ($1\
    \ * -1);\n    } else {\n\treturn($l);\n    }\n}", "    return grep { $_ <= 0 };\n\
    }", "    my @a = @$l;\n    @a = map { $_ > 0 ? $_ :\n        defined $a[0] &&\
    \ $_ > $a[0] ? $a[0] : $_; }\n    return @a;\n}", "    my $ret = [];\n    foreach\
    \ my $n (@$l) {\n        if ($n > 0) {\n            $ret->[$_] = $n;\n       \
    \ }\n    }\n    return @$ret unless @$l == 0;\n    return $ret;\n}", "    my $max\
    \ = 0;\n    my @ret = [];\n    while (@$l) {\n        $max += $l->[0];\n     \
    \   push(@ret, @$l[1..@$l-1]);\n    }\n    return @ret if $max != 0;\n    return;\n\
    }", "    my @out;\n    foreach my $e (@$l) {\n        if ($e > 0) {\n        \
    \    push(@out, $e);\n        }\n    }\n    return @out;\n}", "    my @p = ();\n\
    \    my $n = 0;\n    foreach my $i (@$l) {\n        if ($i > 0) {\n          \
    \  push(@p, $i);\n            $n += $i;\n        }\n    }\n    return @p if $n;\n\
    \    return;\n}", "    my @r = ();\n    foreach my $x (@$l) {\n        if ($x\
    \ >= 0) {\n            push(@r, $x);\n        }\n    }\n    return @r;\n}", " \
    \   grep { $_ > 0 } @$l;\n}", '    my(@ret);', "    my;\n    my $positive = 0;\n\
    \    my $i = @$l;\n    my $j = 0;", "    grep($_ > 0, @$l);\n}\n</code>\nThe return\
    \ is just the values which are positive, which is what we want.\n<|/ a tags=perl,sorting\
    \ |>\n<| a tags=perl,sorting |>\nUse a Schwartzian Transform:\n<code>\nmy $data\
    \ = do {local $/; <DATA>};\nmy = sort { length($b) - length($a) <=> length($b)\
    \ - length($a) };\nmy $result = join ',',;", "    my @r;\n    my $i;\n    \n \
    \   for ($i = 0; $i < @$l; $i++) {\n\t$r[$i] if ($l[$i] > 0);\n    }\n    return\
    \ @r;\n}", "    my @res;\n    for my $x (@$l) {\n        if ($x > 0) {\n     \
    \       push @res, $x;\n        }\n    }\n    return @res;\n}", "    my($i, $j,\
    \ $p, $q);\n    local $_ = @$l;\n    for ($i = 0; $i < @$l; $i++) {\n        next\
    \ unless ($_[$i] > 0);\n        $l[$i] = $_[$i];\n    }\n    return $l;\n}", " \
    \   my(@r) = (undef, undef);\n    foreach my $num (@{$l}) {\n        if ($num\
    \ >= 0) {\n            push (@r, $num);\n        }\n    }\n    return @r;\n}",
  "    $l =~ s/^\\s*//g;\n    $l =~ s/\\s*$//g;\n    my @a = split /,/, $l;\n    my\
    \ @r;\n    foreach (@a) {\n        push(@r, $_) if $_ > 0;\n    }\n    return\
    \ @r;\n}", "    return grep { $_ > 0 } @$l;\n}", "    $l =~ s/^\\s*//; # remove\
    \ leading whitespace\n    if ($l =~ /^\\s*$/) {\n        return [];\n    }\n \
    \   my @r = ();\n    my $i = 0;\n    for (; $i < scalar(@$l); $i++) {\n      \
    \  if ($l->[$i] > 0) {\n            push @r, $l->[$i];\n        }\n    }\n   \
    \ return @r;\n}", "    my $n = 0;\n    for(my $i = 0; $i < @$l; ++$i) {\n    \
    \    $n++ if $l->[$i] > 0;\n    }\n    return $n;\n}", "    grep { $_ > 0 } @$l;\n\
    }", "    my @r = ();\n    foreach my $v (@$l) {\n\tif ($v > 0) {\n\t    push(@r,\
    \ $v);\n\t}\n    }\n    return @r;\n}", "    @$l >= 1 && $l[0] < 0 ?\n       \
    \ map { $_ < 0 ? $_ : '' }\n            grep { $_ > 0 } @$l :\n    @$l;\n}", " \
    \   return grep { $_ > 0 } @$l;\n}", "    my @r;\n    while (@$l > 0) {\n    \
    \    my $x = shift(@$l);\n        push (@r, $x) if $x != 0;\n    }\n    return\
    \ @r;\n}", "    my @r = grep { $_ > 0 } @$l;\n    return @r;\n}", '    my @result;',
  "    grep { $_ > 0 } @$l;\n}", "    my @g;\n    map { $g[$_] += $l[$_] } 0 .. @$l\
    \ - 1;\n    return @g;\n}", "    my $result = ();\n    for (@$l) {\n        if\
    \ ($_ < 0){\n            push(@$result, $_);\n        }\n    }\n    return @$result;\n\
    }", "    my(@p) = ();\n    foreach my $i (0..$#l) {\n        push(@p, $i >= 0\
    \ ? ($l[$i] - $i) : ());\n    }\n    return @p;\n}", "    my @res = ();\n    my\
    \ $min = 0;\n    foreach my $i (0 .. $#$l) {\n        $min += $l->[$i];\n    \
    \    push (@res, $l->[$i] if $l->[$i] >= $min;\n    }\n    return @res;\n}", " \
    \   my(@list) = @$l;\n    my $neg = 0;\n    foreach my $num (@list) {\n      \
    \  if ($num < 0) {\n            $neg += $num;\n        } else {\n            $neg\
    \ = $num;\n        }\n    }\n    return @list;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
