name: HumanEval_30_get_positive
language: pl
prompt: "# Return only positive numbers in the array.\n# >>> get_positive([-1, 2,\
  \ -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1,\
  \ -10])\n# [5, 3, 2, 3, 9, 123, 1]\nsub get_positive {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_positive;\n\
  \        if(eq_deeply($candidate->([-1, -2, 4, 5, 6]),[4, 5, 6])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ -2]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    grep { $_ > 0 } @$l;\n}", "    my @r;\n    my $sign;", "    my\
    \ @pos = grep { $_ > 0 } @$l;\n    return @pos;\n}", "    return grep { $_ > 0\
    \ } @$l;\n}", "    grep { $_ > 0 } @$l;\n}", "    grep {$_ > 0} @$l;\n}", "  \
    \  grep { $_ > 0 } @$l;\n}", "    $l =~ s/^\\s+//; # Remove leading spaces.\n\
    \    my @l = split //, $l;\n    my @r = map { $l[$_] > 0 ? $l[$_] : 0 } 0..$#l;\n\
    \    return @r;\n}", "    @$l =~ m/^(?!(-?0x)?0*)?((-?0x)?([1-9][0-9]*)|((1[0-6])|((0?[1-9])|(10|11|12)))(\\\
    .[0-9]+)?|0x?[1-9]+[0-9]*\\.[0-9]+)/sx;\n    return $l if @$l > 0;\n    return;\n\
    }", "    my @r;\n    foreach my $n (@$l) {\n        if ($n > 0) {\n          \
    \  push(@r, $n);\n        }\n    }\n    @r;\n}", "    @$l =~ /^\\s*(-?\\d*)(\\\
    .\\d*)?([eE][-+]?\\d+)?\\s*$/ix\n        or croak \"Invalid number for get_positive:\
    \ @_\";\n    croak \"Invalid negative value for get_positive: @$l\"\n        if\
    \ (@$l < 1);\n    my $value = $1;\n    $value += 0.0 if ($2 < 0.0);\n    @$l =~\
    \ /^\\s*(-?\\d*)(\\.\\d*)?([eE][-+]?\\d+)?\\s*$/ix\n        or croak \"Invalid\
    \ number for get_positive: @_\";\n    croak \"Invalid negative value for get_positive:\
    \ @$l\"\n        if (@$l < 1);\n    my $neg = $1;\n    $neg -= 0.0 if ($2 < 0.0);\n\
    \    $neg = ($2 < 0.0) ? -$neg : $neg;\n    $value = -$value;\n    $value = ($2\
    \ < 0.0) ? $value + $neg : $value;\n    @$l =~ /^\\s*(-?\\d*)(\\.\\d*)?([eE][-+]?\\\
    d+)?\\s*$/ix\n        or croak \"Invalid number for get_positive: @_\";\n    croak\
    \ \"Invalid negative value for get_positive: @$l\"\n        if (@$l < 1);\n  \
    \  my $neg = $1;\n    $neg -= 0.0 if ($2 < 0.0);\n    $neg = ($2 < 0.0) ? -$neg\
    \ : $neg;\n    $value = -$value;\n    $value = ($2 < 0.0) ? $value + $neg : $value;\n\
    \    return $value;\n}", '    my($ret);', "    map { $_ > 0 ? $_ : () } @$l;\n\
    }", "    return grep { $_ >  0 } @$l;\n}", "    my($n) = 0;\n    my(@r) = (@$l);\n\
    \    foreach $x (@$l) {\n        if ($x < 0) {\n            $n++;\n          \
    \  push @r, $x;\n        }\n    }\n    @$l = @r;\n    @$l = sort @$l;\n    @$l;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=perl,arrays |>\n<code>", "    my @a;\n\
    \    while (@$l > 0) {\n        push (@a, shift @$l) if $_[0] > 0;\n    }\n  \
    \  return @a;\n}", "    return grep { $_ > 0 } @$l;\n}", "    $l =~ s/^\\s*(\\\
    S+)\\s*$/\\$1,/s;\n    return $l unless $l =~ /^\\s*(\\d+)\\s*$/;\n    $1 eq '0'\
    \ ? [] : [$1];\n}", "    my($i, $j, @out);\n    foreach (@$l) {\n        next\
    \ if $_ < 0;\n        $j++;\n    }\n    my $i = 0;\n    for (; $i < $j; $i++)\
    \ {\n        push(@out, $l[$i]);\n    }\n    return @out;\n}", "    return map\
    \ { $_ > 0 ? $_ : () } @$l;\n}", "    my @a;\n    my @b;\n    my $i;\n    my $j;\n\
    \    my $k;", "    my @result = ();\n    for (@$l) {\n        push(@result, $_)\
    \ if $_ >= 0;\n    }\n    return @result;\n}", "    my @x;\n    my @y;\n    my\
    \ $n = 0;\n    for(@$l) {\n        if($_ < 0) {\n            $n++;\n        }\
    \ else {\n            push @x, $_;\n        }\n    }\n    for(@$l) {\n       \
    \ if($_ < 0) {\n            push @y, $_;\n        }\n    }\n    return @x if $n;\n\
    \    return @y;\n}", "    my @positive = ();\n    my $num_positive = 0;", "  \
    \  my(@r) = (0);\n    for (my $i = 0; $i < @$l; ++$i) {\n        if ($l->[$i]\
    \ > 0) {\n            push(@r, $l->[$i]);\n        }\n    }\n    return @r;\n}",
  "    grep { $_ > 0 } @$l;\n}", "    return grep { $_ > 0 } @$l;\n}", "    my @r\
    \ = ();\n    foreach my $x (@$l) {\n\tif ($x > 0) {\n\t    push(@r, $x);\n\t}\n\
    \    }\n    @r;\n}", "    my @ret = ();\n    for my $x (@$l) {\n        if ($x\
    \ > 0) push(@ret, $x);\n    }\n    return @ret;\n}", "    return grep { $_ > 0\
    \ } @$l;\n}", "    my @t = ();\n    while (@$l) {\n        push @t, grep { $_\
    \ > 0 } @$l;\n        splice @$l, @-@;\n    }\n    return @t;\n}\n</code>\nIf\
    \ your perl version is older than 5.14, use\n<code>", "    grep { $_ >= 0 } @$l;\n\
    }", "    my @out = ();\n    my $neg = 0;", "    grep { $_ > 0 } @$l;\n}", "  \
    \  return map { $l > 0 ? $l : () } @$l;\n}", "    my @ret = ();\n    my $i = 0;\n\
    \    my $j = 0;\n    foreach my $num (@$l) {\n        if ($num > 0) {\n      \
    \      $ret[$j] = $num;\n            $j++;\n        }\n        $i++;\n       \
    \ if ($i == @$l) {\n            push @ret, $ret[$j];\n        }\n    }\n    return\
    \ @ret;\n}", "    my @out;\n    for my $i (0 .. $#$l) {\n        if ($l->[$i]\
    \ > 0){\n            push @out, $l->[$i];\n        }\n    }\n    return @out;\n\
    }", "    my(@l);\n    push(@l, $_) while $l && !$l->[0];\n    push(@l, 1);\n \
    \   my $sign = shift @l == 1 ? -1 : 1;\n    map($sign*$_,@l);\n}", "    grep(defined($l->{pos}),\
    \ @$l);\n}", "    return grep { $_ >= 0 } @$l;\n}", "    my(@a) = @$l;\n    my(@b);\n\
    \    my($i, $j, $tmp);\n    my($k);", "    my @r = grep { ($_ > 0) } @$l;\n  \
    \  return @r;\n}", "    $l =~ s/^\\s*(-?\\d+)\\s*//;\n    map { $_ > 0 ? $_ :\
    \ () };\n}", '    my($ret);', "    my @result;\n    foreach my $i (@$l) {\n  \
    \      if ($i > 0) {\n            push(@result, $i);\n        }\n    }\n    return\
    \ @result;\n}", "    return grep { $_ > 0 } @$l;\n}", "    my @t = map { $_ >\
    \ 0 ? $_ : () } @$l;\n    @$l = @t;\n}", "    my @l = @$l;\n    my @r;\n    my\
    \ @r;\n    my $max = 0;\n    my $min = 0;\n    my $i = 0;\n    $i++;\n    for(my\
    \ $n = 0; $n < @l; $n++) {\n\tmy $m = 0;\n\t$i++;\n\tfor(my $j = 0; $j < $n; $j++)\
    \ {\n\t    my $x = $l[$j];\n\t    $i++;\n\t    for(my $k = 0; $k < $n; $k++) {\n\
    \t\t$i++;\n\t\tfor(my $l = 0; $l < $n; $l++) {\n\t\t    $i++;\n\t\t    $m = $l\
    \ if $l[$l] > $x;\n\t\t}\n\t    }\n\t    $m = $j if $l[$j] > $x;\n\t}\n\tmy $r\
    \ = $m;\n\t$i++;\n\tfor(my $j = 0; $j < $n; $j++) {\n\t    $i++;\n\t    for(my\
    \ $k = 0; $k < $n; $k++) {\n\t\t$i++;\n\t\tfor(my $l = 0; $l < $n; $l++) {\n\t\
    \t    $i++;\n\t\t    $r = $l if $l[$l] < $x;\n\t\t}\n\t    }\n\t    $r = $j if\
    \ $l[$j] < $x;\n\t}\n\tpush (@r, $r) if $r > $max;\n\tpush (@r, $r) if $r < $min;\n\
    \    }\n    @r;\n}", "    my @a = grep {$_ > 0} @$l;\n    return @a;\n}", "  \
    \  my @results;\n    for(my $i=0;$i<@$l;$i++) {\n        if($l->[$i] > 0) {\n\
    \            push(@results, $l->[$i]);\n        }\n    }\n    return @results;\n\
    }", "    my @result = ();\n    my $neg = 0;\n    for (@$l) {\n        if ($_ <=\
    \ 0) {\n            $neg++;\n        } else {\n            $_ > 0 ? push @result,\
    \ $_ : push @result, 0;\n        }\n    }\n    return @result;\n}", "    grep\
    \ { ($a < 0) == ($a != 0); } (@$l);\n}", '    return $l if $l && $l =~ /^\s*(\+?)\s*(.*)\s*$/;',
  "    my @r = ();\n    foreach my $x (@$l) {\n        if (defined $x) {\n       \
    \     push @r, $x if $x >= 0;\n        }\n    }\n    return @r;\n}", "    grep\
    \ { ($_ > 0) ? $_ : () } @$l;\n}", "    my $i = 0;\n    my @r = ();\n    while(@$l\
    \ >= 0) {\n\tpush @r, ($l->[$i] >= 0 ? $l->[$i] : 0);\n\t$i++;\n    }\n    return\
    \ @r;\n}", '    my @res;', "    my @a;\n    my $min = -10000;\n    my $max = 1000000;\n\
    \    for(my $i = @$l; $i; $i--) {\n        push(@a,$l->[$i] >= 0 ? ($l->[$i] >=\
    \ $min ? $l->[$i] : $min) : $l->[$i] >= $max ? $l->[$i] : $max);\n    }\n    return\
    \ @a;\n}", "    my @x = ();\n    foreach my $n (@$l) {\n        if ($n > 0) {\n\
    \            push(@x, $n);\n        }\n    }\n    return @x;\n}", "    my @r =\
    \ grep { $_ > 0 } @$l;\n    return @r;\n}", "    my(@ret);\n    \n    for (my\
    \ $i = 0; $i < @$l; $i++) {\n        my($val) = $$l[$i];\n        if ($val > 0)\
    \ {\n            push(@ret, $$l[$i]);\n        }\n    }\n    \n    return @ret;\n\
    }", "    grep { $_ > 0 } @$l;\n}", "    my @r;\n    for (my $x = 0; $x < @$l;\
    \ $x++) {\n        if ($l->[$x] > 0) {\n            push(@r, $l->[$x]);\n    \
    \    }\n    }\n    return @r;\n}", "    my @a;\n    my $n = scalar @$l;\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        $a[0] = $l->[$i] if ($l->[$i] <= 0);\n\
    \    }\n    return @a;\n}", "    my @a = grep { $_ >= 0 } @$l;\n    return @a;\n\
    }", "    my @positive;\n    foreach my $i (@$l) {\n        if ($i < 0) {\n   \
    \         push @positive, $i;\n        }\n    }\n    return @positive;\n}", " \
    \   my @r;\n    my ($min, $max);\n    $min = $$l[0];\n    $max = $$l[0];\n   \
    \ foreach my $e ( reverse @$l) {\n        if ( $e < $min ) {\n            $min\
    \ = $e;\n        }\n        if ( $e > $max ) {\n            $max = $e;\n     \
    \   }\n    }\n    for (my $i = $#$l ; $i >= 0 ; $i--) {\n        push @r, $i if\
    \ $l[$i] >= $min;\n    }\n    return @r;\n}\n</code>\nNow all we need is an operator\
    \ that can test whether a list is all negative. Here I use the grep function:\n\
    <code>", "    my @ret = (0);\n    my ($i, $j, $tmp);\n    \n    for ($i = 0; $i\
    \ < @$l; ++$i) {\n        push(@ret, 0);\n    }\n    for ($j = 0; $j < @$l; ++$j)\
    \ {\n        $tmp = $ret[$j];\n        $ret[$j] = $ret[$i] + $tmp if $tmp > 0;\n\
    \        $ret[$j] = $ret[$i] + 1 if $tmp == 0;\n    }\n    return @ret;\n}", " \
    \   my @a = sort { $a <=> $b } @$l;\n    push @a, $l->[-1] unless @a == 1;\n \
    \   return @a;\n}", "    my @pos = grep {$_ > 0} @$l;\n    \n    if (@pos) {\n\
    \        return @pos;\n    } else {\n        return $l;\n    }\n}", "    my @out\
    \ = ();\n    for my $x (@$l) {\n        push(@out, $x if $x > 0);\n    }\n   \
    \ return @out;\n}", "    my @r = ();\n    my $sign = 1;\n    for my $num (@$l)\
    \ {\n        $sign = $sign * ($num < 0);\n        push @r, $num if $sign;\n  \
    \  }\n    return @r;\n}", "    my @r; @r = grep { $_ > 0 } @$l;\n    return @r;\n\
    }", "    return grep { $_ > 0 } @$l;\n}", "    $l =~ s/^\\s*([^\\s].*?)\\s*$1/$1/;\n\
    \    my(@numbers);\n    foreach my $num (@$l) {\n        if ($num >= 0) {\n  \
    \          push(@numbers, $num);\n        }\n    }\n    return @numbers;\n}",
  "    $l =~ s/^\\s*//;\n    return $l if $l =~ /^[^-]+/;\n    my @a = ();\n    foreach\
    \ my $x (@$l) {\n        $x = $x > 0 ? $x : $_;\n        push(@a, $x);\n    }\n\
    \    return @a;\n}", "    my(@result);\n    my($num);", "    $l =~ s/^\\s*(-?)([0-9]+)/$2$1/;\n\
    \    if ( $l eq '' ) { $l = 0; } else { $l = -$l }\n    $l;\n}", "    grep { $_\
    \ gt 0 } @$l;\n}", "    $l[$_] for grep($_ >=0, @_);\n}", "    my(@result) = (());\n\
    \    foreach my $number (@$l) {\n        if ($number > 0) {\n            push(@result,\
    \ $number);\n        }\n    }\n    return @result;\n}", "    grep { $_ > 0 } @$l;\n\
    }", "    my$c = scalar(@$l);\n    if ($c <= 0) {\n\treturn;\n    }\n    my@$l\
    \ = ();\n    for ($c--; $c >= 0; $c--) {\n\tif ($l[$c] > 0) {\n\t    $l[$c] =\
    \ $l[$c] - 1;\n\t    push(@$l, $l[$c]);\n\t    last;\n\t} else {\n\t    next;\n\
    \t}\n    }\n    return;\n}", "    my($n, $i, $k, $t);\n    my(@r);", "    my @result\
    \ = ();\n    foreach my $x (@$l) {\n        push(@result, $x if $x > 0);\n   \
    \ }\n    return @result;\n}", "    my(@result) = ();\n    foreach(@$l) {\n   \
    \     if($_ > 0) {\n            push(@result, $_);\n        }\n    }\n    return\
    \ @result;\n}", "    my @positive = ();\n    foreach my $e (@$l) {\n        if\
    \ ($e > 0) {\n            push(@positive, $e);\n        }\n    }\n    return @positive;\n\
    }", "    my @a = @$l;\n    for (my $n = 0; $n < @a; ++$n) {\n        if ($a[$n]\
    \ < 0)\n        {\n            @a = @a - $n;\n            splice(@$l, $n, @a);\n\
    \        }\n    }\n    return @$l;\n}", "    my(@g) = ();\n    foreach $i (@$l)\
    \ {\n        if($i > 0 && $i < 1) {\n            push @g, $i;\n        }\n   \
    \ }\n    @$l;\n}", "    my(@a) = @$l;\n    my @b = ();\n    for(my $i = 0; $i\
    \ < @a; ++$i) {\n        if ($a[$i] >= 0) {\n            push(@b, $a[$i]);\n \
    \       }\n    }\n    return @b;\n}", "    my($i, $j);\n    my($k, $l);", "  \
    \  my @positive_numbers;\n    for(@$l) {\n        if($_ > 0) {\n            push\
    \ @positive_numbers, $_;\n        }\n    }\n    return @positive_numbers;\n}",
  "    my(@r);\n    \n    # Find all positive numbers and add them to the result.\n\
    \    for (@$l) {\n\tpush @r, $_ if $_ > 0;\n    }\n    \n    return @r;\n}", " \
    \   my(@r); # Array ref\n    foreach my $x (@{$l}) {\n        if ($x > 0) push(@r,\
    \ $x);\n    }\n    return @r;\n}", "    $l =~ tr/+-/-+/;\n    return grep { $_\
    \ > 0 } @$l;\n}", "    my $positive;\n    foreach my $num (@$l) {\n        if($num\
    \ > 0) {\n            $positive->[$_] = $num;\n        }\n    }\n    return $positive;\n\
    }", "    my $result = [];\n    foreach my $num (@$l) {\n        if ($num > 0)\
    \ {\n            $result->[$#result + 1] = $num;\n        }\n    }\n    $result;\n\
    }", "    my;\n    foreach my $v (@$l) {\n        if ($v > 0) {\n            push(@r,\
    \ $v);\n        }\n    }\n    return \\@r;\n}", "    my @a = @$l;\n    my @new;\n\
    \    foreach my $e (0..$#a) {\n        if ($a[$e] > 0){\n            push(@new,\
    \ $a[$e]);\n        }\n    }\n    return @new;\n}", "    my @r;\n    foreach my\
    \ $num (@$l) {\n        push(@r, $num) if $num > 0;\n    }\n    return @r;\n}",
  "    my @r = ();\n    foreach my $x (@$l) {\n        if ($x > 0) {\n           \
    \ push(@r, $x);\n        }\n    }\n    return @r;\n}", "    my @r;\n    foreach\
    \ my $x (@$l) {\n        push(@r, $x if $x > 0);\n    }\n    return @r;\n}", " \
    \   my @a = ();\n    while(@$l) {\n        push($a, $_[0]) if $_[0] >= 0;\n  \
    \      shift @$l;\n    }\n    @a;\n}", "    my($i);\n    my($n);\n    my($y);",
  "    my @result = ();\n    my @l = @$l;\n    my @pos = ();\n    my %found = ();",
  "    grep { $_ > 0 } @$l;\n}", "    my(@r) = (@$l);\n    foreach $i (0 .. $#$l -\
    \ 1) {\n        my $pos = $r[$i] > 0;\n        $r[$i] = $pos;\n    }\n    @r;\n\
    }", "    my($i, $v);\n    my @positive;\n    \n    foreach $i (@$l) {\n      \
    \  if($i >= 0) {\n            push(@positive, $i);\n        }\n    }\n    return\
    \ @positive;\n}", "    return grep { $_ > 0 } @$l;\n}", "    return @$l if $l->[0]\
    \ > 0;\n    return;\n}", "    return map { $_ > 0 ? $_ : '' };\n}", "    my(@pos)\
    \ = (0);\n    my($i, $n);\n    for(my $i = 0; $i < $#l; ++$i) {\n        if($l[$i]\
    \ < 0) {\n            push(@pos, $l[$i]);\n        } else {\n            $n =\
    \ $l[$i];\n            for(my $j = 0; $j < $i - $n; ++$j) {\n                $n\
    \ = $n / 2;\n            }\n            push(@pos, $n);\n        }\n    }\n  \
    \  while(scalar @pos > 0) {\n        splice(@pos, 0, 1);\n    }\n    return @pos;\n\
    }", "    my @x;\n    my $max = -1;\n    foreach my $i ( @$l ) {\n        if( $i\
    \ >= 0 ) {\n            push @x, $i;\n            $max = $i if $i > $max;\n  \
    \      }\n    }\n    return @x;\n}", "    my @x;\n    my $i = 0;\n    $l->each()\
    \ {\n        push(@x, $_) if $_ > 0 && $i < $#_;\n        $i++;\n    };\n    @x;\n\
    }", "    my@l;\n    my ($n);\n    my $neg;\n    foreach $n (@$l) {\n        if\
    \ ($n < 0) {\n            $neg = 1;\n        }\n        else {\n            push(@l,\
    \ abs($n));\n        }\n    }\n    if ($neg) {\n        @l = reverse @l;\n   \
    \ }\n    return @l;\n}", "    my;\n    for(my $i=0; $i<@$l; $i++) {\n        if\
    \ ($l->[$i] > 0) {\n            push(@res, $l->[$i]);\n        }\n    }\n    return\
    \ @res;\n}", "    my $res = [];\n    for (my $i=0; $i<@$l; $i++) {\n        $res[$i]\
    \ = $l->[$i] > 0 ? $l->[$i] : undef;\n    }\n    return $res;\n}", "    my(@g)\
    \ = ();\n    foreach my $item (@$l) {\n        if ($item < 0) {\n            push(@g,\
    \ $item);\n        }\n    }\n    return @g;\n}", '    my(@res);', "    my $positive\
    \ = ();\n    my $negative = ();\n    foreach my $i (@$l) {\n        if($i < 0)\
    \ {\n            push(@$negative, $i);\n        }\n        else {\n          \
    \  push(@$positive, $i);\n        }\n    }\n    return $positive;\n}", "    my\
    \ @a;\n    foreach my $item (@$l) {\n\tpush @a, $item if $item > 0;\n    }\n \
    \   return @a;\n}", "    map { $_ > 0 ? $_ : undef } @$l;\n}", "    my @ret;\n\
    \    my($i, $n);\n    foreach $i (0 .. $#$l){\n        $n = $l->[$i];\n      \
    \  if ($n >= 0){ push(@ret, $n); }\n    }\n    return @ret;\n}", "    @$l =~ /-?\\\
    d+/g;\n    @$l > 0 ? @$l : ()\n}", "    my @resultant;\n    my $i;\n    my $positive;\n\
    \    $positive = 0;\n    for ($i = 0; $i <= $#$l; $i++) {\n        if ($l->[$i]\
    \ > 0) {\n            $positive++;\n        } else {\n            unless ($positive)\
    \ {\n                $positive++;\n                push @resultant, $l->[$i];\n\
    \            }\n        }\n    }\n    return @resultant if $positive == 0;\n \
    \   return undef;\n}", "    my($result);\n    while (@$l) {\n        push(@$result,\
    \ shift(@$l)) if $_ > 0;\n    }\n    return $result;\n}", '    my @l = @$l;',
  "    my @r;\n    for (@$l) {\n        push @r, $_ if $_ > 0;\n    }\n    return\
    \ @r;\n}", '    my(@r);', "    $l =~ s/-?\\d+//g;\n    $l =~ s/^\\s*//g;\n   \
    \ $l =~ s/\\s*$//g;\n    return $l;\n}", "    my($i, $tmp, @l2);\n    foreach\
    \ $i (@$l) {\n\t$tmp = $i;\n\tfor(my $j = 0; $j < $#l2; $j++) {\n\t    $tmp if\
    \ $l2 [$j] <= $tmp;\n\t}\n\tpush(@l2, $tmp);\n    }\n    @l2;\n}", "    grep {$_\
    \ > 0} @$l;\n}", "    my $llen = @$l;\n    my @a = @$l;\n    my @b;", "    my\
    \ $r = @$l > 0;\n    @$l = ($l ? $l[0] : undef);\n    return @$l;\n}", "    my\
    \ @a;\n    foreach(@$l) {\n\tif ($_ > 0) {\n\t    push(@a, $_);\n\t}\n    }\n\
    \    my @b;\n    foreach my $e (0..$#a) {\n\tpush(@b, $a[$e]);\n    }\n    return\
    \ @b;\n}", "    my $i = 0;\n    my @r;\n    while ($i < scalar(@$l)) {\n     \
    \   if ($l->[$i] > 0) {\n            push(@r, $l->[$i]);\n        }\n        ++$i;\n\
    \    }\n    return @r;\n}", "    @$l =~ /[+-]?\\d+/;\n    @$l =~ /[+-]\\d+/;\n\
    \    sort @$l;\n}", "    my @r;\n    my $neg;\n    my $sign;\n    foreach my $x\
    \ (@$l) {\n        $sign = $x > 0 ? 1 : -1;\n        push(@r, $sign * $x);\n \
    \       $neg = $x < 0;\n    }\n    return @r;\n}", "    my @p = ();\n    my $neg\
    \ = 0;", "    my @res;\n    my $i = 0;\n    my $neg;\n    \n    # Sort from small\
    \ to large.\n    foreach my $ele (@$l) {\n        if ($ele < 0) {\n          \
    \  $neg = 1;\n        }\n        else {\n            push @res, $ele unless $ele\
    \ > 0;\n        }\n    }\n    \n    # If all values are negative then return a\
    \ negative number instead.\n    if ($neg) {\n        return [-1];\n    }\n   \
    \ \n    # Return only the positive numbers.\n    @res = grep {$_ > 0};\n    return\
    \ @res;\n}", "    my @result = ();\n    for(my $x = $#l; $x >= 0; $x--) {\n  \
    \      push(@result, $l[$x] > 0 ? $l[$x] : 0);\n    }\n    return @result;\n}",
  "    my(@ret) = ();\n    for(@$l) {\n        push(@ret, defined($_) ? $_ :0);\n\
    \    }\n    return @ret;\n}", '    my @r;', "    my @res;\n    for(my $i = 0;\
    \ $i < @$l; ++$i) {\n        push(@res, $l->[$i] if (($l->[$i] >= 0)\n       \
    \                     || ($l->[$i] < (0))\n                            || ($l->[$i]\
    \ <= 0));\n    }\n    return @res;\n}", "    my(@r) = ();\n    for (@$l) {\n \
    \       if ($_ > 0) {\n            push(@r, $_);\n        }\n    }\n    @r;\n}",
  "    my %result;\n    for(my $i = 0; $i < @$l; $i++) {\n        if($l->[$i] > 0)\n\
    \            $result{$l->[$i]} = $i;\n    }\n    return \\%result;\n}", "    my\
    \ @pos = map {; $_ > 0 ? $_ : \"NaN\" } @$l;\n    return @pos;\n}", "    my @a;\n\
    \    foreach my $x (@$l) {\n        if ($x >= 0) {\n            push(@a, $x);\n\
    \        }\n    }\n    return @a;\n}", "    grep { $_ > 0 } @$l;\n}", '    my
    @ret = ();', "    grep { $_ > 0 } @$l;\n}\n</code>\nAvoid sub/for/foreach if you\
    \ can as it can be inefficient and can lead to some unpredictable behaviour -\
    \ e.g. see http://blogs.perl.org/users/tinita/2007/03/perl-array-iteration-order.html\n\
    See perldoc perlfunc and perldoc perllol for more information\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for the link!\n<|/ c |>\n<| a tags=arrays,perl,sorting |>\n\
    <code>\n #!/usr/bin/perl\n use strict;\n use warnings;", "    my($ret);\n    foreach\
    \ my $num (@$l) {\n        if ($num >= 0) {\n            push(@$ret, $num);\n\
    \        }\n    }\n    @$ret = sort(@$ret);\n    return @$ret;\n}", "    grep\
    \ { $_ > 0 } @$l;\n}", "    my @positive = ();\n    push(@positive, $l[0]) if\
    \ $l[0] > 0;\n    for (my $i = 1; $i < scalar(@$l); ++$i) {\n        if ($l[$i]\
    \ > 0) {\n            push(@positive, $l[$i]);\n        } else {\n           \
    \ last;\n        }\n    }\n    return @positive;\n}", "    my @a;\n    for (@$l)\
    \ {\n\tif ($_ < 0) { $_ = 0; }\n\telse {\n\t    push(@a, $_);\n\t}\n    }\n  \
    \  @a;\n}", "    grep {defined $_ && $_ gt 0} @$l;\n}", "    my;\n    foreach\
    \ my $i (@$l) {\n        $_ = ($i < 0) ? -$i : $i;\n        push(@new, $_);\n\
    \    }\n    return;\n}", "    my @s = ();\n    foreach my $i (@$l) {\n       \
    \ if ($i < 0) {\n            push(@s, $i);\n        }\n    }\n    return @s;\n\
    }", "    my(@r) = ();\n    foreach $x (@$l) {\n        if ($x < 0) {\n       \
    \     push(@r, $x);\n        }\n    }\n    @r;\n}", "    return grep { $_ > 0\
    \ } @$l;\n}", "    return grep { $_ > 0 } @$l;\n}", "    $l = reverse grep( !\
    \ $_, @$l );\n    $l;\n}", "    my @result;\n    my $sign = 1;\n    my $x;\n \
    \   $x = 0;\n    for my $i (0..$#$l) {\n        $x = $x + $l->[$i];\n        if\
    \ ($x > 0) {\n            $x = $x - $l->[$i];\n            $sign = 0;\n      \
    \  }\n    }\n    for my $i (0..$#$l) {\n        if ($l->[$i] < 0) {\n        \
    \    push @result, $l->[$i];\n        } else {\n            $l->[$i] = 0;\n  \
    \      }\n    }\n    push @result, $l->[$#$l] unless $sign;\n    return @result;\n\
    }", "    my $positive = [];\n    my $i = 0;\n    for my $val (@$l) {\n       \
    \ if ($val > 0) {\n            $positive[$i] = $val;\n        }\n        $i++;\n\
    \    }\n    @$l = @$positive;\n    return $l;\n}", "    my @positive = ();\n \
    \   foreach my $i (@$l) {\n\tpush @positive, $i if $i >= 0;\n    }\n    return\
    \ @positive;\n}", "    @$l = grep { ($_ >  0) || ($_ !~ /^0/) } @$l;\n    @$l\
    \ = grep { ($_ <= 0) || ($_ !~ /^0/) } @$l;\n    return @$l;\n}", "    $l =~ s/^\\\
    s*(-?\\d+)\\s*$/$1/;\n    if ($l =~ /^-?\\d+$/) {\n        return $l;\n    }\n\
    }", "    my(@r) = [];\n    foreach my $x (@$l) {\n        push(@r, $x > 0 ? $x\
    \ : 0);\n    }\n    return @r;\n}", "    my @a = ();\n    foreach my $x (@$l)\
    \ {\n        if($x < 0) {\n            push(@a, $x);\n        }\n    }\n    return\
    \ @a;\n}", "    my @r;\n    my $positive = 0;", "    my @r;\n    while (@$l >\
    \ 0) {\n        my $p = shift @$l;\n        push(@r, $p) if $p > 0;\n    }\n \
    \   return @r;\n}", "    my @out = ();\n    foreach my $item (@$l) {\n       \
    \ if ($item < 0) {\n            $item += 1;\n        }\n        push(@out, $item);\n\
    \    }\n    return @out;\n}", "    my $len = @$l;\n    return @$l[0..($len-1)]\
    \ if $len == 0;\n    my $max = 0;\n    my $min = @$l[0]>0 ? @$l[0] : 1;\n    foreach\
    \ my $x (@$l) {\n        $max = $x if $x>$max;\n        $min = $x if $x<$min;\n\
    \    }\n    return $min..$max if $min>$max;\n    return $min..$len if $len==1;\n\
    \    return $max;\n}", "    grep { $_ gt 0 } @$l;\n}", "    grep { ($l->[$_] >\
    \ 0) } 0..$#l;\n}", "    my@l;\n    for(@_) {\n        $l[-1]++ if $_ > 0;\n \
    \   }\n    @l\n}", "    my @result;\n    for (@$l) {\n\tpush(@result, $_) if $_\
    \ > 0;\n    }\n    @result;\n}", '    my(@r) = (0, 0);', "    my @r;\n    my $n\
    \ = @$l;\n    for (my $i = 0; $i < $n; $i++) {\n        if ($l->[$i] >= 0) {\n\
    \            push @r, $l->[$i];\n        }\n    }\n    return @r;\n}", "    my(@res);\n\
    \    my $sign = 1;\n    for (@_) {\n        $sign *= $_ > 0 ? 1 : -1;\n      \
    \  push, $_ if $_;\n    }\n    push, 1 if $sign < 0;\n    push, -1 if $sign >\
    \ 0;\n    return @res;\n}", "    my@l;\n    foreach my $x (@$l) {\n        return\
    \ if $x <= 0;\n        push(@l, $x);\n    }\n    @$l;\n}", "    return grep {\
    \ $_ gt 0 } @$l;\n}", "    return grep { $_ >= 0 } @$l;\n}", "    my @result;\n\
    \    foreach my $item (@$l) {\n        push(@result, $item if $item > 0);\n  \
    \  }\n    return @result;\n}", '    my @positive;', '    my(@ls);', "    my @new;\n\
    \    foreach my $x (@$l) {\n\tpush(@new, grep {($_ > 0) ? $_ : ()} @$x);\n   \
    \ }\n    return @new;\n}", "    my($result);\n    foreach my $i (@$l) {\n\tif\
    \ ($i <= 0) {\n\t    push (@$result, $i);\n\t}\n    }\n    return @$result;\n}",
  "    return grep { $_ > 0 } @$l;\n}", "    my @a;\n    $l = [sort {$a <=> $b} grep\
    \ { $_ > 0 } @$l];\n    return @$l;\n}", "    map { $_ > 0 ? $_ :() } @$l;\n}",
  "    $l =~ s/^\\s*//;\n    $l =~ s/\\s*$//;\n    my(@r) = ();\n    $l = \"$l\"\n\
    \tunless $l =~ /^(\\-?[0-9.]+)$/;\n    push(@r, $1);\n    while ($l =~ /^(\\-?[0-9.]+)\\\
    s*,\\s*(\\-?[0-9.]+)$/) {\n\tpush(@r, $1 + $2);\n    }\n    while (scalar@r >\
    \ 0 && $l->[$_] <=> $r->[$_] >= 0) {\n\tunshift(@r, shift(@r));\n    }\n    wantarray\
    \ ? @r : \\@r;\n}", "    my @ans = ();\n    foreach my $x (@$l) {\n        if\
    \ ($x > 0) {\n            push(@ans, $x);\n        }\n    }\n    return @ans;\n\
    }", "    return grep { $_ > 0 } @$l;\n}", "    my($pos);\n    my($last);\n   \
    \ \n    # Search for non-zero numbers.\n    # Skip all zero numbers.\n    # Skip\
    \ first number. Thus get all positive numbers.\n    my $first = 0;\n    my $length\
    \ = $l->[0];\n    for (my $i = 1; $i <= $length; $i++) {\n        if ($l->[$i]\
    \ > 0) {\n            next if $first == 0;\n            $first = 1;\n        }\n\
    \        $pos = $i;\n    }", "    grep { $_ > 0 } @$l;\n}", "    my @p;\n    foreach\
    \ my $i (@$l) {\n        if($i>0) {\n            push(@p, $i);\n        }\n  \
    \  }\n    return @p;\n}", "    my(@r) = [];\n    while(@$l) {\n\tpush @r, ($l[0]\
    \ > 0) ? $l[0] : 0;\n\tshift @$l;\n    }\n    return @r;\n}", "    my @r;\n  \
    \  for(my $i = 0;$i <  @$l;$i++){\n        $r[$i] = $l->[$i] if $l->[$i] > 0;\n\
    \    }\n    return @r;\n}", "    if ($l < 0 || !defined $l) { return (); }\n \
    \   return grep { $_ > 0 } @$l;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
