name: HumanEval_126_is_sorted
language: pl
prompt: "# Given an array of numbers, return whether or not they are sorted\n# in\
  \ ascending order. If array has more than 1 duplicate of the same\n# number, return\
  \ . Assume no negative numbers and only integers.\n# Examples\n# >>> is_sorted([5])\n\
  # 1\n# >>> is_sorted([1, 2, 3, 4, 5])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5])\n#\
  \ \"\"\n# >>> is_sorted([1, 2, 3, 4, 5, 6])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5,\
  \ 6, 7])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n# \"\"\n# >>> is_sorted([1,\
  \ 2, 2, 3, 3, 4])\n# 1\n# >>> is_sorted([1, 2, 2, 2, 3, 4])\n# \"\"\nsub is_sorted\
  \ {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_sorted;\n\
  \        if(eq_deeply($candidate->([5]),1)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 3, 2, 4, 5]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, 7]),\"\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3,\
  \ 2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([1, 2, 2, 2, 3, 4]),\"\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 3, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 2, 2, 3, 3, 4]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    my(@nums);\n    push(@nums, $lst[0]) while @$lst > 0;\n    my %seen;\n\
    \    foreach my $num (@nums) {\n        if (exists($seen{$num}++)) {\n       \
    \     return \"\";\n        }\n    }\n    foreach my $num (@nums) {\n        if\
    \ (!exists($seen{$num})) {\n            return 0;\n        }\n    }\n    return\
    \ 1;\n}", "    my $i = 0;\n    my @dupes;\n    while(scalar @$lst > 0) {\n   \
    \     my $item = shift @$lst;\n        my $j = $i;\n        while($j < scalar\
    \ @$lst && $lst->[$j] == $item) {\n            $j++;\n        }\n        unless(\
    \ $j == $i) {\n            $dupes[$i] = $item;\n            $i++;\n        }\n\
    \    }\n    return scalar(@dupes) > 0;\n}", "    my $sorted = 0;\n    my $has_dups\
    \ = 0;", "    my @counts;\n    my $cnt;\n    for my $num (@$lst) {\n\t$cnt = 0;\n\
    \tforeach my $counts (@counts) {\n\t    last if ($counts > $num);\n\t    $cnt\
    \ += 1;\n\t}\n\tpush @counts, $cnt;\n    }\n    if (@counts) {\n\tif ($counts[-1]\
    \ == 1) {\n\t    return 1;\n\t}\n\treturn \"\";\n    }\n    return 1;\n}", " \
    \   for my $val ( sort { $a <=> $b } @$lst ) {\n        return 0 if $val == $lst[0];\n\
    \    }\n    return 1;\n}", "    for my $i (0..$#lst) {\n        my $cmp = $lst[$i];\n\
    \        my $prev_cmp = $lst[$i - 1];\n        if ($cmp < $prev_cmp and $cmp >=\
    \ 0) {\n            return 1;\n        } elsif ($cmp > $prev_cmp and $cmp <= 0)\
    \ {\n            return \"\";\n        }\n    }\n    return 1;\n}", "    my $len\
    \ = scalar @$lst;\n    my $first = $lst[0];\n    my $last = $lst[$len - 1];\n\
    \    my $middle = int(($len - 1) / 2);", "    my %seen = ();\n    for (@$lst)\
    \ {\n        if (! exists $seen{$_}) {\n            $seen{$_} = 1;\n         \
    \   return 1;\n        }\n    }\n    return 0;\n}", "    my $len = scalar @$lst;\n\
    \    my $i;\n    for ($i = 0; $i < $len; $i++) {\n        my $t = $lst->[$i];\n\
    \        my $found;\n        for ($i = 0; $i < $len; $i++) {\n            if ($lst->[$i]\
    \ == $t) {\n                $found = 1;\n                last;\n            }\n\
    \        }\n        return 1 unless $found;\n    }\n    return '';\n}", "    my\
    \ $i = 1;\n    my $found = 0;\n    while ($i < scalar(@$lst)) {\n        my $value\
    \ = $lst->[$i];\n        next if ($value eq \"\");\n        my $test = $value;\n\
    \        while ($i < scalar(@$lst)) {\n            next if ($lst->[$i] eq $test);\n\
    \            $test = $lst->[$i];\n        }\n        last if ($test != $value);\n\
    \        $found = 1;\n        $i++;\n    }\n    return $found;\n}", '    my(@sorted_lst);',
  "    my @seen;\n    for my $val (@$lst) {\n        if (!exists $seen[$val]) {\n\
    \            push @seen, $val;\n        } else {\n            return \".\";\n\
    \        }\n    }\n    return $seen[0] <=> $seen[-1] || $seen[0] <=> 1;\n}", " \
    \   my @lst;\n    my $i = 1;", "    foreach my $l (@$lst) {\n        my %counts\
    \ = map {$_ => 1}\n            map {$_}\n            grep{!exists($counts{$_})}\n\
    \            sort {$a <=> $b} $lst;\n        my $same = exists $counts{$_} &&\
    \ $counts{$_} == 1;\n        return $same ? 1 : 0;\n    }\n    return 1;\n}",
  '    my(@arr);', "    my $count = scalar(@$lst);\n    my $min = $count - 1;", " \
    \   my $sorted = 1;\n    my $last = -1;\n    for my $val (@$lst) {\n        if\
    \ (($last + 1) > $val) { $sorted = \"\" }\n        if ($val == $last) {\n    \
    \        $sorted = \"\";\n            next;\n        }\n        $last = $val;\n\
    \    }\n    return $sorted;\n}", "    foreach my $i (0 .. $#$lst) {\n        my\
    \ $j = $i + 1;\n        if ( $lst->[$i] eq $lst->[$j] ) {\n            return\
    \ 1;\n        } elsif ( $lst->[$i] <=> $lst->[$j] ) {\n            return \"\"\
    ;\n        }\n    }\n    return 1;\n}", '    my %seen = ();', "    my $result\
    \ = 1;\n    my @list  = sort {$a <=> $b} @$lst;", "    # count number of times\
    \ each value appears in the array\n    my %counter;\n    $counter{$_}++ for (@$lst);\n\
    \    # make a list of all the values used in the array\n    # and count the number\
    \ of times each appears\n    my @used = map { $counter{$_}++ } @$lst;\n    # sort\
    \ by number of times each value appears\n    # and return false if any value is\
    \ not found in the array\n    return @$lst == @used ? 1 : 0;\n}", "    my $last\
    \ = -1;\n    my $flag = 0;\n    foreach my $i ( 0 .. $#{$lst} ) {\n        $flag\
    \ = 0;\n        if ($lst->[$i] eq $last) {\n            $flag++;\n        }\n\
    \        if ($flag > 1) {\n            return 1;\n        }\n        $last = $lst->[$i];\n\
    \    }\n    return '';\n}", "    # Sorting is faster than checking uniqueness,\
    \ and faster than\n    # doing a sort that doesn't do anything\n    # O(n * log\
    \ n)\n    my(@uniq_lst) = ();\n    my(@dup_lst) = ();\n    foreach my $elem (@$lst)\
    \ {\n        if( exists $uniq_lst[$elem] and $elem eq $uniq_lst[$elem] ) {\n \
    \           $dup_lst[$elem] .= \"$elem \";\n        } else {\n            $uniq_lst[$elem]\
    \ = $elem;\n        }\n    }\n    my(@sorted_lst) = ();\n    foreach my $elem\
    \ (@uniq_lst) {\n        push (@sorted_lst, $elem);\n    }\n    foreach my $elem\
    \ (@dup_lst) {\n        push (@sorted_lst, $elem);\n    }\n    my $ret = @sorted_lst\
    \ > 1 ? \"\" : \"1\";\n    $ret .= @sorted_lst == 1 ? \"\" : \"s\";\n    return\
    \ $ret;\n}", "    # Check for length of $lst\n    return 1 if scalar(@$lst) ==\
    \ 0;", "    my $count = scalar( grep($_ == $_, $lst) );\n    return 0 != $count\
    \ ? 1 : \"\";\n}", "    if (@$lst == 1) {\n        return 1;\n    }\n    for my\
    \ $item (@$lst) {\n        if ($item != $lst[-1]) {\n            return 1;\n \
    \       }\n    }\n    return \"\";\n}", "    my($first_dup);\n    my($rest);",
  "    my $retval = \"\";\n    for my $item (@$lst) {\n        if ($item eq $lst->[0])\
    \ {\n            $retval = $retval ? 1 : 0;\n        } elsif ($retval == 1) {\n\
    \            $retval = 0;\n        } elsif ($item < $lst->[0]) {\n           \
    \ $retval = 1;\n        }\n    }\n    return $retval;\n}", "    my(@sort) = sort\
    \ { $a <=> $b } @$lst;\n    return @sort == 1 ? '' : '1';\n}", "    my $last =\
    \ $lst[-1];\n    my $count = 0;\n    foreach my $elem (@$lst) {\n        ++$count\
    \ if $elem eq $last;\n    }\n    return $count < 2;\n}", '    my(@sorted);', " \
    \   my($sorted, $sort, $seen, $flag);\n    for (my $i = 1; $i < scalar(@$lst);\
    \ ++$i) {\n        if ($seen->{$lst[$i]}) {\n            return $flag;\n     \
    \   }\n        $seen->{$lst[$i]}++;\n        $sort = $lst[$i] if $sort < $lst[$i];\n\
    \        $sorted++;\n        $flag = $sorted if $sorted > 1;\n    }\n    $flag;\n\
    }", "    my $len = @$lst;\n    my $i = 0;\n    my $cnt = 0;\n    my $flag = 0;\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        if ( $lst[$i] == $lst[$i+1] and\
    \ $lst[$i] eq $lst[$i+2] ) {\n            $cnt++;\n        } elsif ( $cnt > 1\
    \ ) {\n            $flag = 1;\n            last;\n        } elsif ( $cnt > 0 )\
    \ {\n            $cnt = 0;\n        }\n    }\n    return $flag;\n}", "    my $lc_lst\
    \ = join(\"\", sort(@$lst));\n    my $lc_lst2 = join(\"\", sort(@$lst_sorted));\n\
    \    return ($lc_str == $lc_lst2);\n}", "    my $ret = '';", "    for (my $i =\
    \ 0; $i < scalar(@$lst); ++$i) {\n        for (my $j = $i + 1; $j < scalar(@$lst);\
    \ ++$j) {\n            last if $lst[$i] eq $lst[$j];\n        }\n    }\n    !scalar(@$lst)\
    \ ? 1 : 0;\n}", '    my @nums;', "    my @seen = ();\n    $lst ~~ sort;\n    my\
    \ @unsorted = grep { ! $seen[$_] } @$lst;\n    return scalar(@unsorted) ? \"1\"\
    \ : \"0\";\n}", "    my $i = 1;\n    my $sorted = 1;\n    my $dup = 0;\n    my\
    \ $last;", "    my(@lst_hash) = ();\n    my($first_seen) = undef;\n    my $count\
    \ = 1;", "    return 1 if !@$lst;\n    my $last_val = $lst[-1];\n    for my $val\
    \ (@$lst) {\n        return 1 if $val != $last_val;\n        $last_val = $val;\n\
    \    }\n    return 1;\n}", "    my $is_sorted_flag = 1;\n    for (my $i = 1; $i\
    \ < @$lst; $i++) {\n        if ($lst->[$i] != $lst->[$i - 1]) {\n            $is_sorted_flag\
    \ = 0;\n            last;\n        }\n    }\n    return $is_sorted_flag;\n}",
  "    my $i;\n    my $j;\n    my $flag = 0;\n    my $sorted_array;\n    if ($lst->[0]\
    \ > $lst->[-1]) {\n        $flag = 1;\n    }\n    else {\n        $sorted_array\
    \ = 1;\n    }\n    foreach $i(0..$#$lst) {\n        $flag = 0;\n        foreach\
    \ $j($i..$#$lst) {\n            if ($lst->[$j] < $lst->[$i]) {\n             \
    \   $flag = 1;\n                break;\n            }\n        }\n        if (!\
    \ $flag) {\n            $sorted_array = 0;\n        }\n    }\n    return $sorted_array;\n\
    }", "    return 1 if @$lst == 1; # empty or one element, sorted\n    my $dup =\
    \ shift;\n    my @seen = ();\n    foreach my $x (@$lst) {\n        push @seen,\
    \ $x;\n        unless ($x eq $dup) {\n            while (@seen > 0) {\n      \
    \          my $tmp = shift @seen;\n                if ($x eq $tmp) {\n       \
    \             return 1;\n                }\n            }\n        }\n    }\n\
    \    return '' unless @$lst > 1;\n    return 1 if @$lst == 1;\n    $dup = $lst[-1];\n\
    \    foreach my $x (@$lst) {\n        return 1 if ($x eq $dup);\n    }\n    return\
    \ '';\n}", "    my $count = scalar @$lst;\n    my $first = 1;\n    my $prev =\
    \ $lst->[0];\n    my $i = 0;", "    my %hash;\n    for (@$lst) {\n        $hash{$$_}\
    \ += 1 if $$_ ne $_;\n        $hash{$_}++;\n    }\n    return @$hash{keys} ==\
    \ 1;\n}", "    my(@list) = ();\n    my($n);\n    foreach $n(@$lst) {\n       \
    \ my $found = 0;\n        foreach my $lst (@list) {\n            if ($lst eq $n)\
    \ {\n                $found = 1;\n            }\n        }\n        if ($found\
    \ == 0) {\n            push(@list, $n);\n        }\n    }\n    return scalar(@list)\
    \ == 1;\n}", "    my(@lst) = @$lst;\n    my($count);\n    my($first);", "    if\
    \ (@$lst < 1) {\n        return 0;\n    }\n    my $first = $lst[0];\n    my $last\
    \ = @$lst - 1;\n    for (my $i = 1; $i <= $last; $i++) {\n        if ($lst[$i]\
    \ == $first) {\n            $first = $lst[$i + 1];\n        }\n        if ($lst[$i]\
    \ == $last) {\n            return 1;\n        }\n    }\n    return 0;\n}", " \
    \   my(@vals);\n    my @seen;", "    my(@arr);\n    \n    foreach my $val (@$lst)\
    \ {\n        if (exists $seen{$val}) {\n            my $index = $seen{$val};\n\
    \            \n            next if $index < @arr;\n            \n            splice(@arr,\
    \ $index, 1);\n        }\n        else {\n            $seen{$val} = scalar(@arr);\n\
    \            push(@arr, $val);\n        }\n    }\n    \n    return scalar(@arr)\
    \ == 1;\n}", "    return 0 if ($lst->[0] == $lst->[-1]);\n    return 0 if ($lst->[0]\
    \ == $lst->[-2]);\n    for my $i (0 .. $#$lst) {\n        if ($lst->[$i] != $lst->[$i\
    \ - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}", "    my\
    \ $result = 0;\n    \n    foreach my $n (@$lst) {\n        if ($n != $n++ ) {\n\
    \            $result = 1;\n        }\n    }\n    return $result;\n}", "    my\
    \ %seen = ();\n    my @is_sorted = ();\n    my $found = 1;", "    my ($last_elem,\
    \ $found);\n    my $i;\n    my $is_sorted = 1;\n    my $first = 1;\n    for ($i\
    \ = 0; $i < @$lst; $i++) {\n        if ($first_elem && !$found) {\n          \
    \  $first_elem = undef;\n        }\n        $first_elem = $_;\n        $found\
    \ = 0;\n        for (my $j = 1; $j < $i; $j++) {\n            if ($_ eq $lst[$j])\
    \ {\n                $found = 1;\n                last;\n            }\n     \
    \   }\n        if ($found && !$is_sorted) {\n            $is_sorted = 0;\n   \
    \     }\n        if ($found && $is_sorted) {\n            last;\n        }\n \
    \   }\n    return $is_sorted;\n}", "    \n    my $first = 1;\n    \n    my $count\
    \ = _uniq_sort($lst);\n    \n    # Handle single element lists\n    if ($count\
    \ == 1) {\n        return 0;\n    }\n    \n    # Handle duplicate lists\n    if\
    \ ($count == 0) {\n        return 1;\n    }\n    \n    # Sort the list\n    my\
    \ @list = sort { $a <=> $b } @$lst;\n    \n    # Check if the sorted version is\
    \ equal to the unsorted version\n    # Note: In Perl5, an array/hash ref's internal\
    \ pointer points to the\n    #       last element of the array/hash ref, so this\
    \ loop can end up\n    #       exiting before it can compare all elements.\n \
    \   my $check = 1;\n    my $prev_value = 0;\n    my $prev_value2 = 0;\n    my\
    \ $prev_value3 = 0;\n    my $prev_value4 = 0;\n    my $prev_value5 = 0;\n    my\
    \ $prev_value6 = 0;\n    my $prev_value7 = 0;\n    my $prev_value8 = 0;\n    my\
    \ $prev_value9 = 0;\n    my $prev_value10 = 0;\n    my $prev_value11 = 0;\n  \
    \  my $prev_value12 = 0;\n    my $prev_value13 = 0;\n    my $prev_value14 = 0;\n\
    \    my $prev_value15 = 0;\n    my $prev_value16 = 0;\n    my $prev_value17 =\
    \ 0;\n    my $prev_value18 = 0;\n    my $prev_value19 = 0;\n    my $prev_value20\
    \ = 0;\n    my $prev_value21 = 0;\n    my $prev_value22 = 0;\n    my $prev_value23\
    \ = 0;\n    my $prev_value24 = 0;\n    my $prev_value25 = 0;\n    my $prev_value26\
    \ = 0;\n    my $prev_value27 = 0;\n    my $prev_value28 = 0;\n    my $prev_value29\
    \ = 0;\n    my $prev_value30 = 0;\n    my $prev_value31 = 0;\n    my $prev_value32\
    \ = 0;\n    my $prev_value33 = 0;\n    my $prev_value34 = 0;\n    my $prev_value35\
    \ = 0;\n    my $prev_value36 = 0;\n    my $prev_value37 = 0;\n    my $prev_value38\
    \ = 0;\n    my $prev_value39 = 0;\n    my $prev_value40 = 0;\n    my $prev_value41\
    \ = 0;\n    my $prev_value42 = 0;\n    my $prev_value43 = 0;\n    my $prev_value44\
    \ = 0;\n    my $prev_value45 = 0;\n    my $prev_value46 = 0;\n    my $prev_value47\
    \ = 0;\n    my $prev_value48 = 0;\n    my $prev_value49 = 0;\n    my $prev_value50\
    \ = 0;\n    my $prev_value51 = 0;\n    my $prev_value52 = 0;\n    my $prev_value53\
    \ = 0;\n    my $prev_value54", "    return 0 unless @$lst;\n    my $hash = {};\n\
    \    my $prev_val = $lst[0];\n    for(my $i = 1; $i < @$lst; $i++){\n        my\
    \ $val = $lst[$i];\n        if ($hash{$val} == 1){\n            return \"\";\n\
    \        }\n        elsif ($hash{$val} != 1){\n            return \"\";\n    \
    \    }\n        $hash{$prev_val} = 1;\n        $prev_val = $val;\n    }\n    return\
    \ 1;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's a solution using Perl 5.10\
    \ features:\n<code>\nuse strict;\nuse warnings;", "    my $len = @$lst;\n    my\
    \ $i = 0;\n    my $found = 0;\n    while ($i < $len and !$found) {\n        $found\
    \ = ($lst[$i] <= $lst[$i+1]);\n        $i++;\n    }\n    if ($i == $len or !$found)\
    \ {\n        return 0;\n    } else {\n        return 1;\n    }\n}", "    my $i\
    \ = 0;\n    my $prev = 0;\n    my $ret = 0;\n    while(@$lst > 0) {\n        $prev\
    \ = $lst[$i];\n        $ret = 0;\n        for(my $j=0;$j<$i;$j++) {\n        \
    \    my $temp = $lst[$j];\n            if($temp == $prev) {\n                $ret\
    \ = 1;\n            }\n        }\n        last if($ret == 1);\n        $i++;\n\
    \    }\n    return $ret;\n}", "    my $sorted = 0;\n    for my $i (0..$#$lst)\
    \ {\n        if ($lst->[$i] != $lst->[$i-1]) {\n            $sorted = 1;\n   \
    \         last;\n        }\n    }\n    return $sorted;\n}", "    my $first = pop(@$lst);\n\
    \    for my $value ( ) {\n        return 1 if $value < $first;\n    }\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>", "    my($ret);\n    my $num_dups\
    \ = $#{$lst} - 1;\n    my $max_dups = $num_dups - 1;", "    my($sorted = 1);\n\
    \    my($num);", "    $lst = [ sort @$lst ];\n    $lst[0] > $lst[1] if @$lst >\
    \ 1;\n}", "    my $len = scalar($lst);\n    my %counts = ();\n    my $last = 0;",
  "    my $ret = 1;\n    my @lst = ();\n    foreach (@$lst) {\n        push(@lst,\
    \ $_);\n    }\n    my $uniq = @_;\n    if ($uniq > 1 && ! scalar(@lst)) {\n  \
    \      $ret = 0;\n    } elsif ($uniq > 1) {\n        my $count = 0;\n        my\
    \ $prev = $lst[0];\n        foreach (@lst) {\n            my $curr = ($_ - $prev);\n\
    \            if ($curr eq 0) {\n                $count++;\n            }\n   \
    \         $prev = $_;\n        }\n        if ($count > $uniq) {\n            $ret\
    \ = 0;\n        }\n    }\n    return $ret;\n}", "    my $is_sorted = 1;\n    my\
    \ $last_value = \"\";", "    if (scalar($lst) > 1) {\n        return 0;\n    }\n\
    \    my $l = $lst[0];\n    for my $x (@$lst) {\n        return 0 if $x > $l;\n\
    \        return 1 if $x == $l;\n    }\n    return 1;\n}", "    my $sorted_cnt\
    \ = 0;\n    my $last_val = -1;\n    my $last_idx = -1;\n    for (my $i = 0; $i\
    \ <= $#$lst - 1; $i++) {\n        my $current_val = $lst[$i];\n        if ($last_val\
    \ > $current_val) {\n            $sorted_cnt++;\n        } else {\n          \
    \  $sorted_cnt = 0;\n        }\n        if ($sorted_cnt == 1) {\n            $last_val\
    \ = $current_val;\n            $last_idx = $i;\n        } elsif ($sorted_cnt >\
    \ 1) {\n            my $diff = $current_val - $last_val;\n            if ($diff\
    \ < 0) {\n                return \"[out of order]\";\n            }\n        }\n\
    \    }\n    if ($sorted_cnt > 1) {\n        return \"[out of order]\";\n    }\n\
    \    return 1;\n}", '    my $flag = 0;', '    my $len = @$lst;', "    return unless\
    \ @$lst;\n    my %seen = ();\n    foreach my $num (@$lst) {\n        die \"Duplicate\
    \ number in list\" unless $seen{$num}++;\n    }\n    # all numbers unique => sorted\n\
    \    return if @$lst == 1;\n    my $result = $lst[0] > $lst[1]; # first is bigger\n\
    \    return $result if @$lst > 1; # all numbers are bigger, so sorted\n    return\
    \ unless @$lst;\n    # all numbers are equal, return if first is bigger\n    return\
    \ $result if @$lst == 1 && ! defined $seen{$lst[0]}\n        || $lst[0] > $seen{$lst[0]};\n\
    \    return $result if @$lst == 1 && ! defined $seen{$lst[1]}\n        || $lst[1]\
    \ > $seen{$lst[1]};\n    return $result;\n}", "    my $sorted = 0;\n    my $has_dup\
    \ = 0;\n    for (my $i = 0; $i <= $#lst; ++$i) {\n        if (exists $lst_count{$lst[$i]})\
    \ {\n            $has_dup = 1;\n            last;\n        }\n        my $x =\
    \ $lst[$i];\n        if ($x <= $lst[$i - 1]) {\n            $has_dup = 1;\n  \
    \          last;\n        }\n    }\n    return 1 if $sorted or $has_dup;\n   \
    \ return 1;\n}", "    foreach my $i (0 .. $#$lst) {\n        if( $lst[$i] eq $lst[$i\
    \ - 1] || $lst[$i] == $lst[$i - 1] && $i < $#$lst - 1 ) {\n            return\
    \ 0;\n        }\n    }\n    return 1;\n}", "    my $sorted;\n    my $len = @$lst;\n\
    \    my $count = $len / 2;\n    my $last_val = undef;\n    for my $index (1 ..\
    \ $len) {\n        if ($last_val != $lst[$index]) {\n            $last_val = $lst[$index];\n\
    \            $sorted = 0;\n        }\n        elsif ($last_val == $lst[$index]\
    \ && $index > $count) {\n            $sorted = 1;\n        }\n    }\n    return\
    \ $sorted ? 1 : 0;\n}", "    my($sorted = 1);\n    my $found = 0;\n    my $first\
    \ = $lst[0];", "    my @lst = sort @_;\n    return 0 if @lst == 1;\n    return\
    \ 0 if @lst > 1;\n    return if @lst == 0 or $lst[0] eq $lst[-1];\n    return\
    \ '';\n}", "    for (my $i = 0; $i < @$lst; $i++) {\n        my $x = $lst->[$i];\n\
    \        for (my $j = $i + 1; $j < @$lst; $j++) {\n            my $y = $lst->[$j];\n\
    \            next unless $x == $y;\n            return '' if $x == $y;\n     \
    \   }\n        return 1 if $i == @$lst - 1;\n    }\n    return 1;\n}", "    my\
    \ $last = undef;\n    my $flag = 0;\n    for (my $i = 0; $i < @$lst; $i++) {\n\
    \        if ($lst[$i] == $last) {\n            $flag++;\n        } else {\n  \
    \          $last = $lst[$i];\n            $flag = 1;\n        }\n    }\n    return\
    \ $flag == 1 ? \"1\\n\" : \"0\\n\";\n}", "    my $last_value = 0;\n    foreach\
    \ my $num (@$lst) {\n        if ($num == $last_value) {\n            $last_value\
    \ = $last_value + 1;\n        }\n        else {\n            $last_value = $num;\n\
    \            return 0 if $last_value == 1;\n        }\n    }\n    return 1;\n}",
  '    my $len = $#lst + 1;', "    return undef if @$lst <= 1;\n    my $sorted = @$lst;\n\
    \    for (my $i = 1; $i < @$lst; $i++) {\n        my $found = 0;\n        for\
    \ (my $j = $i; $j < @$lst; $j++) {\n            return 1 if ($sorted[$i] lt $sorted[$j]);\n\
    \            $found++ if ($j == $i || $sorted[$j] == $sorted[$i]);\n        }\n\
    \        return 1 if ($found == 1 || $i < $j);\n    }\n    return '';\n}", " \
    \   my $ret = 0;\n    my $last;\n    my $first;\n    my $firstcount = 1;\n   \
    \ for my $item (@$lst) {\n        if ($ret != 0 && $item == $last) {\n       \
    \     $firstcount++;\n            $ret = 0;\n            next;\n        }\n  \
    \      if ($item != $last) {\n            $ret = 1;\n            last;\n     \
    \   }\n        $last = $item;\n    }\n    if ($firstcount != @$lst) {\n      \
    \  $ret = 1;\n    }\n    return $ret;\n}", "    my $i = 0;\n    my $duplicate\
    \ = 0;\n    \n    # Count how many times each number appears\n    my $counts =\
    \ {};\n    foreach (@$lst) {\n        $counts{$_}++;\n    }\n    \n    # Find\
    \ the first number that is different\n    # from the rest\n    foreach (keys %$counts)\
    \ {\n        last unless $_ == $counts{$_};\n        $i++;\n    }", "    my %hash;\n\
    \    my $first_dup = $lst[0];\n    for my $num (@$lst) {\n\tif (defined $hash{$num})\
    \ {\n\t    return 1 if $hash{$num} ne $first_dup;\n\t} else {\n\t    $hash{$num}\
    \ = $first_dup;\n\t}\n    }\n    return 1 if $hash{$first_dup} != $first_dup;\n\
    \    return '';\n}", "    my @tmp = ();\n    my($first, $prev);\n    my(@sorted);\n\
    \    my($len) = @$lst;", "    my $first = 1;\n    my @sorted = ();", "    my $sorted\
    \ = 1;\n    my $dupe = 0;\n    for my $i (0..$#$lst) {\n        if ($lst[$i] ==\
    \ $lst[$i-1]) {\n            $dupe++;\n        }\n        else {\n           \
    \ $sorted = 0;\n            last;\n        }\n    }\n    return $sorted unless\
    \ $dupe;\n    return undef;\n}", "    my $i = 0;\n    my $flag = 1;\n    my $count\
    \ = 0;", "    my $min_element = @$lst > 1 ? $lst->[-1] : 0;\n    my $flag = 0;\n\
    \    my $prev_val = 0;\n    for (my $i = 0; $i < @$lst; $i++) {\n        my $curr_val\
    \ = $lst->[$i];\n        if ($curr_val < $min_element) {\n            $flag =\
    \ 1;\n            $min_element = $curr_val;\n        }\n        $prev_val = $curr_val;\n\
    \    }\n    return $flag;\n}", "    if (@$lst == 1) {\n        return 1;\n   \
    \ }\n    if (@$lst == 0) {\n        return '';\n    }\n    # remove any duplicates\
    \ and sort\n    @$lst = map { ($_ ne $lst[$_]) ? ( $_, $lst[$_] ) : () } 0 ..\
    \ $#$lst;\n    my $is_sorted = 0;\n    for (my $i = 0; $i < $#$lst; $i++) {\n\
    \        $is_sorted = 1 if ($lst[$i] <=> $lst[$i+1]) > 0;\n    }\n    return $is_sorted;\n\
    }\n</code>\n<|/ a tags=algorithm,sorting,perl dscore=2 |>\n<| c |>\nThat looks\
    \ pretty inefficient, no?\n<|/ c |>\n<| a dscore=0 |>\nThe key here is to use\
    \ a hashmap to track how many times each number is repeated. Then, iterate through\
    \ the array and check if each number is in the hashmap for more than one time\
    \ or not.\n<code>", "    return -1 if scalar @$lst < 1;\n    # count the dupes\n\
    \    my $dupes = 0;\n    my $tmp = '';\n    my $res = -1;\n    for my $num (@$lst)\
    \ {\n        if ($tmp eq $num) {\n            $dupes++;\n        } else {\n  \
    \          $tmp = $num;\n            $res = 0 if $dupes == 0;\n            $dupes\
    \ = 0;\n        }\n    }\n    return $res;\n}", "    my(@sorted);\n    my($last,\
    \ $cur);\n    my($i, $j);\n    my($is_sorted);", "    my(@nums);\n    my($ret);",
  "    my $count = 0;\n    my @set = ();\n    for (@$lst) {\n        my $val = $_;\n\
    \        if (exists $seen_vals{$val}) {\n            $seen_vals{$val}++;\n   \
    \     } else {\n            push @set, $val;\n            $seen_vals{$val} = 1;\n\
    \        }\n    }\n    for (@set) {\n        $count++;\n    }\n    return $count\
    \ == @set;\n}", "    for (my $i = 1; $i < scalar(@$lst); $i++) {\n        if ($lst[$i]\
    \ eq $lst[$i - 1]) {\n            return '';\n        }\n    }\n    return 1;\n\
    }", "    my $result;\n    my $last_element = shift(@$lst);\n    my $is_unique;",
  '    my(@hash);', '    my @sorted_lst = ();', "    foreach my $item (@$lst) {\n\
    \        if ($item == $lst->[0]) {\n            last if $item == $lst->[-1];\n\
    \        }\n    }\n    return $lst->[0] > $lst->[-1] ? 1 : 0;\n}", "    $lst =\
    \ [sort @$lst];\n    if ($lst[0] != $lst[1]) {\n        return 0;\n    }\n   \
    \ my @rev = reverse @$lst;\n    foreach my $i (@rev) {\n        $i = 3 - $i;\n\
    \        if ($i == 6) {\n            return 1;\n        }\n    }\n    return 1;\n\
    }", "    for (my $i = 1; $i <= (scalar(@$lst) - 3); $i++) {\n        my $x = $lst[$i];\n\
    \        for (my $j = ($i + 1); $j <= $#{$lst} - $i; $j++) {\n            if ($lst[$j]\
    \ > $x) {\n                return 1;\n            }\n        }\n    }\n    return\
    \ \"\";\n}", '    my(@lst_sorted, $first);', "    # No duplicates\n    unless(scalar(grep\
    \ {++$seen{$_} == 1} @$lst) == scalar(@$lst)) {\n        return 0;\n    }\n  \
    \  # One duplicate\n    my($dup) = grep {$seen{$_} == 1} @$lst;\n    if (@$dup\
    \ == 1) {\n        return 1;\n    }\n    return '';\n}", "    my $is_sorted =\
    \ 1;\n    my %counts;\n    my $i;", "    my $len = scalar @$lst;\n    \n    if\
    \ ($len == 1) {\n        my $elem = $lst->[0];\n        if ($elem == $elem) {\n\
    \            return 1;\n        }\n        return 0;\n    }\n    \n    my $min_elem\
    \ = $lst->[0];\n    my $count = 1;\n    my $index = 0;\n    \n    while ($index\
    \ < $len - 1) {\n        my $next = $lst->[$index + 1];\n        if ($next ==\
    \ $min_elem) {\n            ++$count;\n            if ($count == 2) {\n      \
    \          return 1;\n            }\n            $index = $index + 1;\n      \
    \      next;\n        }\n        \n        if ($next < $min_elem) {\n        \
    \    $count = 1;\n            ++$index;\n            next;\n        }\n      \
    \  \n        if ($next > $min_elem) {\n            ++$index;\n            next;\n\
    \        }\n    }\n    \n    return 0;\n}", "    return 1 if @$lst == 1;\n   \
    \ return @$lst[0] <=> @$lst[-1] if @$lst > 1;\n    my $n = @$lst - 1;\n    my\
    \ $i = 0;\n    foreach my $v (@$lst) {\n        return 1 unless ($v eq ++$i);\n\
    \    }\n    return \"\";\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nWhy do you\
    \ use `==` instead of `eq`? The former implies a numeric comparison, which the\
    \ latter would not.\n<|/ c |>\n<| c |>\n: Thanks, I fixed that.\n<|/ c |>\n<|\
    \ c |>\n`cmp` is for cases where you don't want to compare numbers, just strings.\
    \ For this particular case I guess `<=>` would be a good choice, but that's just\
    \ me.\n<|/ c |>\n<| c |>\n: That would also work, I suppose. `cmp` is better because\
    \ it can be passed a second argument to use to decide the direction of the comparison.\n\
    <|/ c |>\n<| c |>\n: It also happens to work better because `==` will coerce the\
    \ input to a string if needed, whereas `eq` will just be comparing two numbers,\
    \ regardless of their type.\n<|/ c |>\n<| a dscore=1 tags=perl |>\nTo solve this,\
    \ one could make an iterator that returns either one or all of the elements. There\
    \ are a number of ways of doing this, but I like doing it with one sub:\n<code>",
  "    $lst->[@_] !~ /([\\d,])\\1\\1/;\n}", "    my $first_dup = 0;\n    my $result\
    \ = 0;", "    return 1 if !@$lst;\n    my $i = 0;\n    for (@$lst) {\n       \
    \ for my $j (@$lst) {\n            return 1 if ($i < $j && $lst->[$i] eq $lst->[$j]);\n\
    \        }\n        $i++;\n    }\n    return \"\";\n}", "    my $i = 0;\n    my\
    \ $last = $lst[0];", "    my $len = scalar @$lst;\n    for ( my $i = 0; $i < $len;\
    \ $i++ ) {\n        my $tmp = $lst->[$i];\n        for ( $i = $i+1; $i < $len;\
    \ $i++ ) {\n            if ( $tmp != $lst->[$i] ) {\n                return 1;\n\
    \            }\n        }\n    }\n    return \"\";\n}", "    my $cnt = scalar\
    \ @$lst;\n    my @is_sorted = ();\n    my @seen = ();", "    $lst = uniq(@$lst);\n\
    \    if (@$lst > 1) {\n        my $i = 0;\n        my $dup = 0;\n        my $j\
    \ = 1;\n        while (@$lst > 1) {\n            $dup = 1;\n            $lst[$i]\
    \ == $lst[$j] or do {\n                if ($dup) {\n                    $i++;\n\
    \                    $j++;\n                }\n                $lst[$i] == $lst[$j];\n\
    \                $dup = 0;\n            };\n            shift @$lst, shift(@$lst);\n\
    \        }\n        return \"\";\n    } else {\n        return $lst[0] == $lst[1];\n\
    \    }\n}", "    my $sorted = 0;\n    my $is_sorted = \"\";\n    foreach my $i\
    \ (@$lst) {\n        if ($i > $lst[$sorted]) { $sorted++; $is_sorted = \"\"; }\n\
    \        elsif ($i == $lst[$sorted]) { $is_sorted.= \".\"; }\n    }\n    if ($is_sorted\
    \ eq \"\" and $sorted < @$lst ) { return 1; }\n    return $is_sorted;\n}", '    my($sorted_list)
    = 1;', '    my $len = @$lst;', "    for my $v (sort {$a <=> $b} @$lst) {\n   \
    \     my $last = $v;\n        while (scalar keys %{$seen{$last}}) {\n        \
    \    $last .= \"0\";\n        }\n        $seen{$last}++;\n    }\n}", "    if (@$lst\
    \ > 1) {\n        $lst .= [$lst[0]];\n        my %seen = ();\n        for (@$lst)\
    \ {\n            die \"List must not contain duplicate numbers\" if $seen{$_};\n\
    \            $seen{$_} = 1;\n        }\n    } else {\n        die \"List must\
    \ contain one number\" unless @$lst;\n    }", "    my $flag = 0;\n    my $count\
    \ = scalar @$lst;\n    my $i = 0;\n    my $j = 0;\n    my $len = scalar @$lst;\n\
    \    while (@$lst > 1) {\n        for ($i; $i < $len; $i++) {\n            if\
    \ ($lst[$i] > $lst[$i + 1]) {\n                $flag = 1;\n                last;\n\
    \            }\n        }\n        for ($j; $j < $count; $j++) {\n           \
    \ if ($lst[$j] > $lst[$j + 1]) {\n                $flag = 1;\n               \
    \ last;\n            }\n        }\n        if ($flag) {\n            $flag = 0;\n\
    \            next;\n        }\n        $count -= 1;\n        $i += 1;\n      \
    \  $j += 1;\n    }\n    my @sorted_list = ();\n    $flag = 0;\n    for ($i; $i\
    \ < $len; $i++) {\n        if ($lst[$i] < $lst[$i + 1]) {\n            $flag =\
    \ 1;\n            last;\n        }\n    }\n    for ($j; $j < $count; $j++) {\n\
    \        if ($lst[$j] < $lst[$j + 1]) {\n            $flag = 1;\n            last;\n\
    \        }\n    }\n    if ($flag) {\n        return 1;\n    }\n    push(@sorted_list,\
    \ $lst[0]);\n    push(@sorted_list, $lst[$len - 1]);\n    return join(\"\", @sorted_list);\n\
    }", '    my $i;', "    my $result = 1;\n    my $last_num = -1;\n    foreach my\
    \ $num (@$lst) {\n        # Skip if the number is the same\n        if ($num ==\
    \ $last_num) {\n            next;\n        }\n        # Skip if the number is\
    \ less than the previous one\n        if ($num < $last_num) {\n            $result\
    \ = 0;\n            last;\n        }\n        $last_num = $num;\n    }\n    return\
    \ $result;\n}", "    if (scalar @$lst < 2) {\n        return 0;\n    }\n    my\
    \ %hash;\n    $hash{$_}++ for @$lst;\n    return 1 if (scalar keys %hash);\n \
    \   $hash{@$lst} = 1;\n    return 1;\n}", "    my @sorted = sort { $a <=> $b }\
    \ @$lst;\n    return 0 if $sorted[0] =~ /^\\d+$/;\n    return $sorted[0] == $sorted[1]\
    \ if @sorted > 1;\n    return 1;\n}", "    my $lc_lst = uc map { lc } @$lst;\n\
    \    my $len_lst = @$lst;", "    my $sorted = 0;\n    my $hash = {};\n    for\
    \ (@$lst) {\n        $hash->{$_}++ if !defined($hash->{$_});\n        if ($hash->{$_}\
    \ == 1) {\n            $sorted = 1;\n            last;\n        }\n    }\n   \
    \ return !$sorted ? \"\" : \"1\";\n}", "    my $len = @$lst;\n    my $cnt = 0;\n\
    \    my $min = undef;\n    my @sorted;\n    for (my $i = 0; $i < $len; $i++) {\n\
    \        if ($min && $lst[$i] <= $min) {\n            return 1;\n        }\n \
    \       if (!$lst[$i]) {\n            $cnt++;\n        }\n        else {\n   \
    \         $min = $lst[$i];\n            push (@sorted, $lst[$i]);\n        }\n\
    \    }\n    if ($cnt > 1) {\n        return \"\";\n    }\n    for (my $i = 0;\
    \ $i < $len; $i++) {\n        if ($min && $lst[$i] <= $min) {\n            return\
    \ 1;\n        }\n        if (!$lst[$i]) {\n            return 1;\n        }\n\
    \    }\n    return 0;\n}", "    my($num_dup) = @_;\n    for(my $i = 1; $i < $#lst;\
    \ $i++) {\n        my $a = $lst[$i];\n        my $j;\n        for(my $k = $i;\
    \ $k < $#lst; $k++) {\n            $j = $lst[$k];\n            if($a == $j) {\n\
    \                $num_dup++;\n                last if $num_dup == 1;\n       \
    \     }\n        }\n    }\n    return $num_dup > 1 ? '' : 1;\n}", "    my $count\
    \ = 0;\n    for my $i (0 .. $#lst) {\n        if ($lst[$i] == $lst[$i]) {\n  \
    \          $count++;\n        }\n    }\n    return $count == $#lst;\n}", "   \
    \ my $i;\n    my $num_unique;\n    for ($i = 0; $i < @$lst; $i++) {\n        $num_unique\
    \ = 0;\n        for (my $j = 0; $j < $i; $j++) {\n            if ($lst[$j] ==\
    \ $lst[$i]) {\n                $num_unique++;\n            }\n        }\n    \
    \    if ($num_unique == 1) {\n            return 1;\n        }\n    }\n    return\
    \ \"\";\n}", "    $lst =~ tr/0-9//cd;\n    if ($lst == sort @$lst) {\n\treturn\
    \ 1;\n    }\n    return 0;\n}", '    my $count = 1;', "    my %hash = @$lst;\n\
    \    my %hash_count;\n    my(@hash_values);\n    # Build a hash where each key\
    \ is itself an array of\n    # indices of which equal values are present in $lst.\n\
    \    foreach my $key (sort keys %hash) {\n        push(@hash_values, $key, @{\
    \ $hash{$key} });\n    }\n    foreach my $key (sort keys %hash) {\n        my($count)\
    \ = @{ $hash_count{$key} };\n        unless ($count == 0) {\n            # There\
    \ are multiple equal values in $lst.  The\n            # elements in the key must\
    \ be in ascending order.\n            while (my $index = @hash_values[$key]) {\n\
    \                if ($hash_values[$key][$index] > $hash_values[$key][$index -\
    \ 1]) {\n                    push @hash_values[$key], [$index, $hash_values[$key][$index\
    \ - 1]];\n                }\n                $index--;\n            }\n      \
    \  }\n        $hash_count{$key} = [@hash_values[$key], 0];\n    }\n    if (@hash_values\
    \ == 1) {\n        return 0;\n    } elsif (@hash_values == 0) {\n        return\
    \ 1;\n    } elsif ($hash_count{$hash_values[0]}[0] == 1) {\n        return 0;\n\
    \    } else {\n        return 1;\n    }\n}", "    # Check for repeated numbers\n\
    \    if ($lst =~ /[^\\d]\\1/) {\n        return 0;\n    }\n    # Check for duplicates\n\
    \    my %map;\n    foreach my $elem (@$lst) {\n        if (not defined $map{$elem})\
    \ {\n            $map{$elem} = 1;\n        } else {\n            return \"\";\n\
    \        }\n    }\n    # Check for sorted list\n    return 1 if $map > 1;\n  \
    \  return 1;\n}", '    my $retval;', "    my($count) = 0;\n    my($prev_number)\
    \ = 0;\n    my(@sorted_numbers);\n    for(my $i = 0; $i < @$lst; $i++) {\n   \
    \     my $number = $lst->[$i];\n        next if($prev_number == $number);\n  \
    \      next if($count > 1);\n        $count++;\n        $prev_number = $number;\n\
    \        push(@sorted_numbers, $number);\n    }\n    if(@sorted_numbers == 0)\
    \ {\n        return 0;\n    }\n    else {\n        return 1;\n    }\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=function,perl,arrays,sorting |>\nThis is\
    \ probably the simplest way (with minimum code) to do this:\n<code>", "    my\
    \ $len = @$lst;\n    $lst =~ tr/\\0//d;\n    my $i = 0;\n    my $min = $i;\n \
    \   my $max = $len - 1;\n    my $mid;", "    my $ret = 0;\n    for ($lst) {\n\
    \        my $lc = scalar(@$lst);\n        for ($lc) {\n            last if $_\
    \ eq $lst[$_];\n            $ret++;\n        }\n    }\n    return $ret ? \"1\\\
    n\" : \"\";\n}", "    my $count = $lst->[0];\n    for my $i(1..@$lst) {\n    \
    \    my $curr = $lst->[$i];\n        if ($curr != $count) {\n            return\
    \ 1;\n        }\n    }\n    return \"\";\n}", '    return 1 if @$lst < 2;', " \
    \   my($hash);\n    my($duplicate);\n    my($first);\n    my($last);", "    my\
    \ $sorted_lst = uniq sort @$lst;\n    return 1 unless @$sorted_lst == @$lst;\n\
    \    return '' unless @$sorted_lst == 1;\n    return $sorted_lst[0];\n}", "  \
    \  my $sorted = 1;\n    my $last = $lst[0];\n    my $tmp = $last;\n    my $count\
    \ = 1;\n    my $i;", "    my $prev;\n    my $flag = 0;\n    my $cnt = 0;\n   \
    \ for (@$lst) {\n        if ($cnt != 0 && $cnt != $prev) {\n            $flag\
    \ = 0;\n        }\n        $prev = $cnt;\n        if ($flag) {\n            return\
    \ '';\n        }\n        if ($_ > $cnt) {\n            $flag = 1;\n        }\n\
    \        $cnt++;\n    }\n    return 1;\n}", "    my($j);\n    my $flag = 0;\n\
    \    my $sorted = 0;\n    my $x;\n    for $x (@$lst) {\n        if ($x == $lst[$j-1])\
    \ {\n            $flag++;\n        } else {\n            if ($flag > 1) {\n  \
    \              $sorted = 1;\n                return \"\";\n            }\n   \
    \     }\n        $j++;\n    }\n    return $sorted;\n}", "    my($idx) = -1;\n\
    \    for (my $i = $#lst; $i > $idx; $i--) {\n        if ($lst[$i] eq $lst[$idx])\
    \ {\n            $idx++;\n        }\n    }\n    if ($idx > 0) {\n        return\
    \ 1;\n    }\n    return undef;\n}", "    my $count = 0;\n    my $last = -1;\n\
    \    my $first = 1;", '    my $sorted = 1;', "    my @nums = ();\n    foreach\
    \ my $num (@$lst) {\n        if (! grep { $num == $$_[0] } @nums) {\n        \
    \    push(@nums, $num);\n        }\n    }\n    if (@nums == 1) {\n        return\
    \ 1;\n    }\n    else {\n        return \"\";\n    }\n}", "    return 0 unless\
    \ @$lst;\n    my($first, @rest) = @_;\n    my %seen = ();\n    foreach my $val\
    \ (@$lst) {\n        $seen{$val}++;\n    }\n    foreach my $val (@$lst) {\n  \
    \      return 0 if $seen{$val} > 1;\n    }\n    return 1;\n}", "    my $count\
    \ = scalar (uniq @$lst);\n    my %hash = ();\n    my $len = scalar @$lst;", " \
    \   my $ret = 1 if ($lst =~ tr/\\0//);\n    my @sorted = sort { $a <=> $b } @$lst;\n\
    \    $ret = 1 if (@sorted == 1 && $sorted[0] eq $sorted[-1]);\n    $ret;\n}",
  "    my $last = pop(@{$lst});\n    return 1 if @$lst > 1 || $lst == $last;\n   \
    \ return 0 if @$lst == 0;\n    return 1 if $lst->[0] == $last;\n    return 1;\n\
    }", "    if (scalar @$lst == 1) {\n        return 0;\n    }\n    my $last = shift(@$lst);\n\
    \    foreach my $val (@$lst) {\n        if ($val > $last) {\n            return\
    \ 1;\n        } elsif ($val == $last) {\n            last if (scalar @$lst ==\
    \ 1);\n        } else {\n            last;\n        }\n    }\n    return \"\"\
    ;\n}", "    my $i;\n    my $flag = 1;\n    my $first = 1;\n    my $last = -1;\n\
    \    my $length = 0;\n    foreach my $i(@$lst) {\n        $flag = 0;\n       \
    \ if ($first eq $last) {\n            $first = $i;\n            $flag = 1;\n \
    \           next;\n        }\n        if ($i != $last) {\n            $flag =\
    \ 1;\n        }\n        $last = $i;\n    }\n    if ($flag) {\n        return\
    \ \"1\";\n    }\n    else {\n        return \"0\";\n    }\n}", "    return @$lst\
    \ if @$lst == 1;\n    my $first = @$lst;\n    $lst = sort {$a <=> $b} @$lst;\n\
    \    return $first == @$lst ? 1 : 0;\n}", "    my $last = undef;\n    foreach\
    \ my $val (@$lst) {\n        next if !defined($last);\n        return 1 if $val\
    \ > $last;\n        $last = $val;\n    }\n    return 1;\n}", "    my $result;\n\
    \    for my $index (0..$#$lst) {\n        my $elem = $lst->[$index];\n       \
    \ for my $index2 ($index..$#$lst) {\n            if ($elem eq $lst->[$index2])\
    \ {\n                $result = 1;\n                last;\n            }\n    \
    \    }\n    }\n    my $msg = \"Expected array\\n\" . join(\" \", @$lst) . \"\\\
    nto be sorted\";\n    $msg .= \"\\n\" unless $result;\n    $msg .= \"\\n\" unless\
    \ $msg;\n    return $msg;\n}", "    my $result;\n    if (@$lst == 1) {\n     \
    \   $result = 1;\n    } elsif (@$lst > 1) {\n        $result = 0;\n        my\
    \ $prev = -1;\n        my $count = -1;\n        for (my $i = 0; $i < @$lst; $i++)\
    \ {\n            if ($prev != $lst[$i]) {\n                $result = 1;\n    \
    \        }\n            $count++;\n            if ($count == 2) {\n          \
    \      $result = 1;\n            }\n            $prev = $lst[$i];\n        }\n\
    \    }\n    return $result;\n}", "    return $lst->[0] <=> $lst->[-1]\n      \
    \      if $lst->[0] && $lst->[-1];\n    return 0;\n}", "    my @temp = $lst;\n\
    \    my $count = 1;\n    my $last_num = $lst[0];\n    foreach my $num (@temp)\
    \ {\n        if ($num eq $last_num) {\n            $count++;\n        } else {\n\
    \            $count = 1;\n            $last_num = $num;\n        }\n    }\n  \
    \  return $count == $#temp ? 1 : 0;\n}", "    my $ret = 0;\n    for ($lst) {\n\
    \        last if ($_ eq $lst->[0]);\n        last if ($ret > 0);\n        $ret++;\n\
    \    }\n    return $ret;\n}", "    my (@results);\n    for (my $i = 0; $i <= $#$lst\
    \ - 1; $i++) {\n        my $num = $lst[$i];\n        for (my $j = $i + 1; $j <=\
    \ $#$lst - 1; $j++) {\n            if ($num == $lst[$j]) {\n                push\
    \ (@results, $num);\n                $i = $j;\n                last;\n       \
    \     }\n        }\n    }\n    return scalar(@results) == 1 ? @results[0] : 0;\n\
    }", "    my %hash;\n    foreach my $i (@$lst) {\n        $hash{$i}++;\n    }\n\
    \    if ($hash{$$_[0]} == 0) {\n        return 1;\n    } else {\n        return\
    \ \"\";\n    }\n}", "    if (@$lst < 2) {\n        return;\n    }\n    for my\
    \ $i ( 0 .. $#$lst ) {\n        my $x = $lst[$i];\n        my $is_unique = 0;\n\
    \        for my $j ( 0 .. $#$lst ) {\n            if ($i != $j && $lst[$j] ==\
    \ $x) {\n                $is_unique = 1;\n                last;\n            }\n\
    \        }\n        if ($is_unique == 0) {\n            return 1;\n        }\n\
    \    }\n    return \"\";\n}", "    my $flag = 0;\n    for (my $i = 0; $i < @$lst;\
    \ $i++) {\n        my $x = $lst->[$i];\n        if ($x == $x) {\n            $flag\
    \ += $i;\n        }\n    }\n    return $flag == 0;\n}", "    my $sorted = 1;\n\
    \    my $first = $lst[0];\n    for (my $i = 1; $i < $#lst; ++$i) {\n        my\
    \ $j = $i;\n        while (1) {\n            last if $j == $#lst || $lst[$j] !=\
    \ $lst[$j + 1];\n            my $tmp = $lst[$j];\n            $lst[$j] = $lst[$j\
    \ + 1];\n            $lst[$j + 1] = $tmp;\n            --$j;\n        }\n    \
    \    last unless $lst[$i] == $first;\n        $sorted = 0;\n    }\n    $sorted;\n\
    }", "    my($first) = @$lst;\n    my($duplicates) = 0;", "    for (my $i = 1;\
    \ $i <; $i++) {\n        if ($lst[$i] eq $lst[$i - 1]) {\n            return 1;\n\
    \        }\n    }\n    return 1;\n}", "    my $lc = scalar @$lst;\n    my %sorted\
    \ = ();\n    my $dups = 0;\n    for (my $i = 0; $i < $lc; $i++) {\n\tmy $curr\
    \ = $lst[$i];\n\tif (exists $sorted{$curr}) {\n\t    $dups++;\n\t}\n\t$sorted{$curr}++;\n\
    \    }\n    return $dups == 1 ? 1 : 0;\n}", "    my @seen;\n    return undef unless\n\
    \        @$lst && @$lst > 1 && scalar @$lst == scalar grep { !$seen[$_] and $seen[$_]\
    \ == $lst[$_] } 0 .. @$lst - 1;\n    return 1;\n}", "    my @a_sorted = ();\n\
    \    my $num_dups = @$lst;\n    my $last_num = $lst[-1];\n    my $last_num_dupes\
    \ = 0;\n    foreach my $i (@$lst) {\n        $a_sorted[$i] = 1 if $i == $last_num;\n\
    \        $num_dups = $num_dups - $last_num_dups if $i == $last_num;\n        $last_num_dupes\
    \ = 0 if $i != $last_num;\n    }\n    return \"\" unless @a_sorted == $num_dups;\n\
    \    return $num_dups;\n}", "    $lst =~ tr/1-9//d;\n    my $flag = \" \";\n \
    \   my $len = @$lst;\n    my $i = 0;\n    while($i < $len) {\n        while($i\
    \ < $len && $lst[$i] == $lst[$i + 1]) {\n            $i++;\n        }\n      \
    \  if ($i < $len) {\n            $flag .= \"1\";\n        } else {\n         \
    \   $flag .= \"0\";\n        }\n        $i++;\n    }\n    $flag =~ tr/11-0/1-0/d;\n\
    \    return $flag;\n}", "    my $count = 0;\n    foreach my $item (@{$lst}) {\n\
    \        ++$count if ($item == $item);\n    }\n    return 1 if ($count > 1);\n\
    \    my $min = $lst->[0];\n    foreach my $item (@{$lst}) {\n        return \"\
    \" if ($min > $item);\n        $min = $item;\n    }\n    1;\n}", "    my $len\
    \ = scalar @$lst;\n    for (my $i = 0; $i < $len; $i++) {\n        my $x = $lst->[$i];\n\
    \        if ($i == 0) {\n            my $first = 1;\n            my $prev = 0;\n\
    \            my $cur = $x;\n            while($prev < $cur) {\n              \
    \  $first = 0;\n                $prev++;\n            }\n            if ($first\
    \ != 1) {\n                return \"\";\n            }\n        }\n        my\
    \ $y = $lst->[$i - 1];\n        if ($x != $y) {\n            return \"\";\n  \
    \      }\n    }\n    return 1;\n}", "    return undef unless (defined $lst);\n\
    \    my(@sorted, @unsorted, @duplicate, @sorted);\n    my($n, $i, $j, $is_sorted,\
    \ $duplicates);\n    for(my $i = 0; $i < @$lst; ++$i) {\n        $is_sorted =\
    \ 1;\n        $duplicates = 0;\n        $n = $lst->[$i];\n        for(my $j =\
    \ 0; $j < @sorted; ++$j) {\n            next unless ($sorted[$j] eq $n);\n   \
    \         if ($sorted[$j] == $n) {\n                $duplicates = 1;\n       \
    \         last;\n            }\n        }\n        $is_sorted ||= $duplicates;\n\
    \        push(@sorted, $n);\n    }\n    $is_sorted ||= $duplicates == @sorted;\n\
    \    return $is_sorted;\n}", "    my $ret = 0;\n    my $i = 0;\n    while($i <\
    \ @$lst) {\n        $ret += $lst[$i] eq $lst[$i+1] ? 1 : 0;\n        $i++;\n \
    \   }\n    return $ret ? 1 : 0;\n}", "    my $last = undef;\n    for my $val (@$lst)\
    \ {\n        if ($last ne $val) {\n            my $count = 1;\n            while\
    \ ($last and $last eq $val) {\n                $count++;\n                $last\
    \ = $lst->[$#lst];\n            }\n            return $count <= 1;\n        }\n\
    \        $last = $val;\n    }\n    return 0;\n}", "    return ($lst) ? $lst =~\
    \ /(( [0-9]+)+ )/ig : 0;\n}", "    my @num;\n    foreach (@$lst) {\n        push\
    \ (@num, $_) if !$seen{$_};\n        $seen{$_} = 1;\n    }\n    return 1 unless\
    \ @num > 1;\n    return \"\";\n}", "    my $i = 0;\n    my $first = 1;\n    my\
    \ $result;\n    while (@$lst != 0) {\n        $first = 0 if $lst -> [$i] == $lst\
    \ -> [$i - 1];\n        $result = $first if $lst -> [$i] != $lst -> [$i];\n  \
    \      $i++;\n    }\n    return $result ? 1 : 0;\n}", '    my(@val) = @_;', " \
    \   # sort the array first (quickest in many cases)\n    sort($lst);\n    # check\
    \ for duplicates\n    my $has_dupe = 1;\n    my $last_val = $lst[0];\n    my $has_dupe_val\
    \ = \"\";\n    my $i = 0;\n    for my $val (@$lst) {\n        if ($val != $last_val)\
    \ {\n            $has_dupe = 0;\n            $has_dupe_val = $val;\n        }\n\
    \        last if $has_dupe == 1;\n        $i++;\n        $last_val = $val;\n \
    \   }\n    return 1 if $has_dupe;\n    return $has_dupe_val;\n}", "    my $dup;\n\
    \    foreach my $num (@$lst) {\n        $dup = 0;\n        foreach my $i (0..$#$lst)\
    \ {\n            next if $i eq $num;\n            $dup = 1 if $lst[$i] eq $num;\n\
    \        }\n        return $dup ? 1 : 0;\n    }\n    return 1;\n}", "    return\
    \ 1 if scalar @$lst < scalar @$lst;\n    return '' if scalar @$lst == scalar @$lst;\n\
    \    return;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThe short answer is, no.\n\
    The longer answer is, there are a few approaches you can use. One is to sort it,\
    \ and count the number of times each number occurs.  If your data set is very\
    \ large, you may need to use something other than a hash.\n<code>", "    return\
    \ unless @$lst && @$lst;\n    return 1 if @$lst == 1 && !exists($seen{$lst[0]});",
  "    my %seen;\n    for (@$lst) {\n\tnext if $seen{$_};\n\t$seen{$_}++;\n    }\n\
    \    return ! @$lst ? 1 : 0;\n}", "    my $count = -1;\n    my $len = @$lst;",
  "    my(@unsorted);\n    foreach (@$lst) {\n        push @unsorted, $_ if $_ < $_;\n\
    \    }\n    return scalar(@unsorted) == 0;\n}", "    my(@l) = sort($lst);\n  \
    \  return $l[0] > $l[-1];\n}", "    for (my $i = 0; $i < @$lst; $i++) {\n    \
    \    for (my $j = $i + 1; $j < @$lst; $j++) {\n            last if ($lst->[$i]\
    \ cmp $lst->[$j] == 1);\n        }\n    }\n    return 0 unless @$lst == 1;\n \
    \   return @$lst[0] > 1 ? '' : 0;\n}", "    my $i = 1;\n    my $s = 1;\n    my\
    \ $len = length($lst) - 1;\n    while (my $el = $lst[$i]) {\n        last if $s\
    \ == $el;\n        $i++;\n        $s++;\n    }\n    last unless $s == $len;\n\
    \    return 1;\n}", "    return 1 if @$lst == 0;\n    my(@sort) = ();\n    my(@reversed)\
    \ = ();\n    my($i) = 0;\n    my($count, $prev) = (0);\n    my($first, $last)\
    \ = (@$lst);", "    my $is_sorted = 1;\n    for my $val (@$lst) {\n        # Check\
    \ for duplicates\n        for my $i (0..$#$lst) {\n            next unless $i\
    \ eq $#$lst and $lst->[$i] eq $val;\n        }", "    return if ($#lst > 1 &&\
    \ $lst[0] eq $lst[-1]);\n    return 1 if ($lst[0] != $lst[1]);\n    if ($#lst\
    \ == 1) {\n        $_;\n    }\n    else {\n        my $i = 0;\n        my $dup\
    \ = 0;\n        for my $num (@$lst) {\n            ++$i if ($num eq $lst[$i]);\n\
    \        }\n        return 1 if ($i > 1);\n        return 1 if ($dup || $i ==\
    \ 1);\n        return \"\";\n    }\n}", "    my $sorted = 1;\n    $sorted = 1\
    \ if $lst[0] eq $lst[-1]; # O(n) search\n    $sorted = 1 if $lst[0] lt $lst[-1];\
    \ # O(n) search\n    return $sorted ? \"\" : \"1\";\n}", "    my $sorted = sort\
    \ {$a <=> $b} @$lst;\n    my $duplicate = grep{$lst == $_} @$sorted;\n    return\
    \ $duplicate ? $duplicate : 0;\n}", "    my $i = 0;\n    my @hash;\n    my %seen;\n\
    \    while (defined(my $num = $lst[$i])) {\n        $seen{$num}++;\n        $hash{$num}\
    \ = 1;\n        $i++;\n    }\n    for (@$lst) {\n        if (!defined($hash{$_}))\
    \ {\n            return 0;\n        }\n    }\n    return 1;\n}", '    my($first,
    $last, $seen);', "    my $sort = $lst->[0] || 0;\n    my(@sort) = ();"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
