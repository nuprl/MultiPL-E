name: HumanEval_13_greatest_common_divisor
language: pl
prompt: "# Return a greatest common divisor of two integers a and b\n# >>> greatest_common_divisor(3,\
  \ 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\nsub greatest_common_divisor\
  \ {\n    my($a, $b) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&greatest_common_divisor;\n\
  \        if(eq_deeply($candidate->(3, 7),1)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(10, 15),5)) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49,\
  \ 14),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(144,\
  \ 60),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $b > $a ? ($a, $b) : ($b, $a);\n}", "    my $a_b = $b / $a;\n \
    \   return $a if $b == $a_b;\n    return $a if $a_b % $b == 0;\n    return $b;\n\
    }", "    my @a = @{$_[0]};\n    my @b = @{$_[1]};\n    for (my $i = 0; $i < @a;\
    \ $i++) {\n        my $div = $a[$i];\n        for (my $j = 0; $j < @b; $j++) {\n\
    \            if ($a[$i] == $b[$j]) {\n                $div = $j;\n           \
    \ }\n        }\n        $a[$i] = $div;\n    }\n    return @{$_[0]};\n}", "   \
    \ $a -= $b;\n    while ($a % $b != 0) {\n        $a /= $b;\n    }\n    return\
    \ $a;\n}", "    return $a if $a < $b;\n    return $b if $a > $b;\n    my $i =\
    \ 0;\n    while($i < $a and $i < $b) {\n        $i++;\n    }\n    $i = $a if $i\
    \ < $a;\n    return $b if $i >= $b;\n    return $i;\n}", "    return greatest($b,\
    \ greatest($a, $b % $a));\n}", '    my $r;', "    my $div = 1;\n    while (0 <\
    \ $a and $b and $b != $a and $a != $b) {\n        $div = int(($a % $b) / $div);\n\
    \        $a = ($a / $b) if ($a / $b != 0);\n    }\n    return $div;\n}", "   \
    \ return $a if $a <= $b;\n    return $b if $b <= $a;\n    for my $d ($a, $b) {\n\
    \        return $d if $d % 2 == 0;\n    }\n    return $a\n}", '    local $_ =
    shift;', "    $a += 0 unless $a;\n    $b += 0 unless $b;\n    while (1) {\n  \
    \      $a = $a % $b;\n        return $a if $a != 0;\n        $b = $b % $a;\n \
    \       return $b unless $b != 0;\n    }\n}", "    my $c;\n    for(;;) {\n   \
    \     $c = $a % $b;\n        $a = $b if $b == $c;\n        $b = $c if $c != $a;\n\
    \        return $c;\n    }\n}", "    $b = 0 unless defined $b;\n    my $c = $a;\n\
    \    while ($a && $b and $a % $b == 0) { $c++ }\n    return $c;\n}", "    my $c\
    \ = $a % $b;\n    $c = $a if $c == 0;\n    $c = $b if $c > $b;\n    return $c;\n\
    }", "    $a < $b ? $a : $b\n}", "    my ($gc, $r) = (0, 0);\n    while (1) {\n\
    \        $gc = ($a % $b) + $r;\n        if ($gc < 0) {\n            $r--;\n  \
    \      } else {\n            $a = ($a / $gc) % $b;\n            $r = $gc if $r\
    \ == 0;\n        }\n        return $gc;\n    }\n}", "    return $a if $b == 0;\n\
    \    return gcd($a, $b) if $a % $b == 0;\n    return gcd($b, $a) if $b % $a ==\
    \ 0;\n    return $a % $b;\n}", "    my $gcd = gcd($a, $b);\n    return $gcd ==\
    \ $a ? $a : $gcd;\n}", '    $a > $b || return($b);', "    if ($a % $b) {\n   \
    \     return $b;\n    } else {\n        while ($a % $b) {\n            $b /= 2;\n\
    \        }\n        return $b;\n    }\n}", "    $b > $a and return $a if $b ==\
    \ $a;\n    for my $i (1..$b) {\n        if ($b % $i == 0) {\n            return\
    \ $i if $b / $i == $a;\n        }\n    }\n}", "    my $rem;\n    my $gcd = 1;\n\
    \    my $dividend;", '    my($div);', "    # Find GCD of a and b\n    $gcd = gcd($a,\
    \ $b);\n    # Return GCD\n    return $gcd;\n}", '    return undef unless $a and
    $b;', "    return 0 if $a == $b;\n    return $a if $b == 0;\n    my $lcm = ($a\
    \ % $b);\n    return $lcm if $lcm != 0;\n    my $greatest_common_divisor = $a\
    \ * (($b - $lcm) / $a + 1);\n    return $greatest_common_divisor if $greatest_common_divisor\
    \ != $b;\n    return $greatest_common_divisor + 1;\n}", "    my $c;\n    while\
    \ ($b > 0) {\n        $c = $b if $a % $b == 0;\n        $b--;\n    }\n    return\
    \ $c;\n}", "    my($m, $n);\n    my(@r);\n    $m = $a%$b;\n    $n = $a if $b ==\
    \ 0;\n    while (1) {\n        my($q, $r);\n        $q = $n;\n        $r = $m;\n\
    \        $m = $q % $r;\n        $n = $q if $r == 0;\n        if ($m == 0) {\n\
    \            push(@r, $n);\n            last;\n        }\n    }\n    pop(@r);\n\
    \    return $r; # Return greatest common divisor of a and b\n}", "    return greatest(@$a\
    \ % @$b, @$b % @$a);\n}", "    return $a if $b == 0;\n    return $a if $b % $a\
    \ == 0;\n    return $b;\n}", "    return $a if $a < $b;\n    $b > $a ? $b : $a;\n\
    }", "    abs($a) < abs($b) ? $a : $b;\n}", "    return undef if $a > $b;\n   \
    \ my($div, $mod);\n    for ($a = $a; $a > 1; $a--) {\n        $div = $a >> 1;\n\
    \        for ($b = $b; $b > 1; $b--) {\n            if ($b % $div == 0) {\n  \
    \              $mod = $b;\n                last;\n            }\n            $div\
    \ = $div << 1;\n        }\n    }\n    return $mod;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThe performance of `greatest_common_divisor` is `O(N^2)` where\
    \ `N` is the number of digits. In contrast, the `BigInt` solutions perform `O(N)`.\n\
    <|/ c |>\n<| c |>\nTo add to's comment, the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\
    \ computes the GCD of two numbers in `O(log(n))` time (and is extremely simple\
    \ to implement).\n<|/ c |>\n<| c |>\nThe GCD algorithm is also O(N) for BigInts\n\
    <|/ c |>\n<| a tags=math,algorithm,ruby,primes dscore=4 |>\nA few years later\
    \ (Ruby 1.9.3), I implemented the Euclidean Algorithm for determining the Greatest\
    \ Common Divisor using Math::GCD.  It does not require the use of BigInts.\n<code>\n\
    require \"math\"", "    my $d;\n    while (1) {\n        if ($a % $b == 0) {\n\
    \            $d = $b;\n            $b = $a / $b;\n            $a = $d;\n     \
    \   } else {\n            return $b;\n        }\n    }\n}", "    return $a if\
    \ $a < $b;\n    return $b if $b < $a;\n    while ($a != 0) {\n        $b = $b\
    \ / $a;\n        $a--;\n    }\n    return $b;\n}", "    return $a if $b == 0;\n\
    \    return $a if $b < $a;\n    my $gcd = $a % $b;\n    return greatest_common_divisor($b,\
    \ $gcd);\n}", "    my ($r) = Math::BigInt->_new($a);\n    my $remainder = $b -\
    \ $r->_mod;\n    return $r if $remainder == 0;\n    my $gcd;\n    while (1) {\n\
    \        ($gcd) =\n          $r->_div($b)->_mod->_div($r->_mod->_mod($r->_div($b)));\n\
    \        $r->_mod($b);\n        $b = $gcd;\n        last if $r->_mod($b) == 0;\n\
    \    }\n    return $r;\n}", "    $a -= 1;\n    $b -= 1;\n    while ($b > 0) {\n\
    \        if ($a % $b == 0) {\n            $a = $b / $a;\n        }\n        else\
    \ {\n            $b = $a % $b;\n        }\n    }\n    $a;\n}", "    return $a\
    \ if ($a % $b == 0);\n    return gcd($b, $a % $b);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=algorithm,math,language-agnostic,modulus,math |>\nThe simplest\
    \ and most accurate way I see is:\n<code>\nfunction gcd(a, b)\n    if a is even,\
    \ return b\n    if b is even, return a\n    if b > a, return a (a % b)\n    return\
    \ gcd(b, a % b)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is incorrect. Try gcd(15,\
    \ 8) and you will see you get 5 instead of 2\n<|/ c |>\n<| c |>\nSorry about the\
    \ typo, it should have been `gcd(b, a % b)`.\n<|/ c |>\n<| a tags=algorithm,math,language-agnostic,modulus,math\
    \ dscore=0 |>\nIn java\n<code>\npublic int gcd(int a, int b) {\n    if (a < b)\
    \ {\n        return gcd(b, a);\n    } else {\n        while (a % b != 0) {\n \
    \           a = b;\n            b = a % b;\n        }\n        return b;\n   \
    \ }\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,math,language-agnostic,modulus,math\
    \ dscore=0 |>\n<code>\npublic int gcd (int a, int b) {\n    if (b==0) return a;\n\
    \    return gcd(b, a%b);\n}\n</code>\n<|/ a |>\n<| a |>\nThis algorithm is used\
    \ in cryptography to find the greatest common denominator. \nThe algorithm will\
    \ find the greatest common denominator of the two numbers that you enter in and\
    \ returns the remainder. \nThe algorithm works by starting from the lowest number\
    \ and working down. Starting from the lowest number, if it divides evenly with\
    \ any other number then it will find the remainder of that division by that number.\
    \ If it divides evenly with itself then it will go on to the next lowest number\
    \ and it will find the remainder of the division by itself. If it divides evenly\
    \ with itself it will continue doing this until you get to the greatest common\
    \ denominator.\n<code>\nimport java.util.Scanner;\npublic class GCD{\n    public\
    \ static void main(String[] args){", "    # Euclid's Algorithm to calculate gcd\
    \ of 2 integers\n    # http://en.wikipedia.org/wiki/Euclidean_algorithm\n    #\
    \ http://www.mathsisfun.com/algebra/integer-greatest-common-divisor.html\n   \
    \ my $gcd = $a % $b;\n    return $a if $a < $b;\n    return $b if ($b % $gcd ==\
    \ 0);\n    return $gcd;\n}", "    return ($a < $b) ? $a : $b;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nI don't think it's that easy, since it requires the\
    \ use of [Math::BigInt](http://www.perlmonks.org/?node_id=797762). Also, this\
    \ doesn't actually use the gcd function.\n<|/ c |>\n<| c |>\n, `Math::BigInt`\
    \ isn't a requirement, it is just a convenient wrapper around Perl's native `Math::BigFloat`\
    \ type.\n<|/ c |>\n<| c |>\n: Yes, that's true. I just meant that it's very convenient\
    \ to use an already existing module instead of writing a subroutine.\n<|/ c |>\n\
    <| c |>\n`Math::BigInt` isn't a requirement. It just happens to be my favorite\
    \ module that wraps some of Perl's other modules. :-)\n<|/ c |>\n<| c |>\n: Sure,\
    \ I think it's an excellent idea to give a full working solution with an explanation\
    \ on how to implement it :-) But I think it's better to give the OP a chance to\
    \ learn how to do it himself, rather than give him a whole module for one simple\
    \ task.\n<|/ c |>\n<| a tags=algorithm,math,biginteger,perl |>\nHere is an algorithm\
    \ that might help you.", "    return $a % $b unless $b <= 0;\n    my $gcd = $a;\n\
    \    for (my $i = 1; $i <= $b; $i++) {\n        my $rt = $a % $i;\n        if\
    \ ($rt == 0) {\n            $gcd = $i;\n        }\n    }\n    return $gcd;\n}",
  "    if ($b <= 0) {\n\t$a = (abs($a) lt abs($b)) ? -$a : $b;\n\treturn $a;\n   \
    \ }\n    while ($a < $b) {\n\t$a = $b % $a;\n\t$b = $a;\n    }\n    return $b;\n\
    }", "    $b = 0 if $b < 0;\n    $a %= $b;\n    return $b if $a == 0;\n    my $gcd;\n\
    \    for (my $i = 1;  $i <= $b; $i++) {\n        $gcd = $i;\n        if ($a %\
    \ $gcd != 0){\n            $gcd = 1;\n            $a /= $gcd;\n        }\n   \
    \ }\n    return $gcd;\n}", '    my $m;', "    my $gcd = $a;\n    for (my $n =\
    \ $b + 1; $n <= $a; $n++) {\n        $gcd = $gcd*$n/gcd_test($n);\n    }\n   \
    \ return $gcd;\n}", '    my ($n) = @_;', "    if ($b <= 0) {\n        return 0;\n\
    \    }\n    return $a % $b;\n}", "    my $d = 1;\n    my $q;\n    while (1) {\n\
    \t$q = $b % $a;\n\t$d = $a if $q == 0;\n\t$a = $q;\n\tlast if $a < 1;\n    }\n\
    \    return $d;\n}", "    return $a > $b ? $a : $b;\n}", "    if ($a < $b) { $a\
    \ = $b }\n    if ($a == 0) { 1 }\n    else {\n        my($d, $k) = 0;\n      \
    \  while ($a % $d == 0) { $a /= $d }\n        while ($b % $d == 0) { $b /= $d\
    \ }\n        while ($d != 0) {\n            $k++;\n            $d = $k % $d;\n\
    \        }\n        return $d;\n    }\n}", "    my $gcd = 1;\n    while ($b) {\
    \ $gcd = ($b & $gcd) ? ($b & $gcd >> 1) : $b; $b >>= 1; }\n    return $gcd;\n}",
  "    $a <=> $b if ($a < $b); # Make sure $b is greater than $a\n    if ($a < 1)\
    \ {\n        $b++;\n        $a--;\n    }\n    my $remainder = 0;\n    while ($a\
    \ != 0) {\n        $remainder = $a % $b;\n        $a = ($b * $a - $remainder)\
    \ / $b;\n        $b--;\n    }\n    return $b;\n}", "    if ($a == 0) {\n     \
    \   return $b;\n    }\n    if ($b == 0) {\n        return $a;\n    }\n    my($d,\
    \ $e) = (0, 0);\n    my($c, $n) = (0, 1);\n    my($m, $p) = (1, 1);\n    for (;;)\
    \ {\n        my($k, $m) = divmod($m, $p, 1);\n        my($n, $p) = divmod($p,\
    \ $m, 1);\n        $e = $k + ($n - $c);\n        my($d, $p) = ($p, $m);\n    \
    \    $d = $d + $e, $c = $c;\n        last if ($e == $n);\n    }\n    return $d;\n\
    }", '    return 1 if ($a <= 0);', "    # Handle invalid input\n    if ($a eq 0)\n\
    \    {\n        return 0;\n    }\n    if ($b eq 0)\n    {\n        return $a;\n\
    \    }\n    # Handle case where b is a multiple of a\n    if (($a % $b) == 0)\n\
    \    {\n        return $b;\n    }\n    # Handle case where a is a multiple of\
    \ b\n    if (($b % $a) == 0)\n    {\n        return $a;\n    }\n    # Go with\
    \ the larger of the 2 numbers\n    return $a if $a > $b;\n    return $b;\n}",
  "    my $c = $b;\n    while ($a != $b) {\n        $c = $c % $a;\n        $a = $b;\n\
    \        $b = $c;\n    }\n    return $c;\n}", "    return $b if ($a < $b);\n \
    \   return $a if ($a > $b);\n    my $c = 1;\n    while ($a != 0) {\n        $c\
    \ = $b if ($c % $a == 0);\n        $a = int($a / $b);\n        $b = $c;\n    }\n\
    \    $b;\n}", "    my $gcd = $b;\n    for(my $i = $a - 1; $i > 1; $i--) {\n  \
    \      $gcd = $b if ($b % $i == 0);\n    }\n    return $gcd;\n}", "    return\
    \ $a if $b == 0;\n    my($d, $q, $r, $s, $t, $u, $v) = qw(1 0 1 0 1 0 0);\n  \
    \  $d = abs($a) if ($a < 0);\n    $d = abs($b) if ($b < 0);\n    $t = $a;\n  \
    \  do {\n        $r = $v%$t;\n        $s = $t;\n        $t = $q;\n        $q =\
    \ $r;\n        $v = $d;\n        $d = $r%$v;\n    } while (!$d);\n    return $v;\n\
    }", "    if ($a < $b) {\n        ($a, $b) = ($b, $a);\n    }\n    $a = abs($a);\n\
    \    $b = abs($b);\n    while ($a > $b) {\n        ($a, $b) = ($b, $a%$b);\n \
    \   }\n    return $b;\n}", "    $a = 0 unless defined $a;\n    $b = 0 unless defined\
    \ $b;\n    while ($a > $b) {\n        $a = $a % $b;\n    }\n    while ($b > $a)\
    \ {\n        $b = $b % $a;\n    }\n    return $a;\n}", "    my $c = $b == 1 ||\
    \ $a == 1 ? $a : $b / $a;\n    $c > $b ? $c : $b;\n}", "    my $n = abs($a) <=>\
    \ abs($b);\n    return $n < 0 ? $a : abs($a) <=> abs($b);\n}", "    while ($b\
    \ > 0) {\n        my $c = $a % $b;\n        $a = $b;\n        $b = $c;\n    }\n\
    \    return $a;\n}", "    while($b > 0) {\n        ($quotient, $remainder) = div($b,\
    \ $a);\n        last if $remainder < 0;\n        $a = $quotient;\n    }\n    return\
    \ $a;\n}", "    my ($x, $y) = (1, 1);\n    while (1) {\n        $x = $y; $y =\
    \ $a % $b;\n        $a = $b; $b = $y;\n        $x = $x if $x != 1;\n    }\n}",
  "    my $d;\n    while (1) {\n        $d = $a % $b;\n        return $d if $d ==\
    \ 0;\n        $b = $d;\n        $a = $a / $b;\n    }\n}", "    my $c;\n    my\
    \ $d = $a % $b;\n    if ($d != 0) {\n        $c = $b;\n    } else {\n        $c\
    \ = $a;\n    }\n    while ($a != $c) {\n        $a = $b;\n        $b = $c;\n \
    \       $c = $a % $b;\n    }\n    return $c;\n}", "    my($div) = 1;\n    while\
    \ (1) {\n        # Divide both $a and $b and check if they can be\n        # divided\
    \ by $div.  If so, exit.\n        if ($div > 1) {\n            if ($a % $div ==\
    \ 0) {\n                return $div;\n            }\n            if ($b % $div\
    \ == 0) {\n                return $div;\n            }\n        }\n        if\
    \ ($div == 1) {\n            # One of them could be a square.\n            if\
    \ ($a % $div == 0 && $b % $div == 0) {\n                return $div;\n       \
    \     }\n            # They must be of different primes, so try again to divide\n\
    \            # one by $div.\n            $div--;\n        }\n        $div++;\n\
    \    }\n}", "    ($a % $b == 0) ? $a / $b : greatest_common_divisor($b, $a % $b);\n\
    }", "    return $a if $b <= $a;\n    my($c, $d) = $a % $b, $b;\n    while ($c\
    \ < $d) {\n        $c++;\n        $d = $d % $b;\n    }\n    return $c;\n}", " \
    \   my ($gcd, $remainder, $temp) = (0, 0);\n    while ($a != 0) {\n        $remainder\
    \ = $b % $a;\n        $temp = $a;\n        $a = $b;\n        $b = $remainder;\n\
    \        $gcd = $temp;\n    }\n    return $gcd;\n}", "    return $a if $a % $b\
    \ == 0;\n    return $b unless $b == 0;\n    return $b if ($a % $b == 0);\n   \
    \ return greatest_common_divisor($b / 2, $a);\n}", "    return $a if $a > $b;\n\
    \    $a = $a % $b;\n    if ($a > 0) {\n\treturn $b;\n    } else {\n\tfor (my $i\
    \ = $b; $i >= 1; $i--) {\n\t    if ($a % $i == 0) {\n\t\treturn $i;\n\t    }\n\
    \t}\n\treturn $b;\n    }\n}", "    my ($m, $n) = ($a, $b);\n    my $q = $a % $b;",
  "    my $d;\n    for (my $i = 1; $i <= $b; $i++) {\n        if ($b % $i == 0) {\n\
    \            $d = $i;\n        }\n    }\n    return $d;\n}", "    return $a if\
    \ ($b <= $a);\n    my $lcm = $a % $b;\n    if ($lcm != 0) {\n        return $lcm;\n\
    \    }\n    my $gcd = $a // $b;\n    if ($a > $b) {\n        $gcd = $b // $a;\n\
    \    }\n    return $gcd;\n}", "    my $c = $a % $b;\n    while (!($a % $b == $c))\
    \ {\n\t$b = $c;\n\t$c = $a % $b;\n    }\n    return $c;\n}", "    return greatest_common_divisor($b,\
    \ $a % $b);\n}", "    $a =~ s/^0x//;\n    $b =~ s/^0x//;\n    return $a // $b;\n\
    }", "    return $a if $a < $b;\n    return $b if $b < $a;\n    return $a if $a\
    \ > $b;\n    return $b;\n}", "    return $a if ($a < $b);\n    my $m = $a % $b;\n\
    \    return $b if ($m == 0);\n    return greatest_common_divisor($b, $m);\n}",
  "    while ($a && $b) { $a = $b % $a; $b = $a if $b == 0; $a--; }\n    return $a;\n\
    }", "    $a > $b ?  $a : $b;\n}", "    return $a if $a > $b;\n    return $b;\n\
    }", "    return $a if $b == 0;\n    return gcd($a, $b-1);\n}", '    return 0 if
    $a < $b;', "    return $a if $b <= $a;\n    return $a if $b == 1;\n    return\
    \ $b unless $a % $b == 0;\n    return $b;\n}", "    $a >= $b ? $a : $b;\n}", " \
    \   my $c;\n    $c = $a % $b while $a && $b; # until a is zero\n    $c != 0 &&\
    \ $c > $b and $c or $c;\n}", "    $b > $a and return $a if $b == 1;\n    return\
    \ $a if $b == $a->{sign};\n    my $gcd = $a->{sign} == 1 ? $b : $a->{sign} ==\
    \ -1 ? $a : $a->{sign} == 0 ? greatest_common_divisor($a, $b / $a->{sign}) :\n\
    \        greatest_common_divisor($a->{sign} == -1 ? $b / $a->{sign} : $a->{sign}\
    \ == 0 ? $a : $b, $a->{sign} == -1 ? $a->{sign} : $a->{sign} == 0 ? $a : $b /\
    \ ($a->{sign} == -1 ? $a->{sign} : $a->{sign} == 0 ? $a->{sign} : $a->{sign}));\n\
    \    return $gcd == $b ? $gcd : $gcd * $b;\n}", "    return gcd($a, $b)\n    \
    \    if $a <= $b;\n    my($a, $b) = @_;\n    return gcd($b, $a)\n        if $a\
    \ <= $b;\n    $a==$b ? $a : gcd($a/$b, $b);\n}", '    my $gcd;', "    while ($a\
    \ % $b) { $a /= $b; }\n    return $a;\n}", "    # Check to make sure it's valid\
    \ input\n    if (not defined $a or $a < 1 or defined $b or $b < 1) {\n       \
    \ return undef;\n    }\n    # Check to make sure it's not prime\n    if ($a >\
    \ 1 and not defined $b or ($b > 1 and $a % $b == 0)) {\n        $a = $b;\n   \
    \     $b = $a - $b;\n        $a = $a - $b;\n    }\n    # Now we'll just calculate\
    \ the GCD\n    while ($a > 1) {\n        $b = $a % $b;\n        $a = $a - $b;\n\
    \    }\n    return $b;\n}", "    my $result;\n    for my $num (@{$a}, @{$b}) {\n\
    \        $result ||= $num;\n        while ($num % $result != 0) {\n          \
    \  $result *= $result;\n        }\n        $result /= $num;\n    }\n    return\
    \ $result;\n}", "    while($a >= $b) {\n        $a--;\n        last if $a < 0;\n\
    \    }\n    return $a;\n}", "    my $gcd = 1;\n    while($a != 0) {\n        my\
    \ $mod = $a % $gcd;\n        $a = $gcd;\n        $gcd = $mod;\n    }\n    return\
    \ $gcd;\n}\n</code>\n<|/ a |>\n<| c |>\n+1 for clever use of Moo's `reduce` method.\
    \  I like that this is actually tail-recursive and so doesn't impose an arbitrary\
    \ limit on argument size.  (It's an optimisation: Moo can't optimise this out\
    \ completely.)\n<|/ c |>\n<| c |>\nMoo's `reduce` method is also much faster than\
    \ `greatest_common_divisor`.\n<|/ c |>\n<| c |>\nI think that the Moo reduce method\
    \ is actually faster than the recursive method (which does the same thing) when\
    \ run a million times.  It's also faster when run on a single number.\n<|/ c |>\n\
    <| c |>\nAgree that it's faster and should be considered a better solution than\
    \ `greatest_common_divisor` on any modern machine.  The benchmarking code doesn't\
    \ prove it, but it *does* show it *is* faster.\n<|/ c |>\n<| c |>\nI suspect you're\
    \ right, but when I run Moo benchmarks on my machine they show that the recursive\
    \ solution is actually slower.\n<|/ c |>\n<| a tags=perl dscore=4 |>\nIf it has\
    \ to be a subroutine, you can get it done with a little help from the modulus\
    \ operator:\n<code>", "    return $a if $b <= $a;\n    $b - $a if $b % $a == 0;\n\
    }", "    my $gcd = $a % $b;\n    $gcd ? ($a / $gcd > $b ? $a / $b : $a / $b) :\
    \ $a;\n}", "    \n    # Verify that the inputs form a valid GCD problem\n    my\
    \ ($div, $remainder) = div($a, $b);\n    \n    # Return the div if it's smaller\
    \ than the remainder \n    return $div if $div < $remainder;\n    \n    # Return\
    \ the remainder if they're equal\n    return $remainder;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=perl |>\nHere is a simple code based on Ben J's post:\n<code>\n\
    use strict;\nuse warnings;", "    my ($x, $y) = ($a % $b, $b);\n    while ($x\
    \ > 0 && $y > 0) {\n        ($x, $y) = ($y, $x % $y);\n    }\n    return $x if\
    \ $y == 0;\n    return $a;\n}", "    return greatest($a / $b, $b);\n}", "    if\
    \ ($b == 0) return $a;\n    my $c = $a;\n    while($a != 0) {\n        $a = $b\
    \ / $c;\n        $b = $c;\n        $c = $c;\n    }\n    return $a;\n}", "    $a\
    \ % $b == 0 ? $a : $b\n}\n</code>\n<|/ a tags=perl,linux,performance,python,shell\
    \ |>\n<| a tags=perl,linux,performance,python,shell |>\nA Perl solution:\n<code>\n\
    perl -E '$x=<>;chomp;while(<>){/\\d+/&&$y/=$_;END{print greatest($x,$y)}'\n</code>\n\
    Example:\n<code>\n$ seq 1 100 | perl -E '$x=<>;chomp;while(<>){/\\d+/&&$y/=$_;END{print\
    \ greatest($x,$y)}'\n</code>\nOutput:\n<code>\n99\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nOops. I meant `perl -E '$x=<>; chomp; while(<>){say greatest($x,<$_>)'`\
    \ :-)\n<|/ c |>\n<| a tags=perl,linux,performance,python,shell |>\nI ran this\
    \ on a RHEL5 system with 10G of ram and didn't have any problems. I got this output\
    \ from top after 3 runs.\n<code>\nuser@hostname:~$ time ./greatest_common_divisor_perl\n\
    10", '    return $b unless $b == 0;', "    return 0 if $a < 0 || $b < 0;\n   \
    \ return $a if $a <= $b;\n    return $b if $b <= $a;", "    # we already know\
    \ $a is positive, and $b is positive, so we can just\n    # return $a if $b is\
    \ zero\n    return $a if $b == 0;\n    return $a if $b <= $a;\n    my $r;\n  \
    \  my $d;\n    my $m;\n    my $gcd;\n    my $remainder = 0;\n    foreach my $i\
    \ ($a, $b) {\n        $remainder = 0;\n        $remainder += $i if $i % $i ==\
    \ 0;\n        $remainder += $i if $i % $a == 0;\n        $remainder += $i if $i\
    \ % $b == 0;\n        $remainder += $i if $i % $a == $b;\n        $remainder +=\
    \ $i if $i % $b == $a;\n        $remainder += $i if $i % $a == $b;\n        $remainder\
    \ += $i if $i % $b == $a;\n        $remainder += $i if $i % $a == $b;\n      \
    \  $remainder += $i if $i % $b == $a;\n        $remainder += $i if $i % $a ==\
    \ $b;\n        $remainder += $i if $i % $b == $a;\n        $remainder += $i if\
    \ $i % $a == $b;\n        $remainder += $i if $i % $b == $a;\n        $remainder\
    \ += $i if $i % $a == $b;\n        $remainder += $i if $i % $b == $a;\n      \
    \  $remainder += $i if $i % $a == $b;\n        $remainder += $i if $i % $b ==\
    \ $a;\n        $remainder += $i if $i % $a == $b;\n        $remainder += $i if\
    \ $i % $b == $a;\n        $remainder += $i if $i % $a == $b;\n        $remainder\
    \ += $i if $i % $b == $a;\n        $remainder += $i if $i % $a == $b;\n      \
    \  $remainder += $i if $i % $b == $a;\n        $remainder += $i if $i % $a ==\
    \ $b;\n        $remainder += $i if $i % $b == $a;\n        $remainder += $i if\
    \ $i % $a == $b;\n        $remainder += $i if $i % $b == $a;\n        $remainder\
    \ += $i if $i % $a == $b;\n        $remainder += $i if $i % $b == $a;\n      \
    \  $remainder += $i if $i % $a == $b;\n        $remainder += $i if $i % $b ==\
    \ $a;", "    my ($m, $d) = greatest($a % $b, $b % $a);\n    $d > $m ? $d : $m;\n\
    }\n</code>\nI may have misunderstood the question, but this seems to do what you\
    \ want.\n<|/ a |>\n<| a |>\nHere's a solution I wrote:\n<code>", "    my $x;\n\
    \    $x = 0;\n    until ($x != $a%$b) {\n        $x++;\n    }\n    return $x;\n\
    }", "    while ($a != 0) {\n        $b %= $a;\n        $a = ($a * 10 + $b) / 10;\n\
    \    }\n    return $b;\n}", "    my $gcd = $a % $b;\n    return $gcd unless $gcd\
    \ == 0;\n    while (1) {\n        $b = $b % $gcd;\n        $gcd = $gcd;\n    \
    \    last unless $gcd;\n    }\n    return $gcd;\n}", "    die \"Cannot divide\
    \ by zero\" if $a eq $b;\n    my $d;\n    while ($a != 0) {\n        if ($b &\
    \ 1) {\n            $d = $b;\n        }\n        elsif ($a & 1) {\n          \
    \  $d = $a;\n        }\n        else {\n            $d = $a / $b;\n        }\n\
    \        $a = $d % $b;\n    }\n    return $d;\n}", "    \n    $a > $b ? $a : $b;\n\
    }", "    my ($r, $t) = @_;\n    $r = $t if $t == 0;\n    if ($a == 0) {\n    \
    \    return $b;\n    }\n    return $r if $a % $b;\n    my $r = $b; $r /= $a;\n\
    \    $r = $r if $b > $t;\n    return $r;\n}", "    return gcd($a, $b) == 1 ? $a\
    \ : gcd($b, $a) == 1 ? $b : undef;\n}", "    return undef unless $a && $b;\n \
    \   my $gcd = $a % $b;\n    my $i = 1; # count up to $gcd\n    while ($gcd) {\n\
    \        $gcd = $b % $gcd;\n        $i++;\n    }\n    return $i;\n}", "    my\
    \ ($gcd) = $b - $a if $a > $b;\n    defined $gcd and return $gcd;\n}", "    return\
    \ unless $a and $b;\n    return $b <= $a ? $b : $a;\n}", "    return 0 unless\
    \ $b > $a;\n    my $gcd = $a % $b;\n    while ($gcd) {\n        $b = $a % $b;\n\
    \        $a = $b;\n        $gcd = $a % $b;\n    }\n    return $a;\n}", "    my\
    \ $c = $a % $b;\n    while ($c) {\n        $a = $b;\n        $b = $c;\n      \
    \  $c = $a % $b;\n    }\n    return $b;\n}\n</code>\n<|/ a dscore=1 tags=integer,math,perl,division\
    \ |>\n<| c |>\n: Yes, I do want to say that. I did not mean to imply that I had\
    \ answered his question in any particular way.\n<|/ c |>\n<| c |>\nYes, I did.\
    \ That was my intention. He wanted to have a generic division function, so I just\
    \ threw that code up in there. Btw, it's funny, but my answer was deleted before\
    \ I was able to answer it myself (I thought he had deleted it). My answer was\
    \ also posted as a comment to the other answer here: http://stackoverflow.com/questions/5781428/division-between-two-numbers-in-perl\n\
    <|/ c |>\n<| c |>\n: It's not funny at all. I've spent many many hours over the\
    \ years in Perl, and I feel like I was a Perl guru (which I am), but my code was\
    \ very different.\n<|/ c |>\n<| c |>\nI thought you were the guru for Perl :)\n\
    <|/ c |>\n<| c |>\n: I wasn't the guru, but thanks for posting your answer. I\
    \ was trying to find out if there was some Perl magic to do it, but that doesn't\
    \ appear to be possible. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nYou can use the\
    \ modulo operator % to get the remainder of $a/$b, then divide by $b:\n<code>",
  "    return $a if $a < $b;\n    return $b if $a > $b;\n    while ($a != 0) {\n \
    \       $a -= $b if ($a % $b == 0);\n        $b *= 10;\n    }\n    return $b;\n\
    }", "    $a > $b ? $a : $b;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere's a\
    \ version that doesn't use a hash and only works for integers. It uses a loop\
    \ to test each of the two numbers, and each time it finds one that isn't the other\
    \ it swaps them and returns the answer:\n<code>", "    my $gcd;\n    do {\n  \
    \      $gcd = $a % $b;\n        $a = $b;\n        $b = $gcd;\n    } while ($gcd\
    \ != 0);\n    return $a != 1 ? $a : -1;\n}", "    return $a if $a <= $b or $b\
    \ == 0;\n    return $b;\n}", "    return 1 if $a < $b;\n    return $b if ($a %\
    \ $b == 0);\n    while ($b > 0) {\n        $b = $a % $b;\n        $a++;\n    }\n\
    \    return $a;\n}", "    ($a < $b) ? $a : ($a > $b) ? $b : undef;\n}", "    $b\
    \ < $a and return $a if $b == 1;\n    my $remainder = $a % $b;\n    return greatest_common_divisor($b,\
    \ $remainder);\n}", "    my $gcd = 1;\n    for (my $i = 0; $i <= $b; $i++) {\n\
    \        $gcd = $a % $gcd if $a /= $gcd;\n    }\n    return $gcd;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks, this is a better solution than my own.\n<|/\
    \ c |>\n<| c |>\n`greatest_common_divisor` does not always return the greatest\
    \ common divisor. The gcd is not necessarily a number that can be represented\
    \ as an integer (think `greatest_common_divisor(3,4)` vs `greatest_common_divisor(9,8)`).\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    my $r = $a % $b;\n    $r += $b if ($r\
    \ == 0);\n    return $r;\n}", '    return $a if ($a < $b);', "    return 0 unless\
    \ $a && $b;\n    $a > $b ? $a : $b\n}", "    $a < $b\n        ? $b\n        :\
    \ greatest_common_divisor($b, $a % $b);\n}", "    while (@_ > 1) {\n        $a\
    \ = $b;\n        $b = pop(@_);\n        $b /= $a;\n        $a = $b;\n    }\n \
    \   return $a;\n}", "    return $b if ($a < $b);\n    while ($a > $b) {\n    \
    \    $a = $a % $b;\n    }\n    return $a;\n}", "    if ($a < $b) {\n        my\
    \ $tmp = $a;\n        $a = $b;\n        $b = $tmp;\n    }", "    return greatest($a\
    \ / $b, $b);\n}", "    my ($x, $y);\n    $x = abs($a) - abs($b);\n    $y = abs($b);\n\
    \    while ($x > $y) {\n        $x = $x - $y;\n    }\n    return $x;\n}", "  \
    \  if ($a < $b) { return $a }\n    elsif ($a == $b) { return 1 }\n    else { return\
    \ gcd($b, $a % $b) }\n}", "    my $div = 1;\n    while($b > 0) {\n        if($b\
    \ % $a == 0) {\n            return $div;\n        }\n        $div++;\n       \
    \ $b /= $a;\n    }\n    return $div;\n}\n</code>\n<|/ a tags=perl dscore=1 |>\n\
    <| c |>\n: I believe that the question was about integers only, not arbitrary\
    \ precision integers.\n<|/ c |>\n<| a tags=perl dscore=1 |>\nPerhaps something\
    \ like this:\n<code>\nuse List::MoreUtils qw(any);", "    return 0 if ($a == 0\
    \ || $b == 0);\n    $a -= $b;\n    $b -= $a;\n    while ($a >= $b) {\n       \
    \ $a -= $b;\n    }\n    return $a;\n}", '    return $a unless $a > $b;', "   \
    \ return $a if ($a < $b);\n    return $b if ($a < $b);\n    return ($a % $b) if\
    \ ($a % $b == 0);\n    return $b if ($a % $b != 0);\n    return greatest_common_divisor($b,\
    \ $a % $b);\n}", "    my $gcd = 0;\n    while($a > 0) {\n        $b = $b % $a;\n\
    \        $gcd = $a if $b <= 0;\n        $a = $a - $b;\n    }\n    return $gcd;\n\
    }", "    my($temp, $common);\n    $temp = $a % $b;\n    $common = $a if $a ==\
    \ $b;\n    $common = $a if $temp == 0;\n    $common = $b if $temp == 0;\n    return\
    \ $common;\n}\n</code>\n<|/ a tags=perl |>\n<| a tags=perl |>\nHere's another\
    \ solution (based on a previous solution to find the greatest common divisor):\n\
    <code>\nuse warnings;\nuse strict;\nuse feature qw(say);\nuse v5.10;", "    my\
    \ $r = 1;\n    $a %= $b;\n    until ($a != 0) {\n        $r %= $a;\n        $a\
    \ = ($a - $b) / $r;\n    }\n    $r;\n}", "    # Compute GCD without using any\
    \ modules. This is just for fun.\n    # This is an O(N^2) algorithm, but it's\
    \ not even bad because of the O(n).\n    # It's not as good as a hashmap or radix\
    \ sort, so I'll stop here.\n    # We'll see about optimizing this later.\n   \
    \ my $gcd = 1;\n    for (my $i = $a; $i < $b; $i++) {\n        last if $gcd ==\
    \ 1;\n        my $d = $a % $i;\n        $gcd = $d if $gcd > $d;\n    }\n    return\
    \ $gcd;\n}", "    return $a > $b ? ($b > $a ? $b : $a) : $a > $b ? $a : $b;\n}",
  "    return $a > $b ? $a : $b;\n}", "    return $a if ($a < $b);\n    return $b\
    \ if ($a < $b);\n    while ($a % $b != 0) {\n        $b--;\n    }\n    return\
    \ $b;\n}", "    $a % $b || $b % $a || abs($a % $b) == abs($b % $a);\n}", "   \
    \ my ($r, $x, $y) = (0, $a, $b);\n    while ($x != $y) {\n        ($r, $x, $y)\
    \ = ($y, $x % $y, $x);\n    }\n    return $r;\n}", "    if ($a < 0) {\n      \
    \  $a = abs($a);\n        $b > 0 ? $b = -$b : $b = -$b;\n    }\n    return ($a\
    \ % $b);\n}", "    return $a if $a < $b;\n    return $b if $a > $b;\n    return\
    \ $a % $b if $a % $b;\n    carry = 1 if $a > $b;\n    while ($a >= $b and $carry)\
    \ {\n        $a = ($b * ($a / $b) + 1);\n        last if $a > $b;\n    }\n   \
    \ return $b;\n}", "    return $a if $a == $b;\n    my($n) = $a % $b;\n    return\
    \ $n if $n == 0;\n    my($m) = $b - $n % $b;\n    return $m if $m == 0;\n    return\
    \ $m;\n}", "    my $c;\n    $a %= $b;\n    while (1) {\n        $c++;\n      \
    \  $b = $a % $b;\n        $a = $c if $a == $b;\n    }\n    return $a;\n}", " \
    \   my $max = max $a, $b;\n    if ($max < 1) {\n        return 1;\n    } elsif\
    \ ($max < $a) {\n        $max = $a;\n    } elsif ($max < $b) {\n        $max =\
    \ $b;\n    }\n    return $max;\n}", '    my $gcd;', "    \n    while (1) {\n \
    \       $a = $b % $a;\n        $b = $a if $b == 0;\n        last if $a == 0;\n\
    \    }\n    $a;\n}", "    if ($a == 0) {\n        return $b;\n    }\n    return\
    \ greatest_common_divisor($b - $a, $a - 1);\n}", '    my ($div, $mod);', "   \
    \ return unless $a && $b;\n    my $gcd = $a > $b ? $a : $b;\n    for (my $i =\
    \ $gcd + 1; $i && $i !== $b; $i++);\n    return $i ? $i : $a;\n}", "    return\
    \ undef unless defined $a and defined $b;\n    my $gcd = $b;\n    $gcd = 1 unless\
    \ $a % $gcd;\n    my $m = $a / $gcd;\n    $gcd = 1 unless $b % $gcd;\n    my $n\
    \ = $b / $gcd;\n    $gcd = 1 unless $m * $n >= $gcd * ($m + $n);\n    my $lcm\
    \ = $m * $gcd;\n    $lcm == $m or $lcm == $n or $lcm == ($m * $n);\n}", "    if\
    \ ($b == 0) return $a;\n    if ($a <= 0) { return 0; }\n    if ($a % $b == 0)\
    \ return $b;\n    return greatest_common_divisor($b - 1, $a % $b);\n}", "    if\
    \ ($b eq 0) {\n        return $a;\n    }", "    my $gcd;\n    $gcd = $a % $b;\n\
    \    $gcd > $a ? $gcd : $gcd < $b ? $a : $b;\n}", "    return undef unless defined\
    \ $a and defined $b;\n    my $a_rem = $a % $b;\n    return $b unless defined $a_rem;\n\
    \    my $greatest_divisor = $b;\n    do {\n        $greatest_divisor = $greatest_divisor\
    \ % $a;\n    } while ($greatest_divisor != $a_rem);\n    return $greatest_divisor;\n\
    }", "    my $d = $a % $b;\n    if ($d == 0) {\n        return $b;\n    }\n   \
    \ else { \n        return $d;\n    }\n}", "    return $a >= $b ? ($b == 0 ? $a\
    \ : $a) : ($a == 0 ? $b : $b);\n}", "    my $c;\n    my $d;", "    return $b if\
    \ ($a < $b);\n    while ($a % $b) {\n        $b = $b << 1;\n    }\n    return\
    \ $b;\n}", "    my $d = $a % $b;\n    return $d if ($d != 0);\n    return $b if\
    \ ($a == $b);\n    my $i = 1;\n    while ($a % $i && $b % $i && ($i != $b)) {\n\
    \        $i++;\n    }\n    return $i;\n}", "    return 0 if $a < $b;\n    return\
    \ 1 if $a == $b;\n    return $a if $b == ($a | $a >> 1);\n    return $b;\n}",
  "    return $a < $b ? $a : $b;\n}", "    die \"First argument must be greater than\
    \ second\" unless $a >= $b;\n    my $d;\n    my $rem;\n    my $quotient = -1;\n\
    \    my $limit = $a < $b ? $a : $b;\n    my $x = 1;\n    while ($x < $limit) {\n\
    \        $d = $b;\n        $rem = 0;\n        while ($d >= $x) {\n           \
    \ $rem = $d - $x;\n            $quotient = $quotient * $a + $rem;\n          \
    \  $d = $x / $x;\n        }\n        $x = $x * $a;\n    }\n    return $quotient;\n\
    }", "    my $c = $a % $b;\n    while ($c != 0) {\n        my $d = $b % $c;\n \
    \       $a = $c;\n        $b = $d;\n        $c = $a % $b;\n    }\n    return $a;\n\
    }\n</code>\n<|/ a tags=algorithm,math,primes dscore=1 |>\n<| a dscore=0 |>\nHere\
    \ is how I solved the problem. It was a hard problem to solve. Basically I needed\
    \ an efficient way to calculate a prime factorization of a number. I needed this\
    \ for my project. The code below is the Python implementation.\n<code>", "   \
    \ return unless $a != 0 && $b != 0 && $a >= $b;\n    return $a if $b == 0;\n \
    \   return $b if $a == 0;\n    return gcd($a, $b);\n}", "    my $n = 0;\n    while\
    \ ($a > 0 && $b > 0) {\n        if ($a % $b == 0) {\n            $b = $b - $a\
    \ % $b;\n            $a = $a / $b;\n            $n = $a + $b;\n        }\n   \
    \     else {\n            $a = $a - $a % $b;\n            $b = $b / $a;\n    \
    \    }\n    }\n    return $n;\n}\n</code>\n<|/ a tags=math,algorithm,perl,numbers\
    \ dscore=1 |>\n<| c |>\nThe OP asked for the *greatest* common divisor of two\
    \ numbers. This algorithm returns the *least* common multiple of the two.\n<|/\
    \ c |>\n<| c |>\nAs noted in the comments, this algorithm is wrong for negative\
    \ numbers. You need to *reverse* the numbers before calling this algorithm.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out.  I added a comment to the code.\n\
    <|/ c |>\n<| c |>\nThank you. I've updated my code. Your algorithm works now.\n\
    <|/ c |>\n<| c |>\nSure, but your algorithm doesn't work for negative numbers,\
    \ and the comments pointed out that you needed to *reverse* the numbers. I edited\
    \ my answer to show how to do this in a way that doesn't require reversing them.\n\
    <|/ c |>\n<| a tags=math,algorithm,perl,numbers |>\nHere's a solution that works\
    \ for negative numbers:\n<code>", "    return $a if $a > $b;\n    return $b;\n\
    }", "    return $a if ($a > $b);\n    return $b if ($a < $b);\n    return $a if\
    \ ($a % $b == 0);\n    return $b if ($a % $b == 0);\n    return greatest_common_divisor($b,\
    \ $a % $b);\n}", "    my ($n, $r, $q, $m, $i, $j, $cum_q, $cum_q_r, $cum_q, @q,\
    \ $s, $r, $u, $p) = (0, 0, 1, 1, 0, 0, 0);\n    my $tmp = $a;\n    my $tmp2 =\
    \ $b;\n    my ($tmp1, $tmp2, $tmp3, $tmp4) = ($a, $b, $tmp, $tmp2);\n    if ($a\
    \ == $b) {\n        $s = $a = $tmp1 = $tmp2 = 0;\n    }\n    while (1) {\n   \
    \     $cum_q += $q;\n        $cum_q_r += $q_r;\n        if ($cum_q <= $cum_q_r)\
    \ {\n            $n = $cum_q;\n            $q = 0;\n            $m = 1;\n    \
    \    }\n        else {\n            $n = $cum_q_r;\n            $q = 1;\n    \
    \        $m = $cum_q;\n        }\n        for ($i = $m; $i <= $n; $i++) {\n  \
    \          $tmp3 = $tmp2 * $i;\n            $tmp4 = $tmp2 * $m * $i;\n       \
    \     $r += $tmp3 / $tmp4;\n            $q_r += $r * $i;\n            $q += $q_r;\n\
    \        }\n        $s = $a * $q + $b * $q_r;\n        if ($s == 0) {\n      \
    \      last if $n == 1;\n            return $n;\n        }\n        if ($s ==\
    \ 1) {\n            $tmp += $tmp2;\n            $tmp2 -= $tmp;\n            $tmp\
    \ = $s;\n        }\n        if ($n >= $u) {\n            $tmp2 = $b + ($tmp2 -\
    \ $a) / $n;\n            $q += $q_r;\n            $tmp1 = $cum_q_r / $n;\n   \
    \         $u += $q;\n        }\n        else {\n            $tmp2 = $a + ($tmp\
    \ - $b) / $n;\n            $q += $q_r;\n            $tmp1 = $cum_q / $n;\n   \
    \         $u += $q_r;\n        }\n        $i = $q % 2;\n        $cum_q += $i;\n\
    \        $cum_q_r += $q_r * (1 - $i);\n        if ($cum_q <= $cum_q_r) {\n   \
    \         $n = $cum_q;\n            $q = 0;\n            $m = 1;\n        }\n\
    \        else {\n            $n = $cum_q_r;\n            $q = 1;\n           \
    \ $m = $cum_q;\n        }\n        for ($i = $m; $i <= $n; $i++) {\n         \
    \   $tmp3 = $tmp2 * $i;\n            $tmp4 = ", "    # If the divisor is zero,\
    \ return zero\n    return $a if $a < $b;\n    # If the divisors are equal, return\
    \ one\n    return $a if $a == $b;\n    # Otherwise calculate the greatest common\
    \ divisor of\n    # the two divisors and return the result.\n    return $b //\
    \ $a if $b and $a % $b;\n}", "    ($a % $b)\n}", "    my $d = $a % $b;\n    while\
    \ ($d != 0) {\n        $d = $b - $d;\n        $b = ($b - 1) if ($b > 1);\n   \
    \ }\n    return $b;\n}", "    $a -= $b if $a < $b;\n    $b -= $a if $b < $a;\n\
    \    while (1) {\n        if ($a % $b == 0) {\n            return $b;\n      \
    \  } elsif ($b % $a == 0) {\n            return $a;\n        }\n        my $r1\
    \ = $a % $b;\n        my $r2 = $b%$a;\n        $a = $b;\n        $b = $r1;\n \
    \       $a = $r2;\n    }\n}", "    return $a > $b ? $a : $b;\n}", "    my $div\
    \ = do {\n        my $tmp = $a % $b;\n        if ($tmp) {\n            $tmp;\n\
    \        } else {\n            do {\n                $tmp = $b / $a;\n       \
    \     } while ($tmp != $b);\n            $tmp;\n        }\n    };\n    $div;\n\
    }\n</code>\n<|/ a tags=perl,math |>\n<| c |>\nI'm getting a syntax error at `sub\
    \ greatest_common_divisor {` ... Any ideas?\n<|/ c |>\n<| c |>\nAh, I see. I didn't\
    \ realize I had to define a `sub` first (didn't even know that existed). Thanks\
    \ for explaining this!\n<|/ c |>\n<| a dscore=1 |>\nAs the answer above stated,\
    \ your problem is that you are dividing by zero.\nIf $a and $b are both 0, then\
    \ $div is also 0.\nYour code should look something like this:\n<code>", "    my\
    \ ($n, $d) = greatest_common_divisor($b, $a % $b);\n    if ($d == $b) {\n    \
    \    $n = $a / $b;\n    }\n    return $n;\n}", "    if ($a == 0) {\n        return\
    \ $b;\n    }\n    if ($b == 0) {\n        return $a;\n    }\n    if ($a < 0) {\n\
    \        $a = -$a;\n        $b = -$b;\n    }\n    return $a * greatest_common_divisor($a\
    \ - $b + 1, $b);\n}", "    if ($a < $b) {\n        $a = $b;\n        $b = $a;\n\
    \    }", "    $a =~ s/-inf$//; $a =~ s/^\\d+//; $a *= 1; $a /= $b;\n    $b =~\
    \ s/-inf$//; $b =~ s/^\\d+//; $b *= 1; $b /= $a;\n    return $a % $b;\n}", " \
    \   my $d = Math::GCD($a, $b);\n    return $a if ($d == $b);\n    return $d if\
    \ ($a == $d);\n    return gcd($a, $d);\n}", '    my $c;', "    $a >= $b ? $a :\
    \ $b\n}", "    return 1 if $a < $b;\n    return $a if $a == $b;\n    my $c;\n\
    \    for (; $a > 0; $a--, $b--, $c++) {\n        if ($b == 0) {\n            $c\
    \ = $a;\n            last;\n        }\n    }\n    return $c;\n}", "    if ($a\
    \ eq $b) {\n        return $a;\n    }\n    my($div, $remainder) = (0, 1);\n  \
    \  while (1) {\n        my $temp = $a % $b;\n        $remainder = $b;\n      \
    \  $b = $a;\n        $a = $temp;\n        if ($a == 0) {\n            return $div;\n\
    \        }\n        $div++;\n    }\n}", "    if ($a > $b) {\n        $a = $b;\n\
    \    }\n    elsif ($a < $b) {\n        $b = $a;\n    }\n    my $gcd = 0;\n   \
    \ my $q = 0;\n    my $r = 0;\n    while ($a != 0) {\n        $gcd++;\n       \
    \ if ($a & 1) {\n            $a = ($a >> 1) | ($b << 31);\n        }\n       \
    \ else {\n            $q = ($q >> 1) | ($b << 31);\n        }\n    }\n    while\
    \ ($b != 0) {\n        $gcd++;\n        if ($b & 1) {\n            $b = ($b >>\
    \ 1) | ($a << 31);\n        }\n        else {\n            $r = ($r >> 1) | ($a\
    \ << 31);\n        }\n    }\n    \n    my $lcm = $q * $r / $gcd;\n    return $lcm;\n\
    }", "    ($a % $b) == 0 ? $a : $b;\n}", "    # check if a is divisible by b\n\
    \    my $gcd = greatest_divisor($a);\n    # check if b is divisible by a\n   \
    \ return if greatest_divisor($b) eq $gcd;\n    # else find the GCD\n    $gcd =\
    \ gcd($a, $b);\n    return $gcd;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
