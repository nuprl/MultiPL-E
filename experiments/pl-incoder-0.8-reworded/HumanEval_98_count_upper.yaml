name: HumanEval_98_count_upper
language: pl
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper(\"aBCdEf\")\n# 1\n# >>> count_upper(\"abcdefg\"\
  )\n# 0\n# >>> count_upper(\"dBBE\")\n# 0\nsub count_upper {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_upper;\n\
  \        if(eq_deeply($candidate->(\"aBCdEf\"),1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdefg\"),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dBBE\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->(\"B\"),0)) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"U\"),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  \"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  EEEE\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return length((split(//,$s))[0 .. $s-1 % length($s)]);\n}", " \
    \   $s =~ tr/A-Z/A-Z/;\n    length($s) % 2 ? 0 : $s - 1;\n}", "    my $count =\
    \ 0;\n    for($s) {\n        if ($_ eq 'a' ) {\n            $count++;\n      \
    \  } elsif ($_ eq 'A' ) {\n            $count++;\n        } elsif ($_ eq 'e' )\
    \ {\n            $count++;\n        } elsif ($_ eq 'E' ) {\n            $count++;\n\
    \        } elsif ($_ eq 'i' ) {\n            $count++;\n        } elsif ($_ eq\
    \ 'I' ) {\n            $count++;\n        } elsif ($_ eq 'o' ) {\n           \
    \ $count++;\n        } elsif ($_ eq 'O' ) {\n            $count++;\n        }\
    \ elsif ($_ eq 'u' ) {\n            $count++;\n        } elsif ($_ eq 'U' ) {\n\
    \            $count++;\n        } elsif ($_ eq 'y' ) {\n            $count++;\n\
    \        } elsif ($_ eq 'Y' ) {\n            $count++;\n        }\n    }\n   \
    \ return $count;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt isn't a great idea\
    \ to try to reinvent the wheel. Using `index` is far better than writing a regex.\n\
    <|/ c |>\n<| c |>\nThe `index` function isn't a regex. `index` doesn't need to\
    \ compile to a regex to work. `index` takes a string and a substring, not a regex,\
    \ and it doesn't compile anything.\n<|/ c |>\n<| c |>\n- I added a function that\
    \ uses `index`.  It was my understanding that `index` didn't use regex at all,\
    \ but I could be wrong.\n<|/ c |>\n<| c |>\nYeah, it's not a regex, but you're\
    \ still using regex to find a substring.\n<|/ c |>\n<| c |>\nPerl regexes are\
    \ just compiled Perl code. The \"regex engine\" does a lot of work to implement\
    \ a regular expression by actually *parsing* the regex. I can't speak for what\
    \ the regex is doing behind the scenes, but it's not using the same parsing logic\
    \ that's used in `index`.\n<|/ c |>\n<| a tags=perl,algorithm |>\nHere's a nice\
    \ one-liner:\n<code>\n$string =~ tr/aeiouyAEIOUY//cd;\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\n+1 for showing me this handy shortcut :)\n<|/ c |>\n<| c |>\nI\
    \ don't think this works with non-ASCII characters. From the docs:", '    my($num_uppercase,
    $num_even);', "    my $n = length $s;\n    for my $i (0 .. $n-1) {\n        my\
    \ $x = $i & 1;\n        if ($s & $x)\n        {\n            my $j = $i + 1;\n\
    \            if ($j > $n)\n            {\n                $j = $n;\n         \
    \   }\n            while($j > 0) {\n                if ($s & $x) {\n         \
    \           return $j;\n                }\n                $j -= $x + 1;\n   \
    \         }\n            return $n;\n        }\n    }\n    return 0;\n}", "  \
    \  $s =~ tr/A-Z/a-z/;\n    return $s =~ tr/[AEIOU]/[aeiou]/;\n}", "    my $vowel\
    \ = qr/[aeiou]/;\n    my $num_vowel = 0;\n    my $start = 0;\n    my $len = 0;",
  "    my @c = split //, $s;\n    for (my $i = 0; $i < @c; ++$i) {\n        my $c\
    \ = $c[$i];\n        if ($c eq \"A\") {\n            ++$i;\n        } elsif ($c\
    \ eq \"a\") {\n            ++$i;\n        } elsif ($c eq \"B\") {\n          \
    \  ++$i;\n        } elsif ($c eq \"b\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"C\") {\n            ++$i;\n        } elsif ($c eq \"c\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"D\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"d\") {\n            ++$i;\n        } elsif ($c eq \"E\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"e\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"F\") {\n            ++$i;\n        } elsif ($c eq \"f\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"G\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"g\") {\n            ++$i;\n        } elsif ($c eq \"H\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"h\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"I\") {\n            ++$i;\n        } elsif ($c eq \"i\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"J\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"j\") {\n            ++$i;\n        } elsif ($c eq \"K\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"k\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"L\") {\n            ++$i;\n        } elsif ($c eq \"l\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"M\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"m\") {\n            ++$i;\n        } elsif ($c eq \"N\") {\n      \
    \      ++$i;\n        } elsif ($c eq \"n\") {\n            ++$i;\n        } elsif\
    \ ($c eq \"O\") {\n            ++$i;\n        } elsif ($c eq \"o\") {\n      \
    \      ++$i;\n        } elsif ($c ", '    my($cnt);', "    return 0 if $s eq '';",
  "    my $count = 0;\n    for (my $i = 1;  $i <= length($s);  ++$i) {\n        if\
    \ (substr($s, $i, 1) eq 'a' &&\n            substr($s, $i, 2) eq 'A') {\n    \
    \        ++$count;\n        }\n    }\n    return $count;\n}", "    my $i = 0;\n\
    \    foreach my $c (split //, $s) {\n        if ($c eq \"a\") { $i += 1 }\n  \
    \      if ($c eq \"e\") { $i += 1 }\n        if ($c eq \"i\") { $i += 1 }\n  \
    \      if ($c eq \"o\") { $i += 1 }\n        if ($c eq \"u\") { $i += 1 }\n  \
    \      if ($c eq \"e\") { $i += 1 }\n        if ($c eq \"i\") { $i += 1 }\n  \
    \      if ($c eq \"o\") { $i += 1 }\n        if ($c eq \"u\") { $i += 1 }\n  \
    \      if ($c eq \"A\") { $i += 1 }\n        if ($c eq \"E\") { $i += 1 }\n  \
    \      if ($c eq \"I\") { $i += 1 }\n        if ($c eq \"O\") { $i += 1 }\n  \
    \      if ($c eq \"U\") { $i += 1 }\n        if ($c eq \"a\") { $i += 1 }\n  \
    \      if ($c eq \"e\") { $i += 1 }\n        if ($c eq \"i\") { $i += 1 }\n  \
    \      if ($c eq \"o\") { $i += 1 }\n        if ($c eq \"u\") { $i += 1 }\n  \
    \      if ($c eq \"e\") { $i += 1 }\n        if ($c eq \"i\") { $i += 1 }\n  \
    \      if ($c eq \"o\") { $i += 1 }\n        if ($c eq \"u\") { $i += 1 }\n  \
    \      if ($c eq \"A\") { $i += 1 }\n        if ($c eq \"E\") { $i += 1 }\n  \
    \      if ($c eq \"I\") { $i += 1 }\n        if ($c eq \"O\") { $i += 1 }\n  \
    \      if ($c eq \"U\") { $i += 1 }\n        if ($c eq \"A\") { $i += 1 }\n  \
    \      if ($c eq \"E\") { $i += 1 }\n        if ($c eq \"I\") { $i += 1 }\n  \
    \      if ($c eq \"O\") { $i += 1 }\n        if ($c eq \"U\") { $i += 1 }\n  \
    \      if ($c eq \"a\") { $i += 1 }\n        if ($c eq \"e\") { $i += 1 }\n  \
    \      if ($c eq \"i\") { $i += 1 }\n        if ($c eq \"o\") { $i += 1 }\n  \
    \      if ($c eq \"u\") { $i += 1 }\n    }\n    return $i;\n}\n</code>\n<|/",
  "    $s =~ tr/AEIOUaeiou/AEIOU/;\n    return () = $s =~ /([AEIOUaeiou])/g;\n}",
  '    my $count = 0;', "    $s =~ s/\\B(AEIOU)//g;\n    length($s) -\n    (length($s)\
    \ -\n    length($s =~ s/[AEIOU]//g));\n}", "    my $num_upper = 0;\n    $s =~\
    \ s/([aeiou])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n    $s\
    \ =~ s/([AEIOU])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n  \
    \  $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n    $s =~ s/([aeiou])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1", " \
    \   my $n = 0;\n    for(my $i=0;$i<length($s);$i++) {\n        last if($s[i] eq\
    \ \"A\" && $s[$i-1] eq \"B\" && $s[$i-2] eq \"C\");\n        $n++ if $s[$i] eq\
    \ \"a\";\n    }\n    return $n;\n}", "    my($n) = 0;\n    for(my $i = 0; $i <\
    \ length($s); $i++) {\n        $n = $n + ord(substr($s, $i, 1)) >= 65 && ord(substr($s,\
    \ $i, 1)) <= 90 ? 1 : 0;\n    }\n    return $n;\n}", "    my $uc = @$s;\n    for\
    \ (my $i = 0; $i <= $uc / 2; $i++) {\n        if ($s->[$i] =~ /[AEIOU]/) {\n \
    \           $uc++;\n        }\n    }\n    return $uc;\n}", "    my $even = ()\
    \ = $s =~ /even/i;\n    my $upper = 0;\n    for (@_) {\n        $upper += 0 if\
    \ $_ eq 'A'; # A is already counted\n        $upper += 0 if $_ eq 'a'; # A is\
    \ already counted\n        $upper += 0 if $_ eq 'E';\n        $upper += 0 if $_\
    \ eq 'e';\n        $upper += 0 if $_ eq 'I';\n        $upper += 0 if $_ eq 'i';\n\
    \        $upper += 0 if $_ eq 'O';\n        $upper += 0 if $_ eq 'o';\n      \
    \  $upper += 0 if $_ eq 'U';\n        $upper += 0 if $_ eq 'u';\n        $upper\
    \ += 0 if $_ eq 'a';\n        $upper += 0 if $_ eq 'e';\n        $upper += 0 if\
    \ $_ eq 'i';\n        $upper += 0 if $_ eq 'o';\n        $upper += 0 if $_ eq\
    \ 'u';\n        $upper += 0 if $_ eq 'Y';\n        $upper += 0 if $_ eq 'y';\n\
    \        $upper += 0 if $_ eq 'Z';\n        $upper += 0 if $_ eq 'z';\n      \
    \  $upper += 0 if $_ eq 'S';\n        $upper += 0 if $_ eq 's';\n        $upper\
    \ += 0 if $_ eq 'W';\n        $upper += 0 if $_ eq 'w';\n        $upper += 0 if\
    \ $_ eq 'X';\n        $upper += 0 if $_ eq 'x';\n    }\n    return $even ? $upper\
    \ : 0 - $upper;\n}", "    $s =~ /([aeiou])([aeiou])([aeiou])/;\n    return length($1)\
    \ + length($2) + length($3);\n}", "    $s =~ tr/aeiouAEIOU/u;\n    return $s -\
    \ uc($s);\n}", "    my $vowels = \"aeiouAEIOU\";\n    $s =~ tr/AEIOU/$vowels/;\n\
    \    (length($s) % 2) != 0 ? (length($s) / 2) + 1 : 0;\n}", '    my($cx) = 0;',
  "    my($vowel) = 'A' .. 'Z';\n    $s =~ tr/a//cd;\n    my $i;\n    my $n_vowel\
    \ = 0;\n    for ($i = 0 ; $i < length($s) ; $i++){\n        $n_vowel += 1 if ($vowel++\
    \ eq $s[$i]);\n    }\n    return $n_vowel;\n}", "    my $count = 0; # number of\
    \ uppercase vowels\n    for (my $i = 0; $i <= length($s); $i++) {\n        if\
    \ (substr($s, $i, 1) =~ /[AEIOU]/) {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}", "    $s =~ tr/AEIOUaeiou/aeiou/;\n    my $count = 0;\n\
    \    while ($s =~ /[AEIOUaeiou]/) {\n        $count += $1 eq 'A' ? 1 : 0;\n  \
    \      $s =~ tr/AEIOUaeiou/aeiou/;\n    }\n    return $count;\n}", "    my($num_upper);\n\
    \    for my $i (0..length($s) - 1) {\n        if ($s[i] eq \"A\" && $s[i+1] eq\
    \ \"B\") {\n            $num_upper += 1;\n        } elsif ($s[i] eq \"a\" && $s[i+1]\
    \ eq \"b\") { \n            $num_upper += 1;\n        } elsif ($s[i] eq \"B\"\
    \ && $s[i+1] eq \"B\") {\n            $num_upper += 1;\n        } elsif ($s[i]\
    \ eq \"b\" && $s[i+1] eq \"B\") {\n            $num_upper += 1;\n        } elsif\
    \ ($s[i] eq \"C\" && $s[i+1] eq \"D\") {\n            $num_upper += 1;\n     \
    \   } elsif ($s[i] eq \"c\" && $s[i+1] eq \"d\") {\n            $num_upper +=\
    \ 1;\n        } elsif ($s[i] eq \"D\" && $s[i+1] eq \"D\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"d\" && $s[i+1] eq \"d\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"E\" && $s[i+1] eq \"F\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"e\" && $s[i+1] eq \"f\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"F\" && $s[i+1] eq \"f\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"g\" && $s[i+1] eq \"G\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"g\" && $s[i+1] eq \"g\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"G\" && $s[i+1] eq \"G\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"g\" && $s[i+1] eq \"g\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"h\" && $s[i+1] eq \"H\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"h\" && $s[i+1] eq \"h\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"H\" && $s[i+1] eq \"H\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"h\" && $s[i+1] eq \"h\") {\n            $num_upper\
    \ += 1;\n        } elsif ($s[i] eq \"I\" && $s[i+1] eq \"J\") {\n            $num_upper\
    \ += 1;", "    my @vowels = (\"A\", \"E\", \"I\", \"O\", \"U\");\n    my $count\
    \ = 0;\n    for ($s =~ /[AEIOUY]/g) {\n        if ($1 =~ /^[AEIOU]/) {\n     \
    \       $count += $1 eq \"A\" ? 0 : 1;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my $prev_c = 0;\n    my $i = 3;\n    while ($i <\
    \ length($s)) {\n        if ($s[$i] =~ /[AEIOU]/) {\n            $count++;\n \
    \           $prev_c = 0;\n        }\n        $prev_c = $s[$i];\n        $i++;\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nThank\
    \ you very much for showing me how to count upper case characters. However, I\
    \ could not figure out how to make it work on a list of strings. The code below\
    \ gives me the total of all upper case letters across all my strings.", "    my\
    \ $count = 0;\n    for (my $i=0; $i<length($s); $i++) {\n        if ($s[$i] eq\
    \ \"A\" || $s[$i] eq \"E\" || $s[$i] eq \"I\" || $s[$i] eq \"O\" || $s[$i] eq\
    \ \"U\") {\n            $count += 1;\n        }\n    }\n    return $count;\n}",
  "    my @chars = split(//,$s);\n    my $count = 0;", '    my(@upper,@lower);', " \
    \   $s =~ tr/aeiouAEIOU/AEIOU/;\n    my $cnt = 0;\n    $cnt += length($&);\n \
    \   $cnt += length($') * length($') - $s - 1;\n    return $cnt;\n}", "    my $count\
    \ = 0;\n    while ($s =~ /[^aeiouAEIOU]/g) {\n        if ($s =~ /^(?:[aeiouAEIOU])\\\
    1$/) {\n            $count++;\n        }\n    }\n    return $count;\n}", "   \
    \ $s =~ tr/A-Z/a/;\n    $s =~ tr/a-z/a/;\n    $s =~ tr/A-Z/A-Z/;\n    $s =~ tr/a-z/a-z/;\n\
    \    return ($s =~ tr/A-Z/a/);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease\
    \ add an explanation.\n<|/ c |>\n<| a |>\n<code>\nmy $str = q{I like Perl.};\n\
    my $uppers = 0;\nwhile($str =~ /[A-Z]/) {\n    if($str =~ /[A-Z]/g) {\n      \
    \  $uppers++;\n    }\n}\nsay $uppers;\n</code>\n<|/ a tags=perl,regex dscore=2\
    \ |>\n<| a tags=perl,regex |>\nHere's another way to do it using lookahead assertions.\
    \  This works fine with multiline strings.  It works with strings of any length\
    \ and with unicode strings.  It also works with long strings.  It's not too complicated\
    \ once you understand it.\n<code>", "    my(@pairs) = ();\n    for(my $i = 0;\
    \ $i < @$s; ++$i) {\n        if($s[$i] =~ /^[aeiouAEIOU]$/) {\n            push(@pairs,\
    \ $i, $i);\n        }\n    }\n    my $count = 0; for (@pairs) {\n        my $i\
    \ = $pairs[$_]->[0];\n        my $j = $pairs[$_]->[1];\n        my $char = $s->[$i];\n\
    \        $char =~ /^[aeiou]$/\n          and $char += $s->[$j]\n          and\
    \ ++$count;\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| c |>\n: Thanks\
    \ for your effort! But this program is also not working. I have used \"perl5.14\"\
    \ for above code.\n<|/ c |>\n<| c |>\n: Thanks for your effort! But this program\
    \ is also not working. I have used \"perl5.14\" for above code.\n<|/ c |>\n<|\
    \ c |>\n: Thanks for your effort! But this program is also not working. I have\
    \ used \"perl5.14\" for above code.\n<|/ c |>\n<| c |>\n: Thanks for your effort!\
    \ But this program is also not working. I have used \"perl5.14\" for above code.\n\
    <|/ c |>\n<| c |>\n: Thanks for your effort! But this program is also not working.\
    \ I have used \"perl5.14\" for above code.\n<|/ c |>\n<| a |>\nPerl Solution\n\
    <code>", "    my $vowels = qr/[aeiou]/;\n    $s =~ s/$vowels//g;\n    $s =~ s/^$vowels/0/;\n\
    \    $s =~ s/$vowels$//g;\n    return length($s);\n}", "    $s =~ s/([^A-Z])//g;\n\
    \    $s =~ s/^[^A-Z]/0/;\n    return length($s);\n}", "    $s =~ tr/A-Z/a-z/;\n\
    \    $s =~ tr/aeiouAEIOU/AEIOU/;\n    return length($s) - length($s =~ tr/a+/aa/g);\n\
    }", "    $s =~ s/([aeiou])\\1/$1/g;\n    my $len = length($s);\n    if ($len &\
    \ 1) {\n        $s =~ s/(.)\\1/$1$1/g;\n        $len ++;\n    }\n    my $count\
    \ = 0;\n    for (0 .. $len-1) {\n        if ($s =~ /^(.)\\1$/) {\n           \
    \ $count ++;\n        }\n    }\n    $count;\n}", "    $s =~ s/^$::RE::SUB::CAPTURE//;\n\
    \    my $i = 0;\n    while ($i < length($s)) {\n        last unless defined $s[$i]\
    \ and $s[$i] eq $::RE::SUB::CAPTURE;\n        if ($s[$i] eq $::RE::SUB::CAPTURE)\
    \ {\n            $i++;\n        }\n        elsif ($s[$i] =~ /^[A-Z]/) {\n    \
    \        $i++;\n        }\n        elsif ($s[$i] =~ /^[^A-Z]/) {\n           \
    \ $i++;\n        }\n        elsif ($s[$i] =~ /^\\Q$::RE::SUB::CAPTURE\\E$/) {\n\
    \            $i++;\n        }\n        else {\n            last;\n        }\n\
    \    }\n    return $i - 1;\n}", "    my $n = length($s);\n    my $count = 0;\n\
    \    my $i = $n - 1;\n    for (; $i >= 0; $i--) { # count upward from end\n  \
    \      last if ($s[i] eq 'A' || $s[i] eq 'a');\n        $count += 1;\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my $idx;\n    for ($idx = 0;\
    \ $idx < length($s); $idx++) {\n        if (substr($s, $idx, 1) =~ /[AEIOU]/)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    $s\
    \ =~ tr/A-Z/a/;\n    $s =~ tr/a/A/g;\n    return $s =~ tr/B/C/g;\n}\n</code>\n\
    <|/ a tags=perl |>\n<| c |>\nAs a side note, `perl -M5.010 -0` will give you the\
    \ 5.10 version of `perl` instead of 5.8.  This is helpful if you have 5.8.x code\
    \ you need to run with 5.10.  But you can also use `perl -M5.010 -0v` to get a\
    \ verbose output for 5.10 as well.\n<|/ c |>\n<| c |>\nWow, that makes so much\
    \ sense. Thank you!\n<|/ c |>\n<| c |>\nThe \"-M5.010 -0\" flag will break any\
    \ perl 5 program that uses features that were introduced in perl 5.10 (unless\
    \ you use experimental features with 5.10)\n<|/ c |>\n<| c |>\nYes, that's correct.\
    \ I also added the `-0` option to my answer.\n<|/ c |>\n<| c |>\nAh, the `-M5.010\
    \ -0` thing was the ticket. Thanks again!\n<|/ c |>\n<| a dscore=1 tags=perl |>\n\
    The following regex will work if the string is a single lowercase letter followed\
    \ immediately by a digit. \n<code>\n/^[a-z][0-9]/\n</code>\n<|/ a |>\n<| c |>\n\
    This would match all lower case letters followed by digits.  OP wants the match\
    \ to be on a single character.\n<|/ c |>\n<| a dscore=1 |>\nA regex that matches\
    \ a single character in a given range will look like\n<code>\n^[abc\\d]$\n</code>\n\
    If you want to match on any single character (without considering case), then\
    \ use this:\n<code>\n^[\\d]$\n</code>\nOr, if you want only lowercase letters:\n\
    <code>\n^[a-z]$\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis would match all lower\
    \ case letters followed by digits.  OP wants the match to be on a single character.\n\
    <|/ c |>\n<| c |>\nAh, yes, you're right.  I misread the question.  I'll edit\
    \ my answer.\n<|/ c |>\n<| a dscore=0 tags=perl |>\nYou can use a lookahead assertion:\n\
    <code>\n$string =~ /^(?=[a-z])/;\n</code>\nThis would match any lowercase letter\
    \ followed by any number of characters, not just a ", "    my $cnt = 0;\n    for\
    \ (split //, $s) {\n        ++$cnt if ($_ eq 'A' && $cnt++ % 2);\n        ++$cnt\
    \ if ($_ eq 'B' && $cnt++ % 2);\n        ++$cnt if ($_ eq 'C' && $cnt++ % 2);\n\
    \        ++$cnt if ($_ eq 'D' && $cnt++ % 2);\n        ++$cnt if ($_ eq 'E' &&\
    \ $cnt++ % 2);\n        ++$cnt if ($_ eq 'F' && $cnt++ % 2);\n    }\n    return\
    \ $cnt;\n}", "    my(@chars);\n    foreach my $char (split(//, $s)) {\n      \
    \  push(@chars, $char) if $char =~ /[AEIOU]/;\n    }\n    my $count = 0;\n   \
    \ foreach my $i (0 .. $#chars) {\n        $count += $chars[$i] =~ /[AEIOU]/;\n\
    \    }\n    return $count;\n}", "    my $even = 0;\n    $even++ if /([aeiou])\\\
    1/;\n    $even++ if /([aeiou])\\2/;\n    $even++ if /([aeiou])\\3/;\n    return\
    \ $even;\n}", "    my $count   = 0;\n    my $pos     = 1;\n    my $prev_chr =\
    \ \"\";", "    $s =~ /([aeiou])/;\n    $1 =~ /([aeiou])/;\n    return $1 + $1;\n\
    }", "    # Count the number of uppercase vowels in the even indices of the alphabet\n\
    \    my $num_upper = () = grep { m/^[aeiou]/ } ($s =~ /./);\n    $num_upper +=\
    \ $s =~ /[^aeiou]/g;\n    return $num_upper;\n}", "    return scalar(@$s{@_} =~\
    \ /AEIOU|[AEIOU]/g);\n}", "    return 0 if $s =~ /[aeiou]/;\n    return 0 if $s\
    \ =~ /^[^aeiou]$/;\n    my @chars = split //, $s;\n    my %seen;\n    for (@chars)\
    \ {\n        if ($seen{$_}++ % 2 != 0) {\n            return 0;\n        }\n \
    \   }\n    return 1;\n}", "    return undef unless defined $s;\n    my $count\
    \  = 0;\n    for ($s =~ /(?=[aeiou])/) {\n        $count++ if $1 == uc($1);\n\
    \    }\n    return $count;\n}", "    my(@c) = unpack(\"C*\", $s);\n    my($upper);\n\
    \    \n    if (scalar(@c) % 2) {\n        return 0;\n    }\n    \n    for (my\
    \ $i = 0; $i < scalar(@c); $i += 2) {\n        $upper = 1 if ($c[$i] eq \"A\"\
    \ && !$c[$i+1]);\n        last unless $upper;\n    }\n    return $upper;\n}",
  '    my $count = 0;', "    $s =~ /([AEIOU])/;\n    return $1 =~ /[AEIOU]/? 1 : 0;\n\
    }", "    my($num);\n    while($s =~ /([aeiou])([aeiou])/) {\n        $num += 1\
    \ if $1 eq 'a'; $num += 1 if $1 eq 'e'; $num += 1 if $1 eq 'i'; $num += 1 if $1\
    \ eq 'u';\n        $num += 1 if $2 eq 'a'; $num += 1 if $2 eq 'e'; $num += 1 if\
    \ $2 eq 'i'; $num += 1 if $2 eq 'u';\n    }\n    return $num;\n}", "    my(@c)\
    \ = split(//,$s);\n    my($result);", "    # use /g so we don't have to worry\
    \ about multiple letters\n    my $cnt = 0;\n    for (my $i = 0; $i < length($s);\
    \ $i++) {\n        my $c = substr($s, $i, 1);\n        if ($c eq 'A' or $c eq\
    \ 'E' or $c eq 'I' or $c eq 'O' or $c eq 'U') {\n            $cnt++;\n       \
    \ }\n    }\n    return $cnt;\n}\n</code>\n<|/ a tags=perl,python,ruby |>\n<| c\
    \ |>\nYou should never name a variable with Perl keywords or the underscore (`_`)\
    \ symbol. http://stackoverflow.com/questions/488979/what-are-the-rules-governing-the-reusability-of-perl-functions\n\
    <|/ c |>\n<| c |>\n: I know. I did that to help the OP understand what's going\
    \ on. I also mentioned it in a comment on the question, since I was going to do\
    \ that myself. If you're going to do that, at least use a different name for the\
    \ variable than the name of the function.\n<|/ c |>\n<| c |>\nThanks, I got it\
    \ now. Just to point out that \"use warnings\" and similar should be done on the\
    \ module level so that you don't have to include it in every subroutine you write.\
    \ Of course, doing so would make these functions much less useful. As I said,\
    \ I'm just a Python guy, so it's possible that there are other ways to write this\
    \ code.\n<|/ c |>\n<| c |>\n, no, those are warnings. They're there for a reason.\
    \ You're correct that there might be other ways to write this code, but I'd prefer\
    \ to write it that way because it helps other programmers read it and understand\
    \ how it works. It's not always necessary, of course, but for someone who knows\
    \ Perl well, it really helps.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ndef count_vowels(s):\n\
    \   c = 0\n   for i in xrange(len(s)):\n      if s[i] == 'a' or s[i] == 'e' or\
    \ s[i] == 'i' or s[i] == 'o' or s[i] == 'u':\n         c += 1\n   return c\n</code>\n\
    <|/ a tags=perl,python,ruby |>\n<| c |>\nYou could replace the test for `A` to\
    \ `z` with `if i in range(ord('a'),ord('z')):` (the latter being more pythonic,\
    \ but probably slower too).\n<|/ c |>\n<| a tags=perl,python,ruby |>\nThis doesn't\
    \ address your Python question, but I think you were interested in the Python\
    \ part. Your code is definitely too verbose to ", "    my @result;\n    for my\
    \ $i (0..$#s) {\n        my $x = substr($s, $i, 1);\n        if (!$x eq \"_\"\
    ) {\n            push @result, 1 if $x eq 'A' or\n                           \
    \   $x eq 'E' or\n                              $x eq 'I' or\n               \
    \               $x eq 'O' or\n                              $x eq 'U';\n     \
    \   }\n    }\n    scalar(@result);\n}", "    $s =~ tr/A-Z//cd;\n    return $s\
    \ !~ tr/A-Z//cd;\n}\n</code>\n<|/ a |>\n<| c |>\nI used `$s =~ tr/A-Z//cd;` and\
    \ it works, but I have to use `$s =~ tr/A-Z//cd;` not `uc()`. Can you explain\
    \ your code? `tr` converts upper case letters to lower case letters. Then `//cd`\
    \ removes them from `$s` and it returns the number of the letters.\n<|/ c |>\n\
    <| c |>\nYou're asking why you had to use `$s =~ tr/A-Z//cd;` instead of `uc()`?\
    \  You don't need the return statement in this case; that's what the `//cd` modifier\
    \ does.  It removes all upper case letters from the string.  Then, it returns\
    \ the number of letters that were removed.\n<|/ c |>\n<| c |>\nI know that, my\
    \ question is why `//cd` modifier removes all the upper case letters and return\
    \ number, and what does `//cd` do in `tr`? `tr` converts upper case letters to\
    \ lower case letters and remove them, but why it removes them when used with `//cd`?\n\
    <|/ c |>\n<| c |>\nSee [`man perlop`](http://perldoc.perl.org/perlop.html#Modifiers):\
    \ *These operators modify the string in place and return the number of substitutions\
    \ made, or undef if the string was empty or unchanged.*\n<|/ c |>\n<| c |>\nI\
    \ know `//` modifier, I asked what it does in tr. I think now I know what it does,\
    \ thanks.\n<|/ c |>\n<| a dscore=1 |>\nPerl does have the ability to do things\
    \ in one statement (as I showed in my comment). However, it does so by modifying\
    \ the string in place. So, we can make that modifier return the number of replacements\
    \ made:\n<code>\nmy $string = 'aBcDdEf';\n$string =~ tr/A-Z//cd;\nprint \"$string\
    \ has $& replacements.\\n\";\n</code>\nOutputs:\n<code>\naBcDdEf has 7 replacements.\n\
    </code>\nThe /c modifier makes it return the number of replacements made, which\
    \ is exactly what we want. Then, the /d modifier makes it remove the letters.\
    \ This is necessary because tr is \"global\". That is to say, it translates all\
    \ instances of A-Z into their lowercase counterparts, then removes all instances\
    \ of that same letter", "    my $count = 0;\n    my @chars = split //, $s;\n \
    \   for (my $i = 0; $i < $#chars; $i++) {\n        if ($chars[$i] =~ /[AEIOU]/g)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    return\
    \ 0 if $s =~ /[aeiouy]/;\n    $s =~ tr/aeiouy//;\n    return $s =~ tr/a//;\n}",
  "    $s =~ tr/A-Z/A-Z/;\n    return $. % 2;\n}", "    my $count = 0;\n    my $i\
    \ = -1;\n    for (my $i = 0; $i < length($s); $i++) {\n        if (substr($s,\
    \ $i, 1) eq 'A') {\n            $count++;\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a tags=perl,arrays dscore=1 |>\n<| c |>\nThanks everyone. I like\
    \ the solution by because it is concise and readable.\n<|/ c |>\n<| a tags=perl,arrays\
    \ dscore=0 |>\nHere is a solution that uses a hash to keep track of vowels:\n\
    <code>", "    my $even = 0;\n    my $i = 0;\n    my $n = 0;\n    my $vowels =\
    \ \"AEIOU\";\n    for (my $x = 0; $x < length($s); $x++) {\n        next unless\
    \ $s[$x] eq $vowels[$i];\n        $n++;\n        $even++;\n    }\n    return $even\
    \ * $n;\n}", "    my @vowels = qw(aa aE eE iI oO uU);\n    my $count = 0;\n  \
    \  my $i = 0;\n    $i = index($s, $vowels[$i], $count);\n    return $count if\
    \ $i >= 0;\n    return $count + 1 if $i && ($s[i] eq 'A' || $s[i] eq 'E');\n \
    \   $i = 0;\n    $i = index($s, $vowels[$i], $count);\n    return $count if $i\
    \ >= 0;\n    return $count + 1 if $i && ($s[i] eq 'a' || $s[i] eq 'e');\n    $i\
    \ = 0;\n    $i = index($s, $vowels[$i], $count);\n    return $count if $i >= 0;\n\
    \    return $count + 1 if $i && ($s[i] eq 'i' || $s[i] eq 'o');\n    $i = 0;\n\
    \    $i = index($s, $vowels[$i], $count);\n    return $count if $i >= 0;\n   \
    \ return $count + 1 if $i && ($s[i] eq 'u' || $s[i] eq 'i');\n    return 0;\n}",
  "    return 0 unless $s;\n    $s =~ tr/AEIOUaeiou/aeiou/;\n    return $-[0] + ($s\
    \ =~ tr/aeiouAEIOU/AEIOU/);\n}", "    my $n = length $s;\n    my $count = 0;\n\
    \    for my $i (0.. $n - 1) {\n        if ($s =~ m/^.[$i]/) {\n            $count\
    \ += ($i & 1) ? 1 : 0;\n        }\n    }\n    return $count;\n}", "    return\
    \ 0 unless $s;\n    $s =~ s/(..)(..)(..)$/\\1\\U\\2\\U\\3/segs;\n    return length($s);\n\
    }", "    my $n = 0;\n    for ($s =~ m/([AEIOU])/g) {\n        if ($1 eq \"E\"\
    ) {\n            $n += 1;\n        } elsif ($1 eq \"I\") {\n            $n -=\
    \ 1;\n        } elsif ($1 eq \"O\") {\n            $n += 1;\n        }\n    }\n\
    \    return $n;\n}", '    my ($i,$c);', "    $s =~ s/([aeiou])/ $1 /ge;\n    $s\
    \ =~ s/^/0 /;\n    $s =~ s/$/0 /;\n    return $1;\n}", "    $s =~ s/^.+/()/g;\
    \  # remove any leading characters\n    my $vowels = $s =~ /[aeiouyAEIOUY]/;\n\
    \    return $vowels ? $s : 0;\n}", "    my($n, $vowels, $i);\n    $n = 0;\n  \
    \  for ($i = 0; $i < $#_; $i++) {\n        if ($_[$i] =~ m/[AEIOUaeiou]/) {\n\
    \            $vowels = $vowels + 1;\n        }\n    }\n    return $vowels % 2\
    \ == 1 ? $vowels : $vowels + 1;\n}", "    my @chars = split //, $s;\n    my $counter\
    \ = 0;\n    for (@chars) {\n        $counter += 1 if ($_ eq 'a' or $_ eq 'A' or\
    \ $_ eq 'e' or $_ eq 'E' or $_ eq 'i' or $_ eq 'I' or $_ eq 'o' or $_ eq 'O' or\
    \ $_ eq 'u' or $_ eq 'U');\n    }\n    return $counter;\n}", "    my ($i,$count);\n\
    \    $i = 0;\n    foreach $char (split(//,$s)) {\n        next if $char eq \"\\\
    n\" || $char eq \"\\t\" || $char eq \"\\v\" || $char eq \"\\f\";\n        if ($char\
    \ eq \"A\" || $char eq \"E\" || $char eq \"I\" || $char eq \"O\" || $char eq \"\
    U\") {\n            $count++;\n        } else {\n            $count = 0;\n   \
    \     }\n        $i = $i + 1;\n        if ($i == 2) {\n            last;\n   \
    \     }\n    }\n    return $count;\n}", "    $s =~ tr/[a-z]/[A-Z]/;\n    my $len\
    \ = length($s);\n    my $even_count = 0;\n    my $odd;\n    for (my $i = 0; $i\
    \ < $len; $i += 2) {\n\t$odd += 1 if substr($s, $i, 1) eq 'O';\n\t$even_count\
    \ += 1 if substr($s, $i, 1) eq 'E';\n    }\n    return $even_count ? $even_count\
    \ : $len;\n}", "    $s =~ tr/A-Z/a-z/;\n    $s =~ s/[a-z]*([aeiou])/$1/g;\n  \
    \  return length($s);\n}", "    $s =~ tr/AEIOUaeiou/AEIOUaeiou/;\n    return $-[0];\n\
    }", "    my $vowels = \"aeiou\";\n    my $i = 0;\n    my $even_index = 0;\n  \
    \  my $upper = 0;\n    my $count_vowels = 0;", "    my $i = 0;\n    while (length($s))\
    \ {\n        my $char = substr($s, $i, 1);\n        if ($char eq \"A\" || $char\
    \ eq \"E\" || $char eq \"I\" || $char eq \"O\" || $char eq \"U\") {\n        \
    \    $i += 1;\n        }\n        $i += 1;\n    }\n    return $i;\n}", "    $s\
    \ =~ tr/aeiouAEIOU/AEIOU/;\n    return $-[0] - 1;\n}", "    my $count = 0;\n \
    \   for (my $i = 0; $i <= $#s; $i++) {\n        if (substr($s, $i, 1) =~ /[AEIOU]/)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    $s\
    \ =~ tr/[a-z]/[A-Z]/;\n    return $s =~ tr/[A-Z]/[aeiou]/;\n}", "    $s =~ tr/aeiouAEIOU//;\n\
    \    $s =~ tr/eE//;\n    return length($s);\n}", "    return 0 unless length($s);\n\
    \    my(@cs) = split //, $s;\n    my(@counts);\n    my($cnt);\n    foreach $c\
    \ (@cs) {\n        if ($c =~ /^[A-Z]/) {\n            $cnt++;\n            push\
    \ (@counts, $cnt);\n        }\n    }\n    return ($counts[2] if @counts[2]);\n\
    }", "    my $count = 0;\n    $s =~ s/^((\\w*)(\\w*))(\\1)(\\w*)$/ if ($^O =~ /mswin32/);\n\
    \    for (my $i = 0; $i <= length($s); $i++) {\n        my $v = substr($s, $i,\
    \ 1);\n        $v =~ /[AEIOU]/i ? $count++ : $count++;\n    }\n    return $count;\n\
    }", "    return $s =~ s/[AEIOUaeiou]//g;\n}", "    my $count = 0;\n    for my\
    \ $i (0 .. length($s)-2) {\n        if (substr($s, $i, 1) eq \"A\" || substr($s,\
    \ $i, 1) eq \"a\") {\n            $count += 0;\n        } elsif (substr($s, $i,\
    \ 1) eq \"B\" || substr($s, $i, 1) eq \"b\") {\n            $count += 1;\n   \
    \     } elsif (substr($s, $i, 1) eq \"C\" || substr($s, $i, 1) eq \"c\") {\n \
    \           $count += 2;\n        } elsif (substr($s, $i, 1) eq \"D\" || substr($s,\
    \ $i, 1) eq \"d\") {\n            $count += 3;\n        } elsif (substr($s, $i,\
    \ 1) eq \"E\" || substr($s, $i, 1) eq \"e\") {\n            $count += 4;\n   \
    \     } elsif (substr($s, $i, 1) eq \"F\" || substr($s, $i, 1) eq \"f\") {\n \
    \           $count += 5;\n        } elsif (substr($s, $i, 1) eq \"G\" || substr($s,\
    \ $i, 1) eq \"g\") {\n            $count += 6;\n        } elsif (substr($s, $i,\
    \ 1) eq \"H\" || substr($s, $i, 1) eq \"h\") {\n            $count += 7;\n   \
    \     } elsif (substr($s, $i, 1) eq \"I\" || substr($s, $i, 1) eq \"i\") {\n \
    \           $count += 8;\n        } elsif (substr($s, $i, 1) eq \"J\" || substr($s,\
    \ $i, 1) eq \"j\") {\n            $count += 9;\n        } elsif (substr($s, $i,\
    \ 1) eq \"K\" || substr($s, $i, 1) eq \"k\") {\n            $count += 10;\n  \
    \      } elsif (substr($s, $i, 1) eq \"L\" || substr($s, $i, 1) eq \"l\") {\n\
    \            $count += 11;\n        } elsif (substr($s, $i, 1) eq \"M\" || substr($s,\
    \ $i, 1) eq \"m\") {\n            $count += 12;\n        } elsif (substr($s, $i,\
    \ 1) eq \"N\" || substr($s, $i, 1) eq \"n\") {\n            $count += 13;\n  \
    \      } elsif (substr($s, $i, 1) eq \"O\" || substr($s, $i, 1) eq \"o\") {\n\
    \            $count += 14;\n        } elsif (substr($s, $i, 1) eq \"P\" || substr($s,\
    \ $i, 1) eq \"p\") {\n            $count += 15;\n        } elsif (", '    my $count  =
    0;', "    my $n = 0;\n    for (length($s)) { \n        if ($s =~ /[AEIOUaeiou]/)\
    \ { $n++; }\n    }\n    return $n;\n}", "    $s =~ s/(^|[^A-Z]+)(?=[A-Z])/$1$2/g;\n\
    \    $s =~ s/[A-Z]+([^A-Z])/$1 $2/g;\n    $s =~ s/ (?=[A-Z])/$1/g;\n    return\
    \ $s =~ s/^ (\\S+) $/ $1/g;\n}", "    my($ret) = 0;\n    while($s =~ /([A-Z]{2})/)\n\
    \    {\n        ($ret+=1)  if ($1 =~ /([A-Z])/);\n        $s =~ tr/[A-Z]/Ur/;\n\
    \    }\n    return $ret;\n}", "    $s =~ tr/A-Z/a/;\n    $s =~ tr/a-z/0/;\n  \
    \  $s =~ tr/0-9/0/;\n    $s =~ tr/[^a-v]/0/;\n    return $#_ > 0 ? $#_ : 0;\n}",
  '    my $upper = 0;', "    my $count = 0;\n    for my $i (0..$#s) {\n        if\
    \ ($s[$i] =~ /^[AEIOU]$/) {\n            $count += 1;\n        }\n    }\n    return\
    \ $count;\n}", "    $s =~ tr/aeiouAEIOU/AEIOU/;\n    $s =~ tr/U/E/;\n    $s =~\
    \ tr/e/e/;\n    return length($s);\n}", "    my $count = uc($s) =~ tr/A-Z/../;\n\
    \    if ($s[/[aeiou]/] && $s[/[^aeiou]/] && $count != $#s) {\n        $count++;\n\
    \    }\n    return $count;\n}\n</code>\nThe regular expression tr/A-Z/../; in\
    \ scalar context produces the number of uppercase characters found in a string\
    \ (as a subexpression).\n<|/ a dscore=4 |>\n<| c |>\n+1 for \"aBCdEf\" being 1,\
    \ not 0. Had to change the \"if $count != $#s\"\n<|/ c |>\n<| c |>\nYou might\
    \ also want to fix the bug where `$count < 1` since this would give the wrong\
    \ answer for \"A\".\n<|/ c |>\n<| c |>\n+1 for aBCdEf being 1, not 0. Had to change\
    \ the \"if $count != $#s\"\n<|/ c |>\n<| c |>\nYou might also want to fix the\
    \ bug where `$count < 1` since this would give the wrong answer for \"A\".\n<|/\
    \ c |>\n<| c |>\n+1 Yes. The OP asked \"What is wrong with my script?\" and not\
    \ \"What is the correct solution?\" I agree, that `if ($count < 1)` might be a\
    \ bug but as far as I can tell the original code would have been correct since\
    \ it counted the number of characters including non-vowels *except* the last one.\
    \ So I guess they wanted to exclude the last character too.\n<|/ c |>\n<| a tags=perl,perl-data-structures,regex,substring\
    \ |>\nI wrote my answer before I realized that my regex could count the final\
    \ character as uppercase. That's what the $s[/[aeiou]/] condition does. I added\
    \ a test to ignore it if it was the last character:\n<code>", "    $s =~ s/^[a-z]/../;\n\
    \    $s =~ s/([aeiou])([aeiou])/\\1\\3/g;\n    $s =~ s/([aeiou])([AEIOU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([eiou])/$1$2/g;\n    $s =~ s/([aeiou])([AeIOU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([EeIOU])/$1$2/g;\n    $s =~ s/([aeiou])([aeOU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([EeOU])/$1$2/g;\n    $s =~ s/([aeiou])([AeOU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([eEoU])/$1$2/g;\n    $s =~ s/([aeiou])([AeEoU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([EeEoU])/$1$2/g;\n    $s =~ s/([aeiou])([AeEoU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([eEoU])/$1$2/g;\n    $s =~ s/([aeiou])([AeEoU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([eEoU])/$1$2/g;\n    $s =~ s/([aeiou])([AeEoU])/$1$2/g;\n\
    \    $s =~ s/([aeiou])([eEoU])/$1$2/g;\n    $s =~ s/([AEIOU])([aeiou])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([AeIOU])/$1$2/g;\n    $s =~ s/([AEIOU])([EeIOU])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([aeOU])/$1$2/g;\n    $s =~ s/([AEIOU])([EeOU])/$1$2/g;\n\
    \    $s =~ s/([AEIOU])([AeOU])/$1$2/g;\n    $s =~ s/([AEIOU])([eEoU])/$1$", " \
    \   my $vowels = \"AEIOUaeiou\";\n    $vowels =~ tr/aeiouAEIOU/AEIOU/;", "   \
    \ my($i, $u, $c);\n    for($i=0;$i<length($s);$i++) {\n\t$c = substr($s,$i,1);\n\
    \t$u =\n\t    (   substr($s,$i,0,1) eq \"A\" ||\n\t\tsubstr($s,$i,0,1) eq \"a\"\
    \ ||\n\t\tsubstr($s,$i,0,1) eq \"C\" ||\n\t\tsubstr($s,$i,0,1) eq \"c\" ||\n\t\
    \tsubstr($s,$i,0,1) eq \"D\" ||\n\t\tsubstr($s,$i,0,1) eq \"d\" ||\n\t\tsubstr($s,$i,0,1)\
    \ eq \"E\" ||\n\t\tsubstr($s,$i,0,1) eq \"e\" ||\n\t\tsubstr($s,$i,0,1) eq \"\
    F\" ||\n\t\tsubstr($s,$i,0,1) eq \"f\" ||\n\t\tsubstr($s,$i,0,1) eq \"G\" ||\n\
    \t\tsubstr($s,$i,0,1) eq \"g\" ||\n\t\tsubstr($s,$i,0,1) eq \"H\" ||\n\t\tsubstr($s,$i,0,1)\
    \ eq \"h\" ||\n\t\tsubstr($s,$i,0,1) eq \"I\" ||\n\t\tsubstr($s,$i,0,1) eq \"\
    i\" ||\n\t\tsubstr($s,$i,0,1) eq \"J\" ||\n\t\tsubstr($s,$i,0,1) eq \"j\" ||\n\
    \t\tsubstr($s,$i,0,1) eq \"K\" ||\n\t\tsubstr($s,$i,0,1) eq \"k\" ||\n\t\tsubstr($s,$i,0,1)\
    \ eq \"L\" ||\n\t\tsubstr($s,$i,0,1) eq \"l\" ||\n\t\tsubstr($s,$i,0,1) eq \"\
    M\" ||\n\t\tsubstr($s,$i,0,1) eq \"m\" ||\n\t\tsubstr($s,$i,0,1) eq \"N\" ||\n\
    \t\tsubstr($s,$i,0,1) eq \"n\" ||\n\t\tsubstr($s,$i,0,1) eq \"O\" ||\n\t\tsubstr($s,$i,0,1)\
    \ eq \"o\" ||\n\t\tsubstr($s,$i,0,1) eq \"P\" ||\n\t\tsubstr($s,$i,0,1) eq \"\
    p\" ||\n\t\tsubstr($s,$i,0,1) eq \"Q\" ||\n\t\tsubstr($s,$i,0,1) eq \"q\" ||\n\
    \t\tsubstr($s,$i,0,1) eq \"R\" ||\n\t\tsubstr($s,$i,0,1) eq \"r\" ||", "    $s\
    \ =~ tr/[A-Z]/0/;\n    return $+;\n}", "    $s =~ tr/A-Z/a-z/;\n    return 0 unless\
    \ length($s);\n    my $len = $s.length();\n    for (my $i = 0; $i < $len; $i +=\
    \ 2) {\n        $count{$$s}{$_}++ for qw[a e i o u];\n    }\n    return $count{$s}{A};\n\
    }", '    my($count, $i) = (0, 0);', "    $s =~ s/^([A-Z]+)//;\n    $s =~ tr/A-Z/0/;\n\
    \    $s =~ s/(.)(?=\\1)//g;\n    return length($s);\n}", "    my $n = length($s);\n\
    \    my $even = ($n & 1) == 0; # even number\n    my $count = 0;\n    for (my\
    \ $i = 0; $i < $n; ++$i) {\n        my $c = substr($s, $i, 1);\n        if ($c\
    \ == 'A' && !$even) {\n            ++$count;\n        } elsif ($c == 'a' && !$even)\
    \ {\n            $count = 0;\n        } elsif ($c == 'B' && !$even) {\n      \
    \      ++$count;\n        } elsif ($c == 'b' && !$even) {\n            $count\
    \ = 0;\n        } elsif ($c == 'C' && !$even) {\n            ++$count;\n     \
    \   } elsif ($c == 'c' && !$even) {\n            $count = 0;\n        } elsif\
    \ ($c == 'D' && !$even) {\n            ++$count;\n        } elsif ($c == 'd' &&\
    \ !$even) {\n            $count = 0;\n        } elsif ($c == 'E' && !$even) {\n\
    \            ++$count;\n        } elsif ($c == 'e' && !$even) {\n            $count\
    \ = 0;\n        } elsif ($c == 'F' && !$even) {\n            ++$count;\n     \
    \   } elsif ($c == 'f' && !$even) {\n            $count = 0;\n        } elsif\
    \ ($c == 'G' && !$even) {\n            ++$count;\n        } elsif ($c == 'g' &&\
    \ !$even) {\n            $count = 0;\n        }\n    }\n    return $count;\n}",
  "    $s =~ tr/aeiouAEIOU/AEIOU/;\n    return length($s);\n}", "    my $count = 0;\n\
    \    for (split //, $s) {\n        if ($_ eq 'a') {\n            $count++;\n \
    \       } elsif ($_ eq 'A') {\n            $count++;\n        } elsif ($_ eq 'e')\
    \ {\n            $count++;\n        } elsif ($_ eq 'E') {\n            $count++;\n\
    \        } elsif ($_ eq 'i') {\n            $count++;\n        } elsif ($_ eq\
    \ 'I') {\n            $count++;\n        } elsif ($_ eq 'o') {\n            $count++;\n\
    \        } elsif ($_ eq 'O') {\n            $count++;\n        } elsif ($_ eq\
    \ 'u') {\n            $count++;\n        } elsif ($_ eq 'U') {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my $count = 0;\n    my $prev =\
    \ 0;\n    my $i = 0;\n    while ($i < @$s) {\n        if ($prev == 0) {\n    \
    \        ++$i;\n        }\n        elsif ($$s[$i] =~ m/[AEIOU]/) {\n         \
    \   ++$count;\n        }\n        else {\n            ++$i;\n        }\n     \
    \   $prev = $$s[$i];\n    }\n    return $count;\n}", "    $s =~ tr/[AEIOU]/[AEIOUaeiou]/;\n\
    \    scalar @$s == 0 ? 0 : $s[0];\n}", '    my $vowel = qr/[AEIOU]$/;', "    $s\
    \ =~ tr/A-Z/a-zA-Z/;\n    $s =~ tr/aeiou/AEIOU/;\n    return $s =~ tr/aeiouAEIOU/aeiou/;\n\
    }", "    $s =~ tr/[A-Z]//;\n    $s =~ tr/[aeiouAEIOU]//;\n    $s =~ tr/[0-9]//;\n\
    \    return scalar @{$_[0]};\n}", '    my($c);', "    my $count = 0;\n    $s =~\
    \ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s =~ /A/;\n    $s =~ /([a-zA-Z])/;\n\
    \    $count += length($1) if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n\
    \    return $count if $s =~ /B/;\n    $s =~ /([a-zA-Z])/;\n    $count += length($1)\
    \ if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s\
    \ =~ /C/;\n    $s =~ /([a-zA-Z])/;\n    $count += length($1) if length($1) > 0;\n\
    \    $s =~ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s =~ /D/;\n    $s =~\
    \ /([a-zA-Z])/;\n    $count += length($1) if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc\
    \ $1/eg;\n    return $count if $s =~ /E/;\n    $s =~ /([a-zA-Z])/;\n    $count\
    \ += length($1) if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n    return\
    \ $count if $s =~ /F/;\n    $s =~ /([a-zA-Z])/;\n    $count += length($1) if length($1)\
    \ > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s =~ /G/;\n  \
    \  $s =~ /([a-zA-Z])/;\n    $count += length($1) if length($1) > 0;\n    $s =~\
    \ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s =~ /H/;\n    $s =~ /([a-zA-Z])/;\n\
    \    $count += length($1) if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n\
    \    return $count if $s =~ /I/;\n    $s =~ /([a-zA-Z])/;\n    $count += length($1)\
    \ if length($1) > 0;\n    $s =~ s/([a-zA-Z])/uc $1/eg;\n    return $count if $s\
    \ =~ /J/;\n    $s =~ /([a-zA-Z])/;\n    $count += length($1) if length($1) > 0;\n\
    \    $s =~ s/([a-zA-Z])/uc $1/", "    my $i = 0;\n    while ($i < length($s))\
    \ {\n        if ($s[i] eq 'A') { $i++; next }\n        if ($s[i] eq 'a') { $i++;\
    \ next }\n        if ($s[i] eq 'B') { $i++; next }\n        if ($s[i] eq 'b')\
    \ { $i++; next }\n        if ($s[i] eq 'C') { $i++; next }\n        if ($s[i]\
    \ eq 'c') { $i++; next }\n        if ($s[i] eq 'D') { $i++; next }\n        if\
    \ ($s[i] eq 'd') { $i++; next }\n        if ($s[i] eq 'E') { $i++; next }\n  \
    \      if ($s[i] eq 'e') { $i++; next }\n        if ($s[i] eq 'F') { $i++; next\
    \ }\n        if ($s[i] eq 'f') { $i++; next }\n        if ($s[i] eq 'G') { $i++;\
    \ next }\n        if ($s[i] eq 'g') { $i++; next }\n        die \"Unknown letter\
    \ $s[i] in string '$s'\" unless $s[i] eq 'A' \n            || $s[i] eq 'a' ||\
    \ $s[i] eq 'B' || $s[i] eq 'b' || $s[i] eq 'C'\n            || $s[i] eq 'c' ||\
    \ $s[i] eq 'D' || $s[i] eq 'd' || $s[i] eq 'E'\n            || $s[i] eq 'e' ||\
    \ $s[i] eq 'F' || $s[i] eq 'f' || $s[i] eq 'G'\n            || $s[i] eq 'g';\n\
    \    }\n    return $i;\n}", "    $s =~ s/([a-z])/uc($1)/g;\n    my $count;\n \
    \   my $i = 1;\n    for (;$i <= length($s);$i++) {\n        if (substr($s,$i,1)\
    \ =~ /[A-Z]/) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    local $^W;\n    return $s =~ tr/[AEIOUY]//;\n}", "    $s =~ s/[^A-Z]//;\n\
    \    $s =~ tr/aeiouAEIOU/AEIOU/;\n    $s =~ tr/aeiouAEIOU/AEIOU/;\n    my $n =\
    \ @$s;\n    $n -= $s =~ tr/AEIOUaeiou/aeiou/;\n    my $even = 0;\n    for (my\
    \ $i = 0; $i < @$s; $i += 2) {\n        $even += $s[$i] eq 'A' || $s[$i] eq 'a';\n\
    \    }\n    $even *= 2;\n    $n;\n}", "    $s =~ tr/aeiouAEIOU/AEIOUaeiou/;\n\
    \    return $-[0] % 2;\n}", "    my($cnt);\n    for (my $i = 0; $i < length($s);\
    \ $i++) {\n        if ($s[i] eq \"A\" || $s[i] eq \"a\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"B\" || $s[i] eq \"b\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"C\" || $s[i] eq \"c\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"D\" || $s[i] eq \"d\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"E\" || $s[i] eq \"e\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"F\" || $s[i] eq \"f\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"G\" || $s[i] eq \"g\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"H\" || $s[i] eq \"h\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"I\" || $s[i] eq \"i\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"J\" || $s[i] eq \"j\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"K\" || $s[i] eq \"k\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"L\" || $s[i] eq \"l\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"M\" || $s[i] eq \"m\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"N\" || $s[i] eq \"n\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"O\" || $s[i] eq \"o\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"P\" || $s[i] eq \"p\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"Q\" || $s[i] eq \"q\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"R\" || $s[i] eq \"r\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"S\" || $s[i] eq \"s\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"T\" || $s[i] eq \"t\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"U\" || $s[i] eq \"u\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"V\" || $s[i] eq \"v\") {\n            $cnt +=\
    \ 1;\n        } elsif ($s[i] eq \"W\" || $s[i] ", "    $s =~ tr/A-Z/0/;\n    return\
    \ length($s) - length($s =~ /0/) - length($s =~ /[^0]/);\n}", "    return 0 unless\
    \ $s =~ /[a-z]/i;\n    my $count = 0;\n    while ($s =~ /([a-z])/g) {\n      \
    \  my $char = $1;\n        $char eq \"a\" ? $count += 2 : last unless $char eq\
    \ \"d\";\n    }\n    return $count;\n}", "    $s =~ tr/AEIOUaeiou/aeiou/;\n  \
    \  return $-[0] + $s =~ tr/aeiouAEIOU/aeiou/;\n}", "    my $n = length($s);\n\
    \    if ($n eq 0) {\n        return 0;\n    }", '    my($n,$upper,$upper_c);',
  "    local $-[0] =~ s/(.)\\1+/$1/g;\n    $-[0] =~ s/(.)\\1+/$1/g;\n    return length($-[0]);\n\
    }", "    my $count;\n    for (my $i = 0; $i < (length($s) - 2); $i++) {\n    \
    \    if ($s[i] eq $s[$i + 1] and $s[i] eq $s[$i + 2]) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    $s =~ tr/[A-Z]//;\n    $s =~ tr/[a-z]//;\n\
    \    $s =~ tr/[\\d]//;\n    return $s =~ tr/[aeiouAEIOU]//;\n}", '    my (@count)
    = (0, 0);', "    my $count = 0;\n    for(my $i=0; $i<$#s; $i++) {\n        my\
    \ $c = substr($s, $i, 1);\n        if($c eq 'a' || $c eq 'e' || $c eq 'i' || $c\
    \ eq 'o' || $c eq 'u'){\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my @chars = split //, $s;\n    for my $i (0 .. $#chars)\
    \ {\n        next unless $chars[$i] eq 'A' .. 'Z';\n        $count += 1 if $chars[$i]\
    \ eq 'a' .. 'z';\n        $count += 1 if $chars[$i] eq 'A' .. 'Z' && !($i & 1);\n\
    \    }\n    return $count;\n}", '    return 0 if $s =~ /^$/;', "    my $len =\
    \ length($s);\n    my $vowels = 0;\n    for (my $i = 0; $i < $len; $i++) {\n \
    \       my $letter = substr($s, $i, 1);\n        if ($letter eq \"a\") {\n   \
    \         $vowels += 1;\n        } elsif ($letter eq \"e\") {\n            $vowels\
    \ += 1;\n        } elsif ($letter eq \"i\") {\n            $vowels += 1;\n   \
    \     } elsif ($letter eq \"o\") {\n            $vowels += 1;\n        } elsif\
    \ ($letter eq \"u\") {\n            $vowels += 1;\n        }\n    }\n    return\
    \ $vowels;\n}", "    return 0 if $s eq '';\n    my($c) = 0;\n    my $i = 0;\n\
    \    my $char;\n    while ($i < length($s)) {\n        $char = $s[$i];\n     \
    \   if ($char eq 'A' .. 'Z') {\n            $c++;\n        }\n        $i++;\n\
    \    }\n    return $c;\n}", '    my($upper) = 0;', "    return $s =~ m/([aeiou]{2})/g;\n\
    }", "    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/eE/A-Z/;\n    ()\n}", "    my($vowel,\
    \ $consonant);\n    $s = uc $s;", "    $s =~ tr/[AEIOUaeiou]//cd;\n    return\
    \ $s =~ tr/[Bb]//c+;\n}", "    my $n_uppers = 0;\n    for my $i (0 .. length($s)\
    \ - 1) {\n        if ($s[i] eq 'A' .. $s[i] eq 'a') {\n            $n_uppers +=\
    \ 1;\n        } elsif ($s[i] eq 'B' .. $s[i] eq 'b') {\n            $n_uppers\
    \ += 1;\n        } elsif ($s[i] eq 'C' .. $s[i] eq 'c') {\n            $n_uppers\
    \ += 1;\n        } elsif ($s[i] eq 'D' .. $s[i] eq 'd') {\n            $n_uppers\
    \ += 1;\n        } elsif ($s[i] eq 'E' .. $s[i] eq 'e') {\n            $n_uppers\
    \ += 1;\n        } elsif ($s[i] eq 'F' .. $s[i] eq 'f') {\n            $n_uppers\
    \ += 1;\n        }\n    }\n    return $n_uppers;\n}", "    return 0 unless defined\
    \ $s;\n    my(@vowels);\n    for my $i (0 .. length($s) - 1) {\n        push(@vowels,\
    \ $s[$i] =~ /^[AEIOUaeiou]/);\n    }\n    return scalar(grep($s[$_] =~ /^[AEIOUaeiou]/,\
    \ 0 .. length($s) - 1, @vowels));\n}", "    my($c2) = 0;\n    for (my $i = 0;\
    \ $i < length($s); $i++) {\n        my $char = substr($s, $i, 1);\n        if\
    \ ($char =~ /[AEIOU]/) {\n            $c2 += 1;\n        }\n    }\n    return\
    \ $c2;\n}", "    $s =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    $s =~ tr/u/u/;\n    $s\
    \ =~ tr/e/E/;\n    $s =~ tr/a/A/;\n    return $+ * 4;\n}", "    $s =~ tr/a-z/A-Z/;\n\
    \    $s =~ tr/A-Z/a-z/;\n    my $count = 0;\n    my @indices = map { $_ % 2 ?\
    \ $_ : \"$#\" } 0 .. length($s) - 1;\n    foreach my $index (@indices) {\n   \
    \     $count += 1 if $index =~ /a|e/;\n        $count += 1 if $index =~ /b|i/;\n\
    \        $count += 1 if $index =~ /c|o/;\n        $count += 1 if $index =~ /d|u/;\n\
    \    }\n    return $count;\n}", "    my($count) = 0;\n    my($index) = @_ % 2;\n\
    \    my(@vowel) = qw(a e i o u);\n    for (my $index = 0; $index<length($s); $index\
    \ += 2) {\n        next if ($s[$index] in @vowel);\n        $count++ if ($s[$index]==uc($s[$index+1]));\n\
    \    }\n    return $count;\n}", "    $s = uc($s);\n    $s = lc($s);\n    $s =\
    \ uc($s) if ($s eq \"\");\n    my $count = 0;\n    for (my $i = 0; $i < length($s);\
    \ $i++) {\n        if ($s[i] =~ /[AEIOU]/) {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}", "    my $count = 0; # count the number of vowels\
    \ in even indices\n    foreach my $i (0 .. $#_) {\n        next unless $i%2==0;\n\
    \        my($c) = substr($s, $i, 1);\n        next if $c !~ /[AEIOU]/;\n     \
    \   $count++;\n    }\n    return $count;\n}", "    $s =~ tr/A-Z/a-z/;\n    $s\
    \ =~ tr/A-Z/a-z/;\n    my $count = $s =~ tr/A-Z//;\n    return $count;\n}", " \
    \   my $count = 0;\n    for my $i (0 .. length($s) - 1) {\n        next unless\
    \ $s[i] eq \"A\";\n        $count++;\n        next if $s[i] eq \"a\" && !$s[$i\
    \ + 1] eq \"B\";\n        $count++;\n        next if $s[i] eq \"B\" && !$s[$i\
    \ + 1] eq \"a\";\n        $count++;\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    for (my $i = 0; $i < length($s); $i += 2) {\n        last unless $s[$i]\
    \ eq $s[$i + 1];\n        $count++;\n    }\n    $count;\n}", "    $s =~ tr/A-Z/A-Z/;\n\
    \    $s =~ tr/a-z/A-Z/;\n    return ($s =~ /[A-Z]/g) ? 1 : 0;\n}", "    $s =~\
    \ s/([^A-Z]*)([AEIOUaeiou])([^A-Z]*)/ $1 . $2$3 /i;\n    return $s =~ s/([aeiou])([A-Z])/$1\
    \ $2/g;\n}", "    local $^W;\n    return 0 unless $s;\n    return $s =~ tr/A-Z/\\\
    n/;\n}", "    my $count = 0;\n    for(my $i = 0; $i <= length($s) - 1; $i++) {\n\
    \        if ($s[i] eq \"A\") {\n            $count++;\n        } elsif ($s[i]\
    \ eq \"E\") {\n            $count++;\n        } elsif ($s[i] eq \"I\") {\n   \
    \         $count++;\n        } elsif ($s[i] eq \"O\") {\n            $count++;\n\
    \        } elsif ($s[i] eq \"U\") {\n            $count++;\n        } else {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}\n</code>\nThe\
    \ code you posted doesn't work correctly because of this. The problem was that\
    \ when you used the regex ([A-Z]*), the pattern was matching nothing because no\
    \ letters were present in the input string. Even though there was at least one\
    \ character that matched [A-Z]. The reason you were getting a result of 0 is because\
    \ there were no occurrences of those letters. I changed the pattern to ([A-Z]*)\
    \ to match letters instead. Now the function should work correctly. Below is the\
    \ fixed version of the function in full.\n<code>\nuse strict;\nuse warnings;\n\
    use 5.010;", "    my $count = 0;\n    my $even_index = 0;\n    my $prev = 0;\n\
    \    my $length = length($s);\n    my $s_len = length($s);\n    for(my $i = 0;\
    \ $i < $s_len; ++$i) {\n        if($s[$i] eq 'A') {\n            $count++;\n \
    \       }\n        elsif($s[$i] eq 'a') {\n            $count++;\n           \
    \ $even_index++;\n        }\n        elsif($s[$i] eq 'B') {\n            if($even_index)\
    \ {\n                $count++;\n            }\n            elsif($prev) {\n  \
    \              $count++;\n            }\n        }\n        elsif($s[$i] eq 'b')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \            elsif($prev) {\n                $count++;\n            }\n      \
    \  }\n        elsif($s[$i] eq 'C') {\n            if($even_index) {\n        \
    \        $count++;\n            }\n        }\n        elsif($s[$i] eq 'c') {\n\
    \            if($even_index) {\n                $count++;\n            }\n   \
    \     }\n        elsif($s[$i] eq 'D') {\n            if($even_index) {\n     \
    \           $count++;\n            }\n        }\n        elsif($s[$i] eq 'd')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \        }\n        elsif($s[$i] eq 'E') {\n            if($even_index) {\n  \
    \              $count++;\n            }\n        }\n        elsif($s[$i] eq 'e')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \        }\n        elsif($s[$i] eq 'F') {\n            if($even_index) {\n  \
    \              $count++;\n            }\n        }\n        elsif($s[$i] eq 'f')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \        }\n        elsif($s[$i] eq 'G') {\n            if($even_index) {\n  \
    \              $count++;\n            }\n        }\n        elsif($s[$i] eq 'g')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \        }\n        elsif($s[$i] eq 'H') {\n            if($even_index) {\n  \
    \              $count++;\n            }\n        }\n        elsif($s[$i] eq 'h')\
    \ {\n            if($even_index) {\n                $count++;\n            }\n\
    \        }\n        elsif($s[$i] eq 'I') {\n            if($even_index) {\n  \
    \              $count++;\n", "    my $count;\n    for (my $i = 0; $i < @$s; $i\
    \ += 2) {\n        $count += $s->[$i] =~ /[AEIOUaeiou]/;\n    }\n    return $count;\n\
    }", "    # Count each vowel twice for even-length strings. If the string contains\n\
    \    # only one vowel, return 0.\n    # Otherwise, return 1.\n    return 0 if\
    \ $s =~ /[^aeiouAEIOU]/;\n    $s =~ tr/AEIOU/AEYUA/;\n    $s =~ tr/eEYUA/AEIOU/;\n\
    \    return $s =~ tr/u/AE/;\n}\n</code>\nThe regex works like this:", "    my\
    \ $i = 0;\n    my $count_upper = 0;\n    while ($i < length($s)) {\n        if\
    \ ($s[$i] =~ /[AEIOU]/) {\n            $count_upper += 1;\n        }\n       \
    \ $i++;\n    }\n    return $count_upper;\n}", "    $s =~ tr/A-Z/A-Z/;\n    $s\
    \ =~ tr/aeiouy//i;\n    $s =~ tr/o//i;\n    return $s =~ tr/[^aeiouy]/0/;\n}",
  "    my $n = 0;\n    for my $i (0..$#_) {\n        $n++ if $s[$i] eq \"A\" .. \"\
    Z\";\n    }\n    $n;\n}", "    my $n = 0;\n    my $i = 0;", "    my $len = $#{\
    \ $s };\n    for my $i (1 .. $len) {\n        my $c = ${ $s }[$i];\n        if\
    \ ($c eq 'A' || $c eq 'E') {\n            $c eq 'A' ? ( $i += 1 ) : ();\n    \
    \    }\n    }\n    return $len;\n}", "    my($i, $num_upper);\n    $num_upper\
    \ = 0;", "    my $n = scalar $s;\n    my $count = 0;\n    for(my $i = 0; $i <\
    \ $n; $i++) {\n        if($s[$i] eq 'A' .. $s[$i] eq 'Z') {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    $s =~ tr/aeiou/AEIOU/;\n    my\
    \ $n = 0;\n    for (my $i = 0; $i < length($s); $i++) {\n        if (substr($s,\
    \ $i, 1) =~ m/A/) {\n            $n++;\n        }\n    }\n    return $n;\n}",
  '    my $count = 0;', "    my $count = scalar grep { substr($s,$_,1) eq \"A\" ||\
    \ substr($s,$_,1) eq \"E\" || substr($s,$_,1) eq \"I\" || substr($s,$_,1) eq \"\
    O\" || substr($s,$_,1) eq \"U\" } @{[ map { @$_ % 2 } 0 .. length($s) - 1 ]};\n\
    \    $count;\n}", "    my $c = 0;\n    for my $i (0 .. length($s) - 1) {\n   \
    \     my $c = $s eq substr($s, $i, 1) ? 1 : $c % 2;\n        $c = 2 * $c if $i\
    \ & 1;\n    }\n    return $c;\n}", "    my $c = 0;\n    foreach (@{$s}){\n   \
    \     return $c if ($_ >= 'a' && $_ <= 'z' && $_ ne 'A' && $_ ne 'a');\n     \
    \   $c += 1;\n    }\n    return $c;\n}", "    $s =~ tr/A-Z/a/;\n    length($s);\n\
    }", "    $s =~ tr/aeiouAEIOU/uvw/i;\n    return $s =~ tr/U/0/i;\n}", "    $s =~\
    \ tr/[A-Z]/A/g;\n    $s =~ tr/[a-z]/a/g;\n    my $n = 0;\n    for (my $i = 0;\
    \ $i < length($s); $i++) {\n        last if ($s[i] eq \"A\" && ($s[$i] eq \"a\"\
    \ || $s[$i] eq \"A\") || ($s[$i] eq \"a\" && $s[$i-1] eq \"A\"));\n        $n\
    \ += ($s[i] eq \"A\") ? 1 : 0;\n    }\n    return $n;\n}", "    $s =~ tr/aeiouAEIOU//cd;\n\
    \    return $s =~ tr/BCDFGHKLMNPRSTVWXZ//cd;\n}", "    my $n_upper = 0;\n    for\
    \ my $i (0..$#s) {\n        my $c = substr($s, $i, 1);\n        $n_upper += $c\
    \ eq \"A\" || $c eq \"E\" || $c eq \"I\" || $c eq \"O\" || $c eq \"U\";\n    }\n\
    \    return $n_upper;\n}", "    my(@cb_chars) = ('a', 'A', 'e', 'E', 'i', 'I',\
    \ 'o', 'O', 'u', 'U');\n    return 1 if $s =~ /[^A-Z]/ && grep {$_ !~ /^[AEIOU]/}\
    \ @cb_chars;\n    return 0;\n}", "    $s =~ tr/A-Z/A-Z/;\n    return length($s);\n\
    }", "    $s =~ tr/A-Z//;\n    my $result = $s =~ tr/aeiouAEIOU//;\n    return\
    \ $result;\n}", "    my(@counts);\n    for(my $i=0; $i<@s; $i++) {\n        push(@counts,\
    \ $s[$i] =~ /^[AEIOU]/) ? 1 : 0;\n    }\n    return scalar(@counts);\n}", "  \
    \  my $count = 1;\n    my $index = 0;", "    $s =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n\
    \    return length($s) - length($s =~ /AEIOUaeiouAEIOU/);\n}", "    my %vowels\
    \ = (\n        'A' => 1,\n        'E' => 1,\n        'I' => 1,\n        'O' =>\
    \ 1,\n        'U' => 1,\n    );\n    $s =~ tr/AEIOUaeiou/AEIOUaeiou/;\n    return\
    \ scalar keys %vowels;\n}", "    my $num = 0;\n    for (my $i=0; $i<=$#s; $i++)\
    \ {\n        if ( $s[i] eq 'a' || $s[i] eq 'A' || $s[i] eq 'e' || $s[i] eq 'E'\
    \ ||\n            $s[i] eq 'i' || $s[i] eq 'I' || $s[i] eq 'o' || $s[i] eq 'O'\
    \ ||\n            $s[i] eq 'u' || $s[i] eq 'U' || $s[i] eq 'y' || $s[i] eq 'Y'\
    \ ) {\n            $num++;\n        }\n    }\n    return $num;\n}", "    $s =~\
    \ s/(.)\\1{2,}/$1 /s;\n    return $s =~ tr/AEIOUaeiou/aeiou/;\n}", "    my $count\
    \ = 0;\n    my $i = 0;\n    my $j = 1;\n    for ($i = 0; $i <= length($s); $i++)\
    \ {\n        if (($s[i] eq 'A') || ($s[i] eq 'a') || ($s[i] eq 'B') || ($s[i]\
    \ eq 'b') || ($s[i] eq 'C') ||\n           ($s[i] eq 'c') || ($s[i] eq 'D') ||\
    \ ($s[i] eq 'd') || ($s[i] eq 'E') || ($s[i] eq 'e') ||\n           ($s[i] eq\
    \ 'F') || ($s[i] eq 'f') || ($s[i] eq 'G') || ($s[i] eq 'g'))\n        {\n   \
    \         $count += $j;\n            $j += 2;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my $i = 0;\n    while ($i < length($s)) {\n     \
    \   if (substr($s, $i, 1) eq \"A\" ||\n            substr($s, $i, 1) eq \"a\"\
    ) {\n            ++$count;\n        }\n        ++$i;\n    }\n    return $count;\n\
    }", '    my(@count, $num_upper);', "    $s =~ s/^$|$//g;\n    $s =~ s/([aeiou])/$1/g;\n\
    \    $s =~ s/\\B/U/g;\n    length($s);\n}", "    return $s =~ s/^.(?=.*[A-Z])//;\n\
    }", "    my($c) = 0;\n    map {\n        if ($_ % 2 == 0) {\n            $c++\
    \ if m/[A-Z]/;\n        }\n    } split //, $s;\n    return $c;\n}", "    return\
    \ $s =~ tr/A-Z/0/;\n}", "    $s =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    $s =~ s/^(.)\\\
    K/uc $1/;\n    $s =~ s/^$//;\n    return length($s);\n}", "    $s =~ s/^\\s+//;\
    \ # Ignore leading whitespace\n    $s =~ s/\\s+$//; # Ignore trailing whitespace\n\
    \    my $cntr = 0;\n    my $i = 0;\n    for (my $c = $s =~ /./; $i < length($s);\
    \ $c = $s =~ /./) {\n        if ($c =~ /[AEIOU]/) {\n            $cntr++;\n  \
    \      }\n        $i++;\n    }\n    return $cntr;\n}", "    $s =~ s/[AEIOU]//g;\n\
    \    $s =~ s/(.)/ my $c = length $1 ? uc($1) : '.'; $c/g;\n    $s =~ s/^(.)/my\
    \ $c = length $1 ? uc($1) : '.'; $c/g;\n    return $s;\n}", "    my $c = 0;\n\
    \    for ($s =~ /../) {\n        $c += $_ =~ /[AEIOU]/;\n    }\n    return $c;\n\
    }", '    $s =~ tr/a-z/A-Z/;', "    $s =~ s/(.)\\1*/ $1/;\n    my $num_uppers =\
    \ $s =~ tr/AEIOUaeiou/AEIOUaeiou/;\n    return $num_uppers;\n}", "    my $vowels\
    \ = \"aeiouy\";\n    my $cnt = 1;\n    \n    for my $i (0 .. length($s)-1) {\n\
    \        my $ch = $s[$i];\n        $cnt += $vowels =~ /[AEIOUY]$ch/;\n    }\n\
    \    \n    return $cnt;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
