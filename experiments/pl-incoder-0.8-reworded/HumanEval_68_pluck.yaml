name: HumanEval_68_pluck
language: pl
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n\
  # [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
  # Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n\
  # [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so\
  \ we will choose the first zero, which has the smallest index.\n# Constraints:\n\
  # * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) =\
  \ @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
  \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
  \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
  \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ['    my @ret;', "    my @res;\n    $_[0] = $_[0] < 0 ? $_[0]*-1 + 1\
    \ : $_[0];\n    for ($_[0]; $_[0] >= 1; $_[0]--) {\n        if ($arr[$_[0]] &\
    \ 1) {\n            push @res, [\"$arr[$_[0]]\", $_];\n            $_[0] -= 1;\n\
    \        }\n    }\n    if (@res == 1) {\n        push @res, $res->[1];\n    }\n\
    \    if (@res == 0) {\n        return [];\n    }\n    return sort {$a->[0] <=>\
    \ $b->[0] || $a->[1] <=> $b->[1]} @res;\n}", '    my $idx;', "    my @ret = [];\n\
    \    my $smalest_value;\n    my $smalest_index;\n    my $i;", "    my $n = -1;\n\
    \    my $result = -1;\n    my $min_even_even_val = -1;\n    my $i = 0;\n    for\
    \ my $node (@$arr) {\n        $i++;\n        if ($node % 2 == 0) {\n         \
    \   $min_even_even_val = min(abs($node % 2 - $min_even_even_val), $node);\n  \
    \          if ($node < $min_even_even_val && $node != 0) {\n                $min_even_even_val\
    \ = $node;\n                $result = $i;\n            }\n        }\n    }\n \
    \   return $result if $result != -1;\n    return [];\n}", "    my $min = 0;\n\
    \    my $min = pop @$arr;\n    for (my $i = 1; $i <= $#$arr; $i++) {\n       \
    \ if ($arr->[$i] % 2 == 0) {\n            if ($arr->[$i] > $min) {\n         \
    \       $min = $arr->[$i];\n                my $index = $i;\n            }\n \
    \       }\n    }\n    push(@$arr, $min, $index);\n    return $arr;\n}", "    my\
    \ $max_ev = -1;\n    my $index;\n    my @result;\n    for (my $i = 0; $i < @$arr;\
    \ $i++) {\n        if ($ev[$i] < $max_ev) {\n            $index = $i;\n      \
    \      $max_ev = $ev[$i];\n        }\n    }\n    push(@result, $max_ev, $index);\n\
    \    return @result;\n}", "    my $max = $arr[0] % 2;\n    my $min = $arr[0];\n\
    \    my $index = 0;\n    my @ans;\n    for my $i (1..$#arr) {\n        if ($arr[$i]\
    \ % 2 == 0) {\n            if ($arr[$i] > $max) {\n                $max = $arr[$i];\n\
    \            }\n            if ($arr[$i] < $min) {\n                $min = $arr[$i];\n\
    \            }\n            $index++;\n        }\n    }\n    if ($max % 2 == 0)\
    \ {\n        if ($min == $max) {\n            @ans = ($min, $index);\n       \
    \ }\n        elsif ($min < $max) {\n            @ans = ($min, $index);\n     \
    \   }\n        elsif ($min > $max) {\n            @ans = ($max, $index);\n   \
    \     }\n    }\n    return @ans;\n}", "    my @res;\n    my $cur = 0;\n    my\
    \ @smaler = ();\n    for my $node (@$arr) {\n        if ($node % 2 == 0) {\n \
    \           $smaler[$cur] = $node;\n            $cur++;\n        }\n    }\n  \
    \  if (@smaler) {\n        $smaler[0] =~ /0/;\n        @res = map { $_ == $smaler[0]\
    \ ? @smaler : $_ } (@$arr);\n    } else {\n        @res = ();\n    }\n    return\
    \ @res;\n}", "    my @result;\n    my $max_val;\n    my $max_idx = -1;\n    foreach\
    \ my $idx (0..@$arr-1) {\n        my $value = $arr->[$idx];\n        if ($value\
    \ % 2 == 0) {\n            push(@result, $value);\n        }\n        if ($value\
    \ eq $max_val) {\n            $max_idx = $idx;\n        }\n        if ($value\
    \ eq $max_val) {\n            $max_idx = $idx;\n        }\n    }\n    if ($max_idx\
    \ != -1) {\n        $result[0] = $max_val;\n        $result[1] = $max_idx;\n \
    \   }\n    return @result;\n}\n</cell>\n<cell>\ndef sumPairs(nums):\n    sum_pairs\
    \ = 0\n    for x in nums:\n        for y in nums:\n            sum_pairs += ((x-y)**2)\n\
    \    return sum_pairs", "    my @result;\n    my $smal;\n    my $index;\n    for\
    \ (my $i = 0; $i < @$arr; $i++) {\n        $smal = $arr->[$i];\n        $index\
    \ = $i;\n        for (my $j = 0; $j < @$arr; $j++) {\n            if ($smal ne\
    \ $arr->[$j]) {\n                if ($smal % 2 == 0) {\n                    $smal\
    \ = $arr->[$j];\n                    $index = $j;\n                } else {\n\
    \                    last;\n                }\n            }\n        }\n    \
    \    push(@result, $smal, $index);\n    }\n    return @result;\n}", "    my %hash;\n\
    \    for(my $i = 0 ; $i < @$arr ; $i++) {\n        if(!exists $hash{$arr->[$i]})\
    \ {\n            $hash{$arr->[$i]} = $i;\n        }\n    }\n    return grep( !($hash{$_}\
    \ % 2), keys(%hash) );\n}\n</code>\nThe same logic applied here\n<code>", "  \
    \  my($min, $index) = undef;\n    my($smalest_values);", "    my @ans;\n    my\
    \ $min = 0;\n    my %hash;\n    my $index = 0;\n    my $max_index = 0;\n    foreach\
    \ my $node (@$arr) {\n        if ($hash{$node} < 0) {\n            push @ans,\
    \ $node;\n            $hash{$node} = $index;\n            $index++;\n        }\
    \ else {\n            if ($hash{$node} > $hash{$min}) {\n                $min\
    \ = $node;\n                $max_index = $hash{$min};\n            }\n       \
    \ }\n    }\n    push @ans, $min;\n    if ($index == $max_index) {\n        return\
    \ [];\n    } else {\n        return ($hash{$min}, $max_index);\n    }\n}\n</cell>\n\
    <text>\nGiven an array representing a branch of a tree that has non-negative integer\
    \ nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node\
    \ should be the node with the smallest even value.\nIf multiple nodes with the\
    \ same smallest even value are found return the node that has smallest index.\n\
    The plucked node should be returned in an array, [ smalest_value, its index ],\n\
    If there are no even values or the given array is empty, return [].\nExample 1:\n\
    >>> pluck([4, 2, 3])\n[2, 1]\nExplanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\nExample 2:\n>>> pluck([1, 2, 3])\n[2, 1]\nExplanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\nExample 3:\n>>>\
    \ pluck([])\n[]\nExample 4:\n>>> pluck([5, 0, 3, 0, 4, 2])\n[0, 1]\nExplanation:\
    \ 0 is the smallest value, but  there are two zeros,\nso we will choose the first\
    \ zero, which has the smallest index.\nConstraints:\n* 1 <= nodes.length <= 10000\n\
    * 0 <= node.value\nSolution Summary:", "    my ($i, $temp);\n    \n    my $ans\
    \ = [];\n    \n    foreach (0 .. $#$arr) {\n        $temp = $arr->[$_];\n    \
    \    \n        my $even = 0;\n        $ans[$_] = $temp;\n        for (my $j =\
    \ $_ + 1; $j < $#$arr; $j++) {\n            if ($arr->[$j] & 1) {\n          \
    \      $even = 1;\n                $ans[$_] = $temp;\n            }\n        }\n\
    \        \n        if ($even && $ans[$_] > $ans[$_ - 1]) {\n            $ans[$_]\
    \ = $ans[$_ - 1];\n        }\n    }\n    \n    return $ans;\n}", "    return @$arr\
    \ if $arr;\n    return [];\n}\n</code>\n<|/ a |>\n<| c |>\nThat's a nice solution.\
    \ By the way, I think that this solution might be the best one to solve this problem.\
    \ I tried many times to optimize this code, and it is quite faster than the other\
    \ solutions posted. I don't know why, but when I use the code from Sedgewick's\
    \ solution to solve this problem, my code runs faster. It is a big surprise for\
    \ me that my solution runs faster than Sedgewick's solution. Could you explain\
    \ what happened when I use the code from Sedgewick's solution?\n<|/ c |>\n<| c\
    \ |>\nI believe your code is optimized since you use `index` to find the minimum\
    \ even node, and `first` to find the minimum of all even nodes. But my code only\
    \ use 1 `grep` call, while Sedgewick's code use `grep` + `map` to find the minimum\
    \ of all even nodes. If you could explain why my code runs faster than Sedgewick's\
    \ code, I will appreciate it.\n<|/ c |>\n<| c |>\nYes, it's optimized, because\
    \ mine is more optimized than Sedgewick's code, because mine uses less `grep`\
    \ call. I also added comments in the code. Hopefully it will help you to understand\
    \ what I mean :)\n<|/ c |>\n<| c |>\nI have run your program on my machine, and\
    \ it ran slower than Sedgewick's solution. I don't know why it took more time.\
    \ I guess that Sedgewick's code is optimized because he uses less `grep` calls.\
    \ I do some test on my machine and found that mine takes more time than Sedgewick's\
    \ code. By the way, I have written a C++ version, and it runs faster than Sedgewick's\
    \ code on my machine.\n<|/ c |>\n<| a tags=c,grep,algorithm |>\nHere's a naive\
    \ C version:\n<code>\nint min_index(int *arr) {\n    int min = arr[0], i, min\
    \ = INT_MAX;\n    int n = sizeof(arr) / sizeof(*arr);\n    for (i = 0; i < n;\
    \ i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n\
    \    }", "    my $max_value;\n    my ($i, $min_index) = -1;\n    for my $val (@$arr)\
    \ {\n        if ($val < $max_value) { \n            $max_value = $val;\n     \
    \       $min_index = $i;\n        }\n        if ($val % 2 == 0) {\n          \
    \  $max_value *= 2;\n        } else {\n            $max_value *= 2;\n        }\n\
    \    }\n    if ($max_value eq 0) {\n        return [];\n    }\n    return ($max_value,\
    \ $min_index);\n}", "    my $min = 9999;\n    my @nodes;\n    my @returns;\n \
    \   for my $i (0 .. $#{$arr}) {\n        my $v = $arr->[$i];\n        my $ev =\
    \ $v / 2;\n        if ($ev <= $min) {\n            $min = $ev;\n            $nodes[$i]\
    \ = $v;\n        } elsif ($ev == $min) {\n            $nodes[$i] = $v;\n     \
    \   }\n    }\n    return @nodes;\n}", "    my %seen;\n    my @result;", "    my\
    \ @res;\n    my $index_of_smallest_value;\n    my $smallest_value;", "    my @ret;\n\
    \    my ($min_key, $min_value);\n    my $first_key = 0;\n    my $first_value =\
    \ $arr[$first_key];\n    for (my $i = 1; $i < @$arr; ++$i) {\n        my $val\
    \ = $arr[$i];\n        if ($val eq $first_value) {\n            ++$first_key;\n\
    \        }\n        if ($val <= $first_value) {\n            ++$min_key;\n   \
    \         $min_value = $val;\n        }\n    }\n    $ret[0] = $first_value;\n\
    \    $ret[1] = $first_key;\n    if ($min_key > 0) {\n        $ret[0] = $arr[$min_key];\n\
    \        $ret[1] = $min_key;\n    }\n    return @ret;\n}", '    my($min, $max);',
  "    my ($smalest_value) = $arr[0]; # initialize\n    my (@plucked) = []; # initialize\n\
    \    foreach my $num (@{$arr}) {\n        my $index = 0;\n        for (my $i =\
    \ $index; $i < @plucked && $plucked[$i] <= $num; $i++) {\n        } # for\n  \
    \      if ($i == @plucked) {\n            push @plucked, $num;\n        } # if\n\
    \        else {\n            $smalest_value = $num;\n            $index = $i;\n\
    \        } # else\n    } # foreach\n    return @plucked if $smalest_value eq 0;\n\
    \    return [ @plucked, $smalest_value ] if @plucked > 0;\n    return [];\n}",
  "    my $smalest_val;\n    my $smalest_index;\n    my @smalest_values;\n    foreach\
    \ my $index (0 .. $#$arr) {\n        my $value = $arr->[$index];\n        my $is_even\
    \ = $value % 2 == 0;\n        next if ($smalest_val && $is_even);\n        next\
    \ if $smalest_val && $smalest_index == $index;\n        if ($is_even) {\n    \
    \        $smalest_val = $value;\n            $smalest_index = $index;\n      \
    \      push @smalest_values, $value;\n        } elsif ($smalest_val > $value)\
    \ {\n            $smalest_val = $value;\n            $smalest_index = $index;\n\
    \        }\n    }\n    return @smalest_values;\n}", "    my %even_index = ();\n\
    \    my $min_even_val = 0;", "    my($i, $j, $index, $tmp, $min_even);\n    \n\
    \    # Initialize the result\n    my(@result) = ();\n    \n    # Find the smallest\
    \ even value\n    # Find smallest index in the array\n    for (my $i = 0; $i <\
    \ @$arr; $i++) {\n        $index = $i;\n        $min_even = $arr[$i];\n      \
    \  for (my $j = 0; $j < @$arr; $j++) {\n            if ($min_even % 2 != 0) {\n\
    \                $tmp = $arr[$j];\n                if ($tmp < $min_even) {\n \
    \                   $min_even = $tmp;\n                    $index = $j;\n    \
    \            }\n            }\n        }\n        push(@result, $min_even, $index);\n\
    \    }\n    return @result;\n}\n</cell>\n<cell>\nimport random", "    if (@$arr\
    \ == 0 or $arr->[0] == 0) { return (); }\n    my $min_value = $arr->[0];\n   \
    \ my $min_index = 0;\n    for my $index (0 .. $#{$arr}) {\n        if ($arr->[$index]\
    \ % 2 == 0) {\n            if ($min_value < $arr->[$index]) {\n              \
    \  $min_value = $arr->[$index];\n                $min_index = $index;\n      \
    \      }\n        }\n    }\n    return [ $min_value, $min_index ];\n}", "    my\
    \ $min_value = undef;\n    my $min_value = $arr[0];\n    my $min_value_index =\
    \ 1;\n    foreach my $index (1..$#$arr) {\n        if ($arr[$index] % 2 != 0)\
    \ {\n            $min_value = $arr[$index];\n            $min_value_index = $index;\n\
    \        }\n    }\n    return [$min_value, $min_value_index] if $min_value;\n\
    \    return [];\n}", "    my($smalest_value) = @$arr[0]; # $smalest_value -> smallest\
    \ even value\n    my($smallest_index) = 0;\n    my(@resulting_values) = [];\n\
    \    my($node_value,@result_indexes);", '    my($node, $index, $result) = @_;',
  "    my;\n    my @a;\n    my $v;\n    my $i;\n    foreach my $i (0 .. $#{$arr})\
    \ {\n        my $v = ( $arr->[$i] );\n        if ($v % 2 ) {\n            $a[0]\
    \ = $v;\n            $a[1] = $i;\n            $v = 0;\n        }\n        else\
    \ {\n            if ( not exists $a[0] ) {\n                $a[0] = $v;\n    \
    \            $a[1] = $i;\n            }\n            else {\n                if\
    \ ( $a[0] > $v ) {\n                    $a[0] = $v;\n                    $a[1]\
    \ = $i;\n                }\n            }\n        }\n    }\n    return @a;\n}",
  "    my @out;\n    my %out;", "    my $res;\n    my ($key, $min);\n    foreach my\
    \ $n (@$arr) {\n        if ($n % 2 == 0) {\n            $key = $n;\n         \
    \   $min = $n;\n        }\n    }\n    return $min unless defined $key;\n    $key\
    \ = $key - 1;\n    foreach my $n (@$arr) {\n        if ($n % 2 == 0) {\n     \
    \       if ($n eq $key) {\n                $res = [$n, $key];\n              \
    \  last;\n            } else {\n                if ($n < $min) {\n           \
    \         $min = $n;\n                    $res = $key;\n                }\n  \
    \          }\n        }\n    }\n    return $res;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=arrays,perl,recursion |>\n<code>", "    return @$arr if @$arr == 0;\n\
    \    my($min, $index, $found);\n    my %hash;\n    for (@$arr) {\n        if (defined\
    \ $hash{$_}) {\n            push @$found, $hash{$_};\n            $index = $_;\n\
    \        } else {\n            $hash{$_} = $_;\n        }\n    }\n    @$found\
    \ = @$found < $min ? @$found : ();\n    if (@$found == 0) {\n        return ();\n\
    \    }\n    return ($min, $index);\n}\n</cell>\n<text>\n6.6 Die Roll", "    my\
    \ @ret;\n    for(my $i = 0 ; $i < @$arr; $i++) {\n        if($arr->[$i] % 2 ==\
    \ 0) {\n            $ret[$i] = $arr->[$i];\n        }\n    }\n    if(@$arr ==\
    \ 0 ||  grep($arr->[$_] % 2 == 0, 0..$#arr)) {\n        @ret = ();\n    }\n  \
    \  @ret;\n}", "    $arr -> sort { $a <=> $b };\n    my $index = 0;\n    my $smalest_value;\n\
    \    my $smalest_index;\n    for (my $i = 0; $i <= $#{$arr}; $i++) {\n       \
    \ my $value = $arr->[$i];\n        if ($value & 1) {\n            if ($smalest_value\
    \ === undef) {\n                $smalest_value = $value;\n                $smalest_index\
    \ = $index;\n            } else {\n                if ($smalest_value < $value)\
    \ {\n                    $smalest_value = $value;\n                    $smalest_index\
    \ = $index;\n                }\n            }\n        }\n        $index++;\n\
    \    }\n    if ($smalest_index && $smalest_value) {\n        return [$smalest_value,\
    \ $smalest_index];\n    } elsif ($smalest_value) {\n        return [$smalest_value,\
    \ $index];\n    } elsif ($smalest_index) { #even value\n        return [$smalest_value,\
    \ $index];\n    } else {\n        return [];\n    }\n}", "    my $count = 0;\n\
    \    my @ans = ();\n    foreach my $item (@$arr) {\n        push (@ans, $item)\
    \ if $item % 2 == 0;\n        if ($item == 0) {\n            $count++;\n     \
    \   }\n    }\n    if ($count == 0) {\n        return [];\n    }\n    if (@ans\
    \ == 0) {\n        return [];\n    }\n    my $min = $ans[0];\n    my $index_min\
    \ = 0;\n    foreach my $index (0..@ans-1){\n        if ($ans[$index] % 2 == 0)\
    \ {\n            if ($min > $ans[$index]) {\n                $min = $ans[$index];\n\
    \                $index_min = $index;\n            }\n        }\n    }\n    my\
    \ @return = ();\n    push(@return, $min, $index_min);\n    return @return;\n}",
  "    my $idx = 0;\n    my $smalest_value = 0;\n    for my $i (0 .. $#$arr) {\n \
    \       if ($arr[$i] & 1) {\n            $smalest_value = $arr[$i];\n        \
    \    $idx = $i;\n        }\n    }\n    return @$arr[$idx .. $#$arr] if $smalest_value;\n\
    \    return [];\n}", "    if (@$arr == 0){\n        return ();\n    }\n    my\
    \ $index = 0;\n    my $minval = 0;\n    my $smalest_value;\n    foreach (@$arr){\n\
    \        next unless $_%2 == 0;\n        $minval = $_;\n        $smalest_value\
    \ = $_;\n        my $i;\n        for ($i = 0; $i < @$arr; $i++){\n           \
    \ $index++;\n            if ($_ == $minval and $smalest_value < $arr[$i] && $i\
    \ != 0){\n                $smalest_value = $arr[$i];\n                $index =\
    \ $i;\n            }\n        }\n    }\n    if ($minval == 0) {\n        return\
    \ ();\n    }\n    my $result = ();\n    push (@$result, $minval);\n    push (@$result,\
    \ $index);\n    return $result;\n}\n</cell>\n<cell>\nsolve()\n</cell>\n<text>\n\
    Solution 2", "    my @ret;\n    my $len = @$arr;\n    my $min = $len;\n    my\
    \ $min_index;\n    for (my $i = 0; $i < $len; $i++) {\n        if ($arr[$i] %\
    \ 2 != 0) {\n            $min = $i;\n            $min_index = $i;\n        } elsif\
    \ ($arr[$i] == 0 && $len > 1) {\n            $min = $len;\n            $min_index\
    \ = $i;\n            $i = $len - 1; # $len will get reset to 0 after this loop\n\
    \        }\n    }\n    if ($min > 0) {\n        @ret = @$arr[ $min .. $min_index\
    \ + 1 ];\n    } else {\n        @ret = [];\n    }\n    return @ret;\n}", "   \
    \ if (scalar(@$arr) == 0) {\n        return [];\n    }\n    my @even_values;\n\
    \    for (my $i = 0; $i < scalar(@$arr); $i += 2) {\n        if ($arr[$i] & 1)\
    \ {\n            push @even_values, $arr[$i];\n        }\n    }\n    if (scalar(@even_values)\
    \ == 0) {\n        return [];\n    }\n    my $index = 0;\n    my $smallest_even_value\
    \ =\n        $even_values[0] & 1 ? $even_values[0] : $even_values[1];\n    foreach\
    \ my $even_value ($even_values) {\n        my $even_value =\n            $even_value\
    \ & 1 ? $even_value : $even_values[$index + 1];\n        if ($even_value < $smallest_even_value)\
    \ {\n            $smallest_even_value =\n                $even_value < $smallest_even_value\
    \ ? $even_value : $smallest_even_value;\n            $index = $i if $even_value\
    \ == $smallest_even_value;\n        }\n    }\n    return @$arr[$index..$#$arr];\n\
    }\n</cell>\n<cell>", "    my $min_even_value = -1;\n    my $min_index = 0;\n \
    \   my $smallest_value;\n    my @result;\n    foreach my $node (@{$arr}) {\n \
    \       $smallest_value = $node if $node % 2 == 0;\n        if ($smallest_value\
    \ ne -1) {\n            $min_even_value = $node if $node < $min_even_value;\n\
    \            $min_index = $node if $node < $min_index;\n        } elsif ($node\
    \ == 0) {\n            $smallest_value = $node if $node % 2 == 0;\n          \
    \  if ($smallest_value ne -1) {\n                $min_even_value = $node;\n  \
    \              $min_index = $node;\n            }\n        }\n        push(@result,\
    \ [$smallest_value, $min_index]);\n    }\n    return @result if @result;\n   \
    \ return [];\n}", "    my @vals;\n    my $index = 0;\n    foreach my $val (@$arr)\
    \ {\n        if ($val & 0x01) {\n            if ($val > $vals[$index]) {\n   \
    \             $index = $val;\n            }\n            else {\n            \
    \    $vals[$index] = $val;\n            }\n        }\n    }\n    return @vals\
    \ if @vals > 1;\n    return $vals[0];\n}", "    my $size = @$arr;\n    if ($size\
    \ == 0) {\n        return [];\n    }\n    my $min_idx = 0;\n    my $min_val =\
    \ undef;\n    my @ret = $arr;\n    for (my $i = 0; $i < $size; $i++) {\n     \
    \   if ($ret[$i] % 2 == 0) {\n            if (defined $min_val) {\n          \
    \      push(@ret, $min_val);\n                $min_val = undef;\n            \
    \    $min_idx++;\n            }\n            $ret[$i] = $i;\n        }\n    }\n\
    \    if (defined $min_val) {\n        push(@ret, $min_val);\n    }\n    return\
    \ @ret;\n}\n</code>\n<|/ a tags=arrays,perl |>\n<| c |>\nIt returns an empty array\
    \ if there are no even values. If there are multiple nodes with the same smallest\
    \ even value, it will return the node with the smallest index. I think it would\
    \ be great to have another example and explain the difference.\n<|/ c |>\n<| a\
    \ tags=arrays,perl |>\nThis is probably not the fastest solution, but still quite\
    \ readable. Just iterate through the array and check if there are any even numbers\
    \ left. If so, return the smallest one and set all numbers to their index, otherwise\
    \ set the current index to 0.\n<code>", "    my ($i, $val);\n    foreach $i (@$arr)\
    \ {\n        if ($i % 2 == 0) {\n            $val = $i;\n            last;\n \
    \       }\n    }\n    if (!defined $val) {\n        return [];\n    }\n    return\
    \ [$val, $i];\n}", "    if(@$arr == 0) return [];\n    if(@$arr == 1) return $_[0];\n\
    \    my $vals = ();\n    my $smallest_even_val = undef;\n    my $smallest_even_val_pos\
    \ = undef;\n    my $last_val = undef;\n    my $first_val = undef;\n    my $last_idx\
    \ = -1;\n    for(my $i=0; $i<@$arr; $i++) {\n        if($vals->{$_} eq $_) {\n\
    \            $last_idx = $i;\n            $last_val = $_;\n        }\n       \
    \ if($vals->{$_} != $_) {\n            $vals->{$_} = $_;\n            if($smallest_even_val\
    \ eq $_) {\n                $smallest_even_val_pos = $i;\n                $smallest_even_val\
    \ = $_;\n            }\n        }\n    }\n    if($smallest_even_val != $last_val)\
    \ {\n        return [];\n    }\n    return [$smallest_even_val, $smallest_even_val_pos];\n\
    }", "    my @res;\n    my $smallest;\n    my $smallest_index;\n    my $value;\n\
    \    my $index = 0;", "    my $min_even_node = $arr[0];\n    my $index = 0;\n\
    \    my $even_counter = 1;\n    while (@$arr) {\n        my $even_node = $arr[$even_counter];\n\
    \        if ($even_node < $min_even_node) {\n            $min_even_node = $even_node;\n\
    \            $index = $even_counter;\n        }\n        $even_counter++;\n  \
    \  }\n    my ($smalest_value, $smalest_index) = $min_even_node, $index;\n    if\
    \ (@$arr) {\n        $smalest_value = $arr[$smalest_index];\n    }\n    return\
    \ [$smalest_value, $smalest_index];\n}", "    $arr .= 0;\n    for my $v ( @$arr\
    \ ) {\n        if ( $v & 1 ) {\n            return [ @$arr, $v ];\n        }\n\
    \        $arr->[$v] = undef;\n    }\n    return [];\n}", "    my(@smalest_values,\
    \ %smallest_index_nodes);\n    for(my $i = 0; $i < @$arr; $i++) {\n        if(\
    \ $smallest_index_nodes{$i}[$i] ) {\n            $smallest_index_nodes{$i}[$i]\
    \ = $i;\n        }\n        elsif( $smallest_index_nodes{$i}[$i] &&\n        \
    \      !$smallest_index_nodes{$i}[$i] % 2 ) {\n            $smallest_index_nodes{$i}[$i]\
    \ = $i;\n        }\n        else {\n            if( $smallest_index_nodes{$i}[$i]\
    \ ) {\n                $smallest_index_nodes{$i}[$i] = $i;\n            }\n  \
    \          else {\n                $smallest_index_nodes{$i}[$i] = $i;\n     \
    \       }\n        }\n    }", "    return [];\n}", "    my @ret;\n    my %seen;\n\
    \    for (my $i = 0; $i < @$arr; $i += 2) {\n        my $val = $arr->[$i];\n \
    \       my $idx = $i / 2;\n        if ($seen{$val}) {\n            my $prev_idx\
    \ = $seen{$val};\n            if ($prev_idx eq $idx) { # pick the one with the\
    \ smallest index\n                push @ret, map {$_ => $val}\n              \
    \      if ($arr->[$prev_idx] + 1 eq $arr->[$idx]);\n            } else { # pick\
    \ the one with the smallest value\n                push @ret, $val;\n        \
    \    }\n        } else {\n            push @ret, $val;\n        }\n        $seen{$val}\
    \ = $idx;\n    }\n    return @ret ? \\@ret : [];\n}", "    my($min_ev) = (0, undef);\n\
    \    my($index) = (0, 0);\n    my(@min_evs);\n    my(@indexes);\n    for (my $i\
    \ = 0; $i < @$arr; $i++) {\n        my $ev = pop(@$arr);\n        $min_ev->[0]\
    \ = $ev;\n        $min_ev->[1] = $i;\n        @min_evs = ();\n        push(@min_evs,\
    \ $min_ev) if ($ev % 2 != 0);\n        for (my $k = 0; $k < @min_evs; $k++) {\n\
    \            my $ev = @min_evs->[$k];\n            if ($ev % 2 == 0) {\n     \
    \           $min_ev->[0] = $ev;\n                push(@min_evs, $min_ev);\n  \
    \              $index = $k;\n            }\n        }\n    }\n    if (!@min_evs)\
    \ {\n        return [];\n    }\n    if (@min_evs > 1) {\n        my $ev = $min_ev->[0];\n\
    \        $index = $min_ev->[1];\n        for (my $k = 0; $k < @min_evs; $k++)\
    \ {\n            my $ev = @min_evs->[$k];\n            if ($ev->[0] == $ev) {\n\
    \                if ($ev->[1] < $index) {\n                    $index = $k;\n\
    \                }\n            }\n        }\n    }\n    my $ev = @min_evs->[0];\n\
    \    return [map $ev->[0], @min_evs];\n}\n</cell>\n<text>\nThe next cell is your\
    \ turn.", "    if (@$arr == 0){\n        return [];\n    }\n    my $min = -1000000;\n\
    \    my $index = 0;\n    my $smallest_value = shift @$arr;\n    for (my $i = 0;\
    \ $i <; $i++) {\n        my $v = $arr[$i];\n        if ($v == $smallest_value){\n\
    \            $index = $i;\n            last;\n        }\n        if ($v < $smallest_value){\n\
    \            $min = $smallest_value;\n            $index = $i;\n        }\n  \
    \      if ($v % 2 == 0) {\n            $min = $v if $v < $min;\n        }\n  \
    \  }\n    return [ $smallest_value, $index ];\n}", "    if($arr->[0]) {\n    \
    \    my $min;\n        my $index;\n        my $found;\n        my $even;\n   \
    \     my $key;\n        my $i = 0;\n        while(@$arr) {\n            chomp(@$arr);\n\
    \            ++$i;\n            if($found and $found != $i) {\n              \
    \  return $key;\n            }\n            $key = $arr->[0];\n            $found\
    \ = $i;\n            if($key % 2 == 0) {\n                $even = $key;\n    \
    \            $min = $even;\n                $index = $i;\n                $key\
    \ = undef;\n            } else {\n                if($key < $min) {\n        \
    \            $min = $key;\n                    $index = $i;\n                }\n\
    \            }\n            splice, @$arr, 2;\n        }\n        if($min < $even)\
    \ {\n            return [\n                $min,\n                $index\n   \
    \         ];\n        } else {\n            return [];\n        }\n    } else\
    \ {\n        return [];\n    }\n}", '    my $pick;', "    my @smallest_even;\n\
    \    my $smallest_even = 0;\n    my @index;\n    \n    foreach my $val (@$arr)\
    \ {\n        if ($val % 2 != 0 && $smallest_even == 0) {\n            $smallest_even\
    \ = $val;\n        }\n        elsif ($val % 2 == 0) {\n            if ($smallest_even\
    \ > $val) {\n                $smallest_even = $val;\n            }\n        }\n\
    \    }\n    if ($smallest_even > 0) {\n        push(@smallest_even, $smallest_even);\n\
    \        push(@index, $smallest_even - 1);\n    }\n    elsif ($smallest_even <\
    \ 0) {\n        $smallest_even += 1;\n        push(@smallest_even, $smallest_even);\n\
    \        push(@index, $smallest_even - 1);\n    }\n    elsif ($smallest_even ==\
    \ 0) {\n        push(@smallest_even, 0);\n        push(@index, 0);\n    }\n  \
    \  return @smallest_even, @index;\n}", "    @$arr = @$arr[0,1] unless @$arr;\n\
    \    my $min_even_val = -1;\n    my $min_index = 0;\n    for(my $i = 1; $i <=\
    \ @$arr; $i++) {\n        my $val = $arr->[$i];\n        if($val % 2 == 0) {\n\
    \            my $even_val = $val / 2;\n            if($min_even_val == -1 || $even_val\
    \ < $min_even_val) {\n                $min_even_val = $even_val;\n           \
    \     $min_index = $i;\n            }\n        }\n    }\n    if(@$arr == 0) {\n\
    \        return [];\n    }\n    return [ $min_even_val, $min_index ];\n}", " \
    \   @$arr = [@$arr];\n    for (my $i = 0; $i < @$arr; $i++) {\n        my $v =\
    \ ($arr->[$i] % 2) == 0;\n        my $c = $v + $i;\n        my $k = $c % @$arr;\n\
    \        if ($k >= 0) {\n            push (@$arr, $v + $i);\n        }\n    }\n\
    \    return $arr[0] < $arr[1]\n            ? ( [ @$arr, $arr[0] % @$arr ] )\n\
    \            : ();\n}\n</cell>\n<text>\nGiven an array representing a branch of\
    \ a tree that has non-negative integer nodes. Your task is to pluck one of the\
    \ nodes and return it. the plucked node should be the node with the smallest odd\
    \ value. If multiple nodes with the same smallest odd value are found return the\
    \ node that has smallest index. If there are no odd values or the given array\
    \ is empty, return []. Example 1:\n [4, 2, 3]\n Explanation: 2 has the smallest\
    \ odd value, and 2 has the smallest index.\n Example 2:\n [1, 2, 3]\n Explanation:\
    \ 2 has the smallest odd value, and 2 has the smallest index.\n Example 3:\n []\n\
    \ Example 4:\n [5, 0, 3, 0, 4, 2]\n Explanation: 0 is the smallest value, but\
    \ there are two zeros, so we will choose the first zero, which has the smallest\
    \ index.\n Constraints:\n 1 <= nodes.length <= 10000\n 0 <= node.value", '    my(@val);',
  "    my @picked = ();\n    for(my $i = 0; $i < @$arr; $i++) {\n        if ($arr->[$i]\
    \ % 2 != 0) {\n            push(@picked, $arr->[$i]);\n        }\n    }\n    my\
    \ $min = pop(@picked);\n    for(my $i = 0; $i < @picked; $i++) {\n        if ($picked[$i]\
    \ == $min) {\n            return ($picked[$i], $i);\n        }\n    }\n    return\
    \ ();\n}", "    my($result) = [];\n    for (my $i = 0; $i <= $#{$arr}; $i++) {\n\
    \        # Check if current value is even, if so add value to result array\n \
    \       if ($arr->[$i] % 2 != 0) {\n            push(@$result, $arr->[$i]);\n\
    \        }\n    }\n    # Sort the result array by even values\n    sort {$a <=>\
    \ $b} @$result;\n    # Get the element with smallest even value\n    return $result[0]\
    \ if(scalar @$result == 0);\n    # Return both values\n    return [scalar @$result,\
    \ scalar @$result];\n}", "    return [];\n    \n    # Write your code here\n \
    \   my $max = 0;\n    my $idx = 0;\n    for (my $i = 0; $i < $#arr; $i++) {\n\
    \        if ($arr[$i] & 1) {\n            if ($max == 0) {\n                $max\
    \ = $i;\n            }\n            $idx = $i;\n        }\n    }\n    return [\
    \ $max, $idx ];\n}\n</cell>\n<text>\n4.3 Smallest Index", '    my @result;', " \
    \   if(@$arr == 0){\n        return [];\n    }\n    my $min = find_min(@$arr);\n\
    \    return [ $min ];\n}", "    my($smallest_value) = ($arr[0]->{value} < $arr[1]->{value})\
    \ ? $arr[0]->{value} : $arr[1]->{value};\n    my($smallest_index) = ($arr[0]->{index}\
    \ < $arr[1]->{index}) ? $arr[0]->{index} : $arr[1]->{index};\n    my(@return_value);\n\
    \    foreach my $i (0 .. $#$arr) {\n        my($node) = @$arr[$i];\n        if\
    \ ($node->{value} % 2 == 0 && $node->{value} < $smallest_value) {\n          \
    \  $smallest_value = $node->{value};\n            $smallest_index = $i;\n    \
    \    } elsif ($node->{value} % 2 == 0 &&  $node->{value} == $smallest_value &&\
    \ $node->{index} < $smallest_index) {\n            $smallest_value = $node->{value};\n\
    \            $smallest_index = $node->{index};\n        }\n    }\n    push(@return_value,\
    \ $smallest_value, $smallest_index);\n    @return_value\n}", "    my $smallest_even_val;\n\
    \    my $smallest_even_idx;\n    for (my $index = 0; $index<@$arr; $index++) {\n\
    \        my $val = $arr->[$index];\n        if ($val & 1) {\n            $smallest_even_val\
    \ = $val;\n            $smallest_even_idx = $index;\n        }\n    }\n    if\
    \ ($smallest_even_val) {\n        return $smallest_even_val, @$arr[$smallest_even_idx];\n\
    \    }\n    return [];\n}", "    my @res;\n    my $i = 0;\n    my $min = 10000000000000;\n\
    \    my ($node_value, $node_index) = (0, -1);\n    foreach my $node (@$arr) {\n\
    \        if ($node % 2 == 0) {\n            $i = $node;\n            $node_index\
    \ = $i;\n            $node_value = $node;\n        }\n        if ($node < $min)\
    \ {\n            $min = $node;\n            $node_index = $i;\n        }\n   \
    \ }\n    push(@res, [\"$node_value\", \"$node_index\"]);\n    return @res;\n}",
  "    my $result;\n    if ($arr->[0] eq 0) {\n        return [];\n    }\n    my @sorted_array\
    \ = sort {$a->[0] cmp $b->[0]} @$arr;\n    if (@sorted_array->[0] & 1) {\n   \
    \     my $value = $sorted_array->[1];\n        my $index = $sorted_array->[0]\
    \ / 2;\n        while (1) {\n            if ($value & 1) {\n                if\
    \ (@sorted_array->[$index] > 0) {\n                    $result = [$value, $index];\n\
    \                    last;\n                } else {\n                    return\
    \ [];\n                }\n            }\n            $value >>= 1;\n         \
    \   $index += 1;\n        }\n    } else {\n        $result = $sorted_array->[1];\n\
    \    }\n    return $result;\n}", "    if(@$arr == 0){\n        return [];\n  \
    \  }\n    if($arr[0] % 2 == 0){\n        my $min = $arr[0];\n        my $idx =\
    \ 0;\n        for(my $i=1; $i<@$arr; $i++){\n            my $v = $arr[$i];\n \
    \           if($v % 2 ==0){\n                if(($v - $min) % 2 ==0){\n      \
    \              if($v < $min){\n                        $min = $v;\n          \
    \              $idx = $i;\n                    }\n                }\n        \
    \    }\n        }\n        return [$min, $idx];\n    }else{\n        return [];\n\
    \    }\n}\n</code>\n<|/ a tags=perl dscore=2 |>\n<| a tags=perl dscore=1 |>\n\
    Here's a way with grep:\n<code>\nuse strict;\nuse warnings;", "    my $index =\
    \ 0;\n    my $smalest_value;\n    foreach my $node (@{$arr}) {\n        if ($node\
    \ < $smalest_value) {\n            my $temp = @{$arr};\n            $index = 0;\n\
    \            while (@{$temp}) {\n                $index += 1;\n              \
    \  shift @{$temp};\n            }\n        }\n        $smalest_value = $node if\
    \ ($node < $smalest_value);\n    }\n    if ($smalest_value == 0) {\n        return\
    \ ();\n    }\n    return [ $smalest_value, $index ];\n}", "    my @result;\n \
    \   my $min;\n    my $i;\n    my $j;\n    my $value;", "    if (scalar @$arr ==\
    \ 0) {\n        return [];\n    }\n    my(@result,$i);\n    my $min_val = @$arr\
    \ == 1 ? $arr[0] : $arr[0] % 2 == 0 ? $arr[0] : $arr[0] / 2;\n    my $i = 0;\n\
    \    for (@$arr) {\n        if (($val = $_ % 2) == 0) {\n            if ($val\
    \ < $min_val) {\n                $min_val = $val;\n                $i = $i;\n\
    \            }\n        }\n        elsif ($val != $min_val) {\n            if\
    \ ($i == 0) {\n                $min_val = $val;\n                $i = $i;\n  \
    \          }\n        }\n    }\n    if ($min_val != $arr[$i]) {\n        $min_val++;\n\
    \    }\n    push (@result, $min_val);\n    return @result;\n}", "    if(@$arr\
    \ == 0 || @$arr == 1){\n        return @$arr;\n    }\n    my @sorted = sort {\
    \ $a <=> $b } @$arr;\n    if(@sorted == 0){\n        return ();\n    }\n    my($min,\
    \ $min_index);\n    for(my $i = 0; $i < @$arr; $i++){\n        if($sorted[$i]\
    \ % 2 == 0){\n            $min = $sorted[$i];\n            $min_index = $i;\n\
    \        }\n    }\n    return ($min, $min_index);\n}", "    my($min, $index, $min_index);\n\
    \    my $i = 0;\n    while ($i < @$arr) {\n        my $val = $arr->[$i];\n   \
    \     if ($val % 2 == 0) {\n            my $v = $val / 2;\n            if ($v\
    \ < $min) {\n                $min = $v;\n                $min_index = $i;\n  \
    \          }\n            $i++;\n        }\n        else {\n            $i++;\n\
    \        }\n    }\n    return @$arr[0 .. $min_index];\n}", "    my@arr = @$arr;\n\
    \    for(my $i=0; $i<@arr; $i++) {\n        if($arr[$i] % 2 != 0) {\n        \
    \    splice @arr, $i, 1;\n            last;\n        }\n    }\n    my $smallest\
    \ = -1;\n    for(my $i=0; $i<@arr; $i++) {\n        if($arr[$i] % 2 != 0) {\n\
    \            if($smallest == -1) {\n                $smallest = $i;\n        \
    \    } elsif($arr[$i] < $smallest) {\n                $smallest = $i;\n      \
    \      }\n        }\n    }\n    push @$arr, $smallest;\n    return $arr;\n}",
  '    my($smallest, $smallest_index) = (0, 0);', "    my @ret;\n    my %seen;\n \
    \   \n    @$arr =~ m/(.)(.+)/;\n    my $val = $2;\n    my $idx = $1;\n    if ($seen{$val}++)\
    \ {\n        my $i = $idx;\n        for (; $i < @$arr; $i++) {\n            if\
    \ ($seen{$arr[$i]}++) {\n                last;\n            }\n        }\n   \
    \     my $j = $idx;\n        for (; $j < @$arr; $j++) {\n            if ($seen{$arr[$j]}++)\
    \ {\n                last;\n            }\n        }\n        if ($j < @$arr)\
    \ {\n            @ret = map { $arr[$_] } @$arr[0..$j-1];\n        }\n    } else\
    \ {\n        @ret = map { $arr[$_] } @$arr[0..$idx-1];\n    }\n    return @ret\
    \ ? @ret : @$arr;\n}", "    my @index;\n    my $min_even_val = -1;\n    my $smalest_val\
    \ = 0;\n    for (my $i = 0; $i < @$arr; $i++) {\n        my $cur = $arr->[$i];\n\
    \        next unless $cur > 0;\n        $cur % 2 == 0 ? $smalest_val = $cur :\
    \ $min_even_val = $cur;\n        push(@index, $i);\n    }\n    return $smalest_val\
    \ != -1 ? [@$arr[$index[$smalest_val]]] : $arr eq [] ? [] : \\@index;\n}", " \
    \   my@arr; # Array for storing values\n    my($picked);\n    my $min = $arr[0];\n\
    \    my $index;\n    my $count = 0;\n    foreach my $val (@$arr) {\n        my\
    \ $pick = $val;\n        if ($pick % 2 == 0 && $pick < $min) {\n            $min\
    \ = $pick;\n            $picked = $val;\n            $index = $count;\n      \
    \  }\n        $count++;\n    }\n    if ($picked < $min) {\n        return @$picked;\n\
    \    }\n    if ($picked == $min) {\n        return $index;\n    }\n    return\
    \ ();\n}", "    my @res;\n    my $smalest_value = 0;\n    my $smalest_index =\
    \ 0;\n    my $smalest_even_index = 0;", "    if (@$arr == 0 or $arr[0] < 1) {\n\
    \        return [];\n    }\n    my($i, $j, $min, $min_index);\n    for (my $i\
    \ = 0; $i < @$arr; $i++) {\n        if ($arr[$i] % 2 == 0) {\n            $min\
    \ = min $arr[$i],$min;\n            $min_index = $i;\n        }\n    }\n    if\
    \ ($min == 0) {\n        return [];\n    }\n    return [ $min, $min_index ];\n\
    }", "    my $min = -1;\n    my $index = -1;\n    for my $n ( @$arr ) {\n     \
    \   if ( $n & 1 ) {\n            if ( $n < $min ) {\n                $min = $n;\n\
    \                $index = @$arr - 1;\n            }\n            else {\n    \
    \            push @$arr, $n;\n            }\n        }\n    }\n    if ( $min >=\
    \ 0 ) {\n        if ( @$arr == 0 ) {\n            my @temp;\n            push\
    \ @temp, $min;\n            return \\@temp;\n        }\n        my $i = 0;\n \
    \       while ( $i <= $#arr ) {\n            if ( $arr[$i] & 1 ) {\n         \
    \       return @$arr[$i];\n            }\n            $i++;\n        }\n    }\n\
    \    return ();\n}", "    if (@$arr == 0 || @$arr == 1) {\n        return [];\n\
    \    }\n    my $min = $arr->[0];\n    my $index = 0;\n    for my $val (@$arr)\
    \ {\n        if ($val % 2 != 0 && $val < $min) {\n            $min = $val;\n \
    \           $index = $val;\n        }\n    }\n    return [ $min, $index ];\n}",
  "    return $arr[0] if !$arr || !@$arr;\n    my ($even, $index) = (-1, -1);\n  \
    \  for my $n (@$arr) {\n        $index++ if $n & 1;\n        $even += $n if $n\
    \ & 1;\n    }\n    return @$arr[$index] if $even && $even <= @$arr;\n    return;\n\
    }", "    my @res;\n    if (@$arr == 0 || @$arr < 1) {\n        return [];\n  \
    \  }\n    my $min = -1;\n    for my $ele (@$arr) {\n        my $n = $ele % 2;\n\
    \        if ($n eq 0) {\n            if ($min > 0 || $n < 1) {\n             \
    \   $min = $ele if $n eq $min;\n                push(@res, $ele);\n          \
    \  }\n        }\n    }\n    return $min > 0 ? [@res, $min] : [@res];\n}", "  \
    \  my @result;\n    my $smalest_value;\n    my $index;", "    my @out;\n    my\
    \ $min = 0;\n    foreach my $n (@$arr) {\n        if ($n % 2 == 0) {\n       \
    \     my $temp = $n % $min;\n            push @out, [$temp, $n] if $temp > $min;\n\
    \            $min = $n;\n        }\n    }\n    if (scalar @out) {\n        return\
    \ sort { $b->[0] <=> $a->[0] } @out;\n    }\n    return [];\n}", "    my($min);\n\
    \    my($index);\n    my($result);\n    foreach (@$arr) {\n        if ($_ %2 ==\
    \ 0) {\n            $min = $_;\n            $index = 0;\n        } else {\n  \
    \          push(@$result, $min, $index);\n            $min = $_;\n           \
    \ $index++;\n        }\n    }\n    push(@$result, $min, $index);\n    return @$result;\n\
    }", "    my;\n    my($index, $value) = (0, 0);\n    for (my $i = 0; $i <= $#$arr;\
    \ $i++) {\n        push, $arr->[$i];\n        if ($arr->[$i] % 2 == 0) {\n   \
    \         $value = $arr->[$i];\n            $index = $i;\n        }\n    }\n \
    \   if ($value > 0) {\n        push, $value;\n        push, $index;\n    }\n \
    \   return wantarray ? @arr : $arr->[$index];\n}", "    my @result;\n    my $smallest;\n\
    \    my $index;\n    my $even_value;\n    for (my $i = 0; $i < @$arr; $i++) {\n\
    \        if ($i % 2 == 0) {\n            $even_value = $arr->[$i];\n        }\
    \ else {\n            if (defined $smallest and $smallest < $even_value) {\n \
    \               $index = $i;\n                $smallest = $even_value;\n     \
    \       } else {\n                if (defined $index) {\n                    push\
    \ @result, [$smallest, $index];\n                }\n                $smallest\
    \ = undef;\n                $index = undef;\n            }\n        }\n    }\n\
    \    return @result ? [@result] : [];\n}", '    my(@result);', "    my ($even,\
    \ $idx);\n    foreach $idx (0..$#$arr) {\n        if ($arr->[$idx] % 2 != 0) {\n\
    \            ($even, $idx) =\n                $arr->[$idx], $idx if not defined\
    \ $even;\n        }\n    }\n    if (defined $even) {\n        return $even, $idx;\n\
    \    }\n    return;\n}", "    if ($arr == []) {\n        return [];\n    }\n \
    \   my ($i, $min_index, $min_index2, $smalest_value) = @_;\n    my $index = 0;\n\
    \    my $index;\n    my $min_even = 0;\n    foreach my $val (@$arr) {\n      \
    \  if ($val % 2 == 0) {\n            $min_even = $val;\n        }\n        $index++;\n\
    \    }\n    if ($min_even > 0) {\n        my $index = 0;\n        foreach my $val\
    \ (@$arr) {\n            if ($val % 2 == 0) {\n                if ($val < $min_even)\
    \ {\n                    $min_even = $val;\n                    $min_even_index\
    \ = $index;\n                }\n                $index++;\n            }\n   \
    \     }\n        return [$min_even, $min_even_index];\n    }\n    else {\n   \
    \     return [];\n    }\n}", "    if (scalar @$arr == 0) {\n        return [];\n\
    \    }\n    my $min_value = 0;\n    my $index = 0;\n    for (my $i = 0; $i < scalar\
    \ @$arr; $i++) {\n        my $value = $arr->[$i];\n        if ($value % 2 == 0)\
    \ {\n            if ($value < $min_value) {\n                $min_value = $value;\n\
    \                $index = $i;\n            }\n        }\n    }\n    return ($min_value,\
    \ $index);\n}", "    my @ret=();\n    my $ret=0;\n    while(@$arr) {\n       \
    \ my $node=pop(@$arr);\n        my $even=$node % 2 == 0;\n        if($even) {\n\
    \            $ret++;\n            push(@ret, $node);\n        }\n    }\n    return\
    \ @ret ? @ret : [];\n}", "    return @$arr if @$arr == ();\n    my %hash;\n  \
    \  @$arr = map { $arr->[$_] ? $_ => undef } 0..$#arr;\n    for (@$arr) {\n   \
    \     my ($key, $value) = @_;\n        $hash{$key} = $value if ($hash{$key} ||\
    \ $value % 2);\n    }\n    return unless %hash;\n    my @answer;\n    for my $key\
    \ (keys %hash) {\n        push(@answer, [$hash{$key}, $key]);\n    }\n    @answer;\n\
    }", "    my @res;\n    my %hash;\n    my $min = -1;\n    my $key;\n    my @sorted_arr\
    \ = sort {$a <=> $b} @$arr;\n    foreach my $num (@sorted_arr){\n        next\
    \ if $hash{$num}++;\n        if(($num % 2) == 0){\n            $hash{$num} = 1;\n\
    \            $min = $num;\n        }\n    }\n    if($min == -1){\n        return\
    \ [];\n    }\n    push(@res, $min, $hash{$min});\n    foreach my $num (@sorted_arr){\n\
    \        next if $hash{$num}--;\n        if($hash{$num}){\n            $key =\
    \ $num;\n        }\n    }\n    push(@res, $key, $hash{$key});\n    return @res;\n\
    }", "    my $min = Math::BigInt->new('1');\n    my $index = 0;\n    for (my $i\
    \ = 0; $i < @$arr; $i++) {\n        if ($min > $arr->[$i]) {\n            $min\
    \ = $arr->[$i];\n            $index = $i;\n        }\n    }\n    $arr->[$index];\n\
    }", "    my ($min_value, $min_index, @result) = (0, -1, []);\n    foreach my $i\
    \ (0 .. $#{$arr}) {\n        my $value = $arr->[$i];\n        if ($value % 2 ==\
    \ 0) {\n            if ($value < $min_value) {\n                $min_value = $value;\n\
    \                $min_index = $i;\n            } elsif ($value == $min_value)\
    \ {\n                if ($i < $min_index) {\n                    $min_index =\
    \ $i;\n                }\n            }\n        }\n    }\n    if ($min_value\
    \ > 0) {\n        push @result, $min_value, $min_index;\n    }\n    return @result;\n\
    }", '    my($idx);', "    $arr->[0] = $arr->[0] if $arr->[0] > 0;\n    my $min_val\
    \ = 0;\n    my $max_val = $arr->[0];\n    my $min_idx = -1;\n    my $i;\n    for\
    \ ($i = 1; $i < $arr->[0]; ++$i) {\n        if($arr->[$i] % 2 != 0) {\n      \
    \      if($min_val == 0) {\n                $min_val = $arr->[$i];\n         \
    \       $min_idx = $i;\n            }\n            elsif($arr->[$i] < $min_val)\
    \ {\n                $min_val = $arr->[$i];\n                $min_idx = $i;\n\
    \            }\n        }\n    }\n    return ($min_val, $min_idx);\n}", "    my@nodes\
    \ = ();\n    for(my $i = 0 ; $i < @$arr ; $i++) {\n        push(@nodes, $arr->[$i]);\n\
    \    }\n    for(my $i = 0 ; $i < @$arr ; $i++) {\n        if($arr->[$i] % 2 ==\
    \ 0) {\n            my $smallest_value;\n            for(my $k = 0 ; $k < @$arr\
    \ ; $k++) {\n                if($arr->[$k] % 2 == 0) {\n                    if($smallest_value\
    \ == 0 || $arr->[$k] < $smallest_value) {\n                        $smallest_value\
    \ = $arr->[$k];\n                    }\n                }\n            }\n   \
    \         return ($smallest_value, $i);\n        }\n    }\n    return ();\n}",
  "    if (@$arr == 0) {\n        return [];\n    }\n    my ($i, $min, $pick);\n \
    \   $min = $arr[0];\n    $i = 0;\n    for my $x (@$arr) {\n        last if ($x\
    \ % 2 == 0 && $min > $x);\n        $min = $x;\n        $pick = $i;\n        $i++;\n\
    \    }\n    \n    return [$min, $pick];\n}", '    my @out;', "    my ($smalest_value,\
    \ $smalest_index);\n    my $i = 0;\n    for ($i = 0; $i < $#{$arr}; $i++) {\n\
    \        my $val = $arr->[$i];\n        if ($val % 2 == 0) {\n            if ($smalest_value\
    \ < $val) {\n                $smalest_value = $val;\n                $smalest_index\
    \ = $i;\n            }\n        }\n    }\n    return $smalest_value if $smalest_value;\n\
    \    return [];\n}", '    return @$arr if @$arr <= 0;', "    \n    my $res = 0;\n\
    \    my $i;\n    for my $i (0..($#{$arr}-1)) {\n        if ($arr->[$i] % 2 ==\
    \ 0) {\n            my $j = 0;\n            while ($arr->[$i] % 2 == 0) {\n  \
    \              $arr->[$i] -= $arr->[$j];\n                $j++;\n            }\n\
    \            $arr->[$i] -= $arr->[$j];\n            $res = $i + 1;\n         \
    \   last;\n        }\n    }\n    if ($arr->[0] == 0) {\n        return [];\n \
    \   }\n    elsif ($res == 0) {\n        return [];\n    }\n    else { \n     \
    \   return ($arr->[0], $res);\n    }\n}", "    my($result) = (0, undef);\n   \
    \ while(my($node, $index) = splice(@$arr, 0, 2)) {\n        if ($node & 2) {\n\
    \            $result->[0] = $node;\n            $result->[1] = $index;\n     \
    \   }\n    }\n    return @$result if @$result;\n    return [];\n}", "    my $result\
    \ = [];\n    for (my $i = 0; $i < @$arr; ++$i) {\n        my $smallest_index =\
    \ 0;\n        my $smallest_value = $arr->[$i];\n        for my $j = 1; $j < $i;\
    \ ++$j {\n            if ($arr->[$i] % $arr->[$j] == 0) {\n                $smallest_value\
    \ = $arr->[$j];\n                $smallest_index = $i;\n            }\n      \
    \  }\n        if ($smallest_value % 2 == 0) {\n            $result->[0] = $smallest_value;\n\
    \            $result->[1] = $smallest_index;\n        }\n        else {\n    \
    \        last;\n        }\n    }\n    return $result;\n}", "    my $min = $#{$arr}\
    \ + 1;\n    my $idx;\n    for (my $i = 0; $i < @{$arr}; $i++) {\n        $idx++\
    \ if ($arr->[$i] % 2 != 0);\n        if ($i == $min) {\n            return ($arr->[$i],\
    \ $idx);\n        } elsif ($arr->[$i] < $min) {\n            $min = $i;\n    \
    \    }\n    }\n    return ();\n}", "    my ($value, $index) = @{$arr};\n    return\
    \ []\n        unless @$arr;\n    my $min_even = $value % 2;\n    my $min_even_index\
    \ = 0;\n    for (my $i = 0; $i < @$arr; $i++) {\n        my $v = $arr->[$i];\n\
    \        if ($v % 2 == $min_even) {\n            if ($v < $min_even) {\n     \
    \           $min_even = $v;\n                $min_even_index = $i;\n         \
    \   }\n        }\n    }\n    return $arr->[$min_even_index] if $min_even_index;\n\
    \    return [];\n}", "    my($min, $min_index);\n    my(@results);\n    my $num_even\
    \ = 0;\n    my $num_even_index = 0;\n    for my $val (@$arr) {\n        if ($val\
    \ & 1) {\n            $num_even++;\n        }\n        $num_even_index++;\n  \
    \  }", "    my@arr;\n    my $min_value;\n    my $index;\n    my $is_even;\n  \
    \  for my $node (@$arr) {\n        push @$arr,$node;\n        $min_value=$node;\n\
    \        $index=0;\n        $is_even=1;\n        for my $i (1..$#arr) {\n    \
    \        my $node = $arr[$i];\n            if ($node%2 == 0) {\n             \
    \   $is_even=0;\n                if ($node < $min_value) {\n                 \
    \   $min_value = $node;\n                    $index = $i;\n                }\n\
    \            }\n        }\n    }\n    return @$arr;\n}", "    my @out;\n    my\
    \ $index = 0;\n    my $max_index = 0;\n    my $min_even_value = 0;\n    for my\
    \ $val (@$arr) {\n        if ($val == $min_even_value) {\n            $index =\
    \ $max_index;\n        }\n        else {\n            $index = 0;\n        }\n\
    \        for my $i (0 .. $max_index) {\n            if ($val == ($arr[$i] + $min_even_value))\
    \ {\n                push @out, [$val, $i];\n                last;\n         \
    \   }\n        }\n        $max_index = $index;\n        $min_even_value = $val;\n\
    \    }\n    push @out, $min_even_value\n      if @out;\n    return @out;\n}",
  "    my %h;\n    \n    for (my $i = 0; $i <= $#{$arr}; $i++) {\n        if ($h{$arr[$i]})\
    \ {\n            return [$h{$arr[$i]}[0], $h{$arr[$i]}[1]];\n        }\n     \
    \   $h{$arr[$i]} = $i;\n    }\n    return [];\n}", "    if (@$arr == 0 || scalar(@$arr)\
    \ == 1) {\n\treturn []\n    }\n    my $min = -1;\n    my @res;\n    my $cnt =\
    \ 0;\n    for (my $i = 0; $i < scalar(@$arr); $i++) {\n\tmy ($node, $idx) = @{\
    \ $arr->[$i] };\n\tmy $res = $node;\n\tif ($node % 2 == 0) {\n\t    $min = -1;\n\
    \t    $cnt = 0;\n\t}\n\telse {\n\t    $min = -1;\n\t    $cnt = 0;\n\t}\n\tfor\
    \ (my $j = 0; $j < scalar(@$arr); $j++) {\n\t    if ($arr->[$i] == $arr->[$j])\
    \ {\n\t\t$cnt++;\n\t\tnext;\n\t    }\n\t    elsif ($arr->[$i]->[0] <= $arr->[$j]->[0])\
    \ {\n\t\t$cnt++;\n\t\tif ($cnt > $min) {\n\t\t    $min = $cnt;\n\t\t    $res =\
    \ $arr->[$j];\n\t\t}\n\t\tnext;\n\t    }\n\t    else {\n\t\tif ($cnt > $min) {\n\
    \t\t    $min = $cnt;\n\t\t    $res = $arr->[$j];\n\t\t}\n\t\tnext;\n\t    }\n\t\
    }\n\tpush @$res, [ $node, $idx ];\n    }\n    if ($min < 0) {\n\treturn [];\n\
    \    }\n    return @res;\n}", "    my (@even_values, $index);\n    my $index =\
    \ 0;\n    my $min = -1;\n    foreach my $val (@$arr) {\n        if ($val % 2 ==\
    \ 0) {\n            push @$even_values, $val;\n        }\n        if ($val < $min)\
    \ {\n            $min = $val;\n            $index = $index;\n        }\n     \
    \   $index++;\n    }\n    if (@$even_values > 0) {\n        return ($min, $index);\n\
    \    }\n    return [];\n}", "    return @$arr unless @$arr > 1;\n    my($first,\
    \ $index) = @$arr;\n    $arr[0] = 1;\n    my $min_index = 0;\n    my $min_value\
    \ = $first;\n    my $smalest_value = $first;\n    for my $i (1 .. @$arr - 1) {\n\
    \        my $new_value = $arr[$i] + $first;\n        $arr[$i] = $new_value;\n\
    \        if ($new_value % 2 == 0) {\n            $min_value = $new_value;\n  \
    \          $min_index = $i;\n        } elsif ($new_value < $min_value) {\n   \
    \         $min_value = $new_value;\n            $min_index = $i;\n        }\n\
    \    }\n    if ($min_value != $first) {\n        $arr[0] = $min_value;\n     \
    \   $arr[$min_index] = $min_value;\n    }\n    @$arr;\n}", "    my @result = [];\n\
    \    my $min_value = $arr[0];\n    my $min_idx;\n    my $even_values = 0;\n  \
    \  my $index;\n    for(my $i = 0; $i < @$arr; $i ++) {\n        my $value = $arr->[$i];\n\
    \        if($value & 1) {\n            $even_values ++;\n            if($min_value\
    \ eq $value) {\n                $min_idx = $i;\n            } elsif($value ==\
    \ $min_value && $even_values == 1) {\n                $min_idx = $i;\n       \
    \         $min_value = $value;\n            }\n        } else {\n            if($min_value\
    \ eq $value) {\n                $min_idx = $i;\n                $min_value = $value;\n\
    \            } else {\n                push @result, [ $value, $i ];\n       \
    \     }\n        }\n    }\n    if(@$arr > 0) {\n        push @result, [ $min_value,\
    \ $min_idx ];\n    }\n    return @result;\n}", '    my($ans) = [];', "    my @smalest_values;\n\
    \    my @index;\n    my %seen;\n    my $index = 0;\n    foreach my $i (@$arr)\
    \ {\n        if (!exists $seen{$i}) {\n            $seen{$i} = 1;\n          \
    \  push(@smalest_values, $i);\n            push(@index, $index);\n        } elsif\
    \ ($seen{$i} < $i) {\n            $seen{$i} = $i;\n            $index = $i;\n\
    \        }\n    }\n    return @smalest_values;\n}", "    my @ans;\n    my $index\
    \ = 0;\n    foreach my $node (@{$arr}) {\n        if ($node % 2 == 0) {\n    \
    \        if ($ans[-1] > $node) {\n                if ($ans[-1] == $node) {\n \
    \                   $ans[-1]++;\n                    $index++;\n             \
    \   } else {\n                    $ans[-1] = $node;\n                    $index\
    \ = 1;\n                }\n            } else {\n                $ans[-1] = $node;\n\
    \                $index++;\n            }\n        }\n    }\n    if (@ans == 0)\
    \ {\n        return [];\n    } elsif (@ans == 1) {\n        return [$ans[0], 0];\n\
    \    } else {\n        return [$ans[$index % $#ans], $index];\n    }\n}", "  \
    \  my $size = @$arr;\n    my $min_index = 0;\n    my $min_value = 0;\n    my $max_value\
    \ = 0;\n    my $max_index = 0;\n    foreach my $i (0 .. $size - 1) {\n       \
    \ my $value = $arr->[$i];\n        if ($value % 2 == 0) {\n            my $v =\
    \ $value / 2;\n            if ($v < $min_value) {\n                $min_value\
    \ = $v;\n                $min_index = $i;\n            }\n            if ($v >\
    \ $max_value) {\n                $max_value = $v;\n                $max_index\
    \ = $i;\n            }\n        }\n    }\n    if ($max_value == 0) {\n       \
    \ return [];\n    }\n    my @return_list = ();\n    if ($min_value == $max_value)\
    \ {\n        push @return_list, $max_value;\n        return \\@return_list;\n\
    \    }\n    my $start_index = $max_index;\n    my $end_index = $min_index;\n \
    \   while ($end_index > $start_index) {\n        my $mid_value = ($max_value +\
    \ $min_value) / 2;\n        my $mid_i = $start_index;\n        while ($mid_i <\
    \ ($end_index - 1)) {\n            my $current_value = $arr->[$mid_i];\n     \
    \       if ($current_value == $mid_value) {\n                push @return_list,\
    \ $mid_value;\n                return \\@return_list;\n            }\n       \
    \     $mid_i += 1;\n        }\n        $end_index -= 1;\n        $start_index\
    \ += 1;\n    }\n}", '    my @ret;', "    my @result;\n    my $min_even_value =\
    \ -1;\n    my $min_index = -1;\n    my $i = 0;\n    $min_even_value = -1 if $arr->[0]\
    \ == 0;\n    while (scalar @$arr > 0) {\n        my $value = 0;\n        $i++;\n\
    \        while (scalar @$arr > 0) {\n            if ($arr->[$i] % 2 != 0) {\n\
    \                $value = $arr->[$i];\n                last;\n            }\n\
    \            $arr->[$i] = $arr->[$i-1];\n            $arr->[$i-1] = 0;\n     \
    \       $i++;\n        }\n        if (($value % 2) != 0) {\n            push(@result,\
    \ $value);\n            push(@result, $i);\n        }\n    }\n    return @result\
    \ if @result;\n    return;\n}", "    my @ans;\n    my @hash;\n    my $index;\n\
    \    my $value;\n    foreach my $node (@$arr) {\n        if (! defined $hash{\
    \ $node } ) {\n            $hash{ $node } = 1;\n            $ans[ $node ] = $node;\n\
    \        } else {\n            my $ind = $hash{ $node };\n            $hash{ $node\
    \ } = $ind + 1;\n            $ans[ $node ] = $ind;\n        }\n    }\n    if (\
    \ scalar @ans == 0 ) {\n        return [];\n    }\n    if ( scalar @ans == 1 )\
    \ {\n        return [$ans[0]];\n    }\n    foreach my $k (keys %hash) {\n    \
    \    my $ind = $hash{ $k };\n        if ( $ans[ $k ] == $ind ) {\n           \
    \ delete $hash{ $k };\n            $ans[ $k ] = $ind;\n        } else {\n    \
    \        delete $hash{ $k };\n            $ans[ $k ] = $ind;\n        }\n    }\n\
    \    if ( scalar keys %hash == 0 ) {\n        return [];\n    }\n    if ( scalar\
    \ keys %hash == 1 ) {\n        return [$ans[0]];\n    }\n    my $min = 0;\n  \
    \  my $val = 0;\n    foreach my $k ( keys %hash ) {\n        if ( $min == 0 ||\
    \ $ans[ $k ] > $min ) {\n            $val = $ans[ $k ];\n            $min = $val;\n\
    \        }\n    }\n    return [ $val ];\n}", "    my @res;\n    my($i, $v, @temp);\n\
    \    foreach my $i ( 0 .. $#$arr) {\n        $v = $arr[$i];\n        if ($v &\
    \ 1) {\n            push @temp, $v;\n        }\n    }\n    my $min = pop(@temp);\n\
    \    my $index = 0;\n    foreach my $i (@temp) {\n        if ($i eq $min) {\n\
    \            $index++;\n        }\n    }\n    push @res, $min, $index;\n    return\
    \ @res;\n}", "    my @res;\n    my $min;\n    my $i;", "    $arr = [sort { $a\
    \ <=> $b } @$arr];\n    my($smallest, $index) = 0;\n    my(@result) = [];\n  \
    \  for(my $i = 0; $i < @$arr; ++$i) {\n        for(my $j = 0; $j < @$arr; ++$j)\
    \ {\n            next if $i == $j;\n            if($arr->[$i] % 2 == 0 && $arr->[$j]\
    \ % 2 == 0) {\n                ++$index;\n                $smallest = $arr->[$i]\
    \ if $arr->[$i] < $smallest;\n            }\n        }\n        push(@result,\
    \ [ $arr->[$smallest], $index ]);\n    }\n    return @result;\n}", "    my(@ret)\
    \ = ();\n    my $i = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2\
    \ == 0) {\n            push(@ret, grep(!($i & 1), $i));\n            $i += $node;\n\
    \        }\n    }\n    if (@ret) {\n        my $tmp;\n        foreach my $node\
    \ (@ret) {\n            $tmp = $node->[0];\n        }\n        return $tmp;\n\
    \    }\n    return [];\n}\n</cell>\n<text>\nProblem 4", "    my @result;\n   \
    \ my $i = 0;\n    \n    while(scalar @$arr > 0) {\n        my $node = pop(@$arr);\n\
    \        \n        # Check if this node has any children, if so, find the smallest\n\
    \        # value and the index of that value in the array\n        if(@$arr >\
    \ 0) {\n            # Keep searching until you find one with even number\n   \
    \         while(scalar @$arr > 0) {\n                my $n = pop(@$arr);\n   \
    \             \n                # If we find another node with even number\n \
    \               # Check if this node has smaller value than the previous\n   \
    \             if(($n > $node) && ($i != 0)) {\n                    $result[0]\
    \ = $node;\n                    $result[1] = $i;\n                    return @result;\n\
    \                }\n                \n                $i++;\n            }\n \
    \       }\n        \n        if($node % 2 == 0) {\n            $result[0] = $node;\n\
    \            $result[1] = $i;\n        }\n        \n        $i++;\n    }\n   \
    \ \n    # No even value in the array\n    if(@$arr == 0 && @$arr > 0) {\n    \
    \    $result[0] = pop(@$arr);\n        $result[1] = $i;\n    }\n    \n    @result;\n\
    }", '    my (@result, @min, $index);', "    my @result;\n    my %seen;\n    my\
    \ $index;\n    foreach my $x (@$arr) {\n        if (!$seen{$x}) {\n          \
    \  $seen{$x} = 1;\n            $index = $x;\n        }\n        elsif ($seen{$x}\
    \ and !($x & 1)) {\n            push(@result, $x);\n        }\n    }\n    return\
    \ @result ? [$seen{$index}, $index] : [];\n}", "    my @even_values = ();\n  \
    \  my %hash;\n    for (my $n = 0; $n <= $#{$arr}; $n++) {\n        my $val = $arr->[$n];\n\
    \        if ($val % 2 != 0) {\n            push (@even_values, $val);\n      \
    \      $hash{$val} = $n;\n        }\n    }\n    my($smalest_value);\n    my($smallest_index);\n\
    \    if (scalar(@even_values) > 0) {\n        $smalest_value = $even_values[0];\n\
    \        $smallest_index = $hash{$smalest_value};\n        for (my $i = 1; $i\
    \ <= $#even_values; $i++) {\n            my $val = $even_values[$i];\n       \
    \     if ($smallest_index == 0) {\n                $smalest_value = $val;\n  \
    \              $smallest_index = $i;\n            } elsif ($val < $smalest_value)\
    \ {\n                $smalest_value = $val;\n                $smallest_index =\
    \ $i;\n            }\n        }\n    } else {\n        @even_values = ();\n  \
    \  }\n    return $smallest_index, $smalest_value;\n}", "    my @result;\n    my\
    \ $min;\n    for my $n (@$arr) {\n        if ($n =~ /^0$/ or $min eq \"0\" or\
    \ $min eq $n) { $min = $n; next; }\n        next if $n % 2;\n        push (@result,\
    \ $n);\n    }\n    return @result if @result;\n    return [];\n}", "    my @ret;\n\
    \    my $index;\n    my $value;\n    my $node;\n    my $flag;\n    foreach my\
    \ $n (@$arr) {\n        if ($flag) {\n            $flag = 0;\n            $index\
    \ = $node;\n            $value = $n;\n        } else {\n            if ($n =~\
    \ /^0+(\\d)$/) {\n                $flag = 1;\n                $node = $1;\n  \
    \              $value = $n;\n            } else {\n                push (@ret,\
    \ $value);\n                $value = $n;\n            }\n        }\n    }\n  \
    \  if (@ret > 0) {\n        push (@ret, undef);\n        push (@ret, $index);\n\
    \    }\n    return @ret;\n}", "    @$arr =~ m/\\A\\d+\\Z(?!\\n)/;\n    my($min,\
    \ $pos) = @$arr;\n    return $min if ($min =~ m/\\A(?:[02468])\\Z(?!\\n)/); #\
    \ even\n    my $i;\n    for ($i = 0; $i < @$arr; $i++) {\n        if ($arr[$i]\
    \ =~ m/\\A[02468]\\Z(?!\\n)/) {\n            $min = $arr[$i];\n            $pos\
    \ = $i;\n        }\n    }\n    return $min if ($min =~ m/\\A(?:[02468])\\Z(?!\\\
    n)/); # even\n    $arr[$pos] =~ m/\\A[02468]\\Z(?!\\n)/;\n}", "    if (@$arr ==\
    \ null || @$arr == 0) {\n        return [];\n    }\n    my($smallest_even_value,$smallest_index)\
    \ = (0, 0);\n    my ($i, $j, $smallest_even_value_in_current_branch);\n    for\
    \ (my $i=0; $i<@$arr; $i++) {\n        $smallest_even_value_in_current_branch\
    \ = -1;\n        for ($j=0; $j<$i; $j++) {\n            next if ($arr[$i] & 1);\n\
    \            $smallest_even_value_in_current_branch = 1 + $smallest_even_value_in_current_branch;\n\
    \        }\n        if ($smallest_even_value_in_current_branch < $smallest_even_value)\
    \ {\n            $smallest_even_value = $smallest_even_value_in_current_branch;\n\
    \            $smallest_index = $i;\n        }\n    }\n    if ($smallest_even_value_in_current_branch\
    \ != $smallest_even_value) {\n        $smallest_even_value = $smallest_even_value_in_current_branch;\n\
    \        $smallest_index = $i;\n    }\n    return [ $smallest_even_value, $smallest_index\
    \ ];\n}", '    my $result = [];', "    if (scalar @$arr > 1) {\n        my @nodes;\n\
    \        my $min_val = $arr->[0];\n        my $min_idx = -1;\n        for my $n\
    \ (@$arr) {\n            push (@nodes, $n) unless $n % 2;\n            if ($min_val\
    \ < $n) {\n                $min_val = $n;\n                $min_idx = @nodes;\n\
    \            }\n        }\n        push(@nodes, [$min_val, $min_idx]);\n     \
    \   return @nodes;\n    }\n    return [] if scalar @$arr == 0;\n    return []\
    \ if scalar @$arr < 1;\n    my $min = $arr->[0];\n    my $index = 0;\n    for\
    \ my $n (@$arr) {\n        my $m = $n % 2;\n        if ($m < $min) {\n       \
    \     $min = $m;\n            $index = $n;\n        }\n    }\n    return [$min,\
    \ $index];\n}", "    my;\n    my ($node_value, $node_index) = ();", "    my @out;\n\
    \    my $min = 0;\n    my $cur;\n    foreach my $n (@$arr) {\n        $cur = $min\
    \ if $n % 2;\n        $min = $cur if $min == 0 || $cur < $min;\n    }\n    return\
    \ ($min > 0 ? [$min, $min] : []);\n}", '    my @res;', "    my($sorted_arr) =\
    \ sort {$a<=>$b} @$arr;\n    my($smallest) = $sorted_arr[0] if @$arr;\n    my($min_index)\
    \ = 0;\n    for my $i (0 .. @$arr-1) { \n        if ($sorted_arr[$i] % 2 == 0)\
    \ {\n            $smallest = $sorted_arr[$i];\n            $min_index = $i;\n\
    \        }\n    }\n    return $smallest if $smallest;\n    return [] unless @$arr;\n\
    \    return $min_index if $smallest;\n    return $min_index;\n}", "    my $index;\n\
    \    my $smalest_value;\n    foreach my $key (sort {$a <=> $b} keys %{$arr}) {\n\
    \        if ($key % 2) {\n            $smalest_value = $key if !defined $smalest_value\
    \ || ($smalest_value && $key < $smalest_value);\n            $index = $key - 1;\n\
    \        }\n    }\n    return @$arr, $index if defined $smalest_value;\n    return;\n\
    }", "    my @result;\n    foreach my $node (@$arr) {\n        push @result, $node\
    \ if $node % 2 == 0;\n    }\n    return @result if @result;\n    return;\n}",
  "    $_ = [map { $_ - 1 } @$arr];\n    my (@result) = (0, 0);\n    for my $i (0\
    \ .. $#arr) {\n        my $min_even = 0;\n        for my $j ($i + 1 .. $#arr)\
    \ {\n            if ($arr[$i] % 2 != 0 && $arr[$j] % 2 == 0) {\n             \
    \   $min_even = $i;\n                last;\n            }\n        }\n       \
    \ push (@result, $arr[$min_even], $min_even);\n    }\n    return @result;\n}\n\
    </code>\n<|/ a tags=sorting,arrays,algorithm,perl dscore=1 |>\n<| c |>\nThis looks\
    \ like a great algorithm, but I think it would be better if the `if ($arr[$i]\
    \ % 2 != 0 && $arr[$j] % 2 == 0) {` check is made only once and $min_even is initialized\
    \ with the first node index.\n<|/ c |>\n<| a |>\n<code>", "    my($min) = 100;\n\
    \    my(@result) = ();\n    foreach(@$arr) {\n        if($min > $_ & 0x1) {\n\
    \            $min = $_;\n        }\n    }\n    push, [ $min, $_ - $min ];\n}\n\
    </cell>\n<cell>", "    my @ret;\n    my $min_value = -1;\n    my $min_pos = -1;\n\
    \    my $i = 0;\n    for my $n (@$arr) {\n        if($n % 2 eq 0) {\n        \
    \    $min_value = $n;\n            $min_pos = $i;\n        }\n        elsif($min_value\
    \ != -1) {\n            if($min_value < $n) {\n                @ret = ($min_value,\
    \ $min_pos);\n                $min_value = -1;\n                $min_pos = -1;\n\
    \            }\n        }\n        $i++;\n    }\n    if(@ret > 0) {\n        return\
    \ @ret;\n    }\n    return [];\n}", "    if($arr->[0] == 0){\n        return ([$arr->[1],\
    \ $arr->[1]]);\n    }\n    my($sorted_arr) = sort {$a <=> $b} @$arr;\n    my ($key,\
    \ $index) = ($sorted_arr[0], 0);\n    for(my $i = 1; $i < $sorted_arr->length;\
    \ ++$i){\n        if($sorted_arr[$i] % 2 == 0){\n            $key = $sorted_arr[$i];\n\
    \            $index = $i;\n        }\n    }\n    return ([$key, $index]);\n}\n\
    </cell>\n<text>\n7. Minimum Depth", "    my %hash;\n    my $min_even_value = 0;\n\
    \    my $min_index = 0;\n    my $min_val = 0;", "    my @res;\n    my $min_value;\n\
    \    my $min_value_index = 0;\n    my $index = 0;\n    my $value = 0;", "    my\
    \ $min_even_value = shift(@$arr);\n    my ($min_even_value_index) = ();\n    for\
    \ (my $i = 0; $i < scalar(@$arr); ++$i) {\n        my $value = $arr->[$i];\n \
    \       if ($value % 2 == 0) {\n            if ($min_even_value < $value) {\n\
    \                $min_even_value = $value;\n                $min_even_value_index\
    \ = $i;\n            }\n        }\n    }\n    return @$arr[$min_even_value_index..$#arr];\n\
    }", "    return []\n        if $arr->[0] < 0;\n    my $i = 0;\n    my $smallest\
    \ = $arr->[0];\n    for my $n (@$arr) {\n        return [ $smallest, $i ] if $n\
    \ % 2 == 0 && ($n//2)*2 > $smallest;\n        $smallest = $n if ($smallest < $n);\n\
    \        $i++;\n    }\n    return [ $smallest, $i ];\n}", "    if(scalar @$arr\
    \ == 0){return ();}\n    my $i = 1;\n    my $index = 0;\n    my $max = 0;\n  \
    \  my $res;\n    for($i = 1; $i < scalar @$arr; $i++){\n        if($arr[$i] %\
    \ 2 == 0){\n            if($arr[$i] > $arr[$max]){\n                $max = $i;\n\
    \            }\n        }\n    }\n    $res = $arr[$max];\n    if($max != 0){\n\
    \        if($arr[($max - 1)] % 2 != 0){\n            $index = ($max - 1);\n  \
    \      }else{\n            $index = $max;\n        }\n    }\n    return([$res,\
    \ $index]);\n}\n</code>\n<|/ a tags=algorithm,java,recursion,binary-tree |>\n\
    <| a dscore=0 |>\nI got two solutions:\n1.\n<code>\nclass Solution {\n    public\
    \ List<Integer> treeToDoublingPath(TreeNode root) {\n        List<Integer> result\
    \ = new ArrayList<>();\n        doublePath(root, result, 0);\n        return result;\n\
    \    }", "    my @index;\n    my $index;", "    my $val = $arr->[0];\n    my @arr;\n\
    \    my @hash;\n    my $temp = $val;\n    my $index;", '    my($i, $j, @result);',
  "    my $sum = 0;\n    my @even;\n    my $min_value;\n    my $index;", "    $arr\
    \ = [@$arr];\n    my $len = scalar @$arr;\n    my ($node, $index);\n    my $count\
    \ = 0;\n    my $temp;", "    my @result;\n    my $min_val = undef;\n    my $min_idx\
    \ = undef;\n    my $i = 0;\n    for my $v (@$arr) {\n        if ($v & 1) {\n \
    \           if (defined $min_val) {\n                push(@result, $min_val);\n\
    \                push(@result, $min_idx);\n            }\n            $min_val\
    \ = $v;\n            $min_idx = $i;\n        }\n        ++$i;\n    }\n    if (defined\
    \ $min_val) {\n        push(@result, $min_val);\n        push(@result, $min_idx);\n\
    \    }\n    return @result;\n}", "    return if (@$arr == []);\n    @$arr = map\
    \ {\n        if ($_ % 2 != 0) {\n            $_;\n        } else {\n         \
    \   $_ + 1;\n        }\n    } @$arr;\n    my $smallest = @$arr;\n    my $index\
    \ = 0;\n    $smallest = @$arr[$smallest] if $smallest == 0;\n    $index = 0;\n\
    \    foreach my $val (@$arr) {\n        if ($val == $smallest) {\n           \
    \ $index++;\n        }\n    }\n    return if ($index == 0);\n    return [$smallest,\
    \ $index];\n}", "    my @result;\n    my ($i, $min) = @$arr;\n    for($i = 0;\
    \ $i < @$arr; $i++) {\n        $min ^= $arr[$i];\n    }\n    for($i = 0; $i <\
    \ @$arr; $i++) {\n        if($arr[$i] == $min) {\n            push @result, $i;\n\
    \        }\n    }\n    return $result;\n}", "    my($result);\n    for (my $i\
    \ = 0; $i < @$arr; $i++) {\n        if ($arr[$i] % 2 != 0 && $arr[$i] !~ /^\\\
    d+$/ && $arr[$i] !~ /^\\d+\\.\\d+$/ && $arr[$i] !~ /^\\d+\\.\\d+\\.\\d+$/) {\n\
    \            $result = $i;\n            last if $arr[$i] < $arr[$result];\n  \
    \      }\n    }\n    if ($result > 0) {\n        return [ @$arr, $result ];\n\
    \    } else {\n        return [];\n    }\n}", "    my $max_value = 0;\n    my\
    \ $max_index = 0;", "    my @res;\n    my $min_even_val = 0;\n    my $min_even_node\
    \ = 0;\n    my $index;", "    $arr = [sort {$a <=> $b} @$arr] if @$arr;\n    my($max_val,\
    \ $max_i) = (0, -1);\n    for my $i (0..@$arr-1) {\n        my($val, $idx) = @$arr[$i,\
    \ 0];\n        $max_val = $val if $val < $max_val;\n        $max_i = $i if $val\
    \ == $max_val;\n    }\n    return $max_val unless @$arr;\n    my $val = $arr[$max_i];\n\
    \    my(@min_vals) = map {$_->[0] } @$arr;\n    my $min_val = $min_vals[$max_i];\n\
    \    my($idx, @ret_arr) = ($min_val, $arr);\n    for (my $i = $max_i+1 ; $i <\
    \ @$arr; $i++) {\n        my($val, $idx) = @$arr[$i, 0];\n        $idx++ if $val\
    \ == $min_val;\n        push @ret_arr, $val, $idx if $val == $min_val;\n    }\n\
    \    return @ret_arr;\n}", "    $arr[0] = $arr[0] / 2 if $arr[0] & 1;\n    return\
    \ $arr;\n}\n</cell>\n<text>\nQ14. Given a string of lowercase letters, return\
    \ the number of vowels present in the string.", "    $arr = [ @$arr ];\n    my(@index)\
    \ = ();\n    my($i, $j, @ret) = ();\n    for ($i = 0; $i < @$arr; ++$i) {\n  \
    \      for ($j = 0; $j < @index; ++$j) {\n            if ($arr[$i] >= $arr[$index[$j]])\
    \ {\n                ++$index[$j];\n            }\n        }\n        if ($arr[$i]\
    \ % 2 == 0 && $index[0] <= $i) {\n            @ret[@index[0..$i-$index[0]]] =\
    \ [ $arr[$i], $i-@index[0] ];\n        }\n        ++$index[0];\n    }\n    return\
    \ @ret if @ret && @ret > 1;\n    return [];\n}", "    return [] if $arr->is_empty;\n\
    \    my($min, $min_idx, $max_idx) = ();\n    my $smalest_value;", "    my @mins\
    \ = ();\n    my @res = ();\n    for (my $i = 0; $i < $#{$arr}; $i++) {\n     \
    \   my $val = $arr->[$i];\n        next unless $val ne 0;\n        my $idx = $i;\n\
    \        for (my $j = 0; $j < $#{$arr} - $i; $j++) {\n            next unless\
    \ $arr->[$j] eq $val;\n            my $val2 = $arr->[$j + 1];\n            if\
    \ ($val2 eq $val and $j ne $i) {\n                $idx = $j;\n               \
    \ $val = $val2;\n            }\n        }\n        push @mins, [ $val, $idx ];\n\
    \        push @res, [ $val, $idx ];\n    }\n    return @mins if @mins;\n    return\
    \ @res if @res;\n    return [];\n}", "    my;\n    my $len = @$arr;\n    for(my\
    \ $i = 0; $i < $len; $i++){\n        push(@m, $arr->[$i] if(($arr->[$i] % 2) ==\
    \ 0);\n    }\n    my $min = 0;\n    my $found_even = undef;\n    for(my $i = 0;\
    \ $i < $len; $i++){\n        my $e = $arr->[$i] % 2;\n        if( $e == 0){\n\
    \            $found_even = $e;\n            $min = $i;\n            last;\n  \
    \      }\n    }\n    return @m if ( defined $found_even );\n    return ();\n}",
  "    my @res = ();\n    my $min = undef;\n    my $min_idx;\n    my $idx;\n    foreach\
    \ my $node (@{$arr}) {\n        if (defined $min and $node == $min) {\n      \
    \      push @res, @{$min}, $idx;\n            next;\n        }\n        if ($node\
    \ % 2 == 0) {\n            $min_idx = $idx;\n            $min = $node;\n     \
    \   }\n        $idx++;\n    }\n    return @res if $min_idx;\n    return ();\n\
    }\n</cell>\n<cell>\n%matplotlib inline\n</cell>\n<cell>\nfrom pycqed.measurement.stats\
    \ import plot_mean, plot_hist\nimport matplotlib.pyplot as plt\nimport numpy as\
    \ np", "    my @res;\n    for (my $idx=0; $idx < @$arr; $idx++) {\n        my\
    \ $cur = $arr->[$idx];\n        for (my $i=0; $i<@$cur; $i++) {\n            my\
    \ $ev = uc($cur->[$i]);\n            $cur = $ev if $ev % 2 eq 0;\n        }\n\
    \        $cur = \"even-value\" if ($cur % 2);\n        push(@res, @{ $cur }) if\
    \ defined $cur;\n    }\n    return \\@res;\n}", "    my $result;\n    my $index\
    \ = 0;\n    my $min = undef;\n    for (my $i = 0; $i <= $#{$arr}; $i++) {\n  \
    \      my $val = ${$arr}[$i];\n        if ($val & 1) {\n            if (!$min)\
    \ {\n                $min = $i;\n            } elsif ($i != $min) {\n        \
    \        $min = $i;\n            }\n        }\n    }\n    if ($min) {\n      \
    \  push @{$result}, [$arr->[$min], $index];\n    }\n    return $result;\n}", " \
    \   my @res;\n    my $value;", "    my @res;\n    my $smalest;\n    my $smalest_index;\n\
    \    my $i;\n    for(my $n = 0; $n < $#{$arr}; $n++) {\n        if($n % 2 == 0)\
    \ {\n            if($smalest == 0) {\n                $smalest = $arr->[$n];\n\
    \                $smalest_index = $n;\n            }\n            elsif($arr->[$n]\
    \ < $smalest) {\n                $smalest = $arr->[$n];\n                $smalest_index\
    \ = $n;\n            }\n        }\n    }\n    if(@{$arr}) {\n        if($smalest\
    \ == 0) {\n            push(@res, []);\n        }\n        else {\n          \
    \  push(@res, [\"$smalest\", $smalest_index]);\n        }\n    }\n    return @res;\n\
    }", "    my @result;\n    my $min = 0;\n    my $smalest_value;\n    my $smalest_index;\n\
    \    for (my $i = 0; $i < @$arr; ++$i) {\n        $smalest_value = $arr->[$i];\n\
    \        $smalest_index = $i;\n        next unless $smalest_value % 2 eq 0;\n\
    \        for (my $j = $i; $j < @$arr; ++$j) {\n            if ($arr->[$j] % 2\
    \ eq 0 && $smalest_value < $arr->[$j]) {\n                $smalest_value = $arr->[$j];\n\
    \                $smalest_index = $j;\n                next;\n            }\n\
    \        }\n        @result = ($smalest_value, $smalest_index);\n    }\n    wantarray\
    \ ? @result : \\@result;\n}", "    my ($sum, $min, $min_index);\n    foreach my\
    \ $value (@$arr) {\n        if (!($value % 2)) {\n            $sum += $value;\n\
    \        }\n        if ($sum > $min) {\n            $min_index = $#{$arr}+2;\n\
    \            $min = $sum;\n        } elsif ($sum == $min && $value % 2 == 0) {\n\
    \            $min_index += ($value / 2);\n        }\n    }\n    return $min eq\
    \ '0' ? [] : [ $min, $min_index ];\n}", "    my ($index, $min) = ();\n    foreach\
    \ my $node (@$arr) {\n        if ( ! $node ) {\n            $min = $index; return\
    \ [];\n        }\n        if ( $node % 2 == 0 ) {\n            if ( $min eq 0\
    \ ) {\n                $min = $index;\n            } elsif ( $min eq $index )\
    \ {\n                $min++;\n            }\n        }\n    }\n    return [ $min,\
    \ $min ];\n}", "    my $index = 0;\n    my $max;\n    for my $elt ($arr) {\n \
    \       next unless $elt =~ /^\\d+$/;\n        my $val = $elt % 2;\n        if\
    \ ($val > 0) {\n            $max = $val;\n            $index = $elt;\n       \
    \ }\n    }\n    return $max unless $max;\n    return [ $max, $index ];\n}", '    my
    @result;', "    my @ret;\n    $arr = [sort{$a <=> $b}@$arr] if @$arr;\n    foreach\
    \ my $node (@$arr) {\n        if ($node%2 == 0) {\n            push(@ret, @$arr,\
    \ $node);\n        }\n    }\n    return @ret if @ret;\n    return [];\n}", " \
    \   my $res = 0;\n    my $min_val;\n    my $min_pos = 0;\n    for (my $i = 0;\
    \ i < $#{$arr}; $i++) {\n        if ($arr->[$i] & 1) {\n            $min_val =\
    \ $arr->[$i];\n            $min_pos = $i;\n        }\n    }\n    if ($min_val\
    \ == 0) {\n        return ();\n    }\n    return @{$arr->[$min_pos]}, $min_pos;\n\
    }", "    if ($arr->[0] != 0) {\n        @min = map {\n            if ($arr->[$_]\
    \ == 0) {\n                ($arr->[$_], $_)\n            } elsif ($arr->[$_] %\
    \ 2 != 0) {\n                ($arr->[$_], $_)\n            } else {\n        \
    \        (undef, $_)\n            }\n        } 0 .. $#$arr;\n        @min;\n \
    \   } else {\n        []\n    }\n}", "    if (@$arr == 0){\n        return [];\n\
    \    }\n    my $min = 0;\n    my $index = undef;\n    for (my $i = 0; $i < @$arr;\
    \ $i++) {\n        if ($arr[$i] % 2 == 0) {\n            $min = $arr[$i];\n  \
    \          $index = $i;\n        }\n    }\n    if (defined $min) {\n        push\
    \ @$arr, $$min;\n        return [$$min, $index];\n    } else {\n        return\
    \ [];\n    }\n}", "    my $even = 0;\n    my $index = 0;\n    my $smalest_value\
    \ = undef;\n    my $max_index = undef;\n    my $min_value = $arr->[0];\n    foreach\
    \ my $node (@$arr) {\n        if ( $node % 2 == 0 ) {\n            $even += $node;\n\
    \        }\n        if ( $min_value > $node ) {\n            $smalest_value =\
    \ $node;\n            $max_index = $index;\n            $min_value = $node;\n\
    \        }\n        $index++;\n    }\n    return $smalest_value ? [$smalest_value,\
    \ $max_index] : [];\n}", "    my @res;\n    my ($node, $min_index, $val);\n  \
    \  foreach $node (@$arr) {\n        $min_index = 0;\n        $val = $node % 2\
    \ if $node > 0;\n        if ($val == 0) {\n            $min_index = $node > $min_index\
    \ ? $node - $min_index : $min_index;\n        } else {\n            $min_index\
    \ = $val < $min_index ? $val : $min_index;\n        }\n        push(@res, $val,\
    \ $min_index);\n    }\n    return @res;\n}", "    my $len = @$arr;\n    my $min\
    \ = 0;\n    my @min = ();\n    my $index = 0;\n    for(my $i = 0; $i < $len; $i++)\
    \ {\n        if($arr[$i] % 2 != 0) {\n            $min = $i;\n            $min[$i]\
    \ = $arr[$i];\n            $index = $i;\n        }\n    }\n    if($min == 0) {\n\
    \        return ();\n    }\n    for(my $i = 1; $i < $len; $i++) {\n        if($min[$i]\
    \ == $min[$i - 1]) {\n            $index = $i;\n        }\n    }\n    if($min[$index]\
    \ == 0) {\n        return ();\n    }\n    my @even = ();\n    for(my $i = 0; $i\
    \ < $index; $i++) {\n        push @even, $min[$i];\n    }\n    push @even, $min[$index];\n\
    \    return @even;\n}", "    if ($arr == []) {\n        return [];\n    }\n  \
    \  my $smalest_value;\n    my $smalest_index;\n    my $index;\n    my @smalest_nodes;\n\
    \    my %smalest_nodes;\n    foreach my $v (@$arr) {\n        if (!$smalest_nodes{$v})\
    \ {\n            $smalest_nodes{$v} = $v;\n        }\n        if ($smalest_nodes{$v}\
    \ eq $v) {\n            $smalest_value = $v;\n            $smalest_index = $index;\n\
    \        }\n        if ($smalest_nodes{$v} < $v) {\n            $smalest_value\
    \ = $smalest_nodes{$v};\n            $smalest_index = $index;\n        }\n   \
    \     if ($smalest_nodes{$v} < $v) {\n            $smalest_value = $v;\n     \
    \       $smalest_index = $index;\n        }\n        push @smalest_nodes, $smalest_value;\n\
    \        $smalest_nodes{$v} = $v;\n        $index++;\n    }\n    return [$smalest_value,\
    \ $smalest_index];\n}", "    if(@$arr == 0) {\n        return [];\n    }\n   \
    \ my(@min) = ();\n    for(my $i = 0; $i < @$arr; $i++) {\n        if($arr[$i]\
    \ % 2 == 0) {\n            push(@min,$arr[$i]);\n        }\n    }\n    if(scalar(@min)\
    \ > 1) {\n        my $index = -1;\n        for(my $i = 0; $i < scalar(@min); $i++)\
    \ {\n            if($min[$i] % 2 == 0) {\n                my $val = $min[$i];\n\
    \                if($index == -1 || $val < $min[$index]) {\n                 \
    \   $index = $i;\n                }\n            }\n        }\n        return\
    \ [ $min[$index], $index ];\n    }\n    return [];\n}", "    return @$arr if $arr->is_empty;\n\
    \    # Build up a hash of even values to the nodes with that value.\n    my %even;\n\
    \    for my $v (@$arr) {\n        return [] unless $v & 1;\n        $even{$v}\
    \ = $_ if !exists $even{$v};\n    }\n    # Iterate through the hash looking for\
    \ an even value and returning the node\n    # with the smallest index.\n    my\
    \ @results;\n    foreach my $v (keys %even) {\n        my $index = $#{$arr} -\
    \ $#{$arr + 1} - 1;\n        if ($even{$v} == $v) {\n            push (@results,\
    \ $v, $index);\n        }\n    }\n    return @results;\n}", "    my $min_val =\
    \ 0;\n    my $min_idx = 0;\n    for (my $i = 0; $i < @$arr; $i++) {\n        my\
    \ $v = $arr->[$i];\n        if ($v & 1) {\n            if ($v < $min_val) {\n\
    \                $min_val = $v;\n                $min_idx = $i;\n            }\n\
    \        }\n    }\n    return @$arr[$min_idx];\n}", "    my($node, @res, $temp,\
    \ $i, @smallest, @found);\n    foreach $node (@$arr) {\n        $found = 0;\n\
    \        @smallest = ();\n        foreach $temp (@smallest) {\n            if\
    \ ($node == $temp) {\n                $found = 1;\n                break;\n  \
    \          }\n        }\n        if (!$found) {\n            push @smallest, $node;\n\
    \        }\n    }\n    if (@smallest) {\n        foreach $node (@smallest) {\n\
    \            if ($node % 2 == 0) {\n                $node = $smallest[$i];\n \
    \           }\n            push(@res, $node, \"index\", $i);\n        }\n    }\n\
    \    return @res;\n}\n</code>\n<|/ a tags=algorithm,arrays,perl |>\n<| a tags=algorithm,arrays,perl\
    \ |>\n<code>", '    my @result;', "    my @result = ();\n    my $index = 0;\n\
    \    my $min_value = $arr[0];\n    my $min_value_index = 0;", "    my @result;\n\
    \    for(my $i = 0 ; $i < @$arr ; $i++) {\n        if($arr->[$i] % 2 == 0) {\n\
    \            push(@result, $arr->[$i], $i);\n        }\n    }\n    my $result\
    \ = pop(@result);\n    return @result ? [@result] : [];\n}", "    $arr = [@$arr[0..($#arr\
    \ - 1)]];\n    $_->[0] !~ /[02468]/ or die \"Invalid integer: $_\";\n    my $min_index\
    \ = 0;\n    my $min_value = 0;\n    my $i = 1;\n    my $j = 0;\n    while($i <=\
    \ $#arr) {\n        if ($arr[$i] & 1 != 0) {\n            $min_value = $arr[$i];\n\
    \            $min_index = $i;\n        }\n        $i++;\n    }\n    if ($min_value\
    \ != 0) {\n        return [$min_value, $min_index];\n    }\n    if ($min_index\
    \ == 0) {\n        return [];\n    }\n    my $result = $arr[$min_index];\n   \
    \ for (my $i = $min_index + 1;$i <= $#arr;$i++) {\n        if ($arr[$i] & 1 !=\
    \ 0) {\n            $result = $arr[$i];\n            $min_index = $i;\n      \
    \  }\n    }\n    return [ $result, $min_index ];\n}", "    my @res;\n    my %seen;\n\
    \    my ($index) = -1;\n    foreach my $n (@$arr) {\n        if (!defined($seen{$n}))\
    \ {\n            $seen{$n} = 1;\n            push(@res, [$n, $index]);\n     \
    \   }\n        elsif ($seen{$n} == 1 && $n % 2 == 0) {\n            $seen{$n}\
    \ = 2;\n            push(@res, [$n, $index]);\n        }\n        elsif ($seen{$n}\
    \ == 2 && $n < $seen{$n - 1}) {\n            $seen{$n} = 1;\n            $index\
    \ = $n;\n        }\n    }\n    return @res if @res;\n    return [];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
