name: HumanEval_11_string_xor
language: pl
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor(\"\
  010\", \"110\")\n# \"100\"\nsub string_xor {\n    my($a, $b) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n\
  \        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    $a ^= $b; $b = ($b - $b) & 1; $a ^= $b; $b = ($b - $b) & 1; $a\
    \ ^= $b;\n    return ($a + $b);\n}", "    my $result;\n    for ($result, $a) =~\
    \ s/(0+|1+)/$1/g;\n    for ($result, \"$b\") =~ s/(0+|1+)/$1/g;\n    return $result;\n\
    }", "    my $result;\n    my $carry = substr($b, -2, 1);\n    for my $bit (0 ..\
    \ length($a) - 1) {\n        $result .= substr((($a eq '0') ^ ($b eq '0')) xor\
    \ $bit, -2);\n        $carry = substr($b, -2, 1);\n    }\n    $result .= $carry\
    \ xor substr($b, -2, 1);\n    $result =~ s/^(.)\\0/$1/g;\n    return $result;\n\
    }", "    $a ^= $b;\n    return $a ^ $b;\n}", "    my @result;\n    my $i = 0;\n\
    \    while ($i < length($a)) {\n        my $x = (substr($a, $i, 1) ^ substr($b,\
    \ $i, 1));\n        if ($x ne \"0\") {\n            $result[$i] = $x;\n      \
    \  }\n        $i++;\n    }\n    return join('', @result);\n}", "    my $c = '';\n\
    \    my $i = 0;", "    $a =~ s/(.)/oct($1)/eg;\n    $b =~ s/(.)/oct($1)/eg;\n\
    \    $a ^ $b;\n}\n</code>\n<|/ a tags=perl,perl-data-structures dscore=1 |>\n\
    <| c |>\nIt appears that this was the solution that finally worked for me. I would\
    \ vote it up but I don't have enough rep yet. :-/\n<|/ c |>\n<| a |>\nHere is\
    \ a short and easy-to-read solution that I wrote earlier on stackoverflow that\
    \ uses recursion:\n<code>", "    return $a ^ $b unless $a eq $b;\n    $a ^= $b;\
    \ $b ^= $a; $a ^= $b;\n    return $a ^ $b;\n}", "    return \"\" if length($a)\
    \ != length($b);\n    my $result = 0;\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $result ^= ord(substr($a, $i, 1));\n        $result ^= ord(substr($b,\
    \ $i, 1));\n    }\n    return chr(ord($a) ^ $result);\n}", "    $a =~ s/0//g;\n\
    \    $b =~ s/0//g;\n    return $a ^ $b;\n}", "    my $result = '';\n    foreach\
    \ my $c (split(//, $a), split(//, $b)) {\n        $result .= $c ^ $c;\n    }\n\
    \    return $result;\n}", "    return \"$a XOR $b\" if ($a =~ /^(0+)$/);\n   \
    \ return \"$a ^ $b\" if ($b =~ /^(0+)$/);\n    return \"$a XOR $b\" if ($a =~\
    \ /^(0+)(0+)$/);\n    return \"$a ^ $b\" if ($b =~ /^(0+)(0+)$/);\n    return\
    \ \"$a XOR $b\" if ($a =~ /^(0+)(0+)(0+)$/);\n    return \"$a ^ $b\" if ($b =~\
    \ /^(0+)(0+)(0+)$/);\n    return \"$a XOR $b\" if ($a =~ /^(0+)(0+)(0+)(0+)$/);\n\
    \    return \"$a ^ $b\" if ($b =~ /^(0+)(0+)(0+)(0+)$/);\n    return \"$a XOR\
    \ $b\" if ($a =~ /^(0+)(0+)(0+)(0+)(0+)$/);\n    return \"$a ^ $b\" if ($b =~\
    \ /^(0+)(0+)(0+)(0+)(0+)$/);\n    return \"$a XOR $b\" if ($a =~ /^(0+)(0+)(0+)(0+)(0+)(0+)$/);\n\
    \    return \"$a ^ $b\" if ($b =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n    return\
    \ \"$a XOR $b\" if ($a =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n    return \"\
    $a ^ $b\" if ($b =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n    return \"\
    $a XOR $b\" if ($a =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n    return\
    \ \"$a ^ $b\" if ($b =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n \
    \   return \"$a XOR $b\" if ($a =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n\
    \    return \"$a ^ $b\" if ($b =~ /^(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)(0+)$/);\n",
  "    my $res = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $res\
    \ .= $a->[$i] ^ $b->[$i];\n    }\n    return $res;\n}", "    $a ^= $b;\n    $a\
    \ =~ s/^0+(?!$)/0/g;\n    $a =~ s/^1+(?!$)/1/g;\n    return $a;\n}", "    return\
    \ $a ^ $b;\n}", "    my($out) =  \"\";\n    \n    # XOR is reversible so take\
    \ one bit at a time and then XOR them\n    # together.\n    my $xor =  0;\n  \
    \  while (length($a) > length($b)) {\n        $xor ^= $a{substr($b, 0, 1)};\n\
    \        $b{substr($a, 0, 1)} = $xor;\n    }\n    \n    while ($a ne $b) {\n \
    \       $xor ^= $a{substr($b, 0, 1)};\n        $b{substr($a, 0, 1)} = $xor;\n\
    \    }\n    \n    return $out;\n}", "    return $a ^ $b xor $a ^ $b;\n}", "  \
    \  return unpack(\"C*\", $a ^ $b);\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ tags=perl,algorithm,python,cryptography |>\nThis answer doesn't really answer\
    \ the question, but does provide a workaround to using XOR for strings of arbitrary\
    \ length and contents, at least in Perl. \nAs perl strings are arrays of characters,\
    \ using XOR on strings works as one would expect. For example, this code will\
    \ work correctly for strings of arbitrary length:\n<code>\nmy $a = \"a\";\nmy\
    \ $b = \"a\";\nmy $c = $a ^ $b;\nprint $c . \"\\n\"; # prints 'a'\n</code>\nand\
    \ for strings of arbitrary length:\n<code>\nmy $a = \"abcdef\";\nmy $b = \"acdef\"\
    ;\nmy $c = $a ^ $b;\nprint $c . \"\\n\"; # prints 'acdef'\n</code>\nSo you can\
    \ use this to perform XOR for any string length using Perl strings as arrays of\
    \ characters and XOR on the array. \nThe downside to this approach is that it\
    \ works on arbitrary length strings and not just strings of length 1. For strings\
    \ of arbitrary length the result will be a string, but if the input strings are\
    \ of length 1 then XOR is performed on the individual characters of the strings.\
    \ This results in the loss of information.\n<|/ a |>\n<| a |>\nIt might be worthwhile\
    \ to note that the reason python doesn't have the same behavior is because python\
    \ is dynamically typed and perl is statically typed.\nIn Perl, the strings are\
    \ stored as arrays of char and are immutable.\n<code>\nmy $str = \"a\";\nsay $str;\
    \ # prints nothing\n$str++;\nsay $str; # prints a as expected since strings are\
    \ immutable\n</code>\nIn python, strings are immutable. The interpreter stores\
    \ the string as a char[] internally. \n<code>\nstr1 = \"a\"\nprint str1 # prints\
    \ nothing\nstr1 = \"a\"\nprint str1 # prints a\n</code>\n<|/ a tags=perl,algorithm,python,cryptography\
    \ dscore=3 |>\n<| c |>\nI wouldn't call it dynamically typed. It's dynamic typing\
    \ that is being done here. Python is dynamically typed, so you're just playing\
    \ with terminology. It's a very different situation from the one you presented,\
    \ which is more about static vs. dynamic typing.\n<|/ c |>\n<| c |>\nI agree that\
    \ Perl is dynamically typed, however, the semantics of statically vs dynamically\
    \ typed are very different. It took me a little ", '    my $result = "";', " \
    \   my $res = '';\n    my $i;\n    for ($i = 0; $i < length($a); $i++) {\n   \
    \     $res .= substr($a, $i, 1) ^ $substr($b, $i, 1);\n    }\n    return $res;\n\
    }", "    my $out = \"\";\n    for my $i (0..($#{$a} + 1)) {\n        my $c = $a->[$i]\
    \ ^ $b->[$i];\n        $out .= \"$c\";\n    }\n    return $out;\n}", "    my($s,\
    \ $b);\n    $b = \"0\" x length($b);\n    for my $x (0..(length($a) - length($b)))\
    \ {\n        $s .= $a[0..$x] ^ $b[0..$x];\n    }\n    return $s;\n}", "    return\
    \ sprintf(\"%x\", 0xffffffff & ( pack(\"U*\", $a, $b ) ^ (pack(\"U*\", $b, $a)\
    \ & 0xffffffff)));\n}", "    $a ^= $b;\n    my @d = map { ( $a & $_ ) ? 1 : 0\
    \ } ( $a .. $_ );\n    join( '', @d );\n}", "    $a =~ s/^0/\\!0/;\n    $b =~\
    \ s/^0/\\!0/;\n    $a =~ s/1/\\!1/;\n    $b =~ s/1/\\!1/;\n    return $a ^ $b;\n\
    }", "    $a ^= $b; return $a ^ $b;\n}", "    my($c, $d) = ();\n    $c = \"\";\n\
    \    $d = 0;\n    foreach my $i ($a, $b) {\n        if($i eq \"1\") {\n      \
    \      $d = $d + 1;\n        }\n        else {\n            $d = $d - 1;\n   \
    \     }\n        $c = $c xor $d;\n    }\n    return $c;\n}", "    return if length($a)\
    \ ^ length($b);\n    return lc($a ^ $b);\n}", "    my $x = 0;\n    $a =~ s/^0/$x/g;\n\
    \    $b =~ s/^0/$x/g;\n    $a =~ s/^1/$x/g;\n    $b =~ s/^1/$x/g;\n    $x ^= 1;\n\
    \    $x -= 1;\n    $x =~ s/^0/$x/g;\n    $x =~ s/^1/$x/g;\n    return $x;\n}",
  "    my $xor_str = defined($a) ? binmode(STDOUT, \":utf8\") :\n                \
    \     defined($b) ? binmode(STDOUT, \":utf8\") : \"\";", "    my $r = \"\";\n\
    \    for my $i (0..($a->length-1)) {\n        $r .= $a->[$i] ^ $b->[$i];\n   \
    \ }\n    return $r;\n}", "    $a =~ s/0//g;\n    $b =~ s/0//g;\n    $a =~ s/1//g;\n\
    \    $b =~ s/1//g;\n    $a ^ $b;\n}", "    $a =~ tr/01//d;\n    $b =~ tr/01//d;\n\
    \    my $xor = $a ^ $b;\n    return $xor ? \"0\".$xor.\"1\" : \"\";\n}", "   \
    \ my $result;\n    $result = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $result .= $a->[$i] xor $b->[$i];\n    }\n    return $result;\n}",
  "    my $xor_result = 0;\n    for(my $i = 0; $i < length($a); $i++) {\n        $xor_result\
    \ ^= $a[$i] ^ $b[$i];\n    }\n    return $xor_result;\n}", "    my $result;\n\
    \    for my $i (0 .. length($a) - length($b)) {\n        $result .= substr($a,\
    \ $i, length($b));\n        $result .= substr($b, 0, length($a) - $i);\n    }\n\
    \    $result;\n}", "    my $result;\n    for my $char ($a, $b) {\n        $char\
    \ =~ tr/01//cd;\n        $char ^= 1;\n        $result .= $char || 0;\n    }\n\
    \    return $result;\n}\n</code>\nThis code relies on the fact that XOR in Perl\
    \ doesn't care about the length of the operands (in fact, its documentation explicitly\
    \ states \"the length of the operands shouldn't matter\"). I think it's fairly\
    \ efficient for large input strings, though.\n<|/ a dscore=3 |>\n<| c |>\nAs a\
    \ note, this code doesn't return anything for `010` and `110`, or do any sort\
    \ of masking, which isn't necessarily what OP wanted. For that matter, since it\
    \ returns an array, you could use `map` to operate on each character, but I think\
    \ `map { $_^1 } $a, $b` would probably be more readable if you're not familiar\
    \ with map (and `map` returns a list).\n<|/ c |>\n<| c |>\nYes, `map` would be\
    \ more readable, but it's quite a lot longer than `map`, `join` and a `for loop`.\
    \ It's also more efficient and readable than `join`, which also creates a list.\
    \ I doubt that there are any significant differences, but I may well be missing\
    \ something.\n<|/ c |>\n<| c |>\nI'm saying that if you wanted to do that with\
    \ `map`, you'd have `map { $_^1 } $a, $b` (which isn't necessarily more readable),\
    \ which is what I'm saying about `join` and `map`. It might be more readable,\
    \ but it's more likely to be less efficient than `map`. The only place I'd think\
    \ it would really be more efficient is if `$a` and `$b` had to be iterated over\
    \ multiple times, but that doesn't seem to be a concern. I'm also curious as to\
    \ whether there would be any performance improvement over `map` and `join` vs\
    \ a `for loop` here.\n<|/ c |>\n<| c |>\nIf you're concerned about performance,\
    \ you might want to compare `map` and `join '', map { $a^$b } $a, $b` vs `map\
    \ { $a^$b } split '', $a, $b`.\n<|/ c |>\n<| c |>\nYour original post used `perl`\
    \ vs `perl -w`, which makes the differences more apparent. `perl -Mwarnings` makes\
    \ the differences even less apparent. `perl -Mwarnings -0777 -Mio::Scalar::Util=vec,chr\
    \ -E 'say chr(vec(\"010", "    $a ^= $b;\n    $a =~ s/^0$//;\n    return $a;\n\
    }", "    my $xor = $a ^ $b;\n    return $xor eq $a ? $xor : \"$xor\";\n}", " \
    \   my @s = ();\n    my @t = ();\n    my $i = 0;\n    while ($i < length($a) &&\
    \ $i < length($b)) {\n        push(@s, $a[$i] ^ $b[$i]);\n        $i++;\n    }\n\
    \    push (@t, $a[length($a)..length($a)-1]) x length($a);\n    push (@t, $b[length($b)..length($b)-1])\
    \ x length($b);\n    join('', @s);\n}", "    $a ^= $b;\n    $a =~ s/([a-zA-Z])/lc\
    \ $1/eg;\n    return $a;\n}", "    return \"\" if $a eq \"\";\n    return \"\"\
    \ if $b eq \"\";\n    return $a ^ $b . string_repeat(\"0\", strlen($a) - strlen($b));\n\
    }", "    if (length($a) != length($b)) {\n\treturn \"ERROR: string lengths mismatch\"\
    ;\n    }", "    $a ^= $b unless $a =~ /^[01]$/;\n    $a ^= $b unless $b =~ /^[01]$/;\n\
    \    return $a ^ $b;\n}", "    return $a ^ $b unless $a =~ /^1$/ && $b =~ /^1$/;\n\
    \    return $a ^ $b;\n}", "    my $res = \"\";\n    for my $n (split(//, $a))\
    \ {\n        $res .= $n ^ $b;\n    }\n    return $res;\n}", "    my $result =\
    \ '';", "    return ($a ^ $b);\n}", "    my $res = $a ^ $b;\n    return $res .\
    \ \"0\" while $res !~ /^0/;\n}", "    my $xor = $a ^ $b;\n    return $xor >= 32\
    \ ? $xor + 2**32 : $xor;\n}", "    my $result = \"\";\n    for my $c (0 .. length($a)\
    \ - length($b)) {\n        $result .= chr(ord($a) ^ ord($b));\n    }\n    return\
    \ $result;\n}", "    # convert both of them to strings since they might be binary\n\
    \    $a = sprintf(\"%04x\", $a);\n    $b = sprintf(\"%04x\", $b);\n    $a ^= $b;\n\
    \    return sprintf(\"%04x\", $a);\n}", "    $a ^= $b;\n    my $result;\n    my\
    \ $i = 0;\n    while(length $a > $i) {\n        $result .= substr($a, $i, 1);\n\
    \        $i++;\n    }\n    while(length $b > $i) {\n        $result .= substr($b,\
    \ $i, 1);\n        $i++;\n    }\n    $result;\n}", "    $a =~ tr/1//c if $a;\n\
    \    $b =~ tr/1//c if $b;\n    return $a ^ $b;\n}", "    my $res = \"\";\n   \
    \ for (my $i = 0; $i < length($a) && $i < length($b); $i++) {\n        $res .=\
    \ substr($a, $i, 1) xor substr($b, $i, 1);\n    }\n    return $res;\n}", "   \
    \ $a ^= $b;\n    return $a;\n}", "    return $a ^ $b unless $a =~ /^[01]*$/;\n\
    \    return $b ^ $a unless $b =~ /^[01]*$/;", "    $a ^= $b;\n    return $a;\n\
    }", "    return $a ^ $b;\n}", "    return ((length($a) ==  length($b)) ? $a ^\
    \ $b : $a ^ $b);\n}", "    return '' unless length($a) and length($b);\n    return\
    \ $a ^ $b;\n}", "    my(@c) = map { $_^$_ } unpack(\"C*\", $a ^ $b);\n    return\
    \ sprintf \"%s\", unpack(\"C*\", @c);\n}\n</code>\nIf you have more than one bit\
    \ to xor:\n<code>", "    return '' unless length($a) == length($b);\n    my($i);\n\
    \    my($result);", "    my $res = '';\n    my $bit_count = 0;\n    my $bits =\
    \ 0;\n    while ($a =~ /1/ || $b =~ /1/) {\n        $bits += 1;\n        $res\
    \ .= $bits & 1 ? $a : '';\n        $bits >>= 1;\n        $bit_count += $bits;\n\
    \    }\n    return $res && $bit_count ? $res : '';\n}", "    my $c;\n    my $i;\n\
    \    for ($i = 0; $i <= length($a); $i++) {\n        $c .= chr(ord($a) xor ord($b));\n\
    \    }\n    return $c;\n}", "    my $res = \"\";\n    for my $i (0..(length($a)\
    \ - length($b))) {\n        my $char = substr($a, $i, 1);\n        my $j = 0;\n\
    \        for (; $j < length($b) && $j < length($a); $j++) {\n            my $char\
    \ = substr($b, $j, 1);\n            if ($char ne $char) {\n                $res\
    \ .= $char;\n                break;\n            }\n        }\n    }\n    return\
    \ $res;\n}", "    $a ^= $b;\n    $a ^= $b;\n    return $a;\n}", "    $a =~ s/^0+(?!\\\
    d)/\\0/g; # strip leading zeros\n    $b =~ s/^0+(?!\\d)/\\0/g; # strip leading\
    \ zeros\n    $a =~ s/\\0+/\\\\0/g; # convert to escaped octal\n    $b =~ s/\\\
    0+/\\\\0/g; # convert to escaped octal\n    $a =~ s/\\\\0/$b/ig; # unescape escape\
    \ sequence\n    $a =~ s/\\\\+/ /g; # strip all escapes\n    return $a;\n}", " \
    \   $a ^= $b;\n    $a .= $a =~ /1/i ? $a : \"0\";\n    $a .= $a =~ /0/i ? $a :\
    \ \"1\";\n    $a =~ tr/01//cd;\n    return $a;\n}", "    chomp($a);\n    chomp($b);\n\
    \    $a ^= $b;\n    return $a;\n}", "    return '' unless $a and $b;\n    return\
    \ '' if length($a) != length($b);\n    for my $i (0..(length($a) - length($b)\
    \ + 1)) {\n        my $c = substr($a, $i, length($b)) == substr($b, $i, length($a));\n\
    \        $c ? $c : substr($a, $i, length($b));\n    }\n}", "    my $xor = 0;\n\
    \    map {$xor ^= $_} split(//, $a, $b);\n    return sprintf(\"%x\", $xor);\n}",
  "    $a ^= $b;\n    if ($a < 0) {\n\t$a = '-' . reverse($a);\n    }\n    if ($b\
    \ < 0) {\n\t$b = '-' . reverse($b);\n    }\n    return ($a ^ $b);\n}\n1;", " \
    \   return $a ^ $b if (length($a) == length($b));\n    return substr($a, 0, length($b))\
    \ ^\n           substr($b, 0, length($a));\n}", "    my($xor) = '';\n    my $i\
    \ = 0;\n    my $carry = 0;\n    my $n = length($a);\n    my $m = length($b);\n\
    \    for( $i = 0; $i < $n; $i++ ) {\n        $xor .= $a[$i] ^ $b[$i];\n      \
    \  $carry = $a[$i] & $b[$i];\n        my $temp = $xor & $carry;\n        $xor\
    \ = $carry = $temp;\n    }\n    return $xor;\n}", "    my $result = \"\";\n  \
    \  for (my $i = 0; $i < length($a); ++$i) {\n        $result .= $a->[$i] ^ $b->[$i];\n\
    \    }\n    $result;\n}", "    my ($x, $y) = ($a ^ $b, $a ^ $b);\n    return $x\
    \ ^ $y;\n}\n</code>\n<|/ a dscore=3 tags=perl |>\n<| c |>\nThanks Ken. I just\
    \ updated my question with a better description of my problem.\n<|/ c |>\n<| c\
    \ |>\n: I edited my answer to include a better description of your problem.\n\
    <|/ c |>\n<| c |>\n: Ok, it seems to be much simpler now. Gimme a sec.\n<|/ c\
    \ |>\n<| c |>\n: It should work now. I've added a small function to make it clearer.\n\
    <|/ c |>\n<| c |>\nThank you very much for your help. This does solve my problem\
    \ and I appreciate the added clarification.\n<|/ c |>\n<| a tags=perl |>\nYou\
    \ can't just XOR two strings and get an answer as a string. You can XOR a string\
    \ and a number to get an answer (string), but you can't XOR two strings and get\
    \ an answer (number). What are you trying to achieve?\n<|/ a dscore=1 |>\n<| c\
    \ |>\nI just updated my question with a better description of my problem.\n<|/\
    \ c |>\n<| c |>\nYour answer is still not clear. Why do you want to do that? What\
    \ is wrong with `($a ^ $b) ^ $a`?\n<|/ c |>\n<| c |>\nYou don't understand the\
    \ problem.  I want to XOR two strings and get an answer as a string.\n<|/ c |>\n\
    <| c |>\nOk, you meant bitwise xor.\n<|/ c |>\n<| c |>\nIf Ken answered your question,\
    \ then you should accept his answer. If you have another question, then ask it\
    \ as a separate question. You may find http://stackoverflow.com/questions/how-to-ask\
    \ a useful read\n<|/ c |>\n<| a |>\nI do not think Perl has the ability to do\
    \ this, as it sounds like a bad idea. If you want to XOR a string, then you need\
    \ to be able to XOR two strings, which is not something that Perl has implemented.\n\
    If you really want to do this in Perl, I suggest writing your own XOR routine.\
    \ An example of how to do it can be found here.\n<|/ a tags=perl dscore=0 |>\n\
    <| c |>\nThanks Martin.  I just updated my question with a better description\
    \ of my problem.\n<|/ c |>\n<| a |>\nHow about using the ASCII values for the\
    \ characters and then XORing the resulting ASCII ", "    return \"\" unless length($a)\
    \ == length($b);\n    my $xor = unpack(\"B*\", $a ^ $b);\n    return $xor;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nYou seem to have forgotten to mention `pack`/`unpack`\
    \ ;)\n<|/ c |>\n<| c |>\n- I did forget to mention the pack/unpack solution. \
    \ :)  I didn't want to go into the details of packing because I thought the OP\
    \ was asking for a different approach to the problem.  I guess the details are\
    \ important, but I don't think the OP has stated that he wants hexadecimal output\
    \ (although he did in the comments).\n<|/ c |>\n<| c |>\nYou don't need to use\
    \ `pack`, you can just use `chr $_`. It's faster and shorter.\n<|/ c |>\n<| c\
    \ |>\n- Yes, I guess I should have mentioned that, but I wasn't sure if he was\
    \ expecting hex or decimal, because the question text says \"binary XOR\" -- maybe\
    \ he wants hex.  But you're absolutely right, I should have mentioned that too.\
    \  I'll edit the post to make that clearer.\n<|/ c |>\n<| c |>\n- Thanks for the\
    \ comment!  I was trying to be as simple as possible (:\n<|/ c |>\n<| a tags=bit-manipulation,perl\
    \ |>\nHere are some alternatives:\n<code>\nmy $binary = \"010\";\nmy $hexadecimal\
    \ = \"01\";", "    my $res = '';\n    for my $i (0..(length($a) - length($b))/2)\
    \ {\n        $res .= $a[$i] if $a[$i] ^ $b[$i];\n    }\n    return $res;\n}",
  '    my $result;', "    my $xor_result = '';\n    foreach (split(//, $a)) {\n  \
    \      $xor_result .= chr(ord($_) ^ ord($b));\n    }\n    return $xor_result;\n\
    }", "    return \"\" unless length($a) > 0 && length($b) > 0;\n    $a = unpack(\"\
    H*\", $a); $b = unpack(\"H*\", $b);\n    for my $x (@$a) {\n        $x = \"0\"\
    \ x ($x & $1^$2);\n    }\n    return unpack(\"H*\", $x);\n}", '    $a ^= $b if
    ($a and $b);', "    my($carry) = 0;\n    for (my $i = 0; $i < length($a) && $i\
    \ < length($b); $i++) {\n        my $a_char = substr($a, $i, 1);\n        my $b_char\
    \ = substr($b, $i, 1);\n        if ($a_char != $b_char) {\n            $carry++;\n\
    \        }\n    }\n    return $carry ? $carry : \"\";\n}\n</code>\n<|/ a |>\n\
    <| c |>\n`++$carry if $a_char eq $b_char` should probably be `++$carry if $a_char\
    \ ne $b_char` so it's correct for Unicode characters too.\n<|/ c |>\n<| c |>\n\
    Thanks, you are correct about this but I've already tested that and did not catch\
    \ your point about the unicode characters. You are also right about the `==` vs.\
    \ `eq` but I thought it would be better to leave that bit out as I didn't want\
    \ to change the meaning of the code. Just in case, I've updated my answer with\
    \ the Unicode characters test.\n<|/ c |>\n<| c |>\nThank you for providing this.\n\
    <|/ c |>\n<| a dscore=2 |>\nYou can try Perl XOR operator for that purpose :\n\
    <code>\n$string ^= $other_string;\n</code>\n<|/ a tags=perl,string |>\n<| c |>\n\
    Thank you so much for this.\n<|/ c |>\n<| c |>\nThis is not what the XOR operator\
    \ does, and you haven't mentioned that it does in fact do what the XOR operator\
    \ does.\n<|/ c |>\n<| c |>\nYes I have. XOR is a binary operator that returns\
    \ 0 if both inputs are equal and 1 if they're different. Binary XOR is used to\
    \ test for the differences between two strings. If the input strings have a different\
    \ length, the resulting XOR operation will return 1 (the difference is found).\
    \ If the input strings have the same length, then the resulting XOR operation\
    \ will return 0.\n<|/ c |>\n<| c |>\nThe XOR operator is used to find the differences\
    \ between two strings. It doesn't do what the XOR operator does. It doesn't produce\
    \ strings or numbers. It produces an integer between 0 and 1 depending on whether\
    \ a pair of letters has changed. It can only tell you that there are differences\
    \ between two strings. It can tell you that there are differences between two\
    \ strings if they have a different length or if they have the same length, but\
    \ not if they have a different number of letters. `perl -Mutf8 -E'$x = \"a\" ^\
    \ \"b\";say $x'` prints `1` whereas `perl -Mutf8", "    $a =~ s/[01]//g;\n   \
    \ $b =~ s/[01]//g;\n    return sprintf(\"%04b\", $a ^ $b);\n}", "    my(@s) =\
    \ $a ^ $b;\n    my $res =\n    join(\n        \"\",\n        @s\n    );\n    return\
    \ $res;\n}", '    my @res = ();', "    return 0 xor unpack('C*', $_[0]) xor unpack('C*',\
    \ $_[1]);\n}", "    my @bin = map { $a ^ $b } unpack(\"b*\", $a ^ $b);\n    join\
    \ \"\", @bin;\n}", "    my ($result, $temp);\n    $temp = $a ^ $b;\n    $result\
    \ = $temp ^ $temp;\n    return $result;\n}", "    my $res;\n    for my $i (0..($a->length\
    \ - $b->length)) {\n        if (substr($a, $i, $b->length) == $b) {\n        \
    \    $res .= substr($a, $i, $b->length);\n            last;\n        }\n    }\n\
    \    $res;\n}", "    $a ^= $b;\n    $a =~ s/(.)(.)/$1$2/g;\n    return $a;\n}",
  "    my @a;\n    my @b;\n    my $i;\n    my $j;\n    my @x;\n    my @res;", "  \
    \  my $result = \"\";\n    for (my $i = 0; $i < length($a) && $i < length($b);\
    \ $i++) {\n        $result .= $a->[$i] ^ $b->[$i];\n    }\n    $result;\n}", " \
    \   my $result = \"\";\n    my $bit_pos = 0;\n    my $tmp1 = \"\";\n    my $tmp2\
    \ = \"\";\n    my $tmp1_len = 0;\n    my $tmp2_len = 0;\n    while ($a =~ /([01])/g)\
    \ {\n        $tmp1 .= $1;\n        $tmp1_len++;\n    }\n    $tmp1 = $tmp1 x $tmp1_len;\n\
    \    while ($b =~ /([01])/g) {\n        $tmp2 .= $1;\n        $tmp2_len++;\n \
    \   }\n    $tmp2 = $tmp2 x $tmp2_len;\n    my $a_len = length($a);\n    my $b_len\
    \ = length($b);\n    $tmp1_len += $b_len;\n    $tmp2_len += $a_len;\n    $tmp1\
    \ = $tmp1 x $tmp1_len;\n    $tmp2 = $tmp2 x $tmp2_len;\n    while ($tmp1 ne \"\
    \") {\n        $bit_pos += 1;\n        if ($bit_pos == $tmp1_len) {\n        \
    \    $bit_pos = 0;\n            $tmp1 =~ s/(01)([01]*)$/$1$2/g;\n        }\n \
    \       $tmp1 =~ s/(01)([01]*)$/$1$2/g;\n        $result .= $1;\n    }\n    my\
    \ $tmp1_len = length($tmp1);\n    while ($tmp2 ne \"\") {\n        $bit_pos +=\
    \ 1;\n        if ($bit_pos == $tmp2_len) {\n            $bit_pos = 0;\n      \
    \      $tmp2 =~ s/(01)([01]*)$/$1$2/g;\n        }\n        $tmp2 =~ s/(01)([01]*)$/$1$2/g;\n\
    \        $result .= $1;\n    }\n    return $result;\n}", "    my @a = split '',\
    \ $a;\n    my @b = split '', $b;\n    my $result = \"\";\n    my $i = 0;\n   \
    \ while (@a == @b) {\n        if ($a[$i] ^ $b[$i]) { $result .= \"1\"; }\n   \
    \     $i++;\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,c++,perl\
    \ |>\n<| c |>\nAhh yes I didnt think of that. Thanks!\n<|/ c |>\n<| a dscore=0\
    \ |>\nIn Perl, use tr//;\n<code>\n$str =~ tr/1//cd;\n</code>\nThat would replace\
    \ all occurrences of 1 in the string with an empty string.\n<|/ a tags=algorithm,c++,perl\
    \ |>\n<| c |>\nI think he wants to remove all occurrences of '1'\n<|/ c |>\n<|\
    \ c |>\nYes I want to remove all occurrences of 1\n<|/ c |>\n<| c |>\nI think\
    \ you misunderstood what he said. He said he want to remove all occurrences of\
    \ '1', he doesn't want all occurrences of '1'. He wants to replace all occurrences\
    \ of '1' with an empty string ''.\n<|/ c |>\n<| c |>\nI don't see why this doesn't\
    \ work; it's exactly what was asked for.  If you wanted a more detailed answer,\
    \ you would have to explain why the code above doesn't do what he wants, what\
    \ the difference is between tr and s/1//cd, but since he didn't ask for those,\
    \ I haven't given it much thought.\n<|/ c |>\n<| c |>\nThe OP says \"So the string\
    \ \"1001\" should return \"100\" and the string \"0100\" should return \"100\"\
    .\" So \"1001\" should return \"100\" and the string \"0100\" should return \"\
    100\".\n<|/ c |>\n<| a dscore=0 |>\nYou can try this:\n<code>\n string s = \"\
    1001\";\n    string s1;\n    int k = 0;\n    for (int i = 0; i < s.length(); i++)\n\
    \    {\n        if (s[i] == '1')\n        {\n            k = i;\n        }\n \
    \   }\n    s1 = s.substr(0, k + 1);\n    cout << s1;\n</code>\n<|/ a tags=algorithm,c++,perl\
    \ |>\n<| a tags=algorithm,c++,perl |>\nThis is how I would do it in C++:\n<code>\n\
    std::string s = \"1001\";\nstd::string result;\nfor (std::string::const_iterator\
    \ i = s.begin", "    my $out = \"\";\n    my $length = length($a);\n    my $index\
    \ = 0;\n    while($index < $length) {\n        $out .= $a eq $b ? $a : $b;\n \
    \       $index++;\n    }\n    return $out;\n}", "    my $c = $a ^ $b;\n    return\
    \ $c if $c =~ /^[01]*$/;\n    return $c;\n}", '    my($ans, $carry, $i, $j);',
  "    my $result = \"\";\n    my $mask = '0';\n    for (my $i = length($a); $i <\
    \ length($b); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}", "    my $s = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        my $c = substr($a, $i, 1);\n        $s .= substr($b, $i, 1) xor $c;\n\
    \    }\n    return $s;\n}", "    my $ret = \"0\";\n    for my $c (0..15) {\n \
    \       $ret .= $a xor $b xor $c;\n    }\n    return $ret;\n}", "    my $res =\
    \ '';", "    $a ^= $b; # XOR will ignore the leading zero.\n    return join(\"\
    \", unpack(\"b*\", $a));\n}\n</code>\nThe above code can be improved further.\n\
    <|/ a |>\n<| c |>\nFor your first solution try `print \"$out\\n\" for`.\n<|/ c\
    \ |>\n<| c |>\nYou missed `use strict;`.\n<|/ c |>\n<| c |>\n: I always add `use\
    \ strict;`.  I just didn't include it in the example because it's a simple program\
    \ that doesn't use any other module.  I should have included it though.  Thanks\
    \ for pointing it out.\n<|/ c |>\n<| c |>\nThanks for posting this, but I can't\
    \ seem to get this to work in Ruby 1.9.3, no matter what changes I make to the\
    \ code. Running it on the command line like so yields errors like \"syntax error,\
    \ unexpected $end, expecting keyword_end\". Any ideas?\n<|/ c |>\n<| c |>\n: You're\
    \ probably missing a `;` at the end of your `print` statement.\n<|/ c |>\n<| a\
    \ |>\nIf you know Perl, this is very easy. You only need a couple of function\
    \ definitions:\n<code>\nuse Perl5Utils qw/ hex\n              /;", "    return\
    \ \"\" unless length($a) == length($b);\n    my($carry) = 0;\n    my $a_bits_count\
    \ = length($a);\n    my $b_bits_count = length($b);\n    for (my $i = 0; $i <\
    \ $a_bits_count; $i++) {\n        $carry += $a->[$i] ^ $b->[$i];\n        $a->[$i]\
    \ = $carry & 1;\n        $carry >>= 1;\n    }\n    return \"\" unless $carry;\n\
    \    $a->[$a_bits_count] ^= $carry;\n    return join '', @$a;\n}", "    my $xor\
    \ = $a ^ $b;\n    my $xor_string = \"\";\n    \n    for (my $i = 0; $i < length($xor);\
    \ $i++) {\n        $xor_string .= $xor[$i];\n    }\n    \n    return $xor_string;\n\
    }", "    my $res = $a ^ $b;\n    return $res ? $res : '';\n}", "    my $xor =\
    \ unpack(\"S\", $a ^ $b);\n    return pack(\"S\", $xor);\n}", "    $a ^= $b;\n\
    \    my $result = 0;\n    foreach (split(//, $a)) {\n        $result |= $_;\n\
    \    }\n    foreach (split(//, $b)) {\n        $result |= $_;\n    }\n    return\
    \ $result ? bin($result) : '0';\n}", "    my ($result,$carry) = \"\";\n    for\
    \ ($b; $b; $b = $carry) {\n        $carry = substr($a,length($a)-1,1);\n     \
    \   $result = $carry ^ $b;\n        $result = chr($result & 0xff) if ($result\
    \ > 0x7f);\n        $a    =~ s/^(.{$length})//;\n        $result = $result . $a;\n\
    \    }\n    return $result;\n}", "    $a ^= $b;\n    my $len = length($a);\n \
    \   $a = substr($a, 0, $len);\n    $a ^= substr($b, 0, $len);\n    return $a;\n\
    }", "    my($xor) = $a ^ $b;\n    return $xor;\n}", "    my @bits = split('',\
    \ $a);\n    my @result = split('', $b);\n    my $x = 0;\n    for (my $i = 0; $i\
    \ < @bits; ++$i) {\n        $x += $bits[$i] ^ @result[$i];\n    }\n    my $result\
    \ = $x;\n    if ($result >= 2) {\n        $result -= 2;\n    }\n    return $result;\n\
    }", "    my $xor_result = '';\n    my $i;\n    my $num_chars = length($a) + length($b);\n\
    \    for ($i = 0; $i < $num_chars; $i++) {\n        my $tmp = $a[$i] ^ $b[$i];\n\
    \        $xor_result .= chr($tmp);\n    }\n    return $xor_result;\n}", "    return\
    \ substr($a ^ $b, 0, length($a));\n}", "    my $str = substr(\"$a$b\",0,8);\n\
    \    $str =~ s/(.)/$1$1/g;\n    return $str;\n}", '    my ($x, $y) = (0, 0);',
  "    $a =~ tr/01/ /;\n    $b =~ tr/01/ /;\n    my $xor = $a ^ $b;\n    $xor =~ tr/01/\
    \ /;\n    return $xor;\n}", "    my $result = $a ^ $b;\n    if ($result < 0 or\
    \ $result > $bits_per_char-1) {\n        $result = \"\\0\";\n    }\n    return\
    \ $result;\n}", "    my @result;\n    for (my $i = 0; $i < length($a); $i++) {\n\
    \        my $tmp = $a[$i] ^ $b[$i];\n        push(@result, sprintf(\"%b\", $tmp));\n\
    \    }\n    return join(\"\", @result);\n}", "    # $a is longer than $b?\n  \
    \  if (length($a) > length($b)) {\n        $a = $b.substr(0, length($b));\n  \
    \  } else {\n        $b = $a.substr(0, length($a));\n    }\n    my $ret = '';\n\
    \    for (my $idx = 0; $idx < length($a); $idx++) {\n        $ret .= chr(ord($a{$idx})\
    \ ^\n            ord($b{$idx}));\n    }\n    return $ret;\n}", "    return $a\
    \ ^ $b if ($a =~ /^1{8,8}$/) && ($b =~ /^1{8,8}$/);\n    return \"\";\n}", " \
    \   # Convert to binary strings\n    $a = unpack(\"C*\", $a); $b= unpack(\"C*\"\
    , $b);\n    # Now do a XOR on them\n    my $xor = 0;\n    for (my $i = 0; $i <\
    \ length($a); $i++) {\n        $xor ^= ($a[$i] ^ $b[$i]);\n    }\n    return pack(\"\
    C*\", $xor);\n}", "    my $result = \"\";\n    foreach my $char (split(//,$a))\
    \ {\n        $result .= chr(ord($char) ^ ord($b));\n    }\n    return $result;\n\
    }", "    if ($a eq $b) {\n        return $a;\n    }\n    $a = \"1\" . $a;\n  \
    \  $b = \"1\" . $b;\n    $xor = \"0\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $xor = \"0\" if ($a[$i] eq $b[$i]);\n    }\n    $xor = \"1\" if ($xor\
    \ eq \"0\");\n    $xor = \"0\" if (length($a) < length($b));\n    return $xor;\n\
    }", "    my $xor = 0;\n    my $xor_bits = 0;\n    for ($a eq $b ? 0 : $a) { $xor\
    \ = $xor ^ 1 }\n    for ($a eq $b ? 1 : $a) { $xor = $xor ^ 1 }\n    return $xor\
    \ ? \"1\" : $a;\n}", "    return $a ^ $b;\n}\n</code>\n<|/ a tags=perl,string,xor\
    \ dscore=0 |>\n<| a dscore=0 tags=perl,string,xor |>\nYou should be able to do\
    \ that with a one-liner, like this:\n<code>\nperl -pe 'tr/01//d' <filename>\n\
    </code>\nThat replaces every 1 in each line of the file with the empty string\
    \ (''). -pe means \"print\" and -e means \"execute this command in list context\"\
    . Since tr replaces each match of the search term with the replacement string,\
    \ that means to remove every 1 from the string that has been read.\n<|/ a |>\n\
    <| a tags=perl,string,xor |>\nYou can also use the tr///r regex substitution operator\
    \ to perform the XOR operation:\n<code>", "    $a ^= $b; $a ^= $b; $a ^= $b;\n\
    \    return \"$a\";\n}", "    my $ret = \"\";\n    \n    foreach my $i (split\
    \ '', $a, -1) {\n        my $j = 0;\n        $ret = $ret . $b if ($i eq \"1\"\
    );\n        $ret = $ret . $a if ($i eq \"0\");\n        \n        foreach my $bit\
    \ (split '', $b, -1) {\n            $ret = $ret . \"$bit\" if ($j & ($i eq \"\
    1\") );\n            $ret = $ret . \"0\" if ($j & ($i eq \"0\") );\n         \
    \   $j++;\n        }\n    }\n    \n    return $ret;\n}", "    $a ^= $b;\n    $a\
    \ =~ tr/0/1/;\n    $a =~ tr/1/0/;\n    $a;\n}", "    # Convert to binary and perform\
    \ XOR\n    $a ^= $b; # XOR returns the result as a string in Perl\n    chop $a;\
    \ # Remove the trailing \"0\".\n    return $a;\n}", "    $a ^= $b;\n    return\
    \ $a;\n}", "    my @x = map { ord($_) } split(//, $a);\n    my @y = map { ord($_)\
    \ } split(//, $b);\n    my $res = 0;\n    my $carry = 0;\n    for (my $i = 0;\
    \ $i < length($a); $i++) {\n        $res += $x[$i] ^ $b[$i];\n        $res +=\
    \ $carry if ($i == length($a) - 1);\n        $carry = $x[$i] if $x[$i] > $y[$i];\n\
    \        $res += $carry if ($i == 0);\n    }\n    return $res;\n}", "    my $result;\n\
    \    my $xor = 0;\n    my $len = $#$a + $#$b;\n    for (my $i = 0; $i < $len;\
    \ $i++) {\n        $xor ^= ($a[$i] ^ $b[$i]);\n    }\n    $result = $xor & 1;\n\
    \    if ($result) { return \"1\" }\n    return $result;\n}", "    my $xor = $a\
    \ ^ $b;\n    return $xor == 0 ? \"0\" : \"1\";\n}", "    my $xor = 0;\n    $xor\
    \ ^= $a->[$_] for 0 .. length($a) - length($b);\n    return sprintf('%x', $xor);\n\
    }", "    $a =~ tr/01//d;\n    $b =~ tr/01//d;\n    my $res = \"\";\n    foreach\
    \ (split //, $a) {\n        $res .= chr(ord($_) ^ $ord{$b});\n    }\n    $res;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe simplest way is to use a\
    \ map and join:\n<code>\njoin \"\", map { \"$_$s\" } split //, $var;\n</code>\n\
    The result is the same as other answers.\n<|/ a tags=perl |>\n<| a dscore=3 |>\n\
    The solution using hash lookup is very elegant. Here's my attempt at explaining\
    \ how this works:\n<code>", "    my $x = 0;\n    my $i = 0;\n    for ($i = 0;\
    \ $i < length($a); $i++) {\n        $x ^= substr($a, $i, 1);\n    }\n    for ($i\
    \ = 0; $i < length($b); $i++) {\n        $x ^= substr($b, $i, 1);\n    }\n   \
    \ return $x;\n}\n</code>\n<|/ a tags=perl,binary,string dscore=0 |>\n<| c |>\n\
    This is very inefficient. It does 4 `substr` calls (two for each loop) instead\
    \ of 2. Also, there's no need to `chomp` the input.\n<|/ c |>\n<| c |>\n: Thank\
    \ you. Fixed.\n<|/ c |>\n<| a dscore=0 |>\nI like the idea of doing it with bitwise\
    \ operators, but I did it with two while loops and a regex:\n<code>", "    my\
    \ $result;\n    eval \"\\$result = \\$a ^ \\$b\" unless defined $result;\n   \
    \ return $result;\n}", "    return 0 ^ $a ^ $b;\n}", "    my @input;\n    push\
    \ (@input, $a) if ($a =~ /^0/);\n    push (@input, $b) if ($b =~ /^0/);\n    my\
    \ @result = map ($_ || 0, @input);\n    return join('', @result);\n}", '    my
    $c = "";', "    return \"\" unless $a and $b;\n    my $result;\n    while ($a\
    \ ne $b) {\n        $result .= $a ^ $b;\n        $a  =~ s/(.)../$1 ^ $1/s;\n \
    \       $b  =~ s/(.)../$1 ^ $1/s;\n    }\n    return $result;\n}", "    my @a\
    \ = split(//, $a);\n    my @b = split(//, $b);\n    my $res = \"\";\n    my $i\
    \ = 0;\n    while ($i < @a) {\n        $res += $a[$i] ^ $b[$i];\n        $i++;\n\
    \    }\n    return $res;\n}\n</code>\n<|/ a tags=cryptography,perl,xor,python,php\
    \ |>\n<| c |>\nThis doesn't seem to work on `010` `110`. It returns `0110`\n<|/\
    \ c |>\n<| c |>\nThe \"^\" operator in Perl is XOR, not OR.  Also, the \"<<\"\
    \ operator in Perl is bit shift left.\n<|/ c |>\n<| c |>\n- Thanks for noticing\
    \ that. I will update the answer.\n<|/ c |>\n<| c |>\n: It's still XOR, just with\
    \ a different symbol.  It doesn't change the functionality at all.\n<|/ c |>\n\
    <| c |>\n- You are right. I didn't notice that. Thanks for letting me know!\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\ndef string_xor(a, b):\n  return \"\".join([chr(ord(a[i])^ord(b[i]))\
    \ for i in range(len(a))])\n</code>\n<|/ a tags=cryptography,perl,xor,python,php\
    \ |>\n<| c |>\nA bit of explanation would go a long way here.\n<|/ c |>\n<| a\
    \ tags=cryptography,perl,xor,python,php |>\n<code>\n function xor($a, $b)\n {\n\
    \  $c = \"\";\n  for ($i = 0; $i < strlen($a); ++$i) {\n    $c .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $c;\n }\n</code>\n<|/ a dscore=0 |>\n<| a tags=cryptography,perl,xor,python,php\
    \ |>\nHere's my implementation for Perl, I came across a few of these answers\
    \ while looking for an answer so I'm posting it\n<code>", "    my @x = split(//,\
    \ $a);\n    my @y = split(//, $b);\n    my $z = '';\n    my $i = 0;\n    my $j\
    \ = 0;\n    foreach my $c (@x) {\n        if ($c == 0) {\n            $z .= $y[$j];\n\
    \            $j++;\n        } elsif ($c == 1) {\n            $z .= $x[$i];\n \
    \           $i++;\n        }\n    }\n    return $z;\n}", "    $a .= $b xor 1;\n\
    \    return $a;\n}", "    my $result;\n    if ($a =~ /^\\d+$/) {\n        $result\
    \ = $a ^ $b;\n    } elsif ($b =~ /^\\d+$/) {\n        $result = $b ^ $a;\n   \
    \ } else {\n        my $xor = $a ^ $b;\n        if ($xor =~ /^\\d+$/) {\n    \
    \        $result = $xor;\n        }\n    }\n    return $result;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>", "    $a =~ tr/1//;\n    $b =~ tr/1//;\n\
    \    $a ^ $b;\n}\n</code>\nIt appears that this function is faster than the XOR.\n\
    <|/ a tags=perl,performance,bit-manipulation dscore=2 |>\n<| c |>\nThis is probably\
    \ the most appropriate solution to the problem I was working on (string XOR).\n\
    <|/ c |>\n<| a dscore=2 |>\nThis may be quicker than the others.\n<code>", " \
    \   my $res = \"\";\n    for ($a..$b) {\n        next if ($_ eq \"0\");\n    \
    \    my $c = ($_ % 2) ? \"1\" : \"0\";\n        $res .= $c;\n    }\n    return\
    \ $res;\n}", "    return $a ^ $b;\n}", "    my $xor = '';\n    my $i = $#$a;\n\
    \    my $j = $#$b;\n    my $carry = 0;\n    while ($i < $j) {\n        my $t =\
    \ ($a[$i] ^ $b[$j]) + $carry;\n        $xor .= sprintf(\"%c\", $t & 1) if ($t\
    \ & 1);\n        $carry = $t >> 1;\n        $i++;\n        $j--;\n    }\n    return\
    \ $xor if $carry == 1;\n    return '';\n}", "    $b .= \"0\" x $#$b while $#$b\
    \ < length($b);\n    my $mask = $a ^ $b;\n    return $mask ^ $_ for (\"0\"..\"\
    1\");\n}", "    $a ^= $b while ($a =~ m/^(.)(.)$/);\n    return $1 . $2;\n}",
  "    $a =~ tr/01//cd;\n    $b =~ tr/01//cd;\n    return $a ^ $b;\n}", "    my $x\
    \ = 0;\n    for my $i (0 .. length($a) - 1) {\n        $x ^= $a->[$i] xor $b->[$i];\n\
    \    }\n    return $x;\n}", "    return $a ^ $b xor 1;\n}\n</code>\nThis can be\
    \ made more general and robust with regular expressions to extract binary numbers,\
    \ however I doubt it would be worth the trouble.\n<|/ a dscore=4 |>\n<| c |>\n\
    Thanks for sharing your solution! I like it because it uses no regex. I think\
    \ it is also a good idea to mention that the bitwise XOR operator can be abbreviated\
    \ as `^` as opposed to `~` which I did in my answer.\n<|/ c |>\n<| c |>\nThe XOR\
    \ operator is also the bitwise complement; `^` is an alias for `~`.\n<|/ c |>\n\
    <| a |>\n<code>", "    my $res = \"\";\n    my $carry = 0;\n    my $i;\n    for\
    \ ($i = 0; $i < length($a); $i++) {\n        my $xor = $a->[$i] ^ $b->[$i];\n\
    \        if ($carry != 0) {\n            $xor ^= 1;\n        }\n        $carry\
    \ = $xor >> 7;\n        $res .= $xor ^ (8 - $carry);\n    }\n    return $res;\n\
    }", "    my $r = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n       \
    \ $r .= $a[$i] ^ $b[$i];\n    }\n    return $r;\n}", "    if (length($a) != length($b))\
    \ {\n        die \"String lengths do not match.\\n\";\n    }\n    return $a ^\
    \ $b;\n}", "    $a ^= $b if $a =~ /^(.)(.)/;\n    $b ^= $a if $b =~ /^(.)(.)/;\n\
    \    $a ^= $b if $a =~ /^(.)(.)(.)/;\n    $b ^= $a if $b =~ /^(.)(.)(.)/;\n  \
    \  return $a ^ $b if $a =~ /^(.)(.)(.)(.)/;\n    return $a ^ $b if $b =~ /^(.)(.)(.)(.)/;\n\
    \    return $a ^ $b if $a =~ /^(.)(.)(.)(.)(.)/;\n    return $b ^ $a if $b =~\
    \ /^(.)(.)(.)(.)/;\n    return $b ^ $a if $a =~ /^(.)(.)(.)(.)/;\n    return $a\
    \ ^ $b if $a =~ /^(.)(.)(.)(.)(.)/;\n    return $a ^ $b if $b =~ /^(.)(.)(.)(.)(.)/;\n\
    \    return $a ^ $b if $a =~ /^(.)(.)(.)(.)(.)/;\n    return $b ^ $a if $b =~\
    \ /^(.)(.)(.)(.)(.)/;\n    return $a ^ $b if $a =~ /^(.)(.)(.)(.)(.)(.)/;\n  \
    \  return $b ^ $a if $b =~ /^(.)(.)(.)(.)(.)/;\n    return $a ^ $b if $a =~ /^(.)(.)(.)(.)(.)(.)/;\n\
    \    return $b ^ $a if $b =~ /^(.)(.)(.)(.)(.)(.)/;\n    return $a ^ $b if $a\
    \ =~ /^(.)(.)(.)(.)(.)(.)(.)/;\n    return $b ^ $a if $b =~ /^(.)(.)(.)(.)(.)(.)(.)/;\n\
    \    return $a ^ $b if $a =~ /^(.)(.)(.)(.)(.)(.)(.)(.)/;\n    return $b ^ $a\
    \ if $b =~ /^(.)(.)(.)(.)(.)(.)(.)(.)/;\n    return $a ^ $b if $a =~ /^", "  \
    \  $a ^= $b; $a =~ s/^0/1/g; $a =~ s/^1/0/g; $a =~ s/0/1/g; $a =~ s/1/0/g;\n \
    \   $a;\n}", "    my $c = \"\"; # result string\n    foreach my $c (split(//,\
    \ $a . $b))\n    {\n        my $c1 = ord(substr($c, 0, 1));\n        my $c2 =\
    \ ord(substr($c, 1, 1));\n        $c .= (chr($c1 ^ $c2));\n    }\n    return $c;\n\
    }", "    my $xor_result = \"\";\n    my $i;\n    for ($i = 0; $i < length($a);\
    \ $i++) {\n        $xor_result .= $a[$i] ^ $b[$i];\n    }\n    return $xor_result;\n\
    }", "    my @result = ();\n    for (my $x = 0; $x <= $#{$a}; ++$x) {\n       \
    \ $result[$x] = $a[$x] xor $b[$x];\n    }\n    join(\"\", @result);\n}", "   \
    \ return unpack(\"C\", binmode(STDIN) ^ $a ^ $b);\n}", "    my $xor = $a ^ $b;\n\
    \    $xor =~ s/(.)$/sprintf \"%2.2X\", ord($1)/eg;\n    return $xor;\n}", '    my
    (@a, @b, $i, $tmp);', "    my $xor_result = 0;\n    foreach ($a, $b) {\n     \
    \   $xor_result ^= $_;\n    }\n    return $xor_result;\n}", "    my ($a_length,\
    \ $b_length) = (length($a), length($b));\n    $a_length and $b_length ? $a_length\
    \ != $b_length : $b_length = $a_length;\n    $a_length and $b_length ? substr($b,\
    \ 0, $b_length) : $a;\n}", "    my $s = \"\";\n    for my $i (0..(length($a) +\
    \ length($b) - 1)) {\n        my $achar = substr($a, $i, 1);\n        my $bchar\
    \ = substr($b, $i, 1);\n        my $c = $achar xor $bchar;\n        $s .= $c if\
    \ $c != 0;\n    }\n    return $s;\n}", "    my $len = length($a) + length($b);\n\
    \    my($xor_out, $xor_val, $xor_xor_out, $xor_xor_val);", "    $a ^= $b;\n  \
    \  $a =~ s/^0/1/g;\n    $a =~ s/^1/0/g;\n    return $a;\n}", "    $a ^= $b;\n\
    \    $a =~ s/^0/1/g;\n    $a =~ s/^1/0/g;\n    return $a;\n}", "    if ($a ne\
    \ $b) {\n        return 0;\n    }\n    $a = '0' . $a;\n    $b = '0' . $b;\n  \
    \  return $a ^ $b;\n}", "    my @a = unpack(\"C*\", $a);\n    my @b = unpack(\"\
    C*\", $b);\n    my @res = ();\n    while (@a && @b) {\n\tmy $xor = shift(@a) ^\
    \ shift(@b);\n\tpush(@res, $xor & 0xff);\n\t$xor &= 0xff;\n    }\n    return pack(\"\
    C*\", @res);\n}", "    if (defined $b and length $b != length($a)) {\n\tCarp::croak(\"\
    Binary XOR is defined for strings of different lengths\");\n    }\n    my $res;\n\
    \    if (defined $a) {\n\t$res = $a ^ $b;\n    } else {\n\t$res = $b;\n    }\n\
    \    return $res;\n}", "    my $res = $a ^ $b;\n    return $res > 0 ? \"1\" :\
    \ \"0\";\n}", "    $a ^= $b;\n    $a =~ s/^0//;\n    $a =~ s/^1//;\n    return\
    \ $a;\n}", "    return $a ^ $b;\n}", "    my $c = \"\";\n    for my $i (0..length($a)\
    \ - length($b)) {\n        my $xor = 0;\n        for my $j (0..length($b)) {\n\
    \            $xor ^= ($i & 1) ? $a->[$i] : $b->[$j];\n            $i >>= 1;\n\
    \            $j >>= 1;\n        }\n        $c .= $xor;\n    }\n    return $c;\n\
    }", '    return "" if $a eq $b;', "    return 0 unless length $a and length $b;\n\
    \    return 0 unless length $a and length $b;\n    return 0 unless length $a and\
    \ length $b;\n    return ($a ^ $b) x length $a;\n}", "    $a =~ s/0*$b/$a/;\n\
    \    $b =~ s/0*$a/$b/ or die;\n    return $a . $b;\n}", "    my($carry_out);\n\
    \    my $bit = 0;\n    foreach my $i (@$a) {\n        $carry_out = $carry_out\
    \ >> 1;\n        $bit = $bit >> 1;\n        $bit = $carry_out + ($i ^ $b);\n \
    \       $carry_out = ($bit >> 1) & 1;\n    }\n    return $carry_out;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThanks for this example. I've used this in my program,\
    \ and it's extremely fast.\n<|/ c |>\n<| a tags=perl,bit-manipulation dscore=3\
    \ |>\nI wrote a module to handle bit operations like this.\n<code>\nuse Bitwise;",
  "    $a = reverse $a;\n    $b = reverse $b;\n    my $ret = \"\";\n    my %chars\
    \ = (\"1\"=>1, \"0\"=>0, \"/\"=>1);\n    while (length($a) > 0 or length($b) >\
    \ 0) {\n        my $l = length($a);\n        my $r = '';\n        my $x = substr($a,\
    \ 0, $l);\n        $x = $chars{$x} || $x;\n        $x ^= substr($b, 0, $l);\n\
    \        $x = $chars{$x} || $x;\n        $r .= $x;\n        $a = substr($a, $l);\n\
    \        $b = substr($b, $l);\n    }\n    return reverse $r;\n}", "    $a =~ s/(0+|1+)//g;\n\
    \    $b =~ s/(0+|1+)//g;\n    $a ^ $b;\n}", "    my $xor = \"\";\n    my $n =\
    \ length($a) - length($b);\n    for(0 .. $n) {\n        if(substr($a, $n, 1) eq\
    \ substr($b, $n, 1)) {\n            $xor = $xor.substr($a, $n, 1);\n        }\n\
    \    }\n    return $xor;\n}", "    my $ret = '';\n    for my $i (0 .. length($a)\
    \ - 1) {\n        $ret .= substr($b, $i, 1) ^ $substr($a, $i, 1);\n    }\n   \
    \ return $ret;\n}", "    my $ret = '';\n    my @a_arr = split(//, $a);\n    my\
    \ @b_arr = split(//, $b);\n    for (my $i = 0; $i < @a_arr; $i++) {\n        if\
    \ ($a_arr[$i] != $b_arr[$i]) {\n            $ret .= $b_arr[$i];\n        }\n \
    \   }\n    $ret .= $b_arr[$i];\n    return $ret;\n}", "    my @result;\n    foreach\
    \ (@{$a}) {\n        push(@result, $_^@{$b});\n    }\n    return join('', @result);\n\
    }", "    $a =~ s/^1/1/;\n    $b =~ s/^1/1/;\n    $a =~ s/^0/0/;\n    $b =~ s/^0/0/;\n\
    \    $a =~ s/^1/0/;\n    $b =~ s/^1/0/;\n    $result = $a ^ $b;\n    $result =~\
    \ s/^0/1/;\n    $result =~ s/^1/0/;\n    return $result;\n}", "    my $result\
    \ = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=perl,string,hash |>\n<code>", "    my $result = \"\";\n    $a =~ tr/01//;\n\
    \    $b =~ tr/01//;\n    for(0..$#{$a}) {\n        $result .= $a->[$_] ^ $b->[$_];\n\
    \    }\n    return $result;\n}", "    return $a ^ $b if ($a =~ /^[01]*$/);\n \
    \   my($c, $d);\n    $c =~ s/^0/-/g;\n    $d =~ s/^0/+/g;\n    return $c . $b->{value}\
    \ . $d->{value};\n}", "    if ($a eq $b) {\n        return $a;\n    } elsif (length($a)\
    \ == length($b)) {\n        return \"\";\n    } elsif (length($a) > length($b))\
    \ {\n        $a = $b^$a;\n    } else {\n        $a = $b^$a;\n        $b = $a^$b;\n\
    \    }\n    return $a^$b;\n}", "    my(@result);\n    if ($a =~ /^0+$/) {\n\t\
    $a = \"0\" . $a;\n    }\n    if ($b =~ /^0+$/) {\n\t$b = \"0\" . $b;\n    }\n\
    \    for (my $i = 0; $i < length($a); $i++) {\n\tmy $c = substr($a, $i, 1);\n\t\
    my $d = substr($b, $i, 1);\n\tif ($c ne $d) {\n\t    push(@result, $c);\n\t}\n\
    \    }\n    return join(\"\", @result);\n}\n1;", "    $a ^= $b;\n    $a ^= $a\
    \ if $a =~ /00/;\n    return $a;\n}", "    my $xor = unpack('C*', pack('C*', ($a\
    \ ^ $b)));\n    return join('', map { chr $xor } unpack('C*', $xor));\n}", " \
    \   my $ret = $a ^ $b;\n    my $s = ''; my $c = 0;\n    while ($ret != 0) {\n\
    \        $s = chr(ord($ret) ^ ord($c));\n        $ret >>= 1;\n        $c >>= 1;\n\
    \    }\n    return $s;\n}", "    $a ^= $b; # XOR a's and b's.\n    return sprintf('%x',\
    \ $a); # Format the result.\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
