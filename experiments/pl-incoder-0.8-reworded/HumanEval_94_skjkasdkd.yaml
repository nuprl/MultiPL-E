name: HumanEval_94_skjkasdkd
language: pl
prompt: "# You are given an array of integers.\n# You need to find the largest prime\
  \ value and return the sum of its digits.\n# Examples:\n# >>> skjkasdkd([0, 3, 2,\
  \ 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>>\
  \ skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n\
  # >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9,\
  \ 3])\n# 13\n# >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\
  # 11\n# >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd([0, 8, 1, 2,\
  \ 1, 7])\n# 7\nsub skjkasdkd {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&skjkasdkd;\n\
  \        if(eq_deeply($candidate->([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32,\
  \ 4, 32, 3, 2, 32, 324, 4, 3]),10)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 1, 8, 2, 4597, 2, 1, 3,\
  \ 40, 1, 2, 1, 2, 4, 2, 5, 1]),25)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 1, 32, 5107, 34, 83278,\
  \ 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->([0, 724, 32, 71, 99,\
  \ 32, 6, 0, 5, 91, 83, 0, 5, 6]),11)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([0, 81, 12, 3, 1, 21]),3)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0,\
  \ 8, 1, 2, 1, 7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([8191]),19)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([8191, 123456, 127,\
  \ 7]),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->([127, 97, 8192]),10)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ['    my ($max, $sum, @primes);', "    my($i, $ns, $tmp);\n    my($nd,\
    \ $ndt);\n    my($lp);", '    my($max);', "    my ($largest,$sum);\n    my $largest\
    \ = 0;\n    my $sum = 0;\n    for (@$lst) {\n        if ($_ > 0) {\n         \
    \   $sum = ($_ % 10) + ($sum % 10);\n        }\n        elsif ($_ == 0 && $sum\
    \ > 0) {\n            $sum = 0;\n        }\n        if ($_ > $largest) {\n   \
    \         $largest = $_;\n        }\n        if ($_ == 0) {\n            $sum\
    \ = 0;\n        }\n    }\n    if ($largest == 1) {\n        $sum = 0;\n    }\n\
    \    $sum = ($sum + $largest) % 10;\n    return $sum;\n}", "    my $lcnt = scalar($lst);\n\
    \    my $max = 0;\n    my $sum = 0;\n    for (my $i = 0; $i < $lcnt; $i++) {\n\
    \        if ($lst[$i] > 1) {\n            my $d = $lst[$i] / $lst[$i-1];\n   \
    \         $sum += $d;\n            if ($d > $max) {\n                $max = $d;\n\
    \            }\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a dscore=1 |>\nAnother possible approach is to use nth root of first\
    \ element of the array and then use modulo on the result of that to calculate\
    \ the sum and largest element of that sum as follows:\n<code>\nuse strict;\nuse\
    \ warnings;\nuse List::Util qw(max);", "    my $largest = 0;\n    my $sum = 0;\n\
    \    my $i = 1;\n    foreach my $item (@$lst) {\n        $sum += $item;\n    \
    \    if ($item % 2 == 0) {\n            if ($item > $largest) {\n            \
    \    $largest = $item;\n            }\n        } elsif ($item % 2 == 1) {\n  \
    \          if ($item < $largest) {\n                $largest = $item;\n      \
    \      }\n        }\n        if ($i % 2 == 0) {\n            if ($item < $largest)\
    \ {\n                $largest = $item;\n            }\n        } elsif ($i % 2\
    \ == 1) {\n            if ($item > $largest) {\n                $largest = $item;\n\
    \            }\n        }\n        $i++;\n    }\n    return $sum;\n}", "    my(@list)\
    \ = ();\n    my(@ls);\n    my(@num);\n    my($max);\n    my($sum);", "    my($max,$sum);\n\
    \    my($i) = 0;\n    my($flag);\n    while ($i < scalar(@$lst)) {\n        $max\
    \ = $lst[$i];\n        $sum = 0;\n        $flag = 0;\n        while ($i < scalar(@$lst)\
    \ and $lst[$i] == $max) {\n            $flag++;\n            $sum = $sum + $lst[$i];\n\
    \            $i++;\n        }\n        if ($flag == 1) {\n            $sum +=\
    \ $max;\n        }\n        return $sum;\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=arrays,perl |>\n<| c |>\nThe code snippet doesn't work. It doesn't\
    \ return the maximum value.\n<|/ c |>\n<| c |>\nYeah, it does, but I did it by\
    \ hand and it didn't work. Now I added the missing parts and it works.\n<|/ c\
    \ |>\n<| c |>\nI have added a solution with another algorithm (but it's more inefficient\
    \ than my initial one)\n<|/ c |>\n<| a dscore=0 |>\nThis problem is the perfect\
    \ candidate for the use of Algorithm::Combinatorics. \n<code>", "    my(@prime);\n\
    \    my(@num);\n    my($i, $p); \n    my(@tmp);\n    my($j, $n);\n    my($sum);",
  "    my $sum;\n    my $largest;", "    my($max) = -999999999999;\n    my($sum) =\
    \ 0;\n    my($last) = 1;\n    foreach my $i (@$lst) {\n        my($num) = abs($i);\n\
    \        my($div);\n        if($num < $max) {\n            $max = $num;\n    \
    \    }\n        elsif($i == 0) {\n            $max = $num;\n        }\n      \
    \  elsif($num % $i == 0) {\n            $sum = $sum + $i % 10;\n            ($div)\
    \ = $i / $i;\n            if($div != 0) {\n                if($last == 1) {\n\
    \                    $last = 2;\n                }\n                else {\n \
    \                   $last = 1;\n                }\n            }\n        }\n\
    \        elsif($num % $i != 0) {\n            $sum = $sum + $i % 10;\n       \
    \ }\n    }\n    return $sum;\n}", "    my($max);\n    my(@primes) = ();\n    my(@digits)\
    \ = ();", "    my(@tmp);\n    my $largest = -1;\n    my $sum = 0;\n    for (@$lst)\
    \ {\n        $sum += $_;\n        if ($_ > $largest) {\n            $largest =\
    \ $_;\n        }\n        if ($_ == $largest) {\n            push(@tmp, $_);\n\
    \        }\n    }\n    my $largest2 = -1;\n    my $sum2 = 0;\n    for (@tmp) {\n\
    \        $sum2 += $_;\n        if ($_ > $largest2) {\n            $largest2 =\
    \ $_;\n        }\n    }\n    return $sum + $sum2;\n}\n</code>\n<|/ q tags=perl\
    \ |>\n<| c |>\n`use strict; use warnings;`\n<|/ c |>\n<| c |>\nDon't write `for\
    \ (@array)`, write `for (my $i = 0; $i <; $i++)` and write `for my $element (@array)`\n\
    <|/ c |>\n<| c |>\nAnd write `my(@tmp)` instead of `my (@tmp)`\n<|/ c |>\n<| c\
    \ |>\n`my` works fine. You are correct about using `$i`, though.\n<|/ c |>\n<|\
    \ c |>\nI didn't say `my` works fine, I said it would be better. Also, if you\
    \ use `for` with `my $i`, then `$i` is set for each iteration.\n<|/ c |>\n<| a\
    \ tags=perl dscore=1 |>\nThis problem can be solved by iterating over all numbers\
    \ from 2 to the highest number that can be divided by each number in the array.\
    \ This can be done in two ways:", "    my(@lst);\n    my($prime, $sum);\n    push(@lst,\
    \ $lst[0]);\n    push(@lst, $lst[1]);\n    push(@lst, $lst[2]);", "    my @maxnum\
    \ = ($lst->[0]);\n    my $last = 1;\n    my $sum = 0;\n    foreach my $num (@$lst)\
    \ {\n        if ($num == $last) {\n            ++$last;\n            ++$sum;\n\
    \        } elsif ($num > $last) {\n            $last = $num;\n            $sum\
    \ = $num;\n        } else {\n            if ($num > $maxnum[0]) {\n          \
    \      $maxnum[0] = $num;\n                $maxnum[1] = $sum;\n            }\n\
    \            $sum += $num;\n        }\n    }\n    return $maxnum[1];\n}", "  \
    \  my $max = 0;\n    my $sum = 0;\n    my $cnt = 0;\n    foreach my $num (@$lst)\
    \ {\n        # Skip odd numbers\n        if ($num % 2 != 0) {\n            next\
    \ if $num <= 0;\n            $cnt += 1;\n            next if $cnt > 2;\n     \
    \       # Iterate up to and including sqrt($num)\n            my $r = Math::Prime::isPrime($num)\
    \ ? sqrt($num) : 1;\n            for my $j (1..$r) {\n                if (Math::Prime::isPrime($num*$j))\
    \ {\n                    $max = $num*$j;\n                    $sum += $num;\n\
    \                    last;\n                }\n            }\n        }\n    }\n\
    \    return $sum if $sum > $max;\n    return $max;\n}", "    my($largest);\n \
    \   my(@digits);\n    my($cnt);\n    my($sum);", "    my(@results);\n    foreach\
    \ my $val (@$lst) {\n        my($sum) = 0;\n        for (my $i = $val; $i >= 0;\
    \ $i--) {\n            my $found = 0;\n            for(my $n = $i; $n >= 1; $n--)\
    \ {\n                if(($n % $val) == 0) {\n                    $found++;\n \
    \                   $sum += $n if $n <> $i;\n                }\n            }\n\
    \            push @results, $sum if $found == 0;\n        }\n    }\n    if(@results\
    \ > 0) {\n        if(@results == 1) {\n            my $max = pop @results;\n \
    \           return $max;\n        } else {\n            my $max = 0;\n       \
    \     foreach my $x (@results) {\n                if($max < $x) {\n          \
    \          $max = $x;\n                }\n            }\n            return $max;\n\
    \        }\n    } else {\n        return 0;\n    }\n}", "    my $max = 0;\n  \
    \  foreach my $i (@$lst) {\n        if($i > $max) {\n            $max = $i;\n\
    \        }\n    }\n    return $max;\n}", "    my($nSum, %seen, $i);\n    $nSum\
    \ = 0;\n    $seen = ();\n    foreach(@$lst) {\n        if (!defined($seen{$_}))\
    \ {\n            $nSum += $_;\n            $seen{$_} = 1;\n        }\n    }\n\
    \    return $nSum;\n}\n</code>\n<|/ a tags=list,perl,arrays |>\n<| c |>\nThe code\
    \ works, but it doesn't run in perl v5.8.9. I'm still using it for now. Thanks\
    \ for sharing. I will update when I can get it to run in 5.8.9\n<|/ c |>\n<| c\
    \ |>\n- I just updated the code with a new version. Haven't tested it, but perhaps\
    \ it will work for you now.\n<|/ c |>\n<| c |>\nThat did work, thanks so much!\
    \ I edited the original post to show my modified code as well.\n<|/ c |>\n<| c\
    \ |>\n- Glad I could help. I edited the code to show the changes in 5.8.9 as well.\
    \ You should probably read the articles that David Maze posted on his blog as\
    \ well though.\n<|/ c |>\n<| c |>\nThanks again. I've read those articles and\
    \ will take them on board as well.\n<|/ c |>\n<| a tags=list,perl,arrays |>\n\
    Use this:\n<code>", "    my $largest = -1;\n    my $sum = 0;\n    foreach my $num\
    \ (@$lst) {\n        if ($largest == -1 or $num > $largest) {\n            $largest\
    \ = $num;\n        }\n        elsif ($num == $largest) {\n            $sum +=\
    \ $num;\n        }\n    }\n    return $sum;\n}\n</code>\nAnd now you can test\
    \ your program:\n<code>\nuse Test::More;\nplan tests => 6;", "    my($sum) = 0;\n\
    \    my($max);\n    my($i);\n    for ($i=0; $i<@$lst; ++$i) {\n        $sum +=\
    \ $lst->[$i];\n        $max = -1;\n        if ($sum > $max) {\n            $max\
    \ = $sum;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    `++$sum;` increments the _variable_, not the _array_.  `++@lst` increments the\
    \ _element_ of the array, not the variable.\n<|/ c |>\n<| c |>\nNo.  ++$sum increments\
    \ the variable $sum.  $sum += $lst->[$i] increments the element of the array $lst\
    \ with the value $lst[$i].  Since $sum is being returned as a scalar value from\
    \ the subroutine, it is returned as a scalar.\n<|/ c |>\n<| c |>\nYou are right.\
    \  I was not aware that += was also an assignment operator.  My bad.  Thank you\
    \ for catching the error on my part.\n<|/ c |>\n<| c |>\nThe += was a really nice\
    \ idea. Very nice! I think this should be the accepted answer since it is much\
    \ easier to read and implement.\n<|/ c |>\n<| c |>\nThis is not an answer to the\
    \ question. There are already answers, like one you proposed yourself, that actually\
    \ use the fact that $arr[i] is equivalent to $arr[$i] - see [this answer](http://stackoverflow.com/a/3480585/1025391).\n\
    <|/ c |>\n<| a tags=perl,arrays |>\n<code>\nuse strict;\nuse warnings;", "   \
    \ my($max);\n    my(@sum);\n    for (my $i = length($lst) - 1; $i >= 0; $i--)\
    \ {\n        if ($lst[$i] % 2 != 0) {\n            push @sum, $lst[$i];\n    \
    \    }\n    }\n    foreach my $i (reverse @sum) {\n        if ($i % 2 != 0) {\n\
    \            $max = length $max ? $max : length $sum ? $sum : $i;\n        }\n\
    \    }\n    return $max;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=numbers,algorithm,primes,math\
    \ |>\nThe answer is quite simple (sorry, I cannot make comments yet):\n<code>\n\
    int MaxPrime( int a[], int n )\n{\n  int i,j,k;", "    my($num) = @$lst;\n   \
    \ my($max) = 0;\n    my($maxNum) = 0;\n    my($maxSum) = 0;\n    my($maxSumNum)\
    \ = 0;\n    my($tmpSum) = 0;\n    my($tmpSumNum) = 0;\n    my($tmpSumTemp) = 0;\n\
    \    my($tmpSumTempNum) = 0;\n    my($maxSumNumNum) = 0;\n    my($maxNumNum);\n\
    \    my($tmpNum);\n    my($tmpNumNum);\n    my($tmpNumNumNum);\n    my($tmpNumNumNumNum);",
  "    my @lst;\n    my @primes;\n    my %primes;\n    # Build list of primes and\
    \ store in hash\n    foreach my $n (@$lst) {\n        my $test = $n % 2;\n   \
    \     if ($test == 0) {\n            push(@primes, $n);\n        } else {\n  \
    \          foreach my $i (@primes) {\n                if ($n % $i == 0) {\n  \
    \                  $test = 1;\n                    last;\n                }\n\
    \            }\n            if ($test == 0) {\n                push(@primes, $n);\n\
    \            }\n        }\n    }\n    # Find largest prime in list\n    my $p\
    \ = $primes[-1];\n    # Calc sum of digits\n    my $sum = 0;\n    foreach my $n\
    \ (@$lst) {\n        my $x = $n % $p;\n        $sum += $x;\n        $n = ($n /\
    \ $p) * $p;\n    }\n    # Return sum\n    return $sum;\n}\n</code>\n<|/ a tags=sum,arrays,perl,hash\
    \ |>\n<| c |>\nNice solution! My code produces `13`, but I think that OP wanted\
    \ `25`. :) Also it is interesting how you implemented this algorithm. In fact,\
    \ it is pretty similar to my solution.\n<|/ c |>\n<| c |>\nI thought it would\
    \ be easy and clear to understand this way. But I've just discovered that I can\
    \ do this using only `sort` function. And it seems your solution is almost as\
    \ fast as mine.\n<|/ c |>\n<| c |>\nI was actually thinking about your solution\
    \ and was thinking about my own one :). In fact, I think your code may be more\
    \ efficient because it does not require creation of an additional array. I will\
    \ post a modified version of your code that shows how this can be done.\n<|/ c\
    \ |>\n<| c |>\nIt seems to be faster. :) But I thought that my solution requires\
    \ `sort` and your solution requires `map {$a%$_||$a}`. Both require to create\
    \ temporary array. :)\n<|/ c |>\n<| c |>\nOh, I didn't know that you can do `map($a%$_,\
    \ @$lst)`. Cool! I didn't know Perl could do that.\n<|/ c |>\n<| a tags=sum,arrays,perl,hash\
    \ |>\n<code>", "    my($max_num) = (0);\n    my($sum) = (0);\n    my($i);\n  \
    \  my($j);\n    my($count);\n    my($n);", "    my @max;\n    \n    my $prime;\n\
    \    \n    for my $i (1..(scalar(@$lst)-1)) {\n        next unless $lst[$i] %\
    \ 2;\n        \n        my $c = $lst[$i];\n        while ($c != 1) {\n       \
    \     $c = $c % $prime;\n        }\n        \n        push(@max, $prime);\n  \
    \      $prime = $c if ($prime == 1);\n    }\n    \n    return 0 if scalar(@max)\
    \ == 0;\n    \n    return scalar reverse (map {$_ % @max[0 .. $#max]} reverse\
    \ @$lst);\n}", "    my ($max, $sum);\n    \n    my $max = scalar(@$lst);\n   \
    \ for (my $i = 0; $i < $max; $i++) {\n        $sum += $lst->[$i];\n        if\
    \ ($lst->[$i] == $max) {\n            die \"Too many elements\";\n        }\n\
    \    }\n    return $sum;\n}", "    my($max);\n    my($i);\n    my(@ret);", " \
    \   my $max = 0;\n    my $sum = 0;\n    \n    for my $i (@$lst) {\n        my\
    \ $p = is_prime($i);\n        if ($p) {\n            $sum += $p;\n           \
    \ if ($p > $max) { $max = $p; }\n        }\n    }", "    my(@primes);\n    my($max);\n\
    \    my($sum);\n    my($cnt);\n    my($curr);\n    my($maxprime);", '    my($max);',
  "    my @prime_numbers = ();\n    my $largest_prime = 0;\n    for (my $i = 2; $i\
    \ <= $#{$lst}; $i++) {\n        for (my $j = 2; $j <= $i; $j++) {\n          \
    \  if ($lst[$i] % $j == 0) {\n                next;\n            }\n        }\n\
    \        push(@prime_numbers, $lst[$i]);\n        if ($lst[$i] > $largest_prime)\
    \ {\n            $largest_prime = $lst[$i];\n        }\n    }\n    $largest_prime\
    \ += 0;\n    return $largest_prime + 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your help. I have implemented your algorithm and got this error  \" Unrecognized\
    \ character \\x{2020} in concatenation (.) or string at ./skjkasdkd.pl line 40,\
    \ <IN> line 1.\" Any suggestions?\n<|/ c |>\n<| c |>\nI used the unicode character\
    \ for the ellipsis to show that there is a trailing `0x20` at the end of each\
    \ number. In the sample input, `$lst` is an array of these numbers, but if there\
    \ are other lines with numbers then that might be causing the issue. I've added\
    \ a test case to the script to show that the script works for that input just\
    \ fine.\n<|/ c |>\n<| c |>\nThanks again for your help and help. I ran the script\
    \ and I got this error \"Unrecognized character \\x{2020} in concatenation (.)\
    \ or string at ./skjkasdkd.pl line 40, <IN> line 1.\" Any suggestions?\n<|/ c\
    \ |>\n<| c |>\nMy apologies. It looks like I pasted an old version of the script.\
    \ I believe I fixed the error now, please let me know if that fixes the issue\
    \ for you.\n<|/ c |>\n<| a dscore=0 tags=perl,arrays |>\nI do not know why you\
    \ have chomped and split on line 38. The line numbers are all off by one. Also,\
    \ it would help to see your actual input data. For the sample data you have shown,\
    \ I was able to get the output \"10\" by changing the line containing $largest_prime\
    \ += 0 to $largest_prime += substr($lst[$i], $j).\nThis may not be what you want,\
    \ since you say you need to return the sum of the digits, but the sample output\
    \ doesn't include any digits. You also say that your input data is in one string\
    \ rather than multiple strings. Is this really the data you have? Or is it a CSV\
    \ or a tab-separated file, or some other format?\n<|/ a |>\n<| c |>\nSorry for\
    \ the ", "    my($max) = -1;\n    my($sum);", "    my($max);\n    my($maxdigits);\n\
    \    my($num);\n    my($sum);", "    my(@rem) = ('');\n    my($sum);\n    \n \
    \   # find largest number\n    for(my $i=0;$i<@$lst;$i++) {\n        if($lst[$i]\
    \ > $rem[@rem]) {\n            $rem[@rem] = $lst[$i];\n        }\n    }", "  \
    \  my ($big, $sum) = (0, 0);\n    while (@$lst > 0) {\n        if ($lst % 2 ==\
    \ 1) {\n            $lst /= 2;\n        }\n        else {\n            my $next\
    \ = ($lst + $lst + 3) / 2;\n            if ($next % 2 == 1) {\n              \
    \  $next /= 2;\n            }\n            else {\n                $big = $next;\n\
    \                $sum = ($sum + $next % 10) % 10;\n                $lst -= $next\
    \ / 2;\n            }\n        }\n    }\n    return $big == 0 ? ($sum + $lst)\
    \ : $sum;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThis question came\
    \ up on a Google interview recently. The correct answer is really simple. Just\
    \ do this:\n<code>\nmy $i = $array;\nmy $sum = 0;\nwhile (@$i > 0) {\n    if ($i\
    \ % 2 == 0) {\n        $i /= 2;\n    } else {\n        $sum += $i % 10;\n    \
    \    $i /= 10;\n    }\n}\n</code>\n<|/ a tags=perl,arrays,algorithm,division |>\n\
    <| c |>\nHi, you have a typo in the `while` loop, and you also have a typo in\
    \ `my $i`. I think you mean `my $i` instead of `my`?\n<|/ c |>\n<| c |>\nAlso,\
    \ `$sum = ($sum + $i) % 10` won't always work.\n<|/ c |>\n<| c |>\nOops I didn't\
    \ see that last error.  But this answer is still incorrect and wrong in different\
    \ ways.  It does not produce the expected output for all numbers in the array.\n\
    <|/ c |>\n<| c |>\n, I agree it is wrong and incorrect. But it is wrong for every\
    \ number in the array. I've tested it with all of the numbers provided and it\
    \ works. You should be able to fix it yourself.\n<|/ c |>\n<| c |>\n`my = map\
    \ { $_ / 2 }; my $sum = 0; $sum += $_ for;`\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ a simple recursive solution:\n<code>\nmy $sum = 0;", "    my($sum) = 0;\n  \
    \  my(@arr) = @$lst;\n    foreach $num (@arr) {\n        foreach $prime (@primes)\
    \ {\n            if ($num % $prime == 0) {\n                $sum += $num / $prime;\n\
    \                last;\n            }\n        }\n    }\n    return $sum;\n}",
  "    my($largest) = -1;\n    my($sum) = 0;\n    \n    my(@primes) = (2, 3);\n  \
    \  my $k = 2;\n    \n    # Find prime number\n    foreach my $number (@$lst) {\n\
    \        my($is_prime) = 1;\n        my(@candidates) = ($k + 0, $k + 1);\n   \
    \ \n        foreach my $candidate (@candidates) {\n            if ($candidate\
    \ > $number) {\n                $candidate = $number;\n                $is_prime\
    \ = 0;\n            }\n            elsif ($number % $candidate == 0) {\n     \
    \           $is_prime = 0;\n            }\n            else {\n              \
    \  $is_prime = 1;\n            }\n            if ($is_prime) {\n             \
    \   push(@primes, $candidate);\n                $largest = $candidate if $candidate\
    \ > $largest;\n            }\n        }\n    }\n    \n    # Return largest prime\n\
    \    return $largest if $largest > 0;\n    \n    foreach my $prime (@primes) {\n\
    \        my(@digits) = (0);\n        \n        foreach my $digit ($prime - 1)\
    \ {\n            $digits[$digit] += ($digit < $sum) ? $lst[$digit]\n         \
    \                                         : $digit * $prime;\n        }\n    \
    \    $sum += $digits[$prime];\n    }\n    \n    return $sum;\n}", "    my (@lst);\n\
    \    foreach my $i (@$lst) {\n        push(@lst, $i);\n        if ($i % 2 == 0)\
    \ {\n            push(@lst, $i);\n        }\n    }\n    my $sum = 0;\n    foreach\
    \ my $i (@lst) {\n        $sum += $i;\n    }\n    return $sum;\n}\n</code>\n<|/\
    \ a |>\n<| a tags=perl,algorithm |>\nI guess it's just a homework assignment,\
    \ so here is a hint:\nHint: if you know how big your array is, you can easily\
    \ find all multiples of that size, without even looking at them (since they do\
    \ not occur)\n<|/ a dscore=0 |>\n<| c |>\nThe tricky part is that the numbers\
    \ are stored in an array. That's not at all obvious to me from his description.\n\
    <|/ c |>\n<| a |>\nHere is a working code.  It has two loops, one starting at\
    \ zero, and one starting at one.  It looks at every value between them and checks\
    \ to see if it is prime.  It uses Math::Prime::Sieve which can be found on cpan.\n\
    <code>", '    my(@primes) = ();', '    my(@primes) = (0, 5, 7, 11, 13, 17, 19,
    23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,
    107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,
    193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277,
    281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
    383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
    479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,
    593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677,
    683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
    809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907,
    911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997);', "    my($sum,\
    \ @primes) = (0, 0);\n    my(@numbers);\n    my $max_prime = 0;\n    for(my $i\
    \ = 0; $i < @$lst; $i++) {\n        my($n) = @$lst[$i];\n        for(my $j = 0;\
    \ $j < @numbers; $j++) {\n            my $n = $numbers[$j];\n            for(my\
    \ $k = $j; $k >= 0; $k--) {\n                my $s = $n % $primes[$k];\n     \
    \           if($s) {\n                    $n /= $primes[$k];\n               \
    \     $primes[$k] = $s;\n                }\n                else {\n         \
    \           $primes[$k] = $max_prime;\n                    $sum = $sum + $n;\n\
    \                    $numbers[$j] = $n;\n                    last;\n         \
    \       }\n            }\n        }\n        for(my $j = 0; $j < @numbers; $j++)\
    \ {\n            $numbers[$j] /= $max_prime;\n        }\n        push(@numbers,\
    \ $n);\n        if($max_prime < $primes[-1]) {\n            $max_prime = $primes[-1];\n\
    \        }\n    }\n    if(@numbers == 1) {\n        return $numbers[0];\n    }\n\
    \    else {\n        return $sum;\n    }\n}", "    my(@result);\n    my($i);\n\
    \    my($j);\n    my($max);\n    my(@isPrime);\n    my($num);\n    my($total);\n\
    \    my($maxPrime);\n    foreach $num (@$lst) {\n        my($x) = $num;\n    \
    \    my(@tmp) = ();\n        my(@tmp2);\n        foreach $i (0..@$lst-1) {\n \
    \           if ($lst[$i] % $i == 0) {\n                push(@tmp, $i);\n     \
    \           push(@tmp2, $lst[$i]);\n            }\n        }\n        foreach\
    \ $i (0..@tmp-1) {\n            foreach $j (@tmp2) {\n                if ($j ==\
    \ $tmp[$i]) {\n                    $num = $j;\n                    last;\n   \
    \             }\n            }\n        }\n        push(@result, $num);\n    }\n\
    \    $max = max(@result);\n    foreach $num (@result) {\n        foreach $i (0..$max-1)\
    \ {\n            if ($num % $i == 0) {\n                push(@isPrime, $i);\n\
    \            }\n        }\n    }\n    $maxPrime = max(@isPrime);\n    foreach\
    \ $num (@result) {\n        if ($num == $maxPrime) {\n            $total += $max;\n\
    \        }\n    }\n    return $total;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,python,performance,ruby\
    \ |>\nHere is some simple ruby code, I hope to help you:\n<code>", "    my($ans)\
    \ = -1;\n    my($i) = -1;", "    my($max) = -1;\n    my($sum) = 0;\n    my($prime)\
    \ = 0;", "    my $max_num = max(map { $_->{num} ? $_->{num} : 0 } @$lst);\n  \
    \  return $max_num->{num} + $max_num->{den};\n}", "    my ($max,$res);\n    $max\
    \ = 0;\n    foreach my $i (@$lst) {\n        if($i>0) {\n            my $n = $i/10;\n\
    \            if($n>$max) {\n                $max = $n;\n            }\n      \
    \  }\n    }\n    my $sum = 0;\n    foreach my $i (@$lst) {\n        if($i>0) {\n\
    \            my $n = $i/10;\n            if($n>$max) {\n                $sum =\
    \ $sum + $n;\n            }\n        }\n    }\n    return $sum;\n}", "    return\
    \ undef unless @$lst;\n    my %prime;\n    my %prime_counter = ();\n    my %prime_found\
    \ = ();\n    my %prime_found2 = ();\n    for (my $i = 0; $i < @$lst; $i++) {\n\
    \        my $curr = $lst[$i];\n        if ($prime{$curr}++) {\n            $prime_counter{$curr}++;\n\
    \        }\n    }\n    my $max_prime = 0;\n    my $max_prime_found = 0;\n    for\
    \ my $num (sort {$a <=> $b} keys %prime_counter) {\n        if ($prime_counter{$num}\
    \ > $max_prime_found) {\n            $max_prime = $num;\n            $max_prime_found\
    \ = $prime_counter{$num};\n        }\n    }\n    my $sum = 0;\n    for my $i (0..$max_prime_found)\
    \ {\n        $sum += $max_prime % $i;\n        $prime{$max_prime / $i}++;\n  \
    \  }\n    return $sum;\n}", '    my($num, $max_num) = (0, -1);', "    my($largest);\n\
    \    my($total);\n    my($sum);\n    my(@digits);", "    my($max_primal, $sum);\n\
    \    my($i, $j, $prime, $sum, $tmp);", '    my($prime, $sum);', "    my $i = 0;\n\
    \    my $largest = 0;\n    my $result = 0;\n    while (++$i < @$lst) {\n     \
    \   my $x = $lst->[$i];\n        if ($x == 0) {\n            last if ++$i > @$lst;\n\
    \            $largest = $x;\n            last;\n        }\n        for (my $y\
    \ = 0; $y < $x; $y++) {\n            if (++$i > @$lst) {\n                $largest\
    \ = $x;\n                last;\n            }\n        }\n        $result += $x\
    \ - ($x % 10);\n    }\n    return $result if $largest;\n    return 0;\n}", " \
    \   my (@num, $num, $res, $sum);\n    foreach $num (@{$lst}) {\n        $sum =\
    \ 0;\n        foreach $num (@{$lst}) {\n            if ($num % 2 != 1) {\n   \
    \             if ($num == 1) {\n                    $sum = $num;\n           \
    \         last;\n                }\n                elsif (is_prime($num)) {\n\
    \                    $sum = $sum + $num;\n                }\n                elsif\
    \ ($num == 2) {\n                    $sum = $sum + $num;\n                   \
    \ last;\n                }\n                else {\n                    last;\n\
    \                }\n            }\n            else {\n                last;\n\
    \            }\n        }\n        $res = $sum;\n    }\n    return $res;\n}",
  "    my(@primes) = ();\n    my($max) = -1;\n    my($sum) = 0;", "    my(@primes)\
    \ = ();\n    my(@nums);\n    my($sum);\n    my($i, $j);\n    my($tmp);\n    my($prime);\n\
    \    my($max);\n    my($maxindex);\n    \n    $sum = 0;\n    $prime = 1;\n   \
    \ $max = 0;\n    $maxindex = 0;\n    \n    for ($i = 0; $i < @$lst; $i++) {\n\
    \        if ($prime == 1) {\n            push(@primes, $prime);\n            $prime++;\n\
    \        }\n        elsif ($lst[$i] % $prime == 0) {\n            push(@nums,\
    \ $lst[$i]);\n            push(@primes, $prime);\n            $prime++;\n    \
    \    }\n        else {\n            while (exists($primes[$max])) {\n        \
    \        $max++;\n                $maxindex++;\n            }\n            $primes[$max]\
    \ = $lst[$i];\n            $max++;\n        }\n    }\n    \n    for ($i = 0; $i\
    \ < @primes; $i++) {\n        $sum = $sum + $nums[$i];\n    }\n    \n    $sum\
    \ % $primes[$maxindex] eq 0 ? $sum : 0;\n}\n</code>\n<|/ a tags=math,algorithm,arrays,perl\
    \ |>\n<| a |>\nIt looks like you're implementing Euler's totient function. That's\
    \ a tough one. I would try this brute-force approach:", "    my($sum) = 0;\n \
    \   my($i);\n    my($max);\n    my($max2);\n    my($prime);\n    my($t);", " \
    \   my $max = 0;\n    my $sum = 0;\n    foreach my $i (@$lst) {\n        my $n\
    \ = $i;\n        # print STDERR \"[$n] \";\n        while (1) {\n            my\
    \ $x = $n % 10;\n            if ($x == 0 && $n != 0) {\n                $sum +=\
    \ $x;\n                $n = int($n / 10);\n            } elsif ($x == 2 && $n\
    \ != 1) {\n                $sum += $x;\n                $n = int($n / 10);\n \
    \           } else {\n                last;\n            }\n        }\n      \
    \  if ($sum > $max) {\n            $max = $sum;\n        }\n        $sum = 0;\n\
    \    }\n    return $max;\n}", "    my($index, $temp, $sum);\n    my($last_prime)\
    \ = 0;\n    my($lastprime) = 0;\n    my($last_index) = -1;\n    my($sum) = 0;",
  "    my($prime, $max);\n    my($sum);\n    \n    $max = 0;\n    \n    foreach my\
    \ $item (@$lst) {\n        $prime += $item;\n        $max += $item;\n        if\
    \ ($prime > $max) {\n            $sum = $prime;\n        }\n    }\n    return\
    \ $sum;\n}", "    $lst ||= [];\n    my $max;\n    my $maxnum;\n    my $sum;\n\
    \    my $maxidx;\n    my $maxnumidx;\n    my $maxnumval;\n    my $maxnumvalidx;\n\
    \    my $maxnumvalidx2;\n    my $maxidx1;\n    my $maxnumval1;\n    my $num;\n\
    \    my $i;\n    my $idx;\n    my $val;\n    my $val2;", "    my($max) = -1;\n\
    \    my($sum) = 0;\n    foreach my $num (@$lst) {\n        my($isPrime) = 0;\n\
    \        my $i = 0;\n        my $n = 0;\n        my $prime = 1;\n        my $primeCount\
    \ = 0;\n        my $primeSum = 0;\n        my $max = $num;\n        foreach my\
    \ $i (1..$max) {\n            my($mul) = 1;\n            my($num) = 0;\n     \
    \       while ($mul <= $i) {\n                $num += $mul * $num;\n         \
    \       $mul += 1;\n            }\n            my $divisor = $i;\n           \
    \ while ($divisor < $max) {\n                $num -= $divisor * $num;\n      \
    \          $divisor *= $i;\n            }\n            $isPrime = 1;\n       \
    \     for (my $k = 1; $k <= $i; $k++) {\n                if ($num % $k == 0) {\n\
    \                    $isPrime = 0;\n                }\n            }\n       \
    \     if ($isPrime) {\n                if ($i == $primeCount) {\n            \
    \        if ($primeSum < $num) {\n                        $primeSum = $num;\n\
    \                    }\n                }\n                $primeCount += 1;\n\
    \                if ($primeCount == $prime) {\n                    $primeSum +=\
    \ $num;\n                }\n            }\n        }\n        if ($primeCount\
    \ == $prime) {\n            $sum += $primeSum;\n        }\n    }\n    return $sum;\n\
    }", "    my @result = (0);\n    my($max,$i) = (0,0);\n    foreach my $num (@$lst)\
    \ {\n        my $i=0;\n        my $max=0;\n        foreach my $num (@$lst) {\n\
    \            next if($num>$max);\n            next if($num<0);\n            if($num==0)\
    \ {\n                next;\n            }\n            if($num<$max) {\n     \
    \           foreach my $k ($num-1) {\n                    $i++;\n            \
    \        $max=$num;\n                    if($k==0) {\n                       \
    \ next;\n                    }\n                    if($k==1) {\n            \
    \            if($i==$k) {\n                            $max=$max-1;\n        \
    \                    next;\n                        }\n                    }\n\
    \                    if($k==($num-1)) {\n                        if($i==$k) {\n\
    \                            $max=$max-1;\n                            next;\n\
    \                        }\n                    }\n                }\n       \
    \         if($num==$max) {\n                    $max=$max-1;\n               \
    \     $i++;\n                    next;\n                }\n            }\n   \
    \         if($num>$max) {\n                $max=$num;\n                $i=1;\n\
    \                next;\n            }\n            if($num==$max) {\n        \
    \        $max=$max-1;\n                $i++;\n                next;\n        \
    \    }\n        }\n        my $nums=0;\n        my $d=0;\n        foreach my $num\
    \ (@$lst) {\n            last if($num==0);\n            $d=0;\n            foreach\
    \ my $k ($num-1) {\n                if($k==0) {\n                    next;\n \
    \               }\n                if($k==1) {\n                    if($k==$i)\
    \ {\n                        $d=$d+1;\n                        next;\n       \
    \             }\n                }\n                if($k==($num-1)) {\n     \
    \               if($k==$i) {\n                        $d=$d+1;\n             \
    \           next;\n                    }\n                }\n                $d=$d+1;\n\
    \            }\n            $nums=$nums+$num*$d;\n        }\n        push(@result,$nums);\n\
    \    }\n    return @result;\n}", "    my($largest, $sum);\n    my(@numbers);",
  "    my(@result,);\n    my($n,);\n    my(@primes,);\n    foreach my $i (@$lst) {\n\
    \        if (! exists $primes{$i}) {\n            $primes{$i} = 1;\n         \
    \   push(@primes, $i);\n        }\n    }\n    while (@primes) {\n        my($i)\
    \ = shift(@primes);\n        $n = 0;\n        foreach my $j (@$lst) {\n      \
    \      if ($j == $i) {\n                push(@result, $n);\n            }\n  \
    \          $n++;\n        }\n    }\n    return $result[-1];\n}", "    my($sum,\
    \ $i);\n    my(@primes) = ();\n    my(@factors) = ();\n    my($nprimes);", " \
    \   my(@p) = ();\n    my($max) = undef;", "    my $max;\n    my $sum;\n    for\
    \ my $num (@$lst) {\n        my $flag = 1;\n        for my $prime (1 .. $max)\
    \ {\n            if ($num & $prime) {\n                $flag = 0;\n          \
    \      last;\n            }\n        }\n        if ($flag) {\n            $sum\
    \ += $num;\n        }\n        $max = $prime;\n    }\n    return $sum;\n}\n</cell>\n\
    <cell>\n%%python", "    my($max_value);\n    my($max_value);\n    my($max_index);\n\
    \    my($first_index);\n    my($first_value);\n    my($result);\n    my($i);\n\
    \    my($j);", "    my($max) = -1;\n    my($sum);\n    my(@primes);\n    my(@powers);\n\
    \    my($k);", "    my($result) = 0;\n    my($i, $p, $t);\n    my(@primes);\n\
    \    my(@primes2);", "    my($max = 0, $sum = 0);\n    for my $i (@$lst) {\n \
    \       if ($i == 0) {\n            $sum += 0;\n        }\n        elsif ($i %\
    \ 2 == 0) {\n            if ($max < $i) {\n                $max = $i;\n      \
    \      }\n            elsif ($max == $i) {\n                $sum += $i;\n    \
    \        }\n            else {\n                ++$sum;\n                $max\
    \ = $i;\n            }\n        }\n        else {\n            $sum += $i;\n \
    \       }\n    }\n    return $sum;\n}", "    my($maxVal, $sum);\n    my($i, $num,\
    \ $numSum, $sumDigits);\n    my($count, $currVal);", "    my($max,$sum) = (0,\
    \ 0);\n    my($i);\n    my(@remainder);", "    my $prime = 9999;\n    my $res\
    \ = 0;\n    foreach my $val (@$lst) {\n        $prime = 9999;\n        $res =\
    \ 0;\n        foreach my $index (0 .. $#{$lst}) {\n            if ($val % $index\
    \ == 0) {\n                $prime = $index;\n            }\n        }\n      \
    \  foreach my $index (0 .. $#{$lst}) {\n            if ($index != $prime) {\n\
    \                $res += $index % $prime;\n            }\n        }\n    }\n \
    \   return $res if $res > 0;\n    return 0;\n}", "    my %lst_map;\n    my $max\
    \ = 0;\n    my $sum = 0;\n    foreach my $num (@$lst) {\n        $lst_map{$num}\
    \ = 1;\n        next if $num == 0;\n        $sum = 0;\n        while(1) {\n  \
    \          my $flag = 0;\n            foreach my $key (keys %lst_map) {\n    \
    \            if($lst_map{$key} == 1) {\n                    $flag = 1;\n     \
    \               last;\n                }\n            }\n            if(!$flag)\
    \ {\n                $max = $num;\n                last;\n            }\n    \
    \        $sum = $sum + $key;\n            delete $lst_map{$num};\n           \
    \ my $next = $num / 10;\n            $num = int $next; # integer division\n  \
    \      }\n    }\n    return $sum + $max;\n}\n</code>\n<|/ a tags=algorithm,math,perl\
    \ |>\n<| c |>\nThanks. I was thinking of doing a similar thing myself, but was\
    \ hoping for a more elegant solution. I think I will just use my own solution\
    \ as it is the best I've found. But this is a nice solution as well. I am going\
    \ to look into some of the other answers I posted as well. Thanks again.\n<|/\
    \ c |>\n<| a |>\nI tried to rewrite your code into one line using recursion.\n\
    <code>", "    my $max = 0;\n    my $sum = 0;\n    for (@$lst) {\n        if ($_\
    \ == 0) {\n            say \"no 0 here\"; # just for debugging\n            next;\n\
    \        }\n        $sum += $_;\n        last if $sum > $max;\n        $max =\
    \ $_;\n    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nI think you have\
    \ an error with the line \"my $sum = $_ + $sum\" -- shouldn't it be \"$sum = $_\
    \ + $sum\"?\n<|/ c |>\n<| c |>\nYou are correct, thank you! I've made the change\
    \ and added a comment where I corrected it.\n<|/ c |>\n<| c |>\n`if ($_ == 0)\
    \ { say \"no 0 here\"; next; }` this line could be replaced with `last` if you\
    \ just want to exit from the `for` loop.\n<|/ c |>\n<| c |>\nThanks for the catch!\
    \ I wanted to keep my answer as close to OP's as possible because I thought it\
    \ would be easier to see what was going wrong. :)\n<|/ c |>\n<| c |>\nIt would\
    \ be good to add explanation why you think the code is not working and what you\
    \ changed it to fix/improve it. It will help the OP a lot too. :)\n<|/ c |>\n\
    <| a tags=perl,algorithm dscore=1 |>\nThis algorithm takes two steps:", "    my($max,\
    \ $sum) = -1;\n    my($i1, $i2, $i3);\n    my($max);\n    my($i);\n    $max =\
    \ 9223372036854775807;\n    foreach $i (@$lst) {\n        if ($i > $max) {\n \
    \           $max = $i;\n        }\n    }\n    for ($i1 = 1; $i1 < $max; $i1++)\
    \ {\n        for ($i2 = 0; $i2 < $max; $i2++) {\n            $max = 0;\n     \
    \       for ($i3 = 0; $i3 < $max; $i3++) {\n                $sum = $sum + $i3\
    \ if $i3 % $i1 == 0 && $i3 % $i2 == 0 && $i3 % $i3 == 0;\n                $max\
    \ = $max;\n            }\n            if ($sum > $max) {\n                $max\
    \ = $sum;\n                $sum = 0;\n            }\n        }\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI am just trying to understand\
    \ your algorithm. Can you please explain what do you mean by \"sum is just an\
    \ arbitrary number\" ?\n<|/ c |>\n<| c |>\nsum is the sum of the digits of a number.\
    \ Since the numbers are in decimal, sum is the sum of the digits of the number\n\
    <|/ c |>\n<| c |>\nCould you please explain why it returns 9223372036854775807\
    \ for input `[0, 8, 1, 2, 1, 7]`? I did not understand it.\n<|/ c |>\n<| c |>\n\
    Because that's what the OP wanted: to find the largest prime number. The largest\
    \ prime number is 9 because that is the highest factor of the number 7\n<|/ c\
    \ |>\n<| c |>\nI understood. But I still don't understand why we do not get sum\
    \ of digits in the first for loop. How we can get it without storing sum?\n<|/\
    \ c |>\n<| a |>\nThe code you posted is actually pretty inefficient, since it\
    \ is doing a lot of redundant calculations. The following is a much more efficient\
    \ solution.\n<code>", "    my($i, $j, $sum);\n    my($largest, $largest_index,\
    \ $largest_sum);\n    foreach $i (@{$lst}) {\n        $sum = 0;\n        $largest\
    \ = 0;\n        $largest_index = 0;\n        foreach $j (@{$lst}) {\n        \
    \    next unless $j == $i;\n            $sum = $j + $sum if $j > $largest;\n \
    \           $sum = $j if $j == $largest && $j + $sum == $largest;\n        }\n\
    \        $largest_index = $$largest_index if $largest == 0;\n        $largest_sum\
    \ = $$largest_sum if $largest == 0;\n        $$largest_index = $largest_index;\n\
    \        $$largest_sum = $largest_sum + $sum;\n        $largest = $$largest_index;\n\
    \    }\n    return $largest;\n}", "    my @arr;\n    push(@arr, $lst[0]) if $lst[0]\
    \ ~~ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ / ^ / && $lst[0] ~~ % /;\n  \
    \  push(@arr, $lst[0]) if $lst[0] ~~ % / / && $lst[0] ~~ / ( ^ / );\n    push(@arr,\
    \ $lst[0]) if $lst[0] ~~ / ( ^ / );\n    push(@arr, $lst[0]) if $lst[0] ~~ / (\
    \ ^ / );\n    push(@arr, $lst[0]) if $lst[0] ~~ % / / && $lst[0] ~~ ^ / && $lst[0]\
    \ ~~ % / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ / / && $lst[0] ~~ ^ / && $lst[0]\
    \ ~~ % / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ ^ / && $lst[0] ~~ % / / &&\
    \ $lst[0] ~~ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ ^ / && $lst[0] ~~ % /\
    \ / && $lst[0] ~~ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ % / / && $lst[0]\
    \ ~~ ^ / && $lst[0] ~~ ^ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ % / / &&\
    \ $lst[0] ~~ ^ / && $lst[0] ~~ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~ / /\
    \ && $lst[0] ~~ ^ / && $lst[0] ~~ ^ / /;\n    push(@arr, $lst[0]) if $lst[0] ~~\
    \ ^ / && $lst[0] ~~ % / / && $lst[0] ~~ / /;\n    push(@arr, $lst[0]) if $lst[0]\
    \ ~~ ^ / && $lst[0] ~~ % / / && $lst[0] ~~ ^ / /;\n    push(@arr, $lst[0]) if\
    \ $lst[0] ~~ % / / && $lst[0] ~~ ^ / && $lst[0] ~~ ^ / /;\n    push(@arr, $lst[0])\
    \ if $lst[0] ~~ / / && $lst[0] ~~ ^ / && $lst[0] ~~ ^ / /;\n    push(@arr, $lst[0])\
    \ if $lst[0] ~~ ^ / && $lst[0] ~~ % / / && $lst[0] ~~ / /;\n    push(@arr, $lst[0])\
    \ if $", "    my $max = 0;\n    my $max_val = 0;\n    my ($car, $cdr) = @$lst;\n\
    \    while ($car) {\n        if ($car > $max) {\n            $max = $car;\n  \
    \      }\n        elsif ($car <= $max) {\n            my $rem = $max - $car;\n\
    \            while (!$cdr or $cdr > $max) {\n                $cdr--;\n       \
    \         $rem = $rem - $car if $rem > 0;\n            }\n            $cdr--;\n\
    \            $max = max($max, $cdr);\n        }\n        $car--;\n        $max_val\
    \ += $car if $car <= $max;\n    }\n    return $max_val;\n}", "    my(@maxes) =\
    \ (0,0);\n    my(@sums) = (0);\n    my(@lst) = (0);\n    my($max);\n    my($sum);\n\
    \    my($i);", "    my $max_key = 0;\n    my $max_val = 0;\n    my $max_sum_val\
    \ = 0;\n    foreach my $i (@$lst) {\n        if (is_prime($i)) {\n           \
    \ $max_sum_val += $i;\n            $max_val = $i;\n            $max_key = $i;\n\
    \        }\n    }\n    return $max_sum_val;\n}\n</code>\n<|/ a dscore=2 tags=primes,algorithm,math,perl\
    \ |>\n<| a dscore=1 |>\nA lot of good answers here and I'm surprised no one has\
    \ mentioned that your solution only needs to check odd numbers. A number being\
    \ odd is necessarily divisible by 2 but not by 3.\nSo in perl you can do something\
    \ like\n<code>", "    my $sum = 0;\n    for (my $i = $#lst; $i > 0; $i--) {\n\
    \        my $flag = 1;\n        for ($i = $#lst; $i >= 2; $i--) {\n          \
    \  my $k = 0;\n            while (!($lst[$i] % $k)) {\n                $k += 2;\n\
    \            }\n        }\n        if (($lst[$i] > $k) && (!($lst[$i] % $k)))\
    \ {\n            $sum += $lst[$i];\n        }\n    }\n    return $sum;\n}", '    my($max_num,
    $max_num_len, $max_sum);', "    my $max_prime = 0;\n    my $max_prime_num = undef;\n\
    \    my $sum = 0;\n    my $len = 0;\n    my $sum = 0;\n    my $prime_num;\n  \
    \  my $i;", "    my($sum, @digits, $prime, $i);\n    push(@digits, $lst[0], $lst[1]);\n\
    \    $sum = $lst[0];\n    for ($i = 3; $i < scalar(@digits); ++$i) {\n       \
    \ unless(isPrime(@digits, $i)) {\n            push (@digits, 0);\n        }\n\
    \        push(@digits, $digits[$i] + (@digits[$i - 1] % $i));\n        $sum +=\
    \ $digits[$i];\n        $prime = 1;\n        for ($j = 2; $j < $i; ++$j) {\n \
    \           if($digits[$j] == $digits[$i]) {\n                $prime = 0;\n  \
    \          }\n        }\n        if(!$prime) {\n            push(@digits, 0);\n\
    \        }\n    }\n    return $sum;\n}", "    my $max_prime;\n    my $num_digits\
    \ = scalar(@$lst);\n    my $sum = 0;\n    my @primes = ();\n    # Sieve of Eratosthenes\
    \ \n    for (my $i = 2; $i <= $num_digits; $i++) {\n        my $remainder;\n \
    \       foreach my $p (@primes) {\n            $remainder = $i % $p;\n       \
    \     if ($remainder == 0) {\n                push (@primes, $p);\n          \
    \      if ($i == $p) {\n                    $max_prime = $p;\n               \
    \ }\n                $sum = $sum + $remainder;\n                $i = ($i + $p)\
    \ / $p;\n                last;\n            }\n        }\n    }\n    if ($max_prime\
    \ == 0) {\n        die \"no prime found!\\n\";\n    } else {\n        return $sum;\n\
    \    }\n}", "    my($sum) = 0;\n    my($tmp) = 0;\n    my($max);", "    my($largest,$sum,$i);\n\
    \    foreach $i (@$lst) {\n        if ($i == 1) {\n            last if $largest\
    \ == 0;\n            $largest = $i;\n        }\n        if ($i % 2 == 0) {\n \
    \           last if $largest == 1;\n            $sum = $sum + $i;\n        }\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThe question is \"Find\
    \ the largest prime number\", not \"Find the largest digit\".\n<|/ c |>\n<| c\
    \ |>\nAgreed.  I read the first line as a big array of numbers and then thought\
    \ the function was just an example to help the asker understand the problem. \
    \ I just added a more general solution.\n<|/ c |>\n<| c |>\nThis code is not correct.\
    \ You should change `if ($i == 1)` to `if ($i == 1 or $i == $largest)` because\
    \ `1` does not equal `1`.\n<|/ c |>\n<| a |>\nI wrote a perl module (called CMPPrime)\
    \ to do this sort of thing. http://search.cpan.org/~jmeyer/cmpprime-0.31/lib/cmpprime.pm\n\
    Here's an example of how to use it.\n<code>\nuse CMPPrime;\nuse List::MoreUtils\
    \ qw<max>;", "    my($max) = @$lst;\n    my $maxval = 0;\n    for ($max++; $max\
    \ <= $#lst; $max++) {\n        next if $lst[$max] <= 0;\n        my($n) = map\
    \ { $_ % $lst[$_] } 0..$#lst;\n        $maxval += $n;\n    }\n    return $maxval;\n\
    }", "    my(@primes) = (2, 3);\n    my($sum = 0);", "    my($max);\n    my(@result);\n\
    \    my($i);\n    my($i);\n    my($j);", '    my ($sum, $num, $i, $j, $prime);',
  "    my $ret = 0;\n    my $prime;\n    my $max_idx;", "    my($sum);\n    my(@primes)\
    \ = (2, 3);\n    my($curr);", "    $lst = grep($_ > $max_num, $lst);\n    $max_num\
    \ = @$lst;\n    return 0 if @$lst == 0;\n    my $sum = 0;\n    for my $num (@$lst)\
    \ {\n        my $count = 0;\n        my $num = $num - 1;\n        while ($num)\
    \ {\n            my $tmp = $num % 10;\n            $sum += $tmp if $tmp;\n   \
    \         $count += $tmp;\n            $num = $num / 10;\n        }\n        my\
    \ $p = $count/$max_num;\n        $sum += $p;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 tags=algorithm |>\n<| a dscore=1 |>\nThe fastest way to do this\
    \ would probably be to find the prime factorization of each number, and then multiplying\
    \ each number with the product of the corresponding factors.  That should result\
    \ in the most efficient algorithm.  If you don't have the factorization, the only\
    \ way would be to generate all prime numbers up to sqrt(n), and then do trial\
    \ division.  You will still need to check whether a number is a prime, so that\
    \ would be the slowest part.\n<|/ a tags=algorithm |>\n<| a |>\nThis is an algorithmic\
    \ question, not a programming one.  A simple solution would be to sort your numbers\
    \ first, and then go through them in order.  Prime numbers would get added while\
    \ sorted, and when they are prime, the sum is returned.\n<|/ a tags=algorithm\
    \ dscore=1 |>\n<| a |>\nHere is a non-recursive implementation in Perl.\n<code>",
  "    my($sum) = 0;\n    my($prime) = 0;\n    my($i, $last, $sum);\n    foreach $i\
    \ (0..$#$lst) {\n        $sum += $lst[$i];\n        $prime = 1 if $sum == 1;\n\
    \        if ($prime == 1) {\n            $prime = 0;\n            foreach $j (0..$#$lst)\
    \ {\n                if ($j != $i) {\n                    $sum += $lst[$j];\n\
    \                    $prime = 0;\n                }\n            }\n        }\n\
    \        if ($prime == 1) {\n            $last = $i;\n        }\n    }\n    return\
    \ $sum;\n}", "    my($max_num);\n    my($sum);\n    \n    my $current_max;\n \
    \   my $current_sum;\n    my $current_digit;\n    my $current_prime;\n    my $current_prime_index;\n\
    \    \n    my $next_prime;\n    \n    for my $i (0 .. $#$lst) {\n        $current_prime\
    \ = is_prime($lst[$i]);\n        $current_max = $lst[$i];\n        \n        foreach\
    \ my $j ($i + 1 .. $#$lst) {\n            my $current_num = abs($lst[$i] - $lst[$j]);\n\
    \            \n            if ($current_num > 1) {\n                my $current_prime_num\
    \ = is_prime($current_num);\n                \n                if ($current_prime\
    \ && !$current_prime_num ) {\n                    $current_max = $current_max;\n\
    \                    $current_sum += $current_num;\n                }\n      \
    \          elsif (!$current_prime && $current_prime_num ) {\n                \
    \    $current_max = $current_max;\n                    $current_sum += $current_num;\n\
    \                }\n                elsif ($current_prime && $current_prime_num\
    \ ) {\n                    if ($current_prime_index == $current_prime) {\n   \
    \                     if ($next_prime == $current_prime) {\n                 \
    \           $current_sum += $current_num;\n                        }\n       \
    \                 elsif ($next_prime != $current_prime) {\n                  \
    \          $current_max = $current_max;\n                            $current_sum\
    \ += $current_num;\n                        }\n                        else {\n\
    \                            $next_prime = $current_prime;\n                 \
    \           $current_prime_index = $current_prime;\n                        }\n\
    \                    }\n                    else {\n                        $next_prime\
    \ = $current_prime;\n                        $current_prime_index = $current_prime;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return $current_sum;\n}", "    my($max) = -1;\n    my($sum) = 0;", " \
    \   my($sum);\n    my($k);\n    my($i);\n    my($m);", "    my(@num) = ();\n \
    \   my(@prime) = ();\n    my($i);", "    my($largest);\n    my(@numbers);", " \
    \   my(@arr) = @$lst;\n    my($max);\n    my($sum);\n    my($n);\n    my($i);\n\
    \    my($j);\n    my($flag);", "    my $largest;\n    my $largest2 = 0; # 2\n\
    \    my $sum = 0;\n    foreach my $v (@$lst) {\n        my $i = 0; # 0\n     \
    \   foreach my $k (0 .. $#{$v}) {\n            if ($v->[$k] eq $v->[$k+1]) {\n\
    \                $i++;\n            }\n            if ($i > 0) {\n           \
    \     if ($v->[$k] >= $largest) {\n                    $largest = $v->[$k];\n\
    \                }\n                else {\n                    $largest2 = $largest;\n\
    \                }\n                $sum = $sum + $v->[$k];\n            }\n \
    \       }\n    }\n    $sum;\n}", "    my $max_num = pop(@{$lst});\n    my $sum\
    \ = 0;\n    my($count, $i) = (0, 0);\n    while($i < @{$lst}) {\n        while($count\
    \ < $i) {\n            $sum++;\n            $count++;\n        }\n        $i =\
    \ $i + 1;\n        while($count < $i) {\n            $sum += $lst[$count];\n \
    \           $count++;\n        }\n        $i = $i + 1;\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a tags=arrays,perl,algorithm,optimization |>\n<| c |>\nThis can\
    \ be further optimized, by caching the sums of each digit. Also, the sum can be\
    \ calculated from the sums of each digit in the first `while` loop. For example,\
    \ when `$sum` is 2, the digit `0` will need to be added twice.\n<|/ c |>\n<| c\
    \ |>\nThank you! I added a recursive version which should be even faster now.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nuse strict;\nuse warnings;", "    my($max_prime);\n\
    \    my($sum);\n    \n    foreach my $num (@$lst) {\n        if ($num == 1) {\n\
    \            $sum += $num;\n        } else {\n            my($new_sum, $new_max_prime)\
    \ = 0;\n            \n            # find all possible prime factors\n        \
    \    for (my $i = 2; $i <= sqrt($num); $i++) {\n                \n           \
    \     if ($num % $i == 0) {\n                    $new_sum += $i;\n           \
    \         \n                    if ($new_max_prime == 0) {\n                 \
    \       $new_max_prime = $i;\n                    }\n                }\n     \
    \       }\n            \n            if ($new_max_prime > $max_prime) {\n    \
    \            $sum = $new_sum;\n                $max_prime = $new_max_prime;\n\
    \            }\n        }\n    }\n    \n    return $sum;\n}", "    my($i, $j,\
    \ $num, $nums, $count, $sum, $res, $cur, $max) =;\n    $max = 0;", "    my($prime);\n\
    \    my($sum);\n    my(@prime);\n    my($tmp);\n    my($max);\n    my($maxprime);\n\
    \    my(@maxprime);\n    my($maxsum);\n    my(@maxsum);\n    my(@maxsumtemp);",
  "    my($max);\n    my($sum);\n    my(@primes);\n    my($i,$j,@sums);\n    my($tmp);",
  "    my($i, $k, $sum, $max);\n    my(@prime) = 0;\n    my(@prime_arr) = (-1);",
  "    my $max = 0;\n    my $maxnum = 0;", "    my($prime) = 1;\n    my($sum) = 0;\n\
    \    my(@primes) = ();\n    my($i, $num, $prime, $max);\n    push(@primes, 1);\n\
    \    # Check for divisibility by 2 and 3 first\n    foreach $num (@$lst) {\n \
    \       if ($prime == 2 && $num == 3) next; # Skip 3\n        elsif ($prime ==\
    \ 3 && $num == 2) next; # Skip 2\n        # Any odd number not divisible by 2,\
    \ 3 or 5 must be prime\n        elsif ($num % 2 == 1 || $num % 3 == 0 || $num\
    \ % 5 == 0) {\n            $prime++;\n            push(@primes, $prime);\n   \
    \     }\n    }\n    # Now we get to the fun part. Check prime numbers and find\
    \ the largest one\n    for ($i = 0; $i < @primes; $i++) {\n        # Check to\
    \ see if this prime is greater than the largest in our list\n        if ($lst[$i]\
    \ > $max) {\n            $max = $lst[$i];\n        }\n        elsif ($lst[$i]\
    \ % $primes == 0) {\n            $sum += $lst[$i] / $primes;\n        }\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,math,numbers,big-o,primes\
    \ |>\n<code>", "    my $max = -1;\n    my $sum = 0;\n    foreach my $i (0 .. $#lst)\
    \ {\n        next unless $lst[$i] >= 0;\n        my $tmp = Math::Prime::primes(@$lst[$i..$#lst]);\n\
    \        if ($tmp > $max) {\n            $max = $tmp;\n        }\n        $sum\
    \ += $tmp;\n    }\n    return $max * $sum;\n}", "    my($max);\n    my(@max);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n\
    \    push(@max, 1);\n    push(@max, 1);\n    push(@max, 1);\n    push(", "   \
    \ my($i, $prime, $sum);\n    my($len) = scalar(@$lst);", "    my($prime) = 0;\n\
    \    my(@lst2);\n    my(@lst3);\n    my($i);\n    my($sum);", "    return 0 unless\
    \ @$lst;\n    my($psum) = 0;\n    my($pmax) = 0;\n    my($pmin) = 98765;", " \
    \   my @res = ();\n    my ($largest, $len) = 0, 0;\n    for (@$lst) {\n      \
    \  if (@res == 0) {\n            $largest = $_;\n            $len = 1;\n     \
    \   }\n        elsif ($_ == $largest) {\n            $len++;\n        }\n    \
    \    else {\n            if ($len > 1) {\n                $res[-1] += $len;\n\
    \                @res = ();\n                $len = 1;\n            }\n      \
    \  }\n    }\n    if ($len > 1) {\n        $res[-1] += $len;\n        @res = ();\n\
    \    }\n    return @res > 1 ? $res[-1] : 0;\n}\n</code>\n<|/ a tags=perl,algorithm\
    \ |>\n<| c |>\nThanks. How does it compare to my solution? Does it run faster?\
    \ How does it compare to the other solutions posted so far? I'm looking to compare\
    \ against other solutions posted here.\n<|/ c |>\n<| c |>\n: How fast is your\
    \ solution? How fast is my solution? How fast are other solutions? I do not have\
    \ access to all of your solutions, so I cannot comment on them. But I will say\
    \ that all my solutions have a O(n) complexity, where n is the length of your\
    \ list. Your solution is O(n^2), but my solution is O(nlogn) because of the `sort\
    \ { $b <=> $a } @$lst` operation.\n<|/ c |>\n<| c |>\nMy solution seems to take\
    \ roughly 4 times longer than the others. I'm not really sure how well each solution\
    \ is implemented and how well my code compares to the others. I'll just accept\
    \ this answer since it looks very promising and will probably be used often. Thanks!\n\
    <|/ c |>\n<| c |>\n: Ah okay, it wasn't clear to me that you had other solutions\
    \ to compare to. I've added a couple more solutions into the above solution that\
    \ you may want to compare with.\n<|/ c |>\n<| c |>\n: I added another solution\
    \ which I think will perform well enough for this problem.\n<|/ c |>\n<| a dscore=1\
    \ tags=perl,algorithm |>\nI'm sorry, I'm not going to post Perl because I don't\
    \ know Perl (I'm more of a C guy, and I haven't written many Perl programs before).\n\
    I'm going to use Python instead, because the logic is almost exactly the same\
    \ (modulo the printing of the result).\n<code>", "    my($max) = 0, 0;\n    my($sum)\
    \ = 0;\n    foreach $num (@$lst) {\n        if ($num > 0) {\n            my($x)\
    \ = ($num % 10);\n            ($max) = ($max == 0) ? $num : $max;\n          \
    \  if ($max != 0) {\n                ($sum) = ($sum + $x);\n                ($max\
    \ = $num / $x);\n            }\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a tags=sieve-of-eratosthenes,algorithm,primes,perl |>\n<| c |>\nWhy you used\
    \ `($max) = ($max == 0) ? $num : $max;` instead of `($max == 0) ? $num : $max\
    \ += $num;`? This way you don't need to initialize $max to zero\n<|/ c |>\n<|\
    \ c |>\nThat is very clever. Thanks for sharing.\n<|/ c |>\n<| c |>\n`($max ==\
    \ 0) ? $num : $max += $num;` has the same behavior as `($max == 0) ? $num : $max\
    \ = ($max == 0) ? $num : $max + $num;` - it always returns `$max`. So you get\
    \ two branches of `($max == 0) ? $num : $max += $num` which are equal, just written\
    \ differently. And I don't think that's what you want - it would be `($max = $max\
    \ + $num) if $max > 0`\n<|/ c |>\n<| a tags=sieve-of-eratosthenes,algorithm,primes,perl\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    my($max) = -1;\n    my($sum) =\
    \ 0;\n    my(@prime) = ();\n    for(my $i = 0; $i < @$lst; $i++) {\n        if($lst\
    \ -> [$i] % 2 == 0) {\n            $max += $lst -> [$i];\n        }\n        else\
    \ {\n            if($lst -> [$i] % 2 == 1) {\n                push(@prime, $lst\
    \ -> [$i]);\n            }\n            else {\n                for(my $j = 1;\
    \ $j <= $lst -> [$i] / 2; $j++) {\n                    if($lst -> [$i] % $j ==\
    \ 0) {\n                        $max += $j;\n                    }\n         \
    \       }\n            }\n        }\n    }\n    for(my $i = 0; $i < @prime; $i++)\
    \ {\n        if($max > $prime -> [$i]) {\n            $sum = $sum + $prime ->\
    \ [$i];\n        }\n    }\n    return $sum;\n}", "    my($max);\n    my($sum);\n\
    \    my($i, $j, $digit);\n    my(@d);\n    for ($i = 0; @$lst > 0; $i++){\n  \
    \      @d = ();\n        for ($j = 0; $j < @$lst; $j++){\n            $digit =\
    \ $lst[$j];\n            push(@d, $digit % 10);\n            $digit /= 10;\n \
    \       }\n        if ($max < $d[0]){\n            $max = $d[0];\n        }\n\
    \    }\n    for ($i = 0; @$lst > 0; $i++){\n        @d = ();\n        for ($j\
    \ = 0; $j < @$lst; $j++){\n            $digit = $lst[$j];\n            push(@d,\
    \ $digit % 10);\n            $digit /= 10;\n        }\n        if ($d[0] == $max){\n\
    \            $sum += $d[1];\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a tags=math,optimization,algorithm,perl,performance dscore=2 |>\n<| c |>\n\
    Please add some explanation to your answer.\n<|/ c |>\n<| a tags=math,optimization,algorithm,perl,performance\
    \ |>\nJust a small change in algorithm.\n<code>\nuse strict;\nuse warnings;",
  "    my(@primes) = ();\n    my($largest);\n    my($sum);\n    my($index);", "  \
    \  my($max) = 0, 0;\n    my(@lst) = ();\n    my($sum) = 0;\n    my($temp);", " \
    \   my(@sum);\n    my($max);\n    my $is_prime;\n    foreach my $i (@$lst) {\n\
    \        if ($i > 0) {\n            my $count = 0;\n            my $is_prime =\
    \ 1;\n            foreach my $j (@$lst) {\n                next if ($j == $i);\n\
    \                $is_prime = 0 if ($i % ($j * $j) == 0);\n                if ($is_prime)\
    \ {\n                    $count++;\n                    if ($count > $max) {\n\
    \                        $max = $count;\n                    }\n             \
    \   }\n            }\n            $is_prime = 0 if ($i == 0);\n            $is_prime\
    \ += 1 if $i == $max;\n            push(@sum, $is_prime);\n        }\n    }\n\
    \    my $maxsum = scalar(@sum);\n    my $max = $maxsum;\n    foreach my $i (@sum)\
    \ {\n        $max += $i;\n    }\n    return $max;\n}", "    local $_;\n    my\
    \ $largest = 0;\n    for ($_ = 0; $_ < @$lst; ++$_) {\n        if ($lst->[$_]\
    \ % 2 == 0) {\n            for ($_ = 0; $_ < $lst->[$_]; ++$_) {\n           \
    \     if ($lst->[$_] % 2 == 0) {\n                    last;\n                }\n\
    \                else {\n                    ++$largest;\n                }\n\
    \            }\n        }\n        else {\n            for ($_ = 0; $_ < $lst->[$_];\
    \ ++$_) {\n                if ($lst->[$_] % 2 == 0) {\n                    ++$largest;\n\
    \                }\n            }\n        }\n    }\n    return $largest;\n}\n\
    </code>\n<|/ a tags=performance,perl,primes,sieve-of-eratosthenes,sieve-of-atkin\
    \ |>\n<| a dscore=0 |>\nAs a sidenote: I implemented this for a different problem,\
    \ but it should still be possible to adopt it to this one. \nI tested it on a\
    \ list with 70 numbers from 0 to 12 and it finishes in about 10 milliseconds.\
    \ \nI used a sieve that stops at every integer between 2 and 12 (inclusive), but\
    \ you can choose a different stopping criterion.\n<code>\nuse List::Util qw(next_permutation);",
  "    my($max) = -1;\n    my($sum) = 0;\n    my($cur) = 0;\n    my(@ret) = ();\n\
    \    my(@num) = ();\n    my(@nums) = ();\n    my(@numss) = ();", "    my($sum);\n\
    \    my($largest);\n    my(@remainders);\n    my($i);", "    my($max) = 0;\n \
    \   my($prime) = 0;\n    my($sum) = 0;\n    my($len) = @$lst - 1;\n    \n    for\
    \ (my $i = 0; $i < $len; $i++) {\n        next if ($lst[$i] >= $max);\n      \
    \  \n        if ($prime == 0) {\n            $prime = $lst[$i];\n        } elsif\
    \ ($prime == $lst[$i]) {\n            $prime = 0;\n            $sum += $prime;\n\
    \        } else {\n            $prime = 0;\n        }\n        $prime++;\n   \
    \     $max++;\n    }\n    $sum += $max;\n    return $sum;\n}", "    my $max =\
    \ 1;\n    my $sum = 0;\n    my @prime;\n    for ($lst[0], $lst[1]) {\n       \
    \ my $p = 0;\n        for ($lst[0], $lst[1]) {\n            $p++ while $prime[$p]\
    \ <= $lst;\n        }\n        if ($p == $max) {\n            $sum += $prime[$p];\n\
    \        }\n        $max++;\n    }\n    return $sum;\n}", "    my $p = 1;\n  \
    \  my $sum;\n    my $temp;\n    $sum += $lst[0] if $lst[0] != 0;\n    for my $i\
    \ ( 1 .. $#lst ) {\n        if ( $lst[$i] % $p != 0 ) {\n            $p = $lst[$i];\n\
    \            $sum += $p if $p > $sum;\n        }\n        else {\n           \
    \ my $temp_add = $lst[$i] / $p;\n            $temp = $temp + $temp_add if $temp\
    \ > $temp_add;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nWhy don't you use the built-in `prime` function?\n<|/ c |>\n<| c |>\nI didn't\
    \ know that one - thanks for pointing that out. I'll give it a try next time I\
    \ write a solution for this problem.\n<|/ c |>\n<| c |>\nI don't think you should\
    \ be using recursion here. `prime` does a lot of work for you, and it is likely\
    \ more efficient. Also, your solution is O(N^2), but should be O(N).\n<|/ c |>\n\
    <| c |>\n: You can't say that for certain without seeing the `prime` function.\
    \ However, it is reasonably efficient, at least for prime numbers up to 1,000,000\
    \ - see [here](http://stackoverflow.com/q/2628117/95735). I didn't realise that\
    \ `prime` was the solution, since I thought it would have worked in some cases\
    \ (like `1` for `0`), but in fact it doesn't, so I replaced it with my own code.\
    \ `prime` also has a bug, however, so I replaced that too.\n<|/ c |>\n<| c |>\n\
    : Yes, the O(N^2) isn't necessarily bad. I've edited my answer to show how I'd\
    \ do it for N <= 100,000.\n<|/ c |>\n<| a tags=algorithm,big-o,primes,perl,performance\
    \ |>\nThe algorithm is wrong, and doesn't work for odd numbers. I used this version\
    \ to get the result for odd numbers:\n<code>", '    my($max);', "    my($max,\
    \ $sum, @prime);\n    my($n, $i, $cnt);\n    my(@sums);", "    \n    my @ans;\n\
    \    \n    my $prime;\n    for (my $i = 0; $i < $#lst; $i += 2) {\n        $prime\
    \ = $prime != 1 and $lst[$i] or $lst[$i];\n    }\n    \n    for (my $i = 0; $i\
    \ < $#lst; $i += 2) {\n        $prime = $prime != 1 and $lst[$i] or $lst[$i];\n\
    \        my $j = 1 + $i;\n        for (my $k = $j; $k <= $#lst; $k += $j) {\n\
    \            $prime = $prime != 1 and $lst[$k] or $lst[$k];\n            if ($lst[$k]\
    \ != $lst[$i]) {\n                if ($prime != 1) {\n                    $ans[$i]\
    \ = $lst[$i] + $lst[$k];\n                    last;\n                }\n     \
    \           else {\n                    $ans[$i] = $lst[$i];\n               \
    \     last;\n                }\n            }\n        }\n    }\n    return $ans[$#ans];\n\
    }\n</code>\n<|/ a tags=algorithm,primes,arrays,perl,iteration |>\n<| a tags=algorithm,primes,arrays,perl,iteration\
    \ dscore=0 |>\nHere is a very simple algorithm, using two pointers and an array.\n\
    I hope it helps.\n<code>\nuse strict;\nuse warnings;", "    my(@primes) = (2,\
    \ 3);\n    my(@results);\n    my(@factors) = (2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2);\n\
    \    my($max);\n    my($num);", "    my($max);\n    my($sum);", "    my(@rslt)\
    \ = (0, 0);\n    foreach my $elem (@$lst) {\n        my $count = 1;\n        $count++\
    \ while ($elem % $count == 0);\n        foreach my $i (1..$count-1) {\n      \
    \      my $x = $elem * $i;\n            $x++ if $x < $elem or $x == $elem;\n \
    \           $rslt[0] = $rslt[0] + $elem->digit($i) if $x <= $elem;\n         \
    \   $rslt[1] = $rslt[1] + $elem->digit($i-1) if $x >  $elem;\n        }\n    }\n\
    \    $rslt[0] += $rslt[1] if $rslt[0] < $rslt[1];\n    return @rslt;\n}", "  \
    \  my($i, $sum, @prime, $prime);\n    my($tmp, $last, $max, $lastPrime, $primeNumber);",
  '    my(@result) = (0, 0);', "    my($ans) = 0;\n    my($max) = @_[0];\n    my($i);\n\
    \    my(@lst) = @_;\n    my(@prime);\n    my($j);\n    my($p) = 0;", "    my $max\
    \ = -1;\n    for (@$lst) {\n        if ($_ > $max) {\n            $max = $_;\n\
    \        }\n    }\n    $max;\n}\n</code>\n<|/ a tags=arrays,perl |>\n<| a tags=arrays,perl\
    \ dscore=1 |>\nI like solution posted by Patrick,\njust to make it more readable:\n\
    <code>", "    my($sum) = 0;\n    my($largest_prime) = 0;\n    my($largest) = 0;\n\
    \    my($counter) = 0;", "    my $max = -1;\n    foreach my $num (@$lst) {\n \
    \       my $factor;\n        for ($num) {\n            $factor = $_ % $num;\n\
    \            $num = $num / $factor;\n        }\n        $max = $num if $num >\
    \ $max;\n    }\n    return $max;\n}", "    my($max) = -1;\n    my($sum);\n   \
    \ my($prime);\n    my($i);\n    for ($i=0; $i<$#$lst; $i++) {\n        my $d =\
    \ $lst->[$i];\n        $sum += $d;\n        if ($d == 1) {\n            $prime++;\n\
    \        }\n        if ($prime == $max) {\n            $sum = 0;\n           \
    \ $prime = 0;\n        }\n        if ($d == 0) {\n            $sum -= $sum;\n\
    \            $prime = 0;\n        }\n        $max = $prime > $max ? $prime : $max;\n\
    \    }\n    return $sum;\n}", "    my $max = 0;\n    my $prime = 0;\n    my $sum\
    \ = 0;\n    foreach my $num (@$lst) {\n        if ($num == 0) {\n            last;\n\
    \        }\n        if ($num == 1) {\n            $prime++;\n        }\n     \
    \   if ($prime != 0 && $num % $prime != 0) {\n            $prime = 0;\n      \
    \  }\n        if ($num > $max) {\n            $max = $num;\n        }\n    }\n\
    \    $sum = ($sum + $max) % 10;\n    return $sum;\n}", "    my $sum = 0;\n   \
    \ my $max = -1;\n    foreach my $num (@$lst) {\n        my $digit = ${$lst}[$num];\n\
    \        $sum += $digit;\n        if ($digit > $max) {\n            $max = $digit;\n\
    \        }\n    }\n    return $sum;\n}", "    my($max_num, $num_sum);\n    my($i);\n\
    \    my($flag);", "    my(@result) = (0, 0);\n    my($prime) = ($lst[-1] == 1\
    \ ? 1 : ($lst[-1] > 3 ? 3 : ($lst[-1] > 7 ? 7 : $lst[-1])));\n    my($cnt);\n\
    \    foreach my $item (@$lst) {\n        my($tmp) = ($item > $prime ? $item -\
    \ $prime : $item);\n        my($mod) = ($tmp % $prime);\n        push(@result,\
    \ $mod < 0 ? $mod + $prime : $mod);\n        $cnt += $mod < 0 ? 1 : 0;\n    }\n\
    \    ($result[-1] + $cnt) > ($prime * 2) ? ($result[-1], $cnt) : ($result[-1],\
    \ $cnt + 1);\n}", "    my $result = 0;\n    my $largest = 0;", "    my $max =\
    \ 0;\n    for my $i (0 .. $#lst) {\n        my $j = 0;\n        for ($j = 0 ;\
    \ $j < $#{$lst[$i]} ; $j++) {\n            my $x = $lst[$i];\n            $lst[$i]\
    \ = $lst[$j];\n            $lst[$j] = $x;\n            last if $i % $x == 0;\n\
    \        }\n        $max = $lst[$i] if $lst[$i] > $max;\n    }\n    return $max;\n\
    }", "    my(@res, $i);\n    my $prime = -1;\n    my $max = -1;\n    my $sum =\
    \ 0;", "    my $largest = -1;\n    my $sum = 0;\n    my $i;\n    for (my $i =\
    \ 0; $i < @$lst; $i++) {\n        my $temp = $lst->[$i];\n        if ($temp >=\
    \ $largest) {\n            $largest = $temp;\n        }\n    }\n    for (my $i\
    \ = 0; $i < @$lst; $i++) {\n        my $temp = $lst->[$i];\n        if ($temp\
    \ == $largest) {\n            $sum += $temp;\n        }\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a tags=perl,bigint |>\n<| c |>\nThis is probably going to have\
    \ some pretty large numbers and is still going to have a bad time with the first\
    \ few large numbers.\n<|/ c |>\n<| c |>\nNo, it's not going to have *that* many\
    \ large numbers. I took the liberty of modifying the original code to use bigint\
    \ arithmetic, and also added some examples. You might want to try it out and see\
    \ how it works.\n<|/ c |>\n<| c |>\n, can you describe the reason for saying that?\n\
    <|/ c |>\n<| c |>\n, I don't really know how bigint arithmetic works. I've never\
    \ used it before and don't know what it does, or how it works. Do you think it\
    \ could work for the OP? If you had a bigint module installed, it would be worth\
    \ a try. But I doubt it is worth a try. :)\n<|/ c |>\n<| c |>\n, it was just an\
    \ observation. I don't know if bigint is any better than a normal integer. The\
    \ biggest number here would be 1828111, and that's a lot larger than the average\
    \ number, and would require bigint arithmetic to work with.\n<|/ c |>\n<| a tags=perl,bigint\
    \ |>\nAs of version 5.14, Perl's built-in bigint is implemented using the GMP\
    \ library.\nThe GMP library has a C API which Perl can interface with. You can\
    \ see more about this in the perl5iconv section of the GMP documentation. \nThere\
    \ are many Perl modules for working with GMP numbers including Math::GMP and Math::BigInt.\
    \ \nMath::BigInt was a core module in version 5.6 and has been moved into its\
    \ own distribution in Perl 5.14\n<|/ a dscore=4 |>\n<| c |>\nThanks, Math::BigInt\
    \ is very interesting. I will look into it!\n<|/ c |>\n<| a tags=perl,bigint |>",
  '    my(@rslt) = ();', '    my;', "    my($len, $i);\n    my($sum = 0, $max);\n\
    \    my($j, $i);\n    my($count);", "    my $max = 0; # max value\n    my $index\
    \ = 0; # index to find max\n    for (my $i = 2; $i <= $#lst; ++$i) {\n       \
    \ # find max index\n        for ($index = 0; $index <= $#lst; ++$index) {\n  \
    \          if ($lst[$index] == $i) {\n                $max = $lst[$index];\n \
    \               last;\n            }\n        }\n    }\n    return $max;\n}",
  "    my($max_prime);\n    my $n = scalar(@$lst);\n    my $prime = $n <= 1 ? $n :\
    \ ($lst[$n-1]+1);\n    foreach my $i (1 .. $n/$prime) {\n        my $j = $i*$prime;\n\
    \        while(@$lst < $j) {\n            push(@$lst, $n <= 1 ? $n : 0);\n   \
    \     }\n        my $prime_copy = @$lst[$i-1];\n        push(@$lst, $prime);\n\
    \        my $sum = 0;\n        for(my $k = 1 .. $prime) {\n            if($prime_copy[$k]\
    \ == 1) {\n                $sum += $k;\n            }\n        }\n        $max_prime\
    \ = $prime if $sum == $prime;\n    }\n    return $max_prime;\n}", "    my @results;\n\
    \    my ($largest, $sum, $i, $j);\n    my $largest = 0;\n    my $largest2 = 0;\n\
    \    my $sum = 0;\n    for ($i = 0; $i < @$lst; $i++) {\n        $sum += $lst->[$i];\n\
    \        $largest = $lst->[$i] if ($largest < $lst->[$i]);\n        $largest2\
    \ = $lst->[$i] if ($largest < $lst->[$i]);\n    }\n    foreach my $i (@$lst) {\n\
    \        my $j = 1;\n        my $x = 0;\n        $x =~ s/^0/1/g;\n        while\
    \ ($j <= $i) {\n            last if ($j & 1);\n            $j++;\n           \
    \ $x++;\n        }\n        $x++;\n        if (($x & 1) == 0) {\n            $sum\
    \ += $j;\n        }\n    }\n    $sum += $largest;\n    $largest = $largest2;\n\
    \    $sum -= $sum % 10;\n    return $sum;\n}\n</code>\n<|/ a tags=perl,algorithm,modulus\
    \ dscore=1 |>\n<| a tags=perl,algorithm,modulus dscore=1 |>\nHere is another one.\
    \ I used a hash of values to store each digit (0 to 9) in the sum and a hash of\
    \ values to store each digit (0 to 9) in the largest sum. \n<code>", "    my($max);\n\
    \    my($n);\n    my($digit);\n    my($prime);\n    my($sum);\n    my(@primes);",
  "    my $sum = 0;\n    my $largest = 0;", "    my($largest) = -1;\n    my($sum)\
    \ = 0;\n    my($prime) = 0;\n    my($i) = 0;\n    my(@primes) = [];\n    my($k)\
    \ = 0;\n    foreach $num (@{$lst}) {\n        push(@primes, 1);\n    }\n    foreach\
    \ $num (@primes) {\n        while ($num != 0) {\n            my $test = $num %\
    \ 10;\n            if ($test == 0 && $num > 1) {\n                if ($largest\
    \ == 0) {\n                    $largest = $test;\n                    $sum = $num\
    \ % $test;\n                    $prime = 1;\n                    $k = -1;\n  \
    \                  $i = 0; #reset\n                }\n                elsif ($test\
    \ > $largest) {\n                    $largest = $test;\n                    $sum\
    \ = $num % $test;\n                    $prime = 1;\n                    $k = -1;\n\
    \                    $i = 0; #reset\n                }\n            }\n      \
    \      $num = div($num, 10);\n        }\n        push(@primes, $prime);\n    }\n\
    \    return $sum;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1 Nice, but it is\
    \ more efficient to store the last 2 primes in a hash instead of an array. Also,\
    \ there's no need to store all the primes beforehand, you only need the last 2\
    \ primes (for instance the last 2 primes calculated in the previous call).\n<|/\
    \ c |>\n<| c |>\nThat's an interesting optimization - could you please explain\
    \ how you would do it? Also thanks for noticing that I forgot to increment the\
    \ index :)\n<|/ c |>\n<| c |>\n: I just realized I left the index out in my code\
    \ (I didn't read all the way through it). Fixed now. And yes a hash would be much\
    \ better.\n<|/ c |>\n<| a |>\nThe previous answer doesn't actually produce the\
    \ correct answer (it returns 7 for all inputs). If I understand it correctly,\
    \ the algorithm checks the first 10 numbers and looks for a prime factor. If it\
    \ finds a prime, it saves the last prime it found and the last prime it found.\
    \ If it can't find a prime factor, it stops the loop and returns the sum of all\
    \ numbers up to that point. This means that the first number it checks isn't a\
    \ prime number. The correct solution is (I think) much more complicated than this\
    \ one and I will try to explain it below.\nTo begin, let's take a look at the\
    \ definition of a prime number. Wikipedia says it says a prime number is a number\
    \ that is not divisible by any number except itself and 1. That means a number\
    \ that is not divisible ", '    my($max_prime);', "    my($max) = -1;\n    my($sum)\
    \ = 0;\n    my($i, $j);\n    for ($i = 0; $i < @$lst; $i++) {\n        my($x)\
    \ = $lst[$i];\n        my($tmp, $j) = split(//, $x);\n        if ($tmp > $max)\
    \ {\n            $max = $tmp;\n        }\n    }\n    for ($i = 0; $i < @$lst;\
    \ $i++) {\n        my($x) = $lst[$i];\n        my($tmp, $j) = split(//, $x);\n\
    \        if ($tmp == $max) {\n            $sum += $tmp;\n        }\n    }\n  \
    \  return $sum;\n}\n</code>\n<|/ a tags=algorithm,arrays,perl |>\n<| c |>\nAs\
    \ an aside, it's pretty inefficient to call `split` every time. You should either\
    \ use a loop, or `join` the pieces back together.\n<|/ c |>\n<| c |>\n`if ($tmp\
    \ > $max) {\n            $max = $tmp;\n        }` is redundant. The next line\
    \ does that anyway: `my($tmp, $j) = split(//, $x);`\n<|/ c |>\n<| c |>\nThe first\
    \ `for` loop is unnecessary. `$max` is initialized to -1 before the `for` loop.\
    \ It can never be anything but -1, so the `if` statement will never execute.\n\
    <|/ c |>\n<| c |>\nNo, unnecessary assignment. `split` assigns the value returned\
    \ from split directly to `$tmp`, no need to assign it to another variable.\n<|/\
    \ c |>\n<| a tags=algorithm,arrays,perl |>\n<code>\nuse 5.012;\nuse strict;\n\
    use warnings;", "    my(@digits) = ();\n    my(@new_digits) = ();\n    my(@primes)\
    \ = ();\n    my($max);\n    my($max_prime);\n    my(@prime_candidates);\n    my($prime_index);\n\
    \    my($prime_candidate_digit);\n    my(@new_digits_copy);\n    my(@new_digits_copy2);",
  "    my@lst = @$lst;\n    my $maxprime = 0;\n    my $sum = 0;\n    my $i = 0;\n\
    \    my $prime;\n    my $primesum;\n    my $primecount;", "    my @max;\n    my\
    \ $i;\n    my $max = undef;", "    my($sum) = 0;\n    my($max_prime) = 0;\n  \
    \  my($prime) = 0;", "    my($lstlen, $sum) = (scalar @$lst, 0);\n    my ($p,\
    \ $i, $j, $n, $flag, $cp, $cn, $last);", "    my($i);\n    my($l);\n    my($x);\n\
    \    my($prime);\n    my(@nums);\n    my(@primes);", "    my($sum) = 0;\n    my($num)\
    \ = shift @$lst;\n    \n    while ($num > 0) {\n        $num = $num % 10;\n  \
    \      $sum += $num;\n        $num = $num / 10;\n    }\n    return $sum;\n}",
  "    my($max);\n    for(my $i=0; $i < @$lst; ++$i) {\n        for(my $j=0; $j <\
    \ $i; ++$j) {\n            if($lst[$i] % $lst[$j] == 0) {\n                $lst[$j]\
    \ = 0;\n            }\n            else {\n                $lst[$j]++;\n     \
    \           $lst[$i] = 0;\n                $lst[$j] = 1;\n            }\n    \
    \    }\n        for(my $j=1; $j < $i; ++$j) {\n            if($lst[$i] % $lst[$j]\
    \ == 0) {\n                ++$lst[$i];\n            }\n            else {\n  \
    \              $lst[$j] = $lst[$i] / $lst[$j];\n                $lst[$i] = 0;\n\
    \            }\n        }\n        if($lst[$i] != 0) {\n            if($lst[$i]\
    \ > $max) {\n                $max = $lst[$i];\n            }\n        }\n    \
    \    else {\n            $lst[$i] = 0;\n        }\n    }\n    return $max;\n}",
  "    my $max = -1;\n    my $sum = 0;\n    my $prime = 0;", "    my($ns);\n    my($max);",
  "    my(@nums) = ();\n    my(@sums) = ();", "    my @res;\n    for(my $i=0; $i<@$lst;\
    \ ++$i) {\n        my $v = $lst->[$i];\n        push @res, $v if $v > 0;\n   \
    \ }\n    my $max = 0;\n    my $total = 0;\n    for(my $i=0; $i<@res; ++$i) {\n\
    \        $total += $res[$i];\n    }\n    $max = $total if $total > 0;\n    return\
    \ $max;\n}\n</code>\n<|/ a dscore=1 tags=perl,algorithm |>\n<| a |>\nSince you\
    \ said the array had duplicate numbers, here's a solution that's a bit easier\
    \ to think about than the others.\n<code>\nuse strict;\nuse warnings;\nuse autodie;",
  "    my(@p) = ();\n    my(@a) = ();\n    my(@m) = ();\n    my(@s) = ();\n    my(@p)\
    \ = ();\n    my(@sum);\n    my(@max);", "    my(@ret);\n    my($max, $max_cnt);\n\
    \    my($i);\n    my($cnt);\n    my($digit);\n    my($tmp);\n    my($t);\n   \
    \ my(@t);\n    my($j);\n    my(@k);\n    my(@k);", "    my($maxval) = @_ > 1 ?\
    \ $_[1] : 0;\n    my($maxind = -1) = @_ > 2 ? $_[2] : -1;\n    my($sum) = 0;",
  "    my $max_prime = 0;\n    my $max = 0;\n    my $sum = 0;\n    my @primes;\n \
    \   my $i = 1;\n    my $j = 1;\n    while ($i < $#$lst) {\n        my $n = $lst[$i];\n\
    \        my $j = 0;\n        while ($j++ < $#$n) {\n            my $flag = 0;\n\
    \            for (;; $j++) {\n                $flag = $flag + $primes[$j];\n \
    \               if ($flag > $max_prime) {\n                    $max = $j;\n  \
    \                  $max_prime = $flag;\n                }\n                if\
    \ ($flag == $max_prime) {\n                    if ($flag != 1) {\n           \
    \             push @primes, $flag;\n                    }\n                  \
    \  $flag++;\n                }\n            }\n            if ($flag != 1) {\n\
    \                push @primes, $flag;\n            }\n        }\n        $i++;\n\
    \    }\n    return $sum + $max_prime;\n}", "    my($max) = -1;\n    my($sum) =\
    \ 0;\n    my($is_prime) = 0;\n    my($prime_num) = 0;\n    my($digit) = 0;\n \
    \   my($num_digits);\n    foreach my $i (@$lst) {\n        if ($i == 0) {\n  \
    \          $sum += $i;\n        } elsif ($is_prime == 0) {\n            # Check\
    \ to see whether it's a prime number\n            $is_prime = is_prime($i);\n\
    \            if ($is_prime == 0) {\n                $sum += $i;\n            }\n\
    \        } else {\n            # Check to see whether it's a prime\n         \
    \   $prime_num = is_prime($i);\n            if ($prime_num == 1) {\n         \
    \       if ($max < $i) {\n                    $max = $i;\n                }\n\
    \            } else {\n                if ($prime_num == 0) {\n              \
    \      $sum += $i;\n                }\n            }\n        }\n    }\n    return\
    \ $sum;\n}", "    my $max_num = 0;\n    my $max_num2 = 0;\n    my $total_sum =\
    \ 0;\n    my $total_sum2 = 0;\n    my $max_prime = 0;\n    my $max_prime2 = 0;\n\
    \    my $j = 0;\n    my $k;\n    my $prime_count = 0;\n    my $prime_digits =\
    \ 0;\n    for ($j; $j < @$lst; $j++) {\n        $k = int2str($lst[$j]);\n    \
    \    for ($prime_count; $prime_count < 5; $prime_count++) {\n            $prime_digits\
    \ = 0;\n            for ($k; $k < @$lst; $k++) {\n                if ($lst[$k]\
    \ % $max_prime == 0) {\n                    $prime_digits += int2str($lst[$k]\
    \ / $max_prime);\n                    $prime_count++;\n                }\n   \
    \         }\n            if ($prime_digits > $max_num2) {\n                $max_num2\
    \ = $prime_digits;\n                $max_prime2 = $max_prime;\n              \
    \  $max_num = $max_num2;\n                $max_prime = $max_prime2;\n        \
    \    }\n        }\n    }\n    for ($j; $j < @$lst; $j++) {\n        $k = int2str($lst[$j]);\n\
    \        for ($k; $k < @$lst; $k++) {\n            if ($lst[$k] % $max_prime ==\
    \ 0) {\n                $total_sum += int2str($lst[$k] / $max_prime);\n      \
    \      }\n        }\n    }\n    if ($total_sum > $max_num) {\n        $max_num\
    \ = $total_sum;\n        $max_prime = $total_sum2;\n    }\n    return $max_num;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI've made a Perl script that solves the\
    \ problem:\n<code>\nuse v5.10;", "    my ($max_prime, $sum_prime) = (0, 0);\n\
    \    \n    for (my $i = 0; $i < @$lst; $i++) {\n        my $prime = $lst->[$i];\n\
    \        \n        if ($prime == 1 && $i > 0) {\n            $max_prime = $lst->[$i\
    \ - 1];\n        }\n        elsif ($prime == 1 && $i == @$lst - 1) {\n       \
    \     $max_prime = $lst->[$i];\n        }\n        elsif ($prime != 1 && $i >\
    \ 0) {\n            if ($prime != $max_prime) {\n                $sum_prime +=\
    \ $prime;\n            }\n            else {\n                $sum_prime += $max_prime\
    \ * $i + $max_prime;\n            }\n        }\n    }\n    \n    return $sum_prime\
    \ * $max_prime + $max_prime;\n}", "    my $max;\n    my $i;\n    my $maxi = 0;\n\
    \    my $sum;\n    my $maxsum;\n    my $j;\n    for (my $idx = 0; $idx < @$lst;\
    \ $idx ++) {\n        $max = $lst->[$idx];\n        $j = 0;\n        $maxi = 0;\n\
    \        foreach $i (0 .. @$lst - 1) {\n            if ($i == $idx) {\n      \
    \          next;\n            }\n            ++$j;\n            my $d = $lst->[$i]\
    \ - $max;\n            $max = $lst->[$i];\n            if ($d >= 0) {\n      \
    \          last if $maxi == 0;\n                $maxi += $d;\n            }\n\
    \        }\n        $sum = 0;\n        if ($maxi == 0) {\n            $sum +=\
    \ $max;\n            $sum += $j;\n        }\n        else {\n            $sum\
    \ = $j;\n        }\n        if ($sum > $maxsum) {\n            $maxsum = $sum;\n\
    \            $maxi = $maxi;\n        }\n    }\n    return $maxsum;\n}", "    my($lst)\
    \ = grep(!/^\\s+$/,@lst);\n    my($max) = grep(/^\\d+$/,@lst);\n    my($num);\n\
    \    my(@nums);", "    my ($m, $i, $k);\n    $m = $lst[0] < 2 ? 2 : 3;\n    my\
    \ $sum = 0;\n    foreach $i (0 .. $#lst) {\n        for ($k = $m; $k >= 1; $k--)\
    \ {\n            $sum += $lst[$i] % $k;\n        }\n        $m = ($m == 3 ? 2\
    \ : 3) + 1;\n    }\n    return $sum;\n}", "    my($max);\n    my($sum);\n    my($i);\n\
    \    my($c);\n    my($d);", '    my($sum) = 0;', "    my($max, $num);\n    foreach\
    \ my $num (@$lst) {\n        my($tmp) = 0;\n        foreach my $digit (0..($num\
    \ - 1)) {\n            if ($num % $digit == 0) {\n                $tmp += $digit;\n\
    \                $max = $tmp if $tmp > $max;\n            }\n        }\n    }\n\
    \    return $max;\n}", "    my($sum) = 0;\n    my($max) = -1;\n    \n    $max\
    \ = $lst[0];\n    $sum = 0;\n    foreach $i (@$lst) {\n        if ($i > ($max\
    \ - 1)) {\n            $max = $i;\n        }\n        $sum += $i;\n    }\n   \
    \ return $sum;\n}", "    my $res = 0;\n    my %prime = ();\n    my $max = 0;\n\
    \    foreach my $i (@$lst) {\n        if (! defined $prime{$i}) {\n          \
    \  $prime{$i} = 1;\n            ++$max;\n        }\n        if ($prime{$i} > $max)\
    \ {\n            $res = $prime{$i};\n            $max = $prime{$i};\n        }\n\
    \    }\n    if ($max == 1) {\n        $res = 0;\n    }\n    return $res;\n}",
  "    my(@primes) = ();\n    my($max_num) = undef;\n    my(@digits) = ();\n    \n\
    \    for (my $i = 0; $i < scalar(@$lst); $i++) {\n        if ($lst[$i] >= 2) {\n\
    \            my($x) = $lst[$i];\n            push (@primes, $x);\n        }\n\
    \    }\n    for (my $i = 0; $i < scalar(@primes); $i++) {\n        if (scalar(@digits)\
    \ < $primes[$i]) {\n            my($x) = $primes[$i];\n            push (@digits,\
    \ $x);\n        }\n    }\n    for (my $i = 0; $i < scalar(@digits); $i++) {\n\
    \        my $x = $digits[$i];\n        my $max = intdiv($x, $max_num);\n     \
    \   while ($x > $max_num) {\n            my($y) = $max_num;\n            $y -=\
    \ 1;\n            my(@new_digits) = ();\n            for (my $n = 0; $n < scalar(@digits);\
    \ $n++) {\n                my($z) = intdiv($digits[$n], $y);\n               \
    \ push (@new_digits, $z);\n            }\n            @digits = @new_digits;\n\
    \            $max_num += 1;\n        }\n    }\n    my $sum = 0;\n    for (my $i\
    \ = 0; $i < scalar(@digits); $i++) {\n        $sum += $digits[$i];\n    }\n  \
    \  return $sum;\n}", "    my($max) = -1;\n    my($sum);\n    my($i);\n    my($j);\n\
    \    my($len);\n    $sum = 0;\n    $len = $#lst + 1;\n    for ($i = 0; $i < $len;\
    \ $i++) {\n        my($num) = ${$lst}[$i];\n        $max = $num if $num > $max;\n\
    \    }\n    for ($i = 0; $i < $len; $i++) {\n        my($num) = ${$lst}[$i];\n\
    \        for (; $num > 0; $num--) {\n            my $test = $num;\n          \
    \  while ($test != 1) {\n                $test /= $max;\n                $sum\
    \ += $test;\n            }\n        }\n    }\n    return $sum;\n}\n</code>\n<|/\
    \ a tags=perl,hash,arrays |>\n<| c |>\nYou don't have to multiply by -1 to find\
    \ the largest prime number. Just find the largest prime number and subtract it\
    \ from your number, then divide by the number of digits in your number, and multiply\
    \ by -1 to get the largest prime. For example, `13 - 5 = 7 --> 13 / 5 = 2 -->\
    \ 2 * -1 == -1`\n<|/ c |>\n<| c |>\nI like the idea of finding the largest prime\
    \ and subtracting it, but I fear that the time complexity is O(N^2), while your\
    \ idea takes O(N).\n<|/ c |>\n<| c |>\n: No, you are wrong. As I wrote, the number\
    \ of iterations of the while loop is O(N) since there is no division by zero and\
    \ no multiplication. You are right, I should have said \"...and no multiplication\"\
    \ instead of \"...and no division by zero\". Fixed. Thanks.\n<|/ c |>\n<| c |>\n\
    : Also, you should probably put a comment in the code to explain what the code\
    \ is doing, because it's not immediately obvious. And the algorithm is quite simple\
    \ to understand, so it should be easy to understand.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is not easy to understand.  It is so obvious that no one will understand it\
    \ if they can't tell how it works.  It may be obvious to you, but it is not obvious\
    \ to anyone else who has to read this code in six months.  And that includes people\
    \ who are less familiar with Perl than you are!\n<|/ c |>\n<| a tags=perl,hash,arrays\
    \ |>\n<code>", "    my($rslt);\n    my($i, $j, $k);", "    my($max_pnum);\n  \
    \  my($max_sum);", "    my(@primes);\n    my($maxprime);\n    my($sum);\n    my($digitsum);",
  "    my($sum);\n    my($max);\n    my(@res);\n    my(@tmp);", "    # Handle edge\
    \ cases. \n    my $max_prime = $lst->[0];\n    $max_prime += 1 unless $max_prime\
    \ & $max_prime-1;\n    \n    # Traverse through list and check primality of $max_prime\
    \ value.\n    foreach my $val (@$lst) {\n        my $prime = 1;\n        while\
    \ ($val > 0) {\n            my $mod = $val % $max_prime;\n            $prime =\
    \ 1 unless $prime;\n            $val = $mod if $mod > 0;\n        }\n        $max_prime\
    \ = $prime if $max_prime > $prime;\n    }\n    return $max_prime;\n}", "    my\
    \ ($sum, $i) = 0;\n    my (@i, $i);\n    for ($i = 0; $i < @$lst; $i++) {\n  \
    \      if ($i % 2 == 0) {\n            $sum = $sum * 10 + $lst[$i];\n        }\
    \ elsif ($i % 2 != 0) {\n            if ($lst[$i] > $sum) {\n                $sum\
    \ = $lst[$i];\n            }\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=math,algorithm,primes |>\nI believe your original\
    \ approach is correct. Your method of solving this problem is called Sieve of\
    \ Atkin, for details, please take a look at this article: https://en.wikipedia.org/wiki/Sieve_of_Atkin\n\
    <|/ a |>\n<| a dscore=0 |>\nIn case anyone is interested in the C++ code for the\
    \ above,\n<code>", "    my $largest = 1;\n    my $largestPrime = 0;\n    foreach\
    \ my $number (@$lst) {\n        my $prime = 1;\n        my $sum = 0;\n       \
    \ foreach my $index (0..$#$number) {\n            my $num = $number->[$index];\n\
    \            if (($num % $prime) == 0) {\n                $prime = 0;\n      \
    \      } else {\n                $prime = 1;\n            }\n            $sum\
    \ += $num;\n        }\n        if ($prime == 1) {\n            $largestPrime =\
    \ $sum;\n            if ($largest < $sum) {\n                $largest = $sum;\n\
    \            }\n        }\n    }\n    return $largestPrime;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
