name: HumanEval_161_solve
language: pl
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve(\"1234\")\n# \"4321\"\n# >>> solve(\"ab\")\n\
  # \"AB\"\n# >>> solve(\"#a@C\")\n# \"#A@c\"\nsub solve {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n\
  \        if(eq_deeply($candidate->(\"AsDf\"),\"aSdF\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1234\"\
  ),\"4321\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(\"ab\"),\"AB\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#a@C\"),\"#A@c\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  #AsdfW^45\"),\"#aSDFw^45\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"#6@2\"),\"2@6#\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  #$a^D\"),\"#$A^d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"#ccc\"),\"#CCC\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return $s if $s =~ /^\\pL/;\n    my($out) = \"\";\n    my($j) =\
    \ -1;\n    \n    for (my $i = 0; $i < length($s); $i++) {\n        if ($s[$i]\
    \ =~ /[a-z]/i) {\n            $j++;\n            $out .= $j >= length($s) ? $s[$i]\
    \ : $s[$i];\n        } else {\n            $out .= $s[$i];\n        }\n    }\n\
    \    \n    if (length($out) == 0) {\n        $out = \"$s\";\n    }\n    \n   \
    \ return $out;\n}\n</code>\n<|/ a |>\n<| a tags=string,perl |>\n<code>\n #!/usr/bin/perl\n\
    \ $string = \"1234\";\n $string =~ tr/a-z/A-Z/; \n print \"$string\\n\";\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n`tr` only replaces one character at a time.\n<|/ c\
    \ |>\n<| a |>\nTry this (perl code):\n<code>", '    return $s unless $s =~ /^[a-z]+$/i;',
  "    return $s if $s =~ /[a-z]/i;\n    $s =~ tr/A-Z/a-z/;\n    return $s if $s =~\
    \ /[A-Z]/i;\n    return $s !~ /[^A-Z]/? $s : strrev($s);\n}\n</code>\n<|/ a tags=perl\
    \ dscore=2 |>\n<| c |>\nI believe this will fail horribly on strings with more\
    \ than 2 lowercase letters.\n<|/ c |>\n<| a |>\nI know this isn't your question,\
    \ but your code is very similar to the one in the \"Learn Perl\" book.  As I'm\
    \ new to Perl, I wanted to learn as much as possible.  I didn't really like the\
    \ first answer, because it didn't use a regex, and it didn't handle the case where\
    \ you had more than one character in the string.  (I wanted to show another way\
    \ that also used regex)\nI wrote a script based on what you wrote.  This seems\
    \ to work on every test I tried.\n<code>", "    my %seen;\n    \n    for my $c\
    \ (split(//, $s)) {\n        $seen{$c} = 1 if defined $seen{$c};\n    }", "  \
    \  $s =~ s/^(.)$/\\U$1/g;\n    return $s;\n}", "    my $res;\n    foreach my $c\
    \ (split //, $s) {\n        $res .= $c =~ s/(.)/$1 =~ m{^([A-Z])|(^[A-Z]{2,})|([A-Z][a-z])|([A-Z])([a-z])|([a-z][A-Z])|([a-z])([A-Z])|([A-Z][a-z][A-Z])|([A-Z])([a-z][a-z])|([a-z][A-Z])([A-Z])|([A-Z][a-z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([a-z][A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([a-z][a-z])|([A-Z])([a-z][A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])|([a-z])([A-Z])|([A-Z])([A-Z][a-z])|([A-Z])([A-Z][a-z])",
  "    $s =~ s/([a-zA-Z])([a-zA-Z]+)/$1$2/g;\n    return $s;\n}", "    if ($s =~ /[a-zA-Z]/g)\
    \ {\n        $s =~ tr/a-z/A-Z/;\n    } elsif ($s =~ /[a-zA-Z0-9]/g) {\n      \
    \  $s =~ tr/a-zA-Z0-9//D;\n    } else {\n        $s =~ tr/abcdefghijklmnopqrstuvwxyz/NOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/d;\n\
    \    }\n    return $s;\n}\n</code>\n<|/ a tags=perl |>\n<| a |>\n<code>\nuse strict;\n\
    use warnings;\nuse feature qw/say/;\nmy $str = \"#a@C\";\n$str =~ s/([a-z])/uc($1)/ge;\n\
    say $str;\n</code>\n<|/ a dscore=2 tags=perl |>\n<| a dscore=0 |>\n<code>\nuse\
    \ strict;\nuse warnings;\nuse feature qw/say/;", "    my(@ans);\n    foreach my\
    \ $char (split(//,$s)) {\n        if($char =~ m/^[a-z]+$/) {\n            my $rev\
    \ = (lc($char) eq 'a') ? 'b' : 'A';\n            $rev = $rev x (length($char)\
    \ - 1);\n            $ans[$#ans] = $rev;\n        }\n        else {\n        \
    \    $ans[$#ans] = $char;\n        }\n    }\n    return join('',@ans);\n}", " \
    \   $s =~ s/^([a-zA-Z])//; # remove the letter if any\n    $s =~ s/([a-zA-Z])([a-zA-Z])/$1\
    \ $2/g; # reverse the case\n    return $s;\n}\n</code>\n<|/ a tags=python,algorithm,ruby\
    \ |>\n<| c |>\nThis is correct, but it doesn't really answer the OP's question.\n\
    <|/ c |>\n<| c |>\nWell, you didn't ask for \"the most efficient algorithm\".\
    \  I only did a minimal rewrite, maybe someone could do that too. I would not\
    \ call it an efficient algorithm, but I think it answers the OP's question.\n\
    <|/ c |>\n<| c |>\nIt should be noted that the above code is pure Perl, which\
    \ means that it requires the perl interpreter.  Python also has the ability to\
    \ run pure code, which means that this algorithm can be written in Python itself.\
    \  Of course, this is all a bit of a stretch since this algorithm is so simple\
    \ that it should already be available in Python.\n<|/ c |>\n<| c |>\nI believe\
    \ your comment is misleading.\n<|/ c |>\n<| c |>\nNo, it's not. I said this comment\
    \ was for someone who doesn't know Python or Perl. Your comment is misleading\
    \ if you believe my comment is misleading.\n<|/ c |>\n<| a tags=python,algorithm,ruby\
    \ dscore=2 |>\n<code>\n>>> def solve(s):\n...     return \"\".join([c if c.islower()\
    \ else c.upper() for c in s])\n...\n>>> print solve(\"123\")\n123\n>>> print solve(\"\
    AB\")\nAB\n>>> print solve(\"123A\")\n123a\n>>> print solve(\"abc\")\nabc\n>>>\
    \ print solve(\"abbc\")\nabbc\n>>> print solve(\"abBcC\")\nabBcC\n>>> print solve(\"\
    abBcCd\")\nabBcCd\n</code>\n<|/ a |>\n<| a tags=python,algorithm,ruby dscore=2\
    \ |>\nRuby way:\n<code>\ndef solve(str)\n  str.split('').map{|s| s.upcase if (s.downcase\
    \ == s) }.join\nend", "    # use tr/// and casecmp\n    $s =~ tr/a?c/A?c/;\n \
    \   return $s if $s =~ /^\\p{Upper}*$/;\n    $s =~ tr/A?c/a?c/;\n    return $s\
    \ if $s =~ /^\\p{Lower}*$/;\n    return $s;\n}\n</code>\n<|/ a tags=reverse,string,perl,lowercase\
    \ |>\n<| a tags=reverse,string,perl,lowercase dscore=0 |>\n<code>\n$string =~\
    \ tr/A-Z/a-z/;\n$string =~ tr/a-z/A-Z/;\n</code>\n<|/ a |>\n<| c |>\nWhile this\
    \ code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a |>\nHere is a solution that converts all letters\
    \ to lowercase and vice-versa:\n<code>", "    my(@res);\n    \n    for(split('',\
    \ $s)) {\n        push(@res, uc $1) if ($_ !~ /[[:alpha:]]/);\n    }\n    \n \
    \   return @res ? join('', @res) : $s;\n}", "    $s =~ s/^[a-z]+|[a-z]+$//g;\n\
    \    $s =~ s/(.)\\1+/${1}/g;\n    $s =~ tr/A-Z/a-z/;\n    return $s;\n}", "  \
    \  return $s if $s !~ /^[a-zA-Z]*$/ || $s =~ /^[a-zA-Z]*\\z/;\n    return $s !~\
    \ /^[a-zA-Z]*\\z/\n        ? map { uc($a) } split //, $s\n        : map { uc($_)\
    \ } split //, $s\n}\n</code>\n<|/ a tags=string,perl,regex,replace,algorithm |>\n\
    <| c |>\nWow, this is so much simpler than my own solution.  I guess this is the\
    \ same as the more popular \"solution\" to the [Perl challenge \"Reverse the case\
    \ of each word on a string\"](https://stackoverflow.com/q/25279428/1096596).\n\
    <|/ c |>\n<| c |>\nIt's similar, but not the same. For example, if the string\
    \ starts with a digit, that case is reversed; if the string begins with a letter,\
    \ that case is not reversed. This is different than \"Reverse the case of each\
    \ word on a string\", which treats \"1\" as \"1\".\n<|/ c |>\n<| a dscore=3 |>\n\
    Using regex:\n<code>\nuse strict;\nuse warnings;", "    if ( $s =~ /[A-Z]/ ) {\n\
    \        $s =~ tr/A-Z/a-z/;\n    } elsif ( $s =~ /[a-z]/ ) {\n        $s =~ tr/a-z/A-Z/;\n\
    \    } else {\n        $s =~ tr/A-Za-z/A-Z/;\n    }\n    return $s;\n}", "   \
    \ my $ans =();\n    \n    \n    for ($s) {\n        push(@$ans, $_ eq '#' ?\n\
    \            $_ eq '#' ? uc(\"A\") : $_ : \n            $_ eq '@' ?\n        \
    \    $_ eq '@' ? uc(\"a\") : $_ : $_);\n    }\n    $ans[0] =~ s/(.)/\\U$1/g;\n\
    \    $ans[0] =~ s/(.)/\\L$1/g;\n    \n    return $ans[0];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is really clever but this problem is not about reversing case. It\
    \ was just to give a specific example. I tried your solution on a real string\
    \ but it didn't work. It didn't give the expected answer\n<|/ c |>\n<| c |>\n\
    Okay I understand, let me check my solution\n<|/ c |>\n<| c |>\nIt doesn't work\
    \ for: solve(\"12#3\") gives \"12#3\" but should be: \"1#23\".\n<|/ c |>\n<| c\
    \ |>\nYes, sorry, I just realized I wrote this from my phone and I thought it\
    \ was a general solution but actually I changed it because your version worked.\
    \ Thank you very much.\n<|/ c |>\n<| c |>\nPlease don't post screenshots of your\
    \ code, or links to screenshots. Post the actual code here on Stack Overflow.\n\
    <|/ c |>\n<| a tags=perl,regex |>\nSolution that use perl's string functions:\n\
    <code>", "    return $s if ($s eq '');\n    my $new_s = $s;\n    $new_s =~ s/[[:lower:]]/[[:upper:]]/gi;\n\
    \    $new_s =~ s/[[:upper:]]/[[:lower:]]/gi;\n    return $new_s;\n}\n</code>\n\
    <|/ a tags=perl |>\n<| c |>\nThis does not provide an answer to the question.\
    \ To critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| c |>\nThe first few lines of the answer explain what is\
    \ happening. The code provided is a working solution.\n<|/ c |>\n<| c |>\nPlease\
    \ re-read my comment: *This does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post.*\n\
    <|/ c |>\n<| c |>\nThe questions asks for an algorithm and I provided an algorithm.\
    \ The fact that the OP used a language that doesn't provide a native algorithm\
    \ is irrelevant. I'm not asking for anyone to write this code, but to let you\
    \ know that what I have shown you is indeed what happens. I've used Perl to write\
    \ this code. Why did you downvote my answer? How is it not useful?\n<|/ c |>\n\
    <| c |>\nOk, thanks! The fact that you have used Perl is very useful information\
    \ for people who don't know Perl very well (not me, anyway). I've edited your\
    \ answer to remove that statement.\n<|/ c |>\n<| a |>\nThis Perl program demonstrates\
    \ the basic principles of string manipulation in Perl.\n<code>\nuse strict;\n\
    use warnings;", "    $s =~ s/\\p{Ll}/ig;\n    return $s;\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| a dscore=0 |>\n<code>", "    if ($s =~ /^[^a-z]+$/) {\n        $s = $s\
    \ =~ tr/A-Z/a-z/;\n    }\n    return $s;\n}\n</code>\n<|/ a tags=string,perl,subroutine,reverse\
    \ dscore=3 |>\n<| c |>\nThis is exactly what I needed since I was just learning\
    \ perl and am doing an exercise from a book called perl programming for noobs\
    \ (by Jeffery Schreiner) which only gives me the sample code to work with! Thanks\
    \ a lot for your efforts on this\n<|/ c |>\n<| c |>\n, thanks for your feedback.\
    \ I am glad you found my answer useful.\n<|/ c |>\n<| c |>\nNo worries :) thanks\
    \ for the help, your solutions really helped me and i learnt some new things\n\
    <|/ c |>\n<| a dscore=3 tags=string,perl,subroutine,reverse |>\nYou could use\
    \ reverse and chr functions:\n<code>", "    return $s unless $s;\n    return $s\
    \ unless $s =~ /^[a-zA-Z]+$/;\n    $s =~ tr/a-z/A-Z/;\n    $s =~ tr/A-Z/a-z/;\n\
    \    return $s;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou shouldn't use `map`\
    \ for a 1-1 mapping of one element to another. It should only be used when the\
    \ mapping is actually an operation that creates a new list. Since this is a 1-1\
    \ mapping, you should use a simple `for` loop.\n<|/ c |>\n<| a dscore=1 tags=perl\
    \ |>\nAnother way is to use map with tr:\n<code>\nuse strict;\nuse warnings;",
  "    my($i);\n    my($reverse);\n    my $result = \"\";\n    $i = 0;\n    while\
    \ ($i < length($s)) {\n        $reverse = \"\";\n        if ($s[i] =~ /[a-z]/)\
    \ {\n            $i++;\n            $reverse .= uc(substr($s, $i, 1));\n     \
    \       $i++;\n        }\n        elsif ($s[i] =~ /[A-Z]/) {\n            $i++;\n\
    \            $reverse .= lc(substr($s, $i, 1));\n            $i++;\n        }\n\
    \        else {\n            $i++;\n        }\n        $result .= $reverse;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=string,perl |>\n<| a tags=string,perl\
    \ |>\nThe most efficient way I could think of (without regex) was to use the char::is_alphanumeric\
    \ function. You can find the char::is_alphanumeric function here. \n<code>\nuse\
    \ strict;\nuse warnings;\nuse 5.010;\nuse utf8;", "    my $rev_s;\n    my $len\
    \ = length $s;\n    my $i = 1;\n    my $flag = 0;\n    my $letter;", "    return\
    \ \"\" unless $s;\n    my($i, $j) = (1, scalar(@{$s[0]}));\n    \n    # if the\
    \ length is zero return the empty string\n    return $s[0] eq '' ? '' : \n   \
    \     \n        # start by checking all letters are in lowercase\n        $s[$i]\
    \ !~ /^[a-z]+$/ ? $s[0] : \n    \n        # check the whole string and find the\
    \ first upper case letter\n        # this means $s[$i] must be all uppercase,\
    \ otherwise the string is invalid\n        \n        # check the whole string\
    \ and find the last upper case letter\n        # this means $s[$j] must be all\
    \ uppercase, otherwise the string is invalid\n        \n        # find the first\
    \ letter that is uppercase and remove it from the string then increment $i and\
    \ $j\n        \n        # find the last letter that is uppercase and remove it\
    \ from the string then decrement $i and $j\n        \n        # return the string\
    \ from the beginning and end \n        $s[$i..$j];\n}\n</code>\n<|/ a dscore=0\
    \ tags=perl,string,arrays,substring |>\n<| c |>\nThis is an excellent solution.\
    \ Thank you! The code doesn't pass all the test cases for this question but it\
    \ does give the correct output. I tried running it on a few test cases and it\
    \ seems to work.\n<|/ c |>\n<| c |>\nI forgot to add some tests in the beginning,\
    \ I updated the code with some more tests and a couple of additional tests that\
    \ failed, I hope it helps!\n<|/ c |>\n<| c |>\nThank you! I appreciate the help\
    \ a lot.\n<|/ c |>\n<| c |>\nIf my answer helped, you can accept it by clicking\
    \ the check mark next to it.\n<|/ c |>\n<| a tags=perl,string,arrays,substring\
    \ |>\nThis is my solution (without regex)\n<code>\nuse strict;\nuse warnings;",
  "    \n    # Handle empty string\n    return $s eq '' ? '' : \"$s\".\n    \n   \
    \ # Handle string contains only lowercase letters.\n    # Avoid 'aA'.\n    $s\
    \ eq ''   ? '' : \n    (\n        $s =~ /[[:lower:]]/i ? \n        (\n       \
    \     map { $_ eq 'a' ? $_ : 'A'  }  \n            map { uc($_) } \n         \
    \   split //, $s\n        )\n        : $s\n    );\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=reverse,string,perl,lowercase,uppercase |>\nTo my understanding\
    \ this is one line perl\n<code>\n$str =~ tr/a-z/A-Z/;\n</code>\nTo change the\
    \ case of the first letter you can do\n<code>\n$str =~ s/^([A-Z])/uc($1)/e;\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution is very clear and simple, thank\
    \ you. I'm surprised that there isn't a built-in way to solve this problem in\
    \ perl.\n<|/ c |>\n<| a |>\nThe answer from Pshemo works well, but I would recommend\
    \ using this as an alternative.\n<code>\n$str =~ s/(^|\\s)(.)/uc($2)/egi;\n</code>\n\
    It works by first replacing all letters with their uppercase counterparts, then\
    \ it does the same for the first and second character. Then, all that's left is\
    \ to replace the first character with the uppercase version. Doing this twice\
    \ reduces the time complexity from O(n) to O(2n). Doing it once reduces it down\
    \ to O(n).\n<|/ a dscore=1 tags=reverse,string,perl,lowercase,uppercase |>\n<|\
    \ a dscore=0 |>\nThe answer provided by Aymane is correct, however there is a\
    \ subtle caveat: it works only for strings of length 2, because of the limitations\
    \ of tr's 'e' modifier. More explanation can be found here.\nIn case someone will\
    \ need it for strings of more than 2 characters, here is my version of it, that\
    \ doesn't require the use of a temporary variable and doesn't use tr at all:\n\
    <code>", "    $s =~ s/\\A([a-zA-Z])/uc($1)/eg;\n    $s =~ s/\\A([a-zA-Z])/uc($1)/eg;\n\
    \    return $s;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,perl,regex,reverse\
    \ dscore=0 |>\nThe answer of Don Roberts got me on the right track, however, I\
    \ needed to use the uc function.  Here is my final solution in Perl.\n<code>",
  "    # empty string\n    return $s if !defined $s;", "    return $s if $s =~ /^[a-z]+$/i;\n\
    \    return $s =~ /^[a-z]+$/i ? uc($s) : lc($s);\n}", "    my $rv = \"\";\n  \
    \  for my $c (split(//,$s)) {\n        my $uc = lc($c);\n        if ($uc =~ /^[a-z]+$/i)\
    \ {\n            $uc = $uc =~ s/^[a-z]/U/g;\n        }\n        $rv.=$uc;\n  \
    \  }\n    return $rv;\n}", "    # no letters in string\n    return $s if !length($s);",
  "    my $result;\n    my $flag;\n    for ($s) {\n        my $letter = $_;\n    \
    \    if ($letter =~ /[a-z]/) {\n            $flag = 1;\n            $letter =~\
    \ tr/[a-z]//cd;\n            $letter =~ tr/A-Z//cd;\n        }\n        else {\n\
    \            $flag = 0;\n        }\n        if ($flag) {\n            $result\
    \ .= $letter;\n        }\n        else {\n            $result .= $letter;\n  \
    \      }\n    }\n    return $result;\n}", "    return $s unless $s;\n    return\
    \ $s if $s =~ /^[a-z]*$/i;\n    my $res = \"\";\n    my $chars = split(//, $s);\n\
    \    foreach my $char (@$chars) {\n        my $c = ord(substr($chars, $char, 1));\n\
    \        $res .= (($c < 65 || $c > 122)?chr( ($c-32)*2 ) : chr($c-32));\n    }\n\
    \    return $res;\n}", "    my $ret = \"\";\n    my $i = 0;\n    while ($i < length($s))\
    \ {\n        my $ch = $s[$i];\n        if ($ch eq \"\") {\n            $ret .=\
    \ $s[$i];\n            $i++;\n        } elsif ($ch =~ /[a-z]/i) {\n          \
    \  $ret .= ucfirst($ch);\n        } else {\n            $ret .= $ch;\n       \
    \ }\n        $i++;\n    }\n    return $ret;\n}", "    my @result = ();\n    my\
    \ $flag = 0;\n    for (my $i = 0; $i < $#s; $i++) {\n        my $c = substr($s,\
    \ $i, 1);\n        if ($c =~ /^[a-zA-Z]$/) {\n            if ($c =~ /[a-zA-Z]$/)\
    \ {\n                $flag = 1;\n            } else {\n                $c = $c\
    \ . substr($s, $i, 1);\n                $flag = 0;\n            }\n        } else\
    \ {\n            if ($flag) {\n                $c = $c . substr($s, $i, 1);\n\
    \            } else {\n                $c =~ tr/a-zA-Z/A-Z/;\n               \
    \ $c =~ tr/A-z/a-z/;\n                $flag = 1;\n            }\n        }\n \
    \       push(@result, $c);\n    }\n    return @result;\n}", "    return if !length($s)\
    \ || $s =~ /\\A\\z/;\n    my @s = split //, $s;\n    my @t;\n    my $k;\n    for\
    \ $k (0..$#s) {\n        $t[$k] = $s[$k] if $s[$k] =~ /\\pL/;\n        $t[$k]\
    \ = $s[$k]\n            if $s[$k] =~ /\\p{IsUpper}/;\n    }\n    $s =~ tr/[a-z]/[A-Z]/;\n\
    \    my $j;\n    for $j (0..$#t) {\n        $s[$j] = $t[$j] unless $s[$j] =~ /\\\
    pL/;\n        $s[$j] =~ tr/[A-Z]/[a-z]/;\n    }\n    return join \"\", @s;\n}\n\
    </code>\nIt was tested with following results:\n<code>\n  Solve \"1234\" returned\
    \ \"4321\" ", "    chomp($s);\n    \n    $s = uc($s) unless $s =~ /[A-Z]/;\n \
    \   $s = lc($s) unless $s =~ /[a-z]/;\n    \n    my $a = $s;\n    $a =~ s/(.)/\\\
    L$1/g;\n    $a =~ s/\\L$//;\n    $a =~ s/(.)/\\U$1/g;\n    $a =~ s/\\U$//;\n \
    \   \n    $a =~ tr/a-zA-Z/ /;\n    $a =~ tr/A-Z/a-z/;\n    $a =~ tr/@#$%^&*()_+=-[]\\\
    \\\\';,./:;<=>?@^_{}|~-=~/ /;\n    \n    return $a;\n}", "    $s =~ s/[[:lower:]]/lc($1)/ge;\n\
    \    $s =~ s/[[:upper:]]/uc($1)/ge;\n    return $s;\n}", "    my $str = reverse($s);\n\
    \    $str =~ s/^(.)(.)(.)/$3$2$1/;\n    return $str;\n}\n</code>\n<|/ a tags=regex,perl\
    \ |>\n<| a dscore=2 |>\nA simple solution without using any Perl specific regular\
    \ expression would be\n<code>", "    \n    # Your code here\n    for ( my $i =\
    \ 0; $i < length($s); $i++ ) {\n        my $ch = $s[$i];\n        if ( $ch =~\
    \ /^[a-z]/i ) {\n            $s[$i] = $ch;\n        } else {\n            $s[$i]\
    \ = $ch =~ tr/a-z/A-Z/;\n        }\n    }\n    \n    $s =~ tr/A-Z/a-z/;\n    return\
    \ $s;\n}\n</code>\n<|/ a tags=algorithm,perl,regex,string |>\n<| c |>\nThe question\
    \ is about Perl regular expressions, not POSIX regular expressions.\n<|/ c |>\n\
    <| c |>\nOops. I didn't see that and I missed \"perl\" in my answer. Fixed now.\n\
    <|/ c |>\n<| c |>\n`s/$/` doesn't do anything useful if you're replacing with\
    \ `$`.\n<|/ c |>\n<| a |>\n<code>\nmy $s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\
    ;\nmy $c = \"abcdefghijklmnopqrstuvwxyz\";\nmy $r = \"\";\nmy $len = length($s);\n\
    my $i = 0;\nmy $tmp;\nwhile ($i < $len)\n{\n    $tmp = $s[$i];\n    if ( $tmp\
    \ =~ /^[a-z]/i )\n    {\n        $r += $tmp;\n        $i += 1;\n    }\n    else\n\
    \    {\n        $r = substr($r,0,length($r)-1) + $tmp;\n    }\n}\nprint \"$r\\\
    n\";\n</code>\n<|/ a dscore=0 tags=algorithm,perl,regex,string |>\n<| a tags=algorithm,perl,regex,string\
    \ |>\nHere's a Perl solution using tr/// and \\Q...\\E that seems to run quite\
    \ fast.\n<code>\nmy $str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\
    ;", "    if($s =~ /\\A[a-zA-Z]+\\z/) {\n        my $s = ucfirst($s);\n       \
    \ $s =~ tr/a-z/A-Z/;\n    }\n    else {\n        $s =~ tr/A-Z/a-z/;\n    }\n \
    \   return $s;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhat about when there\
    \ is more than one letter in a word?  For instance, \"Apple\" and \"aPple\" both\
    \ become \"ApplE\" when converted to lower case.\n<|/ c |>\n<| c |>\n, good question!\
    \ I believe this only applies to English text, as I tested it on Chinese, it doesn't\
    \ handle \"Chinese\". I think I will have to come up with a new solution. I will\
    \ come back and update this answer.\n<|/ c |>\n<| c |>\nSorry, didn't notice you\
    \ edited your question and saw your answer!  That does work!\n<|/ c |>\n<| a tags=perl,regex\
    \ dscore=4 |>\n<code>", "    my(@result) = (\"\");\n    $s =~ m/^\\w/g;\n    $s\
    \ =~ m/\\w/g;\n    $s =~ m/^\\W/g;\n    $s =~ m/\\W/g;\n    $s =~ m/^[A-Za-z]/g;\n\
    \    $s =~ m/[A-Za-z]/g;\n    $s =~ m/^\\p{L}+/g;\n    $s =~ m/\\p{L}+/g;\n  \
    \  $s =~ m/^\\P{L}+/g;\n    $s =~ m/\\P{L}+/g;\n    $s =~ m/^[a-z]/g;\n    $s\
    \ =~ m/[a-z]/g;\n    $s =~ m/^[^A-Za-z]/g;\n    $s =~ m/[^A-Za-z]/g;\n    $s =~\
    \ m/^[\\p{L}]+/g;\n    $s =~ m/[\\p{L}]+/g;\n    $s =~ m/^[\\P{L}]+/g;\n    $s\
    \ =~ m/[\\P{L}]+/g;\n    $s =~ m/^[a-z]+/g;\n    $s =~ m/[a-z]+/g;\n    foreach\
    \ my $char (split //, $s) {\n        $char = $char;\n        $char = $char =~\
    \ tr/A-Z/a-z/;\n        $char = $char =~ tr/a-z/A-Z/;\n        $char =~ tr/[^A-Za-z]/[A-Za-z]/;\n\
    \        $char =~ tr/[^a-z]/[a-z]/;\n    }\n    $s =~ s/^/@/g;\n    $s =~ s/$/@/g;\n\
    \    $s =~ s/@//g;\n    $s =~ s/^$/@/g;\n    $s =~ s/@/-/g;\n    $s =~ s/@/-/g;\n\
    \    $s =~ s/-/@/g;\n    $s =~ s/-/@/g;\n    $s =~ s/@//g;\n    $s =~ s/$/-/g;\n\
    \    $s =~ s/$/-/g;\n    $s =~ s/-$/@/g;\n    $s =~ s/-$/@/g;\n    $s =~ s/@/-/g;\n\
    \    $s =~ s/@/-/g;\n    $s =~ s/-/@/g;\n    $s =~ s/-/@/g;\n    $s =~ s/@/-/g;\n\
    \    $s =~ s/@/-/g;\n    $s =~ s/-/@/g;\n    $s =~ s/-/@/g;", "    return $s if\
    \ !$s || !$s =~ /[^a-z]/;\n    return $s =~ s/^([a-z])/uc($1) . $1/ge;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is a nice clean solution. Although it makes use\
    \ of external tools. Though I believe that `tr///` can be avoided using Perl's\
    \ `transliterate` function. E.g. `s/^([a-z])/uc($1) . $1/eg;`\n<|/ c |>\n<| c\
    \ |>\nYes, you're right, I forgot about that.\n<|/ c |>\n<| a dscore=2 tags=perl,regex\
    \ |>\nI thought about it more and I believe this should work for you:\n<code>\n\
    use strict;\nuse warnings;", "    # your code goes here\n    my $reverse = \"\"\
    ;\n    for my $i (0 .. length($s) - 1) {\n        my $c = substr($s, $i, 1);\n\
    \        my $l = uc($c); # convert c to uppercase if it is a letter\n        if\
    \ ($l ne $c) {\n            $reverse = substr($reverse, 0, $i-1) . $l;\n     \
    \   }\n        else {\n            $reverse = $reverse . $c;\n        }\n    }\n\
    \    return $reverse;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis seems like\
    \ a very nice solution, but could you add some explanation to it so that it is\
    \ more understandable to people?\n<|/ c |>\n<| c |>\n: Thank you, I have added\
    \ some explanation.\n<|/ c |>\n<| c |>\nSorry but I think this solution is wrong\
    \ if for example `solve(\"ABcd\")` returns `ACBd`, it should be `abc`\n<|/ c |>\n\
    <| c |>\n: Oops, my fault, fixed.\n<|/ c |>\n<| a dscore=1 tags=string,perl,substitution\
    \ |>\n<code>\n$ perl -le 'print lcfirst \"hello\" =~ s/(.)/uc $1/r; print $_'\n\
    olleH\n</code>\nThe /r modifier makes the substitution return the result instead\
    \ of the substitution itself, so you end up with just printing the capitalized\
    \ letters.\n<|/ a |>\n<| c |>\nYeah! This is much more elegant and compact solution\
    \ than mine. +1 from me!\n<|/ c |>\n<| c |>\n, Thank you for your kind explanation.\
    \ :)\n<|/ c |>\n<| a dscore=1 |>\nHere is my solution:\n<code>", "    my $i =\
    \ 0;\n    while($i < length($s)) {\n        my $c = substr($s,$i,1);\n       \
    \ my $l = ucfirst($c);\n        if ($l eq $c) {\n            $c = lcfirst($c);\n\
    \        }\n        else {\n            $c = ucfirst($c);\n        }\n       \
    \ $s = substr($s,0,$i) + $c + substr($s,$i+1,length($s));\n        $i += 1;\n\
    \    }\n    return $s;\n}", "    my $res = \"\";\n    for( 0..$#s ) {\n      \
    \  my $c = substr( $s, $_, $_ );\n        $c =~ s/([a-z])/lc $1/ig;\n        $res\
    \ .= $c;\n    }\n    $res =~ tr/A-Z/a-z/;\n    return $res;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a |>\n<code>\nstring reverse(string)\n{\n    string reverse\
    \ = \"\";\n    string input = \"\";\n    int length = string.length();", "   \
    \ return $s unless $s =~ /[A-Z]/;\n    $s =~ s/([A-Z])/$1/;\n    $s =~ s/([a-z])/\\\
    u$1/i;\n    return $s;\n}\n</code>\n<|/ a tags=reverse,perl |>\n<| a dscore=4\
    \ |>\n<code>\nuse utf8;\nuse strict;\nuse warnings;", "    \n    if ( $s =~ /^[a-zA-Z]+$/\
    \ ) {\n        $s =~ tr/A-Z/a-z/;\n    }\n    else {\n        $s =~ tr/a-z/A-Z/;\n\
    \    }\n    \n    return $s;\n}", "    my @l = split(//,$s);\n    my $res = \"\
    \";\n    foreach my $letter (@l) {\n        if($letter =~ m/[A-Za-z]/) {\n   \
    \         $res .= uc($letter);\n        } elsif ($letter =~ m/\\W/) {\n      \
    \      $res .= $letter;\n        }\n    }\n    return $res;\n}", "    my $res;\n\
    \    my $index = 1;\n    $res = $s[0];\n    while (index($s,$res) != -1) {\n \
    \       if ($s[index($s)] == lc($s[index($s)]) ) {\n            $index++;\n  \
    \          chop $s[index($s)];\n            $res = $res.$s[index($s)];\n     \
    \   } else {\n            $res = $res.$s[index($s)];\n        }\n    }\n    if\
    \ (length($res) == length($s)) {\n        $res = reverse($res);\n    }\n    return\
    \ $res;\n}", "    my $res = $s;\n    if ($s !~ /[[:alpha:]]/) {\n        $res\
    \ = $s =~ tr/a-z/A-Z/;\n    }\n    return $res;\n}\n</code>\n<|/ a tags=perl,pattern-matching\
    \ |>\n<| c |>\nThanks, I think that's the best answer. I'll try to use it as a\
    \ sub and see if I can reuse it.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    my\
    \ @s = split(//, $s);\n    return join(\"\", map { /[a-z]/i ? ucfirst($_) : lc($_)\
    \ } @s) . lc($s);\n}\n</code>\n<|/ a |>\n<| c |>\nthanks for your help, but i\
    \ need to solve this without using subroutine.\n<|/ c |>\n<| c |>\nWhat do you\
    \ mean by \"without using subroutine\"?\n<|/ c |>\n<| c |>\nYou have to split\
    \ your string into character strings. You then have to iterate through these character\
    \ strings one character at a time with a for loop. Within the loop, you will use\
    \ an if statement to determine what you need to do. For each character you will\
    \ want to use the map function to determine if it's a letter. You will then need\
    \ to concatenate the character with its uppercase or lowercase version depending\
    \ on the result of the if statement.\n<|/ c |>\n<| c |>\nHe means that he can't\
    \ use subroutines at all. Using `split` doesn't count as a subroutine.\n<|/ c\
    \ |>\n<| c |>\nI see, thanks. I updated my answer to reflect that `split` isn't\
    \ a subroutine anymore.\n<|/ c |>\n<| a dscore=0 |>\nAnother way to do the same\
    \ without using subroutine.\n<code>\nprint \"Enter the string\\n\";\n$str=<STDIN>;\n\
    chomp($str);\n$len=length($str);\nprint \"Length of the string is $len\\n\";\n\
    for ($i=0;$i<$len;$i++){\nif ($str[$i] >= 'a' && $str[$i] <= 'z')\n{\n    $str[$i]=chr($str[$i]+32);\n\
    }\nelseif ($str[$i] >= 'A' && $str[$i] <= 'Z')\n{\n    $str[$i]=chr($str[$i]-32);\n\
    }\nelse\n{\n    $str[$i]=$str[$i];\n}\n}\nprint \"The string after reversing is:\
    \ \".$str;\n</code>\n<|/ a tags=perl |>\n<| c |>\nThis is not the way to go. You\
    \ are working with characters, not strings. This is called a \"magic number\"\
    .\n<|/ c |>\n<| c |>\nYes, i agree with you. Thanks for pointing out.\n<|/ c |>\n\
    <| a tags=perl |>\n<code>\nuse strict;\nuse warnings;\nuse feature 'say';", " \
    \   my @res;\n    my @tmp;\n    my $i = 0;\n    while($i < length($s)) {\n   \
    \     if($s[i] =~ /^[a-z]$/) {\n            push @tmp, $s[i]. ($s[i] =~ /[a-z]/i\
    \ ? 'a' : 'A');\n        } elsif($s[i] =~ /[a-z]/i) {\n            push @tmp,\
    \ $s[i]. ($s[i] =~ /[a-z]/i ? 'A' : 'a');\n        } else {\n            push\
    \ @tmp, $s[i];\n        }\n        ++$i;\n    }\n    if(length($s) == 1) {\n \
    \       push @res, pop(@tmp);\n    } else {\n        push @res, join(\"\", map\
    \ { $tmp[$_] } 0 .. $#tmp);\n    }\n    return join(\"\", @res);\n}\n</code>\n\
    <|/ a tags=string,perl dscore=0 |>\n<| a tags=string,perl dscore=0 |>\nHere is\
    \ an implementation without using any modules, loops, arrays, regexes, and loops\
    \ that is as fast as possible. \n<code>", "    $s =~ s/\\B([a-zA-Z])/\\U$1/ig;\n\
    \    return $s;\n}\n</code>\n<|/ a |>\n<| a dscore=3 tags=string,perl |>\nThe\
    \ following solution will reverse a string, ignoring numbers as you mentioned\
    \ in comments.\n<code>", "    $s =~ s/([A-Z]+)([A-Z][a-z])/$1.$2/i; \n    return\
    \ $s if $s =~ /\\A[A-Za-z]+\\Z/i;\n    $s =~ s/([a-z])([A-Z])/$2.$1/i; \n    return\
    \ $s if $s =~ /\\A[a-z]+\\Z/i;\n    return $s; \n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks very much for the help. I tested it and it worked perfectly. I'll be sure\
    \ to use it next time.\n<|/ c |>\n<| a |>\nFor those who come here in 2020, the\
    \ answers here don't work anymore. These are the solutions you can use:\n<code>",
  "    my $reverse = \"\";\n    $s =~ tr/A-Z/a-z/;\n    \n    for ($s) {\n       \
    \ my $temp = uc $1;\n        $reverse .= $temp if $temp =~ /^[aeiou]/i;\n    }\n\
    \    return $reverse;\n}\n</code>\n<|/ a dscore=0 tags=perl,regex |>\n<| a tags=perl,regex\
    \ dscore=0 |>\n<code>\nmy $input='abbccc';\nmy = split(//,$input);\nprint join('',map\
    \ {$_=~tr/a-z/A-Z/}@words) . \"\\n\";\n</code>\n<|/ a |>\n<| a tags=perl,regex\
    \ |>\nI made this solution :\n<code>\nuse strict;\nuse warnings;\nuse feature\
    \ 'say';", "    my $str = \"\";\n    my $lower = 0;\n    my $upper = 0;\n    for\
    \ my $char (split(//,$s)) {\n        my $char = uc($char);\n        if ($char\
    \ eq \"A\") {\n            if ($lower == 0) {\n                my $str2 = \"\"\
    ;\n                for (my $i = 0; $i < length($str); $i++) {\n              \
    \      $str2 = substr($str,$i,1) . substr($str2,0,length($str2)-1);\n        \
    \        }\n                $str = $str2;\n            }\n            else {\n\
    \                $str = substr($str,0,length($str)-1) . substr($str,1,length($str));\n\
    \            }\n            $lower = 1;\n            $upper = 0;\n        }\n\
    \        elsif ($char eq \"B\") {\n            if ($upper == 0) {\n          \
    \      my $str2 = \"\";\n                for (my $i = 0; $i < length($str); $i++)\
    \ {\n                    $str2 = substr($str,$i,1) . substr($str2,length($str2)-1,1);\n\
    \                }\n                $str = $str2;\n            }\n           \
    \ else {\n                $str = substr($str,0,length($str)-1) . substr($str,1,length($str));\n\
    \            }\n            $lower = 0;\n            $upper = 1;\n        }\n\
    \        elsif ($char eq \"C\") {\n            if ($lower == 1) {\n          \
    \      my $str2 = \"\";\n                for (my $i = 0; $i < length($str); $i++)\
    \ {\n                    $str2 = substr($str,$i,1) . substr($str2,0,length($str2)-1);\n\
    \                }\n                $str = $str2;\n            }\n           \
    \ else {\n                $str = substr($str,0,length($str)-1) . substr($str,1,length($str));\n\
    \            }\n            $lower = 1;\n            $upper = 1;\n        }\n\
    \        else {\n            $str = $char;\n        }\n    }\n    return $str;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=perl,algorithm dscore=0 |>\nI didn't\
    \ try any perl but a solution in python is as below:\n<code>\ndef solve1(s):\n\
    \    # code goes here\n    lower = False\n    upper = False\n    answer = ''\n\
    \    for i in range(len(s)):\n        if s[i].isalpha():\n            if lower:\n\
    \                answer = answer + s[len(s) - i - 1 : len(s) - i]\n          \
    \      lower = False\n                upper = True\n            else:\n      \
    \          answer = answer + s[i]\n                lower = True\n            \
    \    upper = False\n        else:\n            answer = answer + s[i]\n    return\
    \ answer\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef solve(s):\n    lower = False\n\
    \    upper = False", "    return $s unless $s;\n    \n    $s =~ s/^.//;\n    $s\
    \ =~ s/(.)([A-Z])/$1\\L$2/g;\n    return $s unless $s;\n    \n    $s =~ s/(.)([a-z])/$1\\\
    U$2/g;\n    return $s unless $s;\n    return $s;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThe question specifies that the string can be empty\n<|/ c |>\n<| c |>\n\
    The OP did not specify that. I just copied the sample code given by the OP.\n\
    <|/ c |>\n<| c |>\nThanks for the solution. I also found this link that uses recursion:\
    \ http://www.cs.binghamton.edu/~jamie/163/fall08/lectures/recursion.pdf\n<|/ c\
    \ |>\n<| a dscore=4 tags=perl,string,reverse |>\nMy answer would be a combination\
    \ of split and reverse:\n<code>", "    \n    # find out letters and numbers\n\
    \    my @letters = ();\n    my @numbers = ();\n    \n    for(my $i = 0; $i < length($s);\
    \ $i++) {\n        if($s[$i] =~ /[a-z]/i) {\n            push @letters, $s[$i];\n\
    \        } elsif($s[$i] =~ /\\d/i) {\n            push @numbers, $s[$i];\n   \
    \     }\n    }", "    my @s = split(//, $s);\n    my $reversed = \"\";\n    \n\
    \    foreach my $ele (@s) {\n        my $lc = uc($ele);\n        if (!defined($lc))\
    \ {\n            $lc = \"A\" x length($ele);\n        }\n        $reversed .=\
    \ $lc;\n    }\n    \n    if (length($reversed) > 1) {\n        $reversed = substr($reversed,\
    \ 0, -1);\n    }\n    \n    return $reversed;\n}", "    my(@res);\n    for(my\
    \ $i=0;$i<length($s);$i++) {\n        my($ch,$tmp);\n        $ch = $s[$i];\n \
    \       my $up = (lc($ch) eq \"a\") || (lc($ch) eq \"b\") || (lc($ch) eq \"c\"\
    );\n        if($ch eq \"#\" || $ch eq \"@\" || $ch eq \"$\"){\n            push(@res,$ch);\n\
    \        }\n        elsif($ch eq $up){\n            push(@res,$ch);\n        }\n\
    \        elsif($ch eq $s[$i+1]){\n            if($tmp){\n                $tmp\
    \ = $tmp;\n                $tmp =~ tr/[a-z]/[A-Z]/;\n                $tmp =~ tr/A-Z/[a-z]/;\n\
    \                push(@res,$tmp);\n            }\n        }\n        else {\n\
    \            push(@res,$ch);\n        }\n    }\n    \n    return join(\"\",@res);\n\
    }\n</code>\n<|/ a tags=algorithm,string,perl |>\n<| c |>\nI think it fails to\
    \ handle the case of no vowels in the string. `solve(\"z\")` returns `z`.\n<|/\
    \ c |>\n<| a tags=algorithm,string,perl |>\nThe following works in O(N) time and\
    \ uses no hash lookups:\n<code>", "    $s =~ /([a-zA-Z])/g;\n    $s =~ s/([a-zA-Z])/\\\
    u$1/ig;\n    return $s;\n}", "    my $len = length($s);\n    return if $len <=\
    \ 0;", "    my $ret = \"\";\n    foreach my $c (split //, $s) {\n        if ($c\
    \ =~ /^[A-z]$/) {\n            $ret .= $c;\n        } elsif ($c =~ /[^A-z]/) {\n\
    \            $ret .= uc($c);\n        } else {\n            $ret .= $c;\n    \
    \    }\n    }\n    return $ret;\n}", "    \n    my @arr = split('', $s);\n   \
    \ my $s = \"\";\n    foreach my $char (@arr) {\n        if($char =~ /^[a-z]$/i)\
    \ {\n            $char = lc($char);\n        } else {\n            $char = uc($char);\n\
    \        }\n        $s .= $char;\n    }\n    \n    return $s;\n}\n</code>\n<|/\
    \ a tags=perl |>\n<| c |>\nI tested all the answers and this one is the fastest\
    \ in all tests I ran. Thank you.\n<|/ c |>\n<| c |>\nThis solution assumes that\
    \ `lc` and `uc` work correctly for all characters in Unicode.\n<|/ c |>\n<| c\
    \ |>\nAgreed, it assumes lc returns the correct value. Perhaps it would be better\
    \ to use `lc` directly on the `chr` function, which would also fix the issue of\
    \ \"non-letters\" being interpreted as letters.\n<|/ c |>\n<| a tags=perl |>\n\
    The fastest way is probably to use map and chr:\n<code>\nmap { chr $_ } reverse\
    \ split //, $s;\n</code>\nIt could be more efficient to do the chr calls only\
    \ when needed:\n<code>\nmy $chars = join \"\", map { chr $_ } reverse split //,\
    \ $s;\n$chars = map { /[a-z]/i ? lc $_ :  uc $_ } split //, $chars;\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n`map { /[a-z]/i ? lc $_ :  uc $_ } split //, $s` should\
    \ be written `map { /[a-z]/i ? lc $_ : uc $_  } split //, $s`. Using `map` on\
    \ one side of the `/` will do the wrong thing if the regexp doesn't match. Also,\
    \ you probably mean `split //, $s`, not `split \"\", $s`.\n<|/ c |>\n<| c |>\n\
    , Thanks, fixed. Also, fixed the split on empty string\n<|/ c |>\n<| a dscore=5\
    \ |>\nYou could use String::Reverse from the core module instead of writing your\
    \ own.\n<|/ a tags=perl |>\n<| c |>\nIt's a core module and works well for me.\
    \ I use it all the time when I have to do some very simple string manipulations,\
    \ like changing characters in string and reversing it etc.\n<|/ c |>\n<| c |>\n\
    It's also in the [Perl core](http://perldoc.perl.org/per", "    $s =~ s/^([A-Z]+)/\\\
    L$1/;\n    $s =~ s/^([0-9]+)/\\U$1/;\n    $s =~ s/^([a-z]+)/\\l$1/;\n    $s =~\
    \ s/^([0-9]+)/\\u$1/;\n    $s =~ s/^([A-Z0-9]+)/\\U$1/;\n    $s =~ s/^([a-z]+)/\\\
    l$1/;\n    $s =~ s/^([0-9]+)/\\u$1/;\n    $s =~ s/^([A-Z]+)/\\L$1/;\n    return\
    \ $s;\n}", "    $s =~ s/^([a-z])/lc($1)/ig;\n    $s =~ s/([A-Z])/uc($1)/ig;\n\
    \    $s =~ s/^[^a-zA-Z]/lc($&)/ig;\n    return $s;\n}\n</code>\nThe idea is to\
    \ convert the whole string into a case insensitive character, apply the above\
    \ transformations, and then convert the string back into the original case.\n\
    <|/ a tags=perl,regex,string |>\n<| c |>\nThanks for adding more explanation and\
    \ an example of how to do it.  It's really helpful to see how to do it for future\
    \ reference.\n<|/ c |>\n<| a dscore=2 |>\nThis question is a bit old now but I\
    \ had to solve this problem recently and thought I would share my solution here\
    \ for others that may come across this question and need help.\n<code>\nuse strict;\n\
    use warnings;\nuse POSIX;", "    my(@result) = ('');\n    \n    for (my $index\
    \ = 0; $index <= length($s) - 1; $index++) {\n        my($l) = substr($s, $index,\
    \ 1);\n        my($u) = substr($s, $index, 1);\n        if ($l =~ m/^[a-zA-Z]/)\
    \ {\n            $u = $l;\n        }\n        else {\n            $l = \"$u\"\
    ;\n        }\n        push(@result, $l);\n        push(@result, $u);\n    }\n\
    \    return join(\"\", @result);\n}", "    return $s if $s =~ /^\\s*$/;\n    my(@c);\n\
    \    \n    foreach my $s (split //, $s) {\n      push (@c, $s unless $s =~ /^\\\
    s/);\n    }\n    \n    foreach my $c (@c) {\n      if (my $a = lc $c) {\n    \
    \      $c = $a;\n      }\n    }\n    \n    return join('', map {uc $_ } @c);\n\
    }", "    \n    $s =~ s/^#//;\n    $s =~ s/^@//;\n    \n    # check if it contains\
    \ only digits and characters\n    my $digits = $s =~ /[0-9]+/;\n    $digits and\
    \ $digits == length($s);\n    \n    # check if it is a single letter and convert\
    \ it to upper or lower case\n    my $single = $s =~ /[a-z]/i;\n    $single and\
    \ $single == length($s);\n    \n    # no letters found, reverse the string\n \
    \   $single or $digits and $digits == length($s);\n    \n    $s = reverse($s)\
    \ unless $single or $digits;\n    \n    return $s;\n}", "    my @c = split('',\
    \ uc($s));", '    return "" unless $s;', "    $s =~ s/[a-z]/[A-Z]/g;\n    $s =~\
    \ s/[A-Z]/[a-z]/g;\n    $s =~ s/^#//;\n    $s =~ s/@/[#]/;\n    $s =~ s/[#$]//;\n\
    \    $s =~ s/^[#]/]/;\n    $s =~ s/$/]/;\n    $s =~ s/[\\\\]/]/;\n    $s =~ s/^\\\
    [/[/;\n    $s =~ s/\\]$//;\n    $s =~ s/\\[/\\\\\\[/g;\n    $s =~ s/\\]/\\\\\\\
    ]/g;\n    $s =~ s/\\\\//;\n    return $s;\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ solution is very good for short strings, but fails on longer strings. e.g. 'abc'\
    \ -> 'cba'\n<|/ c |>\n<| c |>\nThis answer has nothing to do with the question\
    \ asked.  What if you're working with long strings with many characters that need\
    \ to be reversed? e.g. 'ab cd ab'? Your code will replace each instance of the\
    \ original string.  I think my code will be better for that situation.\n<|/ c\
    \ |>\n<| a |>\nA bit late to the party, but I thought I would just provide another\
    \ solution that I think will be a little more efficient than using a regex. \n\
    This code works by first getting an array of characters in the string. Then, we\
    \ convert the string to its numeric representation (in this case using ord) and\
    \ then converting it back into its string representation.\nThen, we split the\
    \ string and go through each character in turn, swapping each character with the\
    \ character at the opposite position of the one that came before it.\nFinally,\
    \ we return the string representation of the array.\n<code>", "    if($s =~ m/^[A-Za-z]+$/)\
    \ {\n        $s =~ s/([a-z])/uc $1/i;\n    } else {\n        $s =~ s/([A-Z])/uc\
    \ $1/i;\n    }\n    $s;\n}", "    $s =~ tr/a-zA-Z/A-Z/;\n    $s =~ tr/A-Z/a-z/;\n\
    \    map {$_} split //, $s;\n    return $s;\n}", "    if($s =~ /[a-z]/i){\n  \
    \      $s =~ s/[a-z]/[A-Z]/g;\n        $s =~ s/[A-Z]/[a-z]/g;\n    }\n    elsif(not($s\
    \ =~ /[a-z]/i)){\n        $s =~ s/[a-z]/[A-Z]/g;\n    }\n    return $s;\n}", " \
    \   $s =~ tr/A-Z/a-z/;\n    $s =~ tr/a-z/A-Z/;\n    return $s;\n}", "    if ($s\
    \ =~ /^[a-zA-Z]+$/) {\n        $s =~ s/^([a-zA-Z]+)/Ucfirst($1)/i;\n        $s\
    \ =~ s/([a-zA-Z])/Ucfirst($1)/i; \n    } else {\n        $s = reverse $s;\n  \
    \  }\n    $s;\n}", "    my($reversedstring);\n    my $i;\n    for(my $i = 0; $i\
    \ < length($s); $i++) {\n        my $letter = $s[$i];\n        my $upper;\n  \
    \      my $lower;\n        if($letter =~ m/^[a-zA-Z]$/) {\n            $upper\
    \ = $letter;\n            $lower = uc($letter);\n        }\n        elsif($letter\
    \ =~ m/^[a-zA-Z]/) {\n            $upper = $letter;\n            $lower = $letter;\n\
    \        }\n        else {\n            $upper = $letter;\n            $lower\
    \ = $letter;\n        }\n        if($i == 0) {\n            $reversedstring =\
    \ $lower;\n        }\n        elsif($i == ($length - 1)) {\n            $reversedstring\
    \ .= $upper;\n        }\n        else {\n            $reversedstring .= $lower;\n\
    \        }\n    }\n    return $reversedstring;\n}", "    $s =~ s/([^A-Za-z])([A-Z])/$1$2/g;\n\
    \    $s =~ s/([A-Z])([^A-Za-z])/$2$1/g;\n    $s =~ s/^([A-Z])([A-Z])/$2$1/g;\n\
    \    $s =~ s/^([A-Z])/$2/g;\n    $s =~ s/([A-Z])$1/$1/g;\n    return $s;\n}\n\
    </code>\n<|/ a tags=ruby,regex dscore=0 |>\n<| c |>\nThis is pretty straight forward,\
    \ but not quite so efficient as your solution would be. You'd still have to loop\
    \ through the string three times to get the result you want.\n<|/ c |>\n<| c |>\n\
    , you are right. I guess I didn't take into consideration that the result would\
    \ be the same if reversed or not and if the string contains only one char. My\
    \ bad.\n<|/ c |>\n<| a tags=ruby,regex |>\n<code>\n'aAbcdef' =~ /([a-z])\\1/\n\
    \ => 2", "    my @s = split(//,$s);\n    my $result = \"\";\n    foreach my $letter\
    \ (@s) {\n        if (length($letter)) {\n            $letter =~ tr/a-z/A-Z/;\n\
    \        }\n        else {\n            $letter =~ tr/A-Z/a-z/;\n        }\n \
    \       $result .= $letter;\n    }\n    return $result;\n}", "    \n    # Initialize\
    \ a string to reverse and return the string\n    $s = \"\" if $s eq \"\";\n  \
    \  my $reversed = \"\";\n    \n    for(my $i = 0; $i < length($s); $i++) {\n \
    \       \n        if($s[i] eq \" \") {\n            $s = \"$reversed$s[$i]\";\n\
    \            $i = length($s) - 1;\n        }\n        \n        elsif($s[i] eq\
    \ \"A\") {\n            $s = \"$s[$i]B$s[$i+1]\";\n            $i += 2;\n    \
    \    }\n        elsif($s[i] eq \"B\") {\n            $s = \"$s[$i]A$s[$i+1]\"\
    ;\n            $i += 2;\n        }\n        elsif($s[i] eq \"C\") {\n        \
    \    $s = \"$s[$i]B$s[$i+1]\";\n            $i += 2;\n        }\n        elsif($s[i]\
    \ eq \"D\") {\n            $s = \"$s[$i]C$s[$i+1]\";\n            $i += 2;\n \
    \       }\n        elsif($s[i] eq \"E\") {\n            $s = \"$s[$i]D$s[$i+1]\"\
    ;\n            $i += 2;\n        }\n        elsif($s[i] eq \"F\") {\n        \
    \    $s = \"$s[$i]E$s[$i+1]\";\n            $i += 2;\n        }\n        elsif($s[i]\
    \ eq \"G\") {\n            $s = \"$s[$i]F$s[$i+1]\";\n            $i += 2;\n \
    \       }\n        elsif($s[i] eq \"H\") {\n            $s = \"$s[$i]G$s[$i+1]\"\
    ;\n            $i += 2;\n        }\n        elsif($s[i] eq \"I\") {\n        \
    \    $s = \"$s[$i]H$s[$i+1]\";\n            $i += 2;\n        }\n        elsif($s[i]\
    \ eq \"J\") {\n            $s = \"$s[$i]I$s[$i+1]\";\n            $i += 2;\n \
    \       }\n        elsif($s[i] eq \"K\") {\n            $s = \"$s[$i]J$s[$i+1]\"\
    ;\n            $i += 2;\n        }\n        elsif($s[i] eq \"L\") {\n        \
    \    $s = \"$s[$i]K$s[$i+1]\";\n            $i += 2;\n        }\n        elsif($s[i]\
    \ eq \"M\") {\n            $s = \"$s[$i]L$s[$i+1]\";\n            $i += 2;\n \
    \       }\n        elsif($s[i] eq \"N\") {\n            $s = \"$s[$i]M$s[$i+1]\"\
    ;\n            $i += 2;\n        }\n        elsif($s[i] eq \"O\") {\n        \
    \    $s = \"$s[$i]N", "    \n    return $s if !$s || !$s[0];\n    \n    my(@result)\
    \ = ();\n    my($letter) = ();\n    my $reversed = \"\";\n    \n    # First check\
    \ if there are any letters. If there are no letters, just return it.\n    foreach\
    \ my $l (@{$s}) {\n        $letter .= lc $l;\n    }\n    return $letter if $letter;\n\
    \    \n    foreach my $l (@{$s}) {\n        if($l =~ /\\w/) {\n            $letter\
    \ .= lc $l;\n        } else {\n            $letter .= $l;\n        }\n    }\n\
    \    \n    # No letters, just return it as it is.\n    return $letter if $letter;\n\
    \    \n    foreach my $l (@{$s}) {\n        if($l =~ /\\w/) {\n            my\
    \ $tmp = lc $l;\n            $letter = $tmp if $letter eq $tmp;\n        } else\
    \ {\n            my $tmp = lc $l;\n            $letter = $tmp if $letter ne $tmp;\n\
    \        }\n    }\n    \n    $reversed = $letter;\n    \n    $letter =~ tr/[a-z]/[A-Z]/;\n\
    \    $letter =~ tr/[A-Z]/[a-z]/;\n    \n    $reversed = $letter;\n    \n    $letter\
    \ =~ tr/[A-Z]/[a-z]/;\n    $letter =~ tr/[a-z]/[A-Z]/;\n    \n    $reversed =\
    \ $letter;\n    \n    return $reversed;\n}", "    my @chars = split(//, $s);\n\
    \    my $i = 0;\n    while ($i < @chars) {\n        my $char = substr($chars[$i],\
    \ 0, 1);\n        if ($char =~ /[a-z]/i) {\n            if ($char =~ /[a-z]/i)\
    \ {\n                $chars[$i] = $char . substr($chars[$i], 1);\n           \
    \ } else {\n                $chars[$i] = substr($chars[$i], 0, 1) . substr($chars[$i],\
    \ 1);\n            }\n        } else {\n            $chars[$i] = substr($chars[$i],\
    \ 0, 1) . substr($chars[$i], 1);\n        }\n        ++$i;\n    }\n    return\
    \ join(\"\", @chars);\n}", "    \n    if ($s =~ /^[a-z]+$/i) {\n\t$s = uc($s);\n\
    \    } else {\n\t$s = reverse $s;\n    }", "    my $slen = length($s);\n    my\
    \ $i = 0;", "    my @chars = split(//, $s);\n    my $res = $s;\n    my $l = @chars;\n\
    \    my $i;", "    my $rev = \"\";\n    for (my $i = 0; $i < length($s); ++$i)\
    \ {\n        my $c = substr($s, $i, 1);\n        my $up = $c =~ /[a-z]/i;\n  \
    \      if ($up) {\n            $rev .= $c =~ /[A-Z]/i ? uc($c) : $c;\n       \
    \ } else {\n            $rev .= $c;\n        }\n    }\n    if ($rev) {\n     \
    \   return $rev;\n    } else {\n        return $s;\n    }\n}", "    # base case\n\
    \    return $s if length($s) == 0;\n    $s =~ s/^\\s+|\\s+$//g;\n    $s =~ s/^[[:alpha:]]/ucfirst($1)/g;\n\
    \    $s =~ s/^[[:alpha:]]+/ucfirst($&)/g;\n    return $s;\n}", "    \n    \n \
    \   my $result;\n    if ( $s =~ m/^\\s*$/ ) {\n        $result = $s;\n    } elsif\
    \ ( $s =~ m/^\\s*([A-Za-z]+)\\s*$/ ) {\n        $result = $1 . ucfirst($1);\n\
    \    } elsif ( $s =~ m/^\\s*([a-z]+)\\s*$/ ) {\n        $result = $1 . ucfirst($1);\n\
    \    } else {\n        $result = ucfirst($s);\n    }\n    \n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution is very smart.  It could\
    \ be improved by reversing if the string contains multiple letters such as \"\
    aBc\".  It could be further improved by reversing only if the string begins with\
    \ a number.\n<|/ c |>\n<| c |>\n`The function should return the resulted string.`\n\
    <|/ c |>\n<| a tags=string,perl,regex |>\nYou can do that using negative lookahead\
    \ and capture groups:\n<code>\nuse strict;\nuse warnings;", "    my $r = \"\"\
    ;\n    my $i = 0;\n    for(my $l = 0; $l < length($s); $l++) {\n        if($s[i]\
    \ eq '#') {\n            $i++;\n        }\n        elsif(substr($s, $i, 1) =~\
    \ /[a-z]/) {\n            $r += uc(substr($s, $i, 1));\n            $i += 1;\n\
    \        }\n        elsif($s[$i] eq '') {\n            $i++;\n        }\n    \
    \    else {\n            $r += $s[$i];\n        }\n    }\n    return $r;\n}",
  "    my $reversed = \"\";\n    $s =~ s/^.*([a-z]+)/$reversed=$1;$reversed/;\n  \
    \  $s =~ s/([a-z])$/$reversed=$1$reversed/;\n    return $reversed;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=regex,reverse,perl |>\nPerl Solution: \n\
    <code>\nuse 5.010;\nuse strict;\nuse warnings;\nuse autodie;", "    my @res;\n\
    \    \n    $s =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n    \n    for (my $i = 0; $i\
    \ <= length($s); $i++) {\n        my($c) = $s =~ /[a-z]/i ? uc($s[0]) : lc($s[0]);\n\
    \        $c = substr($s, 0, $i) + $c + substr($s, $i + 1);\n        push(@res,\
    \ $c);\n    }\n    \n    return $res[0] if @res == 1;\n    \n    return $res.reverse;\n\
    }", "    $s =~ s/^[A-Za-z]+//;\n    $s =~ s/^[a-z]+//;\n    $s =~ s/[a-z]+/[A-Z]/g;\n\
    \    $s =~ s/[A-Z]+/[a-z]/g;\n    $s =~ s/^[a-z]+//;\n    $s =~ s/[A-Z]+/[a-z]/g;\n\
    \    return $s;\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this works for the example\
    \ provided, it does not generalize well to cases where `a` and `A` must swap case\
    \ (and similar for `B` and `b`).  And while this will work, it's really inefficient\
    \ (O(N^2)).\n<|/ c |>\n<| c |>\nIt's just to give the idea, not the actual code\
    \ so I don't have much to say about performance. But I agree that it's inefficient.\n\
    <|/ c |>\n<| c |>\nI added a benchmark to my answer. It seems like the answer\
    \ is still O(N^2).\n<|/ c |>\n<| c |>\n: That's a great solution, thanks! I'm\
    \ surprised it takes so much longer than the other answers (I expected it to be\
    \ O(2n) but clearly that's not the case). I'll post my benchmark results in a\
    \ second.\n<|/ c |>\n<| c |>\n: Your solution takes 788 milliseconds while my\
    \ solution takes 968 milliseconds. That's a lot more reasonable :-)\n<|/ c |>\n\
    <| a tags=string,algorithm,c++ |>\nHere's an O(N) solution based on the idea of\
    \ reversing the character in the middle:\n<code>", "    # $s is assumed to be\
    \ a string\n    $s =~ tr/a-zA-Z//cd;\n    if ($s =~ /^$/){\n        $s =~ tr/A-Z/a-z/;\n\
    \    }\n    $s;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution only reverses **consecutive\
    \ letters** not consecutive words.  For example, `solve(\"aba\")` does not return\
    \ `\"baa\"`, but `\"aba\"` since your solution treats `aba` as a single letter.\n\
    <|/ c |>\n<| c |>\nI believe I figured that out in the last edit to the answer.\
    \  My solution reverses consecutive letters, which is why `solve(\"aba\")` returns\
    \ `\"baa\"` and not `\"aba\"`.  Thank you for bringing this up.  I'll post an\
    \ edit if I find anything else.\n<|/ c |>\n<| a tags=string,ruby |>\nHere's a\
    \ solution using tr, tr!, and gsub:\n<code>\ndef solve(str)\n  str.tr!('A-Z',\
    \ 'a-z')\n  str.tr!('a-z', 'A-Z')\n  str.gsub(/[^a-zA-Z]/,'') \nend\n</code>\n\
    tr! modifies the string in place. gsub replaces consecutive non-letters with an\
    \ empty string.\n<code>\nsolve(\"aBcD\")\n  #=> \"AbcD\" \n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI believe I figured that out in the last edit to the answer.  My\
    \ solution reverses consecutive letters, which is why `solve(\"aba\")` returns\
    \ `\"baa\"` and not `\"aba\"`.  Thank you for bringing this up.  I'll post an\
    \ edit if I find anything else.\n<|/ c |>\n<| a |>\n<code>\nclass String\n  def\
    \ upcase\n    chars.map { |c| c.upcase }.join\n  end\n  def downcase\n    chars.map\
    \ { |c| c.downcase }.join\n  end\nend\n</code>\n<|/ a dscore=2 tags=string,ruby\
    \ |>\n<| c |>\nPlease explain your code. Code-only answers are discouraged on\
    \ Stack Overflow.\n<|/ c |>\n<| a dscore=1 tags=string,ruby |>\nThis is an approach\
    \ using Regex\n<code>\ndef solve(str)\n  str.gsub(/\\b([a-z])/i) { $1.upcase }\n\
    end\n</code>\nor\n<code>\ndef solve(str)\n  str.gsub(/([a-z])\\b/i) { ", "   \
    \ $s =~ s/^#//;\n    $s =~ s/^#?([a-zA-Z])/ucfirst($1)/;\n    $s =~ s/^([a-zA-Z])/lc($1)/;\n\
    \    $s =~ s/^([a-zA-Z])/uc($1)/;\n    $s =~ s/^([a-zA-Z])/lc($1)/;\n    return\
    \ $s;\n}", "    $s =~ s/^(.)//;\n    $s =~ tr/[A-Z]/ [a-z]/;\n    $s =~ s/^(.)/\\\
    U$1/g;\n    $s =~ s/^(.)/\\L$1/g;\n    return $s;\n}", '    my(@result) = ();',
  "    my $len = length($s);\n    my $str = \"\";\n    for (my $i = 0; $i < $len;\
    \ ++$i) {\n        if ($s[i] eq $s[$i]) {\n            my $lc = $s[$i];\n    \
    \        if ($lc eq 'l') {\n                substr($s, $i, 1, uc substr($s, $i,\
    \ 1));\n            }\n            elsif ($lc eq 'U') {\n                substr($s,\
    \ $i, 1, lc substr($s, $i, 1));\n            }\n        }\n        else {\n  \
    \          my $lc = $s[$i];\n            my $rc = $s[$i];\n            if ($lc\
    \ eq 'l') {\n                $str .= uc substr($s, $i, 1);\n            }\n  \
    \          elsif ($lc eq 'U') {\n                $str .= lc substr($s, $i, 1);\n\
    \            }\n            else {\n                $str .= $s[$i];\n        \
    \    }\n        }\n    }\n    return $str;\n}", "    $s =~ s/^\\s*|\\s*$//g;\n\
    \    my $i = 0;\n    my @c;\n    \n    while ($i < length($s)) {\n        my $c\
    \ = substr($s, $i, 1);\n        if ($c =~ /[a-z]/i) {\n            my $up = substr($s,\
    \ $i, 1);\n            $up =~ tr/A-Z/a-z/;\n            $s[i..$j] = $up;\n   \
    \         $i ++;\n        } else {\n            $s[i..$j] = $c;\n            $i\
    \ ++;\n        }\n    }\n    $s[i..$j] = $c;\n    $i ++;\n    \n    return $s;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nPlease be aware: this solution doesn't work for\
    \ strings having whitespace at the beginning.\n<|/ c |>\n<| c |>\n, It should\
    \ work for any string. The second regex is ensuring that whitespace is removed\
    \ before it gets checked.\n<|/ c |>\n<| c |>\nThat doesn't mean that it will work\
    \ everywhere. The second regex will remove all whitespace before checking. If\
    \ you input `a b c` then the `a` will be removed (which is good), but the `b`\
    \ and `c` will still be there.\n<|/ c |>\n<| c |>\n, Yes, I noticed that after\
    \ I posted it. Fixed.\n<|/ c |>\n<| c |>\nThe second regex is now also handling\
    \ trailing whitespace.\n<|/ c |>\n<| a |>\nIn Perl 6:\n<code>", "    if ($s =~\
    \ /[a-zA-Z]/) {\n        $s =~ s/([a-zA-Z])/$1-$1/;\n    } else {\n        $s\
    \ =~ s/^([a-zA-Z])/-$1/g;\n        $s =~ s/([a-zA-Z])$/$1-/g;\n    }\n    $s\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI do not know how to use this regex. Could you\
    \ give an example? I tried it on http://regexr.com/ and it is not working.\n<|/\
    \ c |>\n<| c |>\nI tried this regex: `/([a-zA-Z]+)/g`. It worked. But I need some\
    \ explanation of how it works. I could not find much information on `/g`.\n<|/\
    \ c |>\n<| c |>\n- This isn't a regex issue - this is Perl regex syntax. The `/g`\
    \ modifier means to replace all matches, not just the first.\n<|/ c |>\n<| a |>\n\
    <code>", "    my $len = length($s);\n    for (my $i = 0; $i < $len; $i++) {\n\
    \        my $char = $s->[$i];\n        if ($char =~ /^[a-z]+$/i) { # only consider\
    \ a-z\n            $s->[$i] = ord($char) - 64;\n        }\n    }\n    return join\
    \ '', @$s;\n}\n</code>\nThe above uses only 1 substr (the 2nd one) and doesn't\
    \ create additional arrays. \nIn fact, it even uses one regex (the 3rd one) to\
    \ determine if the string is all lowercase or all uppercase, without having to\
    \ use a loop.\n<|/ a |>\n<| c |>\nWhy not just `my $reversed = join '', map {\
    \ (/[a-z]/i ? uc : lc) } @$s;`?\n<|/ c |>\n<| a |>\n<code>", "    my $new = '';\n\
    \    map {\n        my $c = $_ eq '#' ? shift : $_ eq '@' ? shift : ord $_;\n\
    \        $c > 122 ? $c = 32 + $c : \n            $c < 65 ? $c = $c + 26 : $c <\
    \ 97 ? $c = $c + 26 : $c > 122 ? $c = $c - 26 : $c > 96 ? $c = $c - 26 : $c >\
    \ 64 ? $c = $c - 26 : $c > 32 ? $c = $c - 26 : $c > 16 ? $c = $c - 26 : $c > 8\
    \ ? $c = $c - 26 : $c > 4 ? $c = $c - 26 : $c = $c - 26;\n        $new .= chr($c);\n\
    \    } split //, $s;\n    $new =~ tr/A-Z/a-z/;\n    $new =~ tr/a-z/A-Z/;\n   \
    \ $new =~ tr/0-9/a-zA-Z/;\n    return $new;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\nThis solution solves all the test cases in O(1) time and O(1)\
    \ space.\nThis code takes the string and replaces it with the equivalent string\
    \ where each non-alphabetic character (other than the first) is replaced by its\
    \ uppercase equivalent.\n<code>", '    my(@result);', "    return $s if $s !~\
    \ /\\A[A-Za-z]+\\z/i;\n    $s =~ tr/a-z/A-Z/;\n    $s =~ tr/A-Z/a-z/;\n    return\
    \ $s;\n}", "    my @s = split(//,$s);\n    my $ret = \"\";\n    foreach my $i(@s)\
    \ {\n        if ($i =~ /^\\w$/) {\n            if ($i =~ /[a-z]/) {\n        \
    \        $ret .= uc($i);\n            } else {\n                $ret .= lc($i);\n\
    \            }\n        } else {\n            $ret .= $i;\n        }\n    }\n\
    \    if (@s == 0) {\n        $ret = $s;\n    }\n    return $ret;\n}", "    $s\
    \ =~ s/\\AE([A-Z])/$1/g;\n    return $s;\n}", "    return $s if $s =~ /^[a-zA-Z]+$/;\n\
    \    my @chars = split(//, $s);\n    my $res = \"\";\n    for my $char (@chars)\
    \ {\n        $char =~ tr/a-zA-Z//cd;\n        $char =~ tr/ABcDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz//cd;\n\
    \        $char =~ tr/aeiouAEIOU/AEIOUaeiou//cd;\n        $res .= $char;\n    }\n\
    \    return $res;\n}", "    \n    return $s unless $s;\n    \n    $s =~ tr/a-zA-Z//d;\n\
    \    $s =~ tr/a-zA-Z//d unless $s =~ /^[a-z]+$/i;", "    return $s if $s =~ /^[A-Za-z]+$/i;\n\
    \    my $len = length($s);\n    my $reverse = \"\";\n    for (my $i=$len-1; $i\
    \ >= 0; $i--) {\n        if ($s[i] >= 65 && $s[i] <= 90) {\n            $reverse\
    \ .= chr($s[i]-64);\n        } else {\n            $reverse .= $s[i];\n      \
    \  }\n    }\n    return $reverse;\n}", "    my $result = '';\n    my $i = -1;\n\
    \    my $letter;", "    if ($s =~ /^[A-z]+$/ ) {\n        $s =~ tr/a-zA-Z//cd;\n\
    \    }\n    else {\n        $s =~ tr/a-zA-Z//cd;\n    }\n    return $s;\n}", " \
    \   my($i);\n    my($j);\n    my(@chars);", "    my @chars = split(//, $s);\n\
    \    my $res = \"\";\n    for my $char (@chars) {\n        $char =~ tr/a-z/A-Z/;\n\
    \        $char =~ tr/A-Z/a-z/;\n        $res .= $char if ($char =~ /^[A-Z]/);\n\
    \        $res .= $char if ($char =~ /^[a-z]/);\n    }\n    $res;\n}", "    if\
    \ ($s =~ /[^a-zA-Z]/g) {\n        $s = join(\"\",split(\"\",ucfirst($s)));\n \
    \   } else {\n        $s = join(\"\",split(\"\",ucfirst($s)));\n    }\n    return\
    \ $s;\n}\n</code>\n<|/ a tags=string,perl,sorting |>\n<| c |>\nThis is very nice\
    \ except the question doesn't say what to do when there is more than one character\
    \ in the string. For example, `abc` returns `cba`, but that doesn't seem to be\
    \ the correct answer.\n<|/ c |>\n<| c |>\nThis code doesn't handle strings containing\
    \ more than one character correctly.\n<|/ c |>\n<| a tags=string,perl,sorting\
    \ |>\nHere is a solution that uses regular expressions:\n<code>", "    my $result\
    \ = \"\";\n    my @result = ();\n    my $flag = 1;\n    my $len = length($s);\n\
    \    my $i = 0;\n    while ($i < $len) {\n        my $c = $s[$i];\n        if\
    \ ($c =~ /^[a-zA-Z]$/) {\n            $result .= ucfirst($c);\n        } elsif\
    \ ($c =~ /^[0-9]$/) {\n            $result .= $c;\n        } elsif ($c =~ /^\\\
    W+$/) {\n            $result .= ucfirst($c);\n        } else {\n            $flag\
    \ = 0;\n        }\n        $i++;\n    }", "    if($s =~ /[^a-zA-Z]/){\n      \
    \  return $s;\n    }\n    my $lower = \"abcdefghijklmnopqrstuvwxyz\";\n    my\
    \ $upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    my $ans = \"\";\n    for(my $i\
    \ = 0;$i<length($s);$i++){\n        my $c = substr($s, $i, 1);\n        $ans .=\
    \ $c eq $lower ? lc($c) eq $upper ? $c : lc($c) : lc($c);\n    }\n    return $ans;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis approach doesn't work if you have\
    \ the letter 'i' as the last letter, and you want to reverse the cases of all\
    \ the other letters.\n<|/ c |>\n<| c |>\nI posted an answer that is based on yours\
    \ that works on those cases.\n<|/ c |>\n<| c |>\nThis answer doesn't give the\
    \ result the OP asked for. `solve(\"i\")` gives `\"i\"`.\n<|/ c |>\n<| a dscore=0\
    \ |>\nIf you need to preserve the original case of the input string, you can just\
    \ do it in two passes. In case you don't, you don't have to change the case.\n\
    <code>\nmy $s = '1234';\nmy $result = \"\";\nfor my $c (split //, $s) {\n    if\
    \ ($c =~ /[a-z]/) {\n        $result .= lc ($c);\n    } else {\n        $result\
    \ .= $c;\n    }\n}\n$result = lc($result);\n</code>\nIn case you need to preserve\
    \ the original case of the input string, you can do the following (based on Mark's\
    \ answer):\n<code>\nmy $s = '1234';\nmy $result = \"\";\nfor my $c (split //,\
    \ $s) {\n    if ($c =~ /[a-z]/) {\n        $result .= lc ($c);\n    } else {\n\
    \        $result .= lc($c);\n    }\n}\n$result = lc($result);\n</code>\n<|/ a\
    \ tags=perl,case |>\n<| c |>\nYou don't need `split` here. `for my $c ( ) { if\
    \ ( /[a-z]/ ) { ... } else { ... } }` works just fine.\n<|/ c |>\n<| a |>\nHere's\
    \ a solution based on Mark's answer that works correctly even when there are special\
    \ characters in your input string.\n<code>\nuse strict;\nuse warnings;\nuse 5.010;",
  "    for(my $i=0; $i < length($s); $i++) {\n        if ($s[i] eq 'a') { $s[i] .=\
    \ 'A'; $i++; }\n        elsif ($s[i] eq 'A') { $s[i] .= 'a'; $i++; }\n       \
    \ elsif ($s[i] eq '#') { $s[i] .= 'a'; $i++; }\n        elsif ($s[i] eq '#') {\
    \ $s[i] .= '#'; $i++; }\n        elsif ($s[i] eq '0') { $s[i] .= '0'; $i++; }\n\
    \        elsif ($s[i] eq '1') { $s[i] .= '1'; $i++; }\n        elsif ($s[i] eq\
    \ '2') { $s[i] .= '2'; $i++; }\n        elsif ($s[i] eq '3') { $s[i] .= '3'; $i++;\
    \ }\n        elsif ($s[i] eq '4') { $s[i] .= '4'; $i++; }\n        elsif ($s[i]\
    \ eq '5') { $s[i] .= '5'; $i++; }\n        elsif ($s[i] eq '6') { $s[i] .= '6';\
    \ $i++; }\n        elsif ($s[i] eq '7') { $s[i] .= '7'; $i++; }\n        elsif\
    \ ($s[i] eq '8') { $s[i] .= '8'; $i++; }\n        elsif ($s[i] eq '9') { $s[i]\
    \ .= '9'; $i++; }\n        elsif ($s[i] eq '@') { $s[i] .= 'A'; $i++; }\n    \
    \    elsif ($s[i] eq 'A') { $s[i] .= '@'; $i++; }\n        elsif ($s[i] eq 'c')\
    \ { $s[i] .= 'C'; $i++; }\n        elsif ($s[i] eq 'C') { $s[i] .= 'c'; $i++;\
    \ }\n    }\n    return $s;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe OP needs\
    \ to reverse the case of the letters that are _not_ letters. E.g. `\"aB\"` ->\
    \ `\"bA\"` -> `\"bA\"`, not `\"aB\"` -> `\"bA\"` -> `\"bA\"` -> `\"Ba\"`\n<|/\
    \ c |>\n<| c |>\nYou're right, I missed that, I will update my answer to include\
    \ that.\n<|/ c |>\n<| c |>\n: I wonder how ", "    $s =~ s/\\W//g;\n    return\
    \ $s =~ s/([a-z])(?=[A-Z])|([A-Z])(?=\\1)/$1.$2/g if $s =~ /^[a-z]+$/i; \n   \
    \ return $s =~ s/([a-z])(?=[A-Z])|([A-Z])(?=\\1)/$1.$2/g if $s =~ /^[A-Z]+$/i;\n\
    \    return $s;\n}", "    my $str = \"\";\n    \n    for (my $i = 0; $i <= length($s);\
    \ $i++) {\n        if (substr($s,$i,1) =~ /[a-zA-Z]/) {\n            $str .= uc\
    \ substr($s,$i,1);\n            $str .= uc substr($s,$i,1);\n        }\n    }\n\
    \    \n    if (length($str)) {\n        $str =~ tr/A-Za-z/a-z/;\n    }\n    \n\
    \    return $str;\n}", "    $s =~ s/(.)(?=[a-z])/uc($1) eq 'A' ? 'a' : uc($1)/eg;\n\
    \    $s =~ s/(.)(?=[A-Z])/uc($1) eq 'A' ? 'A' : uc($1)/eg;\n    $s =~ s/(.)(?=[\\\
    d])/uc($1) eq '0' ? '0' : uc($1)/eg;\n    $s =~ s/(.)(?=[\\w])/uc($1) eq 'a' ?\
    \ 'A' : uc($1)/eg;\n    $s =~ s/(.)(?=[\\W])/uc($1) eq 'A' ? 'a' : uc($1)/eg;\n\
    \    return $s;\n}\n</code>\n<|/ a tags=regex,perl |>\n<| a |>\n<code>", "   \
    \ my $rev = '';\n    for(my $i = 0; $i -lt length($s); $i++) {\n        if($s[i]\
    \ eq 'l') {\n            $rev = $rev[1 .. $#rev-1];\n        }\n        elsif($s[i]\
    \ eq 'A') {\n            $rev .= $s[$i..$#s-1];\n        }\n        elsif ($s[i]\
    \ eq 'z') {\n            $rev .= $s[$i..$#s-1];\n        }\n        else {\n \
    \           $rev .= $s[i];\n        }\n    }\n    return $rev;\n}", "    return\
    \ $s unless $s;\n    $s =~ s/^ *//;\n    $s =~ s/ *$//;\n    $s =~ s/[^a-zA-Z]/_/g;\n\
    \    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/a-z/A-Z/;\n    return $s;\n}", "    if ($s\
    \ =~ /[a-zA-Z]/) {\n        $s = join \"\", map {lc($_) => uc($_)} (split //,\
    \ $s);\n    } elsif ($s =~ /^[a-zA-Z]/) {\n        $s = join \"\", map {uc($_)\
    \ => lc($_)} (split //, $s);\n    } elsif ($s =~ /^\\p{L}+$/) {\n        $s =\
    \ join \"\", map {uc} (split //, $s);\n    } else {\n        $s = join \"\", map\
    \ {lc($_)} (split //, $s);\n    }\n    return $s;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=3 |>\nA more general solution will work with any Unicode character:\n\
    <code>", "    my $rev = '';\n    my $l = length($s);\n    for(my $i = 0; $i <\
    \ $l; $i++) {\n        if($s[i] eq '#') {\n            if($s[$i-1] eq ' ') {\n\
    \                $rev.= $s[$i];\n                $i++;\n            }\n      \
    \  }\n        elsif($s[i] eq '@') {\n            if($s[$i-1] eq '.') {\n     \
    \           $rev.= $s[$i];\n                $i++;\n            }\n        }\n\
    \        elsif($s[i] eq '$') {\n            if($s[$i-1] eq '.') {\n          \
    \      $rev.= $s[$i];\n                $i++;\n            }\n        }\n     \
    \   elsif($s[i] eq '^') {\n            if($s[$i-1] eq ' ') {\n               \
    \ $rev.= $s[$i];\n                $i++;\n            }\n        }\n        elsif($s[i]\
    \ eq '&') {\n            if($s[$i-1] eq '.') {\n                $rev.= $s[$i];\n\
    \                $i++;\n            }\n        }\n        elsif($s[i] eq '-')\
    \ {\n            if($s[$i-1] eq '.') {\n                $rev.= $s[$i];\n     \
    \           $i++;\n            }\n        }\n        elsif($s[i] eq '<') {\n \
    \           if($s[$i-1] eq '.') {\n                $rev.= $s[$i];\n          \
    \      $i++;\n            }\n        }\n        elsif($s[i] eq '>') {\n      \
    \      if($s[$i-1] eq '.') {\n                $rev.= $s[$i];\n               \
    \ $i++;\n            }\n        }\n        elsif($s[i] eq '\"') {\n          \
    \  if($s[$i-1] eq '\"') {\n                $rev.= $s[$i];\n                $i++;\n\
    \            }\n        }\n        elsif($s[i] eq ' ') {\n            if($s[$i-1]\
    \ eq '.') {\n                $rev.= $s[$i];\n                $i++;\n         \
    \   }\n        }\n        elsif($s[i] eq '.') {\n            if($s[$i-1] eq '.')\
    \ {\n                $rev.= $s[$i];\n                $i++;\n            }\n  \
    \      }\n        elsif($s[i] eq '/') {\n            if($s[$i-1] eq '.') {\n \
    \               $rev.= $s[$i];\n                $i++;\n            }\n       \
    \ }\n        elsif($s[i] eq '?') {", "    my @chars = split(//,$s);\n    my $c\
    \ = 0;\n    $c += reverse $chars[0] if $chars[0];\n    $c += reverse $chars[1]\
    \ if $chars[1];\n    $c += reverse $chars[2] if $chars[2];\n    $c += reverse\
    \ $chars[3] if $chars[3];\n    return $c > 0 ? $chars[0..$c-1] : \"#a@c\";\n}",
  "    \n    my $res = '';\n    for my $char (split(//, $s)) {\n        if ($char\
    \ =~ /^[a-z]+$/i) {\n            $res .= uc($char);\n        } elsif ($char =~\
    \ /^[A-Z]+$/i) {\n            $res .= $char;\n        } else {\n            $res\
    \ .= $char;\n        }\n    }\n    $res;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=python,regex,perl,python-3.x |>\nHere's a Perl implementation:\n<code>",
  "    my $str = \"\";\n    my $count = 0;\n    foreach my $char (split(//,$s)) {\n\
    \        if (lc($char) =~ /^[a-z]/) {\n            my $case = lc($char) eq \"\
    a\" ? \"upper\" : \"lower\";\n            $char  = $case eq \"upper\" ? uc($char)\
    \ : lc($char);\n        } elsif (lc($char) =~ /^\\#/) {\n            $char = lc($char);\n\
    \        } elsif (lc($char) =~ /^\\d+$/) {\n            $char = lc($char);\n \
    \       }\n        $str .= $char;\n        $count++;\n    }\n    if ($count ==\
    \ 0) {\n        $str = lc($str);\n    }\n    return $str;\n}", "    my @chars\
    \ = split('', $s);", "    my $i = 1;\n    $s =~ s/([A-Z])/$1=!$i?'A':'a'; $i++;\n\
    \    $s =~ s/[a-z]/=$i=!$i?'a':'A'; $i++;\n    $s =~ s/[0-9]/=$i=!$i?'0':'9';\
    \ $i++;\n    return $s;\n}", "    my $result;\n    my @chars;\n    $result = $s;\n\
    \    $s =~ tr/A-Za-z/A-Za-z/;\n    if ($s =~ /[^A-Za-z]/ ) {\n        $result\
    \ = $s =~ tr/A-Za-z/A-Za-z/;\n    }\n    else { \n        $result =~ tr/a-z/A-Z/;\n\
    \    }\n    return $result;\n}", "    if ( $s =~ /^[aeiouAEIOU]+$/i ) {\n    \
    \    $s =~ tr/AEIOU/aeiou/i;\n    }\n    else {\n        $s =~ tr/aeiouAEIOU/AEIOUaeiou/i;\n\
    \    }\n    return $s;\n}\n</code>\n<|/ a dscore=0 tags=perl,regex |>\n<| c |>\n\
    This only seems to work if the string is one character long.\n<|/ c |>\n<| a tags=perl,regex\
    \ dscore=0 |>\nI wouldn't use regex. Why not?\n<code>\nuse v5.10; # or later",
  "    foreach $c (map {ord}) {\n        next if $c < 33 || $c > 126;\n        $s\
    \ = $s =~ s/$c/chr($c <= 66 ? $c + 32 : $c - 32);\n    }\n    $s unless $s =~\
    \ /^[a-zA-Z]+$/;\n    map {chop} $s;\n}\n</code>\n<|/ a tags=perl,regex |>\n<|\
    \ a tags=perl,regex |>\n<code>\nmy $s = join('', $fileContent);\n$s =~ tr/A-Za-z//cd;\n\
    $s =~ s/\\n//;\nprint $s;\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe last line\
    \ can be simplified as `$s =~ s/\\n//`\n<|/ c |>\n<| c |>\nYou shouldn't be using\
    \ regex for this. You are converting all letters to lower-case, then removing\
    \ all but letters and then removing all newlines. If you do that twice with the\
    \ same string, it will only do it twice. The regex is needlessly complicated.\n\
    <|/ c |>\n<| a tags=perl,regex dscore=0 |>\n<code>", "    $s =~ s/([^a-z]*)([a-z])/$1$2/g;\n\
    \    $s =~ s/([^A-Z]*)([A-Z])/$1$2/g;\n    $s =~ s/([^A-Z]*)([A-Z])/$1$2/g;\n\
    \    $s =~ s/([A-Z])([A-Z])/$1$2/g;\n    $s =~ s/([a-z])([A-Z])/$1$2/g;\n    $s\
    \ =~ s/([A-Z])([a-z])/$1$2/g;\n    $s =~ s/^(.*)\\z/$1/g;\n    $s =~ s/(.)\\z/$1/g;\n\
    \    return $s;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for the answer. Although\
    \ I understand your approach for reversing case using regexes, I feel like your\
    \ approach is not the most efficient way to solve this problem. Your approach\
    \ involves three substitutions, which should be avoided if possible.\n<|/ c |>\n\
    <| c |>\nI agree with you that this is probably not the most efficient solution.\
    \ But I doubt that it's more efficient than the others. And since this problem\
    \ is not so common (and not so easy to solve), I think that there is no better\
    \ solution, unless you use Perl.\n<|/ c |>\n<| c |>\nI have been thinking about\
    \ your approach for a while now. I am thinking about using 2 arrays instead of\
    \ a single array. One array stores the string and the other array stores the letters\
    \ in reverse order. Although that would involve more code, it would be more efficient.\n\
    <|/ c |>\n<| c |>\nI didn't know that Perl had `tr` operator. Learn something\
    \ new every day. Thanks.\n<|/ c |>\n<| c |>\nI forgot to mention this in the post,\
    \ but I need the code to be in Perl. That's why I only listed one language as\
    \ my target language.\n<|/ c |>\n<| a |>\nHere's a way using only base Perl.\n\
    <code>", "    \n    if(!$s) {\n        return $s;\n    }", "    my(@t);\n    my(@c);\
    \ # current charactere\n    my(@l); # low charactere\n    my(@u); # up charactere",
  "    my $rev = \"\";\n    for my $i (0 .. $#s) {\n        my $c = $s[$i];\n    \
    \    if ($c !~ /[a-z]/) {\n            $rev .= $s[$i];\n        } else {\n   \
    \         $rev .= ucfirst($c);\n        }\n    }\n    return $rev;\n}", "    return\
    \ $s unless $s;\n    my $rev = \"\";\n    for my $c (split(//,$s)) {\n       \
    \ $rev .= uc($c) if (uc($c) eq $c);\n    }\n    return $rev unless $rev;\n   \
    \ return $rev eq \"A\" ? \"a\" : $rev;\n}", "    return $s if ($s =~ /[^a-zA-Z]+/);\n\
    \    return $s if ($s =~ s/(.)/\\U$1/gi);\n    return $s if ($s =~ s/(.)/\\u$1/gi);\n\
    \    return $s if ($s =~ s/(.)/\\l$1/gi);\n    return $s if ($s =~ s/(.)/\\L$1/gi);\n\
    \    return $s if ($s =~ s/(.)/\\u$1/gi);\n    return $s if ($s =~ s/(.)/\\l$1/gi);\n\
    \    return $s if ($s =~ s/(.)/\\L$1/gi);\n    return $s if ($s =~ s/(.)/\\u$1/g);\n\
    \    return $s if ($s =~ s/(.)/\\l$1/g);\n    return $s if ($s =~ s/(.)/\\L$1/g);\n\
    \    return $s if ($s =~ s/(.)/\\u$1\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\\
    l$1\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\L$1\\E$1/gi);\n    return $s if\
    \ ($s =~ s/(.)/\\u$1\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\l$1\\E$1/gi);\n\
    \    return $s if ($s =~ s/(.)/\\L$1\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\\
    u$1\\E/g);\n    return $s if ($s =~ s/(.)/\\l$1\\E/g);\n    return $s if ($s =~\
    \ s/(.)/\\L$1\\E/g);\n    return $s if ($s =~ s/(.)/\\u$1\\E\\E$1/gi);\n    return\
    \ $s if ($s =~ s/(.)/\\l$1\\E\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\L$1\\\
    E\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\u$1\\E\\E$1/gi);\n    return $s if\
    \ ($s =~ s/(.)/\\l$1\\E\\E$1/gi);\n    return $s if ($s =~ s/(.)/\\L$1\\E\\E$1/gi);\n\
    \    return $s if ($s =~ s/(.)/\\u$1\\E\\E/g);\n    return $s if ($s =~ s/(.)/\\\
    l$1\\E\\E/g);\n    return $s ", "    $s =~ s/[^a-zA-Z]//g;\n    $s =~ s/^([a-zA-Z])/\\\
    u$1/;\n    $s =~ s/([a-zA-Z])/$\\u$1/;\n    return $s;\n}", "    my @letters =\
    \ split(//, $s);\n    my $result = $s;\n    for (@letters) {\n        my $char;\n\
    \        if ($char=~/^([A-Z])$/) {\n            $char = $1;\n        } elsif ($char=~/^[a-z]$/)\
    \ {\n            $char = lc(\"$char\");\n        } else {\n            $char =\
    \ $char;\n        }\n        $result =~ s/$char/$char/g;\n    }\n    return $result;\n\
    }", "    my $l=0;\n    for(my $i=0;$i<length($s);$i++){\n        if($s[$i]=~/[a-Z]/i){\n\
    \            $s[$l] = uc($s[$i]);\n            $l++;\n        }else{\n       \
    \     $s[$l] = $s[$i];\n        }\n    }\n    for(my $i=0;$i<$l;$i++){\n     \
    \   $s[$i] = $s[$i].$s[$i+1];\n    }\n    return $s;\n}\n</code>\nThe program\
    \ is very simple, it takes the string and just reverse the chars. It is very easy\
    \ and clear to understand.\n<|/ a tags=perl dscore=0 |>\n<| c |>\nWhy not just\
    \ `reverse $s` instead of the `for` loops?\n<|/ c |>\n<| c |>\nYeah, that would\
    \ be better since I already wrote it.\n<|/ c |>\n<| c |>\nYou have a `return $s`\
    \ at the end of your sub. Is that really necessary?\n<|/ c |>\n<| a tags=perl\
    \ |>\nThis works fine\n<code>\nperl -wnE'say reverse $_'\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nPlease explain your code. Why do you think it works? What does\
    \ it do?\n<|/ c |>\n<| c |>\nThis does not provide an answer to the question.\
    \ Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/28763498)\n<|/ c |>\n<| c |>\nThis\
    \ doesn't actually answer the question, though that is what the OP asked for.\
    \ Why do you expect this to work? What does it do? What does it not do? What does\
    \ it do differently than what the OP expected? How does it compare to the OP's\
    \ code? How does it answer the question?\n<|/ c |>\n<| c |>\nIt does answer this\
    \ question perfectly (although I don't understand why you voted it down so much).\
    \ The answer explains what the code does and shows how to do it in a shorter way\
    \ - just replace the `print ", "    my $str=\"\";\n    my @chars;\n    \n    #\
    \ Check if it's empty or null\n    \n    \n    if ($s eq \"\" || $s eq null) {\n\
    \        return $s;\n    }\n    \n    # Check if there is only 1 letter\n    \n\
    \    my $len = length($s);\n    \n    if ($len == 1) {\n        return $s;\n \
    \   }\n    \n    # Iterate through string\n    \n    my $indx = 1;\n    $len++;\n\
    \    \n    for (my $i = 0; $i<$len; $i++) {\n        my $char = substr($s, $i,\
    \ 1);\n        \n        if ($char == uc $char) {\n            $char = $char;\n\
    \        }\n        \n        push (@chars, $char);\n    }\n    \n    # Iterate\
    \ through chars to reverse the string\n    \n    for (my $i = 0; $i<$len; $i++)\
    \ {\n        $str .= substr($chars[$i], $i, 1);\n    }\n    \n    return $str;\n\
    }", "    $s =~ tr/a-zA-Z/[A-Z]/;\n    $s =~ tr/@/A-Za-z/;\n    return $s;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis does not solve the problem the OP is trying to\
    \ solve. Try your solution with \"ab\" as the argument.\n<|/ c |>\n<| c |>\n:\
    \ Ah yes, you're right, that is a slippery problem that doesn't have a solution\
    \ in the standard library.\n<|/ c |>\n<| a tags=perl,regex dscore=3 |>\nPerl regular\
    \ expressions are case sensitive by default. Thus, \"AaBbCc\" will match \"aaBbCc\"\
    . To make the match case insensitive, you need to use /i flag: \n<code>\nif (m/aaBbCc/i)\
    \ {\n</code>\n<|/ a |>\n<| a tags=perl,regex |>\nTry this:\n<code>", "    my @s\
    \ = split(//,$s);\n    my $s = \"\";\n    foreach my $c (@s) {\n        if ($c\
    \ =~ /^[a-z]/i) {\n            $c = uc($c);\n        }\n        $s .= $c;\n  \
    \  }\n    return $s;\n}", "    my @c = ();\n    my $i = 0;\n    my $last = $i;\n\
    \    my $temp;", "    return $s if $s =~ /[^a-zA-Z]/;\n    $s =~ s/([a-z])(\\\
    w)/ $2 $1 /gi;\n    $s =~ s/([a-zA-Z])(\\w)/ $2 $1 /gi;\n    $s =~ s/([a-zA-Z])([a-z])/\
    \ $2 $1 /gi;\n    return $s;\n}", "    return $s if !$s or $s =~ /^\\W*$/;\n \
    \   my $str = \"\";\n    my $flag = 0;\n    for my $char (split //, $s) {\n  \
    \      if ($char =~ /[A-Z]/) {\n            $flag = !$flag;\n        }\n     \
    \   $str .= $flag ? uc($char) : $char;\n    }\n    return $str;\n}", "    return\
    \ $s unless $s =~ m/^[a-z]+$/i;\n    return reverse $s;\n}\n</code>\nAnd now for\
    \ another solution that is more straightforward than using map:\n<code>", "  \
    \  my(@result);\n    foreach my $c (split(//, $s)) {\n        if ($c =~ m/[a-zA-Z]\\\
    Z/) {\n            my $uc = uc($c);\n            my $rev = $uc =~ tr/a-z/A-Z/;\n\
    \            if (!$rev) {\n                push (@result, $c);\n            }\n\
    \            else {\n                $rev = $uc =~ tr/A-Z/a-z/;\n            \
    \    push (@result, $rev);\n            }\n        }\n        else {\n       \
    \     push (@result, $c);\n        }\n    }\n    return join('',@result);\n}\n\
    </code>\n<|/ a tags=python,algorithm dscore=3 |>\n<| a |>\nA pure Python, O(n),\
    \ answer which does not use any regex and still handles all the edge cases:\n\
    <code>\ndef solve(s):\n    chars = list(s)\n    for i in range(0, len(s), 2):\n\
    \        chars[i], chars[(i+1)%len(chars)] = chars[(i+1)%len(chars)], chars[i]\n\
    \    return ''.join(chars)\n</code>\n<|/ a tags=python,algorithm dscore=2 |>\n\
    <| c |>\nNice solution but you forgot handling of case `\"\"`.\n<|/ c |>\n<| c\
    \ |>\n`''` does not seem to need special handling.\n<|/ c |>\n<| c |>\n, no. Consider\
    \ `\"1234\"` input. For empty string it will return `\"4321\"` not `\"1234\"`.\n\
    <|/ c |>\n<| c |>\nYeah. That's what I've missed and why I wanted to remove this\
    \ question from the first place :)\n<|/ c |>\n<| c |>\nThe OP specifically mentions\
    \ no regex, and I thought that the OP was okay with a simple solution.\n<|/ c\
    \ |>\n<| a tags=python,algorithm dscore=1 |>\nAs the question says, you need to\
    \ reverse the case of the letters within a string. So this can be done in two\
    \ steps:", "    $s =~ s/^([a-z]+)$/$1 =~ /a-z/ ? \n\tuc($1) : \n\t$1/ge \n\t?\
    \ \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\
    \tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge\
    \ \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1)\
    \ :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\
    \t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1)\
    \ :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 )\
    \ /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\t\
    uc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge\
    \ \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1)\
    \ :\n\tuc( $1 ) /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 )\
    \ /ge \n\t? \n\tuc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? \n\t\
    uc($1) :\n\t$1/ge \n\t? \n\tuc($1) :\n\tuc( $1 ) /ge \n\t? ", '    my(@letters);',
  "    my $answer = $s;\n    $answer =~ s/([a-z])/uc($1)/g;\n    $answer =~ s/([^a-z])/uc($1)/ge;\n\
    \    $answer;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nI like this one\
    \ because you can do it all in one regex.\n<|/ c |>\n<| c |>\n`perl -E 'say \"\
    1234\"=~s/[a-z]/uc($&)/g;'`\n<|/ c |>\n<| c |>\n: That will fail on \"12345\"\n\
    <|/ c |>\n<| c |>\nTrue. But I interpreted that to be the intent of the OP.\n\
    <|/ c |>\n<| a |>\n<code>\n sub reverse{\n  my($str) = shift;\n  $str =~ s/^(.)/uc($1)/ge;\n\
    \  $str =~ s/(.)$/uc($1)/ge;\n  return $str;\n }\n reverse(\"abCD\");\n =>\n \"\
    cDaB\"\n</code>\n<|/ a tags=perl,regex dscore=1 |>\n<| c |>\n`s/^(.)/uc($1)/ge`\
    \ can just be `s/^(.)/uc($1)/`.\n<|/ c |>\n<| c |>\nThis fails on \"aBcD\"\n<|/\
    \ c |>\n<| c |>\nNope. I just fixed it. It was failing because I was using `$&`\
    \ instead of `$1`.\n<|/ c |>\n<| c |>\n`s/^(.)/uc($1)/ge` can be `s/^(.)/uc($1)/`,\
    \ which has no effect.\n<|/ c |>\n<| a |>\nHere's another solution:\n<code>",
  "    my @res = split(/@/, uc($s));\n    \n    foreach (@res) {\n        $_ = $1\
    \ if /^[a-z]/i;\n    }\n    \n    return @res ? join(\"\", (map {uc($_)}@res))\
    \ : uc($s);\n}", "    my $result = '';\n    my $i = 0;", "    \n    my $chars\
    \ = '';\n    \n    foreach my $i (split(//, $s)) {\n        if($i =~ /^[a-z]+$/i)\
    \ {\n            $chars .= uc($i);\n        }\n        else {\n            $chars\
    \ .= $i;\n        }\n    }\n    \n    return $chars;\n}", "    return undef unless\
    \ $s;\n    my($result) = '';\n    \n    # Special case when string is empty\n\
    \    my $has_letters = @{ $s =~ /[a-z]/ };\n    $s =~ tr/a-z/A-Z/;\n    \n   \
    \ # Special case when string contains only letters\n    if ($has_letters) {\n\
    \        $result .= $s;\n    }\n    \n    # Special case when string only contains\
    \ digit\n    elsif (@{ $s =~ /[0-9]/ }) {\n        $result .= $s =~ tr/0-9/A-Z/;\n\
    \    }\n    \n    # Else normal case\n    else {\n        $result .= $s =~ tr/A-Z/a-z/;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=regex,perl |>\n<| c |>\n\"\
    The function should return the resulted string\"\n<|/ c |>\n<| c |>\nThank you\
    \ for fixing my code. I've been staring at it for hours and didn't notice that.\
    \ Fixed now.\n<|/ c |>\n<| c |>\nThe OP did not specifically ask for a regex solution\
    \ - but it's worth mentioning that this solution is better than any regex solution\
    \ (not just for performance, but also for clarity, maintainability and readability).\n\
    <|/ c |>\n<| c |>\nActually my question was about a regex solution, and this code\
    \ works perfectly for this question so I will accept it as the solution\n<|/ c\
    \ |>\n<| c |>\nThank you for making it clear you wanted a regex solution (I'm\
    \ glad my answer was helpful). I didn't realize your question was about a regex\
    \ solution.\n<|/ c |>\n<| a tags=regex,perl |>\n<code>\nmy $str = 'asdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdas",
  "    $s =~ s/^#//;\n    $s =~ s/@/a/g;\n    return $s;\n}\n</code>\n<|/ a tags=string,perl,reverse\
    \ dscore=0 |>\n<| c |>\nI assume `perl` since there is `sub solve` but there is\
    \ `sub reverse`\n<|/ c |>\n<| a tags=string,perl,reverse |>\nThe solution with\
    \ the grep is probably a little bit simpler (but maybe a bit less readable). Here\
    \ are two ways you can solve this with grep.\n<code>", "    my @l = ();\n    $s\
    \ =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n    push @l, $s[0];\n    $s =~ s/^[a-z]/ig;\n\
    \    push @l, $1;\n    $s =~ s/^[A-Z]/ig;\n    push @l, $1;\n    $s =~ s/^#/ig;\n\
    \    push @l, $1;\n    $s =~ s/^@/ig;\n    push @l, $1;\n    $s =~ s/^$/ig;\n\
    \    push @l, $1;\n    $s =~ s/$/$/ig;\n    my $i;\n    for ($i = 1; $i < @l;\
    \ $i++) {\n        if ($l[$i] =~ m/^\\./) {\n            $l[$i] = $l[$i] =~ tr/a-zA-Z/A-Z/;\n\
    \        } elsif ($l[$i] =~ m/^\\d/) {\n            $l[$i] = $l[$i] =~ tr/a-zA-Z0-9/A-Z0-9/;\n\
    \        } else {\n            $l[$i] = $l[$i];\n        }\n    }\n    return\
    \ join '', @l;\n}\n</code>\n<|/ a |>\n<| a tags=string,perl,substr,reverse dscore=2\
    \ |>\n<code>", "    my $res = \"\";\n    $s =~ s/\\B([a-zA-Z])/\\U$1/g;\n    if\
    \ ($s =~ /\\A[a-z]*/i) {\n        $s =~ s/^[a-z]*//;\n        $s =~ s/([a-z])\\\
    z/\\U$1/g;\n        $res = $s;\n    } else {\n        $res = $s;\n    }\n    return\
    \ $res;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\nuse strict;\n\
    use warnings;\nuse 5.010;", "    my($out);\n    \n    for(my $i = 0; $i < length($s);\
    \ $i++) {\n        if($s[i] eq '@') {\n            $out = $s[$i];\n          \
    \  $s[$i] = '';\n        } elsif ($s[i] eq '@') {\n            $s[$i] = $out;\n\
    \        } elsif ($s[i] =~ /[A-Z]/) {\n            $s[$i] = ucfirst($s[$i]);\n\
    \        } elsif ($s[i] =~ /[0-9]/) {\n            $s[$i] = pack('C', unpack('n',\
    \ $s[$i])[0]);\n        } else {\n            $s[$i] = $s[$i];\n        }\n  \
    \  }\n    return $s;\n}", "    my $len = length($s);\n    if ($len == 0) {\n\t\
    return $s;\n    }\n    elsif ($s[0] =~ /[a-z]/) {\n\treturn join(\"\", map { uc($_)\
    \ } split //, $s);\n    }\n    else {\n\treturn join(\"\", map { lc($_) } split\
    \ //, $s);\n    }\n}", "    if ($s =~ /^[A-Za-z]+$/){\n        $s =~ tr/A-Z/a-z/;\n\
    \    }\n    elsif ($s =~ /^[a-z]+$/){\n        $s =~ tr/a-z/A-Z/;\n    }\n   \
    \ return $s;\n}", "    my(@r) = ();\n    \n    for ($s) {\n        if (/[a-z]/)\
    \ {\n            push (@r, uc $1);\n        }\n        else {\n            push\
    \ (@r, $s);\n        }\n    }\n    \n    unshift (@r, '');\n    $s = join \"\"\
    , @r;\n    $s =~ s/^([a-z])/uc $1/g;\n    $s =~ s/([A-Z])/uc $1/g;\n    $s =~\
    \ s/^/uc /g;\n    $s =~ s/$/uc /g;\n    return $s;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a |>\n<code>", "    $s =~ s/(^|\\s)([a-z])/${lc($1)} . $2/g;\n    $s\
    \ =~ s/(^|\\s)([A-Z])/${uc($1)} . $2/g;\n    $s =~ s/(^|\\s)([0-9])/${lc($1)}\
    \ . $2/g;\n    $s =~ s/(^|\\s)([0-5])/${uc($1)} . $2/g;\n    $s =~ s/^/${lc($1)}/g;\n\
    \    $s =~ s/$/${uc($1)}/g;\n    return $s;\n}", "    my $i;\n    my $result =\
    \ \"\";\n    for ($i = 0; $i < $#s; $i++) {\n        if ($s[$i] eq 'a') { $result\
    \ .= lc($s[$i]); }\n        elsif ($s[$i] eq 'A') { $result .= uc($s[$i]); }\n\
    \        elsif ($s[$i] eq '#') { $result .= $s[$i]; }\n        elsif ($s[$i] eq\
    \ '@') { $result .= $s[$i]; }\n        else { $result .= $s[$i]; }\n    }\n  \
    \  return $result;\n}\n</code>\n<|/ a tags=string,perl |>\n<| c |>\nThank you\
    \ for sharing your solution! I just have one question, why do you use `substr`\
    \ instead of `substr`?\n<|/ c |>\n<| c |>\n`substr` is like `$s[$i]`, just easier\
    \ to use and shorter. And `substr` without length parameter means \"until end\
    \ of string\", same as `substr($s, $i, -1)`.\n<|/ c |>\n<| a tags=string,perl\
    \ dscore=1 |>\nHere is a simple solution which uses map function.\n<code>", " \
    \   \n    my $new_str = '';\n    \n    foreach my $char (split //, $s) {\n   \
    \     my $temp_char = $char;\n        $temp_char =~ tr/a-z/A-Z/;\n        $temp_char\
    \ =~ tr/A-Z/a-z/;\n        \n        if ($temp_char eq ''){\n            $new_str\
    \ .= $char;\n        } else {\n            $new_str .= $temp_char;\n        }\n\
    \    }", "    $s =~ tr/a-z/A-Z/;\n    if ($s =~ /^[a-zA-Z]+$/) {\n        $s =~\
    \ tr/A-Z/a-z/;\n    }\n    elsif ($s =~ /^[a-zA-Z]+/) {\n        $s =~ tr/a-z/A-Z/;\n\
    \    }\n    $s;\n}", "    if (length($s) == 0) {\n        $s;\n    }\n    if ($s\
    \ =~ /[a-zA-Z]/) {\n        my $result = ucfirst $s;\n        $result = lc $result;\n\
    \        $result = uc $result;\n        $result;\n    } else {\n        $s;\n\
    \    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nPerl solution:\n<code>",
  "    $s =~ tr/a-z/A-Z/;\n    return $s;\n}\n</code>\n<|/ a tags=regex,perl dscore=0\
    \ |>\n<| c |>\nThanks a lot for your answer and your detailed explanation. Your\
    \ solution works and looks nice, but I've just realized that my function was written\
    \ incorrectly. I should have called it `make_lower_case`. I've updated my question.\n\
    <|/ c |>\n<| c |>\nI see no reason in `make_lower_case` not to use `tr/a-z/A-Z/`.\
    \  And `tr/A-Z/a-z/;` does not make sense, because `tr` makes it reverse.\n<|/\
    \ c |>\n<| c |>\n`tr/A-Z/a-z/` reverses case of a-z character only, but does not\
    \ make sense to use it here.\n<|/ c |>\n<| c |>\n`tr/a-z/A-Z/;` makes sense, because\
    \ `tr` makes it reverse and changes case from a-z to A-Z. Your solution works\
    \ because you call it `make_lower_case` and not `reverse_case`. I've updated my\
    \ question to make it more clear.\n<|/ c |>\n<| a dscore=0 |>\nI think this should\
    \ work:\n<code>", "    my $length = length $s;\n    for (my $i=0; $i<$length;\
    \ $i++) {\n\tif ( $s[i] =~ /^[a-z]/i) {\n\t    return lc($s) =~ tr/A-Za-z//d;\n\
    \t} else {\n\t    return lc($s);\n\t}\n    }\n}\n</code>\n<|/ a tags=reverse,perl\
    \ dscore=1 |>\n<| a tags=reverse,perl dscore=1 |>\nThis is an alternative solution\
    \ that is more flexible with regards to what constitutes a letter or digit.  The\
    \ idea is to break the string into an array of characters and then reverse the\
    \ array.  \n<code>\nmy $x = \"ab123#@^%\";\nmy = split //, $x;", "    $s =~ s/\\\
    cL/uc($&)/g;\n    return $s if length($s) > 0;\n    my(@c) = split(//,$s);\n \
    \   my $l = @c;\n    for(my $i = 0 ; $i < $l ; $i++) {\n        $c[$i] = uc($c[$i])\
    \ if ($c[$i] =~ /[a-z]/i);\n    }\n    return join \"\", @c;\n}\n</code>\n<|/\
    \ a tags=algorithm,perl dscore=2 |>\n<| c |>\nI don't think this is correct. This\
    \ will fail on \"abcd\" but will return \"dabc\" instead.\n<|/ c |>\n<| c |>\n\
    It doesn't fail on \"abcd\". `uc()` works on the first character (`a`) and `a`\
    \ gets converted to upper case (`A`). As soon as the first character is a number,\
    \ it just doesn't change anything.\n<|/ c |>\n<| a dscore=2 |>\nI know you've\
    \ already selected an answer, but it's worth noting that, while the accepted answer\
    \ is good enough for this problem, there is a faster solution available, for when\
    \ you need to iterate more than once through your string.\n<code>\nmy $str = 'The\
    \ quick brown fox jumped over the lazy dog.';\n$str =~ tr/a-zA-Z/A-Z/;", "   \
    \ $s =~ tr/a-zA-Z//;\n    $s =~ s/^(.)/\\U$1/g;\n    return $s;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work for the OP's example: `solve(\"12ABC\")`\
    \ gives `\"1BC2\"`, not `\"1BCa\"`.\n<|/ c |>\n<| c |>\nI guess he missed the\
    \ part that it should be reversed only when necessary. I'll add it then.\n<|/\
    \ c |>\n<| c |>\nActually, it works now :-) The OP's example gives \"1BC2\" in\
    \ your solution.\n<|/ c |>\n<| c |>\nNo, OP's example gives \"1BCa\" when run.\
    \ The problem is that your `reverse` function doesn't handle uppercase letters\
    \ correctly (it doesn't handle them correctly).\n<|/ c |>\n<| c |>\n: It doesn't\
    \ matter how you define \"correct\" as long as it actually works.\n<|/ c |>\n\
    <| a dscore=4 tags=algorithm,perl,string |>\nAnother perl solution:\n<code>",
  "    \n    if($s =~ /^.*[^a-zA-Z]+$/) {\n        $s =~ tr/a-zA-Z/A-Z/;\n    } else\
    \ {\n        $s =~ tr/a-z/A-Z/;\n    }\n    return $s;\n}", "    \n    $s =~ s/(.)/\\\
    L$1/g;\n    \n    if ($s =~ /^.?$/) {\n        $s =~ tr/a-z/A-Z/;\n    }\n   \
    \ \n    return $s;\n}", "    $s =~ s/^\\s+//;\n    $s =~ s/\\s+$//;\n    $s =~\
    \ s/^[^A-Za-z]*//;\n    $s =~ s/([^A-Za-z])\\l$/\\L$1/;\n    $s =~ s/\\l([^A-Za-z])/$U\\\
    $1/g;\n    $s =~ s/^[A-Za-z]*\\z//;\n    return $s;\n}", "    $s =~ s/\\Q$ENV{LC_ALL}//gr\
    \ if $ENV{LC_ALL};\n    my $s = ucfirst($s);\n    $s =~ tr/a-z/A-Z/;\n    return\
    \ $s;\n}", "    my $result = '';\n    my $len = length($s);\n    foreach my $char\
    \ (split(//, $s)) {\n        my $upper = ($char =~ /[A-Z]/);\n        my $lower\
    \ = ($char =~ /[a-z]/);\n        $char = ($upper) ? $char =~ tr/A-Z/a-z/i : $char;\n\
    \        $char = ($lower) ? $char =~ tr/a-z/A-Z/i : $char;\n        $char = $char;\n\
    \        $result .= $char;\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI'm sorry to tell you, but this was also my solution in Hackerrank and\
    \ I got \"Wrong answer\" as a result.\n<|/ c |>\n<| c |>\nI fixed the code a bit,\
    \ please try again. Let me know if you face any issues.\n<|/ c |>\n<| a dscore=3\
    \ tags=string,ruby |>\nThe solution by is correct, but if you're looking for a\
    \ more concise solution, then you can try this:\n<code>\ns.chars.map{ |i| i.upcase\
    \ + i.downcase }.join\n</code>\n<|/ a |>\n<| c |>\nI got \"Wrong Answer\" as a\
    \ result. Can you please have a look at it?\n<|/ c |>\n<| c |>\nThis has nothing\
    \ to do with the number of characters in the string.\n<|/ c |>\n<| a |>\n<code>\n\
    def solve str\n  str.chars.map { |c| c.upcase + c.downcase }.join\nend\n</code>\n\
    <|/ a dscore=3 tags=string,ruby |>\n<| a dscore=2 tags=string,ruby |>\nA variant\
    \ that does not require the use of a temporary variable (thanks to Thomas):\n\
    <code>\ndef solve str\n  str.split('').map { |s| s.upcase + s.downcase }.join\n\
    end\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef solve(str)\n  str.scan(/./).map {\
    \ |s| s.upcase + s.downcase }.join\nend\n</code>\n<|/ a dscore=2 tags=string,ruby\
    \ |>\n<| a |>\n<code>\ndef solve(s)\n  s.tr!(/[A-Z]/, 'a'.ord.to_s).tr!(/[a-z]/,\
    \ 'A'.ord.to_s)\nend\n</code>\n<|/ a dscore=2 tags=string,ruby |>\n<| c |>\nI\
    \ got \"Wrong ", "    for(my $i = 0; $i < length($s); $i++){\n        if($s[i]\
    \ =~ m/[A-Za-z]/){\n            if($i < length($s) -1){\n                my $t\
    \ = substr($s, $i, 1);\n                substr($s, $i, 1) = substr($s, $i+1, 1);\n\
    \                substr($s, $i+1, 1) = $t;\n            }\n        }\n       \
    \ else{\n            my $t = substr($s, $i, 1);\n            substr($s, $i, 1)\
    \ = substr($s, $i, 1);\n            substr($s, $i, 1) = $t;\n        }\n    }\n\
    \    return $s;\n}\n</code>\n<|/ a tags=perl,string,reverse |>\n<| c |>\nWhat\
    \ about this: `\"A$%*&^*()#*()$#\"`\n<|/ c |>\n<| c |>\nHi Thanks for your quick\
    \ response,\nIt doesn't work for these characters too.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "    my $str = $s;\n    if ( $str =~ /[a-z]/i ) {\n        $str\
    \ =~ tr/a-z/A-Z/i;\n    }\n    else {\n        $str =~ tr/A-Z/a-z/i;\n    }\n\
    \    return $str;\n}", "    \n    if($s =~ /^\\p{L}$/) {\n        return $s =~\
    \ tr/[AEIOU]/[IAOU]/;\n    } else {\n        return $s;\n    }\n}", "    if($s\
    \ =~ /[a-z]/i) {\n        $s =~ tr/a-z/A-Z/;\n    } elsif($s =~ /[0-9]/i) {\n\
    \        $s =~ tr/0-9A-Z//;\n    } elsif($s =~ /[A-Z]/) {\n        $s =~ tr/A-Z/a-z/;\n\
    \    }\n    $s;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't address the OP's\
    \ requirement that the strings be reversed as they are inputted.\n<|/ c |>\n<|\
    \ c |>\nThe question is \"How to make the program to work with the new case? Now\
    \ it only can convert the lowercase to uppercase.\" The way I interpreted it was\
    \ that it needs to process each character as it comes in. Not once it's all done\
    \ reading and before it's ready.\n<|/ c |>\n<| c |>\nYou're right, that's what\
    \ I missed. Now your answer makes sense. Thanks.\n<|/ c |>\n<| a tags=perl,string,lowercase\
    \ |>\nUsing tr/// is much faster than gsub.\n<code>\nuse Benchmark qw(cmpthese);",
  "    return unless $s;\n    return $s unless length($s);\n    return $s unless length($s)\
    \ =~ /^[A-Za-z0-9]+$/;\n    my $ret = $s;\n    $ret =~ tr/a-z/A-Z/;\n    $ret\
    \ =~ tr/A-Z/a-z/;\n    return $ret;\n}\n</code>\n<|/ a |>\n<| a tags=string,perl\
    \ |>\nFor those who still don't know how to do it:\n<code>", "    my @letters\
    \ = ();\n    my $len = length($s);\n    my $i = 0;", "    my($i);\n    my(@result);\n\
    \    \n    if (length($s) <= 0) {\n        return $s;\n    }\n    if ($s =~ /^#/)\
    \ {\n        return $s;\n    }\n    \n    for ($i=0; $i < length($s); $i++) {\n\
    \        push(@result, $s[$i]);\n    }\n    \n    for ($i = 0; $i < length($s);\
    \ $i++) {\n        if ($s[$i] =~ /^[a-z]+$/i) {\n            $s[$i] = $s[$i] =~\
    \ tr/a-z/A-Z/i;\n        }\n    }\n    \n    for ($i = 0; $i < length($s); $i++)\
    \ {\n        if ($s[$i] !~ /^[a-z]+$/i) {\n            $s[$i] = $s[$i] =~ tr/A-Z/a-z/i;\n\
    \        }\n    }\n    \n    for ($i = 0; $i < length($s); $i++) {\n        $s[$i]\
    \ = $s[$i] =~ tr/A-Z/a-z/i;\n    }\n    \n    for ($i = 0; $i < length($s); $i++)\
    \ {\n        $s[$i] = $s[$i] =~ tr/A-Z/a-z/i;\n    }\n    \n    return @result;\n\
    }", "    if($s =~ /[^a-z]/i) {\n        $s =~ tr/a-z/A-Z/i;\n    }\n    $s;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=regex,perl,string,python |>\nIf you use\
    \ regular expressions and string methods,\nthis one is even simpler:\n<code>\n\
    \"abBcDcC\".gsub(/./, \"\") .\n</code>\nThe regexp /./ (or .) will match any character\
    \ and since gsub uses the g modifier, it will replace each match with the empty\
    \ string.\n<|/ a |>\n<| c |>\nDoesn't work if the input string has digits in it.\n\
    <|/ c |>\n<| c |>\nIt doesn't work because this doesn't answer the question. It\
    \ just removes all non-letters, not just the letters within the string.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nIn perl :\n<code>", "    if($s =~ /^([a-zA-Z]+)(\\1$)/){\n\
    \        $s =~ s/\\L\\l+/\\L/gi;\n        $s =~ s/\\L\\+\\l+/\\L/gi;\n       \
    \ $s =~ s/\\L\\l+/\\L/gi;\n    }elsif($s =~ /^([a-zA-Z])(\\1$)/){\n        $s\
    \ =~ s/\\L\\l+/\\L/gi;\n    }else{\n        $s =~ s/\\L\\+\\l+/\\L/gi;\n    }\n\
    \    $s;\n}\n</code>>\nThe last line is the most interesting.  In this case, we\
    \ know that all the letters come after the first one in alphabetic order.  That\
    \ means that our \\1 group will always have the same letter in it, so the \\L\\\
    l+ will do the same thing as our \\L\\l+.  However, we don't want to match letters\
    \ that come before the first one in alphabetic order.  To do this, we need to\
    \ use the \\L\\+\\l+ instead.  This basically means match all letters that come\
    \ after \\L\\l+.\nThat should be enough for you.  But if you have any questions,\
    \ please ask.  Don't just copy and paste.", "    \n    my $rev = \"\";\n    $rev\
    \ .= $s[0];\n    $rev =~ s/[a-z]/[A-Z]/g;\n    if ($rev !~ /[A-Z]/) {\n      \
    \  $rev =~ s/[A-Z]/[a-z]/g;\n    }\n    $rev =~ s/^[a-z]/[A-Z]/;\n    $rev =~\
    \ s/$/[a-z]/ if ($rev !~ /[a-z]/);\n    $rev;\n}", "    $s =~ tr/a-zA-Z//cd;\n\
    \    return $s unless $s =~ /^[a-z]+$/;\n    return $s =~ /^[a-z]+$/i ? $s =~\
    \ tr/A-Za-z//cd : $s =~ tr/a-zA-Z//cd;\n}\n</code>\n<|/ a dscore=0 tags=perl,case,string\
    \ |>\n<| c |>\nThe OP didn't ask for a solution in perl, but a solution in *any*\
    \ language, i.e. not just perl.\n<|/ c |>\n<| c |>\nI posted a perl solution in\
    \ the question body :)\n<|/ c |>\n<| c |>\nI rephrased the question so that I\
    \ hope it's clear now. Thanks for the answer anyway :)\n<|/ c |>\n<| c |>\n- You\
    \ already have a solution in Perl... `sub solve {` `my($s) = @_;` `$s =~ tr/a-zA-Z//cd;`\
    \ `return $s unless $s =~ /^[a-z]+$/;` `return $s =~ /^[a-z]+$/i ? $s =~ tr/A-Za-z//cd\
    \ : $s =~ tr/a-zA-Z//cd;` }\n<|/ c |>\n<| c |>\n: Sorry my bad. I didn't see it.\
    \ Your solution is indeed a lot better and much more elegant than the one I posted.\
    \ I didn't realise it was even possible to make perl do this!\n<|/ c |>\n<| a\
    \ tags=perl,case,string |>\nAs a quick hack:\n<code>", "    if ($s =~ /^[A-z]+$/)\
    \ {\n        $s =~ tr/[A-Z]/[a-z]/;\n    } else {\n        $s =~ tr/[a-z]/[A-Z]/;\n\
    \    }\n    return $s;\n}", "    \n    foreach my $char (split //, $s) {\n   \
    \     my $c = $char;\n        if( $char eq $char ) {\n            $c =~ tr/a-zA-Z/n-zA-Z/;\n\
    \        }\n        elsif ( $char eq $char ) {\n            $c =~ tr/n-zA-Z/a-zA-Z/;\n\
    \        }\n        else {\n            $c =~ tr/a-zA-z/A-Za-z/;\n        }\n\
    \    }\n    return $s;\n}", "    return ($s =~ tr/a-zA-Z/A-Za-z/) if $s =~ /[^a-zA-Z]/;\n\
    \    $s =~ tr/a-zA-Z//d;\n    return $s;\n}", "    $s =~ s/([0-9]+)/$1^0/eg;\n\
    \    $s =~ s/([a-z])/lc($1)/eg;\n    $s =~ s/\\@/@/ig;\n    $s =~ s/\\#/#/ig;\n\
    \    $s =~ s/\\&/\\&/ig;\n    $s =~ s/\\*/\\*/ig;\n    $s =~ s/\\?/\\?/ig;\n \
    \   $s =~ s/\\!/\\!/ig;\n    $s =~ s/\\^/\\^/ig;\n    $s =~ s/\\$/$/ig;\n    $s\
    \ =~ s/\\+/\\+/ig;\n    $s =~ s/\\-/-/ig;\n    $s =~ s/\\*/\\*/ig;\n    $s =~\
    \ s/\\?/\\?/ig;\n    $s =~ s/\\!/\\!/ig;\n    $s =~ s/\\^/\\^/ig;\n    $s =~ s/\\\
    $/$/ig;\n    $s =~ s/\\-/-/ig;\n    $s =~ s/\\+/\\+/ig;\n    $s =~ s/\\~/\\~/ig;\n\
    \    $s =~ s/\\^/\\^/ig;\n    $s =~ s/\\$/$/ig;\n    $s =~ s/\\-/-/ig;\n    $s\
    \ =~ s/\\+/\\+/ig;\n    $s =~ s/\\~/\\~/ig;\n    $s =~ s/\\^/\\^/ig;\n    $s =~\
    \ s/\\$/$/ig;\n    $s =~ s/\\-/-/ig;\n    $s =~ s/\\+/\\+/ig;\n    $s =~ s/\\\
    ~/\\~/ig;\n    $s =~ s/\\^/\\^/ig;\n    $s =~ s/\\$/$/ig;\n    $s =~ s/\\-/-/ig;\n\
    \    $s =~ s/\\+/\\+/ig;\n    $s =~ s/\\~/\\~/ig;\n    $s =~ s/\\^/\\^/ig;\n \
    \   $s =~ s/\\$/$/ig;\n    $s =~ s/\\-/-/ig;\n    $s =~ s/\\+/\\+/ig;\n    $s\
    \ =~ s/\\~/\\~/ig;\n    $s =~ s/\\^/\\^/ig;\n    $s =~ s/\\$/$/ig;\n    $s =~\
    \ s/\\-/-/ig;\n    $s =~ s/\\+/\\+/ig;\n    $s =~ s/\\~/\\~/ig;\n    $s =~ s/",
  "    $s =~ tr/A-Z/a-z/;\n    my $ret = $s;\n    if ($s =~ /^\\W/) {\n        $ret\
    \ =~ tr/a-z/A-Z/;\n    }\n    return $ret;\n}", "    my(@a);\n    my $c;\n   \
    \ my $temp;\n    my $i;\n    $c = 0;\n    my @tmp;\n    foreach $i (@s) {\n  \
    \      if ($i =~ /[a-z]/) {\n            $tmp[$c++] = $i;\n        }\n       \
    \ else {\n            $c++;\n            $tmp[$c-1] = $i;\n        }\n    }\n\
    \    for ($i = $#tmp; $i >= 0; $i--) {\n        $a = $s[$i..$#s];\n        $a\
    \ = $a =~ tr/a-z/A-Z/;\n        $tmp[$i] = $tmp[$i] . $a;\n    }\n    my $n =\
    \ @tmp;\n    my $res = \"\";\n    for ($i = 0; $i < $n; $i++) {\n        $res\
    \ = $tmp[$i] . $res;\n    }\n    return $res;\n}", "    my (@result) = ();\n \
    \   my($i, $j, $char);\n    my $length = length($s);\n    foreach $char (split\
    \ //, $s) {\n        if ($char =~ /^[a-zA-Z]/) {\n            my $rs = $char =~\
    \ tr/a-z/A-Z/;\n            $result[$char] = $rs;\n        }\n    }\n    foreach\
    \ $char (split //, $s) {\n        if ($char !~ /^[a-zA-Z]/) {\n            my\
    \ $rs = $char =~ tr/A-Z/a-z/;\n            $result[$char] = $rs;\n        }\n\
    \    }\n    $s = join(\"\", @result);\n    return $s;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=perl,string,algorithm |>\nI think this is more perl-like:\n<code>",
  "    return '' unless $s;\n    my @l = ();\n    my %t = ();\n    for (split //,\
    \ $s) {\n\t$l[$_] //= 1;\n\t$t{$l[$_]} //= $_;\n    }\n    $s = join \"\", sort\
    \ { length($t{$a}) <=> length($t{$b}) } keys %t;\n    return $s if length($s);\n\
    \    return reverse $s;\n}\n</code>\n<|/ a tags=perl,string |>\n<| c |>\n`sub\
    \ solve { my($s) = @_; return '' unless $s; ... } solve(\"!@#$%^&*()\"); #=> \"\
    !@#$%^&*()\"`\n<|/ c |>\n<| c |>\n: Oops, I meant to write `sub` instead of `function`.\
    \ I fixed it now.\n<|/ c |>\n<| c |>\nNo worries. `sub solve {...}; solve(\"!@#$%^&*()\"\
    ); #=> \"!@#$%^&*()\"` :)\n<|/ c |>\n<| c |>\n`sub solve { my $s = shift; return\
    \ $s ? reverse $s : ''; }` works just fine.\n<|/ c |>\n<| a tags=perl,string dscore=3\
    \ |>\nI got very sick of all these answers being given to me that involve splitting\
    \ the string into words and sorting the words by length in descending order. What\
    \ if i only needed to reverse the string?\nWell i can just use reverse() and the\
    \ string will be reversed without me having to use any complex sorting algorithms.\
    \ The reverse function reverses the characters in the string in place.\n<|/ a\
    \ |>\n<| c |>\nThis answer was the simplest for me to implement. Thanks.\n<|/\
    \ c |>\n<| c |>\nAgreed, this is the simplest to implement.\n<|/ c |>\n<| c |>\n\
    The other answers do require splitting the string into words. The simple answer\
    \ doesn't require splitting at all. Just use `$str=reverse($str)`\n<|/ c |>\n\
    <| a |>\n<code>", "    my $i = $#s ;\n    my $res = $s[0];", "    $s =~ s/^(.)/ucfirst($1)\
    \ =~ tr/a-z/A-Z/;\n    return $s;\n}", "    $s =~ tr/[a-z]/[A-Z]/;\n    return\
    \ $s =~ tr/[A-Z]/[a-z]/;\n}", "    $s = lcp($s) unless $s =~ /\\A[a-zA-Z]+\\z/;\n\
    \    $s =~ tr/a-z/A-Z/;\n    return $s;\n}", "    $s =~ tr/a-z/A-Z/;\n    return\
    \ $s;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,python |>\n<code>\ndef\
    \ solve(s):\n    newString = ''\n    for i in s:\n        if i.isalpha():\n  \
    \          newString += i.upper()\n        else:\n            newString += i\n\
    \    return newString\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,python |>\n\
    <code>\ndef solve(s):\n    \n    newString = ''\n    \n    for i in s:\n     \
    \   if i.isalpha():\n            newString += i.upper()\n        else:\n     \
    \       newString += i\n    \n    return newString\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nPlease explain how your code solves the problem. This answer was flagged\
    \ as low quality because of its length and content. Furthermore, it does not provide\
    \ any explanation why the code solves the problem, so how do you know what is\
    \ the problem that the code solves?\n<|/ c |>\n<| c |>\nThis answer has been flagged\
    \ for review because of its length and content. Furthermore, it does not provide\
    \ any explanation why the code solves the problem, so how do you know what is\
    \ the problem that the code solves?\n<|/ c |>\n<| a tags=string,python dscore=0\
    \ |>\nThis should work for you\n<code>\ndef solve(s):\n    s=s.lower()\n    s=s.replace('.','')\n\
    \    s=s.replace(',','')\n    s=s.replace('!','')\n    s=s.replace('?','')\n \
    \   s=s.replace(':','')\n    s=s.replace(',','')\n    s=s.replace('!','')\n  \
    \  s=s.replace('?','')\n    s=s.replace(':','')\n    s=s.replace('(','')\n   \
    \ s=s.replace(')','')\n    s=s.replace('\"','')\n    s=s.replace('[','')\n   \
    \ s=s.replace(']','')\n    s=s.replace('{','')\n    s=s.replace('}','')\n    s=s.replace('#','')\n\
    \    s=s.replace('$','')\n    s=s.replace('\xA3','')\n    s=s.replace('\xA5','')\n\
    \    s=s.replace('*','')\n    s=s.replace('&','')\n    s=s.replace('*','')\n \
    \   s=s.replace('&','')\n    s=s.replace('^','')\n    s=s.replace('\xA3','')\n\
    \    s=s.replace('\xA5','')\n    s=s.replace('\xA2','')\n    s=s.replace('"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
