name: HumanEval_120_maximum
language: pl
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum([4, -4, 4],\
  \ 2)\n# [4, 4]\n# Example 3:\n# >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n\
  # Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The\
  \ elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\n\
  sub maximum {\n    my($arr, $k) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&maximum;\n\
  \        if(eq_deeply($candidate->([-3, -4, 5], 3),[-4, -3, 5])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ -4, 4], 2),[4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([-3, 2, 1, 2, -1, -2, 1], 1),[2])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([123,\
  \ -123, 20, 0, 1, 2, -3], 3),[2, 20, 123])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([-123, 20, 0, 1, 2,\
  \ -3], 4),[0, 1, 2, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8,\
  \ 0, 0, 3, 5, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([-1, 0, 2, 5, 3, -10], 2),[3, 5])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 0, 5, -7], 1),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([4, -4], 2),[-4, 4])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10,\
  \ 10], 2),[-10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, -23, 243, -400, 0], 0),[])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @result;\n    # Write your code here.\n    foreach my $num (@$arr)\
    \ {\n        if ($num > $k) {\n            push (@result, $num);\n        }\n\
    \    }\n    push @result, $k;\n    return @result;\n}", "    my $i = 0;\n    my\
    \ @res;", "    my($i, $j, $max, $res);\n    for($i = 0; $i < $k; $i++) {\n   \
    \     if($i > 0) {\n            $max = max($max, $arr[$i-1]);\n        }\n   \
    \     else {\n            $max = $arr[$i];\n        }\n        for($j = $i + 1;\
    \ $j < $k; $j++) {\n            if($arr[$j] > $max) {\n                $max =\
    \ $arr[$j];\n                $res = $max;\n            }\n        }\n        $arr[$i]\
    \ = $res;\n    }\n    return $arr;\n}", "    # Write your code here.\n    my @maxes\
    \ = ();\n    my $n = @$arr;\n    my $m = @$maxes;\n    foreach my $i (0..$n-1)\n\
    \    {\n        if($arr[$i] > $arr[$i-1])\n        {\n            push(@maxes,\
    \ $arr[$i]);\n        }\n        else\n        {\n            push(@maxes, $arr[$i-1]);\n\
    \        }\n    }\n    for(my $i = 0;$i<$m;$i++)\n    {\n        if($maxes[$i]\
    \ != $maxes[$i-1])\n        {\n            push(@maxes, $maxes[$i]);\n       \
    \ }\n        else\n        {\n            push(@maxes, $maxes[$i-1]);\n      \
    \  }\n    }\n    return @maxes;\n}", "    my $max = @$arr;\n    for(my $i = 1;\
    \ $i <= $k; $i++) {\n        $max = max $max, @$arr[$i..@$arr];\n    }\n    return\
    \ @$arr[$k..$max];\n}", "    $k || return ();\n    @$arr = @$arr[0,@$arr] if @$arr\
    \ <= 1000;\n    @$k = @$arr[0,$k] if @$k <= @$arr;\n    $k >= @$k || return ();\n\
    \    my $i = 0;\n    my @ret;\n    while ($i < @$arr) {\n        last if $i >=\
    \ $k;\n        push @ret, @$arr[$i..$i];\n        $i++;\n    }\n    return @ret;\n\
    }", '    my @result;', '    my @ans;', "    my @ret = ();\n    my $len = scalar\
    \ @$arr;\n    my $min = $arr->[0];\n    my $max = $arr->[0];\n    my $i = 0;\n\
    \    my $j = 0;\n    while ($i < $len) {\n        if ($arr->[$i] >= $max) {\n\
    \            $max = $arr->[$i];\n        }\n        $i++;\n    }\n    while ($j\
    \ < $k) {\n        if ($arr->[$j] < $min) {\n            $min = $arr->[$j];\n\
    \        }\n        $j++;\n    }\n    while($i < $len) {\n        if ($arr->[$i]\
    \ < $min) {\n            push (@ret, []);\n            $min = $arr->[$i];\n  \
    \      }\n        else {\n            push (@ret, $arr->[$i]);\n        }\n  \
    \      $i++;\n    }\n    return @ret;\n}", "    my @m;\n    my $i;\n    \n   \
    \ for ($i = 0; $i < $k; $i++) {\n        $m[$i] = $arr[$i] if $arr[$i] > 0;\n\
    \    }", "    return undef if not @$arr;\n    return sort { $a <=> $b }\n    \
    \    if $k <= 0;\n    my($max) = (@$arr)[0];\n    my $index = 0;\n    foreach\
    \ (@$arr) {\n        next if $index % $k == 0;\n        last if $_ > $max;\n \
    \       $max = $_;\n        $index++;\n    }\n    return $max;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nYour `maximum` function doesn't seem to do what your\
    \ description says it does.  It returns the largest element in the array.  It\
    \ does not return the largest k elements from the array.\n<|/ c |>\n<| c |>\n\
    It returns the largest k elements from the array.\n<|/ c |>\n<| a dscore=1 tags=sorting,arrays,perl,max\
    \ |>\n<code>", "    my @a;\n    my $size = @$arr;\n    if ($size <= 1) {\n   \
    \     return @$arr;\n    }\n    for my $i ( 0 .. $size - 1 ) {\n        my $max\
    \ = $$arr[$i];\n        for (my $j = $i + 1; $j < $size; ++$j) {\n           \
    \ if ($$arr[$j] > $max) {\n                $max = $$arr[$j];\n            }\n\
    \        }\n        push @a, $max;\n    }\n    return @a;\n}", "    if (@_ ==\
    \ 1) {\n        my($arr) = $_;\n        $k = scalar(@$arr);\n    }\n    my(@k)\
    \ = ();\n    for(my $i = scalar(@$arr) - 1; $i >= 0; $i--) {\n        push(@k,\
    \ $arr->[$i]);\n    }\n    for(my $i = $k; $i >= scalar(@k); $i--) {\n       \
    \ pop(@k);\n    }\n    for(my $i = scalar(@k) - 1; $i >= 0; $i--) {\n        push(@k,\
    \ $k->[$i]);\n    }\n    return \\@k;\n}", "    my @ret = [];\n    $k--; # k is\
    \ decremented because we want to get the maximum from the end\n    while ($k >\
    \ 0) {\n        push(@ret, $arr[$k]) if ($arr[$k] > $arr[$k - 1]);\n        $k--;\n\
    \    }\n    push(@ret, @{$arr[$k]..$arr[-1]});\n    return @ret;\n}", "    if(@$arr\
    \ <= $k){\n        return $arr;\n    }\n    \n    my($max, $max) = (undef, undef);\n\
    \    for(my $i = 0; $i < $k; $i++){\n        $max = ($arr[$i] > $max) ? $arr[$i]\
    \ : $max;\n    }\n    return $max;\n}", "    my $max_cnt = 0;\n    my @res;\n\
    \    for(my $i = 0; $i < $k; $i++) {\n        $max_cnt++;\n        $res[$i] =\
    \ (defined $arr[$i] ? $arr[$i] : $i);\n    }\n    for(my $i = $k; $i < $#arr;\
    \ $i++) {\n        if($arr[$i] > $arr[$i - 1]) {\n            my $tmp_max = @res\
    \ - 1;\n            my $tmp_idx;\n            for(my $j = 0, $j_size = $i - 1;\
    \ $j < $j_size; $j++) {\n                if($tmp_max < $res[$j]) {\n         \
    \           $tmp_max = $res[$j];\n                    $tmp_idx = $j;\n       \
    \         }\n            }\n            $res[$tmp_idx] = $arr[$i];\n        }\
    \ else {\n            push @res, $arr[$i];\n        }\n        $max_cnt--;\n \
    \       if($max_cnt == 0) {\n            my $j = $i - 1;\n            for(my $k\
    \ = @res - 1; $k > 0; $k--) {\n                @res[$k] = $res[$k - 1];\n    \
    \        }\n            @res = @res[0..$k];\n        }\n    }\n    return @res;\n\
    }", "    my @result;\n    for (my $i = 0; $i < $k; $i++) {\n        my $max =\
    \ pop(@$arr);\n        push @result, $max if $max > @$arr;\n    }\n    return\
    \ @result;\n}", "    if (@$arr > $k) {\n        die \"Not enough elements in array\
    \ to form a sorted array!\\n\";\n    }\n    my @sorted = ();\n    foreach my $i\
    \ (0 .. $k - 1) {\n        my $max_ele = $arr[$i];\n        for (my $j = $i +\
    \ 1; $j < @$arr; $j++) {\n            if ($arr[$j] > $max_ele) {\n           \
    \     $max_ele = $arr[$j];\n            }\n        }\n        push(@sorted, $max_ele);\n\
    \    }\n    return @sorted;\n}", "    @_ = ();\n    my $min_idx = 0;\n    my $i\
    \ = -1;\n    my $max_idx = $#arr + 1;\n    my $ans = @$arr;\n    my $tmp_max =\
    \ 0;\n    my $flag = 0;\n    for(my $i = 0; $i <= $max_idx and $i < $k; $i++)\
    \ {\n        if($arr[$i] >= $tmp_max) {\n            $tmp_max = $arr[$i];\n  \
    \          $min_idx = $i;\n            $flag = 1;\n        }\n    }\n    if(!$flag)\
    \ {\n        for(my $i = $k; $i <= $max_idx and $i < $#arr; $i++) {\n        \
    \    if($arr[$i] >= $tmp_max) {\n                $tmp_max = $arr[$i];\n      \
    \          $min_idx = $i;\n                $flag = 1;\n            }\n       \
    \ }\n    }\n    for(my $i = $k; $i <= $max_idx and $i > 0; $i--) {\n        if($arr[$i]\
    \ >= $tmp_max) {\n            $tmp_max = $arr[$i];\n            $min_idx = $i;\n\
    \            $flag = 1;\n        }\n    }\n    for(my $i = $min_idx; $i <= $max_idx;\
    \ $i++) {\n        $ans[$i] = $arr[$i];\n    }\n    return @$ans;\n}", "    my\
    \ @res;\n    my @copy;\n    for (my $i = 0; $i < @$arr; $i++) {\n        push(@copy,\
    \ $arr->[$i]);\n    }\n    foreach my $i (1 .. $k) {\n        my $j = 0;\n   \
    \     for my $j (0 .. $#copy) {\n            last if ($copy[$j] > $copy[$j + 1]);\n\
    \            push(@res, $copy[$j]);\n            $j++;\n        }\n        shift\
    \ @copy;\n    }\n    return @res;\n}", "    $k = _check_input($k, scalar(keys\
    \ %{$arr}));\n    my @ret;\n    my %max = (0 => 0, 1 => 0);\n    my %reverse =\
    \ (0 => 0, 1 => 0);", "    return sort { $a <=> $b } @$arr[0..$k-1];\n}", "  \
    \  my @result;\n    if ($k == 1) {\n        $result[0] = $arr[0];\n        return\
    \ @result;\n    }\n    my $min = MAX_INT;\n    my $max = MIN_UINT;\n    my $flag\
    \ = 0;\n    my $count = 1;\n    foreach my $index (0..$#$arr) {\n        if ($arr[$index]\
    \ > $max) {\n            $max = $arr[$index];\n        }\n        if ($arr[$index]\
    \ < $min) {\n            $min = $arr[$index];\n        }\n        if ($flag !=\
    \ 1) {\n            $count += 1;\n            if ($count >= $k) {\n          \
    \      $flag = 1;\n                $result[$count] = $arr[$index];\n         \
    \   }\n        } else {\n            if ($arr[$index] > $max) {\n            \
    \    $max = $arr[$index];\n            }\n            if ($arr[$index] < $min)\
    \ {\n                $min = $arr[$index];\n            }\n        }\n    }\n \
    \   return @result;\n}\n</code>\n<|/ a tags=algorithm,arrays,perl |>\n<| a dscore=0\
    \ |>\n<code>\npackage Array::Max;\nuse Exporter;\nour = qw(Exporter);\nour = qw(max_in_array);",
  "    my $len = 0;\n    my $max = undef;\n    for (my $i = 0; $i <= $#$arr; $i++)\
    \ {\n        if ($arr[$i] > $max) {\n            $max = $arr[$i];\n          \
    \  $len = $i;\n        }\n    }\n    my $ret = [];\n    for (my $i = 0; $i <=\
    \ $#$arr; $i++) {\n        if ($i < $len) {\n            $ret[$i] = $arr[$i];\n\
    \        }\n        if ($i == $len) {\n            push (@$ret, $max);\n     \
    \   }\n    }\n    return @$ret;\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3\
    \ |>\nHere's an easy one-liner that does it all in one line of Perl code:\n<code>\n\
    perl -MList::Util=max -le 'print max map {(length($_), $_)} (sort{length($b) <=>\
    \ length($a)})'\n</code>\nThis sorts by the length of the strings first so the\
    \ biggest is first, then sorts by the length of the strings again, so the shorter\
    \ strings are first.\n<|/ a tags=sorting,arrays,perl,max |>\n<| a dscore=3 |>\n\
    <code>\nuse List::Util qw(max);", "    my(@result) = ();\n    my $min = $arr->[0];\n\
    \    my $max = -$min;\n    foreach my $i (0..$#$arr) {\n        if ($arr->[$i]\
    \ > $max) {\n            $max = $arr->[$i];\n        }\n    }", "    my @arr =\
    \ @$arr;\n    my $max = -999;\n    my $i = 0;\n    my $j = 0;\n    while ($i <\
    \ $k && $j < $#arr) {\n        if ($arr[$i] >= $max) {\n            $max = $arr[$i];\n\
    \        }\n        $i++;\n        $j++;\n    }\n    @$arr = map {; $_ >= $max\
    \ ? $max : $_ }[0..$k];\n    return @arr;\n}", "    $k ||= 0;\n    my @result\
    \ = ();\n    my $max_index = 0;\n    my $max_value = $arr[0];\n    my $index =\
    \ 0;\n    foreach my $value (@$arr) {\n        next if ($value > $max_value);\n\
    \        push(@result, $value);\n        $index++;\n        if ($index >= $k)\
    \ {\n            $max_value = $value;\n            $max_index = $index;\n    \
    \    }\n    }\n    $arr[$max_index] = $max_value;\n    return @result;\n}", " \
    \   my(@max_nums) = (0);\n    foreach my $num (@$arr) {\n        push(@max_nums,\
    \ $num) if $num > $max_nums[-1];\n    }\n    \n    my $count = 0;\n    foreach\
    \ my $num (@max_nums) {\n        push @$max_nums[$count++] if $count >= $k;\n\
    \    }\n    return @$max_nums if $count == $k;\n    return;\n}", "    my $result;\n\
    \    my @ret;\n    \n    # k >= len(arr)\n    if($k < 0) {\n        return @ret;\n\
    \    }\n    \n    # k == len(arr)\n    if($k == @$arr) {\n        my $max = &MAX($arr);\n\
    \        for(my $i = 0; $i < $k; $i++) {\n            $ret[$i] = $max;\n     \
    \   }\n        return @ret;\n    }\n    \n    # k <= len(arr)\n    for(my $i =\
    \ 0; $i < $k; $i++) {\n        # Find max element in the range\n        my $max\
    \ = &MAX($arr);\n        \n        # Find a place to put max element in the sorted\
    \ array\n        # Find the index of max element\n        my $index = &INDEX($arr,\
    \ $max);\n        \n        # Insert the max element in sorted array\n       \
    \ @ret[$i] = $arr[$index];\n        \n        # Shift elements from the original\
    \ array\n        # Keep the original array length <= k\n        splice(@$arr,\
    \ 0, @$arr[$index..$#arr]);\n    }\n    \n    # Return the sorted array\n    return\
    \ @ret;\n}", "    my@ret = ();\n    my $i = 0;\n    my $j = 0;\n    my $tmp =\
    \ 0;\n    while (@$arr) {\n        $tmp = $_;\n        $j = 0;\n        while\
    \ ($j < $k and $tmp > $arr[$j]) {\n            $tmp = $arr[$j];\n            $j++;\n\
    \        }\n        push @$ret, @$arr[$i .. $j];\n        $i++;\n    }\n    return\
    \ @$ret;\n}", '    my(@res, $max) = (0, undef);', '    my(@new_arr) = ();', " \
    \   my($max_val);\n    my @res;", "    @$arr = sort {$a <=> $b} @$arr;\n    my\
    \ @res;\n    my $i = 0;\n    for my $num (@$arr) {\n        if ($i < $k) {\n \
    \           $res[$i] = $num;\n            $i++;\n        } else {\n          \
    \  pop @res;\n        }\n    }\n    @res;\n}", "    if (@$arr > $k) {\n      \
    \  # if the length is greater than $k, then return the original array.\n     \
    \   return @$arr;\n    } elsif (@$arr == 0) {\n        return ();\n    } else\
    \ {\n        # sort arr in the range of [0, $k-len(arr))\n        my @sorted_arr\
    \ = sort { $a <=> $b } @$arr[0..$k-1];\n        # return the original array if\
    \ $k <= len(arr)\n        return @$arr if $k <= @sorted_arr;\n        # return\
    \ the sorted array\n        return @sorted_arr;\n    }\n}", "    my @new_arr;\n\
    \    my $max_count = 0;\n    my $i = 0;\n    while (@$arr) {\n        my $cur_count\
    \ = $arr->[$i];\n        if ($cur_count > $max_count) {\n            while (@new_arr)\
    \ {\n                pop @new_arr;\n            }\n            push @new_arr,\
    \ $max_count;\n        }\n        $max_count = $cur_count;\n        ++$i;\n  \
    \  }\n    while (@new_arr) {\n        pop @new_arr;\n    }\n    return @new_arr;\n\
    }", "    my @sorted;\n    my @max_elements = ();\n    for(my $i = 0; $i < @$arr;\
    \ ++$i) {\n        my $value = $arr->[$i];\n        my $index = 0;\n        for(my\
    \ $j = 0; $j < @sorted; ++$j) {\n            my $comparison = $sorted->[$j];\n\
    \            my $comparison_value = $comparison->[$index];\n            if($value\
    \ == $comparison_value) {\n                last;\n            }\n            elsif($index\
    \ == 0) {\n                $sorted->[$j] = $comparison;\n                $index\
    \ = 1;\n            }\n            else {\n                last;\n           \
    \ }\n        }\n        if($index == $k) {\n            push @max_elements, $value;\n\
    \        }\n    }\n    return @max_elements;\n}", "    return $arr if $k == 0;\n\
    \    return $arr if $arr[0] > $arr[$k-1];\n    my $min = 99999999999999;\n   \
    \ for (my $i = 0; $i < $k; $i++) {\n        $min = 1 if $arr[$i] < $min;\n   \
    \ }\n    return @$arr[0..$k-1] if $min == 99999999999999;\n    return @$arr[0..$k-1]\
    \ if $min > 99999999999999;\n    my $result = ();\n    for (my $i = 0; $i < $k;\
    \ $i++) {\n        $result[$i] = $arr[$i] if $arr[$i] > $min;\n    }\n    return\
    \ @$result;\n}", "    my $index = 0;\n    my @max_elements;\n    my %maximum =\
    \ ();", "    my @max = ();\n    my $index = 0;\n    my $max = 0;\n    for(my $i\
    \ = 0; $i < $k; $i++) {\n        my $tmp = 0;\n        for(my $j = 0; $j < $k;\
    \ $j++) {\n            if(!($j % $k)) {\n                $tmp += $arr[$j];\n \
    \           }\n        }\n        if($tmp > $max) {\n            $max = $tmp;\n\
    \        }\n    }\n    for(my $j = 0; $j < $k; $j++) {\n        if(!($j % $k))\
    \ {\n            $arr[$j] = $max;\n        }\n    }\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis takes time proportional to $k, which makes it O(n^2)\n<|/ c |>\n\
    <| c |>\nNope, it's O(n) and O(1) ;) The $max variable is initialized to 0 outside\
    \ the for loop, so it is only accessed once per element in the array.\n<|/ c |>\n\
    <| c |>\n: It takes time proportional to $k.  That means it takes time proportional\
    \ to $k^2 in general.  It's true that in this case, it takes time proportional\
    \ to $k, but the constant factor is very small.\n<|/ c |>\n<| c |>\nNo, it's O(n)\
    \ because it's in the outer loop, which runs n times.  It's O(n^2) because of\
    \ the double loop.\n<|/ c |>\n<| c |>\n: No, it's O(1) because it's in the outer\
    \ loop.  It's O(n^2) because of the double loop.  It's O(n^3) because of the double\
    \ loop.\n<|/ c |>\n<| a tags=algorithm,perl |>\nSince no one has yet posted a\
    \ Perl solution, here's another C solution, with the benefit of efficiency of\
    \ using one O(n) pass through the data.  It uses some basic ideas from the answer\
    \ given by daniu and some ideas from my other answer to this question.\n<code>\n\
    /* Maximum subarray sum subproblem */", "    my @out;\n    my @temp;\n    \n \
    \   for (my $i = 0; $i < $k; ++$i) {\n        push @temp, pop (@$arr);\n    }\n\
    \    for (my $i = 0; $i < $k; ++$i) {\n        if ($arr[$i] > $temp[0]) {\n  \
    \          push @out, $temp[0];\n        }\n        else {\n            push @out,\
    \ $arr[$i];\n        }\n    }\n    \n    return @out;\n}", "    my @ans;\n   \
    \ my $i;\n    my $curr;\n    my $max;\n    my $min_max;\n    my $min;", "    my\
    \ @ret;\n    for my $i (0 .. $k-1) {\n        $ret[$i] = $arr[$i] if $arr[$i]\
    \ > $ret[$i];\n        $ret[$i] = $arr[$i] if $arr[$i] > $ret[$i];\n    }\n  \
    \  return @ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,perl,arrays,algorithm\
    \ |>\nHere is my solution:\n<code>\nmy = qw(4 -4 4);\nmy $max = shift;", "   \
    \ my(@ret) = ();\n    my $i = 0;\n    while (@$arr[$i]) {\n        push(@ret,\
    \ $$arr[$i] if ($i >= $k);\n        $i++;\n    }\n    return @ret;\n}\n</code>\n\
    <|/ a tags=perl,sorting,algorithm,arrays |>\n<| a dscore=1 |>\nI know this question\
    \ has been answered already but here is a solution using hash slice and hashes\n\
    <code>", "    my @ret;\n    my $i = 0;\n    my $j = 0;\n    while(@$arr) {\n \
    \       $ret[$i] = $arr[$j] if $j++ == $k;\n        ++$i;\n    }\n    return @ret;\n\
    }", "    my @result;\n    # Initialize max and max index\n    my $max = $arr[0];\n\
    \    my $max_index = 0;\n    # Initialize i as 0\n    my $i = 0;\n    # Initialize\
    \ result array\n    @result = ();\n    # Initialize flag\n    my $flag = 1;\n\
    \    while ($i < $k) {\n        # Compare current max with arr[i] and get max\
    \ index\n        $flag = 1 if ($arr[$i] > $max);\n        if ($flag == 1) {\n\
    \            $max = $arr[$i];\n            $max_index = $i;\n        }\n     \
    \   elsif ($flag == 0) {\n            if ($arr[$i] == $max) {\n              \
    \  # If current max is not equal to arr[i]\n                push (@result, $max);\n\
    \                $max = $arr[$i];\n            }\n            else {\n       \
    \         # If current max is equal to arr[i], then swap arr[i] and arr[$i]\n\
    \                # and swap arr[$i] and arr[$max_index]\n                $arr[$i]\
    \ ^= $max;\n                $arr[$max_index] ^= $arr[$i];\n                $arr[$i]\
    \ ^= $arr[$max_index];\n                $arr[$max_index] ^= $arr[$i];\n      \
    \      }\n        }\n        ++$i;\n    }\n    return @result;\n}", "    \n  \
    \  if(!defined $k) {\n        return $arr;\n    }\n    \n    my $count = @$arr;\n\
    \    my $result = [];\n    \n    for my $i (1..$k) {\n        if($arr[$i] > $arr[$i\
    \ - 1]) {\n            push($result, $arr[$i - 1]);\n        }\n    }\n    \n\
    \    for my $i (@$arr) {\n        if($i > $arr[$k - 1]) {\n            push($result,\
    \ $i);\n        }\n    }\n    \n    return $result;\n}", "    my @re;\n    for(my\
    \ $i=0; $i<$k; ++$i) {\n        my $max = -1;\n        for(my $j=0; $j<$i; ++$j)\
    \ {\n            my $v = $arr[$j];\n            if($v > $max) {\n            \
    \    $max = $v;\n            }\n        }\n        push @re, $max;\n    }\n  \
    \  return @re;\n}", '    my @res;', "    my @result;\n    my @mins;\n    my $i;\n\
    \    my $max = 0;\n    \n    # find minimum element in arr\n    $min = @$arr;\n\
    \    for(my $i = 0; $i < @$arr; ++$i) {\n        if($arr->[$i] < $min) {\n   \
    \         $min = $arr->[$i];\n        }\n    }\n    \n    # push min element to\
    \ mins array\n    push(@mins, $min);\n    \n    # push rest of elements to result\
    \ array\n    for(my $i = @$arr; $i < $k; ++$i) {\n        if($arr->[$i] > $min)\
    \ {\n            push(@mins, $arr->[$i]);\n        } else {\n            push(@result,\
    \ $arr->[$i]);\n        }\n    }\n    \n    # push max element to result array\n\
    \    push(@result, $max);\n    \n    # sort result array\n    for(my $i = 0; $i\
    \ < @mins; ++$i) {\n        for(my $j = 0; $j < @result; ++$j) {\n           \
    \ if($mins->[$i] <= $result->[$j]) {\n                ($mins->[$i], $result->[$j])\
    \ = ($mins->[$i], $result->[$j]);\n            }\n        }\n    }\n    \n   \
    \ @result;\n}\n</cell>\n<cell>\n@maxs = maximum([-3, -4, 5], 3);\n@maxs\n</cell>\n\
    <text>\nThe \"sorted\" module (for Python)", "    return sort { $a <=> $b } @$arr[0..$k-1];\n\
    }", "    @$arr = sort {$a <=> $b} @$arr;\n    my @ans = ();\n    for ($k > 0)\
    \ {\n        my $tmp = 0;\n        for my $i (@$arr) {\n            if ($i > $tmp)\
    \ {\n                $tmp = $i;\n            }\n        }\n        if ($tmp >\
    \ 0) {\n            push @ans, $tmp;\n            $k--;\n        }\n    }\n  \
    \  return @ans;\n}", "    return sort { $a <=> $b } @$arr[0..$k - 1 ];\n}", " \
    \   my($i, $max_value, $result);\n    $k-- if $k > @$arr;\n    my $size = @$arr;\n\
    \    for ($i = 0; $i < $size; $i++) {\n        $result[$i] = $arr[$i] if $arr[$i]\
    \ > $max_value;\n        $max_value = $arr[$i] if $arr[$i] >= $max_value;\n  \
    \  }\n    splice(0, @$result, $k);\n    return $result;\n}", "    my(@result);\n\
    \    \n    # find the index with max element\n    my $max_idx = 0;\n    my $max_element\
    \ = 0;\n    my $current_idx = 0;\n    \n    for (my $i = 0; $i <= $k; $i++) {\n\
    \        if ($arr[$i] > $max_element) {\n            $max_idx = $current_idx;\n\
    \            $max_element = $arr[$i];\n        }\n        $current_idx += 1;\n\
    \    }\n    \n    # find the element at that index and put it at end of the array\n\
    \    for (my $i = 0; $i <= $k; $i++) {\n        if ($i == $max_idx) {\n      \
    \      push(@result, [$arr[$i]]);\n        } else {\n            push(@result,\
    \ splice(@arr, $i, 1));\n        }\n    }\n    return @result;\n}", "    if ($k\
    \ <= 0) { \n        return [];\n    } elsif ($k >= $#{$arr}) { \n        return\
    \ [$arr[$k]];\n    }\n    my;\n    $k = min $k, $#{$arr};\n    $k <= 0 or die;",
  "    my @res = ();\n    my $max_val = -999999;\n    my $cur;\n    my $i;\n    my\
    \ $cur_idx = 0;\n    my %cur_idx;\n    \n    # Find the largest number in the\
    \ array and store its index\n    for($i=0; $i < $k; $i++){\n        $cur = $arr[$i];\n\
    \        if ($cur > $max_val){\n            $max_val = $cur;\n        }\n    }",
  "    my @max_arr = ();\n    my $len = @$arr;\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        my $cur = $arr->[$i];\n        for (my $j = 0; $j < $k; $j++) {\n\
    \            my $tmp = $cur;\n            $cur = $max_arr[$j];\n            $max_arr[$j]\
    \ = $tmp;\n        }\n    }\n    return @max_arr;\n}\n</code>\n<|/ a tags=math,python\
    \ |>\n<| c |>\nThe question is about Python code, not Ruby code.\n<|/ c |>\n<|\
    \ a tags=math,python |>\nYou can do it without iterating over the whole list by\
    \ using a list comprehension:\n<code>\ndef maximum(lst, k):\n    return sorted([x\
    \ for x, y in zip(lst, range(0, len(lst), k)) if y > 0])\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis works because it sorts by the second value of the tuple. \
    \ Since the first item in the list is always 0, it will always be the largest\
    \ one.\n<|/ c |>\n<| c |>\nThe question asks for the \"maximum k numbers in arr\"\
    , not \"the maximum of the first k numbers\". Also, sorting by second value doesn't\
    \ necessarily work if the array contains duplicate values.\n<|/ c |>\n<| c |>\n\
    I agree with you that it doesn't answer the question as it's written, but this\
    \ answer is more useful for someone looking for \"maximum k numbers in arr\" rather\
    \ than the max value of a particular number.\n<|/ c |>\n<| a |>\nHere is my solution\
    \ to find the maximum k numbers in an array.\n<code>\ndef maxK(A, k):\n    length\
    \ = len(A)\n    kValue = k-1\n    maxValue = -A[0]\n    for i in range(0, length):\n\
    \        if(A[i] > maxValue):\n            maxValue = A[i]\n            kValue\
    \ = k\n        elif (A[i] == maxValue):\n            kValue += 1\n        if(kValue\
    \ > len(A)):\n            break", '    my @result;', "    my @result;\n    $k\
    \ = int((@$arr + $k - 1) / ($k + 1));\n    for my $i (0 .. $k) {\n        $result[$i]\
    \ = $arr[$i] if $arr[$i] > $arr[$i + 1]; \n        $result[$i] = $arr[$i] if $arr[$i]\
    \ < $arr[$i - 1];\n    }\n    return @result;\n}", "    my $ret = @$arr[0..$k-1];\n\
    \    for (my $i = $k - 1; $i >=0 && $ret[$i] < $arr[$i]; $i--) {\n\t$ret[$i+1]\
    \ = $ret[$i];\n    }\n    $ret[$i] = $arr[$i];\n    return @$ret;\n}", "    my\
    \ @ans;\n    my $n = @$arr;\n    my $k = 0;\n    for (my $i = 0; $i < $n; $i++)\
    \ {\n        $k++;\n        if ($k > $k) {\n            push(@ans, $arr[$i]);\n\
    \            $k = 0;\n        }\n    }\n    for (my $i = 0; $i < $n; $i++) {\n\
    \        $k++;\n        if ($k == $k) {\n            push(@ans, $arr[$i]);\n \
    \       }\n    }\n    return @ans;\n}", "    my @res;\n    my $max = $arr->[0]\n\
    \        ; my $count = 1;\n    for my $i (1..$arr->[0]) {\n        if ($arr->[$i]\
    \ >= $max) {\n            $max = $arr->[$i];\n            $count = 1;\n      \
    \  } elsif ($arr->[$i] == $max) {\n            $count++;\n        }\n    }\n \
    \   push(@res, $max) for(1..$k) if $count > 1;\n    @res;\n}", '    my @sorted_arr
    = ();', "    @$arr = sort {$a <=> $b} @$arr;\n    my $result = $arr[0];\n    for(my\
    \ $i = 1; $i <= $k; $i++)\n    {\n        if($arr[$i] > $result)\n        {\n\
    \            $result = $arr[$i];\n        }\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=algorithm,sorting,perl,arrays dscore=1 |>\n<| c |>\nIf you're going\
    \ to use the return value, you should use the `sort` function instead of `sort{$a\
    \ <=> $b}` since the latter only works in very special cases, and the former handles\
    \ all cases.\n<|/ c |>\n<| c |>\nThis can be simplified using a single for loop:\
    \  `for (my $i = 1; $i <= $k; $i++){ if($arr[$i] > $result){$result = $arr[$i]}}`\n\
    <|/ c |>\n<| c |>\nThe subroutine is returning a scalar value instead of an array.\n\
    <|/ c |>\n<| c |>\nOh, right.  I thought it would be obvious that it's returning\
    \ a scalar value.  Fixed.\n<|/ c |>\n<| a tags=algorithm,sorting,perl,arrays |>\n\
    <code>", "    my @result;\n    for (my $i = 0; $i < @$arr; $i++) {\n        my\
    \ $elem = $arr->[$i];\n        if ($k > 0) {\n            while (++$i < @$arr\
    \ && $elem >= $arr->[$i]) {\n                $elem = $arr->[$i];\n           \
    \ }\n        }\n        if ($k == 0) {\n            push, $elem;\n           \
    \ last;\n        }\n        push, $elem;\n    }\n    return @result;\n}\n</code>\n\
    And here is my solution:\n<code>", "    my;\n    my $i = 0;\n    my $max = 0;",
  "    $k += 0;\n    my @temp;", '    @_ >= 1 || @_ > 3 || @_ <= 1000;', "    my @result;\n\
    \    my $max = $arr[0];\n    foreach my $i (@$arr) {\n        push(@result, $i\
    \ if ($i > $max);\n    }\n    push (@result, $max) if ($k == 0);\n    return @result;\n\
    }", "    my @sorted;\n    \n    # check valid\n    die \"k should be in the range\
    \ of [1, 1000]\\n\" if $k < 1 || $k > 1000;\n    die \"arr length should be in\
    \ the range of [1, 1000]\\n\" if @$arr > 1000;\n    die \"elements in arr should\
    \ be in the range of [-1000, 1000]\\n\" \n        if grep { ($a < -1000 || $a\
    \ > 1000) } @$arr;\n    \n    # sort array and get the first k element of sorted\
    \ array\n    foreach my $a (@$arr) {\n        if ($a > $sorted[-1]) {\n      \
    \      push @sorted, $a;\n        }\n    }\n    \n    # return sorted array\n\
    \    return @sorted;\n}", "    my @res;\n    $k++ if $k > @$arr;\n    for my $i\
    \ (0..$#arr) {\n        if ($arr[$i] > $arr[$i+1]) {\n            push(@res, $arr[$i]);\n\
    \        } else {\n            push(@res, $arr[$i+1]);\n        }\n    }\n   \
    \ push(@res, $arr[$#arr]);\n    return @res;\n}", "    my $length = @$arr;\n \
    \   my $i = 0;\n    my $max_num = -1;", "    if (@$arr > $k) {\n        @$arr\
    \ = ();\n    } else {\n        my @temp = ();\n        for (my $i = @$arr; $i\
    \ > $k; $i--) {\n            push(@temp, $arr[$i - 1]);\n        }\n        @$arr\
    \ = @temp;\n    }\n    @$arr;\n}", "    $k > 0 && $k < @$arr || die \"k should\
    \ be between 0 and len of arr\\n\";\n    my @r;\n    for (my $i = 0; $i < $k;\
    \ $i++) {\n\tpush @r, $arr[$i] if $arr[$i] > $arr[$i+1];\n    }\n    @r;\n}",
  "    return sort {$a <=> $b} @$arr[0..$k-1];\n}", "    $k += 0;\n    my @tmp;\n\
    \    my $max_i = 0;\n    my $tmp = 0;\n    my $i = 0;\n    foreach my $num (@$arr)\
    \ {\n        if ($i < $k) {\n            if ($tmp > $num) {\n                $tmp\
    \ = $num;\n                $max_i = $i;\n            }\n            $i++;\n  \
    \      }\n        elsif ($k > 0) {\n            push @tmp, $num;\n           \
    \ $k--;\n        }\n    }\n    return @tmp;\n}", '    my @result;', "    my $result\
    \ = $arr;\n    $k--; # k is greater than or equal to 0\n    my $i;\n    while\
    \ ($k > 0) {\n        $i = 0; \n        for my $j (0 .. $#arr) {\n           \
    \ if ($arr[$j] >= $arr[$i]) {\n                $result[$i] = $arr[$j];\n     \
    \           last if $i == $k - 1; # if k = 1, the while loop will be skipped\n\
    \                $i++;\n            } else {\n                $i--;\n        \
    \    }\n        }\n        $k--;\n    }\n    return $result;\n}", "    my($result,\
    \ $n);\n    for(my $i = 0; $i < $k; $i++) {\n        $result[$i] = 0;\n    }\n\
    \    my($min, $max);\n    for(my $i = 0; $i < $#arr; $i++) {\n        $min = 10000;\n\
    \        $max = 0;\n        for(my $j = $i + 1; $j < $#arr; $j++) {\n        \
    \    if($arr[$i] > $arr[$j]) {\n                $max = $arr[$i];\n           \
    \     $min = $arr[$j];\n            }\n            else {\n                $min\
    \ = $arr[$i];\n                $max = $arr[$j];\n            }\n        }\n  \
    \      $result[$i] += $max - $min;\n    }\n    for(my $i = 0; $i < $#result; $i++)\
    \ {\n        $result[$i] = -($result[$i] % 1000);\n    }\n    return @result;\n\
    }\n</code>\n<|/ a tags=perl,sorting,algorithm |>\n<| a |>\nA variant of quicksort\
    \ that can sort a list with duplicates and then remove duplicates:\n<code>\nuse\
    \ strict;\nuse warnings;", "    my(@result) = ();\n    for(my $i = 0; $i < $k;\
    \ ++$i) {\n        my($tmp_max) = $arr[$i] > $arr[$i + 1] ? $arr[$i] : $arr[$i\
    \ + 1];\n        my($tmp_min) = defined($arr[$i + 1]) ? $arr[$i + 1] : 0;\n  \
    \      push(@result, [$tmp_max, $tmp_min]);\n    }\n    return @result;\n}\n</code>\n\
    <|/ a tags=algorithm,dynamic-programming |>\n<| a dscore=0 |>\nA solution involving\
    \ O(n^2) time and O(1) space. The space could be optimized but since we are dealing\
    \ with small numbers here I wouldn't bother.\n<code>\ndef max_sub_array(arr, k):\n\
    \    max = -float('inf')\n    for i in range(len(arr)):\n        for j in range(i,\
    \ len(arr)):\n            diff = arr[i] - arr[j]\n            if diff > max:\n\
    \                max = diff\n    answers = []\n    current = 0\n    while current\
    \ < k:\n        current = current + 1 if arr[len(arr)-k] == max\n        answers.append(max)\n\
    \    return answers\n</code>\n<|/ a tags=algorithm,dynamic-programming |>\n<|\
    \ a |>\nHere is my dynamic programming solution:\n<code>", "    return sort {$arr[$_]\
    \ <=> $arr[$k - $_]} \n        [reverse @{$arr[0..$k - 1]} @{$arr[$k..@{$arr}[0]]}];\n\
    }", "    my @ret;\n    if (not @$arr) {\n\tpush(@ret,0);\n\treturn @ret;\n   \
    \ }", "    my @res;\n    for (my $i = $k - 1, $j = 0; $i >= 0; $i--, $j++) {\n\
    \        if ($arr[$i] > $arr[$i + 1]) {\n            push @res, $arr[$j];\n  \
    \      }\n    }\n    return @res;\n}", "    my @result;\n    for my $i (0..$#{$arr})\
    \ {\n        my($v) = @{$arr}[$i];\n        if ($i <= $k) {\n            if ($v\
    \ > $result[$i]) {\n                $result[$i] = $v;\n            }\n       \
    \ }\n        else {\n            push, $result[$i];\n        }\n    }\n    return\
    \ @result;\n}", "    @arr =~ s/^-//;\n    return sort { -$a <=> $b } (@arr[0..$k-1]);\n\
    }", "    my @result;\n    for (my $i = 0; $i < $k; ++$i) {\n        push(@result,\
    \ maxValue($arr));\n    }\n    sort(@result);\n    return @result;\n}", "    my;\n\
    \    my $size = scalar(@$arr);\n    \n    if ($k >= $size) {\n        return;\n\
    \    }\n    \n    for (my $i = 0; $i < $k; $i++) {\n        my $max = $arr[$i];\n\
    \        for (my $j = $i + 1; $j < $size; $j++) {\n            my $el = @{$arr[$j]};\n\
    \            if ($el > $max) {\n                $max = $el;\n            }\n \
    \       }\n        push(@max, $max);\n    }\n    return;\n}", "    return ();\n\
    }", "    @_ == 1 && $k == 1 ? @$arr : (@$arr =~ /(-?\\d+)/g);\n    my @ret = ();\n\
    \    for (my $i = $k - 1; $i >= 0; $i--) {\n        push @ret, pop @$arr;\n  \
    \  }\n    return @ret;\n}", "    my($max, $max_idx, @ret);\n    \n    # Check\
    \ if k is out of range.\n    if ($k >= @$arr) {\n        return @$arr;\n    }\n\
    \    \n    # Sort the given array and get its length.\n    @$arr = sort(@$arr);\n\
    \    my $length = @$arr;\n    \n    # Initialize the return array.\n    @ret =\
    \ ();\n    \n    # Iterate through array from back to front.\n    for (my $i =\
    \ $length - $k - 1; $i >= 0; $i--) {\n        # Find the index of the max value.\n\
    \        if ($arr[$i] > $arr[$max_idx]) {\n            $max_idx = $i;\n      \
    \  }\n        \n        # Append the value at the corresponding index.\n     \
    \   @ret[$i] = $arr[$i];\n    }\n    \n    # Append the max value at the end of\
    \ the return array.\n    @ret[$max_idx] = $arr[$max_idx];\n    \n    return @ret;\n\
    }", "    my @new_arr = ();\n    for(my $i = 0; $i < $k; $i++){\n        my $max_el\
    \ = undef;\n        my $max_i = $i;\n        for(my $j = $i; $j < @$arr; $j++){\n\
    \            my $tmp_el = $arr->[$j];\n            if($tmp_el > $max_el){\n  \
    \              $max_el = $tmp_el;\n                $max_i = $j;\n            }\n\
    \        }\n        $new_arr->[$i] = $arr->[$max_i];\n    }\n    return @new_arr;\n\
    }", "    my @nums = ();\n    my($max) = ();\n    my($i);\n    for(my $i = 0; $i\
    \ < @$arr; ++$i) {\n        $nums[$i] = $arr->[$i];\n    }\n    for(my $i = $k\
    \ - 1; $i >= 0; --$i) {\n        if(@nums > 0) {\n            $max[$i] = $nums[$i];\n\
    \            splice(@nums, $i, 1);\n        }\n    }\n    return $max;\n}", " \
    \   my @result = ( $arr[0] );\n    for(my $i = 1; $i -lt $k; ++$i) {\n       \
    \ my $min = max($result[$i-1], $result[$i]);\n        for(my $j = $i + 1; $j -lt\
    \ $k; ++$j) {\n            last if($arr[$j] <= $min);\n            $result[$j]\
    \ = $min;\n        }\n    }\n    return @result;\n}", "    my @ret;\n    my @max;\n\
    \    my $j = 0;", "    my(@ret) = ();\n    \n    foreach my $i (@$arr) {\n   \
    \     if ($i < 0) {\n            push (@ret, -$i);\n        }\n    }", "    my;\n\
    \    my $i;\n    my $max;\n    for ($i = 0; $i < $k; ++$i) {\n        push(@a,\
    \ $arr[$i] if ($arr[$i] > $max));\n    }\n    push(@a, $max) if ($max < 0);\n\
    \    return;\n}", "    my @m;\n    my $i;\n    for my $i (0 .. $#$arr) {\n   \
    \     $m[$i] = $arr[$i] if $m[$i] < $arr[$i];\n        $m[$i] = $arr[$i] if $m[$i]\
    \ > $arr[$i];\n    }\n    for my $i (0 .. $#$m) {\n        if ($i > 0) {\n   \
    \         $m[$i] = $m[$i] if $m[$i] > $m[$i - 1];\n            $m[$i] = $m[$i]\
    \ if $m[$i] > $m[$i - 1];\n        }\n        if ($i < $#$m) {\n            $m[$i]\
    \ = $m[$i] if $m[$i] > $m[$i + 1];\n            $m[$i] = $m[$i] if $m[$i] > $m[$i\
    \ + 1];\n        }\n    }\n    return @m[$k - 1 .. $#m];\n}\n</code>\n<|/ a dscore=3\
    \ tags=sorting,algorithm,perl |>\n<| a tags=sorting,algorithm,perl |>\nI tried\
    \ to follow the comments and write a simple code to demonstrate how to write it.\n\
    <code>\nuse strict;\nuse warnings;", "    my @max = (-1000, 1000) x $k;\n    for\
    \ (my $i = 0; $i <= $#$arr; $i++) {\n        for (my $j = 0; $j <= $#$max; $j++)\
    \ {\n            if ($max[$j] >= $arr[$i]) {\n                $max[$j] = $arr[$i];\n\
    \            }\n        }\n    }\n    for (my $j = 0; $j <= $#$max; $j++) {\n\
    \        $max[$j] = $max[$j] >= $arr[0] ? $max[$j] : -$max[$j];\n    }\n    return\
    \ @max;\n}", "    my;\n    my $i = 0;\n    while($i < $k) {\n        my $max =\
    \ pop(@$arr);\n        $max > $arr[-1] ? push(@$arr, $max) : $max;\n        $i++;\n\
    \    }\n    @$arr[@$k..$#arr];\n}", "    my @result;\n    my @tmp_arr;", "   \
    \ my @max_elem = ();\n    foreach my $i (0 .. $k - 1) {\n        my $max_value\
    \ = $arr[$i];\n        foreach my $j ($i + 1 .. $k) {\n            last if $arr[$i]\
    \ > $arr[$j];\n            $max_value = $arr[$j] if $arr[$i] < $arr[$j];\n   \
    \     }\n        push @max_elem, $max_value;\n    }\n    return @max_elem;\n}",
  "    my($i, $max) = 0, 0;\n    for($i = 0; $i <= $#{$arr}; $i++) {\n        if($arr[$i]\
    \ > $arr[$max]) {\n            $max = $i;\n        }\n    }\n    for($i = 0; $i\
    \ <= $k; $i++) {\n        $arr[$i] = $arr[$i] if $arr[$i] == $arr[$max];\n   \
    \ }\n    return $arr;\n}", "    my %max_hash;\n    my @new_arr = ();\n    foreach\
    \ my $num (@$arr) {\n        if (exists $max_hash{$num}) {\n            $max_hash{$num}++;\n\
    \        } else {\n            $max_hash{$num} = 1;\n        }\n    }\n    foreach\
    \ my $key (sort {$max_hash{$b} <=> $max_hash{$a}} keys %max_hash) {\n        if\
    \ ($k == $max_hash{$key}) {\n            push @new_arr, $key;\n        }\n   \
    \ }\n    return @new_arr;\n}", "    my $ret = @$arr[0..$k-1];\n    for (my $i\
    \ = 1; $i < $k; $i++) {\n        $ret = $ret->[0] > $arr[$i][0] && $ret->[0] <\
    \ $arr[$i]->[0]\n            ? @$ret\n            : $arr[$i];\n    }\n    @$ret\
    \ ? @$ret : $arr[$k];\n}", "    @$_ = ();\n    for(my $i = 0; $i < @$arr; $i++)\
    \ {\n        my $temp = $_[$i];\n        for(my $j = 0; $j < $k; $j++) {\n   \
    \         if($temp > $_[$j]) {\n                $temp = $_[$j];\n            }\n\
    \        }\n        push, $temp;\n    }\n}", "    my @max_numbers;\n    for my\
    \ $idx (0 .. $k - 1) {\n        $max_numbers[$idx] = $arr[$idx] if $arr[$idx]\
    \ > $max_numbers[$idx];\n    }\n    return @max_numbers;\n}", "    @$arr = sort\
    \ {$a <=> $b} @$arr;\n    my $ret = [];\n    for my $i (1..$k) {\n        if (@$arr\
    \ >= $i) {\n            push @$ret, shift @$arr;\n        }\n    }\n    return\
    \ @$ret;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks so much for the help. I'll see\
    \ if I can make this work :) Thanks again for the help.\n<|/ c |>\n<| c |>\nThe\
    \ question asks for O(n) solutions and this has O(n^2) complexity.\n<|/ c |>\n\
    <| a |>\nHere's another O(n) solution. I'm not going to claim this is better than\
    \ the previous two solutions, just because I'm a sucker for golfing :D\n<code>",
  "    if(!defined($arr) || !defined($k)) {\n        return ();\n    }\n    if(defined($k)\
    \ && $k > 0 && $k <= @$arr) {\n        return @$arr[0..$k-1];\n    }\n    if(defined($k)\
    \ && $k < 0 && $k >= @$arr) {\n        return @$arr[-abs($k)..-1];\n    }\n  \
    \  return @$arr;\n}", "    my @result;\n    for (my $i = 0; $i < @$arr; $i++)\
    \ {\n        push(@result, $k > $i ? $arr[$i] : ($arr[$i] > $arr[$i] ? $arr[$i]\
    \ : $arr[$i]));\n    }\n    return @result;\n}", "    my $result;\n    for(my\
    \ $i = 0; $i < $k; $i++) {\n        $result[$i] = $arr[$i] if $arr[$i] > $result[$i];\n\
    \        $result[$i] = $arr[$i] if $arr[$i] <= $result[$i];\n    }\n    return\
    \ @$result;\n}", "    if ($k <= 0) {\n        bless [], 'Solution';\n    } else\
    \ {\n        my $min = @$arr;\n        my $max = $arr[$k - 1];\n        my $count\
    \ = 0;\n        while (@$arr > 1) {\n            my $m = $min + $count - $k;\n\
    \            my $m2 = $max - $count + 1;\n            if ($m > $m2) {\n      \
    \          $min = $m;\n                $max -= $count;\n                $count\
    \ = 1;\n            } elsif ($m2 < $m) {\n                $max = $m2;\n      \
    \          $min -= $count;\n                $count = 1;\n            } else {\n\
    \                $min = $m;\n                $max = $m2;\n                $count++;\n\
    \            }\n        }\n        bless [map $_ - $max, @$arr], \"Solution\"\
    ;\n    }\n}", "    my $i = 0;\n    my @max;\n    foreach my $v (@$arr) {\n   \
    \     push (@max, $v) if $i < $k;\n        $max[$i] = $v if $i < $k;\n       \
    \ $i++;\n    }\n    return @max;\n}", '    my(@max_list) = ();', "    $k = min($k,\
    \ @$arr);\n    my @max = ($arr[0]); # initialize with a single value\n    for(my\
    \ $i = 1; $i <= $k; ++$i) {\n        $max[$i] = $arr[$i] if $arr[$i] > $max[$i];\n\
    \    }\n    return @max;\n}", '    my @temp;', "    my @arr;\n    for (my $i =\
    \ 0; $i < $k; $i++) {\n        push @arr, $arr[$i] if $arr[$i] > 0;\n    }\n \
    \   return @arr;\n}", "    my $count = 0;\n    my %hash;\n    my @res;\n    $k\
    \ = 0 unless $k;\n    foreach my $item (@$arr) {\n        $hash{ $item }++;\n\
    \        $count++;\n    }\n    foreach my $key (sort {$hash{$b} <=> $hash{$a}}\
    \ keys %hash) {\n        if ($k <= $count) {\n            push @res, map {$_->[0]};\n\
    \            splice(@res, $k, 1);\n            last;\n        }\n        if ($hash{$key}\
    \ == $count) {\n            push @res, map {$_->[0]};\n            splice(@res,\
    \ $k, 1);\n        }\n    }\n    return @res;\n}", "    my @new_arr = ();\n  \
    \  my $cur = pop($arr);\n    for(my $i = 0; $i < $k; $i++) {\n        if($cur\
    \ > 0) {\n            $new_arr[$i] = $cur;\n            $cur = pop($arr);\n  \
    \      } else {\n            $cur = $new_arr[$i] = $arr[$i];\n        }\n    }\n\
    \    return @new_arr;\n}", "    return [] if $k < 0;\n    my @max_k = ();", '    my
    @r;', "    # Write your code here.\n}", "    $k += 0 # k is positive\n    my $max\
    \ = $arr[0];\n    my %maxs = ();\n    foreach my $x (@$arr) {\n        my $key\
    \ = $x - $max;\n        $maxs{$key} = $x if !defined($maxs{$key});\n        $max\
    \ = $x;\n    }\n    @$arr = sort {-$maxs{$a} <=> -$maxs{$b}} keys %maxs;\n   \
    \ return @$arr[0..$k-1];\n}", "    my @ret;\n    my $n = @$arr;\n    for my $i\
    \ (0..$k - 1) {\n        push(@ret, max map { $arr->[$_] } 0..$n - $i);\n    }\n\
    \    return wantarray ? @ret : $ret[0];\n}", "    my @ret = ();\n    # Find the\
    \ first element which is greater than or equal to k\n    for (my $i = 0; $i <;\
    \ $i++) {\n        if ($arr[$i] >= $k) {\n            push @ret, $arr[$i];\n \
    \       }\n    }\n    # Find the maximum number in remaining array elements\n\
    \    for (my $i = $k + 1; $i < @$arr; $i++) {\n        if ($arr[$i] > $k) {\n\
    \            push @ret, $arr[$i];\n        }\n    }\n    return @ret;\n}", " \
    \   my @max;\n    my %max;\n    my $maxElement = 0;\n    my $i;", "    my $n =\
    \ $arr->[0];\n    my @maximum = ();\n    for (my $i = 1; $i < $n; $i++) {\n  \
    \      push(@maximum, $arr->[$i]);\n        if ($maximum->[$i] > $arr->[$i]) {\n\
    \            $maximum->[$i] = $arr->[$i];\n        }\n    }\n    if ($k > @maximum)\
    \ {\n        return [];\n    }\n    splice(@maximum, $k, @maximum);\n    return\
    \ @maximum;\n}", "    if ($k == 0) {\n        return $arr;\n    }\n    if (@$arr\
    \ < 1) {\n        die \"The length of the array must be greater than 0\";\n  \
    \  }\n    if (@$arr % 2 != 0) {\n        die \"The length of the array must be\
    \ even\";\n    }\n    my $max_ele = $arr[0];\n    for my $i (1 .. $#arr) {\n \
    \       if ($arr[$i] > $max_ele) {\n            $max_ele = $arr[$i];\n       \
    \ }\n    }\n    my @max_arr = @$arr;\n    for my $i (1 .. $k-1) {\n        if\
    \ ($arr[$i] > $max_ele) {\n            shift @$arr;\n            pop @max_arr;\n\
    \        }\n        else {\n            push @$arr, $max_ele;\n            push\
    \ @max_arr, $max_ele;\n        }\n    }\n    shift @$arr;\n    return @max_arr;\n\
    }", "    my $length = $#{$arr};\n    my @max_element;\n    my $k_index;\n    my\
    \ @tmp;\n    \n    for (my $i = 0; $i < $length; $i++) {\n        if ($arr[$i]\
    \ > $max_element[$k_index]) {\n            $k_index = $i;\n        }\n    }",
  "    my $i = 0;\n    my @max;\n    my @result = ();\n    foreach my $e (@$arr) {\n\
    \        if ($k <= $i) {\n            push @max, $e;\n        }\n        elsif\
    \ ($e > $max[$i - 1]) {\n            push @max, $e;\n        }\n        $i++;\n\
    \    }\n    push @result, @max;\n    return @result;\n}", "    my @result;\n \
    \   if ($k == 0) {\n        @result = @$arr;\n    } else {\n        for (my $i\
    \ = 0; $i <= $k - 1 && $i < @$arr; $i++) {\n            if ($arr[$i] > $arr[$i\
    \ - 1]) {\n                push(@result, $arr[$i - 1]);\n            }\n     \
    \   }\n        push(@result, $arr[$k - 1]);\n    }\n    return @result;\n}", " \
    \   $k = 1 if !defined $k;\n    my $result;\n    $result = $arr[$k] if $k <= $#{$arr};\n\
    \    for my $i (1..$k-1) {\n        $result = $arr[$i] if $arr[$i] > $result;\n\
    \    }\n    return $result;\n}", "    my @ret = ();\n    my $cur_max = 0;\n  \
    \  $cur_max = $arr[0];\n    for my $i(1..$#arr) {\n        if ($arr[$i] > $cur_max)\
    \ {\n            $cur_max = $arr[$i];\n        }\n    }\n    push(@ret, $cur_max);\n\
    \    while ($k > 0) {\n        $k--;\n        for my $i(1..$#arr) {\n        \
    \    if ($arr[$i] > $cur_max) {\n                $cur_max = $arr[$i];\n      \
    \      }\n        }\n        push(@ret, $cur_max);\n    }\n    return @ret;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nFor a slight improvement, just swap the first line\
    \ with: my = (map { $arr[$_] => 1 } 0..$#arr);\n<|/ c |>\n<| c |>\nIf `@arr` is\
    \ empty, the `map` will go into an infinite loop!\n<|/ c |>\n<| c |>\nIf you have\
    \ a `@arr` of size zero, your program will blow up because you're trying to reference\
    \ an element at `$#arr` which is undefined.\n<|/ c |>\n<| c |>\nThat's right.\
    \ Sorry for that. It works well with empty arrays. Thx :)\n<|/ c |>\n<| c |>\n\
    This is an excellent answer. Can you please tell me how this code runs in O(n)\
    \ time or O(nlogn) time.\n<|/ c |>\n<| a tags=max,arrays,perl dscore=4 |>\nSlightly\
    \ more concise version:\n<code>\nuse warnings;\nuse strict;\nuse List::Util qw(reduce);",
  "    my $result = ();\n    my @arr;\n    push(@arr, $arr->[0]) unless (@$arr > 1);\n\
    \    push(@arr, $arr->[-1]) unless (@$arr > 1);\n    push(@arr, $arr->[scalar(@$arr)\
    \ - 1]) unless (@$arr > 1);\n    $result = pop @arr;\n    for (my $i = 1; $i <=\
    \ $k; $i++) {\n        if ($arr->[$i] > $arr->[$i - 1]) {\n            push(@arr,\
    \ $arr->[$i]);\n        }\n        else {\n            pop(@arr);\n          \
    \  push(@arr, $arr->[$i - 1]);\n        }\n    }\n    return @arr;\n}", "    my\
    \ $ret = [];\n    my $size = @$arr;\n    my $max = 0;\n    my $index = 0;\n  \
    \  foreach my $val (@$arr) {\n        ++$index;\n        $max >= $val or $max\
    \ = $val;\n        $ret .= $arr[$index - $k] if $index - $k <= 0;\n    }\n   \
    \ return $ret if $max == $size;\n    my @temp = @$arr[0..$k - 1];\n    @temp =\
    \ $temp if $k > $max - $temp[0];\n    return $temp;\n}\n</code>\n<|/ a tags=sorting,perl,arrays\
    \ |>\n<| c |>\nI like the idea, but it has a lot of issues including `@arr[0..$k-1]`.\
    \ What if `@arr` has less than `k` elements? Then that last line will evaluate\
    \ to `undef`. Why not just `return sort { $a <=> $b } $arr[0..$k-1];`? And then\
    \ you don't even have to bother with the `@temp` variable.\n<|/ c |>\n<| c |>\n\
    Also - `@arr[0..$k-1]` will evaluate to `undef` if it has less than `k` elements.\
    \ I think you mean `@arr[0..$k-1] //= []`, which evaluates to an empty array if\
    \ `@arr` has less than `k` elements. But that could also be written as `@arr[0..$k-1]\
    \ //= []`, which has the advantage of avoiding a \"falsely\" empty array being\
    \ created - a common bug I see in code where an empty array is returned by a function\
    \ that is meant to return an array but is given an empty array.\n<|/ c |>\n<|\
    \ c |>\nThanks for your feedback, I updated my answer to include these points.\
    \ Yeah, you're right, I meant to say `@arr[0..$k-1] //= []`; it's hard to tell\
    \ what the code is doing without seeing it.\n<|/ c |>\n<| c |>\nAlso, as I said\
    \ in my comment above, `@arr[0..$k-1] //= []` has the advantage of avoiding a\
    \ \"falsely\" empty array being created - a common bug I see in code where an\
    \ empty array is returned by a function that is meant to return an array but is\
    \ given an empty array.\n<|/ c |>\n<| c |>\nAlso - `@arr[0..$k-1]` will evaluate\
    \ to `undef` if it has less than `k` elements. I think you mean `@arr[0..$", " \
    \   \n    return wantarray ? @{ $arr } : @$arr[$k];\n}", "    my(@max_arr, $max_arr_len)\
    \ = ();\n    \n    foreach my $i (0 .. $k - 1) {\n        $max_arr_len = 0 unless\
    \ $max_arr_len;\n        push(@max_arr, $arr[($i + $max_arr_len) % $#arr]);\n\
    \    }\n    return @max_arr;\n}", "    my $n = @$arr;\n    my $max_value = $arr->[0];",
  "    my @sorted;\n    push @sorted, $arr[0]; # Push the smallest element to the\
    \ top of the stack.\n    $k = 1 unless defined $k;\n    for (my $i = 1;$i < $k;$i++)\
    \ {\n        if ($arr[$i] > $sorted[$k-1]) {\n            push @sorted, $arr[$i];\n\
    \        }\n    }\n    return @sorted;\n}", "    my($i, $max, $max_k, $min, $min_k)\
    \ = (0, 0);\n    $k++ while $k > $#$arr; # make sure $k <= len(arr)\n    while\
    \ (my ($i, $val) = each %$arr) {\n        $max = $val if $val > $max;\n      \
    \  $max_k = $k if $val > $max and $val < $max_k;\n        $min = $val if $val\
    \ < $min;\n        $min_k = $k if $val < $min and $val > $min_k;\n    }\n    return\
    \ [$max, $max_k] if $max_k > $k;\n    return [$min, $min_k] if $min_k > $k;\n\
    \    return $arr;\n}", "    my @max;\n    for (my $i=0; $i<=$#{$arr}; $i++) {\n\
    \        push(@max, $arr[$i] if $i < $k);\n    }\n    return @max;\n}", "    @arr\
    \ = @$arr;\n    my $l = @arr;\n    my @a = ();\n    for(my $i = 0;$i<$l;$i++)\
    \ {\n        push(@a, $arr[$i]);\n    }\n    my $max = pop @a;\n    for(my $i\
    \ = 0;$i<$k;$i++) {\n        if($a[$i] > $max) {\n            $max = $a[$i];\n\
    \        }\n    }\n    return @a;\n}", "    my @max = (undef);\n    my @tmp;\n\
    \    \n    $k <= $#$arr or return (undef);\n    \n    foreach my $i ( 0 .. $#$arr\
    \ ) {\n        my $tmp = $arr[$i];\n        $tmp > $max[$i] or $max[$i] = $tmp;\n\
    \    }\n    \n    @max;\n}", "    my @out;\n    my @arr = (reverse @_);\n    my\
    \ $max;\n    my $i;\n    for ($k-- > 0 && $k < @arr) {\n        $max = pop @arr;\n\
    \        for ($i = 0; $i < $k; $i++) {\n            if ($arr[$i] >= $max) {\n\
    \                $max = $arr[$i];\n            }\n        }\n        push @out,\
    \ $max;\n    }\n    return @out;\n}", "    my@$arr = @$arr;\n    my $i = 0;\n\
    \    for (; $i < $k; ++$i) {\n        $arr[$i] = $arr[$i] > $arr[$i-1] ? $arr[$i]\
    \ : $arr[$i-1];\n    }\n    return @$arr;\n}\n</code>\n<|/ a tags=arrays,perl,sorting\
    \ dscore=0 |>\n<| a dscore=0 |>\nHere is my solution using an O(n) sort, and using\
    \ two O(n) sorts.  This can easily be adapted for an array with duplicate values.\n\
    <code>", "    my ($i, $max) = (0, -1);\n    foreach (@$arr) {\n        if ($max\
    \ < $_ ) {\n            $max = $_;\n        }\n        elsif ($max > $_ ) {\n\
    \            $max = $_;\n        }\n    }\n    my $i = $max - 1;\n    while ($i\
    \ >= 0) {\n        pop @$arr;\n        $i -= 1;\n    }\n    return @$arr;\n}",
  "    return sort {$arr[$a] > $arr[$b] ? $a : $b} @$arr[0..$k];\n}", "    if (@$arr\
    \ <= 1) {\n        return $arr;\n    }\n    my @new_arr;\n    my $pos = 0;\n \
    \   my ($max, $max_pos) = (0, 0);\n    foreach my $e (@$arr) {\n        if ($e\
    \ > $max) {\n            $max = $e;\n            $max_pos = $pos;\n        }\n\
    \        $pos++;\n    }\n    $new_arr[$max_pos] = $max;\n    foreach my $e (@$arr)\
    \ {\n        if ($e < $max and $e > $new_arr[0]) {\n            push (@new_arr,\
    \ $e);\n        }\n    }\n    return @new_arr;\n}", "    my @new_list = ();\n\
    \    my $max = 0;\n    foreach (@{$arr}) {\n        if ($new_list[$_] > $max)\
    \ {\n            $max = $new_list[$_];\n        }\n        $new_list[$_] += $k;\n\
    \    }\n    return \\@new_list;\n}", "    my @ans;\n    my ($max, $max_idx) =\
    \ (0, 0);\n    my $i = 0;\n    my $j = 0;\n    foreach my $num (@$arr) {\n   \
    \     ++$i;\n        if ($i == $k) {\n            $ans[$j++] = $num;\n       \
    \     $i = 0; # reset index\n        }\n        else {\n            if ($num >\
    \ $max) {\n                $ans[$j++] = $max;\n                $max = $num;\n\
    \                $max_idx = $j;\n            }\n            elsif ($num == $max)\
    \ {\n                $ans[$j++] = $num;\n            }\n        }\n    }\n   \
    \ $ans[$j++] = $max;\n    my $ret_arr = \\@ans;\n    ++$j; # last number\n   \
    \ while ($j > $k) {\n        splice(@$ret_arr, $k - $j, 1);\n        --$j;\n \
    \   }\n    return $ret_arr;\n}", "    $k = _int($k) if $k < 0 || @_ == 1;\n  \
    \  return map {\n      my $i = $_;\n      while ($i < 0 && $i >= -$_) {\n    \
    \    $i += $_;\n      }\n      $i;\n    }\n      sort {\n        $a <=> $b;\n\
    \      } @_[0..$k-1];\n}", "    $k += 0;\n    my(@ret) = ();\n    foreach $i (@$arr)\
    \ {\n        push(@ret, $i) if $i > $ret[$k];\n        $k--;\n    }\n    return\
    \ @ret;\n}", "    @ary = ();\n    @ary = sort {$a <=> $b} @$arr;\n    my $max\
    \ = @ary - $k;\n    for(my $i = 0; $i < $max; $i++) {\n        push (@ary, $ary[$i]);\n\
    \    }\n    return @ary;\n}", "    my @result;\n    my $i = @$arr;", "    $k <=\
    \ 0 or $k >= scalar @$arr ? return : @$arr = @$arr[0..$k];\n    my $max = 0;\n\
    \    my @result;\n    \n    for (@$arr) {\n        if ($max < $_ ) {\n       \
    \     $max = $_;\n        }\n    }\n    \n    for (@$arr) {\n        $_ > $max\
    \ ? push @result, $max++ : $_;\n    }\n    \n    return @result;\n}", "    return\
    \ unless @$arr > $k;\n    my $max = $arr[$k-1];\n    $k--;\n    for (my $i = $k;\
    \ $i >=0; $i--) {\n        $max = max $max, $arr[$i];\n    }\n    return @$arr[$k..$#arr]\
    \ if $max > $arr[$k];\n    return $max;\n}", "    \n    # base case\n    if($k\
    \ <= 0) \n    {\n        $arr[0]\n    }\n    \n    # recursive case\n    else\n\
    \    {\n        if($arr[$k - 1] > $arr[$k])\n        {\n            $arr[$k -\
    \ 1]\n        }\n        else\n        {\n            $arr[$k]\n        }\n  \
    \  }\n}", "    $k--; # We count from 0, so subtract 1 to get the real number of\
    \ elements.\n    \n    my @res;\n    for (my $i=0; $i<$k; $i++) {\n        push\
    \ @res, max @$arr[$i..$i];\n    }\n    \n    return @res;\n}", "    my @sorted\
    \ = ();\n    my $largest = 0;\n    my $size = scalar(@$arr);\n    for (my $i =\
    \ 0; $i < $size; $i++) {\n        push @sorted, $arr->[$i];\n    }\n    $size\
    \ = scalar(@$arr);\n    my $size2 = scalar(@$sorted);\n    if ($k <= $size) {\n\
    \        my $j = 0;\n        my @knums = ();\n        for (my $i = 0; $i < $size;\
    \ $i++) {\n            my $new = 0;\n            my $new2 = 0;\n            my\
    \ $kn = $arr->[$i];\n            for (my $j = 0; $j < $size2; $j++) {\n      \
    \          $new = $kn if $knums[$j] lt $new;\n                $new2 = $j if $knums[$j]\
    \ lt $new2;\n            }\n            push @knums, $new;\n        }\n      \
    \  return @knums;\n    }\n    for my $i (0..$size-1) {\n        my $j = 0;\n \
    \       my $new2 = 0;\n        my $kn = $arr->[$i];\n        for (my $j = 0; $j\
    \ < $size2; $j++) {\n            $new2 = $j if $knums[$j] lt $new2;\n        }\n\
    \        push @sorted, $knums[$new2];\n    }\n    return @sorted;\n}", "    my\
    \ $n = @$arr;\n    my $result = [];\n    for (my $i = 0; $i <= $n; $i++) {\n \
    \       for (my $j = 0; $j <= $k; $j++) {\n            if ($arr[$i] >= $arr[$j])\
    \ {\n                $arr[$i] = $arr[$j];\n            }\n        }\n        push(@$result,\
    \ $arr[$i]);\n    }\n    @$result = sort {$a <=> $b} @$result;\n    return @$result;\n\
    }", "    my($i, $max);\n    for(my $j = 0; $j < $k; ++$j) {\n        if($arr[$j]\
    \ > $max) {\n            $max = $arr[$j];\n        }\n    }\n    $max -= 1;\n\
    \    for(my $j = 0; $j < $k; ++$j) {\n        if($arr[$j] > $max) {\n        \
    \    $arr[$j] = $max;\n        }\n    }\n    return $arr;\n}", "    my $len =\
    \ @$arr;\n    my $min = -$len;\n    my @ret;\n    \n    my @temp;\n    \n    foreach\
    \ my $i (0 .. $len - $k + 1) {\n        my $tmp = 0;\n        for (my $j = i;\
    \ $j < $len && $j + $k - $i < $len; $j++) {\n            $tmp = $tmp > $arr[$j]\
    \ ? $tmp : $arr[$j];\n        }\n        $ret[$i] = $tmp;\n        \n        for\
    \ (my $j = 0; $j < $k - $i; $j++) {\n            push @temp, $arr[$j + $i];\n\
    \        }\n    }\n    \n    foreach my $i (0 .. $len - $k + 1) {\n        push\
    \ @ret, $ret[$i] if $ret[$i] > $min;\n        $min = max $min, $ret[$i] if $ret[$i]\
    \ > $min;\n    }\n    \n    return @ret;\n}", "    $k += 0 unless ($k =~ /^\\\
    +?\\d+$/);\n    $arr[$k] //= 0;\n    my(@max) = (0);\n    for my $i (0 .. $#arr)\
    \ {\n        push(@max, $arr[$i] if ($arr[$i] > $max[$i]);\n    }\n    return\
    \ @max;\n}", "    return @$arr[0..$k-1] if @$arr > $k;\n    my(@l) = @$arr[0..$k-1];\n\
    \    $l[$k] = -$l[$k] if @$arr > $k;\n    return @l;\n}", "    my @ret_arr = ();\n\
    \    my @counter = ();\n    my $max = 0;\n    my $index = @$arr;\n    \n    for\
    \ (my $i = 0; $i < $index; $i++) {\n        push(@counter, $arr->[$i]);\n    }\n\
    \    \n    for ($k = 0; $k < $index; $k++) {\n        $max = $arr->[$k] if $counter[$k]\
    \ > $max;\n    }\n    \n    for ($k = 0; $k < $index; $k++) {\n        if ($counter[$k]\
    \ > $max) {\n            $max = $counter[$k];\n            $index = $k;\n    \
    \    }\n    }\n    \n    for ($k = 0; $k < $index; $k++) {\n        push(@ret_arr,\
    \ $arr->[$k]);\n    }\n    return @ret_arr;\n}", "    $k <= 0 or $k >= @$arr or\
    \ $k eq 0;\n    return @$arr if $k;\n    my $m = 0;\n    my $n = @$arr - 1;\n\
    \    my $ret = $arr[$k];\n    \n    for ($m + 1; $m <= $n; ++$m) {\n        $ret\
    \ = $arr[$m] > $ret ? $arr[$m] : $ret;\n    }\n    \n    return $ret;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat is **O(N)**, where N is the length of the array. Though\
    \ it only uses two indices and does not use nested loops. It is very similar to\
    \ the solution of *LeetCode* where he has `O(N)` time complexity but has O(1)\
    \ space complexity.\n<|/ c |>\n<| a tags=perl,arrays |>\nHere is my solution\n\
    <code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    my @sorted_arr =\
    \ ();\n    # O(n^2)\n    for(my $i = 0;$i < @$arr;$i++) {\n        for(my $j =\
    \ $i;$j < @$arr;$j++) {\n            my $comp = $arr->[$i] > $arr->[$j] ? 1 :\
    \ 0;\n            if($comp == 1) {\n                push(@sorted_arr, $arr->[$i]);\n\
    \            }\n        }\n    }\n    return @sorted_arr;\n}", "    my @result;\n\
    \    for(my $i = 0; $i < @$arr; ++$i) {\n        push(@result, $arr->[$i] if $i\
    \ < $k);\n    }\n    return @result;\n}", "    if (@$arr == 0 || $k <= 0) {\n\
    \        return;\n    }\n    my $m = $k;\n    my $max_idx = -1;\n    my $max_value\
    \ = $arr[0];\n    for (my $i = 1; $i < $#arr; ++$i) {\n        if ($arr[$i] >=\
    \ $max_value) {\n            ++$m;\n        }\n        if ($m == $k || $arr[$i]\
    \ > $max_value) {\n            $max_value = $arr[$i];\n            $max_idx =\
    \ $i;\n        }\n    }\n    $max_idx += 1;\n    for (; $m > $k; ++$m) {\n   \
    \     $arr[$max_idx] = $arr[$max_idx] - 1;\n    }\n    return @$arr[$k..$#$arr];\n\
    }", "    my @res = ();\n    my $j = 0;\n    my $max = 0;\n    my $min = $arr[0];\n\
    \    while(@$arr and $j < $k) {\n        my $tmp = shift @$arr;\n        if($tmp\
    \ > $max) {\n            $max = $tmp;\n        }\n        if($tmp < $min) {\n\
    \            $min = $tmp;\n        }\n        $j++;\n    }\n    for(; $j < $k;\
    \ $j++) {\n        push @res, shift @$arr;\n    }\n    return @res;\n}", "   \
    \ my @m;\n    my $i = 0;\n    while($i < $k) {\n        my $v = $arr[$i];\n  \
    \      while($i < $k and $v gt $arr[$i]) {\n            ++$i;\n        }\n   \
    \     push @m, $v;\n    }\n    return @m;\n}\n</code>\n<|/ a |>\n<| c |>\n`-3\
    \ > -4`? It's not like that in real life.\n<|/ c |>\n<| c |>\nI think it is! :)\
    \ I took the array from a question of LeetCode and it seems to work. I'll modify\
    \ my answer if he wants negative numbers.\n<|/ c |>\n<| a tags=sorting,algorithm\
    \ |>\nSince you mention C++, I will answer using C++. I'll leave the solution\
    \ for others to read.\n<code>", "    my @result;\n    my %max = ();\n    \n  \
    \  # Sort array on descending order\n    my $sorted = sort {\n        ($a cmp\
    \ $b) ? ($b cmp $a) : 1\n    } @$arr;", "    my @res;\n    my $cur_max = -1;\n\
    \    my $index;\n    for (my $i = 0; $i < $k; $i++) {\n        if ($cur_max <\
    \ $arr[$i]) {\n            $cur_max = $arr[$i];\n            $index = $i;\n  \
    \      }\n    }\n    push(@res, $arr[$index]);\n    my $count = $k;\n    while\
    \ ($count > 0) {\n        $count--;\n        my $new_max = -1;\n        for (my\
    \ $i = $index; $i < $k; $i++) {\n            if ($new_max < $arr[$i]) {\n    \
    \            $new_max = $arr[$i];\n            }\n        }\n        if ($new_max\
    \ < 0) {\n            last LOOP;\n        }\n        push(@res, $new_max);\n \
    \   }\n    return @res;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis looks like\
    \ some kind of homework. Can you post the code you wrote to solve this?\n<|/ c\
    \ |>\n<| c |>\nHe did exactly that: \"I tried to implement this using binary search\
    \ tree, but I can't figure out a way to get the left and right nodes of each node\
    \ in the tree\"\n<|/ c |>\n<| c |>\nOh I didn't see that line of the question!\
    \ Sorry, my bad. I'll leave the answer here because I think it is important to\
    \ understand the process behind it.\n<|/ c |>\n<| a tags=binary-tree,algorithm,language-agnostic\
    \ |>\nHere is another solution in Java\n<code>\npublic class BinaryTree {\n  private\
    \ Node root;", "    my(@max) = (0, @arr);\n    while($k != 0) {\n        my ($i,\
    \ $j) = @{$max[0]};\n        $k --;\n        while($j >= 0 &&\n            @{$max[$j]}\
    \ > $arr[$i] &&\n            $max[$j] >= 0) {\n            $max[$j + 1] = $max[$j];\n\
    \            $max[$j] = $i;\n            $j = $max[$j + 1];\n        }\n    }\n\
    \    return @max;\n}", "    my @res;\n    my $j;\n    for (my $i = 0; $i < $k;\
    \ $i++) {\n        push(@res, max($arr[$i]));\n    }\n    $k--;\n    for (my $i\
    \ = 0; $i < $k; $i++) {\n        $j = scalar;\n        for(my $j = 0; $j < $j;\
    \ $j++) {\n            push(@res, max($arr[$i], $arr[$j]));\n        }\n    }\n\
    \    return @res;\n}", "    $k += 0;\n    return sort { $a <=> $b } @$arr[0..$k];\n\
    }", "    my $result = [];\n    $k = 0 unless $k;\n    my $n = 0;\n    my $i;\n\
    \    for ($i = @$arr; $i >= 0; $i--) {\n        push (@$result, $arr->[$i] if\
    \ $n < $k);\n        $n++;\n    }\n    @$result = sort {$a <=> $b} @$result;\n\
    \    @$result\n}", "    my @res;\n    my $count = 0;\n    my $max_val = -1;\n\
    \    my $idx = 0;\n    while(@$arr) {\n        $count++;\n        if($max_val\
    \ > $arr[0]) {\n            $max_val = $arr[0];\n            $idx = 1;\n     \
    \   } elsif($count > $k) {\n            push @$res, @$arr[0..$k-1];\n        \
    \    delete @$arr[0..$k-1];\n        } else {\n            push @$res, @$arr[0..$k];\n\
    \        }\n        shift @$arr;\n    }\n    if(@$arr) {\n        push @$res,\
    \ @$arr;\n    }\n    return @res;\n}", "    my %max = ();\n    for (my $i = 0;\
    \ $i < $k; $i++) {\n        my $value = $arr[$i];\n        if (exists $max{$value})\
    \ {\n            $max{$value}++;\n        } else {\n            $max{$value} =\
    \ 1;\n        }\n    }\n    my $result = array();\n    for (my $i = 0; $i < $k;\
    \ $i++) {\n        my $value = $arr[$i];\n        if ($max{$value} == 1) {\n \
    \           $result[$i] = $value;\n        }\n    }\n    return @$result;\n}",
  "    my @arr = @$arr;\n    my @res;\n    \n    my $max_idx = -1;\n    my $max_val\
    \ = -1;\n    for my $i (0 .. $#arr) {\n        my $tmp = $arr[$i];\n        if\
    \ ($tmp > $max_val) {\n            $max_idx = $i;\n            $max_val = $tmp;\n\
    \        }\n    }\n    \n    $res[$max_idx] = $max_val;\n    \n    for my $i ($max_idx\
    \ + 1 .. $#arr) {\n        if ($arr[$i] > $max_val) {\n            $res[$i] =\
    \ $arr[$i];\n        }\n    }\n    \n    return @res;\n}", "    my(@max_value)\
    \ = ();\n    my($max);\n    \n    $k++ while $k > $#arr;\n    \n    foreach my\
    \ $index (0..$#arr) {\n        if ( $max < $arr[$index] ) {\n            $max\
    \ = $arr[$index];\n        }\n    }\n    \n    foreach my $index (0..$#arr) {\n\
    \        if ( $arr[$index] == $max ) {\n            push(@max_value, $arr[$index]);\n\
    \        }\n    }\n    \n    return @max_value;\n}\n</cell>\n<cell>\n%%time",
  "    @_ = (1) x (@{$arr} <= $k ? @{$arr} : $k);\n}", '    my(@max) = ();', "   \
    \ my @max;\n    \n    for(my $i = 0; $i < @$arr; $i++) {\n        if($max[0] >\
    \ $arr->[$i]) {\n            $max[0] = $arr->[$i];\n            $max[1] = $i;\n\
    \        }\n    }\n    \n    if($k > @max) {\n        $k = @max;\n    }\n    \n\
    \    my @sub = ();\n    for(my $i = 0; $i < $k; $i++) {\n        push(@sub, $arr->[$max[1]]);\n\
    \        $max[1] = $max[1] + 1;\n    }\n    \n    return @sub;\n}", "    if (@$arr\
    \ >= $k) {\n        return ($arr[0]) x ($k);\n    }\n    my $maximum = 0;\n  \
    \  my $index = 0;\n    foreach my $i (0 .. $#$arr) {\n        if ($maximum < $arr[$i])\
    \ {\n            $maximum = $arr[$i];\n            $index = $i;\n        }\n \
    \       if ($maximum == $arr[$i]) {\n            last if (++$index > $k);\n  \
    \      }\n    }\n    return @$arr[0..$index];\n}\n</cell>\n<cell>\nprint maximum([-3,\
    \ -4, 5], 3)\n</cell>\n<cell>\nprint maximum([4, -4, 4], 2)\n</cell>\n<cell>\n\
    print maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n</cell>\n<text>\nQuestion 7", "  \
    \  my $l = length($arr);\n    if ($l > $k) {\n        die \"Length is too large\"\
    ;\n    }\n    my @result;\n    my $curr = $arr[0];\n    \n    for(my $i = 1; $i\
    \ < $l; $i++) {\n        if ($arr[$i] > $curr) {\n            $curr = $arr[$i];\n\
    \        }\n    }\n    \n    for (my $i = $l; $i > $k; $i--) {\n        if ($arr[$i]\
    \ > $curr) {\n            splice @result, 0, 0;\n        }\n        \n       \
    \ push @result, $arr[$i];\n    }\n    \n    return @result;\n}\n</cell>\n<cell>\n\
    def maximum3(arr,k):\n    maximum3 = lambda arr,k: sorted(arr, key=lambda x: (-1\
    \ if (x < 0) else 0, x))[:k]\n    maximum3(arr,k)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 1)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 2)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 3)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 4)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 5)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 6)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 7)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 8)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 9)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 10)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 11)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 12)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 13)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 14)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 15)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1], 16)\n</cell>\n<cell>\nmaximum3([-3,2,1,2,-1,-2,1],\
    \ 17)\n</cell>\n<cell>\n", "    my $len = @$arr;\n    my $k1 = $k;\n    $k1 =\
    \ -1 if $k1 < 0;\n    $k1 = $len if $k1 > $len;\n    my @ans = ();\n    for (my\
    \ $i = 0; $i < $k1; $i++) {\n        push (@ans, $arr->[$i] if $arr->[$i] > 0);\n\
    \    }\n    push (@ans, $arr->[$k1]) if $k1 < $len;\n    @ans = reverse @ans;\n\
    \    my $max = @ans;\n    $max -= 1 if $k1 == 0;\n    for (my $i = $k1 + 1; $i\
    \ < $len; $i++) {\n        $arr->[$i] = $arr->[$i] - $arr->[$i-1] if $i != 0 &&\
    \ $arr->[$i] > 0;\n    }\n    return @ans if $max == 0;\n    return @ans if $max\
    \ == 1;\n    return @ans + [@ans[0]];\n}", "    # Base case\n    return () if\
    \ $k < 0;\n    return @$arr if $k == 0;\n    # Divide into two equal halves and\
    \ recurse\n    return max($maximum($arr[0..$k / 2], $k / 2),\n               $maximum($arr[($k\
    \ / 2)..$#$arr], $k / 2));\n}", "    @arr > $k || return @arr;\n    my($i) = 0;\n\
    \    my(@sorted);\n    for(@arr) {\n        push, $_ if ++$i == $k;\n    }\n \
    \   bless \\@sorted, 'Array';\n}", "    my $ret = [];\n    my $i = 0;", "    my\
    \ @result;\n    my $len = @$arr;\n    \n    # Initialize a temporary array to\
    \ store maxima\n    for (my $i = 0; $i < $k; $i++) {\n        push @result, 0;\n\
    \    }\n    \n    # Store elements in temporary array\n    for (my $i = 0; $i\
    \ < $len; $i++) {\n        if ($arr[$i] >= $result[$i]) {\n            $result[$i]\
    \ = $arr[$i];\n        }\n    }\n    \n    # Sort the temporary array and store\
    \ maxima\n    for (my $i = 0; $i < $k; $i++) {\n        $result[$i] = $arr[$i]\
    \ if $arr[$i] > $result[$i];\n    }\n    \n    # Return sorted array and maxima\n\
    \    return @result;\n}", "    my $max_array = [];\n    \n    while(my($i, $val)\
    \ = ( $#{$arr}, $arr->[$#{$arr}-1] ) ){\n        $max_array->[$i] = $val if $val\
    \ > $max_array->[$i];\n    }\n    return $max_array if $k == 1;\n    \n    my\
    \ $j = 0;\n    \n    while( $j < $k ){\n        $max_array->[$j] = $max_array->[$j-1]\
    \ if $j > 0 && $max_array->[$j-1] > $max_array->[$j];\n        $j++;\n    }\n\
    \    \n    return $max_array;\n}", "    return unless @$arr;\n    $k = 0 unless\
    \ defined $k;\n    @$arr = sort { $a <=> $b } @$arr;\n    $k = 0 unless defined\
    \ $k;\n    @$arr = @$arr[0..$k-1];\n    return @$arr;\n}", "    my ($i, $max,\
    \ $temp);\n    if ($k <= 0 || $arr->[0] > $arr->[1]) {\n        return $arr;\n\
    \    }\n    foreach $i (0..($k-1)) {\n        if ($arr->[$i] > $arr->[$i+1]) {\n\
    \            $max = $arr->[$i];\n            $temp = $arr->[$i+1];\n        }\n\
    \        else {\n            $max = $arr->[$i+1];\n            $temp = $arr->[$i];\n\
    \        }\n    }\n    return $arr->[0..$k-1] if($arr->[$k-1] > $temp);\n    $arr->[$k-1]\
    \ = $temp;\n    $arr->[$k] = $max;\n    return $arr;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI understand this but I'm looking for a more efficient method...\n<|/\
    \ c |>\n<| c |>\nI thought my answer had a better performance than yours, but\
    \ I see it doesn't. I had to go back and redo the code a couple of times to see\
    \ where it went wrong. I'll see if I can fix it now. Hopefully you can figure\
    \ it out. :)\n<|/ c |>\n<| c |>\nOkay, I did it now. Sorry for the delay.\n<|/\
    \ c |>\n<| c |>\nI fixed it now and edited my post with my code. I think it is\
    \ more efficient now. I tested it against yours and it was indeed faster with\
    \ large arrays. Good luck with your program!\n<|/ c |>\n<| a tags=sorting,arrays,perl,algorithm\
    \ |>\nYou can use the quicksort-algorithm to sort an array. This will give you\
    \ a O(nlogn) sorting algorithm. Just look at the wikipedia article for more information.\
    \ But the quicksort algorithm works best with small arrays. So it is better to\
    \ use a algorithm like quicksort. If you need more efficiency, you can also use\
    \ merge sort or quick sort. But merge sort will only work on arrays of length\
    \ 2 or less.\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nmy = sort { $a <=>\
    \ $b };\n</code>\n<|/ a tags=sorting,arrays,perl,algorithm |>\n<| a tags=sorting,arrays,perl,algorithm\
    \ |>\nUse an array:\n<code>\nmy;\n$temp[0] = $arr[0];\n$temp[1] = $arr[1];\n$temp[2]\
    \ = $arr[2];\n...\n$temp[$k] = $arr[$k];", "    my @max_arr = ();\n    foreach\
    \ my $key (sort { $a <=> $b } keys %$arr) {\n        if ($key >= $k) {\n     \
    \       push (@max_arr, $arr->{$key});\n        }\n    }\n    return @max_arr;\n\
    }", "    my @result;\n    my $count = 0;\n    my $pos = 0;\n    my $len = @$arr;\n\
    \    while ($k >= $pos) {\n        $count++;\n        if ($count > $len) {\n \
    \           push @result, $arr[$pos];\n            $pos = $pos + 1;\n        }\n\
    \        if ($arr[$pos] >= 0) {\n            $pos = $pos + 1;\n        }\n   \
    \ }\n    if ($count <= $len) {\n        push @result, $arr[$pos];\n    }\n   \
    \ return @result;\n}", "    my $n = @$arr;\n    my $sum = 0;\n    for (my $i=0;\
    \ $i<$k; $i++) {\n        $sum += $arr->[$i];\n    }\n    return sort { $a <=>\
    \ $b } map { $sum - $_ } @$arr[0..$k-1];\n}", '    my @maximum = ();', "    my\
    \ @m;\n    my ($i, $x, $y);\n    foreach $x (@$arr) {\n        next unless $x\
    \ < 0;\n        push(@m, $x);\n    }\n    $k = @m - 1;\n    $k == 0 ? @m : @m\
    \ = sort { $a <=> $b } @m[0..$k];\n}", "    $k += 0;\n    return $arr->[$k] if\
    \ $arr->[$k] > 0;\n    my $temp = 0;\n    my $max;\n    for (my $i = 0; $i < $k;\
    \ $i++) {\n        $temp = $arr->[$i] if $arr->[$i] > 0;\n        my $cmp = compare($temp,\
    \ $arr->[$i]);\n        $max = $i\n            if $cmp > 0;\n    }\n    $arr->[$max];\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
