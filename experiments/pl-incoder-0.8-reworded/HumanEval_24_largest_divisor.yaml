name: HumanEval_24_largest_divisor
language: pl
prompt: "# For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n# >>> largest_divisor(15)\n# 5\nsub largest_divisor {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_divisor;\n\
  \        if(eq_deeply($candidate->(3),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(7),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),5))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),50))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49),7))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    for(my $divisor = 1; $divisor <= $n; $divisor++) {\n        if\
    \ ($n % $divisor == 0) {\n            $n = $divisor;\n        }\n    }\n    return\
    \ $n;\n}", "    my $max_factor = 1;\n    my $max_factor_num = $n;", "    if ($n\
    \ <= 0) {\n        return 0;\n    }\n    my $largest = 0;\n    my $remainder;\n\
    \    while (1) {\n        $remainder = $n % 2;\n        if ($remainder == 0) {\n\
    \            my $divisor = 1 + $largest;\n            if ($divisor > $n) {\n \
    \               return $divisor;\n            }\n        }\n        else {\n \
    \           $largest = $remainder;\n        }\n        $n /= 2;\n    }\n}", " \
    \   my $max = $n if $n < 1;\n    my $i;\n    my $divisor = 1;\n    for (my $i\
    \ = 1; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            $divisor =\
    \ $i;\n        }\n        $max = $divisor if $divisor > $max;\n    }\n    return\
    \ $max;\n}", "    my($max_divisor) = $n;\n    my $counter = 1;\n    while(1) {\n\
    \        if ($n % $max_divisor == 0) {\n            my $next_divisor = $max_divisor;\n\
    \            $max_divisor = $max_divisor + $counter;\n            $counter++;\n\
    \            if ($next_divisor > $n) {\n                last;\n            }\n\
    \        }\n        else {\n            last;\n        }\n    }\n    return $max_divisor;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nGreat solution! I'm glad I learned something\
    \ new, but I wonder if there isn't a way to do this without writing a loop...\n\
    <|/ c |>\n<| c |>\n: It is not clear what is the algorithm you want to implement.\
    \ Can you give some example?\n<|/ c |>\n<| c |>\nI thought it was clear, although\
    \ it's been quite some time since I last looked at this. Basically I wanted to\
    \ find the largest number that could be made by multiplying each number in sequence\
    \ by the preceding one. For example I wanted to find the largest number that could\
    \ be made by multiplying the numbers 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,\
    \ 9, 8, 7, 6, 5, 4, 3, 2, 1 by each other: 20, 24, 28, 32, 36, 40, 44, 48, 52,\
    \ 56, 60... It can be thought of as the largest number that can be divided by\
    \ 2 without remainder.\n<|/ c |>\n<| c |>\n: I added a solution with no loop\n\
    <|/ c |>\n<| a |>\nIt's easiest if you convert your numbers into a string and\
    \ then find the largest one in that string.\nFor example, using the numbers you\
    \ gave above, I would do this:\n<code>", '    my $largest = 1;', '    my($i, $k);',
  "    return $n if $n <= 1;\n    my $max_divisor = 1;\n    while($max_divisor <=\
    \ $n) {\n        $max_divisor = 2 * $max_divisor;\n    }\n    return $max_divisor;\n\
    }", "    my $max_n = 0;\n    my $max_div;", "    my($largest_divisor);\n    #\
    \ Assume that n >= 2\n    for (my $i = 1; $i <= $n; $i++) {\n        # Check if\
    \ the remainder of n/i is evenly divisible by i\n        if ($n % $i == 0) {\n\
    \            $largest_divisor = $i;\n        }\n    }\n    return $largest_divisor;\n\
    }", "    my $largest = 1;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($n\
    \ % $i == 0) {\n            $largest = $i;\n        }\n    }\n    return $largest;\n\
    }", '    my($max);', "    \n    # Start at the largest\n    my $largest = $n;\n\
    \    \n    # If the number isn't an even number, stop\n    if ($n % 2 == 0) {\n\
    \        return $largest;\n    }\n    \n    # Divide the number by each number\
    \ less than or equal to n\n    while (not $n % 2) {\n        $n /= 2;\n    }\n\
    \    \n    return $n;\n}\n</cell>\n<text>\nThis doesn't work, since you're using\
    \ the same variable $n to store each new value.", "    my($div);\n    for(my $i\
    \ = 1; $i <= $n; $i++) {\n        if($n % $i == 0) {\n            $div = $i;\n\
    \        }\n    }\n    return $div;\n}", "    my(@div) = ();\n    my($d);\n  \
    \  my($div);\n    \n    if ( $n % 2 == 0 ) {\n        push(@div, $n);\n    }\n\
    \    \n    for ( $d = $n; $d > 1; $d /= 2 ) {\n        foreach $div (@div) {\n\
    \            if ( $n % $div == 0 ) {\n                last;\n            }\n \
    \       }\n        push(@div, $d);\n    }\n    \n    return(pop(@div));\n}", " \
    \   my($div, $limit, $result) = 0;\n    while ($n > 0) {\n        if ($n % 2 ==\
    \ 0) {\n            $div = $n/2;\n            $limit = $n;\n        }\n      \
    \  elsif ($n % 2 != 0) {\n            $n = $div*2;\n            $result = $div;\n\
    \            $limit = $n;\n        }\n        else {\n            last;\n    \
    \    }\n    }\n    return $result;\n}", "    return 1 if $n == 0;\n    for (my\
    \ $i = 5; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            return $i\
    \ if $n > $i;\n        }\n    }\n    return $n;\n}", "    my $largest_divisor\
    \ = 1;\n    while ($n > 1) {\n        $largest_divisor *= $n;\n        $n--;\n\
    \    }\n    return $largest_divisor;\n}", "    my $max = 1;\n    my $d = 1;\n\
    \    while ($n >= $d) {\n        $d = $d;\n        $max = $max * $d;\n       \
    \ $n = $n % $d;\n    }\n    return $max;\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\n\"Find largest divisor for a number with digits less than or equal to a\
    \ given N\" -- this would work for numbers greater than `2^53`, but does not work\
    \ for numbers smaller than `2^53`, which would result in a `0` as result. Thus,\
    \ `largest_divisor` would return `2^53` (or `2^53 - 1` if the number is a power\
    \ of 2) even for numbers less than `2^53`.\n<|/ c |>\n<| c |>\nIf n is less than\
    \ 2^53, then the largest divisor is 0, and if n is greater than 2^53, then the\
    \ largest divisor is 2^53 - 1\n<|/ c |>\n<| c |>\nIt's important to note that\
    \ this is an O(log(n)) solution\n<|/ c |>\n<| c |>\nYou forgot n is a positive\
    \ integer.\n<|/ c |>\n<| c |>\nThanks, I fixed that now.\n<|/ c |>\n<| a tags=algorithm,math,language-agnostic,factorial,big-o\
    \ |>\nIf you're trying to get the largest factorial number for a particular number\
    \ (say 100), it can be done quite easily with successive multiplications:\n<code>\n\
    100! = 1000! * 100! * 10! * 1!\n</code>\nThus we can use the fact that:\n<code>\n\
    (n!)^k = (n!)^(k-1) * n!\n</code>\nAnd we can use that fact:\n<code>\n100! = 1\
    \ * 10! * 100! * 1000! * ... * 10!\n</code>\nWe can use this fact to find k by\
    \ starting with an initial value of 1, increasing it by 1 until we reach 100!,\
    \ and repeating until we reach 100!^k. We can then easily see that if k is sufficiently\
    \ large, this is also the value of 100!^k - 1, which we can plug back into our\
    \ previous formula.\nIn code:\n<code>\npublic static final long LargestFactorial(final\
    \ long n) {\n    long max = 1;\n    long d = 1;\n    while (n > d) {\n       \
    \ d = d * 10;\n        max = max * d;\n        n--;\n    }\n    return max;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNot quite right -- you're missing a `*`\
    \ in the multiplication step.\n<|/ c ", "    return 1 if $n <= 2;\n    for my\
    \ $i(1..$n-1) {\n        if ($n % $i == 0) {\n            return $i;\n       \
    \ }\n    }\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGreat solution. But please\
    \ correct for beginners: add \"use integer;\" and \"sub largest_divisor { }\"\
    \ to the top of your file to use it.\n<|/ c |>\n<| c |>\nA minor comment - if\
    \ your `largest_divisor` subroutine is recursive, the stack size might get too\
    \ big.\n<|/ c |>\n<| a dscore=4 |>\n<code>\nuse Math::BigInt;", "    return $n\
    \ if $n == 0;\n    for (my $divisor = 3; $divisor <= $n; $divisor++) {\n     \
    \   my $test = $n/$divisor;\n        if ($test == $n) {\n            $divisor\
    \ = $n;\n            last;\n        } elsif ($test > $n) {\n            $divisor\
    \ = $test;\n        }\n    }\n    $divisor;\n}", "    my($max_divisor);\n    for\
    \ (1..$n) {\n        if ($n % $_ eq 0) {\n            $max_divisor = $_;\n   \
    \         last;\n        }\n    }\n    return $max_divisor;\n}", "    if (! defined\
    \ $n) {\n\t$_[0];\n    } elsif ($n == 0) {\n\t$_[0];\n    } else {\n\tmy $max\
    \ = 0;\n\tmy $remainder = $_[0];", "    my $i = 1;\n    my $m = 1;\n    my $limit\
    \ = 1;", '    my($iMax) = 0;', "    if ($n % 2 == 0) {\n        $n++;\n    }\n\
    \    my $counter = 0;\n    my $max = 0;\n    while (--$n != 0) {\n        $max\
    \ = 2 * $max;\n        $counter++;\n    }\n    return $max if $counter > 0;\n\
    \    return $n if $counter < 1;\n    return;\n}\n</code>\n<|/ a tags=numbers,perl,math\
    \ |>\n<| c |>\nThank you for your answer. Yes, I do understand that this is far\
    \ more efficient to find divisors than to find a number that divides evenly. However\
    \ the problem was that I did not want to use an infinite loop. Perl was a very\
    \ good language to start with, so I used the loop to learn about loops.\n<|/ c\
    \ |>\n<| c |>\nThe loop does not iterate infinitely. It simply breaks out of it\
    \ once the condition `$n % 2 == 0` is satisfied. Thus, this solution does *not*\
    \ rely on any infinite loop. :)\n<|/ c |>\n<| a |>\nPerl is pretty fast and efficient\
    \ at arithmetic operations. I believe this is the fastest way to find the divisors\
    \ of a number.\n<code>\nuse strict;\nuse warnings;\nuse Benchmark qw(:all);",
  "    # special case: handle 0 without throwing divide-by-zero\n    if ($n <= 0)\
    \ {\n        return 0;\n    }\n    if ($n % 2 == 0) {\n        return $n;\n  \
    \  }\n    my $max = 1;\n    # find the next greater power of 2 that is larger\
    \ than $n\n    while ($n >= 2 * $max) {\n        $max *= 2;\n    }\n    my $ans\
    \ = $n / $max;\n    while ($max > 2) {\n        # find the next smaller power\
    \ of 2 that is smaller than $max\n        $max *= 2;\n    }\n    until ($n / $max\
    \ >= $ans) {\n        $max *= 2;\n    }\n    return $ans;\n}", "    if ($n < 2)\
    \ {\n        return $n;\n    }\n    my($largest,$divisor_count) = (0, 0);\n  \
    \  my($divisor, $quotient) = (0, 0);\n    while ($divisor < $n) {\n        ++$divisor_count;\n\
    \        $quotient = $n / $divisor;\n        if ($quotient != 0) {\n         \
    \   ++$divisor;\n        }\n        if ($divisor_count == $largest) {\n      \
    \      $largest = $divisor_count;\n        }\n    }\n    return $largest;\n}\n\
    </cell>\n<cell>", "    if ( $n <= 1 ) {\n        return $n;\n    }\n    \n   \
    \ my($div) = $n / 2;\n    my($mod);", "    $n = abs($n);\n    my($max_divisor)\
    \ = -1;", "    # make sure n is a positive integer\n    if (! defined $n || !\
    \ $n > 0) {\n        warn \"Please provide an integer value for n.\\n\";\n   \
    \     return 0;\n    }", '    my($max_divisor);', "    $_ = $_ * $n;\n    $_ +=\
    \ 1;\n    my $max_divisor = 1;\n    my $divisor = 1;\n    while (1) {\n      \
    \  $divisor++;\n        if ($_ % $divisor == 0) {\n            $max_divisor =\
    \ $divisor;\n            last if $divisor > $n;\n        }\n    }\n    return\
    \ $max_divisor;\n}", "    my $limit = $n / 2;\n    for(my $i = 1; $i <= $limit;\
    \ ++$i) {\n        if($n % $i == 0) {\n            return $i;\n        }\n   \
    \ }\n    return $n;\n}", "    my($max_divisor);\n    my $temp = $n;", "    for\
    \ my $factor (1 .. $n) {\n        if ($n % $factor == 0) {\n            return\
    \ $factor;\n        }\n    }\n    return $n;\n}\n</code>\nOf course, this does\
    \ go through every number in the range and checks for divisors. This could be\
    \ a lot of work for a relatively small range. A more efficient solution is to\
    \ use mathematical primality tests:\n<code>", "    my $max_div = 1;\n    my $max_div_found\
    \ = 0;\n    foreach my $i (1..$n) {\n        if ($n % $i == 0) {\n           \
    \ my $cur_div = $i / $n;\n            if ($cur_div > $max_div) {\n           \
    \     $max_div = $cur_div;\n                $max_div_found = $i;\n           \
    \ }\n        }\n    }\n    return $max_div_found;\n}", "    for(my $i = 1; $i\
    \ <= $n; $i++) {\n        if(!($n % $i)) {\n            $i = $n;\n        }\n\
    \    }\n    return $i;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code fails\
    \ for large `n`, like `largest_divisor(1000000000) \u2248 1.01e+18` which is ~1M\
    \ and will take much more time to compute.\n<|/ c |>\n<| c |>\nI added a [memoize\
    \ version](http://stackoverflow.com/a/19114979/176646) of `largest_divisor`.\n\
    <|/ c |>\n<| a tags=math,algorithm,python dscore=2 |>\nThis is an incredibly simple\
    \ solution in Javascript.\n<code>\nfunction largestDivisor(n){\n    let result\
    \ = 0\n    for(let i = 1; i < n; i++){\n        if(n % i == 0){\n            result\
    \ = i;\n            break;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYou don't have to set `result` to zero before you start the\
    \ loop.  Just `let result = 1;`\n<|/ c |>\n<| c |>\nYou're right, thank you for\
    \ the tip.\n<|/ c |>\n<| a tags=math,algorithm,python dscore=2 |>\nPython\n<code>\n\
    def largestDivisor(n):\n    for i in range(1,n+1):\n        if n % i == 0:\n \
    \           return i\n    return 0\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIn Haskell\
    \ (with laziness):\n<code>\nlargestDivisor :: Int -> Int\nlargestDivisor n = let\
    \ m = 1 :: Int \n                in foldr (\\v n -> if (n `mod` v == 0) then (v\
    \ + 1) else v) m [n..] \n</code>\n<|/ a tags=math,algorithm,python |>\n<| c |>\n\
    This is very inefficient as you're generating a huge number of unnecessary `1`\
    \ values. `foldl (\\v n -> if (n `mod` v == 0) then (v + 1) else v) 1` would be\
    \ a little more efficient.\n<|/ c |>\n<| c |>\nThanks Rob. I don't understand\
    \ your point. The `1` in `1 :: Int` isn't the head of a list, it's just a \"hint\"\
    \ to the compiler to not generate any list at all. But I agree that `foldl` would\
    \ be a better option. I'll edit the answer.\n<|/ c |>\n<|", "    my $num_divisors\
    \ = 0;\n    while (int($n / $num_divisors) < $n) {\n        $num_divisors++;\n\
    \    }\n    $num_divisors == $n or $num_divisors == 0 ? $n : int($n / $num_divisors)\
    \ - 1\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile I really appreciate the answer\
    \ (and the code example), this question is specifically asking for an algorithm\
    \ to solve this problem...  Your algorithm is O(n).\n<|/ c |>\n<| c |>\nThis algorithm\
    \ is O(sqrt(n)). Even a little bit more if you add the check that the number is\
    \ odd...\n<|/ c |>\n<| c |>\nNot if you add more checks to find out whether a\
    \ divisor divides the number...\n<|/ c |>\n<| c |>\n: I agree with you, but it\
    \ still can be optimized with memoization. Also, for large numbers, you can also\
    \ keep a hash-table of the results for speed...\n<|/ c |>\n<| c |>\n: I see you\
    \ didn't take that into account in your code, my bad.\n<|/ c |>\n<| a dscore=2\
    \ tags=algorithm,c++ |>\nIt seems your question is, given a number n, find the\
    \ largest number that divides n evenly, smaller than n.  I don't think you can\
    \ do it faster than O(n).  The answer is: it's going to be n/2, or sqrt(n), or\
    \ O(sqrt(n)).\nThe answer is pretty simple.  It's going to be the smallest number\
    \ that is larger than n/2, such that n/2 divides it.  That would be O(sqrt(n)).\n\
    <|/ a |>\n<| c |>\nI agree. O(n) would be a little bit better, but a lot more\
    \ code would need to be written. Also, I think it's a valid question, even if\
    \ it is a little bit obtuse :)\n<|/ c |>\n<| a dscore=2 tags=algorithm,c++ |>\n\
    This is a solution which uses simple math.  It works well for n less than 50.\n\
    <code>\nfunction largest_divisor {\n  # If n > 50, return 0\n  [ $n ] | return\
    \ 0 if !$n", "    my($i);\n    my($max_divisor);", "    if ($n < 0) {\n\t$n =\
    \ (-$n) - 1;\n    }\n    my $max = 1;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \tmy $temp = ($n % $i);\n\tif ($temp == 0 && $i > 1) {\n\t    $max = $i;\n\t}\n\
    \    }\n    return $max;\n}", "    my $largest;\n    for ($n ; $n > 0 ; $n--)\
    \ {\n        if (! $n % 2) {\n            $largest = $n;\n        }\n    }\n \
    \   return $largest;\n}", "    my($largest);\n    my($div);\n    my($i);\n   \
    \ for ($i = 1; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            $div\
    \ = $i;\n            $largest = $i;\n            last;\n        }\n    }\n   \
    \ return $largest;\n}", "    $n % 2 and return $n;\n    while($n /= 2) {\n   \
    \     $n % 2 and return $n;\n    }\n    return $n;\n}\n</code>\n<|/ a tags=algorithm,python,math\
    \ |>\n<| c |>\nThis is great but you can use the following function instead of\
    \ the while loop:\n`return $n if $n&1 eq 0`\n<|/ c |>\n<| c |>\nThat is clever,\
    \ but unfortunately, it is also a _quadratic_ time algorithm. For a number of\
    \ the form `p^2 / (e^x+1)`, that means checking `log (log (p) / (e^x+1)) == log(log(p))\
    \ + (log(e) - log(x))`. So `log(log(p)) + (log(e) - log(x))` _must_ be equal `log(log(p))\
    \ + (log(e) - log(x))`, which means, it must be an _Omega(log(log(p)) + (log(e)\
    \ - log(x)))_ function, which means that a _logarithmic_ algorithm will run _Omega(log(log(p))\
    \ + (log(e) - log(x)))_ times, which means _Omega(log(p))_ time.\n<|/ c |>\n<|\
    \ c |>\nI suppose that's a fair point. I'm not sure I quite understand why you're\
    \ using logarithms here, I think it's more of a mental exercise than something\
    \ that would be useful in real code. But in any case, your solution is clever\
    \ and I learned something new today.\n<|/ c |>\n<| a dscore=2 tags=algorithm,python,math\
    \ |>\n<code>\ndef largest_divisor(n):\n    \"\"\"\n    Find the largest divisor\
    \ less than n\n    \"\"\"\n    if n < 2:\n        return n\n    elif n >= 1:\n\
    \        largest_divisor = n // 2\n        smallest_divisor = n // 2\n       \
    \ while smallest_divisor < n:\n            largest_divisor = smallest_divisor\
    \ + 1\n            smallest_divisor = largest_divisor // 2\n        return largest_divisor\n\
    </code>\n<|/ a |>\n<| c |>\nThis is a bad idea. Try `largest_divisor(23)`.\n<|/\
    \ c |>\n<| c |>\nIt seems that it works fine with all the test cases I have tried.\
    \ Thanks!\n<|/ c |>\n<| c |>\nit works fine for me - `largest_divisor(23)` returns\
    \ `5`.\n<|/ c |>\n<| c |>\nIf you run the program with the `print(largest_divisor(9))`\
    \ line included, it will output `3` ", "    $n++ while $n < 100 and $n % $n !=\
    \ 0;\n    $n -= 1;\n    while ($n > 1) {\n        my $div = int(($n-1)/2);\n \
    \       if ($n % $div == 0) {\n            return $div;\n        }\n        $n\
    \ -= $div;\n    }\n    return;\n}", "    my($max);\n    foreach my $divisor (1..$n)\
    \ {\n        my $remainder = $n % $divisor;\n        if ($remainder == 0) {\n\
    \            $max = $divisor;\n            last;\n        }\n    }\n    return\
    \ $max;\n}", "    my $max_divisor = 1;\n    my $max_divisor_size = 1;\n    my\
    \ $current_divisor = 1;\n    my $current_divisor_size = 1;\n    my $max_divisor_factor\
    \ = 1;", "    my($highest);\n    my($num, $denom);\n    $num = $n;\n    $denom\
    \ = 2;\n    $highest = $n;\n    while($num > 1) {\n        if($num % $denom ==\
    \ 0) {\n            $highest = $num;\n        }\n        $num = $num / $denom;\n\
    \        $denom++;\n    }\n    return $highest;\n}\n</code>\n<|/ a tags=perl |>\n\
    <| c |>\nHaven't thought of that. But I wonder how efficient it would be if the\
    \ largest number is the square root of n\n<|/ c |>\n<| c |>\nYes, of course. Sorry\
    \ I didn't get that from the OP :)\n<|/ c |>\n<| a dscore=1 |>\nThis solution\
    \ uses Schwartzian transformation and is also slightly more efficient.\n<code>\n\
    use strict;\nuse warnings;", "    my ($n1, $n2, $n3);\n    foreach $n1 (1..$n)\
    \ {\n        for ($n3 = 1; $n3 < $n; $n3++) {\n            if ($n % $n3 == 0)\
    \ {\n                ($n3, $n2) = ($n2, $n3);\n            }\n        }\n    }\n\
    \    return $n2;\n}", "    my $max = -1;\n    for (my $i = 1; $i <= $n; $i++)\
    \ {\n        if ($n % $i == 0) {\n            $max = $i;\n            last if\
    \ $max >= $n;\n        }\n    }\n    return $max;\n}", "    my $max_divisor =\
    \ 1;\n    my $max_divisor_value;", "    foreach my $d (2..$n) {\n        my $d\
    \ = $n / $d;\n        return $d if $n % $d == 0;\n    }\n    return;\n}", "  \
    \  my $max_divisor = -1;\n    foreach my $divisor(2..$n/2) {\n        if ($n %\
    \ $divisor == 0) {\n            last if $divisor > $max_divisor;\n           \
    \ $max_divisor = $divisor;\n        }\n    }\n    return $max_divisor;\n}", " \
    \   foreach $i (1..$n) {\n        if ($n % $i == 0) {\n            return $i;\n\
    \        }\n    }\n    return $n;\n}", "    for (my $i = 1; $i <= $n; ++$i) {\n\
    \        if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return\
    \ $n;\n}", "    my $max = -1;\n    \n    while ($n != 1) {\n        $n = int($n\
    \ / 2);\n        if ($n % 2 == 0) {\n            $max = $max < $n ? $n : $max;\n\
    \        }\n    }\n    \n    return $max;\n}", "    my $maxdiv = 1;\n    my $div\
    \ = 1;\n    while ($div <= $n) {\n        my $test = $n / $div;\n        if ($test\
    \ < $maxdiv) {\n            $maxdiv = $test;\n        }\n        $div += 1;\n\
    \    }\n    return $maxdiv;\n}", "    my($i, $m, $max);\n    my($max) = 1;\n \
    \   my($factor, $i);\n    \n    for(; $n >= $max; $max += $max) {\n        $i++;\n\
    \        $m = $i * $i;\n        while($m % $n != 0) {\n            $m /= $n;\n\
    \        }\n        $factor = $i;\n        if($m == 1) {\n            exit($factor);\n\
    \        }\n    }\n    exit(0);\n}", "    my $divisor;\n    my $i;\n    for(my\
    \ $i = 0; $i < $n; $i++) {\n        $divisor = 1;\n        for($i; $i <= $n; $i++)\
    \ {\n            if($n % $i == 0) {\n                $divisor *= $i;\n       \
    \         last if  $i == $n;\n            }\n        }\n        $i++;\n    }\n\
    \    return $divisor;\n}", "    my $max_divisor = -1;\n    my $max_divisor_index;\n\
    \    \n    for (my $index = 1; $index * $index < $n; $index++) {\n        if ($n\
    \ % $index == 0 && $index > $max_divisor) {\n            $max_divisor = $index;\n\
    \            $max_divisor_index = $index;\n        }\n    }\n    return $max_divisor_index\
    \ if $max_divisor > 0;\n    return $n;\n}\n</cell>\n<text>\nExercise 2\nWhat is\
    \ the smallest number n where n/4 does not equal 1? What about n/2? How about\
    \ n/3?", "    for(my $i = 10; $i; $i--){\n        if ($n % $i == 0){\n       \
    \     return $i;\n        }\n    }\n    return $n;\n}", "    if ($n <= 1){\n \
    \       return 1;\n    }\n    my $max_divisor = 1;\n    my $max_divisor_remainder\
    \ = 1;\n    my $divisor = 1;\n    my $divisor_remainder = 1;\n    while ($n %\
    \ $divisor == 0){\n        $divisor_remainder += $divisor;\n        $max_divisor_remainder\
    \ = $divisor_remainder > $max_divisor_remainder ? $divisor_remainder : $max_divisor_remainder;\n\
    \        $max_divisor = $divisor;\n        $divisor += 1;\n    }\n    return $max_divisor_remainder;\n\
    }", "    my($max_divisor) = 1;\n    my($i, $d, $n);\n    my($factors);\n    while\
    \ ($n >= $max_divisor) {\n        $i++;\n        $d = $n/$max_divisor;\n     \
    \   $factors = @$factors[0..$i];\n        if ($d != 1) {\n            for ($n\
    \ = 0; $n <= $d; $n++) {\n                $factors[$n] += 1;\n            }\n\
    \        }\n        if ($d != $max_divisor) {\n            $max_divisor = $d;\n\
    \        }\n        else {\n            $n = $d / 2;\n        }\n    }\n    $n\n\
    }\n</code>\n<|/ a tags=math,python,algorithm,perl |>\n<| c |>\nAh, I like Perl.\
    \ I've always been a Python guy.\n<|/ c |>\n<| c |>\nI wish I could upvote this\
    \ more. Nice, neat solution that actually uses Perl instead of Python!\n<|/ c\
    \ |>\n<| a tags=math,python,algorithm,perl |>\nI hope that this solution is not\
    \ too ugly.\nIt works for positive integers, but there is a special case where\
    \ it fails.\n<code>\ndef largestDivisor(n):\n    def divisor(n):\n        for\
    \ d in range(1, int(n ** 0.5) + 1):\n            if n % d == 0:\n            \
    \    yield d\n            else:\n                break\n    yield n\n    divs\
    \ = list(divisor(n))\n    divs.sort(reverse=True)\n    for div in divs:\n    \
    \    yield div\n    \ndef largest_divisor(n):\n    largest = 0\n    for div in\
    \ largestDivisor(n):\n        if div > largest:\n            largest = div\n \
    \   return largest\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks. I was able to\
    \ use your code to find prime factors of a number. Here is the link: http://stackoverflow.com/questions/2204877/python-prime-factors\n\
    <|/ c |>\n<| c |>\n: Note that this solution doesn't find all divisors. E.g. try\
    \ factoring 11 (=2*3*5).\n<|/ c |>\n<| c |>\n: Good point about that. I would\
    \ not want it to work on big numbers since I knew it would take a long time. But\
    \ if you had a way to improve it, I'd be interested in hearing it.\n<|/ c |>\n\
    <| c |>\n: I added a second solution that doesn't use prime factors, it finds\
    \ divisors recursively.\n<|/ c |>\n<| c |>\n: I added a solution without prime\
    \ factors, it finds divisors ", "    my $max = 1;\n    for(my $i = 1; $i <= $n;\
    \ ++$i) {\n        my $d = $i / $n;\n        if($d % 2 != 0) {\n            $max\
    \ = $d;\n            last;\n        }\n    }\n    return $max;\n}", "    return\
    \ 1 if $n == 1;\n    if ($n % 2 == 0) {\n        return largest_divisor($n-1);\n\
    \    } else {\n        my $max_div = 1;\n        for (my $i = 3; $i <= $n/2; $i+=2)\
    \ {\n            if ($n % $i == 0) {\n                return $max_div if $max_div\
    \ < $i;\n                $max_div = $i;\n            }\n        }\n        return\
    \ $max_div;\n    }\n}", "    my ($max, $divisor, $remainder);\n    my $i;", " \
    \   return 1 if $n == 0; # can't divide by 0", "    my $div = $n;\n    my $largest;",
  "    my $highest = 1;\n    for (my $i = 1; $i <= $n; $i++) {\n        if ($n % $i\
    \ == 0) {\n            if ($i > $highest) {\n                $highest = $i;\n\
    \            }\n        }\n    }\n    return $highest;\n}", "    if ( $n == 1\
    \ ) {\n        $n++;\n        $n += 1;\n    }\n    my $max_divisor = $n / 2;\n\
    \    for ( my $i = 3; $i <= $n; $i += 2 ) {\n        if ( $n % $i == 0 ) {\n \
    \           $max_divisor = $i;\n        }\n    }\n    return $max_divisor;\n}",
  "    my $n_max = $n / 2;\n    while ($n % $n_max) {\n        $n_max *= 2;\n    }\n\
    \    return $n_max;\n}", "    return $n if $n < 2;\n    my $max_div = 1;\n   \
    \ while ($n % 2 == 0) {\n        $max_div *= 2;\n        $n--;\n    }\n    while\
    \ ($n % 2 == 0) {\n        $n--;\n    }\n    while ($n % $max_div == 0) {\n  \
    \      $max_div++;\n        $n--;\n    }\n    return $max_div;\n}", "    my $div\
    \ = shift;\n    $div = 1 if ($div < 1);\n    $div = 2 if ($div > 2);", "    my(@factors)\
    \ = ();\n    my($max_div);\n    my($i);\n    my($max);\n    \n    $n = abs($n);\n\
    \    \n    while($n != 1) {\n        $max_div = 0;\n        $i = 1;\n        \n\
    \        while($n >= $i) {\n            if($n % $i == 0) {\n                $factors[]\
    \ = $i;\n                $n /= $i;\n            }\n            $i++;\n       \
    \ }\n        \n        my $max_num = @factors;\n        if($max_num > $max_div)\
    \ {\n            $max_div = $max_num;\n            $max = $factors[0];\n     \
    \   }\n    }\n    \n    return $max;\n}\n</cell>\n<code language=conda-env-py35-py>\n\
    largest_divisor(15)\n</cell>\n<code language=conda-env-py35-py>", '    my $largest_divisor
    = $n if $n >= 2;', "    my $result;\n    for(my $i = $n; $i > 1; $i /= 2) {\n\
    \        $result = $i  if $i % 2 != 0;\n    }\n    return $result;\n}", "    my\
    \ $max = 1;\n    my $factor = 2;\n    while ($n >= $factor) {\n        $n = ($n\
    \ / $factor) - 1;\n        if ($n % $factor) {\n            $max = $factor;\n\
    \        } else {\n            $factor++;\n        }\n    }\n    return $max;\n\
    }", "    return $n if $n <= 1;\n    return $n if $n % 2 != 0;\n    return $n if\
    \ $n % 3 == 0;", "    my $max_div = 1;\n    for(my $i=1; $i <= $n; $i++) {\n\t\
    my $div = $i / $n;\n\tif ($div > $max_div) {\n\t    $max_div = $div;\n\t}\n  \
    \  }\n    return $max_div;\n}", "    my($divisor, $max_divisor);\n    my($remainder)\
    \ = 0;\n    my($counter);", "    return unless $n >= 0;\n    $n -= 1;\n    while\
    \ ($n != 0) {\n        my $d = $n /= 2;\n        if ($d % 2 == 0) {\n        \
    \    return $d;\n        }\n    }\n    return 1;\n}", '    my $max_num = ($n +
    1) / 2;', "    my $max = 1;\n    my $divisor = 1;", "    my $n = abs($n);\n  \
    \  $n -= 1 if ($n != 0);\n    my $max = 1;\n    my $i = 2;\n    my $j = 1;", " \
    \   my(@divisors) = ();\n    my($highest_divisor) = 0;\n    for(my $i=2;$i<=$n;$i++){\n\
    \        if($n%$i == 0){\n            push(@divisors,$i);\n            if($i>$highest_divisor){\n\
    \                $highest_divisor = $i;\n            }\n        }\n    }\n   \
    \ if(scalar(@divisors) > 0){\n        my $max = 1;\n        for(my $i=scalar(@divisors)-1;$i>=0;$i--){\n\
    \            my $div = $divisors[$i];\n            while($n%$div == 0){\n    \
    \            $n=$n/$div;\n                last;\n            }\n            while($div\
    \ > 1){\n                $div--;\n                if($n%$div == 0){\n        \
    \            $n=$n/$div;\n                    last;\n                }\n     \
    \       }\n            $max = $i if $n > $max;\n        }\n        return $max;\n\
    \    }\n    return 1;\n}", '    my($largest);', "    my $max_div = 0;\n    my\
    \ $max_n = 0;\n    \n    for(my $i = 1; $i <= $n; $i++) {\n        my $d = $i\
    \ * ($i / 2);\n        if($n % $d == 0) {\n            my $x = $n;\n         \
    \   $n = $d;\n            \n            $max_div = $i;\n            $max_n = $x;\n\
    \        }\n    }\n    \n    return $max_div;\n}\n</cell>\n<text>\nChallenge 11:\
    \ Factorial of N\nWrite a program to find the factorial of N (n!).", "    my $max_div\
    \ = 1;\n    my $max_divisor = 1;\n    while ($max_div <= $n) {\n        $max_div\
    \ *= 2;\n        $max_divisor *= 2;\n    }\n    return $max_divisor;\n}", "  \
    \  my $max_divisor = 0;\n    for(my $i = 0; $i < $n; $i++) {\n        my $divisor\
    \ = 1;\n        for(; $i*$i <= $n; $i++) {\n            last if $n % $i;\n   \
    \         $divisor *= $i;\n        }\n        if($divisor > $max_divisor) {\n\
    \            $max_divisor = $divisor;\n        }\n    }\n    return $max_divisor;\n\
    }", "    return $n if $n <= 1;\n    $n = int $n;\n    return $n if $n != $n+1\
    \ / $n;\n    # $n could be an integer, or we could return $n\n    my($k, $div,\
    \ $i);\n    for $i (1 .. $n) {\n        $k = $n/$i;\n        if ($k <= $n) {\n\
    \            return $k;\n        }\n    }\n    return $n;\n}", "    \n    # Handle\
    \ case where n is odd\n    return 1 if $n % 2 == 1;\n    \n    # Find largest\
    \ divisor for n by factorizing the n\n    my $factors = factorize($n);\n    #\
    \ Find largest factor\n    my $divisor = @$factors -2;\n    # Loop until we find\
    \ one that is smaller than n\n    while (@$factors > 0 && $factor != 1) {\n  \
    \      $divisor++;\n        if ($n % $factors == 0) {\n            $factor = $factors;\n\
    \        }\n        $factors = @$factors;\n    }\n    return $factor;\n}", '    my
    ($d) = split //, Math::BigInt->new($n);', "    for ($n = 3; $n <= $n; $n++) {\n\
    \        if (! $n % 2 && ! $n % 3 && ! $n % 5 && ! $n % 7 && ! $n %11) {\n   \
    \         return $n;\n        }\n    }\n}", "    for (my $i = 1; $i <= $n; $i++)\
    \ {\n        if ($n % $i eq 0) {\n            $n++;\n            return $i;\n\
    \        }\n    }\n    return $n;\n}", "    my $n = int($n);\n    for (my $i =\
    \ 1; $i <= $n; $i++) {\n        my $remainder = 0;\n        for (my $j = 0; $j\
    \ < $i; $j++) {\n            $remainder *= $i;\n            $remainder %= $n;\n\
    \        }\n        return $i if $remainder == 0;\n    }\n    return $n;\n}",
  "    return 1 if $n <= 1;\n    my($largest, $remainder) = (0, 1);\n    for my $i(2,\
    \ $n-1) {\n        my($div) = div($n, $i);\n        $largest = $div if $div >\
    \ $largest;\n        $remainder = $n % $div;\n        $n = $div;\n    }\n    return\
    \ $remainder;\n}", '    my(@div) = ();', '    my(@results);', "    return 0 if\
    \ $n == 0;\n    my $max_factor = 1;\n    my $factor = 1;\n    while ($n /= $factor)\
    \ {\n        $max_factor = $factor if $factor > $max_factor;\n        $factor++;\n\
    \    }\n    return $max_factor;\n}", "    my $max_num;\n    my $max_div;\n   \
    \ my $max_val;\n    my $min_val;\n    my $i;\n    $max_num = -1;\n    $min_val\
    \ = 1;\n    $max_div = -1;\n    for ($i = 0; $i < $n; $i++) {\n        $max_div\
    \ = -1 if $i / $max_num > $max_div;\n        $max_num = -1 if $i / $max_num <\
    \ $max_num;\n    }\n    return $max_num if $max_div >= $min_val;\n    return -1;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=c,algorithm |>\nHere is a simple solution\
    \ that does not need any loops (assuming the numbers are in ascending order):\n\
    <code>", "    return $n if $n <= 1;\n    my @divisors = (1, $n / 2, $n / 3, $n\
    \ / 4, $n / 5, $n / 6, $n / 7);\n    my $divisor = pop @divisors;\n    return\
    \ $divisor if $n % $divisor == 0;\n    foreach my $d (@divisors) {\n        if\
    \ ($n % $d == 0) {\n            pop @divisors;\n            return $d;\n     \
    \   }\n    }\n    return 0;\n}", "    # Check if $n divides evenly\n    die \"\
    Not divisible\" if $n % 2;\n    # Divide $n by 2 until we get back to 1 and not\
    \ even\n    my $n = $n;\n    while ($n /= 2) {\n        last if $n != 1;\n   \
    \ }\n    return $n;\n}", "    my($i);\n    for(my $i = 0; $i < $n; $i++) {\n \
    \       if ($n % $i == 0) {\n            $i = $i + 1;\n            last;\n   \
    \     }\n    }\n    return $i;\n}\n</code>\n<|/ a tags=division,math,perl |>\n\
    <| c |>\nI don't think this is right. For example, `largest_divisor(8)` returns\
    \ 3 instead of 6. Also, you're not handling negative numbers.\n<|/ c |>\n<| c\
    \ |>\nYeah, I realized that after I wrote the answer (I used the word \"handle\"\
    \ loosely). Also, I added an explanation as to why you might want it to handle\
    \ negative numbers.\n<|/ c |>\n<| a dscore=2 |>\nThe most efficient method I know\
    \ of would be the following:\n<code>", "    # Special cases: n must be 1 or 2,\
    \ and n can be even\n    if($n <= 1) {\n        return $n;\n    } elsif($n % 2\
    \ == 0) {\n        return $n;\n    } elsif($n % 4 == 0) {\n        return $n;\n\
    \    }\n    \n    my $divisor = 1;\n    my $temp = 1;\n    my $counter = 0;\n\
    \    \n    while($counter < $n) {\n        $temp = $n / $divisor;\n        if($temp\
    \ == 0) {\n            return $divisor;\n        }\n        $divisor++;\n    \
    \    $counter++;\n    }\n}", "    my $m = $n;\n    for(my $i = 1; $i <= $n; $i++)\
    \ {\n        if( $n % $i eq 0 ) {\n            $m = $i;\n            last;\n \
    \       }\n    }\n    return $m;\n}", '    my ($highest_divisor) = 0;', "    my\
    \ $divisor = $n;\n    for(my $i=1; $i <= $divisor; $i++) {\n        if($n % $i\
    \ == 0) {\n            my $remainder = $n % $i;\n            if($remainder ==\
    \ 0) {\n                $n = $i;\n            }\n            else {\n        \
    \        $n = $i;\n                last;\n            }\n        }\n    }\n  \
    \  return $n;\n}", "    my($max);\n    my($max_idx);\n    my $divisor = 1;\n \
    \   for (my $i = 1; $i <= $n; $i++) {\n        if (($n % $i) == 0) {\n       \
    \     $divisor = $i;\n        }\n        if ($divisor > $n) {\n            $divisor\
    \ = $n;\n        }\n    }\n    $max = $divisor;\n    $max_idx = 1;\n    for (my\
    \ $i = 1; $i <= $n; $i++) {\n        if ($i == $divisor) {\n            $max_idx++;\n\
    \        }\n        if ($i != $divisor and $i == $n and $i == $divisor) {\n  \
    \          $max_idx++;\n        }\n        if ($i != $divisor and $i == $n and\
    \ $i == $divisor and $i == $max_idx) {\n            $max_idx++;\n        }\n \
    \       if ($i != $divisor and $i == $n and $i == $divisor and $i == $max_idx)\
    \ {\n            $max_idx++;\n        }\n        if ($i != $divisor and $i ==\
    \ $n and $i == $divisor and $i == $max_idx) {\n            $max_idx++;\n     \
    \   }\n        if ($i != $divisor and $i == $n and $i == $divisor and $i == $max_idx)\
    \ {\n            $max_idx++;\n        }\n        if ($i != $divisor and $i ==\
    \ $n and $i == $divisor and $i == $max_idx) {\n            $max_idx++;\n     \
    \   }\n        if ($i != $divisor and $i == $n and $i == $divisor and $i == $max_idx)\
    \ {\n            $max_idx++;\n        }\n        if ($i != $divisor and $i ==\
    \ $n and $i == $divisor and $i == $max_idx) {\n            $max_idx++;\n     \
    \   }\n        if ($i != $divisor and $i == $n and $i == $divisor and $i == $max_idx)\
    \ {\n            $max_idx++;\n        }\n        if ($i != $divisor and $i ==\
    \ $n and $i == $divisor and $i == $max_idx) {\n            $max_idx++;\n     \
    \   }\n    }\n    return $max;\n}", "    for (my $i = 1; $i < $n; $i++) {\n  \
    \      if ($n % $i eq 0) {\n            return $i;\n        }\n    }\n    return\
    \ $n;\n}", "    my $divisor;\n    for ($divisor = 3; $divisor <= $n; $divisor++)\
    \ {\n        my $remainder = $n % $divisor;\n        if ($remainder == 0) {\n\
    \            return $divisor;\n        }\n    }\n}", "    my $count = 0;\n   \
    \ my($divider) = grep(!($n % $count), 1..$n);\n    return $divider;\n}", "   \
    \ for (my $i = 1; $i <= $n; $i++) {\n        if ($n % $i eq 0) {\n           \
    \ $n = $i;\n            last if $i > $n;\n        }\n    }\n    return $n;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nThe algorithm for the largest prime factor\
    \ is:", "    my($max_divisor) = 1;\n    my($divisor) = 0;", "    my $largest =\
    \ 0;\n    $largest = 1 if $n <= 1;\n    for my $div (2..($n+1)) {\n        my\
    \ $remainder = $n % $div;\n        $largest = 1 if $remainder == 0;\n        $largest\
    \ = $div if $remainder > 0;\n    }\n    return $largest;\n}", "    $n -= 1 unless\
    \ $n =~ /[02-9]+$/;\n    $n -= 1 unless $n % 2 == 0;\n    return $n % 2 ? $n :\
    \ largest_divisor($n/2);\n}", "    my $max_divisor = 0;\n    my $max_divisor_indx\
    \ = 0;", "    return 1 if $n == 1;\n    return $n\n        if $n % 2 == 0;\n \
    \   my($max_divisor) = -1;\n    my($div);\n    foreach $div (1, $n / 2){\n   \
    \     if ($n % $div == 0) {\n            ($max_divisor) = $div;\n            last;\n\
    \        }\n    }\n    return $max_divisor;\n}", '    my(@factors);', "    $n\
    \ += 1;\n    $n % 2 ? $n : largest_divisor($n/2);\n}", "    for (my $i = 1; $i\
    \ <= $n; $i++) {\n        if ($n % $i == 0) {\n            my $count = 1;\n  \
    \          while ($n % $i == 0) {\n                $n /= $i;\n               \
    \ $count++;\n            }\n            return $n;\n        }\n    }\n    return;\n\
    }", "    my $result = 0;\n    while ($n >= 1) {\n\tmy $nr = $n / 2;\n\twhile ($nr\
    \ >= 1) {\n\t    $nr *= 2;\n\t    $result++;\n\t}\n\tmy $nr2 = $n / $nr;\n\t$n--;\n\
    \t$nr = $nr2;\n    }\n    return $result;\n}", "    my $n1 = $n;\n    my $n2 =\
    \ $n1;\n    while($n2 != 1) {\n        $n1 -= $n2 if $n2 % 2 == 0;\n        $n2\
    \ = $n2 >> 1;\n    }\n    return $n1;\n}", "    my($max);\n    my $div = $n %\
    \ 4;\n    my($small) = $n % $div;\n    if ($div > 0) {\n        $max = $small;\n\
    \    } else {\n        $max = 2 * $small + 1;\n    }\n    return $max;\n}", '    my($max_div);',
  "    return 1 if $n == 0; # no divisors possible\n    for (my $i = 1; $i <= $n;\
    \ $i++) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n  \
    \  }\n    return $n;\n}", "    my($max_divisor);\n    my($largest_divisor);\n\
    \    \n    # initialize variables\n    $max_divisor = -1;\n    $largest_divisor\
    \ = -1;\n    \n    # find the largest divisor that is smaller than n\n    while(1)\
    \ {\n        if($n % 2 == 0) {\n            if($max_divisor == -1) {\n       \
    \         $max_divisor = 2;\n                $largest_divisor = 2;\n         \
    \   }\n            elsif($max_divisor < $largest_divisor) {\n                $max_divisor\
    \ = 2;\n                $largest_divisor = 2;\n            }\n            else\
    \ {\n                $largest_divisor = $max_divisor;\n            }\n       \
    \ }\n        elsif($n % 3 == 0) {\n            if($max_divisor == -1) {\n    \
    \            $max_divisor = 3;\n                $largest_divisor = 3;\n      \
    \      }\n            elsif($max_divisor < $largest_divisor) {\n             \
    \   $max_divisor = 3;\n                $largest_divisor = 3;\n            }\n\
    \            else {\n                $largest_divisor = $max_divisor;\n      \
    \      }\n        }\n        elsif($n % 5 == 0) {\n            if($max_divisor\
    \ == -1) {\n                $max_divisor = 5;\n                $largest_divisor\
    \ = 5;\n            }\n            elsif($max_divisor < $largest_divisor) {\n\
    \                $max_divisor = 5;\n                $largest_divisor = 5;\n  \
    \          }\n            else {\n                $largest_divisor = $max_divisor;\n\
    \            }\n        }\n        else {\n            last;\n        }\n    }\n\
    \    \n    return $largest_divisor;\n}\n</code>\n<|/ a |>\n<| c |>\n`while(1){if($n%2==0){$max_divisor=2;$largest_divisor=2;}elsif($n%3==0){$max_divisor=3;$largest_divisor=3;}elsif($n%5==0){$max_divisor=5;$largest_divisor=5;\
    \ }else{ last;}$n--;}`", "    my $max_divisor = 1;\n    while(1) {\n        $max_divisor++;\n\
    \        my $rem = $n % $max_divisor;\n        return 0 if $rem == 0;\n      \
    \  $n = $max_divisor;\n    }\n}", "    my $max_div = 0;\n    my $max_div_n;\n\
    \    my $min_div = 1;\n    my $min_div_n;\n    for my $i (1 .. $n) {\n       \
    \ $max_div = max $max_div, $i if $i divides $n evenly and $i > $max_div_n;\n \
    \       $min_div = min $min_div, $i if $i divides $n evenly and $i < $min_div_n;\n\
    \        $max_div_n = $i;\n        $min_div_n = $i;\n    }\n    return $max_div;\n\
    }", "    my $result = 0;\n    for(my $i = 0; $i <= $n; $i++) {\n        $result\
    \ = $i if ($n % $i == 0);\n    }\n    return $result;\n}", "    for (my $i = 1;\
    \ $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            return $i;\n   \
    \     }\n    }\n    return $n;\n}", "    my $max = $n;\n    while($max) {\n  \
    \      my $factor = 1;\n        for(my $i = $max; $i > 0; $i--) {\n          \
    \  my $test = $i / $factor;\n            if($test) {\n                $factor\
    \ *= $test;\n                $max = abs($test);\n            }\n        }\n  \
    \  }\n    return $max;\n}", "    for my $d (1..$n) {\n        if (($n / $d) %\
    \ 2 == 0) {\n            return $d;\n        }\n    }\n    return $n\n}", "  \
    \  my $div = 1;\n    while ( ($n / $div) != $n ) {\n        $div++;\n    }\n \
    \   $div;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=math,algorithm,php,number-theory\
    \ |>\nI think your question can be answered using these few steps:", '    my($i);',
  "    my $max_divisor = $n;\n    my $current_divisor = $n;\n    $max_divisor = 1\
    \ if ($n % 2);\n    \n    while($current_divisor > 1) {\n        $current_divisor\
    \ /= 2;\n        if($current_divisor % 2 != 0) {\n            $max_divisor = $current_divisor;\n\
    \        }\n    }\n    return $max_divisor;\n}", '    my $max = 1;', "    return\
    \ unless (defined $n);\n    my(@factors);\n    for (my $i = $n/2;$i > 0;$i/=2){\n\
    \        if ( $n % $i ) {\n            last;\n        }\n        push (@factors,\
    \ $i);\n    }\n    return ($factors[-1])? $factors[-1] : 1;\n}", "    my($largest);\n\
    \    my($i);", "    return $n if $n > $max_divisor;\n    my $max_divisor = 1;\n\
    \    my $divisor = 1;\n    while ($n % $divisor != 0) {\n        $divisor += 2;\n\
    \    }\n    ++$max_divisor;\n    while (1) {\n        while ($n % $divisor !=\
    \ 0) {\n            $divisor += 2;\n        }\n        if (++$divisor > $max_divisor)\
    \ {\n            $max_divisor = $divisor;\n        }\n        else {\n       \
    \     return $max_divisor;\n        }\n    }\n}", '    my $result = 0;', "   \
    \ $n += 1;\n    my $largest = $n-1;\n    my $divisor = 1;\n    foreach my $i (1..$n)\
    \ {\n        if ($n%$divisor == 0) {\n            $largest = $divisor;\n     \
    \       $divisor = 1;\n        } elsif ($n%$divisor != 0) {\n            $divisor++;\n\
    \        }\n    }\n    return $largest;\n}", "    $n += 1;\n    $n++ while $n%2\
    \ != 0;\n    return $n\n}", "    my $result;\n    my $i;\n    for ($i = $n; $i\
    \ > 0; $i--) {\n        if ($i%2 != 0) {\n            $result = $i;\n        }\n\
    \    }\n    return $result;\n}", "    # No divisor is smaller than n\n    return\
    \ 0 if $n == 0;\n    # No divisor is larger than n\n    return $n if $n == 1;\n\
    \    # First pass: find out which divisor is the largest for n / 2\n    my $largest\
    \ = largest_divisor($n/2);\n    # Second pass: if n / 2 divides evenly into n,\
    \ it divides n evenly into\n    # largest divisor, too\n    return $n if $n %\
    \ 2 == 0 && $largest % 2 == 0;\n    # n / 2 divides evenly into largest divisor,\
    \ so find the largest divisor for\n    # n / 2 + 1\n    return largest_divisor($n/2\
    \ + 1);\n}", "    my $d = $n / 2;\n    my $found;\n    while ($d % 2 == 0 && $d\
    \ <= $n) {\n        $found = $d;\n        $d /= 2;\n    }\n    return $found;\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,math,primes,sieve-of-eratosthenes,c\
    \ |>\n<| c |>\nThe question asks about the largest prime divisor less than or\
    \ equal to its input, which the code doesn't do.\n<|/ c |>\n<| c |>\nI believe\
    \ that you are mistaken; my code produces the correct output for the example case\
    \ of the OP's question \"For a given number n, find the largest number that divides\
    \ n evenly, smaller than n\".  The only error I see is that the last iteration\
    \ of the loop would cause it to return 1 instead of 0 as per the OP's question,\
    \ but that is easily fixed with a test to see if the loop has exited.\n<|/ c |>\n\
    <| c |>\nIt works perfectly fine. Did you test it? Please post a [MCVE] when you're\
    \ correcting mistakes.\n<|/ c |>\n<| c |>\nMy code works correctly, and I believe\
    \ that is the intended behavior.  Hence my comment that it is easily fixable with\
    \ a test to see if the loop has exited.\n<|/ c |>\n<| c |>\nYes, it does, and\
    \ your example code works too. I don't see what you're arguing about.\n<|/ c |>\n\
    <| a dscore=0 |>\nI think you actually want to find the largest prime factor of\
    \ a number.  For example, if your number is 13, you want to find the largest prime\
    \ factor which is less than or equal to 13 (which is 2).  So you want to find\
    \ the largest prime factor less than or equal to 2.  What you need to do is start\
    \ at the square root of the number and divide the number by any number less than\
    \ the square root of the number.  You will get an integer greater than the original\
    \ number that divides evenly between the original number and itself.  Then you\
    \ take the square root of that number (the square root of 3 is 2, so you just\
    \ need to divide by 2 again).  Repeat until the square root of the number is greater\
    \ than or equal to the original number.  Since you know that the number is greater\
    \ than or equal to the original number, once you have found a number that is greater\
    \ than or equal to the original number, you know that you have found a prime number.\
    \  So, if your number is 13, you want to find the largest prime factor which is\
    \ less than or equal to 13 (which is 2).  You need to start at 3, then you divide\
    \ by 4, then by 6, etc.  If you divide the number by 3, you get 6.  If you divide\
    \ it by 4, you get 2.  Since 6 and 2 are ", "    my($divisor);\n    for(my $i\
    \ = 1; $i <= $n; $i++) {\n        $divisor = $i;\n        while($n % $divisor\
    \ == 0) {\n            $divisor++;\n        }\n        return $divisor;\n    }\n\
    }", "    my($max_divisor);\n    for (my $i = 1; $i <= $n; $i++) {\n        if\
    \ ($n % $i == 0) {\n            $max_divisor = $i;\n            last if $max_divisor\
    \ < $n;\n        }\n    }\n    return $max_divisor;\n}", "    $n //= 2;\n    $n;\n\
    }", "    return 1 if $n == 0;\n    return $n if $n % 2 == 0;\n    return $n if\
    \ $n % 2 == 1;\n    my($max) = 0;\n    foreach my $i ( 0 .. $n-1 ) {\n       \
    \ my($div) = div($n,$i);\n        if ( $div > $max ) {\n            $max = $div;\n\
    \        }\n    }\n    return $max;\n}", "    return $n if $n <= 1;\n    my(@d)\
    \ = map { $n / $_ } (1..$n);\n    my $res = $d[0];\n    for(my $i = 1; $i < @d;\
    \ $i++) {\n        if($d[$i] % $res == 0) {\n            $res = $d[$i];\n    \
    \    }\n    }\n    return $res;\n}", "    my $n = $n->import('numify');\n    my\
    \ @div;", "    my $max_div = 1;\n    my $div = 1;\n    for (my $i = 1; $i <= $n;\
    \ ++$i) {\n        $max_div = ($i % $max_div == 0) ? ($i % $max_div) : ($max_div);\n\
    \        $div = ($i % $div == 0) ? ($i % $div) : ($div);\n    }\n    $max_div++;\n\
    \    $max_div = ($n % $max_div == 0) ? ($n % $max_div) : ($max_div);\n    $max_div++;\n\
    \    $max_div = ($n % $max_div == 0) ? ($n % $max_div) : ($max_div);\n    return\
    \ $max_div;\n}", "    my $max = -1;\n    my $divisor = 1;\n    while($divisor\
    \ * $divisor <= $n and $n % $divisor == 0) {\n        $divisor++;\n    }\n   \
    \ while ($n > 1) {\n        if ($n % $divisor == 0) {\n            $max = $divisor\
    \ if $max < $divisor;\n            $n /= $divisor;\n        } else {\n       \
    \     $n = $n / $divisor;\n        }\n        $divisor++;\n    }\n    return $max;\n\
    }", "    if ($n == 1) {\n        return $n;\n    }", "    my($max_divisor) = (-1);\n\
    \    my(@divisors) = (1);\n    my($div);", "    $n += 0;\n    while ($n > 1) {\n\
    \        $n = $n / 2;\n        if ($n % 2 == 0) {\n            return $n;\n  \
    \      }\n    }\n}", "    return $n if $n < 2;\n    my $max = 1;\n    my $d =\
    \ 1;\n    while ($d < $n) {\n        $max *= $d++;\n    }\n    while ($n % $max\
    \ != 0) {\n        $max--;\n    }\n    return $max;\n}", "    foreach my $d (1\
    \ .. $n) {\n        if ($n%$d == 0) {\n            return $d;\n        }\n   \
    \ }\n    return $n;\n}", "    my($max);\n    my($max_end);\n    my $i;", '    my($max_divisor);',
  "    my $i = 0;\n    my $divisor = 1;\n    my $remainder = 0;\n    while($i <  3)\
    \ {\n        while($divisor <= $n) {\n            $remainder = $n % $divisor;\n\
    \            if($remainder == 0) {\n                $n = ($n - $remainder) / $divisor;\n\
    \                last;\n            }\n            $divisor++;\n        }\n  \
    \      $i++;\n    }\n    return $n;\n}\n</code>\n<|/ a dscore=1 tags=factorial,algorithm,python\
    \ |>\n<| a dscore=1 |>\nI know it's already been posted but here is a little Python\
    \ program that does the job:\n<code>\nimport math", '    my($factor);', '    my
    $i = 1;', "    for my $d (2..$n) {\n        if ($n%$d == 0) {\n            return\
    \ $d;\n        }\n    }\n    return $n;\n}", "    my $largest = 1;\n    for (my\
    \ $i = 1; $i <= $n; $i++) {\n        if ($n % ($i + 1) == 0) {\n            if\
    \ ($largest>$n) {\n                $largest = $n;\n            }\n        }\n\
    \    }\n    return $largest;\n}", "    my $largest = 1;\n    foreach my $k (1\
    \ .. $n) {\n        my $n_in_k_evenly_divisible = 0;\n        foreach my $m ($k\
    \ / $largest) {\n            $n_in_k_evenly_divisible += 1 if $m % 2 == 0;\n \
    \       }\n        if ($n_in_k_evenly_divisible == 0) {\n            $largest\
    \ = $k;\n        }\n    }\n    return $largest;\n}", "    my $num;\n    while\
    \ ($n != 1) {\n        $num = $n % $n; $n  = $num / $n;\n    }\n    return $n;\n\
    }", "    return 1 unless $n;\n    my($max) = $n % 2 == 1;\n    my($div) = $n %\
    \ $max;\n    my($remainder) = $n / $max;\n    \n    return $max if $div == 0 &&\
    \ $remainder == 0;\n    return $div if $div == 0;\n    return $max if $remainder\
    \ == $max;\n    return $max if $remainder > $max;\n    return $remainder;\n}\n\
    </code>\n<|/ a tags=bignum,math,perl |>\n<| a dscore=4 |>\nI wrote a program for\
    \ doing this in Perl.  The code below is based heavily on McGuire's answer.  I\
    \ wrote it because I needed a fast algorithm to do this task.  It could be used\
    \ in other situations, but this is an example where it's useful.  Note that this\
    \ algorithm works in O(n) time and space.\n<code>\nuse bignum;\nuse 5.010;", " \
    \   my($i, $d);\n    for(; $n != 1; $n /= 2) {\n        $i = $d;\n        $d =\
    \ $n / $i;\n    }\n    return $d;\n}", "    my(@divisors);\n    for my $d (1 ..\
    \ $n) {\n        if ($n % $d != 0) {\n            push(@divisors, $d);\n     \
    \       push(@divisors, $n/$d);\n        }\n    }\n    return shift @divisors;\n\
    }", "    my $max_div = -1;\n    my $max_div_count = 0;\n    for (my $i = 0; $i\
    \ <= $n; $i++) {\n        my $div = $i / $n;\n        if ($div == $n) {\n    \
    \        $max_div = $i;\n            $max_div_count = 1;\n            last;\n\
    \        } elsif ($div > $max_div) {\n            $max_div = $div;\n         \
    \   $max_div_count = 1;\n        } elsif ($div == $max_div) {\n            $max_div_count++;\n\
    \        }\n    }\n    return $max_div;\n}\n</code>\n<|/ a tags=math,algorithm,primes,numbers\
    \ |>\n<| c |>\nI do not think that this is correct. Let's look at your example\
    \ with n = 15 and 15/4 = 1. It should be 1, not 0. You also do not handle n =\
    \ 0.\n<|/ c |>\n<| c |>\nOops, thanks for spotting that. Fixed.\n<|/ c |>\n<|\
    \ c |>\nI appreciate your help! I implemented the function based on the Wikipedia\
    \ article and it works very well. Thank you very much.\n<|/ c |>\n<| c |>\nI believe\
    \ you meant `return $max_div_count` instead of `return $div_count` when returning\
    \ `1` as the divisor count\n<|/ c |>\n<| c |>\nThanks for spotting that. Fixed.\n\
    <|/ c |>\n<| a dscore=4 tags=math,algorithm,primes,numbers |>\nI came up with\
    \ this solution using the Sieve of Atkin, by finding the prime numbers up to sqrt(n)\
    \ and then checking whether each number is a divisor of n (including itself).\
    \  \nThe algorithm is described in more detail here.\nIt's also a nice article\
    \ on Sieve of Atkin.\nThe code is a bit long so I have pasted the code here.\n\
    <code>\ndef isPrime(n):\n    # check if n is a prime\n    if n<=1:\n        return\
    \ False\n    # check if n is even \n    if n%2 == 0:\n        return False\n \
    \   # check if n is odd\n    if n%2 == 1:\n        return False\n    i = 2\n \
    \   while i * i <= n:\n        if n % i == 0:\n            return False\n    \
    \    i += 1\n    return True", '    my $max = 0;', "    my($max);\n    my ($i);",
  "    return -1 if $n eq 0;\n    my($l) = -1;\n    my($d) = -1;\n    for(my $x =\
    \ $n; $x < 100; $x += 25) {\n        my $quotient = intdiv($x, $n);\n        if($quotient\
    \ != 0) {\n            $d = $quotient;\n            last;\n        }\n    }\n\
    \    return $d;\n}", "    my($d);\n    foreach $d (1 .. $n) {\n        if ($d\
    \ % 2 == 0) {\n            return $d;\n        }\n    }\n}", "    if ($n < 0)\
    \ {\n        die(\"Negative number not allowed\");\n    }\n    my $largest = -1;\n\
    \    my $i;\n    for($i = $n; $i; $i -= 2) {\n        if($i & 1) {\n         \
    \   if($largest == -1) {\n                $largest = $i;\n            } elsif($largest\
    \ < $i) {\n                $largest = $i;\n            }\n        }\n    }\n \
    \   return $largest;\n}", "    $n += 1 if $n % 2 == 0; # make sure $n is odd to\
    \ prevent the loop from exiting early\n    my $largest = 1; # initialize largest\
    \ as 1\n    my $i = 2;\n    foreach my $m (1 .. floor($n)) { # loop while $m <=\
    \ $n\n        if ($n % $m == 0) { # $m divides evenly into $n\n            $largest\
    \ = $m if $m > $largest; # if the number is smaller than largest, we take it\n\
    \            last if $largest; # exit the loop if $largest is found\n        }\n\
    \        $i++;\n    }\n    return $largest;\n}\n</code>\n<|/ a tags=algorithm,performance,numbers,perl,math\
    \ dscore=4 |>\n<| a dscore=4 |>\nMy solution is simple:\n<code>", "    my $largest\
    \ = $n;\n    my $divisor = 1;\n    while(1) {\n        if($n % $divisor == 0)\
    \ {\n            $largest = $divisor;\n        }\n        $divisor++;\n      \
    \  if($divisor > $n) {\n            last;\n        }\n    }\n    return $largest;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis algorithm runs in O(sqrt(n)) and\
    \ O(sqrt(n)) space. There are no nested loops\n<|/ c |>\n<| c |>\n: That is true,\
    \ but it is also a very simple algorithm. The above code was meant as a way to\
    \ demonstrate how one could do this without using a nested loop.\n<|/ c |>\n<|\
    \ c |>\n: That's not true. There are loops within loops, and each loop runs O(sqrt(n))\
    \ times. A nested loop would run O(sqrt(n)) times, and would require O(sqrt(n)^2)\
    \ memory space. Also, it is very simple in that it doesn't use a nested loop (it\
    \ only uses a single loop).\n<|/ c |>\n<| c |>\n: Actually, I did a quick benchmark,\
    \ and you're right. My test was flawed, as I forgot that my code was more efficient\
    \ than yours. Thanks for pointing that out!\n<|/ c |>\n<| c |>\nA quick benchmark\
    \ does not prove an algorithm is better than another. It just shows you how it\
    \ could be written in a very simple way. And yes, it's true that it is true that\
    \ there are loops inside, but I didn't want to give a solution that involved nested\
    \ loops to beginners (because they don't understand it yet, especially when they\
    \ are not that familiar with the language).\n<|/ c |>\n<| a tags=division,algorithm,bignum\
    \ |>\nThe most efficient way that I've seen is to use the Moore\u2013Penrose primality\
    \ test to determine whether a number is prime, and then (if appropriate) verify\
    \ that no number larger than the sqrt of the number is prime.\n<|/ a dscore=3\
    \ |>\n<| a |>\nOne way you could do this would be to check all the integers up\
    \ to sqrt(n) and check if they are divisible by n.\n<|/ a tags=division,algorithm,bignum\
    \ dscore=2 |>\n<| a |>\nHere is a little bit different algorithm:\n<code>", " \
    \   for(my $m = $n; $m % 2 == 0; $m /= 2) {\n        return $m if ($n % $m ==\
    \ 0);\n    }\n    return $m;\n}", "    \n    for(my $n = 1; $n <= $n; $n++) {\n\
    \        if($n mod 2 == 0) {\n            $n = $n / 2;\n        } else {\n   \
    \         my $temp = $n;\n            $n = $temp / 2;\n        }\n    }\n    return\
    \ $n;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,math |>\nThis is an\
    \ old question, but since I still feel like writing my own answer...\n<code>\n\
    function gcd($x,$y) {\n    $tmp=$y;\n    while($x>0) {\n        $x--;\n      \
    \  $tmp=$x%$tmp;\n        if($tmp==0) {\n            $tmp=$tmp*10;\n         \
    \   $x=$x/10;\n            $x++;\n        }\n    }\n    return $tmp;\n}", "  \
    \  $n -= 1;\n    while (!($n % 2)) {\n        $n /= 2;\n    }\n    my $largest\
    \ = 1;\n    for (my $i = $n + 1; $i <= $n; $i++) {\n        if ($i % 2 == 0) {\n\
    \            $largest = 1 + $largest;\n        }\n    }\n    return $largest;\n\
    }", "    return $n if $n <= 1;\n    $n = (2**53)/($n+1);\n    $n = $n - (2**53)/($n+1);\n\
    \    my $i;\n    for ($i = 0; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n\
    \            $i = $n - $i;\n            last unless $i;\n        }\n    }\n  \
    \  return $i;\n}", "    my($div);\n    if ($n <= 0) {\n        return 0;\n   \
    \ }\n    $div = 1;\n    while ($div) {\n        $div = $div * 2;\n        if ($n\
    \ % $div == 0) {\n            return $div;\n        }\n    }\n    return 0;\n}",
  '    my($max);', "    foreach my $i (0 .. $#_) {\n        if ( $i % 2 ) {\n    \
    \        if ( ( $_[$i] / $n ) % 2 ) {\n                last if $_[$i] > $n; #\
    \ largest even divisor\n                return $_[$i];\n            }\n      \
    \  }\n    }\n    return;\n}", "    my($max_divisor) = -1;\n    my($max_divisor_size);",
  "    my $max;\n    my $i;\n    for ($i = 2; $i <= $n; $i++) {\n        my $j = $i;\n\
    \        while ($j > 1 && $n % $j == 0) {\n            $max = $j if $max < $j;\n\
    \            $j--;\n        }\n    }\n    return $max if $max;\n    return 0;\n\
    }", '    my $answer;', "    my $n = $n;\n    while ($n % 2 == 0) {\n        $n\
    \ = $n / 2;\n    }\n    return $n;\n}", "    my $max = 0;\n    for(my $i = 2;\
    \ $i <= $n; $i++){\n        if($n % $i == 0){\n            $max = $i;\n      \
    \  }\n    }\n    return $max;\n}", "    my $smallest = -1;\n    my $largest =\
    \ -1;\n    for(my $i = 0; $i < $n; $i++) {\n        my $current = ($n % $i);\n\
    \        next if($current != 0 && $current > $largest);\n        $largest = $i;\n\
    \    }\n    return $largest;\n}", '    return 1 unless $n;', "    my $max_div_num\
    \ = $n;\n    my $max_div = $n;\n    my $cur_div = 0;\n    for (my $i = 1; $i <=\
    \ $n; $i++) {\n        if ($n % $i == 0) {\n            $cur_div = $i;\n     \
    \   }\n        if ($cur_div > $max_div) {\n            $max_div = $cur_div;\n\
    \            $max_div_num = $n;\n        }\n    }\n    return $max_div_num;\n}",
  "    if ($n == 0) {\n        return 0;\n    }\n    my (@div) = (1, 1, 2, 3, 5, 8);\n\
    \    my $max_div;\n    my $i;", "    my $count = 0;\n    for (my $i = 1; $i <=\
    \ $n; $i++) {\n        if ($n % $i eq 0) {\n            $count = $i;\n       \
    \ }\n    }\n    return $count;\n}", '    my($max_div);', "    my $divisor = 0;\n\
    \    while (! ($n%$divisor)) {\n        $divisor++;\n    }\n    return $divisor;\n\
    }", "    my $nn = $n;\n    my $res = 1;\n    my $temp;\n    while ($nn > 0) {\n\
    \        my $n = int(sqrt($nn));\n        if ($nn % $n == 0) {\n            $res\
    \ = $n;\n            $temp = $nn;\n        }\n        $nn = $n;\n    }\n    return\
    \ $temp;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,math,python,perl,ruby |>\n\
    One more solution in perl\n<code>", "    my $res = $n;\n    for(my $d = 2; $d\
    \ <= $n; ++$d) {\n        if(($n % $d) == 0) {\n            $res = $d;\n     \
    \       last;\n        }\n    }\n    return $res;\n}\n</code>\nIt returns the\
    \ correct result for any number smaller than $max_divisor. \n<code>\nuse strict;\n\
    use warnings;\nuse bignum;", "    my $max_divisor = $n;\n    my $max_divisor2\
    \ = $n;\n    while (true) {\n        if ($max_divisor2 % 2 == 0) {\n         \
    \   last if ($max_divisor2 > $max_divisor);\n            my $max_divisor3 = $max_divisor;\n\
    \            my $max_divisor4 = $max_divisor2;\n            while ($max_divisor3\
    \ % 3 == 0) {\n                $max_divisor4 += 2;\n                $max_divisor3\
    \ -= 3;\n            }\n            if ($max_divisor3 > $max_divisor) {\n    \
    \            $max_divisor = $max_divisor3;\n            }\n            else {\n\
    \                $max_divisor = $max_divisor4;\n            }\n        }\n   \
    \     else {\n            last if ($max_divisor2 > $max_divisor);\n          \
    \  my $max_divisor3 = $max_divisor;\n            my $max_divisor4 = $max_divisor2;\n\
    \            while ($max_divisor4 % 4 == 0) {\n                $max_divisor3 +=\
    \ 2;\n                $max_divisor4 -= 4;\n            }\n            if ($max_divisor4\
    \ > $max_divisor) {\n                $max_divisor = $max_divisor4;\n         \
    \   }\n            else {\n                $max_divisor = $max_divisor3;\n   \
    \         }\n        }\n    }\n    $max_divisor;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
