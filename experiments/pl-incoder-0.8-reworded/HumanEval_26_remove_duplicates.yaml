name: HumanEval_26_remove_duplicates
language: pl
prompt: "# From an array of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\n# >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n# [1, 3, 4]\nsub remove_duplicates {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_duplicates;\n\
  \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 2,\
  \ 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 2, 4, 3, 5]),[1, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    # Copy numbers to remove from output array.\n    my(@unique) =\
    \ map { ++$_ } @$numbers;\n    my $num;\n    while ($num = $numbers[0]) {\n  \
    \      $numbers[0] =~ s/^$num//;\n        my $pos = -1;\n        for (@unique)\
    \ {\n            ++$pos if $_ eq $num;\n        }\n        splice( @unique, $pos,\
    \ 1 );\n    }\n    return @unique;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=0\
    \ |>\nThis is what I would do for your specific example.\n<code>", "    my @uniques;\n\
    \    foreach (@$numbers) {\n        push (@uniques, $_) if !($uniques[-1] =~ /$_/);\n\
    \    }\n    return @uniques;\n}", "    my $array_ref;\n    if (ref $numbers eq\
    \ 'ARRAY') {\n        $array_ref = $numbers;\n    } elsif (ref $numbers eq 'HASH')\
    \ {\n        $array_ref = [@{$numbers}];\n    } else {\n        $array_ref = [$numbers];\n\
    \    }", "    my @result;\n    my $cnt = 0;\n    foreach my $n (@$numbers) {\n\
    \        $cnt++;\n        if($cnt) {\n            push @$result, $n;\n       \
    \ }\n    }\n    return @$result;\n}", "    my @results;\n    \n    for my $number\
    \ (@$numbers) {\n        push @results, $number unless $results[$number] == 1;\n\
    \        $results[$number] = 1;\n    }\n    \n    return @results;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI believe you meant `$results[$number] == 0` instead\
    \ of `$results[$number] == 1`. And this does not preserve the order of the elements.\n\
    <|/ c |>\n<| c |>\nI thought that the order would be preserved using the `sort`\
    \ method.\n<|/ c |>\n<| c |>\nPerhaps I am misunderstanding something, but this\
    \ solution does not preserve the order of the elements.\n<|/ c |>\n<| c |>\nThanks,\
    \ I fixed that part. I was thinking the order was preserved when I originally\
    \ wrote it when I wrote it last year.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nuse\
    \ strict;\nuse warnings;\nuse 5.010;", "    $numbers |= ();\n    my @seen;\n \
    \   for (@$numbers) {\n        push (@seen, $_) unless $seen[$_];\n        $seen[$_]\
    \ = 1;\n    }\n    return @$numbers;\n}", "    my @unique = ();\n    my @duplicated\
    \ = ();\n    $#unique = $#numbers;\n    my $last_value = $numbers[-1];\n    foreach\
    \ my $num (@$numbers) {\n        push (@unique, $num);\n        $num = $last_value\
    \ if $unique[$#unique - 1] != $num;\n        push (@duplicated, $num);\n    }\n\
    \    return @unique;\n}", "    my $hash;\n    my @output;", "    my %seen;\n \
    \   grep {! $seen{$_}++} @$numbers;\n}", "    my %unique;\n    my @output;\n \
    \   my $size = scalar @$numbers;\n    my $i = 0;\n    for (my $i = 0; $i < $size;\
    \ ++$i) {\n        my $value = $numbers->[$i];\n        if (! defined $unique{$value})\
    \ {\n            $unique{$value} = $i;\n            push @output, $value;\n  \
    \      }\n    }\n    return @output;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\n\
    This is much slower than my solution, which is a good compromise between the two,\
    \ although the code does have fewer lines.\n<|/ c |>\n<| c |>\n: I timed your\
    \ solution, and it was indeed much slower than mine. I did some more testing and\
    \ the time it took to run your solution increases linearly with the size of the\
    \ list: about `O(n log n)` for `remove_duplicates` and about `O(n)` for `remove_repetitive`,\
    \ so the overall performance of mine is `O(n log n)`.\n<|/ c |>\n<| c |>\nInteresting.\
    \ That makes sense. I did find that mine did give the correct output for [remove_duplicates([1,\
    \ 2, 3, 2, 4])] but would give incorrect output for [remove_duplicates([1, 2,\
    \ 3, 2]]. I can't quite reproduce that though... Are you running it on 5.10 or\
    \ 5.11? Mine would give me [1,2,3] on 5.10 and 5.11. I'll check with my lab guy.\n\
    <|/ c |>\n<| c |>\nYes, I'm running it on 5.10. The output I get is `[1, 2, 3]`.\
    \ I don't know what happened; I must have mistyped something, or perhaps I made\
    \ a mistake when running the tests. :-)\n<|/ c |>\n<| c |>\nAh, it must be the\
    \ way the two tests were run. I ran remove_duplicates([1, 2, 3]) three times,\
    \ and the final result was `[1, 2]` on the last run.\n<|/ c |>\n<| a |>\nUse List::MoreUtils::uniq:\n\
    <code>\nuse strict;\nuse warnings;\nuse 5.010;\nuse List::MoreUtils qw(uniq);",
  "    \n    my @unique = ();", '    my(@result);', '    $numbers = @$numbers if scalar
    @$numbers == 0;', "    my (@unique, %seen);\n    foreach my $number (@$numbers)\
    \ {\n        next unless $seen{$number}++;\n        push @unique, $number;\n \
    \   }\n    return @unique;\n}", "    my @unique;\n    $numbers->[..$#$numbers]\
    \ = grep !exists $unique[$_], 0..$#$numbers;\n    return @unique;\n}", "    my($i,\
    \ $result);\n    for($i = 0; $i < @$numbers; $i++) {\n        $result = $numbers[$i]\
    \ if $numbers[$i] >= $numbers[$i - 1];\n        $numbers[$i] = $result;\n    }\n\
    \    return @$numbers;\n}\n</code>\n<|/ a dscore=3 tags=perl,algorithm |>\n<|\
    \ c |>\nI think this would be much easier with the \"use List::MoreUtils\" module.\n\
    <|/ c |>\n<| c |>\nI haven't used that, but I'll look into it.  Thanks!\n<|/ c\
    \ |>\n<| c |>\nI didn't think of that. I guess it would require the module to\
    \ be installed.\n<|/ c |>\n<| c |>\nYou can install it on Linux and OSX using\
    \ `cpanm List::MoreUtils` but I'm not sure about Windows.  Perhaps you can compile\
    \ it yourself.\n<|/ c |>\n<| c |>\nYou were right.  I just tried `cpanm List::MoreUtils`\
    \ in Windows, and it installed without problems.  Thanks!\n<|/ c |>\n<| a tags=perl,algorithm\
    \ |>\nThe most straightforward way would be to sort the array and then remove\
    \ duplicates:\n<code>\nmy = sort { $a <=> $b } @$array;\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThe question is \"how to remove duplicates\", not \"how to sort\"\
    \n<|/ c |>\n<| c |>\nThe title says so, but I guess it is misleading. The question\
    \ doesn't say \"remove duplicates\" but \"find duplicates\"\n<|/ c |>\n<| c |>\n\
    The title says \"find duplicates\" too. But the question doesn't say \"find duplicates\"\
    , but \"remove duplicates\".\n<|/ c |>\n<| c |>\nI agree that it does say \"remove\
    \ duplicates\".  I guess I was just trying to be helpful.  I like your solution\
    \ though.\n<|/ c |>\n<| c |>\nBy the way, this answer doesn't use anything from\
    \ the standard Perl library, so I guess it's not that bad!  I just wanted to point\
    \ it out in case someone else took a crack at it.  Thanks!\n<|/ c |>\n<| a dscore=2\
    \ |>\nA solution from List::MoreUtils that doesn't sort.\n<code>\nuse List::MoreUtils\
    \ qw{ uniq };", "    my @uniques;\n    my $unique = 1;\n    my @counters;\n  \
    \  my $number;\n    foreach $number (@$numbers) {\n        next if $unique++ ==\
    \ 1;\n        push @uniques, $number;\n        push @counters, 1;\n    }\n   \
    \ return @uniques;\n}", "    my @seen;\n    my $result;", "    my %seen;\n   \
    \ my @output;", "    my @unique_numbers = ();\n    my @counts;\n    my $index\
    \ = 0;", "    my $length = $#{$numbers};\n    for (my $i = 0; $i < $length; $i++)\
    \ {\n        my $element = $numbers[$i];\n        if ($seen{$element}) {\n   \
    \         splice @$numbers, $i, 1;\n            --$length;\n        }\n      \
    \  else {\n            $seen{$element} = 1;\n        }\n    }\n    return @$numbers;\n\
    }", "    my @seen;\n    foreach my $number (@$numbers) {\n        if (not $seen{$number})\
    \ {\n            $seen{$number} = 1;\n        } else {\n            delete $seen{$number};\n\
    \        }\n    }\n    return sort keys %seen;\n}", "    $numbers = sort {$a <=>\
    \ $b} @$numbers;\n    my($result, $num, $i);\n    for(my $i = 1;$i < scalar(@$numbers);$i++)\
    \ {\n        $num = $numbers[$i];\n        for(my $j = $i + 1;$j < scalar(@$numbers);$j++)\
    \ {\n            if($num == $numbers[$j]) {\n                splice @$numbers,\
    \ $i, 1;\n                last;\n            }\n        }\n    }\n    $result\
    \ = join ',', @$numbers;\n    $result =~ s/^,//;\n    $result;\n}", "    my @seen;\n\
    \    $numbers++ # Don't want to remove the first element\n    foreach my $n (@$numbers)\
    \ {\n        next if $seen[$n];\n        $seen[$n] = 1;\n        push(@$numbers,\
    \ $n) if $n <= 1;\n    }\n    @$numbers = reverse @$numbers if $#seen;\n    return;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl,arrays |>\nUsing List::MoreUtils:\n\
    <code>", "    my %seen;\n    foreach my $num (@$numbers) {\n\tif ($seen{$num})\
    \ {\n\t    delete $seen{$num};\n\t}\n\telse {\n\t    $seen{$num} = 1;\n\t}\n \
    \   }\n    return [grep !$seen{$_}, @$numbers];\n}", "    my %seen;\n    \n  \
    \  @$numbers = grep { !$seen{$_}++ } @$numbers;\n    return @$numbers;\n}", " \
    \   my %seen;\n    my @duplicates;\n    for(@$numbers) {\n        if (!$seen{$_}++)\
    \ {\n            push(@duplicates, $_);\n        }\n    }\n    return @duplicates;\n\
    }", "    return [] unless @$numbers;\n    @$numbers = grep { ++$seen{$_} <= $#_\
    \ } (sort @$numbers);\n    return @$numbers;\n}", '    my @output;', "    my %seen;\n\
    \    return @$numbers if @$numbers == 1;\n    \n    my $prev_value = $numbers[0];\n\
    \    \n    for my $number (@$numbers) {\n        return @$numbers if $seen{$number}\
    \ || $number eq $prev_value;\n        \n        $prev_value = $number;\n     \
    \   $seen{$number}++;\n    }", "    my $result = ();\n    my $i = 0;\n    for\
    \ (@$numbers) {\n        $result[$i] = $_;\n        $i++;\n        next if $result[$i]\
    \ eq $_;\n    }\n    return @$result;\n}", "    my $result = [];\n    my $counter\
    \ = 1;\n    while (@$numbers) {\n        my $new_number = 0;\n        for my $number\
    \ (@$numbers) {\n            ($new_number += $number) == 1 ? $numbers[$new_number]\
    \ = undef : $new_number++;\n        }\n        $counter++;\n    }\n    return\
    \ $result;\n}", "    my %seen;\n    my @result;\n    foreach my $num (@$numbers)\
    \ {\n        if (!exists $seen{$num}) {\n            push(@result, $num);\n  \
    \          $seen{$num} = 1;\n        }\n    }\n    return @result;\n}", "    my\
    \ @new_numbers;\n    my $index = 0;\n    my $j;", "    my @unique = ();\n    my\
    \ $count_i = 0;\n    \n    for my $number (@$numbers) {\n        if (!exists($unique[$number]))\
    \ {\n            $unique[$number] = $count_i;\n        }\n        $count_i++;\n\
    \    }\n    \n    return @unique;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c\
    \ |>\nI love how this was just two lines of code! One note though, you don't need\
    \ the leading `;` in the `for` loops, as the `if` statements don't require it\
    \ anyway.\n<|/ c |>\n<| c |>\nThanks, I've been using Perl for a few years now,\
    \ but never came across this solution! It's very elegant, it just so happened\
    \ that I was working on a similar problem and came across this solution. Thanks\
    \ a bunch!\n<|/ c |>\n<| a dscore=2 tags=perl,arrays |>\n<code>", "    my(@result)\
    \ = ();\n    my($last_number);", "    my $hash;\n    my $i=0;\n    my $count =\
    \ scalar( @$numbers );\n    while ($i < $count) {\n        my $j = $i + 1;\n \
    \       $hash->{ $numbers[$i] } = $numbers[$j];\n        $i++;\n    }", "    my\
    \ @out;\n    $numbers->[grep { !$seen{$_}++ } @$numbers] = undef;\n    push(@out,\
    \ @{$numbers->[0]});\n    return wantarray ? @out : $out[0];\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI'm new to perl, but this seems to be the right way\
    \ to go (thanks!). My current code reads a file, which I then pipe into this subroutine.\
    \ I was wondering if this could be done in one go?\n<|/ c |>\n<| a |>\n<code>\n\
    use List::Util 'uniq';", "    my %seen;\n    \n    # Don't use grep for this as\
    \ that's not a builtin\n    foreach my $n (@$numbers) {\n        my $exists;\n\
    \        foreach my $key (keys %seen) {\n            if ($seen{$key} eq $n) {\n\
    \                $exists = 1;\n            }\n        }\n        \n        if\
    \ (! $exists) {\n            $seen{$n} = 1;\n        }\n    }\n    \n    return\
    \ values %seen;\n}\n</code>\n<|/ a |>\n<| c |>\nI wish there was a way to upvote\
    \ you more than once. Thank you!\n<|/ c |>\n<| c |>\nYou're welcome.  I only have\
    \ 6 months reputation so don't forget to come back and upvote once you can.  (Though\
    \ maybe not until you have 15+ rep.)\n<|/ c |>\n<| a tags=arrays,perl |>\nTry\
    \ this one:\n<code>\nuse strict;\nuse warnings;", "    my @res;\n    foreach my\
    \ $number (@$numbers) {\n        unless (defined $res[$number]) {\n          \
    \  push @res, $number;\n        }\n    }\n    return @res;\n}", "    my @uniques;\n\
    \    $_ for (sort { $a <=> $b } @$numbers);\n    $_\n}", "    my $hash = {};\n\
    \    foreach my $number (@$numbers) {\n        if (!defined $hash->{$number})\
    \ {\n            $hash->{$number} = 1;\n        } else {\n            $hash->{$number}++;\n\
    \        }\n    }\n    my @result = ();\n    foreach my $key (keys %$hash) {\n\
    \        push @result, $key;\n    }\n    return @result;\n}", '    my(@unique,
    @seen);', "    my @return = ();\n    my @hash;\n    my $key;\n    my $count;",
  "    my @output;\n    my $seen;\n    my @seen_next;\n    \n    foreach my $num (@$numbers)\
    \ {\n        if (not exists $seen{$num}) {\n            $seen{$num} = 1;\n   \
    \         $seen_next[$#seen_next] .= $num;\n        }\n    }\n    \n    for (my\
    \ $i = 0; $i < $#seen_next; $i++) {\n        if ($seen{$seen_next[$i]} > 1) {\n\
    \            push(@output, delete $seen{$seen_next[$i]});\n        }\n    }\n\
    \    \n    return @output;\n}", "    my @unique;\n    my $idx = 0;\n    my $last_seen;\n\
    \    while ($idx < @$numbers) {\n        if ($numbers[$idx] != $last_seen) {\n\
    \            $last_seen = $numbers[$idx];\n            $unique[$idx] = $numbers[$idx];\n\
    \            $idx++;\n        }\n    }\n    return @unique;\n}\n</code>\n<|/ a\
    \ tags=hash,sorting,perl,arrays dscore=4 |>\n<| c |>\nI don't understand how that\
    \ sorts the elements in the array. What is the order for sorting?\n<|/ c |>\n\
    <| c |>\nWhat do you mean by \"order for sorting\"? If you mean how it is sorted\
    \ when displayed, it is sorted. Think of it as an array of unique elements, in\
    \ the original order (not the order of unique elements).\n<|/ c |>\n<| c |>\n\
    `sort { $a <=> $b }` would sort by lexicographical order (case insensitive), which\
    \ would not work for the OP's example because `1` comes before `3`.\n<|/ c |>\n\
    <| c |>\n: You are absolutely right! I guess I thought of \"hash table\" as something\
    \ that remembers things in sorted order, and was surprised to find that it doesn't\
    \ behave like that. I've updated the answer to avoid confusing that with the order\
    \ of hash keys (the one returned by the `keys()` method).\n<|/ c |>\n<| a tags=hash,sorting,perl,arrays\
    \ |>\n<code>\nmy;\nmy %hash;\nfor (@array) {\n    push, $_ if $hash{$_};\n   \
    \ $hash{$_} = 1;\n}\nmy = map { ($hash{$_} ? $_ : ()) };\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\nHere is another way to remove duplicates by sorting the\
    \ array before removing duplicates. \n<code>", "    my @sorted = sort {$a <=>\
    \ $b} @$numbers;\n    return @sorted;\n}", "    \n    @$numbers = grep { !$seen{$_}++\
    \ } @$numbers;\n    return @$numbers;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "    # Don't modify original array and don't bother copying.\n    my @unique_numbers\
    \ = @$numbers;", "    my;\n    my $unique = 0;\n    for(@$numbers) {\n       \
    \ push(@keep, $_) if $unique++ == 1;\n    }\n    return @keep;\n}\n</code>\n<|/\
    \ a tags=perl,arrays,unique dscore=5 |>\n<| c |>\nThis solution modifies the input!\
    \ I suggest using `@keep` instead of `@$numbers` in the `push` statement.\n<|/\
    \ c |>\n<| c |>\n: Good point - edited to use `@keep`. Thanks for the comment.\n\
    <|/ c |>\n<| c |>\n: This is just an answer to an old question. Perhaps I shouldn't\
    \ comment on questions I answered, but this was a recent question that I found\
    \ this information on at PerlMonks, so I figured I'd post it here. YMMV.\n<|/\
    \ c |>\n<| c |>\nThis is nice, but has the side effect of sorting the array. `@$numbers\
    \ = sort { ... } @$numbers`\n<|/ c |>\n<| c |>\n: I haven't tested it, but it\
    \ would seem that `@$numbers = sort { ... } @$numbers` will return a sorted array\
    \ without actually changing the contents of `@$numbers`.\n<|/ c |>\n<| a dscore=5\
    \ |>\nIn Perl, you can use grep for this:\n<code>\nmy = grep { !$seen{$_}++ };\n\
    </code>\nThe grep expression evaluates to true if the element is not already seen,\
    \ and false if it is.  The $seen{$_}++ will increment  the value associated with\
    \ $_ on the first occurrence of each element to 1, so when the value gets to 2,\
    \ it will evaluate to false.  Since grep returns all elements for which the expression\
    \ is true, the resulting array contains all unique elements in order.\n<|/ a tags=perl,arrays,unique\
    \ |>\n<| c |>\nAs a small nitpick: grep is usually faster than looping over the\
    \ array and pushing onto a new array.\n<|/ c |>\n<| c |>\nThis solution modifies\
    \ the input.\n<|/ c |>\n<| c |>\n: I agree, it's unfortunate that it modifies\
    \ it - but it does return a new array with the unique elements, in order, rather\
    \ than just modifying the input array in place.\n<|/ c |>\n<| c |>\n+1 for teaching\
    \ me a Perl operator, that's been my go-to for ages. Not sure if I should down-vote\
    \ your answer though, just to push my vote on the question :)\n<|/ c |>", "  \
    \  my($result);\n    my $index = 0;\n    foreach (@$numbers) {\n        if (++$index\
    \ <= 1) {\n            push(@$result, $_);\n        }\n    }\n    return @$result;\n\
    }", "    my @duplicates = ();\n    for my $number (@$numbers) {\n\t++$duplicates[$number]\
    \ if exists $duplicates[$number];\n    }\n    return @$numbers if @$numbers ==\
    \ @$duplicates;\n    return @$duplicates;\n}", "    my @new_numbers;\n    $numbers[-1]\
    \ unless @$numbers == 0;\n    for(my $i = 1; $i <= $#{$numbers};  $i++){\n   \
    \     my $number = $numbers[$i];\n        for(my $j = $i + 1; $j <= $#{$numbers};\
    \  $j++){\n            next unless $numbers[$i] == $numbers[$j];\n        }\n\
    \        push(@new_numbers, $numbers[$i]);\n    }\n    return @new_numbers;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis looks good, except you need to remove\
    \ the numbers at the end of the array.  It may have to be done manually.\n<|/\
    \ c |>\n<| c |>\n, It doesn't have to be done manually. You simply remove them\
    \ by writing `@new_numbers -= [@numbers[$i..$#numbers]]` after the `if` conditional.\n\
    <|/ c |>\n<| a tags=arrays,perl |>\nA solution that uses hashes to handle a O(n)\
    \ solution.\nThe key is to use hashes to avoid searching for duplicates and to\
    \ handle them later.\nThe code is commented so you can understand it better.\n\
    <code>\nuse strict;\nuse warnings;", "    return @$numbers if scalar @$numbers\
    \ == 1;\n    my $counter = scalar @$numbers;\n    my @out;\n    my $last_elem\
    \ = scalar @$numbers - 1;\n    for (my $i = 0; $i < $counter; $i++) {\n      \
    \  if ($numbers[$i] != $last_elem) {\n            $out[$i] = $numbers[$i];\n \
    \       } else {\n            $out[$i] = 0;\n        }\n    }\n    return @out;\n\
    }", "    my $i = 0;\n    my @output;\n    while($i < scalar(@$numbers)) {\n  \
    \      my $value = $numbers->[$i];\n        while($i < scalar(@$numbers) && $numbers->[$i]\
    \ == $value) {\n            $i++;\n        }\n        push, $value;\n    }\n \
    \   return @output;\n}\n</code>\nThe first solution iterates over your array two\
    \ times. The second solution iterates over your array just one time.\n<|/ a tags=perl,arrays\
    \ |>\n<| a tags=perl,arrays |>\nHere is a solution using grep + sort:\n<code>\n\
    my = sort grep { ! $.++ % 2 }; \n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Use a hash to find out if the item has already been added or not.\n<code>", '    my
    @ordered_numbers;', "    my(@result) = ();\n    my(@unique) = (0);\n    for(my\
    \ $i = 0; $i < @$numbers; $i++) {\n        my $num = $$numbers[$i];\n        if(!exists($unique[$num]))\
    \ {\n            push(@result, $num);\n            push(@unique, $num);\n    \
    \    }\n    }\n    return @result;\n}", "    my @output;\n    my $i = 0;\n   \
    \ for (my $i = 0; $i < scalar(@$numbers); $i++) {\n        my $number = $numbers[$i];\n\
    \        unless ($seen{$number}++) {\n            $output[$i] = $number;\n   \
    \     }\n    }\n    return @output;\n}\n</code>\n<|/ a tags=perl,arrays,algorithm\
    \ |>\n<| c |>\nVery nice, thanks! I'll try to modify it so that it would work\
    \ with hashes too. :)\n<|/ c |>\n<| a |>\n<code>", "    my @res;\n    my $index\
    \ = 0;", "    my @output;\n    my $i = 0;\n    foreach my $number (@$numbers)\
    \ {\n        push @output, if ($i && $number eq $numbers[$i]);\n        $i++;\n\
    \    }\n    return wantarray ? @output : $output[0];\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nHere's a Perl solution that returns a sorted array:\n<code>\n\
    use strict;\nuse warnings;", "    my @uniques;\n    foreach my $n (@$numbers)\
    \ {\n        unless(grep {$_ == $n}) {\n            push @uniques, $n;\n     \
    \   }\n    }\n    return @uniques;\n}", "    my @unique_numbers;\n    for my $number\
    \ (@$numbers) {\n        if (grep {$_ eq $number} @unique_numbers) {\n       \
    \     $unique_numbers{$number}++;\n        }\n        else {\n            $unique_numbers{$number}\
    \ = 1;\n        }\n    }\n    return wantarray ? %$unique_numbers : $unique_numbers;\n\
    }", "    my @new_numbers;\n    my %seen;\n    for (@$numbers) {\n        $seen{$_}++;\n\
    \        push(@new_numbers, $_) unless $seen{$_};\n    }\n    return @new_numbers;\n\
    }", "    $numbers = grep { !$seen{$_}++ } @$numbers;\n    return @$numbers;\n}",
  "    my($count) = 0;\n    my($output);\n    foreach my $num (@$numbers) {\n    \
    \    $count++ if $output->[$count] eq $num;\n        $output->[$count] = $num\
    \ if $count < @$output;\n    }\n    return @$output;\n}", "    my @unique;\n \
    \   my @seen;\n    foreach my $n (@$numbers) {\n        if (not exists $seen[$n])\
    \ {\n            push(@unique, $n);\n            push(@seen, $n);\n        }\n\
    \    }\n    return @unique;\n}", '    my @unique = ();', "    my $seen = {};\n\
    \    return grep { !$seen{$_} ? ($seen{$_}++, 1) > 1 : 1 } @$numbers;\n}", " \
    \   my @output;\n    foreach my $number (@$numbers) {\n        push(@output, $number);\n\
    \        next if $seen{$number}++;\n    }\n    return wantarray ? @output : $output[0];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNot sure I understand this solution. Can\
    \ you show how you use it?\n<|/ c |>\n<| c |>\nI guess I didn't explain well enough.\
    \ This solution doesn't eliminate the duplicates, instead it takes the unique\
    \ elements only. Thus, it would take `1`, `2` and `3` in the input array and put\
    \ them in the result array.\n<|/ c |>\n<| c |>\nYes, I see that. Sorry for the\
    \ confusion. Still, this doesn't completely remove duplicates. It is more like\
    \ \"de-duplicates\" than \"remove\" as in, no two elements can be the same. For\
    \ example, `[1,2,2,3]` would become `[1,2,3]`. And `[1,2,3,4]` would become `[1,3,4]`.\n\
    <|/ c |>\n<| c |>\nI agree with you. I added a comment in the code explaining\
    \ the behavior of it.\n<|/ c |>\n<| c |>\nNo, `[1,2,3,4]` is already \"de-duplicated\"\
    \ with `[1,2,3]`. To achieve that, you need to \"remove\" all the duplicates from\
    \ the original list. This is a trivial task in which you simply loop over it and\
    \ add a new element if one wasn't already in the list.\n<|/ c |>\n<| a tags=perl,duplicates\
    \ |>\nHere's a way to solve this problem. \nIt takes the input file as an argument,\
    \ reads it into an array and stores the unique elements in another array.\n<code>\n\
    use strict;\nuse warnings;", "    my @unique = ();\n    foreach my $num (@$numbers)\
    \ {\n        if (grep {$_ eq $num} @unique) {\n            next;\n        }\n\
    \        push(@unique, $num);\n    }\n    return @unique;\n}", "    my @return\
    \ = ();\n    my $count = 0;\n    foreach my $number (@$numbers) {\n        if\
    \ ($count < $number) {\n            $count = $number;\n            $return[$number-1]\
    \ = $number;\n        }\n    }\n    return \\@return;\n}", "    my @seen;\n  \
    \  my @result;\n    for my $number (@$numbers) {\n        if (! exists $seen{$number})\
    \ {\n            $seen{$number}++;\n            push(@result, $number);\n    \
    \    }\n    }\n    return wantarray ? @result : $result[0];\n}", "    my @unique_elements\
    \ = ();\n    my $previous_index = -1;\n    my $unique_index = -1;\n    for my\
    \ $index (0 .. $#$numbers) {\n        if ($unique_elements{$previous_index} eq\
    \ $numbers[$previous_index]) {\n            $unique_index++;\n        } else {\n\
    \            $unique_elements{$previous_index} = $numbers[$previous_index];\n\
    \            $unique_index = 1;\n        }\n        $previous_index = $index;\n\
    \    }\n    return @unique_elements;\n}\n</code>\n<|/ a |>\n<| c |>\nthanks for\
    \ the answer, but I don't want a hash of duplicate values. I want to keep order\
    \ of elements left the same as in the input\n<|/ c |>\n<| c |>\nYes, I see what\
    \ you mean.  I'll add code to my answer.\n<|/ c |>\n<| c |>\nI added code to do\
    \ that.  I didn't even know you could use references in `unique` like that.\n\
    <|/ c |>\n<| a |>\n<code>\nperl -lne 'push, $_; say for uniq(@a)' file\n</code>\n\
    or \n<code>\nperl -ane 'push, $F[0]; say for uniq(@a)' file\n</code>\n<|/ a dscore=0\
    \ tags=unix,perl,arrays,sorting |>\n<| c |>\nthanks for the answer, but I don't\
    \ want a hash of duplicate values. I want to keep order of elements left the same\
    \ as in the input\n<|/ c |>\n<| c |>\n: I added a version to keep original order\
    \ of elements. And it works with sorted input\n<|/ c |>\n<| c |>\nthanks for the\
    \ answer. I don't want to use another array to keep original order. Is it possible\
    \ with grep or grepW?\n<|/ c |>\n<| c |>\n: I added a version to keep the original\
    \ order of elements. I guess it uses grep and grepW\n<|/ c |>\n<| c |>\nthanks\
    \ for the answer. Is it possible to remove duplicates using grep or grepW?\n<|/\
    \ c |>\n<| a dscore=0 |>\nI would use Tie::IxHash and then use uniq:\n<code>\n\
    use strict;\nuse warnings;\nuse Tie::IxHash;", "    # Create a hash table of the\
    \ numbers\n    # keys are the numbers themselves, values are the count\n    my\
    \ %counts;\n    $counts{$_}++ for;\n    return sort grep $counts{$_} > 1, keys\
    \ %counts;\n}", "    my %seen = ();\n    foreach my $num (@$numbers) {\n     \
    \   $seen{$num}++;\n    }\n    my @result = ();\n    foreach my $num (keys %seen)\
    \ {\n        push @result, $num;\n    }\n    return @result;\n}", '    my(@result)
    = ();', "    my @removed = ();\n    my $i = 0;\n    my $j = 0;\n    my $remove\
    \ = ();\n    while (@$numbers) {\n        push(@removed, shift(@$numbers));\n\
    \        $i++;\n        $j++;\n        while (@$numbers && $i ne $j) {\n     \
    \       push(@removed, shift(@$numbers));\n            $i++;\n            $j++;\n\
    \        }\n    }\n    return @removed;\n}", "    my @unique = ();\n    my $i\
    \ = 0;\n    for (@$numbers) {\n        if (!exists $unique[$i]) {\n          \
    \  $unique[$i++] = 1;\n        }\n    }\n    return @unique;\n}", '    my @return
    = ();', "    return [ grep { !$numbers->[$_]++} 0 .. @$numbers - 1];\n}", "  \
    \  my @result;\n    my $index = 0;\n    while (@$numbers) {\n        my $value\
    \ = $numbers[$index];\n        push @result, $value if ($result[$index] == $value);\n\
    \        $index++;\n    }\n    return @result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThe `@result =` can be written `@result if !$result[$index] or $result[$index]\
    \ == $value`\n<|/ c |>\n<| c |>\n: Yes, that's a better way to express it. I wanted\
    \ to keep it close to his code, but that's more readable.\n<|/ c |>\n<| c |>\n\
    `@result =` can be written `@result if !$result[$index] or $result[$index] ==\
    \ $value`\n<|/ c |>\n<| c |>\nHis code would produce an empty array if all elements\
    \ are unique. It may be a good idea to change the return value from empty array\
    \ to `undef` so it will not break code which expects it to have at least 1 element.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. I changed it to `undef` since that's\
    \ what the function says. Thanks.\n<|/ c |>\n<| a tags=perl,arrays,duplicate-removal\
    \ |>\nTo avoid the complexity of sorting the list and using a hash, I suggest\
    \ using the following approach, using Perl's unique array operator.\n<code>",
  "    my($result) = [];\n    for (@$numbers) {\n        if (not exists $seen{$_})\
    \ {\n            $seen{$_} = 1;\n            $result->[$_] = 1;\n        }\n \
    \   }\n    return @$result;\n}\n</code>\n<|/ a dscore=1 tags=perl,arrays,hash,duplicates\
    \ |>\n<| a |>\nYou can do this using Hash::MultiValue :\n<code>\nuse Hash::MultiValue;\n\
    my = qw(a b c a e f c a b c d f e f c e d);\nmy $hm = Hash::MultiValue->new(\\\
    @keys);\n$hm->remove_duplicates\nprint join(\"\\n\",$hm->values()),\"\\n\";\n\
    </code>\nOutput:\n<code>\na\ne\nc\nd\nf\n</code>\n<|/ a tags=perl,arrays,hash,duplicates\
    \ dscore=0 |>\n<| c |>\nThis is wrong. Your output does not contain duplicates.\n\
    <|/ c |>\n<| c |>\n- It's not a very good solution. The OP wants to \"remove duplicates\"\
    \ from the input array and leave the duplicate elements in the output, and your\
    \ code will remove *all* duplicates. See the answer to [**this question**](http://stackoverflow.com/questions/16343079/how-to-delete-duplicates-from-array-in-perl).\n\
    <|/ c |>\n<| a dscore=0 tags=perl,arrays,hash,duplicates |>\nOne way would be:\n\
    <code>\nmy = qw(a b c a e f c a b c d f e f c e d);\nmy %hash;\nmap { $hash{$_}++\
    \ };\nmy = grep { not $hash{$_} };\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI didn't\
    \ know about this module before. It looks very useful, and I have found that it's\
    \ fairly simple to implement yourself.\nThe first thing you should know is that\
    \ the hash key will only be set once. So we need to create a second hash that\
    \ will track our unique keys.\n<code>\nuse strict;\nuse warnings;", "    my();\n\
    \    my $counter = 0;\n    my $value;", "    my @new_numbers = ();\n    my $count\
    \ = 0;\n    \n    foreach my $number (@$numbers) {\n        ++$count;\n      \
    \  push @new_numbers, $number if $number > 1;\n    }\n    \n    return @new_numbers;\n\
    }", "    my @return_list;\n    my $index = 0;", '    my($result) = [];', "   \
    \ my %seen;\n    my @uniques;\n    foreach my $i (@$numbers) {\n        $seen{$i}++\
    \ if $seen{$i} == 1;\n        push @uniques, $i unless $seen{$i};\n    }\n   \
    \ @$numbers = @uniques;\n    return $numbers;\n}", "    my @unique;\n    my $number\
    \ = 0;\n    foreach $number (@$numbers) {\n        if (!$unique[$number]) {\n\
    \            $unique[$number] = 1;\n        }\n    }\n    return @unique;\n}",
  "    my(@unique) = ([]);\n    my $j = 0;\n    for(my $i = 0; $i < @$numbers; $i++)\
    \ {\n        ++$j;\n        for(my $n = 0; $n < $j; $n++) {\n            if($numbers[$i]\
    \ eq $unique[$n]) {\n                splice @$numbers, $i, 1;\n              \
    \  splice @unique, $n, 1;\n                last;\n            }\n        }\n \
    \   }\n    return @unique;\n}", "    my @result;\n    my %seen = ();", "    my\
    \ @numbers;\n    my $seen = 0;\n    foreach my $num (@$numbers) {\n        if($seen++\
    \ == 1) { $seen++; push (@numbers, $num); }\n    }\n    @$numbers = @numbers;\n\
    }", "    my @seen;\n    foreach my $num (@$numbers) {\n        if (not defined\
    \ $seen[$num]) { $seen[$num] = 1; }\n        else { $seen[$num] = $seen[$num]\
    \ + 1; }\n    }\n    $numbers = map { $seen[$_] > 1 ? $_ : () } @$numbers;\n \
    \   return @$numbers;\n}", "    my @result;\n    my $hash;", "    my $unique_numbers\
    \ = undef;\n    for (@$numbers) {\n        my $unique = 1;\n        for (@$unique_numbers)\
    \ {\n            if ($_ eq $_) {\n                $unique = 0;\n            }\n\
    \        }\n        if ($unique) {\n            push(@$unique_numbers, $_);\n\
    \        }\n    }\n    return @$unique_numbers;\n}", "    my @unique;\n    my\
    \ %seen;", "    my %seen;\n    foreach my $number (@$numbers) {\n        if (!exists\
    \ $seen{$number}) {\n            $seen{$number}++;\n        }\n    }\n    return\
    \ @$numbers;\n}\n</code>\n<|/ a tags=perl,algorithm,hash,arrays |>\n<| a tags=perl,algorithm,hash,arrays\
    \ dscore=2 |>\n<code>", "    my @output;\n    my %seen;\n    foreach my $num (@$numbers)\
    \ {\n        if (not exists $seen{$num}) {\n            $seen{$num} = 1;\n   \
    \         push(@output, $num);\n        }\n    }\n    return \\@output;\n}\n</code>\n\
    <|/ a dscore=2 tags=arrays,perl,hash,hashtable |>\n<| c |>\nYour `remove_duplicates`\
    \ sub is broken. `if (not exists $seen{$num})` should be `if (not exists $seen{$num})`.\
    \ Or more concisely, `if (not $seen{$num})`.\n<|/ c |>\n<| c |>\n: Good catch.\
    \ I fixed it.\n<|/ c |>\n<| a dscore=1 |>\nThe answer by Chris Torek seems to\
    \ be good enough for you.  But I thought I'd offer another answer that doesn't\
    \ use any of Perl's special syntax and doesn't require any use of modules.  It\
    \ uses regular expressions.  It has two advantages:", "    my $n = 0;\n    my\
    \ %seen;\n    while( my $n = shift @$numbers && $seen{$n}++ ){\n        delete\
    \ $numbers->[ $_ % $numbers->[0] ];\n    }\n    return @$numbers;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=perl,arrays,sorting |>\nSince you have a fixed sequence\
    \ of numbers, just use shift with your numbers in reverse order.\n<code>", " \
    \   my %seen;\n    return grep !$seen{$_}++, @$numbers;\n}", "    $numbers = \\\
    @$numbers;\n    my $hash = {};\n    my @result;\n    my $prev;\n    my $i = -1;\n\
    \    foreach my $num (@$numbers) {\n        ++$i;\n        $hash->{$num} = $i;\n\
    \        $prev = $num;\n    }\n    foreach my $num (sort {$a <=> $b} keys %$hash)\
    \ {\n        $result[$i] ||= $prev;\n        $result[$i]->[1] = $prev;\n     \
    \   $prev = $num;\n    }\n    return \\@result;\n}", '    my @result;', '    my
    @uniques = ();', "    my;\n    for(my $i=0; $i<@$numbers; $i++) {\n        for(my\
    \ $j=$i+1; $j<@$numbers; $j++) {\n            if($numbers[$i] eq $numbers[$j])\
    \ {\n                splice(@$numbers, $i, 1);\n                last;\n      \
    \      }\n        }\n    }\n    return;\n}", "    my;\n    for (@$numbers) {\n\
    \        push, $_ unless grep {$_ == $_} @{$numbers};\n    }\n    return;\n}",
  "    my @unique = ();\n    my @seen = ();\n    foreach my $num (@$numbers) {\n \
    \       if (!defined $seen[$num]) { $seen[$num] = 1;\n                       \
    \         push @unique, $num; \n                            }\n    }\n    return\
    \ @unique;\n}", '    my($i, $j, $num_unique, $num_leftover) = @_;', "    $numbers[-1]\
    \ = $numbers[-1] if scalar @$numbers == 0;\n    my $i = 0;\n    my @results;\n\
    \    while (@$numbers) {\n        my $number = shift;\n        if ($i++ > 0) {\n\
    \            push @results, $number;\n        }\n    }\n    @results;\n}", " \
    \   my;\n    my $last_seen;", "    my;\n    my %seen;\n    for(@$numbers) {\n\
    \        if (! exists $seen{$_}) {\n            push, $_;\n            $seen{$_}\
    \ = 1;\n        }\n    }\n    return wantarray ? @$numbers : \\@$numbers;\n}",
  "    my $hash = {};\n    my $size = @$numbers;\n    my $index = 0;\n    foreach\
    \ my $num (@$numbers) {\n        if (!$hash->{$num}++) {\n            $hash->{$num}\
    \ = $index++;\n            $numbers->[$hash->{$num}] = $num;\n        }\n    }\n\
    \    return @$numbers;\n}", "    my @seen;\n    my @unique_numbers;\n    my $key;\n\
    \    for (@$numbers) {\n        $key = $_;\n        push @unique_numbers, $key\
    \ unless $seen[$key] and push @seen, $key;\n    }\n    return @unique_numbers;\n\
    }", "    my @unique = ();\n    my %seen;\n    \n    for my $number (@$numbers)\
    \ {\n        if (!exists $seen{$number}) {\n            $seen{$number}++;\n  \
    \          push @unique, $number;\n        }\n    }\n    \n    return @unique;\n\
    }", '    my @unique_numbers;', "    my $num_seen = {};\n    my $nums_seen = ();\n\
    \    $num_seen{$_}++ for;\n    while(my($number, $count) = each %$num_seen) {\n\
    \        delete $num_seen{$number} if $count <= 1;\n        $nums_seen = grep\
    \ { ! exists $num_seen{$_} } @$nums_seen;\n    }\n    @$numbers = @$nums_seen;\n\
    \    return $numbers;\n}", "    my $index = 0;\n    my @output;\n    foreach my\
    \ $number (@$numbers) {\n        if (++$index == 1) {\n            push(@output,\
    \ int($number));\n        } else {\n            if ($number == $output[-1]) {\n\
    \                pop(@output);\n            } else {\n                push(@output,\
    \ $number);\n            }\n        }\n    }\n    return @output;\n}\n</code>\n\
    <|/ a tags=arrays,hash,perl |>\n<| a tags=arrays,hash,perl |>\nHere is a little\
    \ function which doesn't use hashes:\n<code>", "    my;\n    \n    for(my $i =\
    \ 0; $i < @$numbers; ++$i) {\n        my $value = $numbers->[$i];\n        \n\
    \        if($seen{$value}++) {\n            push, $value;\n        }\n    }\n\
    \    return @numbers;\n}", '    my %seen;', "    my @hash;\n    foreach my $n\
    \ (@$numbers) {\n        my $k;\n        for ($k = 0; $k < $#{$hash} ||= 0; $k++)\
    \ {\n            last if $hash[$k] eq $n;\n        }\n        $hash[$k] = $n;\n\
    \    }\n    return @hash;\n}", '    my @output;', "    my $length = $numbers->length;\n\
    \    my %seen = ();", "    my @result;\n    for (@$numbers) {\n        if ( $seen{$_}++\
    \ ) {\n            push @result, $_;\n        }\n    }\n    return @result;\n}",
  "    my($i, $j, $tmp);\n    \n    for ($i = 0, $j = -1;) {\n        if ($i < @$numbers)\
    \ {\n            $tmp = $numbers[$i];\n            next if ($tmp eq $numbers[$j]);\n\
    \            \n            if ($tmp > $j + 1) {\n                splice (@$numbers,\
    \ $j + 1, 1);\n                push @$numbers, $tmp;\n            }\n        \
    \    $j = $i;\n        }\n        ++$i;\n    }\n    @$numbers\n}", "    my @result\
    \ = ();\n    my $j;\n    my $count = 0;\n    my $tmp;\n    while( @$numbers )\
    \ {\n        $tmp = $numbers[$_];\n        ++$count if $tmp == $_;\n        push\
    \ @result, $tmp if $count == 1;\n        $count = $tmp;\n        splice @$numbers,\
    \ $_, 1;\n    }\n    return @result;\n}\n</code>\n<|/ a tags=perl,arrays |>\n\
    <| c |>\n: No need to do that.  `push` takes the number of elements to add.\n\
    <|/ c |>\n<| c |>\n: I stand corrected. I was thinking it would shift elements\
    \ by one, not copy them. Thanks.\n<|/ c |>\n<| c |>\nYour code works but it is\
    \ slower than the one above. Check my answer for a fast code.\n<|/ c |>\n<| a\
    \ dscore=3 tags=perl,arrays |>\nAnother way of doing it is to use the uniq subroutine\
    \ from List::MoreUtils Perl library.\n<code>\nuse List::MoreUtils qw(uniq);",
  "    my @result;\n    my $last_number;\n    my %seen;", "    my(@unique_numbers);\n\
    \    my($i, $j);", "    my @result = ();\n    my $len = scalar @$numbers;\n  \
    \  for (my $index = 0; $index < $len; ++$index) {\n        push(@result, $numbers[$index]\
    \ unless $seen{$numbers[$index]};\n        $seen{$numbers[$index]}++;\n    }\n\
    \    return @result;\n}", '    my @unique_numbers;', "    my @result = ();\n \
    \   my $j = 0;\n    my $i = -1;\n    while (++$i < scalar(@$numbers)) {\n    \
    \    unless(exists($result[$j])) {\n            $result[$j] = $numbers[$i];\n\
    \        } elsif($numbers[$i] eq $result[$j]) {\n            $result[$j]++;\n\
    \        } else {\n            $j++;\n        }\n    }\n    return @result;\n}",
  "    my %seen;\n    my $result = undef;\n    foreach my $num (@$numbers) {\n   \
    \     if (! defined $seen{$num}) {\n            $seen{$num} = 1;\n           \
    \ $result = $num;\n        }\n    }\n    return $result;\n}", "    my @output;\n\
    \    my $last;\n    my $count = 0;", '    my $length = @$numbers;', '    my($j);',
  "    my @unique_numbers;\n    @unique_numbers = ();\n    my $i = 0;\n    for (@$numbers)\
    \ {\n        if (! exists $unique_numbers->[$i]) {\n            $unique_numbers->[$i]\
    \ = $i;\n        }\n        $i++;\n    }\n    return @unique_numbers;\n}", '    my($hash);',
  "    return $numbers[] if scalar @$numbers == 1;\n    my @seen;\n    for (my $i\
    \ = 0; $i < scalar @$numbers; $i++) {\n        if (exists $seen{$numbers[$i]})\
    \ {\n            delete $seen{$numbers[$i]};\n            $numbers[$i] = undef;\n\
    \        } else {\n            $seen{$numbers[$i]} = 1;\n        }\n    }\n  \
    \  return @$numbers;\n}", "    my @duplicates;\n    my @new_numbers = ();\n  \
    \  my $index = 0;\n    for my $i (@$numbers) {\n        if ($i eq $numbers[$index])\
    \ {\n            push(@duplicates, $i);\n        } else {\n            push(@new_numbers,\
    \ $i);\n        }\n        $index++;\n    }\n    return @new_numbers;\n}", " \
    \   my %seen;\n    $seen{$_} = 1 for;\n    return sort grep !$seen{$_}++,;\n}",
  "    my @number_seen;\n    $number_seen[$_] = 1 for @$numbers;\n    my @result;\n\
    \    for (@$numbers) {\n        unless (defined $number_seen[$_]) {\n        \
    \    push @result, $_;\n        }\n        $number_seen[$_] = 1;\n    }\n    return\
    \ @result;\n}", "    my $n = @$numbers;\n    my $i = 0;\n    while ($i < $n) {\n\
    \        my $v = $numbers->[$i];\n        $i++;\n        while ($i < $n && $numbers->[$i]\
    \ == $v) {\n            $i++;\n        }\n        splice(@$numbers, $i, 1);\n\
    \    }\n    return $numbers;\n}", '    my @output;', "    $numbers = sort @$numbers;\n\
    \    my $i = 0;\n    my $result;\n    while($i < @$numbers) {\n        if($numbers[$i]\
    \ == $numbers[$i-1]) {\n            $numbers[$i--];\n        } else {\n      \
    \      $result->[$i++] = $numbers[$i];\n        }\n    }\n    @$numbers = @$result;\n\
    }", '    my;', "    my(@output) = (@$numbers);\n    my @seen;\n    while (@$numbers)\
    \ {\n        my $number = shift @$numbers;\n        my $pos = $seen{$number}++;\n\
    \        splice @$output, $pos, 1;\n    }\n    return (@output);\n}", "    my(@numbers_unique);\n\
    \    my($count);\n    foreach (@$numbers) {\n        $count++ if $_ eq $_;\n \
    \   }\n    foreach (@$numbers) {\n        if ($count > 0) {\n            $numbers_unique[$count-1]\
    \ = $_;\n            $count--;\n        }\n    }\n    return @$numbers_unique;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is also an excellent solution.  I\
    \ went with another one because I wanted to learn what was wrong with the original\
    \ approach.\n<|/ c |>\n<| c |>\nNice. +1. One small thing: `$numbers_unique[$count-1]\
    \ = $_;` should probably be `$numbers_unique[$count] = $_;`, otherwise you'll\
    \ have a lot of duplicates.\n<|/ c |>\n<| c |>\nIt could also be slightly improved\
    \ with `delete $numbers_unique[$_] for (grep !$count--, 0 .. $#numbers)`.\n<|/\
    \ c |>\n<| c |>\n, that's a very good idea - I didn't think of using an array\
    \ slice for that. Although I'd probably write it using a foreach loop since it's\
    \ so terse.\n<|/ c |>\n<| c |>\nYeah, I thought it would be clever to do that\
    \ but couldn't come up with a way to do it.\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ another approach, using the power of Perl's sort:\n<code>", '    return @$numbers
    if scalar @$numbers == 1;', "    my($counts) = ();\n    foreach my $x (@$numbers)\
    \ {\n\t$counts{$x}++ if exists $counts{$x};\n    }\n    my @result = ();\n   \
    \ foreach my $x (keys %$counts) {\n\tpush(@result, $x);\n    }\n    return @result;\n\
    }", "    return () unless @$numbers;\n    my @result;\n    @$numbers = sort {\
    \ $a <=> $b } @$numbers;\n    for my $number (@$numbers) {\n        ++$result[$_]\
    \ for 0..$#result if $result[$_] == $number;\n    }\n    return @result;\n}",
  "    my $number_count = scalar @$numbers;\n    @$numbers = grep { $_ ne $numbers[$_]\
    \ } 0 .. $number_count - 1;\n    return;\n}", "    my $count = scalar (@$numbers);\n\
    \    while ( $count > 1 ) {\n        $count--;\n        last unless $numbers[$count]\
    \ == $numbers[$count-1];\n    }\n    return @$numbers;\n}\n</code>\n<|/ a dscore=5\
    \ tags=perl,arrays |>\n<| c |>\nIt would be nice to give a detailed explanation\
    \ of what the code does. This is more about how to use the function than about\
    \ why it works.\n<|/ c |>\n<| a dscore=4 |>\nI prefer using grep for this:\n<code>\
    \ = grep { not $seen{$_}++ }\n</code>\nThe advantage of this over the accepted\
    \ answer is that grep stops as soon as it finds a duplicate instead of looping\
    \ over the whole array.  The accepted answer also loops over the whole array,\
    \ even though it only loops over the first element, and skips the rest.\n<|/ a\
    \ tags=perl,arrays |>\n<| c |>\nIf you just want to remove duplicates in one line,\
    \ you can also use `uniq { $seen{$_}++ }`\n<|/ c |>\n<| c |>\n: This only works\
    \ in Perl 5.10+.\n<|/ c |>\n<| c |>\nI didn't know about the existence of `uniq`\
    \ in Perl 5.10. Thanks for pointing out.\n<|/ c |>\n<| c |>\nThanks Jonathan,\
    \ I didn't know about this function. I was going to add it to the accepted answer\
    \ and delete this comment but decided it would be a good addition to yours.\n\
    <|/ c |>\n<| c |>\nTo prevent looping over unchanged elements, you can wrap your\
    \ grep in `@array_ref = grep { not $seen{$_}++ } @$array_ref` which would copy\
    \ `@$array_ref` to the array in place and avoid the copying step entirely if the\
    \ element isn't in the hash. The copy step would only be done if the element was\
    \ a false result from the grep, which means it's in the array and wasn't in the\
    \ hash. Obviously, this only works for scalars, so you could do `@array_ref =\
    \ map { [grep { not $seen{$_}++ }] } @$array_ref` if that makes you uncomfortable.\n\
    <|/ c |>\n<| a dscore=3 tags=perl,arrays |>\nOne of the few times when you really\
    \ need something that can do this:\n<code>\nuse Algorithm::Loops qw( uniq ); =\
    \ uniq (@array);\n</code>\nAnd that's it, not only is it more efficient (", " \
    \   my (@unique, $last_seen);\n    for my $number (@$numbers) {\n        if (not\
    \ $unique[$number]) {\n            $unique[$number] = 1;\n        }\n        else\
    \ {\n            $last_seen = $number;\n        }\n    }\n    return @unique;\n\
    }", "    my @numbers_copy = $numbers;\n    my $n = scalar(@numbers_copy);\n  \
    \  for(my $i=0; $i < $n; $i++) {\n        for(my $j=$i+1; $j < $n; $j++) {\n \
    \           if($numbers_copy[$i] == $numbers_copy[$j]) {\n                splice(@numbers_copy,\
    \ $j, $n-$i);\n                $n -= $i;\n            }\n        }\n    }\n  \
    \  return @numbers_copy;\n}\n</code>\nThis is an imperative solution, which makes\
    \ no explicit use of any kind of sort or hashing.  The inner loop is O(n^2), but\
    \ if all you want to do is remove duplicates, this won't be much of an issue.\n\
    <|/ a |>\n<| c |>\nThe question asks for a solution that is concise but performant.\n\
    <|/ c |>\n<| c |>\n: That's a very important point to make.  What is the expected\
    \ efficiency of this solution?  I'm guessing `O(n)`, but I'd like to be sure.\
    \  I updated my answer to include the `O(n)` information.\n<|/ c |>\n<| c |>\n\
    I wouldn't worry about performance until I discovered that an O(n^2) algorithm\
    \ was the way to go. I'd definitely try to write an O(n) algorithm!\n<|/ c |>\n\
    <| a dscore=1 tags=perl,sorting,arrays |>\nYou can try this:\n<code>\nuse strict;\n\
    use warnings;", "    my $size = @$numbers;\n    my @new_numbers = ();\n    my\
    \ $i = 0;\n    for(my $n = 0; $n < $size; $n++) {\n        if ($numbers[$n] eq\
    \ $numbers[$n+1]) {\n            $new_numbers[$i++] = $numbers[$n];\n        }\
    \ else {\n            push (@new_numbers, $numbers[$n]);\n        }\n    }\n \
    \   return @new_numbers;\n}", "    my @ordered_numbers = sort {$a <=> $b};\n \
    \   my($counts) = map {$_ => 1}, [@ordered_numbers[0..$#ordered_numbers] ];\n\
    \    my($result) = [];\n    foreach my $number (@$numbers) {\n        if (exists\
    \ $counts{$number}) {\n            delete $counts{$number};\n        } else {\n\
    \            $result->[$#result]=$number;\n        }\n    }\n    return @$result;\n\
    }", "    my %seen;\n    for (@$numbers) {\n        if (exists $seen{$_}) {\n \
    \           delete $seen{$_};\n        }\n        else {\n            $seen{$_}\
    \ = 1;\n        }\n    }\n    return values %seen;\n}", "    my @result = ();\n\
    \    my $index = 0;\n    foreach my $num (@$numbers) {\n        if ($index++ ==\
    \ 0) {\n            $result[$index] = $num;\n        } else {\n            push\
    \ @result, $num if $result[$index-1] eq $num;\n        }\n    }\n    return @result;\n\
    }", "    my(@results);\n    while(@{$numbers}) {\n        push(@results, shift(@{$numbers}));\n\
    \    }\n    return @results;\n}", '    $numbers = sort $numbers;', "    my $unique_numbers;\n\
    \    for(my $number = 0; $number < $#{$numbers};\n       $number++ ) {\n     \
    \   my $current_value = $numbers[$number];\n        unless($unique_numbers->{$current_value}++)\
    \ {\n            $unique_numbers->{$current_value}++;\n        }\n    }\n    return\
    \ values %{$unique_numbers};\n}", "    my @unique;\n    my %seen;\n    for(my\
    \ $i=0; $i<@$numbers; $i++) {\n        push @unique, $seen{$numbers[$i]} || $numbers[$i];\n\
    \        $seen{$numbers[$i]} = 1;\n    }\n    return @unique;\n}", "    my(@unique);\n\
    \    my($i, $j);", "    my $i = 0;\n    my %seen;", "    my %seen;\n    my @new;\n\
    \    foreach my $num (@$numbers) {\n        if (! defined $seen{$num}) {\n   \
    \         $seen{$num} = 1;\n            push(@new, $num);\n        }\n    }\n\
    \    return @new;\n}", "    my @unique;\n    my $num_seen = 0;\n    foreach my\
    \ $num (@$numbers) {\n        if ($num_seen++ == $num) {\n            next;\n\
    \        }\n        push(@unique, $num);\n    }\n    return @unique;\n}", '    my
    @output;', "    my $n = 0;\n    my @result = (0);\n    \n    for my $num (@$numbers)\
    \ {\n        ++$n if ($n++ > 1);\n        push(@result, $num);\n    }\n    \n\
    \    return @result;\n}", '    my %seen = ();', "    my(@uniques, $i, $j);\n \
    \   \n    for(my $i = 0; $i < scalar @$numbers; $i++) {\n        my $number =\
    \ $numbers[$i];\n        if(defined $uniques[$number]) {\n            next if($uniques[$number]\
    \ > 1);\n        } else {\n            $uniques[$number] = 1;\n        }\n   \
    \ }", "    $numbers[-1] //= 1;\n    my %seen;\n    grep { !$seen{$_}++ } @$numbers;\n\
    }", "    my @uniques;\n    \n    foreach my $number (@$numbers) {\n        push\
    \ @uniques, $number unless $uniques{$number}++;\n    }\n    \n    return @uniques;\n\
    }", "    my $len = @$numbers;\n    my $numbers_new = ();\n    my $number;\n  \
    \  my $i = 1;\n    while ($i < $len) {\n        if (defined $numbers[$i]) {\n\
    \            $number = $numbers[$i];\n            $numbers_new->push($number);\n\
    \            $i++;\n        } else {\n            $i++;\n        }\n    }\n  \
    \  return @$numbers_new;\n}", "    return sort grep {++$numbers->[$_] > 1} 0 ..\
    \ $#$numbers;\n}", "    my %seen = ();\n    my @unique = ();\n    while(@$numbers)\
    \ {\n        my $number = shift @$numbers;\n        next unless $seen{$number}++;\n\
    \        push @unique, $number;\n    }\n    return wantarray ? @unique : \\@unique;\n\
    }", "    my $i = 0;\n    my = ();\n    foreach my $num (@$numbers) {\n       \
    \ if ($num == $numbers[$i]) {\n            splice(@numbers, $i, 1);\n        }\
    \ else {\n            $i++;\n            push(@numbers, $num);\n        }\n  \
    \  }\n    wantarray ? @numbers : \\@numbers;\n}\n</code>\n<|/ a dscore=5 tags=perl,arrays\
    \ |>\n<| c |>\nWhy are you testing `!$nums` instead of `!$numbers`?  I don't think\
    \ that's right.  Also, why are you using `splice` instead of `push`?\n<|/ c |>\n\
    <| c |>\n$nums is the array reference and $numbers is the array. Both can be iterated\
    \ over as if they were the same thing.\n<|/ c |>\n<| c |>\nIn Perl 5.10.0, the\
    \ two are the same.  But `@numbers` will change in place if you use `push`, so\
    \ it's a good habit to get into to keep your code future proof -- at least until\
    \ you're sure you're no longer using Perl 5.10.0.\n<|/ c |>\n<| a dscore=5 |>\n\
    If you're using Perl 5.14 or later, you could use Set::Scalar.\n<code>\nuse strict;\n\
    use warnings;\nuse Set::Scalar;", "    my $seen = [0];\n    return grep { ! $seen[$_]\
    \ } 0 .. $#numbers;\n}", "    $numbers =~ tr/\\n//d;\n    my $unique_numbers =\
    \ sort { $a <=> $b } keys %{ $numbers };\n    my $unique_hash = {};\n    for my\
    \ $number (@$unique_numbers) {\n        $unique_hash->{$number}++;\n    }\n  \
    \  my = grep { $unique_hash->{$_} == 1} (keys %$unique_hash);\n    return @numbers;\n\
    }\n</code>\n<|/ a tags=perl,arrays dscore=1 |>\n<| c |>\n`sort { $a <=> $b }`\
    \ will also do string sorting; I believe that should be changed to `sort { $a\
    \ cmp $b }`\n<|/ c |>\n<| c |>\nYour code produces a warning when run in strict\
    \ mode. Also it is inefficient -- you create a hash each time you call the subroutine.\
    \ Better to build the hash before the subroutine call. Also, `grep` will create\
    \ an anonymous array reference, which you then unpack using `@` and assign to\
    \ `@unique`. I suggest `my = grep { not $unique{$_} } (keys %unique)`\n<|/ c |>\n\
    <| c |>\n, Yes, I realized the warnings about strictness. I was thinking about\
    \ efficiency too. Thanks.\n<|/ c |>\n<| a |>\n<code>", '    my @new_numbers =
    ();', '    my(@ordered_numbers);', "    my $count = scalar @$numbers;\n    my\
    \ $new_numbers = ();", "    my @numbers_unique = ();\n    my $i = 0;\n    for(my\
    \ $n = 0; $n < scalar(@$numbers); $n++) {\n        if($numbers[$n] ne $numbers[$i])\
    \ {\n            push(@numbers_unique, $numbers[$n]);\n            $i++;\n   \
    \     }\n    }\n    return @numbers_unique;\n}", "    $numbers[-1] =~ tr/#/0/;\n\
    \    $numbers[-1] =~ tr/0/#/;\n    return @$numbers;\n}", "    my @result;\n \
    \   my %seen;", "    my $hash = {};\n    my @numbers_ordered;\n    my @to_remove;\n\
    \    my $i = 0;\n    while($i < @$numbers) {\n        my $value = $numbers[$i];\n\
    \        $hash->{$value}++;\n        push (@to_remove, $value) unless $hash->{$value};\n\
    \        $numbers_ordered[$i] = $value;\n        $i++;\n    }\n    for($i = 0;\
    \ $i < @to_remove; $i++) {\n        delete $hash->{$to_remove[$i]};\n    }\n \
    \   while(@to_remove) {\n        unshift @$numbers_ordered, shift @to_remove;\n\
    \    }\n    @$numbers = @numbers_ordered;\n    return @$numbers;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\nA bit late to the party, but this should be pretty\
    \ efficient since it only loops through the input once:\n<code>", "    $numbers\
    \ -= [sort {$a <=> $b} grep {!$seen{$_}++} @$numbers];\n}", "    my @seen;\n \
    \   my($count);\n    foreach my $number (@$numbers) {\n        if (not exists\
    \ $seen[$number]) {\n            $seen[$number] = 1;\n            $count++;\n\
    \        }\n    }\n    return @$numbers if $count > 1;\n}", "    my $sorted =\
    \ uniq @$numbers;\n    return @$numbers[@$sorted > 1];\n}\n</code>\nAnd finally,\
    \ the version which works directly from STDIN:\n<code>", "    my @output = $numbers;\n\
    \    my $index = 0;\n    while ($index < @output) {\n        my $value = $output[$index];\n\
    \        my $pos = $index;\n        while ($pos + 1 < @$numbers && $output[$pos\
    \ + 1] == $value) {\n            $pos++;\n        }\n        if ($pos == $index)\
    \ {\n            splice(@output, $index, 1);\n        } else {\n            $index\
    \ = $pos;\n        }\n    }\n    return @output;\n}", "    # Add an element to\
    \ the hash if the element is not yet in the hash\n    foreach my $number (@$numbers)\
    \ {\n        $numbers{$number}++;\n    }\n    # Now go through the hash and make\
    \ an array of the elements whose value is 1\n    my(@uniques) = ();\n    while\
    \ (my ($key, $val) = each %$numbers) {\n        if ($val == 1) {\n           \
    \ push(@uniques, $key);\n        }\n    }\n    return @uniques;\n}\n</code>\n\
    To get unique entries in a hash, one usually does a reverse lookup using keys.\n\
    <|/ a tags=perl,hashmap,arrays |>\n<| c |>\nIt would be better to use a hash with\
    \ keys being the original array index and values being the elements themselves.\
    \ Then you simply return keys afterwards to get the unique values. Apart from\
    \ that your method seems more efficient than mine.\n<|/ c |>\n<| c |>\nYes, that's\
    \ a good point and I considered it, but I decided against it because it would\
    \ be more complicated to write and understand, and it seemed like more trouble\
    \ than it's worth for the OP's purposes.\n<|/ c |>\n<| c |>\nThe only problem\
    \ I see is that it returns unique values as values as opposed to keys, so you\
    \ would have to do a `keys %uniques` to get the unique values.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nI suggest something like this:\n<code>\nuse Algorithm::Loops qw(\
    \ uniq );", '    my @result;', "    my @unique_numbers = ();\n    my $num;", '    my
    %counts;', "    my %seen;\n    \n    foreach my $number (@$numbers) {\n      \
    \  $seen{$number}++ if $seen{$number} < 2;\n    }\n    \n    return @{$numbers}\
    \ ? values %seen : ();\n}", "    my(@results);\n    my $i = 0;\n    for my $num\
    \ (@$numbers) {\n        push(@results, $num);\n        $i++;\n        if ($i\
    \ == 1) {\n            $i = 0;\n        }\n    }\n    return @results;\n}", " \
    \   my $result = shift;\n    my $size = @$result;", "    my @new;\n    my %seen;\n\
    \    foreach my $n (@$numbers) {\n        if (not exists $seen{$n}) {\n      \
    \      push @new, $n;\n            $seen{$n}++;\n        }\n    }\n    return\
    \ \\@new;\n}", "    my $counts{$_}++ for @$numbers;\n    my %ret;\n    @$numbers\
    \ = map {delete $counts{$_} ? $_ : () } keys %counts;\n    return \\@$numbers;\n\
    }\n</code>\n<|/ a tags=perl |>\n<| c |>\nI like this solution a lot, because it\
    \ makes it easy to generalize this code to work on any kind of datastructure (like\
    \ hashes or arrays), not just strings.\n<|/ c |>\n<| a |>\nA simple solution (using\
    \ hashes) using hashes to count the frequency of each element and then simply\
    \ removing those that appear more than once in the original array:\n<code>", '    my
    %seen;', "    my @seen;\n    my $number = 0;\n    while (@$numbers) {\n      \
    \  $number += shift @$numbers;\n        push @$numbers, $number;\n        push\
    \ @seen, $number unless exists $seen[$number];\n    }\n    return @$numbers;\n\
    }\n</code>\nThis isn't the most efficient implementation, but its fairly easy\
    \ to understand, and should allow for you to learn a little bit about the language\
    \ and how to solve some problem easier.\n<|/ a dscore=1 |>\n<| a tags=perl,sorting,arrays\
    \ |>\nI wrote a short code that would do this. Its not the most efficient but\
    \ it works.\n<code>\nmy = ( 10, 50, 60, 30, 40, 30, 10 );", "    my $unique =\
    \ ();\n    foreach my $num (@$numbers) {\n        push @$unique, $num if !grep(!($unique->[0]\
    \ eq $num), @$unique);\n    }\n    return @$unique;\n}", "    my %seen;\n    my\
    \ @result;\n    foreach my $num (@$numbers) {\n        if(not exists $seen{$num})\
    \ {\n            push @result, $num;\n            $seen{$num} = 1;\n        }\n\
    \    }\n    @$numbers = @result;\n    return $numbers;\n}", '    my @result;']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
