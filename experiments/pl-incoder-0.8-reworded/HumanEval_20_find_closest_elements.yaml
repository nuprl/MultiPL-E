name: HumanEval_20_find_closest_elements
language: pl
prompt: "# From a supplied array of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # [2.0, 2.2]\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0,\
  \ 2.0]\nsub find_closest_elements {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_closest_elements;\n\
  \        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0,\
  \ 2.2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0])) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2,\
  \ 3.1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $smallest = Math::BigRat->new->badd($numbers[0]);\n    my $largest\
    \  = Math::BigRat->new->badd($numbers[-1]);", "    my($smallest, $largest);\n\
    \    my $smallest_distance = undef;\n    my $greatest_distance = undef;\n    foreach\
    \ my $number (@$numbers) {\n        my $distance = abs($number - $smallest);\n\
    \        if ($smallest_distance eq undef) {\n            $smallest_distance =\
    \ $distance;\n            $smallest = $number;\n        }\n        else {\n  \
    \          $smallest_distance = $smallest_distance if $smallest_distance > $distance;\n\
    \        }\n        $greatest_distance = $greatest_distance if $greatest_distance\
    \ < $distance;\n    }\n    my $result = $smallest;\n    $result->[0] = $smallest;\n\
    \    $result->[1] = $greatest_distance;\n    return @$result;\n}\n</code>\n<|/\
    \ a tags=perl,algorithm,numbers |>\n<| c |>\nThe question is not about efficiency,\
    \ but about coding. And `find_closest_elements([1.,2.,3.,4.,5.])` gives [2.0,2.2],\
    \ which is wrong. Also, `find_closest_elements([1,3,5,9])` gives `3,5`, which\
    \ is also wrong.\n<|/ c |>\n<| c |>\n: Yes, but the function returns an array\
    \ with two numbers in it. He can do whatever he wants with it.\n<|/ c |>\n<| c\
    \ |>\nI understand your function, but your implementation is a bit too complicated\
    \ compared to what other languages offer.\n<|/ c |>\n<| c |>\n: It's complicated,\
    \ yes. But it does solve the problem as stated.\n<|/ c |>\n<| c |>\nI think this\
    \ is far too complicated. Just call `sort { abs($a - $b) } $array` -- that's all\
    \ that matters.\n<|/ c |>\n<| a tags=perl,algorithm,numbers dscore=1 |>\nA slight\
    \ variant on \"binary search\", where you use the median of the values around\
    \ the current one, so you can find the middle of the array in O(logN) time. I\
    \ also rewrote it in a way that sorts the input list before finding the median.\n\
    <code>", "    my @result;\n    my $smallest = $numbers[0];\n    my $largest =\
    \ $numbers[0];\n    my $index = -1;\n    my $diff;", "    return @$numbers[min($numbers,\
    \ sub ($_, $numbers[0]) {\n        $_ - $_\n    })]\n}", "    # Sort smallest\
    \ to largest and grab the smallest (closest to zero)\n    my @closest = sort {\
    \ $a <=> $b } @$numbers;", "    \n    my($smallest, $largest);\n    \n    foreach\
    \ my $number (@$numbers) {\n        if (defined $smallest and $number < $smallest)\
    \ {\n            $largest = $number;\n        }\n        else {\n            $smallest\
    \ = $number;\n        }\n    }\n    \n    return [$smallest, $largest];\n}", " \
    \   my(@closest);\n    my($closest1, $closest2);\n    my $min = $numbers[0];",
  "    my $min_diff = $numbers[0] - $numbers[1];\n    my $min = $numbers[0];\n   \
    \ my $max = $numbers[0];\n    for(my $i = 1; $i <= $#$numbers; $i++) {\n     \
    \   my $diff = $numbers[$i] - $numbers[$i - 1];\n        if($diff < $min_diff)\
    \ {\n            $min_diff = $diff;\n            $min = $numbers[$i];\n      \
    \      $max = $numbers[$i];\n        } elsif($diff > $min_diff) {\n          \
    \  if( $diff < $max) {\n                $max = $numbers[$i];\n            }\n\
    \        }\n    }\n    return ($min, $max);\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThank you! This worked perfectly. Unfortunately the other guy answered\
    \ first and so I accepted his answer.\n<|/ c |>\n<| c |>\nNo problems bud. Welcome\
    \ to SO and thanks for posting an answer :-)\n<|/ c |>\n<| c |>\nThank you so\
    \ much! This worked perfectly. Also thank you for the link to the Perl Cookbook.\
    \ I really should read through it more!\n<|/ c |>\n<| a dscore=1 |>\nA short one-liner\
    \ :\n<code>\nperl -le 'print join \" \", grep {$_ + $_ !~ / /g}' < input.txt\n\
    </code>\n<|/ a tags=perl |>\n<| a |>\n<code>", "    my($min, $max) = @$numbers[0,\
    \ 1];\n    for(my $i = 0; $i < scalar(@$numbers) - 1; ++$i) {\n        if($numbers[$i\
    \ + 1] < $min) {\n            $min = $numbers[$i + 1];\n        } elsif($numbers[$i]\
    \ > $max) {\n            $max = $numbers[$i];\n        }\n    }\n    return ($min,\
    \ $max);\n}", "    my ($index, $max, $maxindex, $min, $minindex);\n    my $mindistance\
    \ = 0;\n    foreach $index (0..$#numbers) {\n        ($max, $min) = @{$numbers[$index]};\n\
    \        if ($index > 0) {\n            ($maxindex, $minindex) = $numbers[$index-1];\n\
    \            if ($maxindex > $minindex) {\n                $min = $max;\n    \
    \            $max = $minindex;\n            } else {\n                $max = $min;\n\
    \                $min = $maxindex;\n            }\n        }\n        $mindistance\
    \ += abs($max - $min);\n    }\n    my @result;\n    if ($mindistance > 0) {\n\
    \        push (@result, $numbers[0]);\n        push (@result, $numbers[$#numbers]);\n\
    \    }\n    if ($mindistance > 1) {\n        my $mid = $mindistance / 2;\n   \
    \     my $minmid = $numbers[$#numbers] / 2;\n        if ($numbers[$#numbers-1]\
    \ < $minmid) {\n            push (@result, $numbers[$#numbers]);\n           \
    \ push (@result, $minmid);\n        }\n        else {\n            push (@result,\
    \ $numbers[$#numbers-1]);\n            push (@result, $minmid);\n        }\n \
    \   }\n    @result;\n}", "    my $min_index = 0;\n    my $min = $numbers[0];\n\
    \    my $max_index = 0;\n    my $max = $numbers[0];", "    my $max = -1;\n   \
    \ my($min, @return);\n    my $smallest;\n    my $secondSmallest;\n    foreach\
    \ my $number (@$numbers) {\n        my $temp = $number;\n        $temp = $temp\
    \ + 0.5;\n        if ($temp > $max) {\n            $max = $temp;\n        }\n\
    \    }", '    my($closest1, $closest2, $min1, $min2);', "    return map { $_ <\
    \ $numbers[0] ? $_ : $numbers[0] } sort { $numbers[0] cmp $numbers[1] };\n}",
  "    my($closest_number);\n    my(@closest_numbers);", "    return wantarray ? @$numbers\
    \ : $numbers[0];\n}", "    my $min_diff = $numbers[0];\n    my $max_diff = $numbers[1];\n\
    \    $min_diff->copy();\n    $max_diff->copy();\n    for (my $i = 0; $i < @$numbers;\
    \ $i++) {\n        $min_diff->[$i] = $numbers[$i];\n        $max_diff->[$i] =\
    \ $numbers[$i];\n    }\n    for (my $i = 1; $i < @$numbers; $i++) {\n        for\
    \ (my $j = 0; $j < $i; $j++) {\n            $min_diff->[$j] = $numbers[$i] + min($numbers[$j],\
    \ $numbers[$i] - $numbers[$j]);\n            $max_diff->[$j] = $numbers[$i] +\
    \ max($numbers[$j], $numbers[$i] - $numbers[$j]);\n        }\n    }\n    my $closest_elements\
    \ = [];\n    for(my $i = 0; $i < @$numbers; $i++) {\n        if($min_diff->[$i]\
    \ <= $max_diff->[$i]) {\n            $closest_elements->[$i] = $min_diff->[$i];\n\
    \        } else {\n            $closest_elements->[$i] = $max_diff->[$i];\n  \
    \      }\n    }\n    sort(@$closest_elements);\n    return @$closest_elements;\n\
    }\n</code>\n<|/ a tags=perl |>\n<| c |>\nAh yes, I forgot to mention, that the\
    \ array is really huge. Thanks for the fast answer.\n<|/ c |>\n<| c |>\nI see\
    \ - it wasn't clear from your question how big you wanted to search for the closest\
    \ values that weren't in the array. There are some very clever solutions that\
    \ could make use of that; see my comment on murrayfox's solution.\n<|/ c |>\n\
    <| a dscore=3 |>\nHere's a solution based on the idea that you have an ordered\
    \ list of items and you wish to find the closest one in the list that isn't in\
    \ the list\nThe idea is to find the closest item to the left of the item you are\
    \ looking for, remove it from the list then find the closest item to the right\
    \ of the item you are looking for, remove it from the list. Repeat until you hit\
    \ a number in the list or there are no more items to remove.\n<code>\nuse strict;\n\
    use warnings;", "    if (@$numbers == 0) {\n        return ();\n    }\n    \n\
    \    my($min, $max, $min_index, $max_index, $i);\n    my $min_index;\n    my $max_index;\n\
    \    my $max_diff;\n    \n    $min = $numbers[0];\n    $max = $numbers[0];\n \
    \   \n    for ($i = 1; $i <= @$numbers; $i++) {\n        if ($numbers[$i] < $min)\
    \ {\n            $min = $numbers[$i];\n            $min_index = $i;\n        }\
    \ elsif ($numbers[$i] > $max) {\n            $max = $numbers[$i];\n          \
    \  $max_index = $i;\n        }\n    }\n    \n    if ($min != $numbers[0]) {\n\
    \        # $min is less than all of $numbers, $numbers[0] is closest to $min\n\
    \        return ($numbers[0], $numbers[0]);\n    }\n    \n    if ($max != $numbers[0])\
    \ {\n        # $max is greater than all of $numbers, $numbers[0] is closest to\
    \ $max\n        return ($numbers[0], $numbers[0]);\n    }\n    \n    for ($i =\
    \ 1; $i <= @$numbers; $i++) {\n        if ($numbers[$i] < $min) {\n          \
    \  $min = $numbers[$i];\n            $min_index = $i;\n        } elsif ($numbers[$i]\
    \ > $max) {\n            $max = $numbers[$i];\n            $max_index = $i;\n\
    \        }\n    }\n    \n    for ($i = 1; $i <= @$numbers; $i++) {\n        my\
    \ $diff = $numbers[$i] - $min;\n        \n        if ($diff < $max_diff) {\n \
    \           $max_diff = $diff;\n            $max_index = $i;\n        }\n    \
    \    \n        if ($diff > $max_diff) {\n            $max_diff = $diff;\n    \
    \        $min_index = $i;\n        }\n    }\n    \n    return ($numbers[$min_index],\
    \ $numbers[$max_index]);\n}", "    my ($low, $high) = (0, 0);\n    my ($next,\
    \ $nextnext);\n    my $max = $numbers[0];\n    my $min = $numbers[0];\n    my\
    \ $i;\n    for ($i = 1; $i < @$numbers; $i++) {\n        if ($numbers[$i] >= $max)\
    \ {\n            $next = $max;\n            $max = $numbers[$i];\n        } elsif\
    \ ($numbers[$i] <= $min) {\n            $next = $min;\n            $min = $numbers[$i];\n\
    \        } else {\n            $next = $numbers[$i];\n        }\n        if ($next\
    \ > $high) {\n            $high = $next;\n            $nextnext = $numbers[$i];\n\
    \        }\n        if ($next < $low) {\n            $low = $next;\n         \
    \   $nextnext = $numbers[$i];\n        }\n    }\n    return ($low, $high);\n}",
  "    my @closest_elements;\n    my $smallest_number = $numbers[0];\n    my $smallest_index\
    \ = 0;\n    my $closest_element;\n    my $index;\n    my $i;\n    \n    foreach\
    \ my $number (@$numbers) {\n        if ( abs($number - $smallest_number) < $smallest_number)\
    \ {\n            $smallest_number = $number;\n            $smallest_index = $i;\n\
    \        }\n        $closest_element = $smallest_number;\n        $index = scalar(@closest_elements);\n\
    \        $closest_elements[$index] = $smallest_number;\n        $smallest_number\
    \ = $number;\n        $closest_elements[$index] = $smallest_number;\n    }\n \
    \   return @closest_elements;\n}", "    my $min = $numbers[0];\n    my $max =\
    \ $numbers[0];\n    my %diffs;\n    my @results;\n    # Find the difference between\
    \ each element\n    for my $index ( 0..(@$numbers - 1) ) {\n        $diffs{$numbers[$index]}\
    \ = $numbers[$index + 1] - $numbers[$index];\n    }\n    # Sort by the smallest\
    \ difference and the second smallest difference\n    my $key;\n    if ( ($key,$numbers[$#{$numbers}})\
    \ =\n         ($key,$numbers[$#{$numbers}-1]) ) {\n        @results = sort {\n\
    \            $diffs{$a} <=> $diffs{$b}\n        } keys %diffs;\n    }\n    else\
    \ {\n        @results = sort {\n            $diffs{$a} <=> $diffs{$b}\n      \
    \  } keys %diffs;\n    }\n    return @results;\n}", "    # Special case if the\
    \ input is a single number.\n    if (@$numbers == 1) {\n        return ($numbers[0],\
    \ @$numbers);\n    }\n    my ($closest, $next_closest) = (0, 0);\n    my $closest_element\
    \ = Math::BigInt->new($numbers[0]);\n    # Special case for no numbers, return\
    \ nothing.\n    return () if @$numbers == 0;\n    # Loop through the input array\
    \ and find the closest number to the\n    # first one.\n    for (my $i = 1; $i\
    \ < (@$numbers - 1); $i++) {\n        my $current_number = Math::BigInt->new($numbers[$i]);\n\
    \        if ($current_number->bcmp($closest_element) == 0) {\n            $closest\
    \ = $i;\n        }\n    }\n    # Now we need to find the next closest number.\
    \ First look at the first\n    # two numbers, then the next two numbers, etc.\
    \ If we didn't find an\n    # exact match and we are looking for a 'greater than'\
    \ match, continue\n    # to look at the next two numbers.\n    for (my $i = 2;\
    \ $i < (@$numbers - 1); $i++) {\n        my $current_number = Math::BigInt->new($numbers[$i]);\n\
    \        if ($current_number->bcmp($closest_element) == 0) {\n            $next_closest\
    \ = $i;\n        }\n        elsif ($closest_element->bcmp($current_number) < 0)\
    \ {\n            $next_closest = $i;\n        }\n    }\n    return ($numbers[$closest],\
    \ $numbers[$next_closest]);\n}\n</code>\nNote that this module requires Math::BigInt\
    \ to be installed.\n<|/ a dscore=2 tags=perl,bigint |>\n<| a tags=perl,bigint\
    \ |>\n<code>", '    my($i, $j, $min_i, $min_j, $min_diff);', "    $numbers[0]\
    \ = 0 if $numbers[0] < 0;\n    $numbers[-1] = 0 if $numbers[-1] < 0;\n    my(@ret,\
    \ $x, $y);\n    foreach $x (@$numbers) {\n        $x->[0] = 0 if $x->[0] < 0;\n\
    \        $x->[-1] = 0 if $x->[-1] < 0;\n        $x->[1] > $y->[1] && $x->[0] >\
    \ $y->[0] && push(@ret, $x->[0]);\n        $x->[0] > $y->[0] && $x->[1] > $y->[1]\
    \ && push(@ret, $x->[-1]);\n        $x->[1] > $y->[1] && $x->[1] > $y->[1] &&\
    \ $x->[1] > $y->[1] && push(@ret, $x->[1]);\n        $x->[1] > $y->[1] && $x->[1]\
    \ > $y->[1] && $x->[0] > $y->[0] && push(@ret, $x->[-1]);\n    }\n    return \\\
    @ret;\n}\n</code>\n<|/ a |>\n<| a |>\nThe other answers have a great deal of code,\
    \ so I'll go through it to show you how it works.\nThe basic idea is to create\
    \ a map of which numbers have already been found. For each pair of numbers, first\
    \ see which one is closest to the other - either +1 or -1. Then you compare this\
    \ value with the value in the current map, and see which one is closer. If it\
    \ is the same value, you add the current number to the current set, and if it\
    \ is different, you add the number to the end of the current set. \nSince it is\
    \ the same number, the map values will always equal the number of numbers found.\
    \ For each pair you then see which of the sets is smaller (either +1, -1 or 0).\
    \ For each of this sets, you then add either +1 or -1 to the set of numbers that\
    \ you already have. \nAt the end, the sets in which you found the numbers should\
    \ contain all the numbers from the original array, in any order. \nThis algorithm\
    \ can be improved slightly by using the map to keep track of which numbers have\
    \ already been found, and only adding numbers to the sets for which you found\
    \ them - in other words you only need to check each pair once for the same number\
    \ more than once - but that would just add some overhead. \nThis should give an\
    \ interesting variation of what you would get if you tried to find the closest\
    \ pair of numbers without actually finding them. \nHere is the code:\n<code>\n\
    use strict;\nuse warnings;", "    my @numbers_sorted = sort;\n    my $closest_number\
    \ = 0;\n    my $closest_element = 0;\n    my($smallest_difference);\n    foreach\
    \ my $number (@$numbers) {\n        $smallest_difference = $number - $closest_number;\n\
    \        foreach my $element (@numbers_sorted) {\n            my $difference =\
    \ $element - $number;\n            if($difference < $smallest_difference) {\n\
    \                $closest_element = $element;\n                $closest_number\
    \ = $number;\n                $smallest_difference = $difference;\n          \
    \  }\n        }\n    }\n    return ($closest_number, $closest_element);\n}\n</code>\n\
    <|/ a tags=perl,optimization |>\n<| a |>\nIn a language that allows you to use\
    \ map/sort, you can use something like:\n<code>", "    my(@closest,);\n    my($closest_first,\
    \ $closest_second);", "    my (@closest_elements, $closest_number);\n    my $min_number\
    \ = $numbers[0];\n    my $max_number = $numbers[0];\n    foreach my $number (@$numbers)\
    \ {\n        if (($number - $min_number) < ($max_number - $min_number)) {\n  \
    \          $closest_number = $number;\n            $closest_number = $min_number;\n\
    \            $closest_number->{'closest_number'} = 0;\n        } else {\n    \
    \        $closest_number = $min_number;\n            $closest_number->{'closest_number'}\
    \ = 1;\n        }\n        $min_number = $max_number;\n        $max_number = $number;\n\
    \    }\n    return @closest_numbers;\n}", "    my (@smallest, $max, @largest);\n\
    \    my $smallest;\n    my $max;\n    my $i;", "    my $min_diff;\n    my $first_num;\n\
    \    my $second_num;\n    my $diff;", "    my(@result);\n    my($numbers_size)\
    \ =;\n    if ($numbers_size < 2) {\n        die \"Not enough numbers\";\n    }",
  "    my($smallest, $largest, $i, $j);\n    my $min_distance = INF;", "    return\
    \ map { abs($numbers[$_] - $numbers[$_-1]) } 0..$#numbers;\n}", "    my @closest_numbers;\n\
    \    my $min;\n    my $max;\n    if (@$numbers == 0) {\n\treturn $closest_numbers;\n\
    \    }\n    for (my $i = 0; $i < @$numbers; $i++) {\n\tif ($numbers[$i] < $min)\
    \ {\n\t    $min = $numbers[$i];\n\t}\n\telsif ($numbers[$i] > $max) {\n\t    $max\
    \ = $numbers[$i];\n\t}\n    }\n    for (my $i = 0; $i < @$numbers; $i++) {\n\t\
    if ($numbers[$i] == $min) {\n\t    push @closest_numbers, $numbers[$i];\n\t}\n\
    \telsif ($numbers[$i] == $max) {\n\t    push @closest_numbers, $numbers[$i];\n\
    \t}\n\telse {\n\t    push @closest_numbers, $min;\n\t}\n    }\n    return @closest_numbers;\n\
    }", "    my($min) = shift @$numbers;\n    my($max) = shift @$numbers;\n    my\
    \ $smallest_difference = shift @$numbers;\n    my $greatest_difference = shift\
    \ @$numbers;\n    if ($min eq $max) {\n        push @$numbers, $min;\n       \
    \ return @$numbers;\n    }\n    # Find closest value to min and greatest to max\n\
    \    my $min_index = 0;\n    my $max_index = @$numbers - 1;\n    while ($min_index\
    \ < $max_index) {\n        my $cur_diff = $max >= $numbers[$min_index + 1] ? $numbers[$min_index\
    \ + 1] - $max : $max - $numbers[$min_index + 1];\n        if ($cur_diff < $smallest_difference)\
    \ {\n            $smallest_difference = $cur_diff;\n            $min_index = $min_index\
    \ + 1;\n        }\n        elsif ($cur_diff > $greatest_difference) {\n      \
    \      $greatest_difference = $cur_diff;\n            $max_index = $max_index\
    \ - 1;\n        }\n        else {\n            last;\n        }\n    }\n    push\
    \ @$numbers, $numbers[$min_index];\n    push @$numbers, $numbers[$max_index];\n\
    \    return @$numbers;\n}\n</code>\n<|/ a tags=optimization,algorithm,perl,arrays\
    \ |>\n<| a tags=optimization,algorithm,perl,arrays |>\nHere's a solution that\
    \ will give you the result you want using Schwartzian transforms. It's similar\
    \ to how sorting works, but instead of comparing values in one array to the values\
    \ in another array, it compares the values in the array that you want to compare\
    \ to the values in your array. That way, you don't have to sort your array and\
    \ you get an O(log N) solution.\n<code>\nuse strict;\nuse warnings;", "    my\
    \ @closest_elements;\n    my $closest_element;\n    my $current_smallest_number;\n\
    \    my $current_largest_number;", "    my($smallest, $largest, $current, $previous,\
    \ $min, $max);\n    my(@results);", '    my($i, $j) = (0, 0);', "    my $closest\
    \ = undef;\n    my $closestIndex = 0;\n    my $currentIndex = 0;\n    \n    for\
    \ ($currentIndex = 0; $currentIndex < scalar(@$numbers); $currentIndex++) {\n\
    \        if ($numbers[$currentIndex] >= $numbers[$closestIndex]) {\n         \
    \   $closestIndex = $currentIndex;\n            $closest = undef;\n        } elsif\
    \ ($numbers[$currentIndex] <= $numbers[$closestIndex]) {\n            my $distance\
    \ = $numbers[$closestIndex] - $numbers[$currentIndex];\n            $closest =\
    \ undef;\n            for ($closestIndex = 0; $closestIndex < scalar(@$numbers);\
    \ $closestIndex++) {\n                if ($numbers[$closestIndex] <= $distance\
    \ && $numbers[$closestIndex] >= $numbers[$currentIndex]) {\n                 \
    \   $closest = $numbers[$closestIndex];\n                    $closestIndex = $currentIndex;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return ($closest,$closestIndex);\n}", "    my $min = @$numbers < 2 ?\
    \ $numbers[0] : $numbers[0];\n    my $max = @$numbers < 2 ? $numbers[0] : $numbers[0];",
  "    my ($smallest, $largest) = @$numbers[0, @$numbers - 1];\n    my ($smallest_index,\
    \ $largest_index) = 0, $#numbers;\n    while($smallest_index <= $largest_index)\
    \ {\n        $smallest = shift @$numbers;\n        while($smallest->($smallest_index)\
    \ <= $largest->($largest_index)) {\n            $smallest = shift @$numbers;\n\
    \        }\n        last if @$numbers == 0; # no more elements to check\n    \
    \    $largest = shift @$numbers;\n        while($largest->($largest_index) <=\
    \ $smallest->($smallest_index)) {\n            $largest = shift @$numbers;\n \
    \       }\n        last if @$numbers == 0; # no more elements to check\n     \
    \   $smallest_index++;\n        $largest_index--;\n    }\n    my $closest_index\
    \ = 0;\n    while(@$numbers > 1 && $smallest->($closest_index) == $largest->($closest_index))\
    \ {\n        shift @$numbers if $smallest_index == $largest_index;\n        $closest_index++;\n\
    \    }\n    my @closest_numbers = @$numbers[$smallest_index..$largest_index];\n\
    \    return @closest_numbers;\n}", '    my($min, $max);', '    my($min, $max);',
  "    my $min = 0;\n    my $max = $#numbers - 1;\n    my @result;\n    \n    while\
    \ ($min < $max) {\n        my $mid = ($min + $max) / 2;\n        $mid++ if $numbers[$mid]\
    \ > $numbers[$mid+1];\n        push @result, [$numbers[$mid], $numbers[$mid+1]];\n\
    \        $min = $mid + 1;\n        $max = $mid - 1;\n    }\n    return @result;\n\
    }", "    my @result;\n    # Find the two elements closest to each other.\n   \
    \ my $min_diff = abs($numbers[0] - $numbers[1]);\n    my ($a, $b) = ($numbers[0],\
    \ $numbers[1]);\n    for (my $i = 1; $i < (@$numbers - 1); $i++) {\n        my\
    \ $diff = $numbers[$i] - $a;\n        if ($diff < $min_diff) {\n            $a\
    \ = $numbers[$i];\n        }\n        else {\n            $b = $numbers[$i];\n\
    \        }\n    }\n    # Output the two numbers in order and return the array\
    \ slice.\n    push(@result, $a, $b);\n    @$numbers = @result;\n    return @$numbers;\n\
    }", "    return unless $numbers > 1;\n    my($small, $large) = (0, 0);\n    foreach\
    \ my $n (@$numbers) {\n        my($midpoint) = int(($n + $large) / 2);\n     \
    \   my($smaller, $larger) = ($midpoint + $small, $midpoint + $large);\n      \
    \  if ($smaller < $n) {\n            $smaller = $n;\n        }\n        if ($larger\
    \ > $n) {\n            $larger = $n;\n        }\n        $small = $smaller < $n\
    \ ? $smaller : $n;\n        $large = $larger > $n ? $larger : $n;\n    }\n   \
    \ return [@$numbers[$small .. $large]];\n}", "    # Find first two closest numbers\n\
    \    my $closest_elements = Math::Parsec::closest_numbers(@$numbers);\n    # If\
    \ there are less than two numbers then return first two\n    return @$closest_elements\
    \ if @$closest_elements < 2;\n    # Get all numbers greater than the two closest\
    \ ones\n    my @greater_numbers = $closest_elements[2..@$closest_elements];\n\
    \    # Return the first two numbers that are greater than the two closest ones\n\
    \    @$closest_elements = @greater_numbers;\n    @$closest_elements = Math::Parsec::closest_numbers(@$closest_elements);\n\
    \    # Return the elements from the original list that aren't in the array\n \
    \   return grep { ! exists $numbers[$_] } 0..$#numbers;\n}", "    # This is really\
    \ inefficient, but this function is only called on\n    # small-ish arrays, so\
    \ I don't think there is a way to speed it up much\n    # without rewriting it\
    \ entirely.\n    # $numbers is assumed to be sorted.", "    \n    my($min, $max)\
    \ = @_;\n    \n    if ($min == $max) {\n        return ($min, $min);\n    }\n\
    \    \n    return ($min < $max) ? \n\t(($numbers[0] < $numbers[1]) ? ($numbers[0],\
    \ $numbers[1]) : ($numbers[1], $numbers[0])) :\n\t(($numbers[0] > $numbers[1])\
    \ ? ($numbers[0], $numbers[1]) : ($numbers[1], $numbers[0]));\n}", '    my ($i,
    $min, $max) = @$numbers;', "    my($smallest_number);\n    my($larger_number);\n\
    \    my(@closest_numbers);", "    my $min = $numbers[0] > $numbers[1] ? $numbers[0]\
    \ : $numbers[1];\n    my $max = $numbers[0] > $numbers[1] ? $numbers[1] : $numbers[0];\n\
    \    my $index = $min > $max ? 0 : 1;", "    my ($min, $max) = @_;\n    return\
    \ unless @$numbers;", "    my @result;\n    my $min_distance;\n    my $max_distance;",
  "    my @closest_numbers = ();\n    my $min_diff = 10;\n    my $num_differences\
    \ = 1;\n    foreach my $number (@$numbers) {\n        if ($number == $numbers[-1])\
    \ {\n            push(@closest_numbers, $number);\n            next;\n       \
    \ }\n        for my $i (0..$num_differences-1) {\n            if (abs($number\
    \ - $numbers[$i+1]) < $min_diff) {\n                $min_diff = abs($number -\
    \ $numbers[$i+1]);\n                my $index = $i+1;\n                if ($min_diff\
    \ == 0) {\n                    push(@closest_numbers, $numbers[$index]);\n   \
    \                 last;\n                }\n            }\n        }\n       \
    \ $num_differences++;\n    }\n    return @closest_numbers;\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a tags=sorting,algorithm dscore=2 |>\nI have an optimized solution\
    \ in O(n) time. You can implement this in O(n) time and space complexity. \n<code>\n\
    def findClosest(numbers):\n    numbers = numbers.copy()\n    numbers.sort()\n\
    \    minDiff = numbers[0] - numbers[-1]\n    minIndex = -1\n    for i in range(len(numbers)):\n\
    \        if(numbers[i] - numbers[-1] < minDiff):\n            minDiff = numbers[i]\
    \ - numbers[-1]\n            minIndex = i", "    my @closest = ();\n    for my\
    \ $x (@$numbers) {\n        my $smallest;\n        my $current;\n        $smallest\
    \ = min($x);\n        $current = $x;\n        if ($x < $smallest) {\n        \
    \    $current;\n        }\n        else {\n            $smallest;\n        }\n\
    \        push(@closest, $current);\n    }\n    @closest;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks. Could you please explain how to get it working for an array\
    \ of arrays? For example, `@a = [[4,5,6,7],[8,9,10,11]]`\n<|/ c |>\n<| c |>\n\
    : I updated my answer. It was a pain, but I realized that my code actually doesn't\
    \ work as intended when dealing with lists of lists of numbers, like [[1, 2, 3],\
    \ [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]. Maybe this\
    \ will help: https://pastebin.com/RzJCcYqx\n<|/ c |>\n<| c |>\nThanks, it works\
    \ fine. I'm still new to perl, and it took me a while to understand it.\n<|/ c\
    \ |>\n<| c |>\nI tried to generalize it, and have added it in a separate answer\
    \ below.\n<|/ c |>\n<| a dscore=2 |>\nI think this solution is probably simpler\
    \ than the one by Joshua Taylor, and it is easier to generalize:\n<code>", " \
    \   my(@closest, $closest_value);\n    \n    my $smallest = $numbers[0];\n   \
    \ my $largest = $numbers[0];\n    \n    foreach my $value (@$numbers) {\n    \
    \    if ($value < $smallest) {\n            $smallest = $value;\n        }\n \
    \       if ($value > $largest) {\n            $largest = $value;\n        }\n\
    \    }\n    \n    push @$numbers, $smallest;\n    push @$numbers, $largest;\n\
    \    \n    return @$numbers;\n}\n</code>\n<|/ a tags=perl,sorting |>\n<| a tags=perl,sorting\
    \ dscore=2 |>\nA little benchmark of the answers here. \n<code>", "    my @numbers\
    \ = @$numbers;\n    my $min = $numbers[0];\n    my $max = $numbers[0];", "   \
    \ my @result;\n    my @numbers_to_compare;\n    my $min = 0;\n    my $max = scalar(@$numbers);\n\
    \    my $min_diff = MAX_DIFF;\n    my $max_diff = 0;", "    my(@closest);\n  \
    \  my($min);", "    my $min = $numbers[0];\n    my $max = $numbers[0];\n    foreach\
    \ my $num (@$numbers) {\n        if ($num > $max) {\n            $max = $num;\n\
    \        }\n        if ($num < $min) {\n            $min = $num;\n        }\n\
    \    }\n    return [ $min, $max ];\n}", "    my @ret;\n    my($min, $max);\n \
    \   \n    $min = $numbers[0];\n    $max = $numbers[-1];\n    \n    foreach my\
    \ $i (0 .. @$numbers - 1) {\n        if ($numbers[$i] < $min) { $min = $numbers[$i];\
    \ }\n        if ($numbers[$i] > $max) { $max = $numbers[$i]; }\n    }\n    \n\
    \    foreach my $i (0 .. @$numbers - 1) {\n        if ($numbers[$i] <= $min) {\
    \ push(@ret, $numbers[$i]); }\n        if ($numbers[$i] > $max) { push(@ret, $numbers[$i]);\
    \ }\n    }\n    \n    return @ret;\n}", "    my($i, $j, $smallest, $largest);\n\
    \    my $minimum = 1000000; # some large number to start with", "    my $min =\
    \ $numbers[0];\n    my $max = $numbers[0];\n    for my $number (@$numbers) {\n\
    \        if ($number < $min){ $min = $number; }\n        if ($number > $max){\
    \ $max = $number; }\n    }\n    return ($min, $max);\n}", "    my($min, $max)\
    \ = (0, 0);\n    my($smallest, $largest) = ();", "    my $min = 0;\n    my $max\
    \ = -1;\n    my $best;\n    \n    my $min_dist = undef;\n    my $max_dist = undef;\n\
    \    \n    # Find min & max values, and if possible the closest to those.\n  \
    \  foreach my $x (@$numbers) {\n\tmy $d = $x - $max;\n\tif (defined $min_dist\
    \ && $d < $min_dist) { $min_dist = $d; }\n\t\n\t$d = $max - $x;\n\tif (defined\
    \ $max_dist && $d > $max_dist) { $max_dist = $d; }\n\t\n\t$max = $x;\n\t$min =\
    \ defined($x) ? $x : undef;\n    }\n    \n    if (defined $min_dist) {\n\tprint\
    \ \"$min $max_dist\\n\" if defined $max_dist;\n\t$best = $max;\n    } else {\n\
    \tprint \"$min $max_dist\\n\" if defined $max_dist;\n\t$best = $min;\n    }\n\
    \    \n    my = grep { $best > $_ } @$numbers;\n    return \\@closest_numbers;\n\
    }", '    my @results;', "    my(@sorted);\n    my($low, $high);\n    push(@sorted,\
    \ $numbers[0]) if @$numbers > 0;\n    if (@$numbers == 1) {\n        return [$numbers[0]];\n\
    \    }\n    foreach $number(@$numbers) {\n        # Find the two numbers that\
    \ are farthest away from each other\n        $low = $high = $number;\n       \
    \ $low -= 1;\n        $high -= 1;\n        $numbers[$low] > $numbers[$high] or\
    \ do {\n            push(@sorted, $high);\n            pop(@$numbers);\n     \
    \       $high -= 1;\n        };\n        push(@sorted, $low) if $low == $high;\n\
    \        pop(@$numbers) if $low > $high;\n    }\n    return @sorted;\n}", "  \
    \  my($closest, $smallest, $largest);\n    $smallest = $largest = $numbers[0];\n\
    \    my $diff = $numbers[0] - $numbers[1];\n    if ($diff < 0) {\n        $smallest\
    \ = $numbers[1];\n        $diff = $numbers[1] - $numbers[0];\n    }\n    for my\
    \ $n (@$numbers) {\n        if ($diff < 0) {\n            if ($n <= $smallest)\
    \ {\n                $closest = $smallest;\n                $smallest = $n;\n\
    \                $diff = $n - $closest;\n            }\n        } elsif ($diff\
    \ > 0) {\n            if ($n > $largest) {\n                $closest = $largest;\n\
    \                $largest = $n;\n                $diff = $n - $closest;\n    \
    \        }\n        } else {\n            if ($n == $smallest) {\n           \
    \     $closest = $smallest;\n                $smallest = $n;\n            }\n\
    \            if ($n == $largest) {\n                $closest = $largest;\n   \
    \             $largest = $n;\n            }\n        }\n    }\n    return $smallest,\
    \ $largest;\n}", "    my($min, $max);\n    my @closest = ();\n    foreach my $num\
    \ (@$numbers) {\n        $min = $num if $min > $num;\n        $max = $num if $max\
    \ < $num;\n        push(@closest, [$num, $num] if $num > $max and $num < $min;\n\
    \    }\n    return @closest;\n}", "    my $min = $numbers[0];\n    my $max = $numbers[0];\n\
    \    my $index;", "    my @closest;\n    my $closest_diff = 999999999;\n    my\
    \ $closest_diff2 = 0;\n    my %closest;\n    foreach my $num (@$numbers) {\n \
    \       if (not exists $closest{$num}) {\n            push @closest, [$num, $num];\n\
    \            $closest{$num} = 1;\n        }\n        else {\n            my $diff\
    \ = $num - $closest{$num}[0];\n            if (abs($diff) < $closest_diff) {\n\
    \                $closest_diff = $diff;\n                push @closest, [$num,\
    \ $num];\n            }\n            else {\n                my $diff2 = $num\
    \ - $closest{$num}[1];\n                if (abs($diff2) < $closest_diff2) {\n\
    \                    $closest_diff2 = $diff2;\n                    push @closest,\
    \ [$num, $num];\n                }\n            }\n        }\n    }\n    return\
    \ @closest;\n}", "    return map { $numbers[$_] } grep { abs($numbers[$_] - $numbers[$_\
    \ -1]) < 0.01 } 0..$#$numbers;\n}", "    my ($i, $closest, $temp, $smallest) =\
    \ (0, 0, 0);\n    foreach my $num (@$numbers) {\n        if ($temp = $smallest)\
    \ {\n            $temp = $num;\n        }\n        $smallest = $num if $temp <\
    \ $num;\n        if ($smallest == $temp) {\n            $closest = $num;\n   \
    \         $smallest = $num;\n        }\n    }\n    return $closest;\n}", "   \
    \ my($min_two);\n    my($max_two);\n    my($min_index);\n    my($max_index);",
  "    my $min = sqrt($numbers[0]^2 + $numbers[1]^2);\n    my $closest = -1;\n   \
    \ my $i = 1;\n    foreach my $number (@$numbers) {\n        my $diff = sqrt($number^2\
    \ + $numbers[$i]^2);\n        if ($diff < $min) {\n            $min = $diff;\n\
    \            $closest = $i;\n        }\n        $i++;\n    }\n    return @$numbers[$closest\
    \ .. $#$numbers]\n}", "    my($min, $min_index) = (0, 0);\n    my($max, $max_index)\
    \ = (0, 0);\n    foreach my $i (0..$#numbers) {\n        # if the index is already\
    \ the minimum index then update it as the new minimum\n        if ($i < $min_index)\
    \ {\n            $min_index = $i;\n        }\n        # if the index is already\
    \ the maximum index then update it as the new maximum\n        if ($i > $max_index)\
    \ {\n            $max_index = $i;\n        }\n        if ($numbers[$i] < $numbers[$min])\
    \ {\n            $min = $numbers[$i];\n            $min_index = $i;\n        }\n\
    \        if ($numbers[$i] > $numbers[$max]) {\n            $max = $numbers[$i];\n\
    \            $max_index = $i;\n        }\n    }\n    return ($numbers[$min_index],\
    \ $numbers[$max_index]);\n}", "    my($closest_element_index) = undef;\n    my($closest_element_distance)\
    \ = undef;\n    my($index_min) = undef;", "    my $best_number = $numbers[0];\n\
    \    my $best_index = 0;\n    my $min_index = 0;\n    my $max_index = 0;\n   \
    \ my $min_dist = 0;\n    my $min_dist_index = 0;\n    for my $index (0 .. $#numbers)\
    \ {\n        if ($numbers[$index] <= $best_number) {\n            if ($best_index\
    \ == 0) {\n                $min_dist = $numbers[$index];\n                $best_index\
    \ = $index;\n            } else {\n                my $distance = $numbers[$index]\
    \ - $numbers[$best_index];\n                if ($distance < $min_dist) {\n   \
    \                 $min_dist = $distance;\n                    $best_index = $index;\n\
    \                }\n            }\n        }\n    }\n    if ($best_index == 0)\
    \ {\n        $best_index = 1;\n    }\n    if ($best_index > 0) {\n        $best_index\
    \ = $best_index - 1;\n        $numbers[$best_index] = $numbers[$best_index] +\
    \ 1;\n    }\n    my @sorted_numbers = @$numbers;\n    sort { $a <=> $b } @sorted_numbers;\n\
    \    return @sorted_numbers;\n}\n</code>\n<|/ a dscore=3 tags=sorting,perl,perl-data-structures\
    \ |>\n<| c |>\nThanks, that's a nice solution. Although it took a bit of extra\
    \ memory to store the array of numbers. It can be easily fixed with storing only\
    \ the closest element and updating the array of numbers with the remaining values\
    \ after each search.\n<|/ c |>\n<| c |>\nThanks, yes storing the closest element\
    \ after each search would be much easier\n<|/ c |>\n<| a tags=sorting,perl,perl-data-structures\
    \ |>\nIf you do not want to use List::MoreUtils::natatime, you can try this one\n\
    <code>\nuse List::Util qw(reduce);", "    my $smallest = @$numbers < 2 ? 0 : @$numbers\
    \ - 1;\n    my $largest = 0;\n    \n    for (my $i = 0; $i < @$numbers; $i++)\
    \ {\n        my $difference = $$numbers[$i] - $$numbers[$smallest];\n        if\
    \ ($difference < 0) {\n            $smallest = $i;\n        } elsif ($difference\
    \ > 0) {\n            $largest = $i;\n        }\n    }\n    return $numbers[$smallest],\
    \ $numbers[$largest];\n}", "    my $smallest_difference = undef;\n    my $next_smallest_difference\
    \ = undef;\n    my %numbers_map;\n    foreach my $i (@$numbers) {\n        $numbers_map{$i}\
    \ = $i;\n    }\n    my $smallest_number = shift @$numbers;\n    foreach my $i\
    \ (@$numbers) {\n        my $difference = abs($i - $smallest_number);\n      \
    \  if (!defined($smallest_difference) || $difference < $smallest_difference) {\n\
    \            $smallest_difference = $difference;\n            $smallest_number\
    \ = $i;\n            $next_smallest_difference = $i;\n        } elsif ($difference\
    \ == $smallest_difference) {\n            $next_smallest_difference = $i;\n  \
    \      }\n    }\n    return $smallest_number, $next_smallest_difference;\n}\n\
    </code>\n<|/ a tags=hash,perl,arrays,comparison |>\n<| a dscore=0 |>\nThis is\
    \ a slightly modified version of's find_closest_elements sub that avoids hashing\
    \ all the elements:\n<code>", "    my (@return, $smallest, $largest);\n    my\
    \ ($first, $second) = (0, 0);", "    return @$numbers[0] if (scalar @$numbers\
    \ == 1);\n    my @closest;\n    my ($smallest, $largest);\n    my $min_index =\
    \ $numbers->[0];\n    my $max_index = scalar @$numbers - 1;\n    while (scalar\
    \ @closest < 2) {\n        my $mid_index = ($min_index + $max_index) / 2;\n  \
    \      my $mid_number = $numbers[$mid_index];\n        if ($mid_number > $numbers[0])\
    \ {\n            $max_index = $mid_index - 1;\n        } else {\n            $min_index\
    \ = $mid_index + 1;\n        }\n        push(@closest, $mid_number);\n    }\n\
    \    return @closest;\n}", '    my($first, $second);', "    my(@closest_numbers);\n\
    \    my($closest_number);", "    my ($closest_index, $closest_value) = (), ();\n\
    \    my @min_value = ();\n    for (my $i = 0; $i < @$numbers; $i++) {\n      \
    \  # initialize min to last number in array\n        $min_value[$i] = $numbers[$i];",
  '    my(@sorted) = (sort {$a <=> $b} @$numbers);', "    my $min = find_smallest_number($numbers);\n\
    \    my $max = find_largest_number($numbers);\n    $max = abs($max);\n    my $min_index;\n\
    \    my $max_index;\n    my $max_value;\n    foreach my $i (0 .. $#numbers) {\n\
    \        if ($numbers[$i] <= $max) {\n            if ($numbers[$i] >= $min) {\n\
    \                if ($numbers[$i] == $min) {\n                    $min_index =\
    \ $i;\n                } else {\n                    $max_value = $numbers[$i];\n\
    \                    $max_index = $i;\n                }\n            }\n    \
    \    }\n    }\n    return [\n        shift(@$numbers,$min_index), $numbers[$min_index]\n\
    \    ];\n}\n</code>\n<|/ a dscore=4 tags=perl,arrays,algorithm,max |>\n<| a dscore=4\
    \ |>\n<code>", "    my($min, $max) = (0, $numbers[0]);\n    foreach my $i (0 ..\
    \ $#numbers) {\n        my $d = $numbers[$i] - $max;\n        $min = min $d, $min;\n\
    \        $max = max $d, $max;\n    }\n    return [sort {$a <=> $b} $numbers],\
    \ $min, $max;\n}", "    my $min = Math::BigInt->new(\"0\");\n    my $max = Math::BigInt->new(\"\
    0\");\n    my $min_index;\n    my $max_index;", "    my(@elements);\n    my($i,\
    \ $j, $closest_index);\n    my $min_diff;\n    foreach my $number (@$numbers)\
    \ {\n        foreach $i (0 .. $#$numbers) {\n            next unless $numbers[$i]\
    \ >= $number;\n        }\n        foreach $j ($i+1 .. $#$numbers) {\n        \
    \    next unless $numbers[$j] >= $number;\n        }\n        next unless $numbers[$i]\
    \ > $numbers[$j];\n        $min_diff = $numbers[$i] - $numbers[$j];\n        push\
    \ (@elements, $numbers[$j]);\n    }\n    return @elements;\n}", "    my @closest_elements;\n\
    \    my @min_and_max;\n    # Find the minimum and maximum and add them to the\
    \ min_and_max array.\n    my $minimum = pop(@$numbers);\n    $minimum = $minimum\
    \ + 0.0001 if $minimum < 0.0000001;\n    my $maximum = pop(@$numbers);\n    $maximum\
    \ = $maximum + 0.0001 if $maximum > 0.0000001;\n    push @min_and_max, [$minimum,\
    \ $maximum];\n    # Do some bookkeeping to find the two elements that are closest\
    \ to each\n    while (@$numbers > 1) {\n        my $minimum = pop(@$numbers);\n\
    \        my $maximum = pop(@$numbers);\n        my $diff_minimum = $minimum -\
    \ $minimum;\n        my $diff_maximum = $maximum - $maximum;\n        my $ratio\
    \ = $diff_maximum / $diff_minimum;\n        my $closest_value = $minimum + $ratio\
    \ * $maximum;\n        push @closest_elements, [$closest_value, $closest_value];\n\
    \        push @min_and_max, [$minimum, $maximum];\n    }\n    push @min_and_max,\
    \ [$minimum, $maximum];\n    return @closest_elements;\n}", "    my @numbers_sorted\
    \ = sort { $a <=> $b } @$numbers;\n    # Using grep() makes these two lines easier\
    \ to read:\n    # grep { $numbers_sorted->[0] <=> $_ }\n    grep { $numbers_sorted->[0]\
    \ <=> $_ } @$numbers;\n}", "    my($min, $max);\n    my($closest_number, $closest_value);\n\
    \    my $min_value;\n    my $max_value;", "    my $min = lc($numbers[0]);\n  \
    \  my $max = lc($numbers[0]);\n    my $found = 0;\n    foreach my $num (@$numbers)\
    \ {\n        if (lc($num) == $min) {\n            $found++;\n        } elsif (lc($num)\
    \ == $max) {\n            $found--;\n        } else {\n            $min = $num\
    \ if lc($num) < $min;\n            $max = $num if lc($num) > $max;\n        }\n\
    \    }\n    chomp(my $output = join(',', @$numbers[0..$found-1]));\n    $output\
    \ .= ','.$numbers[$found] if not $found;\n    return $output;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis fails when there is a tie. E.g., `[1,2,3]`. You also need\
    \ to choose the smallest value: `[1,2,3]` returns `2`, but `[2,2,3]` returns `3`.\n\
    <|/ c |>\n<| c |>\nAgreed, but that's what the original question stated, so it's\
    \ unclear what he actually wants to do with tied values, but I'm guessing that's\
    \ what he meant.\n<|/ c |>\n<| c |>\nThanks. That's much closer to what I'm after.\
    \ I'll give it a try.\n<|/ c |>\n<| c |>\nAh, I see what you mean. It wasn't clear\
    \ from your question as to whether the input arrays are ordered or not. I've reworked\
    \ the function to take that into account.\n<|/ c |>\n<| c |>\nHi Toby. I think\
    \ I understand your code. But I am not quite understanding why the last line in\
    \ the else block is necessary? It seems unnecessary. Why not simply return the\
    \ value? Can you please elaborate on that? Thanks.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's another way. Basically it finds the two closest numbers based on the delta\
    \ of the difference between the numbers. A little fiddly because of the way we\
    \ handle ties. First the helper functions\n<code>", "    my ($index) = @_;\n \
    \   my @elements = (@$numbers)[0..$index-1];\n    my $min = @elements;\n    my\
    \ $max = $index-1;\n    for(my $i = 1; $i < $index; $i++){\n        my $diff =\
    \ $elements[$i] - $elements[$i-1];\n        if($diff < $min){\n            $min\
    \ = $diff;\n        } elsif($diff > $max){\n            $max = $diff;\n      \
    \  } else {\n            last;\n        }\n    }\n    return @elements[$min..$max];\n\
    }", "    my @closest;\n    my %closest = map { $_ => undef; } keys %{ $numbers\
    \ };", "    my $min = shift @$numbers;\n    my $min = shift @$numbers;", "   \
    \ my $min_diff = -1;\n    my $min_number = undef;\n    my $max_number = undef;\n\
    \    my $current_diff = abs($numbers[1] - $numbers[0]);\n    my $current_number\
    \ = $numbers[1];\n    foreach my $number (@$numbers) {\n        my $diff = abs($number\
    \ - $current_number);\n        if ($diff < $current_diff) {\n            $current_diff\
    \ = $diff;\n            $current_number = $number;\n        }\n        if ($diff\
    \ < $min_diff) {\n            $min_diff = $diff;\n            $min_number = $current_number;\n\
    \        }\n        if ($diff > $max_diff) {\n            $max_diff = $diff;\n\
    \            $max_number = $current_number;\n        }\n    }\n    return ($min_number,\
    \ $max_number);\n}", "    my $smallest = $numbers[0];\n    my $largest = $numbers[0];\n\
    \    my $count = 1;", "    my @closest_numbers;\n    my $smallest_diff;\n    my\
    \ $current_diff;\n    foreach my $number (@$numbers) {\n        $current_diff\
    \ = $number - $smallest_diff;\n        push @closest_numbers, $number if ($current_diff\
    \ >= 0 && $current_diff < $smallest_diff);\n        $smallest_diff = $current_diff;\n\
    \    }\n    return @closest_numbers;\n}", "    my $first_min = $numbers[0];\n\
    \    my $first_max = $numbers[0];\n    my $second_min = $numbers[0];\n    my $second_max\
    \ = $numbers[0];\n    for (my $index = 1; $index <= scalar ($numbers); $index++)\
    \ {\n        my $current_min = $numbers[$index];\n        my $current_max = $numbers[$index];\n\
    \        if ($current_min < $first_min) {\n            $first_min = $current_min;\n\
    \        }\n        if ($current_max < $first_max) {\n            $first_max =\
    \ $current_max;\n        }\n        if ($current_min > $second_min) {\n      \
    \      $second_min = $current_min;\n        }\n        if ($current_max > $second_max)\
    \ {\n            $second_max = $current_max;\n        }\n    }\n    return ($first_min,\
    \ $first_max, $second_min, $second_max);\n}", "    my ($smallest, $largest);\n\
    \    my $numbers_ref = \\@$numbers;", "    my $min = 0;\n    my $max = 0;\n  \
    \  my $smallest = 0;\n    my $largest = 0;\n    foreach (@$numbers) {\n      \
    \  if ($smallest == 0) {\n            $min = $_;\n            $smallest = $_;\n\
    \        }\n        elsif ($largest == 0) {\n            $max = $_;\n        \
    \    $largest = $_;\n        }\n        elsif ($_ >= $smallest) {\n          \
    \  $min = $_;\n            $smallest = $_;\n        }\n        elsif ($_ < $largest)\
    \ {\n            $max = $_;\n            $largest = $_;\n        }\n    }\n  \
    \  my @result;\n    if ($min == $largest) {\n        @result = ();\n    }\n  \
    \  elsif ($smallest < $largest) {\n        @result = ();\n    }\n    else {\n\
    \        my $range = $largest - $smallest + 1;\n        @result = ($smallest +\
    \ $range/2);\n    }\n    return @result;\n}", "    my @nearest_elements;\n   \
    \ my $min_diff = $numbers[0];\n    my $closest_number;\n    my $i;\n    for my\
    \ $number (@$numbers) {\n        if ($min_diff > $number) {\n            $min_diff\
    \ = $number;\n            $closest_number = $number;\n        } elsif ($number\
    \ - $min_diff < $closest_number) {\n            $closest_number = $number;\n \
    \       }\n    }\n    return @nearest_elements;\n}", "    my($min, $max) = find_mins_and_max($numbers);\n\
    \    my($closest_elements);\n    \n    for my $i (0 .. $#{$numbers} - 1) {\n \
    \       my($this, $that) = $numbers[$i] eq $min\n                    ? [$min,\
    \ $numbers[$i + 1]]\n                    : [$numbers[$i + 1], $numbers[$i]];\n\
    \        \n        if ($this == $that) {\n            push (@{$closest_elements},\
    \ $this);\n            next;\n        }\n        \n        my($this_diff, $that_diff)\
    \ = $this - $that;\n        \n        if ($this_diff < $that_diff) {\n       \
    \     $closest_elements[$closest_elements_index] .= $that;\n            $closest_elements_index++;\n\
    \            $closest_elements[$closest_elements_index] = $this;\n        } else\
    \ {\n            $closest_elements[$closest_elements_index] .= $this;\n      \
    \      $closest_elements[$closest_elements_index] = $that;\n        }\n    }\n\
    \    \n    @$closest_elements;\n}", "    my $min = $numbers[0];\n    my $max =\
    \ $numbers[0];\n    for my $number (@$numbers) {\n        $min = $number if $number\
    \ < $min;\n        $max = $number if $number > $max;\n    }\n    return ($min,\
    \ $max);\n}", "    my $closest_diff;\n    my($closest, $current);\n    my @closest_values\
    \ = ();\n    my $current_min_diff = undef;\n    foreach my $num (@$numbers) {\n\
    \        $closest_diff = $num;\n        $current = $num;\n        foreach my $i\
    \ (1..$#{$numbers}) {\n            my $diff = $numbers[$i] - $current;\n     \
    \       if ($diff == 0) {\n                next;\n            }\n            $closest_diff\
    \ += $diff * $diff;\n            if ($diff < $current_min_diff) {\n          \
    \      $current_min_diff = $diff;\n                $closest = $current;\n    \
    \            $current = $numbers[$i];\n            }\n        }\n        push\
    \ @closest_values, $closest;\n    }\n    return @closest_values;\n}", "    my\
    \ $min_value = $numbers[0];\n    my $max_value = $numbers[0];\n    my %closest\
    \ = ( min => $min_value, max => $max_value );", "    my(@closest_numbers);\n \
    \   my(@closest_closest_numbers);", "    my $result = $numbers[0];\n    my $min;\n\
    \    my $max;\n    my $prev_min;\n    my $prev_max;\n    for my $i (1..$#numbers)\
    \ {\n        if ($numbers[$i] < $min) {\n            $min = $numbers[$i];\n  \
    \      }\n        if ($numbers[$i] > $max) {\n            $max = $numbers[$i];\n\
    \        }\n    }\n    for my $i ($min..$max) {\n        $result = $i;\n     \
    \   if ($numbers[$i] == $prev_min) {\n            return $result;\n        }\n\
    \        if ($numbers[$i] == $prev_max) {\n            return $result;\n     \
    \   }\n        $prev_min = $numbers[$i];\n        $prev_max = $numbers[$i];\n\
    \    }\n    return $result;\n}\n</code>\nThis solution works fine for small lists.\
    \ However, for larger lists, the time complexity is O(n). With n being the number\
    \ of elements in the list. To get around this issue I used a second array containing\
    \ the indices of the elements. I then use the indices to obtain the elements themselves.\
    \ The time complexity is then O(n).\n<|/ a |>\n<| a |>\nJust for fun: Here is\
    \ a solution using the \"trick\" of binary search:\n<code>\nuse strict;\nuse warnings;",
  "    my(@closest_elements);\n    my($min, $max);\n    my($closest_element, $i, $dist);",
  "    my @closest_elements;\n    my $smallest_distance;\n    my $second_smallest_distance;\n\
    \    my $min_distance;\n    my $second_min_distance;\n    my $smallest_number;\n\
    \    my $second_smallest_number;\n    my $max_distance;\n    my $second_max_distance;\n\
    \    my $max_number;\n    my $second_max_number;\n    foreach my $number (@$numbers)\
    \ {\n        my $distance_to_smallest_number = sqrt(($number * $number) + $smallest_number\
    \ * $smallest_number);\n        my $distance_to_second_smallest_number = sqrt(($number\
    \ * $number) + $second_smallest_number * $second_smallest_number);\n        if\
    \ ($min_distance == -1 || $distance_to_smallest_number < $min_distance) {\n  \
    \          $min_distance = $distance_to_smallest_number;\n            $smallest_number\
    \ = $number;\n        }\n        if ($second_min_distance == -1 || $distance_to_second_smallest_number\
    \ < $second_min_distance) {\n            $second_min_distance = $distance_to_second_smallest_number;\n\
    \            $second_smallest_number = $number;\n        }\n        if ($max_distance\
    \ == -1 || $distance_to_smallest_number > $max_distance) {\n            $max_distance\
    \ = $distance_to_smallest_number;\n            $max_number = $number;\n      \
    \  }\n        if ($second_max_distance == -1 || $distance_to_second_smallest_number\
    \ > $second_max_distance) {\n            $second_max_distance = $distance_to_second_smallest_number;\n\
    \            $second_max_number = $number;\n        }\n    }\n    @closest_elements\
    \ = ($smallest_number, $second_smallest_number, $max_number, $second_max_number);\n\
    \    return @closest_elements;\n}", "    my %min = map { abs($numbers[$_]) ? $_\
    \ => $numbers[$_] } 0..$#numbers;\n    my @results;\n    foreach my $number (sort\
    \ keys %min) {\n        if ($min{$number} > $numbers[$number]) {\n           \
    \ push(@results, $numbers[$number]);\n            pop(@results);\n        }\n\
    \    }\n    return @results;\n}\n</code>\n<|/ a tags=algorithm,perl,arrays |>\n\
    <| c |>\nThis has O(n^2) performance, which is very inefficient\n<|/ c |>\n<|\
    \ c |>\n: I agree, but it is O(n*m) where `n` is the size of the array to search\
    \ for and `m` is the size of the array containing the numbers to search for.\n\
    <|/ c |>\n<| a |>\n<code>\nmy =;\nmy;", "    my $result = $numbers[0];\n    my\
    \ $closest = $numbers[0];\n    my $smallest = $numbers[0];\n    my $largest =\
    \ $numbers[0];", '    return unless @$numbers > 2;', '    my @elements;', "  \
    \  my($min, $max) = (0, 1);\n    for my $n (@$numbers) {\n        my($i, $j) =\
    \ index($n, $numbers[$min]) .. index($n, $numbers[$max]);\n        $min = min\
    \ $i, $min;\n        $max = max $j, $max;\n    }\n    return @$numbers[$min..$max];\n\
    }", "    my $first_number = $numbers[0];\n    my $second_number = $numbers[1];\n\
    \    my $min_number = $first_number;\n    my $max_number = $second_number;\n \
    \   my $min_element = $numbers[0];\n    my $max_element = $numbers[1];", "   \
    \ $numbers = map { $_ } @$numbers;\n    $numbers[0] < $numbers[1] ? $numbers[0]\
    \ : $numbers[1];\n}", '    my @closest_numbers;', "    my ($i, $j, $min, $min_index,\
    \ $min_index2);\n    $i = 0;\n    $j = $#numbers;\n    $min = $numbers[$i];\n\
    \    $min_index = $i;\n    $min_index2 = $i;\n    while (1) {\n        $i++;\n\
    \        last unless $i eq $j;\n        $min_index = $i;\n        $min_index2\
    \ = $min_index;\n        $j--;\n        $min = $numbers[$j] if $numbers[$j] <\
    \ $min;\n    }\n    return [$min, $numbers[$min_index], $min_index2, $numbers[$min_index2]];\n\
    }", "    my($smallest, $largest) = ($numbers[0], $numbers[0]);\n    \n    foreach\
    \ my $number (@$numbers) {\n        if ($number > $largest) {\n            $largest\
    \ = $number;\n        } elsif ($number < $smallest) {\n            $smallest =\
    \ $number;\n        }\n    }\n    return $smallest, $largest;\n}", "    my ($smallest,\
    \ $largest, $found) = (0, 0);\n    my $len = scalar @$numbers;\n    for (my $i\
    \ = 0; $i < $len; $i++) {\n        if ($numbers[$i] < ($smallest || 0)) {\n  \
    \          $smallest = $numbers[$i];\n        }\n        if ($numbers[$i] > ($largest\
    \ || 0)) {\n            $largest = $numbers[$i];\n        }\n        $found++;\n\
    \    }\n    if ($found == 1) {\n        return [$smallest, $largest];\n    }\n\
    \    if ($found == 2) {\n        return [$smallest, $largest];\n    }\n    return;\n\
    }", "    my $min_element = min($numbers);\n    my $max_element = max($numbers);",
  "    my ($smallest, $largest) = (0, 0);\n    my @elements;", "    my(@closest_numbers,\
    \ $smallest, $largest);\n    foreach my $number (@$numbers) {\n        if($smallest->{'value'}\
    \ > $number) {\n            $smallest->{'value'} = $number;\n            $smallest->{'index'}\
    \ = $i;\n        }\n        if($largest->{'value'} < $number) {\n            $largest->{'value'}\
    \ = $number;\n            $largest->{'index'} = $i;\n        }\n    }\n    if(@$numbers\
    \ == 1) {\n        # There is only one number in the array; just return\n    \
    \    return @{$numbers}[1..2];\n    } else {\n        @closest_numbers = @{$numbers}[1..(@$numbers-1)];\n\
    \        return @closest_numbers;\n    }\n}", "    my $smallest;\n    my $largest;\n\
    \    my $temp;", "    my $min = 0;\n    my $max = scalar(@$numbers);\n    for\
    \ (my $i = 0; $i < $max; $i++) {\n        my $diff = $numbers[$i] - $numbers[$min];\n\
    \        if ($diff == 0) {\n            $min = $i;\n        }\n        elsif ($diff\
    \ < 0 and $numbers[$i] > $numbers[$min]) {\n            $min = $i;\n        }\n\
    \        elsif ($diff > 0 and $numbers[$i] < $numbers[$min]) {\n            $min\
    \ = $i;\n        }\n    }\n    return @$numbers[$min .. $max];\n}", "    my $closest\
    \ = undef;\n    my(@min_max_numbers);\n    my($small, $large);\n    my(@returned_numbers);\n\
    \    my $smallest = $numbers[0];\n    my $largest = $numbers[0];\n    foreach\
    \ my $num (@$numbers) {\n        if($smallest > $num) {\n            $smallest\
    \ = $num;\n        }\n        elsif($largest < $num) {\n            $largest =\
    \ $num;\n        }\n    }\n    foreach my $num (@$numbers) {\n        if($closest\
    \ != undef) {\n            if( abs($closest - $num) < abs($smallest - $num) )\
    \ {\n                next;\n            }\n            if( abs($closest - $num)\
    \ < abs($largest - $num) ) {\n                $closest = undef;\n            \
    \    next;\n            }\n        }\n        $closest = undef;\n        if(abs($smallest\
    \ - $num) < abs($largest - $num)) {\n            $smallest = $num;\n        }\n\
    \        else {\n            $largest = $num;\n        }\n    }\n    @min_max_numbers\
    \ = ($smallest, $largest);\n    foreach my $num (@$numbers) {\n        if($closest\
    \ != undef) {\n            if( abs($closest - $num) < abs($smallest - $num) )\
    \ {\n                next;\n            }\n            if( abs($closest - $num)\
    \ < abs($largest - $num) ) {\n                $closest = undef;\n            \
    \    next;\n            }\n        }\n        if(abs($smallest - $num) < abs($largest\
    \ - $num)) {\n            push @returned_numbers, $num;\n        }\n        else\
    \ {\n            push @returned_numbers, $num;\n        }\n    }\n    return @returned_numbers;\n\
    }", "    my($closest) = (0, 0);\n    my($smallest) = (0, 0);\n    foreach my $number\
    \ (@$numbers) {\n        my $distance = abs($number - $closest[0]);\n        if\
    \ ($distance < abs($number - $smallest[0])) {\n            $smallest = (' '.$number.'\
    \ '.$closest[0], $distance);\n        }\n        $closest = (' '.$number.' '.$smallest[0],\
    \ $distance);\n    }\n    return ($smallest[1], $closest[1]);\n}", "    my $min\
    \ = Math::Math::min($numbers);\n    my $max = Math::Math::max($numbers);\n   \
    \ my @closest_numbers = ();\n    for (my $i = 0; $i < @$numbers; $i++) {\n   \
    \     if ($numbers[$i] >= $min && $numbers[$i] <= $max) {\n            push(@closest_numbers,\
    \ $numbers[$i]);\n        }\n    }\n    return @closest_numbers;\n}", "    my\
    \ @closest_numbers;\n    # sort by absolute difference\n    @closest_numbers =\
    \ sort {abs($a) <=> abs($b)} @$numbers;\n    my $closest = @closest_numbers[0];\n\
    \    my $closest_index = @closest_numbers - 1;\n    my $closest_distance = abs($closest\
    \ - $numbers[0]);\n    return if @closest_numbers == 1;\n    # find smallest distance\
    \ to any other number\n    for my $index (1..$#closest_numbers) {\n        my\
    \ $distance = abs($closest - $closest_numbers[$index]);\n        if ($distance\
    \ < $closest_distance) {\n            $closest_distance = $distance;\n       \
    \     $closest_index = $index;\n        }\n    }\n    return @closest_numbers[$closest_index\
    \ .. $#closest_numbers];\n}", "    my($min, $max);\n    my($i) = 0;\n    while($i\
    \ < $#{$numbers}) {\n        if($numbers[$i] eq $numbers[$i+1]) {\n          \
    \  $i += 2;\n        }\n        else {\n            if(($numbers[$i] < $numbers[$i+1])\
    \ || ($numbers[$i] == $numbers[$i+1])) {\n                $min = $numbers[$i];\n\
    \                $max = $numbers[$i+1];\n                $i++;\n            }\n\
    \            else {\n                $min = $numbers[$i+1];\n                $max\
    \ = $numbers[$i];\n                $i++;\n            }\n        }\n    }\n  \
    \  return ($min, $max);\n}", "    if (scalar($numbers) <= 1) {\n        return;\n\
    \    }", "    my($closest_one, $closest_two) = (0, 0);\n    my(@closest_numbers);\n\
    \    my $min_diff = 0;\n    for my $index (0..$#numbers) {\n        my $diff =\
    \ $numbers[$index] - $numbers[$closest_two];\n        if ($diff < $min_diff) {\n\
    \            $closest_two = $index;\n            $closest_one = $closest_two;\n\
    \            $min_diff = $diff;\n        } elsif ($diff == $min_diff) {\n    \
    \        $closest_two = $index;\n        }\n    }\n    if ($closest_one == $closest_two)\
    \ {\n        @closest_numbers = (@numbers, $closest_one);\n    } else {\n    \
    \    @closest_numbers = ($numbers[$closest_one], $numbers[$closest_two]);\n  \
    \  }\n    @closest_numbers;\n}", '    return unless @$numbers;', "    return unless\
    \ @$numbers > 2;\n    my($first, $last) = (0, -1);\n    for my $num (@$numbers)\
    \ {\n        if ($num > $last) {\n            $last = $num;\n            $first\
    \ = $num;\n        } elsif ($num < $last) {\n            $last = $num;\n     \
    \   }\n    }\n    return [ $first, @$numbers[0..$#{$numbers}-1] ];\n}", "    return\
    \ unless @$numbers > 1;\n    my $smallest = min($numbers);\n    my $largest =\
    \ max($numbers);\n    return $numbers[$numbers ~~ [$smallest, $largest]];\n}",
  "    if (scalar($numbers) < 2) {\n        return ();\n    }\n    my @closest_elements;\n\
    \    my $min_index;\n    for (my $i = 1; $i <= scalar($numbers); $i++) {\n   \
    \     my $smallest_distance = undef;\n        my $smallest_element;\n        my\
    \ $distance = 0;\n        for my $j ($i+1, $numbers->[$i]) {\n            my $current_distance\
    \ = $_->($j) - $numbers->[$i];\n            if (defined($smallest_distance) &&\
    \ $current_distance < $smallest_distance) {\n                $smallest_distance\
    \ = $current_distance;\n                $smallest_element = $j;\n            }\n\
    \            $distance += $current_distance;\n        }\n        push(@closest_elements,\
    \ $smallest_element);\n        if (defined($smallest_distance)) {\n          \
    \  push(@closest_elements, $smallest_element);\n        }\n        if ($smallest_distance\
    \ != 0) {\n            $min_index = $i;\n        }\n    }\n    return @closest_elements;\n\
    }", '    return unless @$numbers > 2;', "    my(@result) = ( );\n    \n    foreach\
    \ my $number (@$numbers) {\n        my($smallest, $largest, $middle) = ();\n \
    \       \n        foreach my $number (@$numbers) {\n            $smallest = undef;\n\
    \            $largest = undef;\n            \n            if (abs($number - $numbers[$smallest])\
    \ < abs($number - $numbers[$largest])) {\n                if (abs($number - $numbers[$smallest])\
    \ < abs($number - $numbers[$middle])) {\n                    $smallest = $number;\n\
    \                    $middle = $number;\n                }\n                else\
    \ {\n                    $largest = $number;\n                }\n            }\n\
    \            else {\n                if (abs($number - $numbers[$largest]) < abs($number\
    \ - $numbers[$middle])) {\n                    $largest = $number;\n         \
    \           $middle = $number;\n                }\n                else {\n  \
    \                  $smallest = $number;\n                }\n            }\n  \
    \      }\n        \n        push(@result, $smallest);\n        push(@result, $largest);\n\
    \    }\n    \n    return @result;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,perl\
    \ |>\n<| a tags=algorithm,perl |>\nI think this is an interesting task for recursive\
    \ programming. I know Perl but this is the first time I've used it to solve this\
    \ problem. I was thinking I couldn't do this in one pass, because if I find a\
    \ number in the array that's smaller than the median and larger than the median,\
    \ I need to remove one of the elements, and then do the same for the remaining\
    \ elements, until I have one number left that's not less than the median.\nHere's\
    \ a solution that uses recursion. It also removes elements from the array when\
    \ they're found to be the median.\n<code>", "    my ($largest, $closest) = ();\n\
    \    my $smallest = $numbers[0];\n    foreach my $number (@$numbers) {\n     \
    \   if ($number < $smallest) {\n            $closest = $number;\n            $smallest\
    \ = $number;\n        } elsif ($number > $largest) {\n            $closest = $number;\n\
    \            $largest = $number;\n        } else {\n            next;\n      \
    \  }\n    }\n    return ($smallest, $closest);\n}", "    my $min = MAX_NUM;\n\
    \    my @closest_elements;", "    my($min, $max) = @$numbers;\n    my($smaller,\
    \ $larger) = (0, 1);\n    foreach my $number (@$numbers) {\n        if ($number\
    \ > $max) {\n            $larger = $number; # $smaller will change to this\n \
    \       } elsif ($number < $min) {\n            $smaller = $number;\n        }\
    \ else {\n            last;\n        }\n    }\n    return ($smaller, $larger);\n\
    }", '    my @result;', "    return sort { $a <=> $b } $numbers[0..($#numbers-1)];\n\
    }", "    my $closest_element = $numbers[-1];\n    my $smallest_distance = undef;\n\
    \    my $second_closest_element = $numbers[0];\n    for my $number (@$numbers)\
    \ {\n        # Use distance squared (squared = square root to remove square root)\
    \ from first element\n        # then square the distance to see which is the smallest\n\
    \        # Use that distance to find second element\n        my $distance = $number\
    \ - $closest_element;\n        $distance_squared = $distance * $distance;\n  \
    \      if ($distance_squared < $smallest_distance) {\n            $second_closest_element\
    \ = $closest_element;\n            $smallest_distance = $distance_squared;\n \
    \       } elsif ($distance_squared == $smallest_distance) {\n            $second_closest_element\
    \ = $number;\n        }\n    }\n    return ($smallest_distance, $second_closest_element);\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`find_closest_elements` only returns the second\
    \ closest element, not the closest two numbers.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out - fixed now.  I still think the code does its job, though.\n\
    <|/ c |>\n<| c |>\nYour second code doesn't work either. Try `find_closest_elements([1,\
    \ 2, 3, 10, 15, 20])`. It returns `[3, 15]`, when it should be `[3, 10]`.\n<|/\
    \ c |>\n<| c |>\nThanks for pointing that out.  I've updated the code accordingly\
    \ and I believe this now works.\n<|/ c |>\n<| a tags=perl,closest-points,sorting\
    \ |>\nHere is my version of Oscars solution using List::MoreUtils::nmin. It returns\
    \ the two numbers, not only the second closest one:\n<code>\nuse strict;\nuse\
    \ warnings;\nuse 5.010;\nuse List::MoreUtils qw(nmin);", "    my @ret;\n    my($i,\
    \ $min) = @_;\n    $min = $numbers->[$min];\n    for(my $i = 1; $i < scalar(@$numbers);\
    \ $i++) {\n        $i = ($i > $min ? $i : $min);\n        $i = ($i < $numbers->[$i]\
    \ ? $i : $numbers->[$i]);\n        $min = $i;\n        push @ret, @$numbers[$i];\n\
    \    }\n    @ret;\n}", "    my($min, $max) = @$numbers;\n    return $min unless\
    \ $min == $max;\n    if ($numbers[0] <= $numbers[1]) {\n        return $numbers;\n\
    \    }\n    my $closest = $numbers[0];\n    my $min_diff = $numbers[1] - $closest;\n\
    \    for my $number (@$numbers) {\n        my $diff = $number - $closest;\n  \
    \      if ($diff < $min_diff) {\n            $closest = $number;\n           \
    \ $min_diff = $diff if ($min_diff == 0);\n        }\n    }\n    return ($closest,\
    \ $closest);\n}\n</code>\n<|/ a tags=perl,arrays,subroutine |>\n<| c |>\nThe only\
    \ problem with this implementation is that it requires multiple passes through\
    \ the array, whereas `sort` only requires one pass through the array.  This makes\
    \ it faster if you have a large array and only need a few elements.  But yes,\
    \ this is the right answer.\n<|/ c |>\n<| c |>\n: I didn't take this implementation\
    \ into account, so thanks for pointing it out.\n<|/ c |>\n<| a |>\nI haven't tested\
    \ this for correctness, but a solution using map might look something like this.\n\
    <code>\nuse strict;\nuse warnings;", "    my $min = scalar(@$numbers);\n    my\
    \ $max = 0;\n    my $i = 0;\n    foreach my $number (@$numbers) {\n        next\
    \ unless $number > 0;\n        $max = $i;\n        $i = $number;\n    }\n    return\
    \ map {\n        $numbers[$_] > 0 ? $numbers[$_] : $numbers[$max]\n    } 0 ..\
    \ $max - 1;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI've used it for\
    \ a lot of different things and have had no problems. It's fast and has worked\
    \ well for me.\n<|/ a tags=perl,arrays |>\n<| a dscore=2 |>\nThe fastest way to\
    \ find the smallest value of a list is to use sort:\n<code>\nmy =;\nsort {$a <=>\
    \ $b} and print $sorted_values[0];\n</code>\n<|/ a tags=perl,arrays |>\n<| a |>\n\
    A quicker way is to find the minimum value in an array. \n<code>\nuse strict;\n\
    use warnings;", "    my($smallest, $largest) = ();\n    $smallest = $numbers[0];\n\
    \    $largest = $numbers[0];\n    foreach my $number (@$numbers) {\n        $smallest\
    \ = unless ($smallest > $number);\n        $largest = unless ($largest < $number);\n\
    \        $smallest = $number if ($smallest > $number);\n        $largest = $number\
    \ if ($largest < $number);\n    }\n    ($smallest, $largest);\n}", "    \n   \
    \ # Make sure numbers is an array\n    unless (ref($numbers) eq 'ARRAY') {\n \
    \       return $numbers;\n    }\n    \n    # Find smallest and largest of the\
    \ numbers\n    my $smallest = $numbers[0];\n    my $largest = $numbers[0];\n \
    \   foreach my $number (@$numbers) {\n        $smallest = $number if $number <\
    \ $smallest;\n        $largest = $number if $number > $largest;\n    }", "   \
    \ my($smallest, $largest) = ();\n    my($i, $j);\n    \n    # Sort smallest and\
    \ largest in descending order\n    $numbers = sort {$a <=> $b} @$numbers;\n  \
    \  \n    # Scan in order of smallest to largest\n    for ($i = $#$numbers; $i\
    \ > 0; $i--) {\n        $smallest = $numbers[$i];\n        $j = $i;\n        \n\
    \        # Look for the next element that is larger than the current one\n   \
    \     while ($j > 0 && $numbers[$j-1] > $smallest) {\n            $j--;\n    \
    \    }\n        \n        # Save larger as smallest\n        $smallest = $numbers[$j];\n\
    \        \n        # Save smallest as largest\n        $largest = $smallest;\n\
    \        \n        # Save smallest as current largest\n        $numbers[$j] =\
    \ $smallest;\n    }\n    \n    return @$numbers;\n}", "    my($smallest, $largest);\n\
    \    my(@closest, @closest_index);", "    my @closest_elements;\n    my $min_diff;\n\
    \    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    for (my $i = 0; $i <\
    \ scalar(@$numbers); $i++) {\n        $min_diff = $numbers[$i];\n        for (my\
    \ $j = $i + 1; $j < scalar(@$numbers); $j++) {\n            my $diff = $numbers[$j]\
    \ - $numbers[$i];\n            if (abs($diff) < $min_diff) {\n               \
    \ $min_diff = $diff;\n            }\n        }\n        push(@closest_elements,\
    \ $numbers[$i]);\n        $count++;\n    }\n    return @closest_elements;\n}",
  "    my $min = $numbers[0];\n    my $min_index = 0;", "    my @closest_elements;\n\
    \    my $previous_element;", "    my($closest_number);\n    my($smallest_distance);",
  "    return unless $numbers;\n    my @results = map {\n        my $diff = $_ - $numbers[$#numbers\
    \ + 1];\n        return $diff if $diff <= 0;\n        $diff\n    } (0..($#numbers\
    \ - 1));\n    my $largest = @results[-1];\n    my $smallest = @results[0];\n \
    \   @results\n}", '    return $numbers[0] if @$numbers < 2;', "    if (@$numbers\
    \ == 1) {\n        return (shift(@$numbers), $numbers[0]);\n    }\n    my $min_dist\
    \ = sqrt(@$numbers);\n    my $max_dist = 0;\n    foreach my $number (@$numbers)\
    \ {\n        my $dist = abs($number - $min_dist);\n        if ($dist > $max_dist)\
    \ {\n            $max_dist = $dist;\n        }\n    }\n    if ($max_dist > 0)\
    \ {\n        foreach my $number (@$numbers) {\n            my $dist = abs($number\
    \ - $min_dist);\n            if ($dist > $max_dist) {\n                my $result\
    \ = $number;\n                if ($dist < $min_dist + 1) {\n                 \
    \   $result = $min_dist;\n                }\n                return ($result,\
    \ $max_dist);\n            }\n        }\n    }\n    return (shift(@$numbers),\
    \ $numbers[0]);\n}", "    my(@min_values);\n    my(@max_values);\n    \n    foreach\
    \ my $number (@$numbers) {\n\tpush (@min_values, $number) if $number < $min_values[0];\n\
    \tpush (@max_values, $number) if $number > $max_values[0];\n    }\n    \n    return\
    \ ($min_values[0], $max_values[0]) if @min_values > 1;\n    return ($min_values[-1],\
    \ $max_values[-1]) if @max_values > 1;\n    \n    return ($min_values[0], $max_values[0])\
    \ if @min_values == @max_values;\n    return ($min_values[-1], $max_values[-1])\
    \ if @min_values > @max_values;\n    \n    # When there's only one element, just\
    \ return the element\n    return ($min_values[0], $min_values[0]) if @min_values\
    \ == 1;\n    return ($max_values[-1], $max_values[-1]) if @max_values == 1;\n}",
  "    return unless (@$numbers);\n    my $min_number = $numbers[0];\n    my $max_number\
    \ = $numbers[0];\n    for my $number (@$numbers) {\n        return $min_number,\
    \ $max_number if $number < $min_number or $number > $max_number;\n        $min_number\
    \ = $number;\n        $max_number = $number;\n    }\n    return $min_number, $max_number;\n\
    }", "    my @closest_elements = ();\n    my $smallest_number = $numbers[0];\n\
    \    my $largest_number = $numbers[-1];\n    my $index = 0;\n    my $closest_number\
    \ = $numbers[1];\n    # for each number in $numbers check which number is closest\
    \ to $closest_number\n    foreach my $number (@$numbers) {\n        if (abs($number\
    \ - $closest_number) < abs($closest_number - $number)) {\n            my $next_number\
    \ = $numbers[$index + 1];\n            if (abs($next_number - $closest_number)\
    \ < abs($closest_number - $next_number)) {\n                $closest_number =\
    \ $number;\n                $closest_index = $index;\n            }\n        \
    \    else {\n                $closest_number = $next_number;\n               \
    \ $closest_index = $index++;\n            }\n        }\n        else {\n     \
    \       if (abs($number - $closest_number) > abs($closest_number - $number)) {\n\
    \                $closest_number = $number;\n                $closest_index =\
    \ $index;\n            }\n            else {\n                $closest_number\
    \ = $numbers[$index];\n                $closest_index = $index++;\n          \
    \  }\n        }\n    }\n    push (@closest_elements, $closest_number);\n    push\
    \ (@closest_elements, $closest_numbers[$closest_index]);\n    return @closest_elements;\n\
    }", "    my @sorted;\n    my @close;\n    my $min;\n    my $max;\n    $min = $max\
    \ = $numbers[0];\n    for my $number (@$numbers) {\n        if ($number < $min)\
    \ {\n            $min = $number;\n        } elsif ($number > $max) {\n       \
    \     $max = $number;\n        } else {\n            $min = $number if $number\
    \ < $min;\n            $max = $number if $number > $max;\n        }\n    }\n \
    \   push(@sorted, $min);\n    push(@sorted, $max);\n    push(@close, $min);\n\
    \    push(@close, $max);\n    return @close;\n}", "    my $closest_element = 999999999;\n\
    \    my $second_closest_element = 999999999;\n    for my $num (@$numbers) {\n\
    \        my $tmp = $num;\n        if (abs($closest_element - $tmp) < abs($closest_element\
    \ - $second_closest_element)) {\n            $closest_element = $tmp;\n      \
    \  }\n        $second_closest_element = $closest_element;\n    }\n    return [grep\
    \ {abs($num - $_) < abs($closest_element - $_)} @$numbers];\n}", "    $numbers\
    \ = [grep((my $v = shift) !~ m/^[+-]?\\d+$/ && $v != 0, @$numbers)];\n    if (@$numbers\
    \ == 0) {\n        die \"No numbers supplied\\n\";\n    }\n    my $smallest =\
    \ @$numbers > 1 ? $numbers[0] : 1;\n    my $largest = @$numbers > 1 ? $numbers[1]\
    \ : 0;", "    my $min = Math::BigInt->new(0);\n    my $max = $numbers[0];\n  \
    \  my $min_index = 0;\n    my $max_index = 0;\n    for(my $i = 0; $i < @$numbers;\
    \ $i++) {\n        # Find smallest and largest values\n        if($min > $numbers[$i])\
    \ {\n            $min = $numbers[$i];\n            $min_index = $i;\n        }\
    \ elsif($numbers[$i] > $max) {\n            $max = $numbers[$i];\n           \
    \ $max_index = $i;\n        }\n    }\n    return [\n        Math::BigInt->new($numbers[$min_index]),\n\
    \        Math::BigInt->new($numbers[$max_index]),\n    ];\n}", "    my($max_index)\
    \ = scalar(@$numbers);\n    my($min_diff) = abs(@$numbers);\n    my($closest_diff)\
    \ = (@$numbers[0]);\n    for ($i = 1; $i < $max_index; $i++) {\n        if ($closest_diff\
    \ > abs(@$numbers[$i])) {\n            $closest_diff = abs(@$numbers[$i]);\n \
    \           $min_diff = $closest_diff;\n            $closest_index = $i;\n   \
    \     }\n    }\n    return @$numbers[$closest_index..$max_index];\n}", "    if\
    \ (scalar(@$numbers) <= 1) {\n        return;\n    }\n    my $best_dist = undef;\n\
    \    my $best_pair = undef;\n    foreach my $idx (0..scalar(@$numbers)) {\n  \
    \      my $dist = -($numbers[$idx] - $numbers[$idx-1]);\n        if (defined $best_dist\
    \ and $dist < $best_dist) {\n            next;\n        }\n        if (defined\
    \ $best_dist and $dist == $best_dist) {\n            $best_pair = ($idx, $idx-1);\n\
    \        }\n        $best_dist = $dist;\n    }\n    return $best_pair;\n}", " \
    \   my(@closest_to_each) = ();\n    my(@closest_to_each_index) = ();\n    my(@selected_numbers)\
    \ = ();\n    my($current_smallest_number_index);\n    my($current_smallest_number);\n\
    \    my($current_largest_number_index);\n    my($current_largest_number);\n  \
    \  my($smallest_number_is_in_selected_numbers_array);\n    my($largest_number_is_in_selected_numbers_array);\n\
    \    foreach my $number(@$numbers) {\n        next unless ($number);\n       \
    \ next unless ($number < $current_smallest_number);\n        next unless ($number\
    \ > $current_largest_number);\n        push(@closest_to_each, $number);\n    \
    \    push(@closest_to_each_index, $index);\n        push(@selected_numbers, $number);\n\
    \        $current_smallest_number = $number;\n        $current_smallest_number_index\
    \ = $index;\n        push(@selected_numbers, $number);\n        $current_largest_number\
    \ = $number;\n        $current_largest_number_index = $index;\n    }\n    while\
    \ (@closest_to_each_index) {\n        $current_smallest_number_index--;\n    \
    \    $current_smallest_number = shift(@closest_to_each);\n        $current_largest_number_index--;\n\
    \        $current_largest_number = shift(@closest_to_each);\n        $smallest_number_is_in_selected_numbers_array\
    \ = $current_smallest_number in @selected_numbers;\n        $largest_number_is_in_selected_numbers_array\
    \ = $current_largest_number in @selected_numbers;\n        if ($smallest_number_is_in_selected_numbers_array)\
    \ {\n            push(@closest_to_each, $current_smallest_number);\n         \
    \   push(@closest_to_each_index, $current_smallest_number_index);\n        }\n\
    \        if ($largest_number_is_in_selected_numbers_array) {\n            push(@closest_to_each,\
    \ $current_largest_number);\n            push(@closest_to_each_index, $current_largest_number_index);\n\
    \        }\n    }\n    return wantarray ? @closest_to_each : \\@closest_to_each;\n\
    }", "    my ($biggest, $smallest) = ($numbers[$#numbers], $numbers[0]);\n    for\
    \ my $i (1 .. $#numbers) {\n        my $d = $numbers[$i] - $smallest;\n      \
    \  if ($d < $biggest) {\n            $smallest = $numbers[$i];\n        }\n  \
    \      elsif ($d > $biggest) {\n            $biggest = $d;\n        }\n    }\n\
    \    return ($biggest, $smallest);\n}", "    # Find the two closest values to\
    \ each other.\n    my $closest_elements = $numbers[0];\n    my $closest_distance\
    \  = $numbers[1];\n    my @rest;", "    my @return = ();\n    my $smallest;\n\
    \    my $largest;\n    my $min_index;\n    my $max_index;\n    my $value;\n  \
    \  $min_index = 0;\n    $max_index = $#{$numbers} - 1;\n    while ($min_index\
    \ <= $max_index) {\n        my $temp = $numbers[$min_index];\n        $min_index++;\n\
    \        $min_index if $min_index < $max_index;\n        my $temp_min = $numbers[$min_index];\n\
    \        my $temp_max = $numbers[$min_index];\n        $min_index++;\n       \
    \ my $min_diff;\n        my $max_diff;\n        while ($min_index <= $max_index)\
    \ {\n            $temp = $numbers[$min_index];\n            $min_index++;\n  \
    \          $min_index if $min_index < $max_index;\n            $temp_min = $numbers[$min_index];\n\
    \            $min_index++;\n            $min_diff = $temp_max - $temp;\n     \
    \       $max_diff = $temp - $temp_min;\n            last if $min_diff < $max_diff;\n\
    \        }\n        last if $temp < $smallest;\n        $smallest = $temp;\n \
    \       last if $temp > $largest;\n        $largest = $temp;\n    }\n    my @return\
    \ = ();\n    for ($min_index; $min_index <= $max_index; $min_index++) {\n    \
    \    $return[$min_index] = $numbers[$min_index];\n    }\n    return @return;\n\
    }", "    my @closest_elements;\n    my $smallest_difference = find_smallest_difference($numbers[0],\
    \ $numbers[1]);\n    my $closest_element = $numbers[0];\n    for my $number (@$numbers)\
    \ {\n        my $difference = find_smallest_difference($number, $closest_element);\n\
    \        if ($difference == $smallest_difference) {\n            push(@closest_elements,\
    \ $closest_element);\n            $closest_element = $number;\n        }\n   \
    \     $smallest_difference = $difference;\n    }\n    push(@closest_elements,\
    \ $closest_element);\n    return @closest_elements;\n}\n</code>\n<|/ a dscore=0\
    \ tags=perl,arrays |>\n<| c |>\nWhile this is definitely a good start, it doesn't\
    \ produce the correct result when there is a tie. For example when there is two\
    \ equal minimum differences.\n<|/ c |>\n<| a |>\nThe key point is this:", '    my($i,
    $j, $closest);', "    my($min, $max) = (undef, undef);\n    \n    my $num = $numbers[0];\n\
    \    foreach my $num (@$numbers) {\n        if ($num < $min) { $min = $num; }\n\
    \        if ($num > $max) { $max = $num; }\n    }\n    return ($min, $max);\n}",
  "    my $min = min($numbers);\n    my $max = max($numbers);\n    my = grep { abs($number\
    \ - $min) < abs($number - $max) };\n    return;\n}\n</code>\n<|/ a tags=arrays,perl\
    \ |>\n<| a dscore=2 tags=arrays,perl |>\n<code>", "    my($min) = undef;\n   \
    \ my($min2) = undef;", "    my $max_diff = undef;\n    my $first_number = $numbers[0];\n\
    \    my $second_number = $numbers[1];\n    for(my $index = 0; $index < @$numbers;\
    \ $index++) {\n        $max_diff = undef;\n        if($index == 0) {\n       \
    \     $max_diff = ($numbers[$index] - $first_number);\n            $first_number\
    \ = $numbers[$index];\n        } elsif($index == 1) {\n            $max_diff =\
    \ ($numbers[$index] - $second_number);\n            $second_number = $numbers[$index];\n\
    \        } else {\n            my $diff = ($numbers[$index] - $numbers[$index\
    \ - 1]);\n            if($diff > $max_diff) {\n                $max_diff = $diff;\n\
    \            }\n        }\n    }\n    return ($first_number, $second_number, $max_diff);\n\
    }", "    my($closest_numbers) = [];\n    my($min_index);\n    my($max_index);",
  "    my @closest_numbers;\n    my $smallest = $numbers[0];\n    my $largest = $numbers[0];\n\
    \    for my $number (@$numbers) {\n        my $diff = $number - $smallest;\n \
    \       if ($diff < $smallest) {\n            $smallest = $diff;\n        }\n\
    \        if ($diff > $largest) {\n            $largest = $diff;\n        }\n \
    \       push @closest_numbers, $number;\n    }\n    return @closest_numbers;\n\
    }\n</code>\nAnd some tests:\n<code>\nprint \"\\n\";\nprint find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), \"\\n\";\nprint find_closest_elements([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.1]), \"\\n\";\nprint find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.5, 2.2]), \"\\n\";\nprint find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.7, 2.3]), \"\\n\";\n</code>\noutputs:\n<code>\n[2.0, 2.2]\n[2.0,\
    \ 2.0]\n[2.0, 2.3]\n[2.0, 2.7]\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl,subroutine\
    \ dscore=0 |>\nMy solution is based on Tie::IxHash\n<code>\nuse Tie::IxHash;\n\
    my = qw(\n    1 2 3 4 5\n    8 7 6 5 4\n);", "    my (@nearest_numbers);\n   \
    \ my (@min_delta);", '    my($min, $max) = (0, 0);', "    my($min, $max);\n  \
    \  \n    my $closest_number;\n    my $closest_index = 0;\n    \n    for (my $i\
    \ = 0; $i < @$numbers; $i++) {\n        if ($numbers[$i] < $numbers[$closest_number])\
    \ {\n            $closest_number = $numbers[$i];\n            $closest_index =\
    \ $i;\n        }\n    }\n    \n    return @$numbers[0..$closest_index];\n}\n</code>\n\
    The function returns the two numbers that you requested. The returned array has\
    \ the smaller number at index 0, and the larger number at index 1.\n<|/ a dscore=0\
    \ tags=arrays,perl,sorting |>\n<| c |>\nPlease don't use 'my' for variables -\
    \ it can confuse readers and it can mask the global variable of a package. Also,\
    \ the default package is still called \"main\", so \"sub find_closest_elements\"\
    \ is going to confuse most people who come across it.\n<|/ c |>\n<| c |>\nI agree.\
    \ I changed `my` to `local` to prevent confusion. `sub find_closest_elements {`\n\
    <|/ c |>\n<| a tags=arrays,perl,sorting |>\nThis is a case where an XY problem\
    \ might make sense.\nYou have two pieces of information and you want to determine\
    \ the relationship (the direction of travel) of the two pieces of information\
    \ together to determine the shortest distance between them.\nIn your case, you\
    \ are trying to determine a relationship (the direction of travel) between a particular\
    \ location (latitude and longitude) and the closest pair of locations, and the\
    \ shortest distance between them.\nThis type of problem is called 'travelling'\
    \ a distance between two points.\nYour array represents locations (latitude and\
    \ longitude), and you want to find the shortest distance between locations 1 and\
    \ 2.\nI do not think it can be solved using the 'sort' function because it is\
    \ just too slow.\nYou need to calculate the distance between each pair of locations\
    \ and then find the pair with the smallest distance between them.\nI cannot think\
    \ of an easy way to do this in a single statement.  So I would suggest creating\
    \ a function called 'distance' that accepts a pair of locations as arguments and\
    \ returns the distance between them.  Then you can use this function to do the\
    \ following:", "    my @closest_numbers = ();\n    my $smallest_value = $numbers[0];\n\
    \    my $largest_value = $numbers[0];\n    my $last_index = scalar(@$numbers)\
    \ - 1;\n    foreach my $index (0..$last_index){\n        my $current_value = $numbers[$index];\n\
    \        my $difference = $current_value - $smallest_value;\n        if (abs($difference)\
    \ < abs($largest_value - $current_value)){\n            $smallest_value = $current_value;\n\
    \        }\n        else{\n            $largest_value = $current_value;\n    \
    \    }\n        push @closest_numbers, $current_value;\n    }\n    return @closest_numbers;\n\
    }", '    my($min, $max) = @$numbers;', "    my(@closest_numbers);\n    my(@smallest_numbers);\n\
    \    my(@largest_numbers);\n    my $smallest_number = $numbers[0];\n    my $largest_number\
    \ = $numbers[0];\n    foreach my $number (@$numbers) {\n        if($number < $smallest_number)\
    \ {\n            $smallest_number = $number;\n        }\n        elsif($number\
    \ > $largest_number) {\n            $largest_number = $number;\n        }\n  \
    \  }\n    my $smallest_number_index = 0;\n    my $largest_number_index = 0;\n\
    \    foreach my $number (@$numbers) {\n        if($number < $smallest_number)\
    \ {\n            $smallest_number_index++;\n            $smallest_number = $number;\n\
    \        }\n        elsif($number > $largest_number) {\n            $largest_number_index++;\n\
    \            $largest_number = $number;\n        }\n    }\n    push(@closest_numbers,\
    \ $smallest_number);\n    push(@closest_numbers, $largest_number);\n    for(my\
    \ $i = $smallest_number_index; $i <= $largest_number_index; $i++) {\n        push(@smallest_numbers,\
    \ $numbers[$i]);\n    }\n    for(my $i = $largest_number_index; $i >= $smallest_number_index;\
    \ $i--) {\n        push(@largest_numbers, $numbers[$i]);\n    }\n    return @closest_numbers;\n\
    }", '    my(@closest_numbers);', "    my @sorted_numbers;\n    my $smallest =\
    \ undef;\n    my $largest = undef;\n    my $middle = undef;\n    my $index_of_smallest_number\
    \ = 0;\n    my $index_of_largest_number = 0;\n    my $num_elements = scalar @$numbers;",
  '    my ($min, $max) = (0, 0);', "    my $min = Math::BigRat->new('1');\n    my\
    \ $max = Math::BigRat->new('0');\n    my $elements;\n    my $temp;\n    my $index;\n\
    \    my $last;\n    my $count = 0;", '    return if scalar @$numbers < 2;', " \
    \   my @min_and_max;\n    my $min = shift(@$numbers);\n    my $max = shift(@$numbers);",
  "    \n    my $result = $numbers[0];\n    my $smaller = $numbers[0];\n    my $larger\
    \ = $numbers[0];\n    \n    for (my $i = 1; $i < @$numbers; $i++) {\n        my\
    \ $diff = $larger->-$result if $larger->-$result > $numbers[$i];\n        \n \
    \       if ($diff == 0) {\n            $result = $numbers[$i];\n            $smaller\
    \ = $numbers[$i];\n            $larger = $result;\n        } else {\n        \
    \    $result = $numbers[$i];\n            $smaller = $result;\n            $larger\
    \ = $numbers[$i];\n        }\n    }\n    \n    return @$numbers[$i..$#$numbers],\
    \ $result, $smaller, $larger;\n}", "    my(@closest_numbers);\n    my($numbers_length)\
    \ = $numbers->[0];", "    return $numbers[0], $numbers[1] if @$numbers > 1;\n\
    \    my($number, $delta) = @$numbers;\n    return $numbers[@$numbers - 1], $numbers[0]\
    \ if @$numbers == 2;\n    my ($min_dist, $min_num) = @$numbers;\n    for my $num\
    \ (@$numbers) {\n        my($dist) = abs($num - $min_num);\n        if ($dist\
    \ < $min_dist) {\n            $min_dist = $dist;\n            $min_num = $num;\n\
    \        }\n    }\n    @$numbers = ($min_num, $min_num);\n    return @$numbers;\n\
    }", "    my($smallest);\n    my($largest);", "    my @closest_elements = ();\n\
    \    my $min = $numbers[0];\n    my $max = $numbers[0];\n    foreach my $num (@$numbers)\
    \ {\n        my $dist = abs($min - $num);\n        if ($dist < $max) {\n     \
    \       $max = $dist;\n            $min = $num;\n        } elsif ($dist == $max)\
    \ {\n            $max = $num;\n        }\n        push(@closest_elements, $num);\n\
    \    }\n    return @closest_elements;\n}", "    my($i, $j, $smallest, $smallest_index,\
    \ $large, $large_index);\n    # Sort $numbers ascending\n    @$numbers = sort\
    \ {$a <=> $b} @$numbers;\n    # Initialize variables\n    $smallest = pop(@$numbers);\n\
    \    $large = pop(@$numbers);\n    $smallest_index = -1;\n    $large_index = -1;\n\
    \    for(my $i = 0; $i < scalar(@$numbers); $i++) {\n        if ($numbers[$i]\
    \ == $smallest) {\n            $smallest_index = $i;\n        }\n        elsif\
    \ ($numbers[$i] == $large) {\n            $large_index = $i;\n        }\n    \
    \    else {\n            if ($numbers[$i] < $smallest) {\n                $smallest\
    \ = $numbers[$i];\n                $smallest_index = $i;\n            }\n    \
    \        else {\n                $large = $numbers[$i];\n                $large_index\
    \ = $i;\n            }\n        }\n    }\n    return ($smallest_index, $large_index);\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
