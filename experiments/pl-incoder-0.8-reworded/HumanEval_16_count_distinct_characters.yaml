name: HumanEval_16_count_distinct_characters
language: pl
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters(\"\
  Jerry\")\n# 4\nsub count_distinct_characters {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_distinct_characters;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcde\"),5)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdecadeCADE\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"aaaaAAAAaaaa\"),1)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jerry\
  \ jERRY JeRRRY\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n}\n\ntesthumaneval();"
completions: ["    my($length) = (length($string));\n    my(@count) = (0);", "   \
    \ my $characters = '';\n    foreach my $char (split(//,$string)) {\n        $characters\
    \ .= $char;\n        die if $char =~ /[[:upper:]]/;\n    }\n    return scalar(split(//,$characters));\n\
    }", "    my $count = 1;\n    while ($string =~ /([A-Z])/g) {\n        $count +=\
    \ ($1 eq $string) ? ($count+3) : 1;\n    }\n    return $count;\n}", "    my($characters);\n\
    \    my($character);", "    my $count = 0;\n    $string =~ tr/a-zA-Z//cd;\n  \
    \  ++$count;\n    $string =~ tr/A-Z//cd;\n    ++$count;\n    $string =~ tr/0-9//cd;\n\
    \    ++$count;\n    return $count;\n}", "    $string =~ tr/A-Za-z//d;\n    return\
    \ scalar keys %seen;\n}", '    my($num);', "    my $count = 0;\n    $string =~\
    \ tr/a-zA-Z/a-zA-Z/;\n    $string =~ tr/A-Za-z/A-Za-z/;\n    $string =~ tr/0-9/0-9/;\n\
    \    while($string =~ /[^a-zA-Z0-9]+/) {\n        $count++;\n    }\n    return\
    \ $count;\n}", "    return scalar grep {lc eq $_} split(//, $string);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=0 tags=perl,string,regex |>\nIf you're looking\
    \ for a faster way of counting distinct characters in strings, this is what I\
    \ came up with, using a single regex:\n<code>", "    return length($string) -\
    \ length($string =~ tr/A-Z/a-z/);\n}", "    my($length, $count);\n    $count =\
    \ 1;\n    while($string =~ /([a-z])\\1*/g) {\n        $count++;\n    }\n    return\
    \ $count;\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    return scalar keys %{ map\
    \ { $_ => 1 } split //, $string };\n}", "    my($characters) = 0;\n    my($lowercase)\
    \ = 0;\n    my($uppercase) = 0;\n    my($digit) = 0;\n    my($special) = 0;\n\
    \    my($total) = 0;", "    my($uniques) = 1;\n    my($count) = 0;", "    my($characters);\n\
    \    my($distinct) = 0;\n    my($first);\n    \n    foreach $characters(split\
    \ //, $string) {\n\t$first++;\n\t$distinct += ($characters == $characters) ? 1\
    \ : 0;\n    }\n    \n    return $distinct / $first;\n}", "    return scalar(map\
    \ { uc($string) } split //, $string);\n}", "    return scalar(split(//,$string));\n\
    }", '    my $result;', "    my $count = 0;\n    my $char_length = length($string);\n\
    \    for(my $i = 0; $i < $char_length; $i++) {\n        $count += ($string =~\
    \ /[A-Za-z]/ ? 1 : 0) + ($string =~ /[0-9]/ ? 1 : 0) + ($string =~ /[!@#$%^&*()_+\\\
    -=\\[\\]{};':\"\\\\|,.<>\\/?]/ ? 1 : 0);\n    }\n    return $count;\n}", "   \
    \ my $counter = 0;\n    for (split(//, $string)) {\n        if ($counter != $_)\
    \ {\n            $counter++;\n        }\n    }\n    return $counter;\n}", "  \
    \  return scalar(sort(split //, $string))->uniq->length;\n}", "    $string =~\
    \ tr/a-zA-Z0-9//cd;\n    return $string;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for adding this answer, as I never realized how powerful `tr` can be. :)\n<|/\
    \ c |>\n<| c |>\nThe `tr` is much simpler (and more efficient) than mine, I'll\
    \ be using that instead. Thanks again for the answer!\n<|/ c |>\n<| c |>\nThe\
    \ `tr` solution is much more flexible than mine. It will also work with the `a`\
    \ character and many other Unicode characters.\n<|/ c |>\n<| c |>\nThis does not\
    \ work for all Unicode characters. For example it does not work with `\u2020`\
    \ (which has unicode code point U+2074) as well as `\xC6` (which also has unicode\
    \ code point U+00C6). I would use `tr/a-zA-Z0-9\u2020-\xC6-\xD8-\xC5-\xC0-\xFF\
    //cd;` to cover all the characters in the range `a-z` (case insensitive), `A-Z`\
    \ (case insensitive), `\xE6` (case insensitive) and `\xF8` (case insensitive),\
    \ then `tr/-\u2020\xE6\xF8\xC6\xD8\xC5\xE0\xC0\xFF//cd;` to cover the remaining\
    \ characters in the range `A-Z` (case insensitive).\n<|/ c |>\n<| a |>\nAnother\
    \ way to do it, using just regular expression matching:\n<code>", "    my $count\
    \ = 0;\n    foreach my $char (split //, $string) {\n        $count++ unless $char\
    \ =~ /[a-z]/i or $char =~ /[A-Z]/i or $char =~ /\\d/i;\n    }\n    return $count;\n\
    }", "    $string =~ tr/a-zA-Z0-9//cd;\n    return scalar keys %{ map { uc($_)\
    \ => 1 } $string };\n}", "    $string =~ tr/A-Za-z//cd;\n    $string =~ tr/A-Za-z0-9//cd;\n\
    \    return scalar $string;\n}", "    return 0 if $string eq \"\";\n    my $len\
    \ = length($string);\n    return 0 if $len < 1;\n    return $len if $len < 2;\n\
    \    my $num_distinct = 0;\n    my $first_char = $string[0];\n    foreach my $char\
    \ (@$string) {\n        my $prev_char = $char;\n        my $prev_char_tolower\
    \ = uc($prev_char);\n        if ($char eq $first_char) {\n            ++$num_distinct;\n\
    \        }\n        elsif ($char eq $prev_char) {\n            ++$num_distinct;\n\
    \        }\n        elsif ($char eq $prev_char_tolower) {\n            ++$num_distinct;\n\
    \        }\n        else {\n            ++$num_distinct;\n        }\n    }\n \
    \   return $num_distinct;\n}", "    my %characters = ();\n    $characters{' '}\
    \ = 0;\n    $characters{'\\n'} = 0;\n    $characters{'\\t'} = 0;\n    $characters{'\\\
    r'} = 0;", "    my $count = 0;\n    my $lower;\n    my $upper;\n    my @chars;",
  "    # Remove non-alpha characters:\n    $string =~ s/\\W//g;\n    # Count unique\
    \ characters:\n    return scalar keys %$string;\n}\n</code>\n<|/ a tags=algorithm,perl\
    \ |>\n<| c |>\nThis is actually wrong, at least for \"Jerry\"\n<|/ c |>\n<| c\
    \ |>\n: Thanks for pointing it out. Fixed.\n<|/ c |>\n<| a dscore=4 tags=algorithm,perl\
    \ |>\nA solution in perl\n<code>\nmy $s = \"aBcde\";\n$s =~ tr/a-zA-Z//;\nmy $n\
    \ = $s =~ tr/a-zA-Z//;\n</code>\n<|/ a |>\n<| c |>\nPerl doesn't have tr/// so\
    \ this is not a Perl solution.\n<|/ c |>\n<| c |>\n- It will work because tr///\
    \ is implemented in Perl.\n<|/ c |>\n<| c |>\nBut it's not Perl - it's POSIX shell\
    \ scripting.\n<|/ c |>\n<| a tags=algorithm,perl |>\n<code>", '    my $count =
    0;', "    my(@results,@distinct_characters);\n    my($first_char,$last_char);\n\
    \    \n    foreach my $char (split(' ',$string)) {\n        ($first_char,$last_char)\
    \ = ($char,$char) if $first_char eq $last_char;\n        push(@distinct_characters,$char);\n\
    \    }\n    \n    foreach my $char (@distinct_characters) {\n        ++$results[$char];\n\
    \    }\n    \n    return @results;\n}", "    my $count = 1;\n    $string =~ tr/A-Za-z//;\n\
    \    $string =~ tr/A-Z//;\n    $string =~ tr/a-z//;\n    while ($string =~ tr/A-Z//)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    my($count, $ch);\n\
    \    for(my $i=0;$i<length($string);$i++) {\n        $ch = substr($string, $i,\
    \ 1);\n        $count++ if !defined $count{$ch};\n        $count{$ch} = 1;\n \
    \   }\n    return $count;\n}", "    my $length = $#{$string} - 1;\n    return\
    \ 0 if !defined $string;\n    my $total = 0;\n    my $previous = $string[$length];\n\
    \    foreach my $character (reverse @{$string}) {\n        if ($character ne $previous)\
    \ {\n            $total++;\n            $previous = $character;\n        }\n \
    \   }\n    return $total if $total > 0;\n    return 0;\n}", "    my $count = (length($string)\
    \ -\n                   $string =~ tr/a-z/A-Z/) +\n                   (length($string\
    \ =~ tr/A-Z/a-z/) -\n                    length($string =~ tr/a-z/A-Z/));\n  \
    \  return $count + (length($string =~ tr/A-Z/a-z/) -\n                       length($string\
    \ =~ tr/a-z/A-Z/));\n}", "    my $count = () = map { uc } split //, $string;\n\
    \    return scalar keys %$count;\n}", "    my($count_distinct) = 0;\n    my($length)\
    \ = $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/0-9//cd;\n\
    \    my($count_lowercase) = $string =~ tr/a-z/A-Z/;\n    my($count_uppercase)\
    \ = $string =~ tr/A-Z/A-Z/;\n    my($count_numbers) = $string =~ tr/0-9//cd;\n\
    \    my($count_special) = 0;\n    $count_distinct += $length;\n    $count_distinct\
    \ += $count_lowercase;\n    $count_distinct += $count_uppercase;\n    $count_distinct\
    \ += $count_numbers;\n    $count_distinct += $count_special;\n    return $count_distinct;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nIt would be a nice improvement if you could explain\
    \ why you think it's a good improvement and what the purpose of your code is.\
    \ Also, you should probably remove the second `tr` in the first `count_distinct_characters`\
    \ to avoid confusion.\n<|/ c |>\n<| c |>\nPlease note that your \"count_distinct\"\
    \ does not count distinct characters, it counts how many letters there are, excluding\
    \ numbers. If you want to count distinct letters including numbers you should\
    \ do something like this instead: my $count_distinct = () = $string =~ m/([A-Z]+)/gi;\n\
    <|/ c |>\n<| c |>\nThe second `tr` was there to remove any case-differences. It's\
    \ a good idea to add it back in if you want.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ at the top. Sorry for not being more clear earlier. Thanks for the feedback.\n\
    <|/ c |>\n<| a tags=algorithm,perl |>\nUse a hash to count distinct characters:\n\
    <code>", "    my $count = scalar(split(//, $string));\n    \n    # Special cases:\
    \ 0 characters, empty string\n    return $count if $count <= 1;\n    \n    # Special\
    \ case: all letters are lowercase \n    return $count if $string eq lc($string);\n\
    \    \n    # Special case: all letters are uppercase\n    return $count if $string\
    \ eq uc($string);\n    \n    # Special case: all letters are lowercase or all\
    \ letters are uppercase\n    return $count if lc($string) eq uc($string);\n  \
    \  \n    # Special case: one letter is uppercase, one letter is lowercase\n  \
    \  return $count if (lc($string) eq uc($string)) || (uc($string) eq lc($string));\n\
    \    \n    return $count + (length($string) - scalar(split(//, $string)));\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nAh, I see why you think that would be a more\
    \ elegant way to count the distinct characters. But it doesn't work at all. Even\
    \ after converting the string to lowercase, there are still two more distinct\
    \ characters than there are in the original string: `my $distinct_character_count\
    \ = scalar(sort(split(//, $string)));`\n<|/ c |>\n<| c |>\nYou were right on the\
    \ `sort`. I forgot to remove it when I rewrote my answer. Replacing it with `scalar\
    \ split(//, $string)` solves the problem perfectly.\n<|/ c |>\n<| c |>\nThis is\
    \ an old answer, but just for future reference, there is another problem with\
    \ `sort`: If the string is all ASCII, the sort will work just fine, but if the\
    \ string contains non-ASCII characters, it will fail and return 0. See [this answer](http://stackoverflow.com/a/30753969/376454)\
    \ for an example where this happens.\n<|/ c |>\n<| c |>\nFor those trying to use\
    \ this solution, keep in mind that it does not work if the string has Unicode\
    \ characters. I had to rewrite the method with Unicode characters handling.\n\
    <|/ c |>\n<| c |>\nThe comment is incorrect. The first comment is correct.\n<|/\
    \ c |>\n<| a |>\nHere's a shorter variant of Mark's answer:\n<code>", "    $string\
    \ =~ tr/[A-Z]/A/g;\n    $string =~ tr/[a-z]/a/g;\n    $string =~ tr/[0-9]/0/g;\n\
    \    return scalar $string;\n}", "    $string =~ tr/A-Z/a-z/;\n    return scalar(()\
    \ = $string =~ /[^a-z]/ig);\n}", "    my $count = 0;\n    \n    for my $character\
    \ (split //, $string) {\n        $count += length($character);\n    }\n    \n\
    \    return $count;\n}", '    my($chars);', "    my $total = 0;\n    $string =~\
    \ tr/A-Z/a-z/;\n    $total += length $string;\n    $string =~ tr/a-z/A-Z/;\n \
    \   $total += length $string;\n    return $total;\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThanks for the explanation on why you chose to use `tr/a-z/A-Z/`.\
    \ I had just read up on the `tr` operator and was very surprised when I saw that\
    \ you could only use it one way or the other. I never would have guessed that.\n\
    <|/ c |>\n<| c |>\nIt's pretty unfortunate that there's only one way to go about\
    \ this. It seems like a very poor design choice on the part of the Perl developers.\n\
    <|/ c |>\n<| c |>\nNot necessarily. I guess it is just because I like Perl better,\
    \ and I find it easier to reason about things in Perl instead of having to remember\
    \ how these things really work. I find it harder to believe that Perl is anything\
    \ more than a fancy regex engine, and that some things are just not possible or\
    \ very difficult to do without using regex tricks.\n<|/ c |>\n<| c |>\nI agree\
    \ that Perl is *very* fancy, and I like Perl, but I still find the concept of\
    \ \"string manipulation\" to be confusing when there are multiple ways to do it.\
    \ So I don't mind Perl not having this nice trick, but I do find it frustrating\
    \ that they decided to make `tr` the only way to go, but forgot about `lc` or\
    \ `uc`, which could be the best way to go. But I guess it can be explained that\
    \ way.\n<|/ c |>\n<| c |>\nYes, `tr` is one of the best ways to go about this.\
    \ I too find it frustrating that Perl's `tr` is so poorly designed and implemented\
    \ with limited functionality. Also, `tr` can do more than just replace individual\
    \ characters with something else. For example, `tr/a{2,4}z/y{2,4}z` will replace\
    \ all `a`s with `y`s and all `b`s with `z`s, even though `tr` can do that in a\
    \ single step. See [this](http://perldoc.perl.org/functions/tr.html) for details.\n\
    <|/ c |>\n<| a tags=perl,regex |>\nIn order to count the number of distinct characters,\
    \ you don't need to count the number of characters at all. Just take the first\
    \ character. That's easy:\n<code>\n", "    # Count unique characters regardless\
    \ of case\n    my $count = 0;\n    foreach my $char (split(//, $string)) {\n \
    \       $count++ if ($char !~ m/[A-Z]/ && ! $char !~ m/[a-z]/);\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    map { ++$count } split //, $string;\n\
    \    return $count;\n}", "    my($uni_char_count) = 1;\n    my($char_count_table)\
    \ = ();\n    my($char_count_table) = (\n        1 => 1,\n        2 => 1,\n   \
    \     3 => 1,\n        4 => 2,\n        5 => 2,\n        6 => 2,\n        7 =>\
    \ 3,\n        8 => 3,\n        9 => 3,\n        10 => 3,\n        11 => 4,\n \
    \       12 => 4,\n        13 => 4,\n        14 => 4,\n        15 => 4,\n     \
    \   16 => 4,\n        17 => 4,\n        18 => 4,\n        19 => 4,\n        20\
    \ => 5,\n        21 => 5,\n        22 => 5,\n        23 => 5,\n        24 => 5,\n\
    \        25 => 5,\n        26 => 5,\n        27 => 5,\n        28 => 5,\n    \
    \    29 => 6,\n        30 => 6,\n        31 => 6,\n        32 => 6,\n        33\
    \ => 6,\n        34 => 6,\n        35 => 6,\n        36 => 7,\n        37 => 7,\n\
    \        38 => 7,\n        39 => 7,\n        40 => 7,\n        41 => 7,\n    \
    \    42 => 7,\n        43 => 7,\n        44 => 7,\n        45 => 7,\n        46\
    \ => 7,\n        47 => 7,\n        48 => 8,\n        49 => 8,\n        50 => 8,\n\
    \        51 => 8,\n        52 => 8,\n        53 => 8,\n        54 => 8,\n    \
    \    55 => 8,\n        56 => 8,\n        57 => 8,\n        58 => 8,\n        59\
    \ => 9,\n        60 => 9,\n        61 => 9,\n        62 => 9,\n        63 => 9,\n\
    \        64 => 9,\n        65 => 9,\n        66 => 9,\n        67 => 9,\n    \
    \    68 => 9,\n        69 => 9,\n        70 => 9,\n        71 => 9,\n        72\
    \ => 9,\n        73 => 9,\n        74 => 9,\n        75 => 9,\n        76 => 10,\n\
    \        77 => 10,\n        78 => 10,\n        79 => 10,\n        80 => 10,\n\
    \        81 => 10,\n        82 => 10,\n        83 => 10,\n        84 => 10,\n\
    \        85 => 10,\n        86 => 10,\n        87 => 10,\n        88 => 10,\n\
    \        89 => 10,", "    return scalar(grep {lc($_) eq uc($string)} split('',\
    \ $string));\n}", "    my($total_chars) = 0;\n    my($total_chars_lowercase) =\
    \ 0;\n    my($total_chars_uppercase) = 0;", "    $string =~ tr/A-Za-z/a-z/;\n\
    \    return scalar keys %{_};\n}", "    $string =~ tr/a-zA-Z/A-Z/;\n    return\
    \ scalar(keys %_);\n}", "    my $count = () = $string =~ m/([a-zA-Z])/g;\n   \
    \ return $count ? $count : 1;\n}", "    my $count = 0;\n    foreach my $c (split(//,\
    \ $string)) {\n        $count++ if $c !~ /[a-z]/i;\n    }\n    return $count;\n\
    }", "    $string =~ tr/A-Za-z/A-Za-Z/;\n    return $string =~ tr/A-Z/a-z/;\n}",
  "    my $i = 0;\n    my %seen;\n    while (++$i, $string=~m/\\G(.)/sg) {\n     \
    \   my $char = $1;\n        $seen{$char}++;\n    }\n    return $i;\n}", "    $string\
    \ =~ tr/A-Za-z//cd;\n    length($string) - $string =~ tr/A-Z//cd;\n}", "    return\
    \ scalar(scalar(keys(%{$string =~ tr/a-z/A-Z/}) - keys(%{$string =~ tr/A-Z/a-z/})));\n\
    }", "    my %counts;\n    $counts{\"\"} = 1;\n    $counts{\"A\"} = 1;\n    for\
    \ my $char (split //, $string) {\n        $counts{ uc($char) }++;\n    }\n   \
    \ return scalar keys %counts;\n}", "    $string =~ tr/a-zA-Z0-9//cd;\n    return\
    \ $string =~ tr/[a-z]/[a-z]/ig;\n}", "    my $count = 0;\n    my $len = length($string);\n\
    \    my $i;\n    for ($i = 0; $i < $len; $i++) {\n        if ($string[$i] =~ /[[:lower:]]/)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    my\
    \ $count = 0;\n    foreach my $char (split //, $string) {\n        $count++ while\
    \ $string =~ /($char)/i;\n    }\n    return $count;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    return length($string);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=perl,string,substring\
    \ |>\n<code>\nuse feature 'say';\nuse 5.010;\nuse warnings;", "    my $count =\
    \ 0;\n    foreach my $char (split(//, $string)) {\n        $count++ if !exists\
    \ $counts{$char}++;\n    }\n    return $count;\n}", "    my $char_counter = 0;\n\
    \    my(@characters) = split //, $string;\n    foreach my $character (@characters)\
    \ {\n        $char_counter += scalar(@{ $unique_characters{$character} });\n \
    \   }\n    return $char_counter;\n}", "    my($characters) = 0;\n    my($current_character)\
    \ = \"\";\n    foreach $char (split //, $string) {\n        if ($char eq $current_character)\
    \ {\n            $characters++;\n        }\n        else {\n            $current_character\
    \ = $char;\n            $characters++;\n        }\n    }\n    return $characters;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    my $count=0;\n    for (split(//,$string))\
    \ {\n       ++$count;\n    }\n    return $count;\n}", "    my %counts;\n    my\
    \ $count = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n        my $char\
    \ = $string[$i];\n        $counts{$char} = $counts{$char} + 1;\n    }\n    return\
    \ scalar keys %counts;\n}", '    return 0 if !defined $string;', "    return scalar(my($count));\n\
    }", "    return scalar(grep { ($string =~ /$_/) ? 1 : ($string !~ /$_/) } @characters);\n\
    }", "    $string =~ tr/a-zA-Z//cd;\n    return length($string);\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    return length($string) - length(translate($string, '1234567890',\
    \ ''));\n}", "    return scalar keys %{ map {lc($_) => 1} map {uc$_} split /[\\\
    s-]/, $string };\n}\n</code>\n<|/ a |>\n<| c |>\nOhh I see what you're doing!\
    \ This is really cool and actually works to solve the problem. I'll have to figure\
    \ out exactly how it works though. I've been trying to understand the regex but\
    \ I'm really not sure what it does exactly. Could you explain how the regex works?\
    \ I'm guessing it's basically splitting on the whitespaces and then converting\
    \ the lowercase to uppercase for the first and second elements. But I can't really\
    \ understand what the regex is doing exactly.\n<|/ c |>\n<| c |>\n- Added explanation.\
    \ Hope it's clearer.\n<|/ c |>\n<| c |>\n, your regex is missing a closing brace:\
    \ `s/^(\\S+)\\s+(\\S+)\\s+(.*)/\\1\\n\\2\\n\\3\\n/`\n<|/ c |>\n<| a dscore=4 |>\n\
    I was going to use perl, but I thought that maybe awk could be used. Since I didn't\
    \ want to use it, I did some more digging, and came up with this:\n<code>\nawk\
    \ '{print substr($0,length($0),1)}' file > file.new\n</code>\nBasically, it finds\
    \ the length of the string in the file, and removes the first character.\nI got\
    \ this from here: How can I remove the first character in a string in bash?\n\
    <|/ a tags=perl,regex |>\n<| c |>\nThis doesn't work if you have an embedded newline\
    \ in your string (like `$'string'`)\n<|/ c |>\n<| c |>\n- True, but that can be\
    \ overcome with some more fiddling around with awk's `RS` variable.\n<|/ c |>\n\
    <| a dscore=3 tags=perl,regex |>\nThis might work for you:\n<code>\n$str =~ s/^[^[:upper:]]//;\n\
    </code>\nThe regex will find any non-uppercase letters at the beginning of the\
    \ string and remove them.\n<|/ a |>\n<| a dscore=3 |>\nUsing pure Perl one can\
    \ write it like this:\n<code>", "    $string =~ tr/A-Za-z//cd;\n    return length($string);\n\
    }", "    my($chars) = 0;\n    foreach my $char (split //, $string) {\n       \
    \ $chars += $char =~ tr/A-Z//;\n    }\n    return $chars;\n}", "    my @chars\
    \ = $string =~ /([a-zA-Z0-9_]+)/gi;\n    return scalar(@chars);\n}", "    return\
    \ scalar(@{$_[0]} ^ (split(' ', $string)));\n}", "    return length($string) -\
    \ count_chars($string);\n}", "    my $count = 0;\n    while ($string =~ /([A-Za-z])/)\
    \ {\n        $count++;\n    }\n    return $count;\n}", "    my $count = 0;\n \
    \   map { $count++ } split //, $string;\n    return $count;\n}", "    my %letters\
    \ = ();\n    foreach (split //,$string) { $letters{$_}++; }\n    return scalar\
    \ keys %letters;\n}", "    $string =~ tr/A-Z/A-Z/;\n    $string =~ tr/a-z/a-z/;\n\
    \    $string =~ tr/0-9/0-9/;\n    length($string);\n}", "    my $count = 0;\n\
    \    $string =~ s/([^A-Za-z0-9])/$count++/ig;\n    return $count;\n}", "    $string\
    \ =~ tr/a-zA-Z0-9_//cd;\n    return scalar(keys(%count));\n}", "    return scalar(grep\
    \ { length($_) == 1 } split(//, $string));\n}", "    my $result = 0;\n    my $i\
    \ = 0;\n    while (my $char = $string[$i]) { # find out how many characters are\
    \ in the string\n        $result += (length($char) - length($_)) unless ($_ =\
    \ $char);\n        $i++;\n    }\n    return $result;\n}", "    return scalar grep\
    \ {!$seen{$_}++} split /(?=[A-Z])/, $string;\n}", "    return undef unless $string;\n\
    \    return scalar(grep $_, unique(map { uc($_) } split(//, $string)));\n}", " \
    \   my($count) = uc(length($string));\n    for my $char (split(//, $string)) {\n\
    \        $count++ if uc($char) != $char;\n    }\n    return $count;\n}", "   \
    \ my $count = scalar(keys %{ map { uc($_) => 1 } $string });\n    $count += scalar\
    \ keys %{ map { lc($_) => 1 } $string };\n    return $count;\n}", "    $string\
    \ =~ tr/A-Z//;\n    $string =~ tr/a-z//;\n    $string =~ tr/0-9//;\n    length($string);\n\
    }", "    my $total_distinct_characters = 0;\n    my $characters_lowercase = 0;\n\
    \    my $characters_uppercase = 0;\n    for my $char ($string =~ /[a-z]/i) {\n\
    \        $characters_lowercase += 1;\n    }\n    for my $char ($string =~ /[A-Z]/i)\
    \ {\n        $characters_uppercase += 1;\n    }\n    $total_distinct_characters\
    \ = $characters_lowercase + $characters_uppercase;\n    return $total_distinct_characters;\n\
    }", "    my(@characters) = ();\n    my($count, $character);", "    $string =~\
    \ tr/A-Z//d;\n    return scalar keys %$string;\n}\n</code>\n<|/ a tags=perl |>\n\
    <| c |>\nI believe the problem is the fact that `tr` translates to `s/\\b[A-Z]//g;`\
    \ which can remove more than 1 capital letter because it will find all of them\
    \ at the start of the word. Try `\"aaABCDE\"` where `\"BBBBB\"` is found at the\
    \ start. Though `/\\b[A-Z]/g` would work.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\n\
    use warnings;", '    my $cnt = 0;', "    $string =~ tr/a-zA-Z0-9//d;\n    return\
    \ scalar keys %{$_[0]};\n}", "    $string =~ tr/A-Z/a-z/;\n    return scalar(split(//,\
    \ $string));\n}", '    my $count = 0;', "    my $distinct_characters = 0;\n  \
    \  foreach my $char (split //, $string) {\n        $distinct_characters ++ if\
    \ $char !~ m/[a-z]/i || $char !~ m/[A-Z]/i;\n    }\n    return $distinct_characters;\n\
    }", "    my($length, $distinct, $character);\n    $distinct = 0;\n    foreach\
    \ $character (split(//, $string)) {\n        # Keep track of how often each character\
    \ appears.\n        next unless $length++ != 0;\n        $distinct++;\n    }\n\
    \    $length;\n}", "    return scalar( $string =~ tr/A-Z/a-z/igc );\n}", "   \
    \ $string =~ tr/ +//d;\n    return scalar keys %{ $string };\n}", "    my(@results);\n\
    \    my($i,$j);", "    my($hash) = @_;\n    my($number_of_distinct_characters)\
    \ = 0;", "    $string =~ tr/[a-z]/[A-Z]/;\n    return $string =~ tr/[A-Z]/[a-z]/;\n\
    }", "    return $string =~ tr/A-Za-z/A-ZA-Z/;\n}", "    my $count = 0;\n    my\
    \ $char;\n    foreach $char (split(//,$string)) {\n        $count++;\n    }\n\
    \    return $count;\n}", "    my(@characters) = ();\n    my($current_character);\n\
    \    my($number_of_distinct_characters);\n    my($number_of_distinct_characters_below_the_current_character);\n\
    \    my($number_of_distinct_characters_above_the_current_character);\n    foreach\
    \ $current_character (split(//, $string)) {\n        push(@characters, $current_character);\n\
    \    }\n    $number_of_distinct_characters = scalar(@characters);\n    foreach\
    \ $current_character (@characters) {\n        $number_of_distinct_characters_below_the_current_character\
    \ = $number_of_distinct_characters - 1;\n        $number_of_distinct_characters_above_the_current_character\
    \ = $number_of_distinct_characters + 1;\n    }\n    return $number_of_distinct_characters;\n\
    }", "    return 0 if $string eq \"\";\n    $string =~ tr/A-Za-z/A-Za-z/;\n   \
    \ return length($string);\n}", '    my(@characters) = ();', "    my $n = 0;\n\
    \    my $string_to_char = split(//, $string);\n    foreach my $char (@$string_to_char)\
    \ {\n        $n += scalar grep { $char eq $_ } @{ $self->_char_to_index };\n \
    \   }\n    return $n;\n}", "    return scalar(keys %{ $string =~ /([A-Z]+)/ig\
    \ });\n}", "    my($nc) = 0;\n    while($string ne '') {\n        $nc += ($string\
    \ =~ tr/a-z//i);\n        $string =~ tr/A-Z//i;\n    }\n    return $nc;\n}", " \
    \   my $count = 0;\n    my $letter;\n    foreach $letter (split('', $string))\
    \ {\n        $count++ if $letter !~ /^[A-Za-z]$/i;\n    }\n    return $count;\n\
    }", '    my $length = length($string);', "    return $string =~ tr/[A-Z]/0/;\n\
    }", "    my($hash);\n    my($character) = 0;\n    \n    my $prev_chr;\n    \n\
    \    foreach my $chr (split //, $string) {\n        next unless $chr =~ /[a-z]/i;\n\
    \        $hash->{$chr}++;\n    }\n    \n    while (my $chr = shift @{ $hash->{qw(a\
    \ b c)} }) {\n        $character += $hash->{$chr};\n        $character -= $hash->{$prev_chr}\
    \ if $prev_chr;\n        $prev_chr = $chr;\n    }\n    \n    return $character;\n\
    }", "    # Special case for empty string\n    return 0 \n        unless $string;\n\
    \    # Find the length of the string\n    my $length = $string =~ tr/A-Za-z//;\n\
    \    # Count the number of distinct characters\n    return scalar keys( split(\
    \ /[A-Za-z]/, $string ) );\n}", "    $string =~ tr/A-Za-z//cd;\n    return scalar(split\
    \ //, $string);\n}", "    my $count = () = $string =~ m{\\A([^A-Za-z])\\K}g;\n\
    \    return $count;\n}", "    return scalar grep { uc($1) ne uc($string) } split(//,$string);\n\
    }", "    $string =~ tr/A-Za-z/A-Za-z/;\n    return scalar keys(%seen);\n}", " \
    \   my $count = 0;\n    for (@$string) {\n        $count++ if ! $count++;\n  \
    \  }\n    return $count;\n}", "    return scalar keys(%{$string =~ tr/\\W+/});\n\
    }", '    my($char_count);', "    $string =~ tr/a-zA-Z/A-Z/;\n    scalar(split(//,\
    \ $string));\n}", '    my($count);', "    my $count = 1;\n    foreach my $char\
    \ (split(//,$string)) {\n        if ($char =~ /^[A-Z]$|^[a-z]$|^[0-9]$/) {\n \
    \           $count++;\n        }\n    }\n    return $count;\n}", '    return 0
    unless $string;', "    my $count = 0;\n    my $low = 0;\n    my $high = length($string)\
    \ - 1;", '    my $count = 1;', "    $string =~ tr/A-Z//cd;\n    return scalar(@$string);\n\
    }", "    $string =~ tr/A-Z//cd;\n    $string =~ tr/a-z//cd;\n    $string =~ tr/0-9//cd;\n\
    \    return scalar keys %characters;\n}", '    my($number_of_distinct, $number_of_different,
    $number_of_characters);', "    my($count);\n    foreach my $char (split(//, $string))\
    \ {\n        if ($char =~ /^[a-z]+$/i) {\n            $count += length($char);\n\
    \        }\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=2 tags=perl,string,regex\
    \ |>\n<| c |>\nI agree, however, I would have used `tr/A-Z//c` for case insensitive\
    \ removal and `tr//cd` to convert from upper to lower case (or vice-versa)\n<|/\
    \ c |>\n<| c |>\n: Yeah, I knew those two functions, but I was hoping someone\
    \ could explain the regexp to me so I could try to understand this stuff. Thanks!\n\
    <|/ c |>\n<| a |>\nI believe it's because your string is not defined as a scalar\
    \ variable. \nThe subroutine is expecting a scalar variable, but you're passing\
    \ it an array instead. \nIn addition, the subroutine isn't called as a function\
    \ but rather as a subroutine call. Try using something like the following:\n<code>\n\
    use strict;\nuse warnings;", "    my $count = 0;\n    while ($string =~ /(\\w+)/g)\
    \ {\n        ++$count;\n    }\n    return $count;\n}", "    my($count) = $string\
    \ =~ tr/a-z/A-Z/;\n    return $count;\n}", "    my $result;\n    my($char, $count)\
    \ = (\"\", 0);\n    for ($char = $string; $char ne \"\"; $char = $string->[$char])\
    \ {\n        $count++;\n    }\n    $result = $count;\n    return $result;\n}",
  "    my $length = 0;\n    my $char;\n    my $is_upper;", "    $string =~ tr/A-Za-z//cd;\n\
    \    return scalar keys %{$string};\n}", "    my(@chars);\n    my($total_char_count);",
  "    # @chars, @chars_with_case, $unique_strings contains all distinct characters\
    \ in $string\n    my(@chars) = grep { !$unique_strings{$_}++ } split //, $string;\n\
    \    # $unique_strings stores all distinct characters in $string in hash format\n\
    \    # i.e. each key is stores a character and each value is the character count\n\
    \    # $unique_strings{$char} will return the number of times the character $char\
    \ appears\n    # @chars_with_case contains distinct characters in $string in the\
    \ case insensitive way\n    my(@chars_with_case) = map { lc($_) => $unique_strings{$_}\
    \ ? $unique_strings{$_} : 0 } keys %unique_strings;\n    # return the maximum\
    \ of all the distinct characters counts\n    # @chars_with_case\n    return scalar(@chars_with_case)\
    \ > 0 ? $chars_with_case[0] : 0;\n}", "    my $num_characters = scalar(split(\"\
    \\t\", $string));\n    return $num_characters - scalar(split(\"[aeiouAEIOU]\"\
    , $string));\n}", "    $string =~ s/^\\s+|\\s+$//g;\n    $string =~ tr/A-Za-z/a-z/;\n\
    \    $string =~ tr/A-Za-z0-9/a-zA-Z0-9/;\n    return $string =~ tr/a-z/A-Z/;\n\
    }", "    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return scalar\
    \ $string;\n}", "    my $count = 0;\n    for my $char (split //, $string) {\n\
    \        $count++ if $char !~ /[a-z]/;\n        $count++ if $char !~ /[A-Z]/;\n\
    \        $count++ if $char !~ /[0-9]/;\n    }\n    return $count;\n}", "    my($chars_count)\
    \ = 0;\n    my($c) = 0;\n    foreach $c ($string) {\n        if ($c !~ /^\\p{Upper}$/)\
    \ {\n            $chars_count++;\n        }\n    }\n    return $chars_count;\n\
    }", "    my $count = 0;\n    foreach my $char (split(//, $string)) {\n       \
    \ if ($char =~ /^[A-Za-z]$/) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    my($c = 0);\n    \n    for(split(//, $string)) {\n       \
    \ $c += $_ =~ tr/A-Za-z/A-Z/;\n    }\n    \n    return $c;\n}", "    my $count\
    \ = 0;\n    my $character;\n    my $is_first_char;", "    my($hash_of_letters);\n\
    \    my($total_num_of_letters);", "    $string =~ tr/A-Za-z//cd;\n    return scalar(keys\
    \ %CHARS);\n}", "    my $count = 0;\n    for (split(/[[:lower:]]/, $string)) {\n\
    \        $count++ if !grep(/[[:upper:]]/, uc($_));\n    }\n    return $count;\n\
    }\n</code>\n<|/ a tags=perl |>\n<| c |>\nAh, the first two lines (and the one\
    \ inside the sub) seem like they should both be `my`.\n<|/ c |>\n<| c |>\nYou\
    \ don't really need the variable if you're just going to use it once.  Just `return\
    \ scalar` would work.  Also, I'm pretty sure you need a `!` in front of grep.\n\
    <|/ c |>\n<| c |>\nYes, you're right. `my` should be used.\n<|/ c |>\n<| c |>\n\
    Your \"return scalar\" suggestion is definitely better, since you don't have to\
    \ keep a copy of the value in a variable (but do keep a copy if you need it for\
    \ something else, such as printing it, returning it, or passing it to another\
    \ subroutine).  But this version still has some serious problems: it counts uppercase\
    \ letters too, and it only counts uppercase letters if there is at least one lowercase\
    \ letter in the string.  This is not the right way to do it.\n<|/ c |>\n<| c |>\n\
    , thanks for your remarks. My answer was an attempt to fix the OP's code which\
    \ didn't work and I didn't want to spend time on it too much. Fixed my code so\
    \ that it works now. I've also noticed that my code missed the possibility of\
    \ uppercase letters. I'm also not that good at Perl but I'll take a look at your\
    \ suggestion.\n<|/ c |>\n<| a dscore=2 tags=perl |>\n<code>\nmy $len = length($string);",
  "    my $count = 0;\n    my $chars = '';\n    for my $char (split //, $string) {\n\
    \        $chars .= $char;\n        $chars =~ tr/a-zA-Z//cd;\n        $chars =\
    \ lc $chars;\n        $count += length $chars;\n    }\n    return $count;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=perl,regex,perl-data-structures |>\nIf you\
    \ don't mind the complexity of the algorithm, I would probably start by just using\
    \ an array with pairs.  Each element in the array would contain a pair of strings.\
    \  You can then iterate over the pairs to find out which letters correspond to\
    \ each letter.\n<|/ a dscore=0 |>\n<| a |>\nI did it in Python, perhaps it would\
    \ be of interest to you?\n<code>\ndef countChars(string):\n    counts = dict()\n\
    \    for letter in string:\n        if letter in counts:\n            counts[letter]\
    \ += 1\n        else:\n            counts[letter] = 1\n    return counts\n</code>\n\
    <|/ a tags=perl,regex,perl-data-structures dscore=0 |>\n<| a dscore=0 tags=perl,regex,perl-data-structures\
    \ |>\nIt is not very efficient, but for fun I hacked it up with perl:\n<code>\n\
    my $a = \"qwertzuiopuasdfghjklzxcvbnm\";", "    my(@chars);\n    foreach my $char\
    \ (split //, $string) {\n        push @chars, $char if $char =~ /^[a-z0-9]+$/i;\n\
    \    }\n    my $n_distinct_chars = scalar (sort {$a cmp $b} @chars);\n    return\
    \ $n_distinct_chars;\n}", "    my $characters_count = {};\n    my $result;\n \
    \   $characters_count->{\" \"} = 1;\n    $characters_count->{_} = 1;\n    my $i\
    \ = 0;\n    while($i < length $string) {\n        my $character = substr($string,\
    \ $i, 1);\n        $characters_count->{$character}++;\n        $i++;\n    }\n\
    \    foreach $key (sort keys %{$characters_count}) {\n        $result = $result\
    \ + $characters_count->{$key};\n    }\n    return $result;\n}", '    my($count);',
  "    $string =~ tr/A-Z/a-z/;\n    return scalar keys %{$string =~ tr/A-Z/a-z/};\n\
    }", "    my $count = 0;\n    \n    for (my $i = 0; $i < length($string); $i++)\
    \ {\n        my $char = substr($string, $i, 1);\n        if (!defined($char))\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    return\
    \ length($string) - uc($string) =~ /[[:alpha:]]/g;\n}", "    my $count = 0;\n\
    \    $string =~ tr/a-zA-Z//;\n    $count++;\n    return $count;\n}", '    my($num_distinct_chars)
    = -1;', "    my $count = 0;\n    for my $c (split(//, $string)) {\n        next\
    \ if $c = '';\n        ++$count if $c =~ /^[A-Z]$/;\n        ++$count if $c =~\
    \ /^[a-z]$/;\n        ++$count if $c =~ /^\\d$/;\n    }\n    return $count;\n}",
  "    my($count) = 1;\n    my($first_char, $second_char);\n    $first_char = uc($string[0]);\n\
    \    $second_char = uc($string[1]);\n    for my $char ($string[2..-1]) {\n   \
    \     if ($char eq $first_char and $char eq $second_char) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}\n</code>\n<|/ a tags=perl,regex,string\
    \ |>\n<| c |>\nPlease note the example in my answer -- there were cases where\
    \ it didn't work.\n<|/ c |>\n<| c |>\nThis works quite well, but I haven't found\
    \ a way of getting the correct counts for non-ascii characters, i.e. characters\
    \ that cannot be encoded with the ascii table. I've tried `use utf8; uc $string;`\
    \ and then `chr $string`, but that didn't seem to help. Any ideas how this could\
    \ be improved?\n<|/ c |>\n<| c |>\n: I suspect that the problem is that your characters\
    \ are actually multi-byte characters.  If so, your only option is to count characters\
    \ in the *actual* UTF-8 encoding, and not characters in any code point within\
    \ the string.  There are a few modules that can help you with this, but I prefer\
    \ [Unicode::String](https://metacpan.org/pod/Unicode::String) or [String::Normalize](https://metacpan.org/pod/String::Normalize).\n\
    <|/ c |>\n<| a tags=perl,regex,string dscore=2 |>\n<code>\nmy $str1 = 'AA BB CC';\n\
    my $str2 = 'BB CC';\nmy %hash = ();\nfor (split(/ /, $str1)) {\n    my $key =\
    \ $_;\n    $hash{$key} += length($str2) =~ /$key/g;\n}\nprint \"$_ => $hash{$_}\\\
    n\"\nfor sort {\n    $hash{$a} <=> $hash{$b}\n} keys %hash;\n</code>\n<|/ a |>\n\
    <| c |>\nAh, this solution is probably the best one here (for speed). You don't\
    \ need to split the string, you can just use the `length()` function of the string\
    \ directly.\n<|/ c |>\n<| c |>\n: I see you are new to Stack Overflow. If you\
    \ feel an answer solved the problem, please mark it as 'accepted' by clicking\
    \ the green check mark. This helps keep the focus on older SO which still don't\
    \ have answers.\n<|/ c |>\n<| c |>\nOh sorry, my bad.\n<|/ c |>\n<| c |>\n", " \
    \   my $characters = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n \
    \       $characters += length substr($string, $i, 1);\n    }\n    return $characters;\n\
    }", "    $string =~ tr/ /A-Za-z/;\n    scalar($string);\n}", '    my($distinct)
    = 0;', "    return scalar(uniq(split(//, $string)));\n}", "    return length($string)\
    \ unless $string =~ m/[[:alpha:]]/;\n    $string =~ s/[[:alpha:]]//g;\n    return\
    \ length($string);\n}", "    my $count = 0;\n    $string =~ /[a-z]/;\n    $count++;\n\
    \    $string =~ /[A-Z]/;\n    $count++;\n    $string =~ /[0-9]/;\n    $count++;\n\
    \    return $count;\n}", "    return scalar split(//, $string) if $string =~ /[^A-Za-z0-9]/;\n\
    \    return scalar(split(//, $string));\n}", '    my $counter = 0;', "    my $count\
    \ = 0;\n    for (split('', $string)) {\n        $count++;\n    }\n    return $count;\n\
    }", "    my $chars = qr![^A-Za-z]+!i;\n    $string =~ tr/A-Z/a-z/;\n    return\
    \ scalar $string =~ tr/$chars/;\n}", "    my $chars = 0;\n    foreach my $char\
    \ (split(//, $string)) {\n        if ($char eq $char =~ /[a-z]/i) {\n        \
    \    $chars++;\n        }\n    }\n    return $chars;\n}", "    my($result);\n\
    \    \n    # Sort characters, as we don't need to care about the order for counting\n\
    \    my @sorted_characters;\n    my @distinct_characters;\n    for (@$string)\
    \ {\n        my $char = $_;\n        if ($char eq '') {\n            $char = '\\\
    0';\n        }\n        \n        push(@sorted_characters, $char);\n    }\n  \
    \  \n    # Count distinct characters, ignoring case\n    for (@sorted_characters)\
    \ {\n        my $distinct_char = $_;\n        my $count_distinct_chars = 1;\n\
    \        for (my $i = 1; $i < (@sorted_characters); $i++) {\n            if (lc($_)\
    \ eq lc($distinct_char)) {\n                $count_distinct_chars++;\n       \
    \     }\n        }\n        push(@distinct_characters, $count_distinct_chars);\n\
    \    }\n    \n    $result = (@distinct_characters);\n    \n    1;\n}", "    my\
    \ $length = 0;\n    my @chars = split //, $string;\n    foreach my $char (@chars)\
    \ {\n        $length++;\n        $length += length($char) unless $char eq '_';\n\
    \    }\n    return $length;\n}", "    my $count = 0;\n    my $char;\n    while\
    \ ($string =~ m/([A-Z]+)/g) {\n        ++$count;\n        $char = uc($1);\n  \
    \      $string =~ s/$char//g;\n    }\n    return $count;\n}", "    $string =~\
    \ tr/A-Z/a-z/;\n    return scalar keys %unique;\n}", "    my($distinct) = 0;\n\
    \    my($char) = 0;", "    my $count = 0;\n    foreach my $char (split //, $string)\
    \ {\n        $count += $char =~ tr/A-Z/a-z/;\n    }\n    return $count;\n}", " \
    \   my($nchars);\n    my($char_map);\n    my($chars);\n    my($char);\n    my($max_count)\
    \ = undef;\n    \n    # Step 1: Scan the string and build a character map.\n \
    \   # Step 2: Count the frequency of each character.\n    # Step 3: Find out how\
    \ many distinct characters there are in the string.\n    $nchars = scalar(@$char_map);\n\
    \    $nchars = $nchars/2;", "    # Count all characters in all cases (case insensitive\
    \ and accents)\n    my $n = length $string;\n    return 1 + grep { (/[a-z]/i)\
    \ or /[A-Z]/i } $string;\n}", "    my $distinct_chars = 0;\n    $distinct_chars\
    \ += length($string) unless $string =~ /\\0/;\n    $distinct_chars += $string->length\
    \ if $string =~ /\\0/;\n    return $distinct_chars;\n}", "    my $count = 0;\n\
    \    my $current_character;\n    foreach $current_character (split //, $string)\
    \ {\n        $count++ if $current_character =~ /^[A-Z]/ || $current_character\
    \ =~ /^[a-z]/;\n    }\n    return $count;\n}", '    my($count, @characters, %unique);',
  "    my $result = 1;\n    foreach my $char ($string =~ /([a-z]+|[A-Z]+|[0-9]+)/ig)\
    \ {\n        $result *= (length($char)-1);\n    }\n    return $result;\n}", " \
    \   $string =~ tr/A-Za-z//cd;\n    return scalar keys %seen;\n}", "    my $count\
    \ = scalar(@$string) - 1;\n    for (my $i = length($string) - 1; $i >= 0; $i--)\
    \ {\n        $count -= 1 if $string[$i] ne $string[$i - 1];\n    }\n    return\
    \ $count;\n}", "    my @chars = $string =~ /(?:[A-Za-z])+/g;\n    return scalar\
    \ keys %{ map { $_ => 1 } @chars };\n}", '    my($count, $char, $distinct);',
  "    return scalar grep { length($_) == 1 } split(//, $string);\n}", "    return\
    \ length($string) / 2;\n}", "    my $count = 0;\n    for (split //, $string) {\n\
    \        $count += 1;\n    }\n    return $count;\n}", "    my @chars;\n    $string\
    \ =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Za-z/a-z/;",
  '    my($characters, $i, $max);', "    my $count = 0;\n    my $chars = \"\";\n \
    \   for ($string) {\n        ++$count if !$chars || $chars ne $chars;\n      \
    \  $chars .= $string->[$_] if $string->[$_] ne $string->[$_ - 1];\n    }\n   \
    \ return $count;\n}", "    return scalar($string =~ tr/a-zA-Z//d);\n}", '    my(@distinct_characters)
    = ();', '    my($result);', "    my($distinct_char_count);\n    my($string_to_hash);"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
