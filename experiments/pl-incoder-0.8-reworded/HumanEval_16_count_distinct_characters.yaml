name: HumanEval_16_count_distinct_characters
language: pl
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters(\"\
  Jerry\")\n# 4\nsub count_distinct_characters {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_distinct_characters;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcde\"),5)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdecadeCADE\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"aaaaAAAAaaaa\"),1)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jerry\
  \ jERRY JeRRRY\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n}\n\ntesthumaneval();"
completions: ["    my($distinct_chars);\n    my($character);\n    \n    for (my $i\
    \ = 0; $i <= length($string) - 2; $i++) {\n        $character    = substr($string,\
    \ $i, 1);\n        $distinct_chars = $distinct_chars + 1 unless $distinct_chars{$character};\n\
    \    }\n    return $distinct_chars;\n}", "    my $count = 0;\n    $string =~ tr/A-Za-z/A-Za-z/;\n\
    \    $string =~ tr/A-Za-z/A-Za-z/;\n    $string =~ tr/A-Za-z/A-Za-z/;\n    $string\
    \ =~ tr/A-Za-z/A-Za-z/;\n    $string =~ tr/A-Za-z/A-Za-z/;\n    return $count;\n\
    }\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\n+1. I was thinking you were the\
    \ guy who asked the question, just didn't want to write your code for you. :)\n\
    <|/ c |>\n<| c |>\nI asked this question as a learning exercise, not a production\
    \ implementation. :-)\n<|/ c |>\n<| c |>\nThat's a pretty nifty solution. Do you\
    \ know if there is any performance difference between the different methods, or\
    \ is this all just as fast as `tr`?\n<|/ c |>\n<| c |>\n: I thought this was a\
    \ good question! I didn't know Perl had regex capabilities built in! Nice answer,\
    \ by the way, +1.\n<|/ c |>\n<| c |>\n: Not sure how you came up with your method\
    \ (which is really the fastest I came up with), but I just did some testing and\
    \ was surprised to find this out: on my system (a Linux machine), this was twice\
    \ as fast as `tr`. See my answer: http://stackoverflow.com/questions/939420/how-many-distinct-characters-in-a-given-string-case-aware/939477#939477\n\
    <|/ c |>\n<| a |>\n<code>\nmy $str = \"aBcDfG\";\n$str =~ tr/A-Z/A-Z/;\n$str =~\
    \ tr/a-z/A-Z/;\n$str =~ tr/A-Z/A-Z/;\n$str =~ tr/A-Z/A-Z/;\n$str =~ tr/A-Z/A-Z/;\n\
    print \"$str\\n\";\n</code>\nIt works for me. I think it could be done better,\
    \ but maybe someone else will come up with better idea.\n<|/ a dscore=2 tags=perl,regex\
    \ |>\n<| c |>\nWhy would that be better? It's just three `tr`s, no?\n<|/ c |>\n\
    <| c |>\n: Yes, but this one works. No matter how clever it can be, I think this\
    \ solution is as good as it can be.\n<|/ c ", "    my $count = 0;\n    $string\
    \ =~ tr/ //d;\n    $string =~ tr/a-zA-Z//cd;\n    ++$count;\n    return $count;\n\
    }", "    my($count) = 0;\n    my($characters) = 0;", "    return scalar(grep {\
    \ length } $string =~ m{[a-z]+});\n}", "    my $count = 0;\n    for my $char (split(//,\
    \ $string)) {\n        $count++ if $char ne $char;\n    }\n    $count;\n}", " \
    \   $string =~ tr/A-Za-z//cd;\n    return $string =~ tr/A-Z//cd;\n}", "    $string\
    \ =~ tr/A-Z/a-z/;\n    return $string =~ tr/a-z/A-Z/;\n}", "    my $num_distinct_characters\
    \ = 0;\n    for (my $i = 0; $i <length($string); $i++) {\n        my $letter =\
    \ substr($string, $i, 1);\n        $num_distinct_characters += $letter;\n    }\n\
    \    return $num_distinct_characters;\n}", '    return 0 unless defined $string;',
  "    my $count = 0;\n    $string =~ tr/[a-z]//cd;\n    $string =~ tr/[A-Z]//cd;\n\
    \    $string =~ tr/[0-9]//cd;\n    $count += ($string =~ tr/[a-z]//cd);\n    $count\
    \ += ($string =~ tr/[A-Z]//cd);\n    $count += ($string =~ tr/[0-9]//cd);\n  \
    \  return $count;\n}", "    my(@characters) = ();\n    \n    if ($string =~ /^$/\
    \ ) {\n        return scalar;\n    }\n    \n    for (split //, $string) {\n  \
    \      push(@characters, uc($_));\n    }\n    \n    return scalar(@characters);\n\
    }", "    return length($string) - scalar(grep{lc($_) eq $_}\n                \
    \            split(//, $string));\n}", '    my(@strings) = split //, $string;',
  "    $string =~ tr/a-zA-Z//cd;\n    return length($string);\n}", "    return $string\
    \ =~ tr/A-Za-z/A-Za-z/;\n}", "    my $cnt;\n    my $char_count = 0;\n    for (split('',\
    \ $string)) {\n        $char_count += length($_);\n    }\n    $cnt = $char_count;\n\
    \    $cnt += $char_count % 2 ? 1 : 0;\n    return $cnt;\n}", '    my $count =
    0;', "    my $num_chars = 0;\n    my @chars = split(//, $string);", "    my $char_count\
    \ = 0;\n    $string =~ tr/A-Za-z//;\n    $char_count++;\n    $string =~ tr/A-Z//;\n\
    \    $char_count++;\n    $string =~ tr/a-z//;\n    $char_count++;\n    return\
    \ $char_count;\n}\n</code>\n<|/ a |>\n<| c |>\nHmm, not sure why this was downvoted.\
    \ Seems like a viable approach. Plus, it doesn't do any sorting (well, unless\
    \ it sorts first - not likely)\n<|/ c |>\n<| c |>\nThis fails for \"abc\". I think\
    \ the OP wants \"abc\" to return \"3\" (not \"2\").\n<|/ c |>\n<| a tags=perl\
    \ dscore=1 |>\nA different solution:\n<code>\nmy $n = $string; $n =~ tr/A-Za-z//;\
    \ $n =~ tr/A-Z//;  $n =~ tr/a-z//; $n =~ tr/0-9//; $n = length($n);\n</code>\n\
    <|/ a |>\n<| c |>\nThanks, this also seems to have worked, but I will have to\
    \ choose the one from Borodin since it explains the reasoning behind what was\
    \ happening more clearly than my own answer\n<|/ c |>\n<| c |>\n: I really don't\
    \ think you need to choose Borodin's answer as the chosen answer doesn't explain\
    \ what was happening at all. I was the only person to post a solution that works.\n\
    <|/ c |>\n<| c |>\nYou do need to choose Borodin's answer. His answer explains\
    \ that his solution sorts the string.  That was really obvious once he pointed\
    \ it out.  I chose this answer just because I didn't think it explained the sort\
    \ algorithm well enough to make that point even obvious.\n<|/ c |>\n<| c |>\n\
    : And he explained it well enough when you pointed it out. He even wrote in the\
    \ comments that it sorts.\n<|/ c |>\n<| a |>\n<code>\nmy $n = \"abcd\";\nmy $count\
    \ = 0; # total count of char\n$n =~ tr/A-Za-z//;\n$n =~ tr/A-Z//;\n$n =~ tr/a-z//;\n\
    $n =~ tr/0-9//;\n$n = length($n);\n</code>\n<|/ a tags=perl dscore=0 |>\n<| c\
    \ |>\nWhat ", "    my @counter = ();\n    foreach my $char (split(//, $string))\
    \ {\n        $counter[$char] ++ unless (defined $counter[$char]);\n    }\n   \
    \ return scalar keys %counter;\n}", "    $string =~ tr/A-Z/a-z/;\n    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Za-z/;\n    return length($string);\n}",
  "    my $count = 0;\n    $string =~ tr/a-zA-Z//;\n    $count = $#string + 1;\n \
    \   return $count;\n}", "    my($count) = 0;\n    my($character);\n    my($char_count);",
  "    my $count = 0;\n    my $char_set;\n    $char_set = $string =~ tr/A-Z/a-z/;\n\
    \    $char_set =~ tr/a-zA-Z0-9/;\n    return $char_set =~ tr/0-9//;\n}", "   \
    \ return scalar(keys %_)\n}", "    my($characters) = split //, $string;\n    $characters\
    \ -= 1;\n    return scalar keys %{$characters}\n}", "    $string =~ tr/a-z//cd;\n\
    \    return scalar(@$string);\n}", "    $string =~ s/^\\s+//;\n    $string =~\
    \ s/\\s+$//;", "    my $count = 0;\n    my $char_count = ();", "    my $i = 0;\n\
    \    while($i < length $string) {\n        if($string[$i] =~ /[A-Z]/) {\n    \
    \        $i = length($string) + 1;\n        }\n        elsif($string[$i] =~ /[a-z]/)\
    \ {\n            $i = length($string) + 1;\n        }\n        elsif($string[$i]\
    \ =~ /[0-9]/) {\n            $i = length($string) + 1;\n        }\n        elsif($string[$i]\
    \ =~ /[!@#$%^&*()_+=-./:\"?><,]+/) {\n            $i = length($string) + 1;\n\
    \        }\n        else {\n            $i++;\n        }\n    }\n    return length($string);\n\
    }", "    my($characters);\n    my($count);", "    my $char_found = 1;\n    my\
    \ $count = 1;", "    my $count = 0;\n    my $char_map = ();\n    foreach my $char\
    \ (split //, $string) {\n        $char_map->{$char} += 1;\n    }\n    while(my\
    \ ($char, $freq) = each %$char_map) {\n        $count += $freq;\n    }\n    return\
    \ $count;\n}", "    # first we convert everything to lower case\n    $string =~\
    \ tr/a-zA-Z//cd;\n    # then we find out how many of each case there is\n    my($num_unique_characters)\
    \ = map {$_ eq $string ? ($_ eq 'A') ? 26 : ($_ eq 'B') ? 25 : ($_ eq 'C') ? 24\
    \ : ($_ eq 'D') ? 23 : ($_ eq 'E') ? 22 : ($_ eq 'F') ? 21 : ($_ eq 'G') ? 20\
    \ : ($_ eq 'H') ? 19 : ($_ eq 'I') ? 18 : ($_ eq 'J') ? 17 : ($_ eq 'K') ? 16\
    \ : ($_ eq 'L') ? 15 : ($_ eq 'M') ? 14 : ($_ eq 'N') ? 13 : ($_ eq 'O') ? 12\
    \ : ($_ eq 'P') ? 11 : ($_ eq 'Q') ? 10 : ($_ eq 'R') ? 9 : ($_ eq 'S') ? 8 :\
    \ ($_ eq 'T') ? 7 : ($_ eq 'U') ? 6 : ($_ eq 'V') ? 5 : ($_ eq 'W') ? 4 : ($_\
    \ eq 'X') ? 3 : ($_ eq 'Y') ? 2 : ($_ eq 'Z') ? 1 : 0 } (split('', $string));\n\
    \    return $num_unique_characters;\n}\n</code>\n<|/ a |>\n<| a |>\nThe accepted\
    \ answer has some limitations that might not be noticeable in practice. Here's\
    \ my suggestion, using Perl's regular expressions.\nIt doesn't take into account\
    \ special characters in the input.\n<code>\nuse strict;\nuse warnings;", "   \
    \ my($chars, $distinct, $uniq) = (0, $chars, $string);\n    do {\n        $chars++;\n\
    \        $distinct++;\n        $uniq ^= $string++;\n    } while ($uniq =~ /[[:upper:]]/);\n\
    \    return $chars;\n}", "    my @chars = split //, $string;\n    my $count =\
    \ 0;\n    for (@chars) {\n        if (exists $self->{$_}) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    return 0 if !$string || length($string)\
    \ == 0;\n    my @characters;\n    for (my $i = 0; $i < length($string); $i++)\
    \ {\n        $characters[$i] = uc(substr($string, $i, 1));\n    }\n    my @count\
    \ = ();\n    my $unique = 0;\n    foreach my $char (@characters) {\n        if\
    \ (exists($count[$char])) {\n            $unique++;\n        }\n        $count[$char]++;\n\
    \    }\n    return $unique ? $unique : scalar @characters;\n}", "    my($count);\n\
    \    foreach $char (split(//, $string)) {\n        if ($char =~ /^[A-Z]$/) {\n\
    \            $count++;\n        } else {\n            $count += 1;\n        }\n\
    \    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a tags=string,perl,regex\
    \ |>\nYou can just use regex /[A-Z]/ to get the count of distinct characters in\
    \ a string\n<code>\nmy $count = () = $string =~ m{[A-Z]}g;\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 tags=string,perl,regex |>\n<code>\nuse strict;\nuse warnings;",
  "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    $string =~ tr/A-Za-z/A-Z/;\n\
    \    $string =~ tr/A-Za-z/a-z/;\n    return scalar keys %{ ($string =~ tr/A-Z//cd);\n\
    }", "    my %hash = @_;\n    return scalar keys %hash;\n}", "    my $count = 1;\n\
    \    $string =~ tr/A-Z/a-zA-Z/;\n    $string =~ tr/a-z/a-zA-Z/;\n    $string =~\
    \ tr/A-Za-z/a-zA-Z/;\n    while ($string =~ m/([A-Za-z])/g) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    $string =~ tr/a-z/A-Z/;\n    return scalar(keys\
    \ %_);\n}", "    my $count = 0;\n    my $chars = split(//,$string);\n    $chars\
    \ =~ tr/A-Za-z/A-Za-z/;\n    $count += scalar keys %{$chars};\n    return $count;\n\
    }", "    $string =~ tr/A-Za-z/A-Za-z0-9/;\n    return scalar keys %$string;\n}",
  "    return scalar grep { ! /[[:upper:]]/i } $string;\n}", "    return scalar map\
    \ { (uc($string) ne $_) ? (uc($string) ne $_) \n        ? (lc($string) ne $_)\
    \ ? (lc($string) ne $_) \n        : (uc($string) ne $_) ? (uc($string) ne $_)\
    \ \n        : (lc($string) ne $_) ? (lc($string) ne $_) \n        : 0 } \n   \
    \     @{ $self->{_distinct_characters} };\n}", "    my $count = 0;\n    for my\
    \ $char (split(//, $string)) {\n        $count++ unless lc($char) eq lc($char)\n\
    \    }\n    return $count;\n}", "    return scalar(keys(%{map { uc($_) => 1 }\
    \ split(//, $string)});\n}", "    return scalar(split(//,$string));\n}", "   \
    \ return $string =~ tr/A-Z//d;\n}", "    $string =~ tr/A-Za-z//d;\n    return\
    \ scalar keys %$string;\n}", '    my($count_characters) = 0;', "    my $count\
    \ = 0;\n    $string =~ tr/A-Za-z/A-Za-z0-9/;\n    $string =~ tr/A-Z/a-z/;\n  \
    \  $string =~ tr/a-z/A-Z/;\n    $string =~ tr/0/0/;\n    ++$count;\n    ++$count;\n\
    \    ++$count;\n    ++$count;\n    return $count;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/0-9/a-z/;\n    $string =~ tr/a-zA-Z/a-z/;\n    return scalar(split(//,\
    \ $string));\n}", "    return scalar(split('', $string));\n}", "    my $length\
    \ = length $string;\n    my $count = 0;", "    my $count = 0;\n    my = split(//,\
    \ $string);\n    foreach my $char (@characters) {\n        $count++ if $char eq\
    \ $_;\n    }\n    return $count;\n}", "    my $total_characters = 0;\n    $total_characters\
    \ += length $string; # Count number of characters\n    $total_characters += length\
    \ $string if $string =~ tr/A-Z/A-ZA-Z/; # Count number of distinct uppercase letters\n\
    \    $total_characters += length $string if $string =~ tr/a-z/A-Za-z/; # Count\
    \ number of distinct lowercase letters\n    $total_characters += length $string\
    \ if $string =~ tr/A-Za-z/A-ZA-Za-z/; # Count number of distinct letters\n   \
    \ $total_characters--;\n    return $total_characters;\n}", "    # count number\
    \ of different characters in string\n    my $number_of_distinct_characters = 0;\n\
    \    my $string_to_test = &{uc $string};\n    my $string_to_test1 = $string_to_test\
    \ =~ tr/[A-Z]/[a-z]/i;\n    $number_of_distinct_characters += $string_to_test1\
    \ unless $string_to_test1;\n    return $number_of_distinct_characters;\n}", " \
    \   my $count = length($string);\n    my @characters = split(//,$string);\n  \
    \  my $i = 0;\n    my $char;\n    \n    while(++$i<$count) {\n        $char =\
    \ shift(@characters);\n        $char =~ s/\\W/./;\n        \n        # Skip any\
    \ character with a lowercase variant\n        next if $char =~ /^[a-z]$/;\n  \
    \      \n        $count++ unless grep { lc $_ eq $char };\n    }\n    \n    return\
    \ $count;\n}", "    return scalar(map { $string=~tr/A-Za-z/A-Z-/; length($&) }\
    \ split(//, $string));\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis\
    \ is what I did:\n<code>\nmy $string = 'aaaBbbCcccDdddEeeeFfff';\nmy $letters\
    \ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nmy $count = {};", "    my $count = -1;\n  \
    \  my @chars = split(//, $string);\n    foreach my $char (@chars) {\n      $count++\
    \ if ($char =~ /[A-Z]/);\n      $count++ if ($char =~ /[a-z]/);\n      $count++\
    \ if ($char =~ /[0-9]/);\n    }\n    return $count;\n}", "    $string =~ tr/A-Z/a-z/;\n\
    \    return scalar( sort { length($b) <=> length($a) } split //, $string );\n}",
  "    my $count = 0;\n    my = split(//,$string);\n    foreach my $x (@unique) {\n\
    \        if ($x ne '') {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", '    my($count, %counts);', '    my $count = 1;', "    return scalar(split(//,$string));\n\
    }", "    my($length) = length($string);\n    my $count = 0;\n    for(my $i = 0;\
    \ $i < $length; $i++) {\n        if($string[$i] eq $string[$i - 1]) {\n      \
    \      $count++;\n        }\n    }\n    return $count;\n}", "    my($count, $character);\n\
    \    foreach $character (split(//, $string)) {\n        $count++ if $character\
    \ !~ /\\d/;\n    }\n    $count;\n}", "    $string =~ tr/A-Z//cd;\n    $string\
    \ =~ tr/a-z//cd;\n    $string =~ tr/0-9//cd;\n    $string =~ tr/-_.//cd;\n   \
    \ $string =~ tr/\\?#\\\\//cd;\n    $string =~ tr/()//cd;\n    $string =~ tr/[]{}<>\\\
    |^,.;:~'@#$%&*()_+?~-\"^\\\\\\]\\[~-]/cd;\n    return scalar keys %$string;\n}",
  "    my(@letters);\n    my($count, $prev);\n    my($i, $j);\n    my(@chars, @tmp);",
  "    my $count = 0;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n\
    \    $string =~ tr/A-Za-z/;\n    $string =~ tr/-/\\//;\n    $string =~ tr/A-Z/a-z/;\n\
    \    do {\n        $count++;\n        $string =~ tr/a-zA-Z//;\n    } while ($string\
    \ =~ tr/-/\\//);\n    return $count;\n}", "    my $count = 0; # initialize count\
    \ with zero\n    my $current_char;\n    foreach $current_char (split(//, $string))\
    \ {\n        # increment count for each character encountered in the string\n\
    \        $count++ if $current_char !~ /[A-Z]/;\n    }\n    return $count;\n}",
  "    $string =~ tr/[a-z]/[A-Z]/g;\n    scalar(keys(%unique));\n}", "    return scalar\
    \ grep { $string =~ m/$char/ } split //, $string;\n}\n</code>\nThe above function\
    \ works by splitting the string on every single character in the alphabet, which\
    \ returns a list of all the distinct characters found in the string.  Then we\
    \ simply return how many of those distinct characters there are in the string.\n\
    I chose to split the alphabet into an array and loop through it each time we were\
    \ looking for distinct characters to avoid having to create another regular expression\
    \ that would be very expensive (although this is only a couple of additional lines\
    \ of code).\n<|/ a dscore=4 |>\n<| c |>\nThis will not work properly if there\
    \ are spaces in the string.\n<|/ c |>\n<| c |>\n: Yes, of course it will not work\
    \ properly if there are spaces in the string.  I mentioned that in my answer,\
    \ and I explained why in the second paragraph.  The only way to handle spaces\
    \ in a string is to split the string on every single character, which would increase\
    \ the time complexity of the function from O(n) to O(n^2).\n<|/ c |>\n<| a |>\n\
    The answer by will work, but if you're trying to do this more than once, you're\
    \ better off defining a constant that is a hash set of characters. You can define\
    \ one like this:\n<code>\nuse Hash::Util qw(string_hash);\nmy %unique = string_hash($string);\n\
    </code>\nThen you can do this:\n<code>\n$unique{lc($char)}++;\n</code>\nThis is\
    \ far more efficient than a regex solution, because it'll only do the hashing\
    \ once rather than once per character.\nIf you need to do this more than once,\
    \ I'd suggest writing a small utility function like this:\n<code>", "    return\
    \ scalar(keys %{lc $string});\n}", "    my $len = 0;\n    my $char;", "    my\
    \ $cnt = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n        my $ch\
    \ = $string[$i];\n        $cnt++ if $ch !~ /[A-Za-z]/;\n        $cnt++ if $ch\
    \ !~ /[a-z]/;\n    }\n    return $cnt;\n}", "    my $len = length($string);\n\
    \    my $count = 0;\n    for (my $i = 0; $i < $len; $i++) {\n        $count +=\
    \ 1 if ($string[$i] !~ m/^[A-Za-z]/);\n    }\n    return $count;\n}", "    my($count)\
    \ = 0;\n    for(my $char = $string[0]; $char ne $string[-1..$#string]; ++$count)\
    \ {\n        foreach my $char_in_string (@strings) {\n            if ($char eq\
    \ $char_in_string) {\n                last;\n            }\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    for my $char (split //, $string)\
    \ {\n        $count++ if $char =~ /^[a-z]$/i;\n    }\n    return $count;\n}",
  "    my $count = () = $string =~ tr/[a-z]/[A-Z]/;\n    return $count if $count >\
    \ 1;\n    return $string->length();\n}", "    my $count = 1;\n    my $len = length($string);",
  "    my($distinct_characters_string);\n    my($count_characters);\n    my($count_distinct_characters);",
  '    my $count = 1;', "    $string =~ tr/A-Za-z/A-Z/;\n    $string =~ tr/0-9//cd;\n\
    \    $string =~ tr/A-Za-z//cd;\n    return scalar(split(//, $string));\n}", " \
    \   return scalar(split(\"[ATGCNy]\",$string));\n}", "    $string =~ tr/A-Z/A-Z/;\n\
    \    $string =~ tr/a-z/a-z/;\n    $string =~ tr/0-9/0-9/;\n    return scalar keys\
    \ %{$_[0]};\n}", "    $string =~ tr/A-Z//cd;\n    scalar keys %count;\n}", " \
    \   my $count = 0;\n    $string =~ tr/[A-Z]/[A-Z]/;\n    $string =~ tr/[a-z]/[a-z]/;\n\
    \    $string =~ tr/[0-9]/[0-9]/;\n    $string =~ tr/[!\"#$%&'()*+,-./:;<=>?@^_`{|}~]/;\n\
    \    $string =~ tr/\\s+/\\s+/;\n    foreach (split //, $string) {\n        $count++;\n\
    \    }\n    return $count;\n}", "    $string =~ tr/A-Za-z//;\n    return scalar\
    \ $string;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nIt was a typo on my\
    \ part, I meant to use $string =~ tr/A-Za-z//;.", "    return length($string)\
    \ if $string =~ /^\\s*$/;\n    my @chars_found = ();\n    my $i;\n    my $counter\
    \ = 1;\n    for ($i = 0; $i < length($string); $i++) {\n        my $char_found\
    \ = 0;\n        for my $j (0 .. length($string) - $i - 1) {\n            $char_found++\n\
    \                if $string[$i + $j] eq $string[$j];\n        }\n        push\
    \ @chars_found, $char_found;\n        $counter++;\n    }\n    return @chars_found\
    \ ? $counter : 0;\n}", "    my(@distinct_chars);\n    for ($string =~ /[A-Za-z]/g)\
    \ { push(@distinct_chars, $_) }\n    return scalar(@distinct_chars);\n}", "  \
    \  my $count = 0;\n    my $chars;", "    return scalar(keys(%{$string =~ tr/A-Z/a-z/}));\n\
    }", "    my($count, $ch);\n    foreach $ch (split(//, $string)) {\n\t$count++\
    \ if $ch ne $ch and $ch !~ /^\\d/;\n    }\n    return $count;\n}", "    my $result\
    \ = $string =~ tr/A-Za-z/A-Za-z/;\n    return $result ? length($string) - $result\
    \ : 0;\n}", "    $string =~ tr/a-z/A-Z/;\n    return scalar keys %$string;\n}",
  "    my($count);\n    $count = 1;\n    my $letter;\n    foreach $letter (split(//,\
    \ $string)) {\n        my($case_insensitive);\n        if (($case_insensitive\
    \ = lc($letter))) {\n            $count++ if $letter !~ /[a-z]/i;\n        }\n\
    \    }\n    return $count;\n}", "    my $chars = ();\n    my $counter = 1;\n \
    \   $string =~ s/^\\s+|\\s+$//g;\n    while( $string =~ /[a-z]/i ) {\n       \
    \ my $character = $&;\n        $chars{$character}++;\n        $string=~s/$character//i;\n\
    \    }\n    foreach my $key ( sort keys %chars ) {\n        $counter += $chars{$key};\n\
    \    }\n    return $counter;\n}", "    $string =~ tr/A-Z/a-z/;\n    return scalar\
    \ keys %{$string =~ tr/a-z/A-Z/};\n}", "    my @characters;\n    my @characters_nocase;\n\
    \    for (my $i = 0; $i < @$string; $i++) {\n        my $character = $string->[$i];\n\
    \        push(@characters, $character);\n        push(@characters_nocase, $character\
    \ if $case ne \"upper\");\n    }\n    return scalar(@characters) + (scalar(@characters_nocase)\
    \ - scalar(@characters));\n}", "    $string =~ tr/a-z//cd;\n    return scalar\
    \ keys %{ uc $string };\n}", "    my $count;\n    my $length = $string =~ tr/A-Z/a-z/;\n\
    \    $count = $length / $all_characters / $all_characters;\n    return $count;\n\
    }", "    my $result;\n    for my $char (split //, $string) {\n        $result++\
    \ if $char ne $char;\n    }\n    return $result;\n}", "    my($counter);\n   \
    \ my($total_chars);\n    my($char_counter);", "    my($count, $character);\n \
    \   my($lower_characters);\n    my($upper_characters);", "    my(@distinct_chars);\n\
    \    my($distinct);", "    return scalar(map {\n        $_ =~ tr/a-zA-Z/A-Z/;\n\
    \    } split //, $string);\n}", "    return scalar(grep {lc($_) ne lc($string)}\
    \ split(//,$string));\n}", "    $string =~ tr/A-Za-z//cd;\n    return scalar keys\
    \ %seen;\n}", "    my $num_chars = scalar(split(//, $string));\n    my $min_chars\
    \ = length($string);\n    return $num_chars - $min_chars + 1;\n}", "    $string\
    \ =~ s/^[[:alpha:]]+//;\n    return length($string);\n}", "    my $count = 1;\n\
    \    for my $char (split //, $string) {\n        ++ $count if $char !~ /[a-z]/i;\n\
    \    }\n    return $count;\n}\n</code>\nIf you were expecting more than one distinct\
    \ character to be present, you need to modify the regex to include them (and maybe\
    \ an optional space after the last character so \"xyz\" isn't counted as one character).\n\
    <|/ a dscore=0 tags=string,perl,arrays |>\n<| c |>\nI guess he wanted distinct\
    \ characters **in order**. e.g. `\"abc\"` is one distinct character and `\"bca\"\
    ` is another.\n<|/ c |>\n<| c |>\n- I agree, but that's not what the question\
    \ says. He said that the list should contain exactly one set of distinct characters.\
    \ I interpreted that as wanting to count the number of distinct characters in\
    \ the string (i.e. `abc` and `bca` would be two distinct characters), but that's\
    \ not what the question is saying.\n<|/ c |>\n<| c |>\nThe question says \"Given\
    \ a string, find out how many distinct characters (regardless of case) does it\
    \ consist of\". So `bcA` and `Abc` would be two distinct characters. The problem\
    \ states that there are no duplicate characters.\n<|/ c |>\n<| c |>\n- I guess\
    \ I misread the question. I thought he wanted distinct characters **in order**.\
    \ e.g. `bcA` and `Abc` are distinct characters, but `\"abc\"` is distinct characters\
    \ too.\n<|/ c |>\n<| c |>\n- That is what I thought too. I've just made an edit\
    \ to my answer, but I think that is what he wants.\n<|/ c |>\n<| a |>\nI suspect\
    \ the problem is with the way you're reading the file. It doesn't have to be the\
    \ way you read it, as long as you open the file correctly.\nHere's a version that\
    \ works for me:\n<code>\nuse 5.010;\nuse strict;\nuse warnings;", "    return\
    \ scalar(grep { $string =~ /\\b\\Q$_\\E\\b/ } keys(%{ $char_to_count }));\n}",
  "    my @distinct_characters = ();\n    for (my $i = 0; $i < length($string); $i++)\
    \ {\n        $distinct_characters[ord(substr($string, $i, 1))]++;\n    }\n   \
    \ my $total = 0;\n    for (my $i = 0; $i < @distinct_characters; ++$i) {\n   \
    \     $total += $distinct_characters[$i];\n    }\n    return $total;\n}", "  \
    \  my $count = 0;\n    $string =~ tr/a-z/A-Z/;\n    $count += $-[0] if  $string\
    \ =~ tr/A-Z/a-z/;\n    $count += $-[0] if  $string =~ tr/A-Z/A-Z/;\n    $count\
    \ += $-[0] if  $string =~ tr/a-z/A-Z/;\n    return $count;\n}", "    $string =~\
    \ tr/A-Za-z//d;\n    return scalar keys %{_};\n}", "    my($count, $character);\n\
    \    \n    for ($count=0, $character= uc($string[0]); $character ne uc($string[$#string]);\
    \ $character=uc($string[$count+1])) {\n        ++$count;\n    }\n    \n    return\
    \ $count;\n}\n</code>\n<|/ a tags=perl,algorithm |>\n<| c |>\nAh, I see. Didn't\
    \ think of that. I'll try it out and see how it compares to `uniq`. But `uniq`\
    \ also takes care of duplicates in case that's a problem for me. I'll also try\
    \ out your `count-distinct-characters` sub as well.\n<|/ c |>\n<| c |>\n`uniq`\
    \ also takes care of duplicates, and as far as I can tell `count-distinct-characters`\
    \ uses this under the hood. It also does not require the list to be sorted.\n\
    <|/ c |>\n<| c |>\n: Yes, I realized that `uniq` also sorts the list, but I thought\
    \ it might be nice to have that as explicit in the function name.\n<|/ c |>\n\
    <| c |>\n: My `count-distinct-characters` also does not sort the list, I just\
    \ use `sort()` to do that. Of course you could write a variant that does that.\n\
    <|/ c |>\n<| c |>\nI actually just realized that `count-distinct-characters` also\
    \ takes care of duplicates without needing to sort it. I'll edit my answer to\
    \ add that in, but I'll leave the question up since it might be helpful to someone\
    \ else anyway. Thanks for your help!\n<|/ c |>\n<| a |>\nYou could use a hash\
    \ of hashes where the key is the character and the value is the count of that\
    \ character.\nIn Perl it would look something like this:\n<code>", "    $string\
    \ =~ tr/A-Z//cd;\n    return scalar keys %{$_[0]};\n}", "    my(@results);\n \
    \   my($i);\n    my $char_array;\n    my $char_array2;\n    $char_array = split('',\
    \ $string);\n    $char_array2 = split('', $string);\n    foreach $i (0 .. $#char_array)\
    \ {\n        $results[$i] = 0;\n    }\n    foreach $i (0 .. $#char_array2) {\n\
    \        my $found = 0;\n        foreach $char_array2[$i] {\n            if ($char_array2[$i]\
    \ eq $char_array[$i]) {\n                $results[$i]++;\n                $found++;\n\
    \                last;\n            }\n        }\n        if (!$found) {\n   \
    \         $results[$i]++;\n        }\n    }\n    return $results[$#char_array];\n\
    }", "    $string =~ tr/A-Za-z/A-Z/;\n    return $string =~ tr/A-Z/a-z/;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThat is exactly what I need :) Thanks!\n<|/ c |>\n\
    <| c |>\nIt's not the best solution, but it's fast enough for most practical purposes.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\n$string =~ tr/A-Za-z//;\n</code>\nThis replaces\
    \ everything except letters with nothing. It's faster than counting distinct characters.\n\
    <|/ a tags=perl,string |>\n<| c |>\n: I believe that regex does it in two passes\
    \ -- one to count letters, and one to replace them.\n<|/ c |>\n<| a tags=perl,string\
    \ dscore=3 |>\nHere's my solution:\n<code>", "    my $num_chars = $string =~ tr/a-zA-Z//;\n\
    \    return $num_chars;\n}", "    $string =~ tr/a-zA-Z//d;\n    return scalar;\n\
    }", "    $string =~ tr/A-Za-z/;\n    return scalar(split(//, $string));\n}\n</code>\n\
    <|/ a dscore=2 tags=perl,unicode,utf-8,regex |>\n<| c |>\nthanks! I did that and\
    \ it works. But the thing is, I cannot use any external libraries. Like for example\
    \ use utf8;. Can we solve this without using any external library?\n<|/ c |>\n\
    <| c |>\nI added a solution that doesn't require any external libraries.  Does\
    \ that work?\n<|/ c |>\n<| c |>\nI edited the original question. Can you please\
    \ check. I tried your solution but I am getting errors. Can you please check it\
    \ once. Thanks\n<|/ c |>\n<| c |>\nI changed the code slightly.  Have you tried\
    \ that?  As for your error, it seems like you need to also `use utf8;` before\
    \ the first call of `count_distinct_characters()`.  See my edited answer.\n<|/\
    \ c |>\n<| a |>\nThis solution uses only one regular expression (no external libraries).\n\
    It counts the number of characters in every string without changing the case or\
    \ removing non-alphanumeric characters (as pointed out by), but does this in two\
    \ steps:", "    my $count = 0;\n    while ($string =~ /([a-zA-Z0-9]+)/g) {\n \
    \       $count++;\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for your answer. I think that this approach would work perfectly except\
    \ the fact that it doesn't return a string but a number. Anyway, your approach\
    \ definitely helped me to improve my code. Thanks! :)\n<|/ c |>\n<| c |>\nIf your\
    \ problem is solved please accept the answer with the tick mark on the left of\
    \ the answer.\n<|/ c |>\n<| c |>\nYour approach works, too. I'll have to wait\
    \ until I can accept an answer soon. :)\n<|/ c |>\n<| a |>\nMy approach is:\n\
    <code>\nfunction count_distinct_characters($string) {\n    my($string) = @_;\n\
    \    my $count = 0;\n    my $seen = {};\n    foreach my $char (split //, $string)\
    \ {\n        if (!exists $seen->{$char}) {\n            $seen->{$char} = 1;\n\
    \            $count++;\n        }\n    }\n    return $count;\n}\n</code>\n<|/\
    \ a tags=perl dscore=0 |>\n<| a dscore=0 tags=perl |>\nThis should work too\n\
    <code>", "    $string =~ tr/a-z/A-Z/;\n    return length($string) - length($string-1);\n\
    }\n</code>\nAs per's comment, an alternative is\n<code>", "    my @chars = split(//,$string);\n\
    \    my $char_counter = 0;\n    foreach my $char (@chars) {\n        $char_counter\
    \ += scalar grep { $char eq $_ } split(' ',$char);\n    }\n    return $char_counter;\n\
    }\n</code>\n<|/ a dscore=0 tags=perl |>\n<| c |>\nI tested this script in Perl\
    \ 5.10.1 and it didn't work as intended. There was a subtle bug that only happened\
    \ when two or more identical characters exist in the same string. Example: \"\
    asasaas\" would return 4, while \"asasaasaa\" would return 6. Other than that,\
    \ it's pretty much spot on.\n<|/ c |>\n<| a dscore=0 tags=perl |>\n<code>\nuse\
    \ strict;\nuse warnings;\nuse 5.010;\nmy = ( \"\", \"\", \"\", \"\", \"\" );\n\
    my $s = \"qweqweqweqwe\";\nmy $n = 0;\n$n++ while $s =~ tr/a-zA-Z/a-z/;\nsay $n;\n\
    </code>\n<|/ a |>\n<| c |>\nPlease don't use bare `say`. It doesn't handle `STDERR`\
    \ well.\n<|/ c |>\n<| c |>\nYou also don't need `tr` at all. `my $n = grep { $s\
    \ =~ /[a-z]/i };` is the same thing.\n<|/ c |>\n<| a tags=perl |>\n<code>", " \
    \   my $count = 0;\n    for (my $i = 0; $i <= length($string); $i++) {\n     \
    \   for (my $j = $i; $j <= length($string); $j++) {\n            $count++ if ($string[$i]\
    \ eq $string[$j]);\n        }\n    }\n    return $count;\n}", "    return scalar\
    \ split(//,$string);\n}", "    return scalar(grep(\"[A-Za-z]\",$string));\n}",
  "    # convert string to lowercase\n    $string =~ tr/a-zA-Z//cd;\n    # count the\
    \ characters, ignoring case\n    return scalar(keys %hash);\n}", "    # Sort characters\
    \ in case a particular case makes it easier to count\n    my(@sorted_chars) =\
    \ sort { lc($_) cmp lc($a) } split //, $string;\n    # Count the distinct characters\
    \ in the sorted list\n    return scalar(@sorted_chars);\n}", "    my %seen;\n\
    \    $seen{'a'}++; $seen{'z'}++; $seen{'A'}++;\n    $seen{'b'}++; $seen{'z'}++;\
    \ $seen{'B'}++;\n    $seen{'c'}++; $seen{'z'}++; $seen{'C'}++;\n    $seen{'d'}++;\
    \ $seen{'z'}++; $seen{'D'}++;\n    $seen{'e'}++; $seen{'z'}++; $seen{'E'}++;\n\
    \    $seen{'f'}++; $seen{'z'}++; $seen{'F'}++;\n    $seen{'g'}++; $seen{'z'}++;\
    \ $seen{'G'}++;\n    $seen{'h'}++; $seen{'z'}++; $seen{'H'}++;\n    $seen{'i'}++;\
    \ $seen{'z'}++; $seen{'I'}++;\n    $seen{'j'}++; $seen{'z'}++; $seen{'J'}++;\n\
    \    $seen{'k'}++; $seen{'z'}++; $seen{'K'}++;\n    $seen{'l'}++; $seen{'z'}++;\
    \ $seen{'L'}++;\n    $seen{'m'}++; $seen{'z'}++; $seen{'M'}++;\n    $seen{'n'}++;\
    \ $seen{'z'}++; $seen{'N'}++;\n    $seen{'o'}++; $seen{'z'}++; $seen{'O'}++;\n\
    \    $seen{'p'}++; $seen{'z'}++; $seen{'P'}++;\n    $seen{'q'}++; $seen{'z'}++;\
    \ $seen{'Q'}++;\n    $seen{'r'}++; $seen{'z'}++; $seen{'R'}++;\n    $seen{'s'}++;\
    \ $seen{'z'}++; $seen{'S'}++;\n    $seen{'t'}++; $seen{'z'}++; $seen{'T'}++;\n\
    \    $seen{'u'}++; $seen{'z'}++; $seen{'U'}++;\n    $seen{'v'}++; $seen{'z'}++;\
    \ $seen{'V'}++;\n    $seen{'w'}++; $seen{'z'}++; $seen{'W'}++;\n    $seen{'x'}++;\
    \ $seen{'z'}++; $seen{'X'}++;\n    $seen", "    my $distinct_characters = 0;\n\
    \    my $last_char = '';\n    \n    $string =~ tr/a-z/A-Z/;\n    \n    while ($string\
    \ =~ tr/A-Z/a-z/) {\n        $distinct_characters++;\n        $last_char = $1;\n\
    \        $string =~ tr/A-Z/a-z/;\n    }\n    \n    return $distinct_characters;\n\
    }", "    my $count = 0;\n    foreach my $char (split('', $string)) {\n       \
    \ $count++ if $char ne uc $char && $char !~ /[a-z]/;\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my $character;\n    while($string =~ /([a-zA-Z])/gi){\n\
    \        $count++;\n        $character = $1;\n    }\n    return $count;\n}\n</code>\n\
    <|/ a tags=perl,regex,string |>\n<| c |>\nNote that this won't detect if there\
    \ are any extra whitespace characters between words.  It will only count distinct\
    \ characters within the string.\n<|/ c |>\n<| c |>\nTrue. Also, this code counts\
    \ punctuation characters as distinct characters.\n<|/ c |>\n<| c |>\nThe \"count\
    \ distinct characters within the string\" part of the question was my main point\
    \ of confusion towards the end. Thanks for the regex and code examples!\n<|/ c\
    \ |>\n<| c |>\n: Actually, the `g` flag means that `/([a-zA-Z])/gi` will match\
    \ all possible matches, not just the first one.\n<|/ c |>\n<| c |>\n: I see. I\
    \ thought it matched all of them.\n<|/ c |>\n<| a tags=perl,regex,string |>\n\
    A simple way is to split the string on the whitespace character, and count the\
    \ distinct elements.\n<code>\nmy $s = \"foo bar foo bar\";\nmy = split ' ', $s;\n\
    my $n = scalar;\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWon't work if the string\
    \ contains multiple spaces.\n<|/ c |>\n<| c |>\nYes, that won't work. Still, it's\
    \ a fairly simple fix.\n<|/ c |>\n<| c |>\nThis is clever, but requires creating\
    \ a temporary string.  (Depending on how much memory your program uses, this may\
    \ or may not be an issue.)\n<|/ c |>\n<| a |>\nI like Tim's solution, but to make\
    \ it more efficient, I would use substr instead of split:\n<code>\nmy $str = \"\
    foo bar foo bar\";\nmy $n = length($str);\nmy $distinct = 0;\nmy $i;\nfor ( $i\
    \ = 0; $i < $n; $i++ ) {\n  $distinct += $i if substr($str,$i,1) ne substr($str,$i-1,1);\n\
    }\n</code>\n<|/ a dscore=3 tags=perl,regex,string |>\n<| c |>\nI suppose you could\
    \ also do the same thing in one line, but Tim's solution is more flexible.\n<|/\
    \ c |>\n<| c |>\nYes, of course.  It's also a good example of how you could use\
    \ map and grep.\n<|/ c |>\n<| c ", "    my %distincts;\n    my $char_len = length($string);\n\
    \    for(my $i = 0; $i <= $char_len; $i++) {\n        my $ch = $string[$i];\n\
    \        $distincts{$ch}++;\n    }\n    scalar keys %distincts\n}", "    my $distinct\
    \ = length $string;\n    my $i = 0;\n    for (my $i = 0; $i < $distinct; $i++)\
    \ {\n        $distinct -= $string[$i] eq $string[$i+1];\n    }\n    return $distinct;\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    my $length = $#_;\n    $string =~ tr/A-Z/a-z/;\n\
    \    my $length2 = $#_;\n    $length = $length+$length2;\n    return $length;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis fails on all but the first word. For example,\
    \ it returns 1 for the string \"abc def\" when it should return 3.\n<|/ c |>\n\
    <| c |>\nI realize that, but I was hoping that people would be able to modify\
    \ it more easily than the other (which is actually very inefficient). Of course,\
    \ since this is likely to be a one-off, there's no need for efficiency. :-)\n\
    <|/ c |>\n<| c |>\nThis doesn't work for all cases, for instance, it returns 1\
    \ for the string \"abc def\" when it should return 3.\n<|/ c |>\n<| c |>\nI realized\
    \ this afterward, but it wasn't immediately obvious how it could be fixed. Hopefully\
    \ I've got it fixed now.\n<|/ c |>\n<| c |>\nThis fails on all but the first word.\
    \  For example, it returns 1 for the string \"abc def\" when it should return\
    \ 3.\n<|/ c |>\n<| a tags=perl,regex |>\nIn a Perl regex (like any regex), a backslash\
    \ (\\) escapes a character. It doesn't mean \"backslash\" (which would be \\),\
    \ it means \"something I want\". If I wanted to match a backslash, I would use\
    \ \\. Instead, I need to escape the backslash, which can be done by doubling it:\n\
    <code>", "    my($count, $character);\n    for(my $i = 0; $i < length($string);\
    \ $i++) {\n        $character = substr($string, $i, 1);\n        if($character\
    \ ~~ m/[^a-zA-Z]/g) {\n            ++$count;\n        }\n    }\n    return $count;\n\
    }", "    return scalar(keys %$string);\n}", "    return $string =~ tr/a-z/A-Z/;\n\
    }", "    my $count = 1;\n    \n    foreach my $char (lc($string)) {\n        #\
    \ In Perl, lc converts string literals to lower case. \n        # Use $char to\
    \ avoid this extra overhead\n        $count++ if $char !~ /[a-z]/;\n    }\n  \
    \  return $count;\n}", "    my $count = 0;\n    $string =~ /[^A-Za-z]/g;\n   \
    \ $count++;\n    $string =~ /[^A-Z]/g;\n    $count++;\n    $string =~ /[^a-z]/g;\n\
    \    $count++;\n    return $count;\n}", "    $string =~ tr/A-Z/a-z/;\n    return\
    \ scalar(keys(%$string));\n}", "    my $count = 0;\n    foreach my $char (split(//,$string))\
    \ {\n        $count++ if $char ne $char =~ /[A-Z]/;\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIf you're trying to count the number of\
    \ unique characters in the string, the easiest way to do this is to use an array\
    \ and use the array as a set.\n<code>", "    my($total_distinct) = 0;\n    foreach\
    \ my $character (split(' ', $string)) {\n        $total_distinct += length($character);\n\
    \    }\n    return $total_distinct;\n}", "    my($count) = 0;\n    my($char);",
  "    my($count) = 1;\n    my($character, $case) = (\"\", \"\");", '    my(@counts);',
  "    my($count, $letter);\n    return if ($string eq '');", "    my $num_distinct_characters\
    \ = 0;\n    while($string =~ /([A-Z])/ig) {\n        ++$num_distinct_characters;\n\
    \    }\n    return $num_distinct_characters;\n}", "    return scalar grep($string\
    \ =~ /[a-zA-Z]+/, keys %$counts);\n}", "    my $count = 0;\n    for my $char (split(//,\
    \ $string)) {\n        $count++ if $char ne uc($char);\n    }\n    return $count;\n\
    }", "    my($characters) = 0;\n    my($lowercase_count) = 0;\n    my($lowercase_characters)\
    \ = 0;\n    my($uppercase_count) = 0;\n    my($uppercase_characters) = 0;\n  \
    \  my($other_count) = 0;\n    my($other_characters) = 0;\n    for ($string) {\n\
    \        my($char) = $_;\n        if ($char =~ /^[a-z]/) {\n            $lowercase_count++;\n\
    \            $lowercase_characters ++;\n        } elsif ($char =~ /^[A-Z]/) {\n\
    \            $uppercase_count++;\n            $uppercase_characters ++;\n    \
    \    } else {\n            $other_count++;\n            $other_characters ++;\n\
    \        }\n    }\n    my($distinct_characters) = ($lowercase_characters + $uppercase_characters)\
    \ * 2;\n    $distinct_characters += $other_characters;\n    $distinct_characters\
    \ += $other_count * $other_characters;\n    return $distinct_characters;\n}",
  "    my($length);\n    while($string =~ s/(.)\\1+/$1/g) {\n        $length++;\n\
    \    }\n    return $length;\n}", "    my $count = 1;\n    my $lowers = 1;\n  \
    \  my $uppers = 1;\n    my $symbols = 0;", "    my $char_counter = 0;\n    my\
    \ @chars = split //, $string;\n    $char_counter += scalar(@chars); # 1 for the\
    \ entire string\n    for (@chars) {\n        $char_counter += scalar(@{$_}); #\
    \ 1 for each character in each word\n    }\n    return $char_counter;\n}", '    my($count,
    $character);', "    my $count_dist = 0;\n    foreach my $char (split(//,$string))\
    \ {\n        $count_dist++;\n    }\n    return $count_dist;\n}\n</cell>\n<cell>",
  "    my($chars_count) = 0;\n    my($char) = uc($string[0]);\n    my($count);\n \
    \   for (my $i = 1; $i < $string; $i++) {\n        $char = uc($string[$i]);\n\
    \        if ($char ne $chars_count) {\n            $chars_count = $char;\n   \
    \         $count++;\n        }\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI do not know Perl, but you cannot use `uc($string[0])` when `$string[0]`\
    \ is not defined. And you do not need `$chars_count` since `$char` will be equal\
    \ to `$string[0]` after the first iteration (unless `++` evaluates first operand).\n\
    <|/ c |>\n<| c |>\n: You're correct, my bad. I was testing this in JavaScript\
    \ and it threw me for a loop. I've changed my answer.\n<|/ c |>\n<| c |>\nNow\
    \ I see that you've changed the code in your answer - now it is correct :)\n<|/\
    \ c |>\n<| c |>\nThanks Jonathan!  I was actually testing your solution out. \
    \ I noticed that your solution was a lot faster than mine.  I will test your solution\
    \ out and compare it to my solution.\n<|/ c |>\n<| c |>\n: Btw, you can replace\
    \ all your `++` with `+` (in JavaScript too). The only difference is the semantics\
    \ of the operator (it might work in some cases, but not in all).\n<|/ c |>\n<|\
    \ a |>\nHow about this?\n<code>\nfunction countDistinctCharacters(str) {\n  var\
    \ chars = {};\n  var count = 0;\n  var char;\n  for (var i = 1; i < str.length;\
    \ i++) {\n    char = str.substr(i, 1);\n    chars[char] = chars[char] + 1 || 1;\n\
    \  }\n  for (var key in chars) {\n    count = Math.max((count + chars[key]), 1);\n\
    \  }\n  return count;\n}\n</code>\nThis should use less memory (as long as str\
    \ doesn't get large), and be faster, too.\n<|/ a dscore=0 tags=perl,javascript\
    \ |>\n<| a dscore=0 |>\nHere's a javascript solution:\n<code>\nvar str = \"Jerry\"\
    ;\nvar count = 0;\nvar counts = {};", "    my %seen = ();\n    my $count = 0;\n\
    \    for my $char (split //, $string) {\n\t$seen{$char}++;\n\t$count++ while $seen{$char}\
    \ == 1;\n    }\n    $count;\n}", "    my $chars_count = 0;\n    my $current_char;\n\
    \    for my $char (split(//, $string)) {\n        $current_char = uc($char);\n\
    \        if ($chars_count == 0) {\n            $chars_count = $chars_count;\n\
    \        }\n        elsif ($chars_count != 0) {\n            $chars_count = $chars_count\
    \ + $current_char eq $char ? 1 : $chars_count;\n        }\n    }\n    return $chars_count;\n\
    }", "    my $count = scalar($string);\n    my($letter, $current_char);\n    for(my\
    \ $i = 0; $i < $count; $i++) {\n        $letter = substr($string, $i, 1);\n  \
    \      $current_char = ord(substr($string, $i, 1));\n        for(my $j = 0; $j\
    \ < 256; $j++) {\n            if(($j != $current_char) && (($letter ~~ pack(\"\
    c\", $j)) || ($letter ~~ pack(\"C\", $j)))) {\n                $count--;\n   \
    \             last if $count == 1;\n            }\n        }\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    my $last_char;", "    my($num_chars);\n\
    \    my($character);", "    my $count = 0;\n    $string =~ tr/ /U/;\n    my $i\
    \ = 0;\n    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    while($i\
    \ < length($string)) {\n        $string =~ tr/a-z/A-Z/;\n        $string =~ tr/A-Z/a-z/;\n\
    \        $count++;\n    }\n    return $count;\n}", "    $string =~ tr/A-Z/a-zA-Z/;\n\
    \    return scalar keys %{ Hash::Util::FieldHash->new( { %{$string} }, { undef=>1\
    \ } ) };\n}", "    my $result = 0;\n    my $char_hash = {};\n    foreach my $character\
    \ (split(//,$string)) {\n        $char_hash->{$character}++;\n    }\n    foreach\
    \ my $char (keys(%$char_hash)) {\n        $result += $char_hash->{$char};\n  \
    \  }\n    return $result;\n}", "    $string =~ tr/a-z/A-Z/;\n    return scalar\
    \ keys %{$string =~ /[A-z]/};\n}", "    my(@distinct_characters);\n    foreach\
    \ my $character(@$string) {\n        if ($character =~ /[a-z]/i) {\n         \
    \   $distinct_characters[$character] ||= 0;\n            $distinct_characters[$character]++;\n\
    \        }\n        if ($character =~ /[A-Z]/i) {\n            $distinct_characters[$character]\
    \ ||= 0;\n            $distinct_characters[$character]++;\n        }\n       \
    \ if ($character =~ /[0-9]/i) {\n            $distinct_characters[$character]\
    \ ||= 0;\n            $distinct_characters[$character]++;\n        }\n    }\n\
    \    my $count = 0;\n    for my $character(keys %$distinct_characters) {\n   \
    \     $count++;\n    }\n    return $count;\n}", "    my $count = 0;\n    for (length($string))\
    \ {\n        my $char = substr($string, 0, 1);\n        $count += 1 while $string->[$_]\
    \ eq $char;\n    }\n    return $count;\n}", "    my $count = 0;\n    $string =~\
    \ s/(.)/ $1 eq $1 ? ++$count : $count/ge;\n    return $count;\n}", "    my $count\
    \ = 0;\n    foreach my $char (split(//, $string)) {\n        $count++ unless defined\
    \ $count{$char};\n    }\n    return $count;\n}", "    my $length = 0;\n    my\
    \ @char_hash;\n    \n    for my $char (split //, $string) {\n        if ($char\
    \ eq 'x') {\n            $char_hash[$char] = 1;\n        }\n        elsif ($char\
    \ eq 'X') {\n            $char_hash[$char] = 2;\n        }\n        else {\n \
    \           $char_hash[$char]++;\n        }\n    }\n    \n    foreach my $key\
    \ (sort keys %char_hash) {\n        $length++;\n    }\n    return $length;\n}",
  "    return scalar(grep{!($_ =~ m/[a-z]/i)} split(//,$string));\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    scalar(split(//,$string));\n\
    }", "    $string =~ tr/a-z/A-Z/;\n    $string =~ tr/A-Z/a-z/;\n    return $string\
    \ =~ tr/A-Za-z0-9//;\n}", "    return scalar(grep(/[a-z]/i,$string));\n}", " \
    \   my $count = 0;\n    my %counts;\n    $counts{''} = 0;\n    \n    for ($string)\
    \ {\n        my ($letter) = $_;\n        $counts{$letter} += 1;\n    }\n    \n\
    \    foreach my $key (keys %counts) {\n        $counts{$key} /= ($counts{$key}\
    \ > 1)?1:0;\n        $count += $counts{$key};\n    }\n    \n    return $count;\n\
    }", "    # If the string has only one character in it, we will treat it as distinct\
    \ characters\n    if ( $string =~ /^(.)$/s ) {\n        return 1;\n    }\n   \
    \ # Iterate over the string, counting distinct characters one by one\n    my $count\
    \ = 0;\n    while ( $string =~ /^(.)/gs ) {\n        ++$count;\n    }\n    return\
    \ $count;\n}", '    my $result;', '    my($result);', '    my %count = ();', " \
    \   $string =~ tr/A-Z/a-z/;\n    $string =~ tr/a-z/A-Z/;\n    return ($string\
    \ =~ tr/A-Z/a-z/) + 1;\n}", "    my $count = 0;\n    $string =~ tr/a-zA-Z//cd;\n\
    \    return $count;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `tr` doesn't make any\
    \ sense. `tr` replaces characters, not substrings.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I was just trying to make `count_distinct_characters`\
    \ more readable and understandable by showing the `tr` usage.\n<|/ c |>\n<| a\
    \ tags=perl,unix |>\nPerl solution:\n<code>", "    return length($string) - length(lc\
    \ $string);\n}", "    my($char_num);\n    my($char_map);", "    $string =~ tr/A-Za-z//cd;\n\
    \    $string =~ tr/A-Za-z0-9//cd;\n    return scalar keys %{ $string };\n}", " \
    \   my $count = 0;\n    foreach my $char (split('', $string)) {\n        $count++\
    \ if ($char =~ /^(.)/i);\n    }\n    return $count;\n}", "    $string =~ tr/a-z/A-Z/;\n\
    \    return scalar(\n        $string =~ tr/A-Za-z/\n    );\n}", "    my $string\
    \ = $string =~ tr/ /0/;\n    return $string =~ tr/ABCDEFGHIJKLMNOPQRSTUVWXYZ/0/;\n\
    }", "    my(@characters) = split('', $string);\n    my $count = 1;\n    $count++\
    \ while $characters[$count] =~ /./i;\n    return $count;\n}", '    my $count =
    0;', "    my($characters) = 0;\n    my($char_found) = 0;\n    \n    # Search for\
    \ all characters within $string that do not already have $characters assigned\
    \ a value.\n    # Each time a character is found, increment $characters by the\
    \ number of times it occurs, \n    # and increment $char_found accordingly.\n\
    \    while ($string =~ /([A-Za-z])/g) {\n        $char_found += $1;\n        $characters++;\n\
    \    }\n    \n    return $characters;\n}", "    $string =~ tr/a-zA-Z//cd;\n  \
    \  return scalar;\n}", "    return 0 unless $string;\n    my($count) = 0;\n  \
    \  my $char;\n    foreach $char (split(//, $string)) {\n        $count++ if $char\
    \ !~ /[^a-zA-Z0-9_]/g;\n    }\n    return $count;\n}", "    my($chars_found) =\
    \ 0;\n    my($current_character);"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
