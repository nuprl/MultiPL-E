name: HumanEval_91_is_bored
language: pl
prompt: "# You'll be given a string of words, and your task is to count the number\n\
  # of boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
  \ are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored(\"Hello world\"\
  )\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n# 1\nsub is_bored {\n    my($S) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_bored;\n\
  \        if(eq_deeply($candidate->(\"Hello world\"),0)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Is the\
  \ sky blue?\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"I love It !\"),1)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bIt\"\
  ),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  I feel good today. I will be productive. will kill It\"),2)) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"You\
  \ and I are going for a walk\"),0)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    ($S) = join('',split/\\./,$S) if $S =~ /^\\s*$/;\n    my($T) =\
    \ $S =~ /(^|\\s)I(\\W|$)/;\n    defined $T ? $T : 0;\n}", "    $S =~ s/^([.?!])/$1/;\n\
    \    $S =~ s/\\s*([.?!])\\s*$//;\n    return (scalar grep($S eq 'I', split(/\\\
    ./, $S)));\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for pointing me to\
    \ that question. I did find the question you linked to before posting this, but\
    \ it was a while ago and I no longer have access to any machine to test the answers\
    \ on.\n<|/ c |>\n<| c |>\nYour answer fails miserably on `II love to work`\n<|/\
    \ c |>\n<| c |>\nThanks. Fixed now.\n<|/ c |>\n<| c |>\nIt still fails for `II\
    \ love to work` - I assume that's what you mean with failing\n<|/ c |>\n<| c |>\n\
    I'm a bit surprised `split /\\b/`\n<|/ c |>\n<| a tags=perl |>\n<code>", '    my($count,
    $boredom);', "    my($bored_pattern)= '{I}\\.?!';\n    my($bored) = 0;\n    $S\
    \ =~ s/($bored_pattern)/++$bored;\n    return $bored;\n}", "    my $num_boredoms\
    \ = 0;\n    while ($S =~ /\\.\\.|\\?|!/) {\n        ++$num_boredoms if $S =~ /^I\\\
    ./;\n        ++$num_boredoms if $S =~ /^I\\?/;\n        ++$num_boredoms if $S\
    \ =~ /^I\\!/;\n        $S =~ s/^I//;\n    }\n    return $num_boredoms > 0;\n}",
  "    my $b = 0;\n    for (split /\\.|\\?|!/, $S) {\n        $b++ if /^I\\b/;\n \
    \   }\n    return $b;\n}", "    my($boredoms_found, $boredoms_not_found);\n  \
    \  while(my($word, $index) = each %$s) {\n        ($word eq \"I\" && $boredoms_found\
    \ == 0) ||\n        ($word eq \".\" && $boredoms_found == 0) ||\n        ($word\
    \ eq \"?\" && $boredoms_found == 0) ||\n        ($word eq \"!\" && $boredoms_found\
    \ == 0)\n          ? ($boredoms_found += $index)\n          : $boredoms_not_found++;\n\
    \    }\n    ($boredoms_found > $boredoms_not_found) ? 1 : 0;\n}\n</code>\n<|/\
    \ a tags=perl,regex,perl-data-structures |>\n<| a dscore=2 tags=perl,regex,perl-data-structures\
    \ |>\nUsing a hash is definitely the best way.  But if you are going to be doing\
    \ this a lot then it may be worth the overhead of converting each sentence into\
    \ a hash (I haven't actually checked how long that would take).\nYou didn't specify,\
    \ but if you're not worried about punctuation, this could work:\n<code>\nmy =\
    \ split (/[\\.\\?\\!]/, <STDIN>);\nmy $num_bored = 0;\nforeach my $sentence (@sentences)\
    \ {\n    $num_bored += ($sentence =~ /^I/ ? 0 : 1);\n}\nprint \"$num_bored\\n\"\
    ;\n</code>\nThis takes your input, splits it into sentences, checks to see if\
    \ each sentence starts with \"I\" and returns 0 if so, and 1 otherwise.\n<|/ a\
    \ |>\n<| c |>\nIt depends on how big the input is.\n<|/ c |>\n<| c |>\n, It's\
    \ not really big. On my machine, it's only 100 or so sentences.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYou can use a hash table. \n<code>", "    my $N = -1;\n    foreach\
    \ my $w (split /\\.|\\?|\\!/, $S) {\n        if ($w eq 'I') {\n            $N++;\n\
    \        }\n    }\n    return $N;\n}", "    my(@words) = split;\n    my $count\
    \ = 0;\n    foreach my $word (@words) {\n        if($word =~ /^I\\s/) {\n    \
    \        $count++;\n        }\n    }\n    return $count;\n}", "    my $bored =\
    \ 0;\n    for my $w (split /\\./, $S) {\n        for my $r (qw!? !.) {\n     \
    \       $bored += $w =~ /^$r/;\n        }\n    }\n    return $bored;\n}", "  \
    \  $S =~ /^I\\w*/;\n    return scalar;\n}", "    my $N = -1;\n    my ($I) = m/(I[^\\\
    .!?]*)/;\n    my ($E) = m/(E[^\\.!?]*)/;\n    my ($A) = m/(A[^\\.!?]*)/;\n   \
    \ my ($O) = m/(O[^\\.!?]*)/;\n    my ($H) = $S =~ m/(.)/;\n    return $N if $I\
    \ !~ /I/ || $E !~ /E/ || $A !~ /A/ || $O !~ /O/ || $H !~ /\\./ || $H !~ /!/;\n\
    \    $N += 1;\n    return $N;\n}", "    $S =~ s/ /\\.|\\.\\?|\\.\\!| /ig;\n  \
    \  return 1 if $S =~ /^\\b.I\\b/;\n    return 0;\n}", "    my $boredoms = 0;\n\
    \    my($I, $O, $N);\n    for ($I = 0, $N = $#S; $I < $N; $I++) {\n        my\
    \ $word = $S[$I];\n        if ($word eq 'I' || $word eq 'you' || $word eq 'he'\
    \ || $word eq 'she') {\n            $boredoms += 1;\n        }\n        if ($word\
    \ =~ /^[A-Za-z0-9.!?]/) {\n            $boredoms += 1;\n        }\n    }\n   \
    \ return $boredoms;\n}", "    my $num_boredoms = 0;\n    my $prev_state = 0;\n\
    \    foreach my $word (split /\\.|\\?|\\!/, $S) {\n        $prev_state += 1 if\
    \ ($word eq 'I');\n        if ($word eq '.') {\n            $num_boredoms = $prev_state\
    \ if ($prev_state > 0);\n            $prev_state = 0;\n        }\n    }\n    return\
    \ $num_boredoms;\n}", "    my(@boredoms);\n    my($boredom);\n    my($count);",
  "    if ($S =~ /^I (?:is|are) bored/) {\n        return 0;\n    }\n    else {\n\
    \        return 1;\n    }\n}", "    $S =~ s/^\\s+//;\n    my(@words) = split /([\\\
    .\\?!])/, $S;\n    my($bored) = 0;\n    foreach my $w (@words) {\n        $bored\
    \ += 1 if ($w eq 'I');\n    }\n    return $bored;\n}\n</code>\n<|/ a tags=perl,regex,performance\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "    return 0 if $S =~ /^\\W/ or $S\
    \ =~ /^\\./;\n    return 1 if $S =~ /^\\?/ or $S =~ /^!/;\n    return 2;\n}",
  "    my $boredom = 0;\n    $boredom += 1 if ($S =~ /^(I|me)/s);\n    $boredom +=\
    \ 1 if ($S =~ /^(you|you're|you've|you'll|you'll've)/s);\n    $boredom += 1 if\
    \ ($S =~ /^(I|you|we|me|us|you're|you've|you'll)/s);\n    $boredom += 1 if ($S\
    \ =~ /^(I|you|we|me|us|you're|you've|you'll|you're|you've|you're|you'll've)/s);\n\
    \    $boredom += 1 if ($S =~ /^(I|you|we|me|us|you're|you've|you'll|you're|you've|you'll've|you're|you've|you'll|you're|you've|you'll've|you're|you've|you'll've)/s);\n\
    \    return $boredom;\n}", "    my $n = 0;\n    for (split('\\.\\?\\!',$S)) {\n\
    \t$n = $n + $wordcount{$_};\n    }\n    return $n;\n}", "    $S =~ /^(I)(.*)(\\\
    .|?|!)/;\n    return scalar grep(/^I/,$3);\n}", "    my($ws,$boredoms) = 0;\n\
    \    while(my($word,$chars) = split ' ', $S, 2) {\n        $boredoms++ if $char\
    \ eq '.' || $char eq '?' || $char eq '!';\n    }\n    return $boredoms;\n}", " \
    \   chomp($S);\n    my @A = split (/([\\.\\?!])/, $S);\n    my $B = 0;\n    foreach\
    \ my $A (@A) {\n        my $C = substr($A, 0, 1);\n        if ($C eq \"I\") {\n\
    \            $B++;\n        }\n    }\n    return $B;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work when the string contains multiple sentences.\
    \ The number of sentences in `is_bored` is always the same as number of elements\
    \ in `$A`.\n<|/ c |>\n<| c |>\nYou're right. I've updated my answer so it works\
    \ now.\n<|/ c |>\n<| c |>\nIf it helps, it works now. Try running it on your sample\
    \ input. I only added one line to print out $B.\n<|/ c |>\n<| c |>\nIt still doesn't\
    \ work, because it counts also the sentences that are not bored but contains \"\
    I\" in the first word.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    $S =~ /^(?:I[\\\
    .\\?!]|^)([^.!?]+)\\z/;\n    my $length = $2 ne 'I' ? length($2) : 0;\n    return\
    \ $length;\n}", "    my @words = split /([\\.\\?\\!])/, $S;\n    my $boredoms\
    \ = 0;\n    foreach my $w (@words) {\n        if($w eq \"I\") {\n            $boredoms++;\n\
    \        }\n    }\n    return $boredoms;\n}", "    my $counter = 0;\n    if ($S\
    \ =~ m/\\bI\\b/) {\n        $counter++;\n    }\n    return $counter;\n}\n</cell>\n\
    <cell>", "    return $S =~ /((?<=^| )(I(?=\\.|!|\\?|$))|(\\. | \\? | \\!))/;\n\
    }", "    $S =~ s/^\\s*//;\n    $S =~ s/\\s*$//;\n    $S =~ s/\\.\\.\\B/\\.\\B/g;\n\
    \    $S =~ s/\\.\\B/\\.\\B/g;\n    $S =~ s/\\?\\B/\\.\\B/g;\n    $S =~ s/\\!\\\
    B/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n  \
    \  $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\B/g;\n    $S =~ s/\\bI\\\
    b/\\.\\B/g;\n    $S =~ s/\\bI\\b/\\.\\", "    $S =~ /^(I)/;\n    $bored++;\n}",
  "    my %count = ();\n    my $boredom_count = 0;\n    for (split(\" \",$S)) {\n\t\
    if ($_ =~ /^I/ ) {\n\t    $count{\"I\"}++;\n\t}\n\telsif ($_ =~ /^[.?!]/ ) {\n\
    \t    $count{$_}++;\n\t}\n\telse {\n\t    $boredom_count++;\n\t}\n    }\n    return\
    \ $boredom_count;\n}", "    $S =~ /^(I|We|You|Me|The|What)\\.?$/;\n    if ($1)\
    \ {\n\treturn 0;\n    }\n    return 1;\n}", "    $S =~ /^I\\w*\\.?\\.?/;\n   \
    \ return ($S =~ /^I\\w*\\.?\\.?/);\n}", "    return $S =~ /^\\s*I\\s*/ ? 1 : 0;\n\
    }", "    chomp($S);\n    if ($S =~ /^([Ix]{0,1}\\.)(.*)([Ix]{0,1}\\.)$/s) {\n\
    \        $S = $3;\n    } else {\n        $S = $1;\n    }\n    $S = uc($S);\n \
    \   $S =~ tr/[A-Z]/[aeiou]/;\n    return 1 if ($S =~ /^[Ix].+[Ix]$/);\n    return\
    \ 0 if ($S =~ /^[Ix].+[Ix][Ii][Pp]/);\n    return 0 if ($S =~ /^[Ix].+[Ix][Ii][Pp].+[Ix]$/);\n\
    \    return 0 if ($S =~ /^[Ix].+[Ix][Ii][Pp].+[Ix][Ii][Pp]/);\n    return 0 if\
    \ ($S =~ /^[Ix].+[Ix][Ii][Pp].+[Ix][Ii][Pp][Ii][Pp]/);\n    return 0 if ($S =~\
    \ /^[Ix].+[Ix][Ii][Pp].+[Ix][Ii][Pp][Ii][Pp][Ii][Pp]/);\n    return 0 if ($S =~\
    \ /^[Ix].+[Ix][Ii][Pp].+[Ix][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp]/);\n\
    \    return 0 if ($S =~ /^[Ix].+[Ix][Ii][Pp].+[Ix][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][Pp][Ii][P",
  "    $S =~ /\\.|!|\\?|I /;\n    return length($&);\n}", "    my($i, $n) = 0;\n \
    \   while(1) {\n        if( $S =~ /^I/ ) {\n            $n++;\n        }\n   \
    \     elsif( $S =~ /^[.?!]$/ ) {\n            last;\n        }\n        elsif(\
    \ length($S) == 0 ) {\n            last;\n        }\n        else {\n        \
    \    $S = $S[0];\n        }\n    }\n    $n;\n}", "    $S =~ m/(\\.|!|\\?)I\\b/;\n\
    \    return $+;\n}", "    my($bored_string) = 0;\n    my ($sentence_counter, $sentence_end);\n\
    \    my (@sentences, $bored);\n    \n    # Split the given sentence into sentences.\n\
    \    ($bored_string) = $S =~ /\\.|!|?/;\n    \n    # Split each sentence into\
    \ words.\n    (@sentences, $sentence_counter, $sentence_end) = ($bored_string\
    \ =~ m/([^\\.\\?!]+[\\.\\?!]\\S*)/s);\n    \n    # Go through the words.\n   \
    \ for ($sentence_counter; $sentence_counter <= $sentence_end; $sentence_counter++)\
    \ {\n        \n        # If the word starts with I, it's a boredom.\n        if\
    \ ($sentences[$sentence_counter] =~ /I\\b/) {\n            $bored = 1;\n     \
    \       last;\n        }\n    }", "    my(@sentence) = split (/\\./, $S);\n  \
    \  my($count) = 0;\n    for ($i = 0; $i < @sentence; ++$i) {\n        if ($sentence[$i]\
    \ eq \"I\") {\n            ++$count;\n        }\n    }\n    return $count;\n}",
  "    $S =~ s/[\\.\\?\\!]+/ /g;\n    my $count = () = $S =~ /^I (\\S+)/;\n    $count\
    \ = ($count+0)+1;\n    return $count;\n}", "    my $count = 0;\n    foreach my\
    \ $w (split(/\\W+/,$S)) {\n        if ($w =~ /^I(\\.|!|\\?|\\.$)/) {\n       \
    \     $count++;\n        }\n    }\n    return $count;\n}", "    $S =~ s/^([.?!])//;\n\
    \    my $n = scalar keys %boredom;\n    return $n if $S =~ /\\b$boredom{$_}\\\
    b/;\n    return 0;\n}", "    my($bored) = 0;\n    my($sentence);\n    my($boredWord);\n\
    \    my($count) = 0;", "    my $n = -1;\n    my $bored = 0;\n    my $i;\n    my\
    \ $w = 0;\n    my $x;\n    my $y;", "    my($boredom = $S);\n    chomp($boredom);\n\
    \    my($boredom_found) = 0;\n    my($boredom_found1);", "    $S =~ s/\\.|!|I//g;\n\
    \    $S =~ s/\\?//g;\n    $S =~ s/\\.$//g;\n    my $len = length($S);\n    $S;\n\
    }\n</code>\n<|/ a tags=string,perl,regex,string |>\n<| c |>\nI really don't understand\
    \ why this was downvoted. It's a correct answer. I can't really see any other\
    \ way to improve it. I would recommend you check out the [Perl Cookbook](http://perldoc.perl.org/perlbook.html),\
    \ in particular the section on [Perl regular expressions](http://perldoc.perl.org/perlre.html).\
    \ In particular, check out the section on `Character Classes and Bracket Expressions`.\
    \ That will probably be helpful in the future.\n<|/ c |>\n<| c |>\nI didn't downvote\
    \ it, but your answer doesn't work for the test cases in the question (which don't\
    \ begin with 'I' but contain 'I').\n<|/ c |>\n<| c |>\nOops, sorry about that.\
    \ I was thinking that 'I' was the *only* non-alphanumeric character in these sentences.\
    \ I'll fix it now.\n<|/ c |>\n<| c |>\nOops, sorry about that too. Now it should\
    \ be fixed.\n<|/ c |>\n<| c |>\nWhat if `boredom` *starts* with a digit? The question\
    \ asks for `boredom` that starts with an 'I'.\n<|/ c |>\n<| a tags=string,perl,regex,string\
    \ |>\nHere's a pretty good solution that doesn't use regex:\n<code>\nuse warnings;\n\
    use strict;\nuse feature qw(say);", "    my $N = 1;\n    my $S = lc $S;\n    my\
    \ $K = substr($S,0,1);\n    $K =~ /[ie!?]/i;\n    if($K eq 'i') {\n        if($S\
    \ =~ /^\\./ || $S =~ /\\.\\?/ || $S =~ /\\.\\!/) {\n            $N = 0;\n    \
    \    } else {\n            $N = 1;\n        }\n    }\n    return $N;\n}", '    my($boredom);',
  "    my ($boredoms) = ($S =~ /^($RE{boredom})$/);\n    return $boredoms ? 1 : 0;\n\
    }", "    \n    my $C = 0;\n    for ($S =~ m/([.!?])/) {\n        if ($1 eq '.'\
    \ || $1 eq '!' || $1 eq '?') {\n            ++$C;\n        }\n    }\n    \n  \
    \  return $C == 0;\n}", "    chomp($S);\n    $bored = 0;\n    foreach $word (split\
    \ /\\.|\\?|!/, $S) {\n        if ($word eq \"I\") {\n            $bored = 1;\n\
    \            last;\n        }\n    }\n    return $bored;\n}\n</code>\n<|/ a tags=count,perl,loops\
    \ |>\n<| c |>\n`split(/\\.|\\?|!/, $S)` will split on `\\.` unless `?` or `!`\
    \ appears in the input. `split` has a special meaning of `/\\s+/` which means\
    \ \"one or more whitespace characters.\"\n<|/ c |>\n<| a dscore=1 |>\nTry this\
    \ :\n<code>\n$str = \"Hello world\";", "    $S =~ s/([.!?])/$1/g;\n    if ( $S\
    \ =~ /^I/ ) {\n        return 0;\n    }\n    else { return 1; }\n}", "    my $bored\
    \ = substr($S, 0, 1) =~ m/[\\.\\?\\!]/;\n    $bored = 1 if $bored; # first character\
    \ must be I\n    return $bored;\n}", "    my %hash = map { $_ => 0 } @bored_words;\n\
    \    my $count = 0;\n    while ($S =~ /(^|\\s)(\\b\\Q$bored_words{lc($1)}\\E)(\\\
    s|\\.|\\?|!)+/ig) {\n        $hash{$2}++;\n    }\n    foreach my $key (keys %hash)\
    \ {\n        if ($hash{$key} == 1) {\n            return 1;\n        }\n    }\n\
    \    return 0;\n}", "    my $N = 0;\n    $S =~ s/([.?!])/$1/g;\n    $N =~ /^I(\\\
    w+)$/ ? $N++ : 0;\n    return $N;\n}", "    my($boredoms);\n    \n    if($S =~\
    \ m/^(.*\\.)*[I]/ or $S =~ m/^(.*\\?)+[I]/ or $S =~ m/^(.*\\!)+[I]/) {\n     \
    \   $boredoms = 1;\n    } else {\n        $boredoms = 0;\n    }\n    return $boredoms;\n\
    }", "    my($bored) = ();\n    my($word_count) = 0;\n    my($bored) = \".?!\"\
    ;\n    my(@words);\n    foreach $word (split(/\\s+/, $S)) {\n        if ($word\
    \ =~ /^I$/) {\n            push(@bored, $word);\n        }\n    }\n    if (@bored\
    \ > 0) {\n        for ($i=0; $i < @bored; $i++) {\n            push(@words, $bored[$i]);\n\
    \        }\n        $word_count = scalar(@words);\n    }\n    return $word_count;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe question was for a solution that used the builtin\
    \ subroutine count which was provided in the question. This solution does not.\n\
    <|/ c |>\n<| c |>\nThat was my point. I would argue that this solution is more\
    \ correct than the builtin count subroutine.\n<|/ c |>\n<| c |>\nThat is correct,\
    \ although the builtin subroutine count is very efficient. On my computer it is\
    \ 10x faster than the solution using indexes.\n<|/ c |>\n<| c |>\nThat is incorrect.\
    \ Using indexes requires 2 passes; my solution requires 1 pass. So for long strings\
    \ my solution is slower than yours. And for short strings yours is the fastest.\n\
    <|/ c |>\n<| c |>\nI guess I meant using the `grep` function, which should be\
    \ more efficient than `index` since it does it all in one pass.\n<|/ c |>\n<|\
    \ a |>\nHere is how I would go about it. There are a few things to note about\
    \ this.", "    my(@b) = split('\\.|\\?|\\!', $S);\n    my $count = 0;\n    foreach\
    \ my $i (@b) {\n        if ($i eq 'I') {\n            $count++;\n        }\n \
    \   }\n    return $count;\n}", "    my(@words) = split(\" \", $S);\n    my($bored,$boredom);\n\
    \    my $i = 0;\n    foreach my $word (@words) {\n        $boredom += 1;\n   \
    \     last if $word eq \"I\";\n        $i += 1;\n    }\n    return $bored;\n}\n\
    </code>\n<|/ a tags=count,perl,sentence |>\n<| c |>\nThis is a very good answer.\
    \ It seems that the person asking the question wants a code sample, not an explanation\
    \ of how to solve the problem.\n<|/ c |>\n<| c |>\nThe question asks for a code\
    \ sample, not a description of how to solve the problem.\n<|/ c |>\n<| c |>\n\
    : I disagree. The asker wants to write code and not a description of a solution.\
    \ (Which may well be the best answer.)\n<|/ c |>\n<| a tags=count,perl,sentence\
    \ |>\nHere is some code from my 'Programming Perl' book that does something similar\
    \ to what you're trying to do.  It might give you some ideas.\n<code>\n    sub\
    \ count_sentences {\n    my $input = shift;\n    my $count = 0;\n    $input =~\
    \ s/[^.!?]+//g;\n    while ($input =~ s/[.!?]+//g) {\n        ++$count;\n    }\n\
    \    return $count;\n}\n</code>\nIt removes punctuation, spaces, and non-word\
    \ characters, and counts the number of times the loop is entered.\n<|/ a dscore=2\
    \ |>\n<| c |>\nI thought that might have been the case but I'm afraid to say it\
    \ doesn't. This code doesn't count periods or question marks (unless they're at\
    \ the beginning of a sentence).\n<|/ c |>\n<| c |>\n: It does; I checked it. \
    \ Perhaps you misinterpreted my answer.\n<|/ c |>\n<| c |>\nSorry, I misread.\
    \ :) I thought you said it counts periods and question marks at the beginning\
    \ of sentences.\n<|/ c |>\n<| c |>\n: I believe you to be correct.  I had to remove\
    \ periods and question marks from the beginning of the sentence before counting\
    \ them, so I couldn't test the code myself.  I'll be careful with my wording.\n\
    <|/ c |>\n<| a dscore=2 |>\nA quick and dirty version which just uses Perl operators.\
    \ I believe it works for your test case but may not for other examples:\n<code>",
  "    $S =~ m/\\b(i|i)(n|ve)\\b|\\b(am|amen|is|are|isn't|was|were|wasn't|been|been|was|were|weren't|wasn|being|wasn|being|weren|wasn|been|was|were|wasn't|are|is|are)\\\
    b/;\n    return 0 if $?;\n    return 1;\n}", "    my $boredom = 0;\n    for(split(/\\\
    .|\\?|!/, $S)) {\n        for(split(/([A-Z][a-z]+)/, $_, 3)) {\n            if($_\
    \ eq \"I\") {\n                $boredom++;\n            }\n        }\n    }\n\
    \    return $boredom;\n}", "    my ($boredom, $counter);\n    \n    if ($S=~/\\\
    .$/) { $boredom = $S; }\n    elsif ($S=~/[!?]$/) { $boredom = $S; }\n    else\
    \ { $boredom = undef; }\n    \n    if (defined $boredom) {\n        if ($boredom\
    \ =~ /\\bI\\b/) {\n            $counter ++;\n        }\n    }\n    \n    return\
    \ $counter;\n}", "    my @words = split /\\./, $S;\n    my $bored = 0;\n    for\
    \ my $word (@words) {\n        $bored++ if $word eq 'I' || $word eq 'you' || $word\
    \ eq 'it';\n    }\n    return $bored;\n}", "    chomp($S);\n    if ( $S =~ /^.\\\
    ?$|.\\!$/ ) {\n        return 0;\n    }\n    my $cnt = 0;\n    $cnt += $S =~ /^I\\\
    b/;\n    $cnt += $S =~ /^i\\b/;\n    $cnt += $S =~ /^e\\b/;\n    $cnt += $S =~\
    \ /^a\\b/;\n    $cnt += $S =~ /^o\\b/;\n    $cnt += $S =~ /^e\\b/;\n    $cnt +=\
    \ $S =~ /^y\\b/;\n    $cnt += $S =~ /^l\\b/;\n    $cnt += $S =~ /^l\\b/;\n   \
    \ $cnt += $S =~ /^o\\b/;\n    $cnt += $S =~ /^w\\b/;\n    $cnt += $S =~ /^h\\\
    b/;\n    $cnt += $S =~ /^y\\b/;\n    $cnt += $S =~ /^d\\b/;\n    $cnt += $S =~\
    \ /^e\\b/;\n    $cnt += $S =~ /^\\.$|\\.\\.$|\\.\\?$|\\.\\!$/ ? 1 : 0;\n    return\
    \ $cnt;\n}", "    my $bored = 0;\n    while ($S =~ /^([^.?!]+)(\\.|\\.\\?|\\!)$/)\
    \ {\n\tif ($1 eq 'I') {\n\t    $bored++;\n\t}\n    }\n    return $bored;\n}",
  '    my ($boredom_start, $boredom_end) = ($S =~ /^(?:I|[.?!]\s)/);', "    my $i\
    \ = 0;\n    while ($S =~ /(?:^|\\?|!)I\\B/ig) {\n        $i++;\n    }\n    return\
    \ $i;\n}\n</code>\nThe regex above will match any sentence that starts with \"\
    I\" followed by any sequence of non-word characters, followed by a \"I\". You\
    \ may wish to adjust the regex accordingly, but this example should give you an\
    \ idea of the flexibility of Perl regexes.\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ very much for the answer, but unfortunately the regex you suggested isn't working\
    \ for me - it returns 0 for all inputs. I thought that maybe I should use something\
    \ else to solve my problem, but I'm not entirely sure which one. I'm thinking\
    \ maybe I should look into regular expressions more, maybe I should try with regular\
    \ expressions to solve my problem... But I still don't know exactly which one\
    \ to use (regular expressions or something else). Any thoughts on that?\n<|/ c\
    \ |>\n<| c |>\nOK, I've found out what was wrong with my code - it was very uneffective,\
    \ I've just noticed it because I used `while (<STDIN>)` instead of `while ($S\
    \ =~ /(?:^|\\?|!)I\\B/ig)` and it didn't work. Now it works perfectly fine with\
    \ my code. Thank you very much for your help!\n<|/ c |>\n<| c |>\nGlad you found\
    \ it useful. I've updated the answer with a much simpler regex that should work\
    \ just as well for your purposes.\n<|/ c |>\n<| a |>\nSince you've indicated that\
    \ you are not allowed to use any modules in your assignment, here's a solution\
    \ using a regex match and a simple state machine. As you didn't specify whether\
    \ you will be providing the input or just receiving it from the command line,\
    \ I've provided both.\n<code>\nuse strict;\nuse warnings;", "    return 0 if $S\
    \ =~ /^\\W(I)/;\n    return 1 if $S =~ /^\\W(I|\\?)/;\n    return 1 if $S =~ /^\\\
    W(I|!)/;\n    return 0;\n}", "    my %count;\n    my($boredom);\n    foreach my\
    \ $word (split(/\\./, $S)) {\n        my $i = index($word, \"I\");\n        if\
    \ ($i && $i + 1 < length($word)) {\n            $boredom = 1;\n            $count{$word}++;\n\
    \        }\n    }\n    return $boredom ? 1 : 0;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n`split` is awesome, but it's worth noting that `perl`'s `split` doesn't\
    \ accept the `/e` modifier like some regexp engines do. So, for instance, this\
    \ will not work: `split /\\.\\./, $S`\n<|/ c |>\n<| c |>\nThanks, I didn't realize\
    \ that.\n<|/ c |>\n<| c |>\nI thought that `split` with single argument would\
    \ be the same as `split` with two, since `split` with one argument behaves like\
    \ `split` with two. [perldoc](http://perldoc.perl.org/functions/split.html)\n\
    <|/ c |>\n<| c |>\nIt's not quite the same, though. If you give it a single argument,\
    \ it splits on any whitespace, even if it's inside double quotes. (So, `split\
    \ /\\t/` splits on tabs, instead of on whitespace).\n<|/ c |>\n<| a |>\nPerl's\
    \ split function doesn't have the option to split by '.' but you can make use\
    \ of another function like index to get the index of first occurrence of 'I'.\n\
    <code>", "    my (%seen, %bored);\n    my $i = 0;\n    for my $word (split /([.!?])/,\
    \ $S) {\n        if (exists $seen{$word}) {\n            $bored{$word}++;\n  \
    \          $seen{$word}++;\n        } else {\n            $seen{$word} = $i;\n\
    \        }\n        $i++;\n    }", "    my @words = split \"\\.|\\?|!\", $S;\n\
    \    my $bored = 0;\n    my $start_flag = 0;\n    my $i = 0;\n    while ($i <\
    \ scalar(@words)) {\n        my $word = shift @words;\n        if ($word eq 'I')\
    \ {\n            $start_flag = 1;\n        }\n        elsif ($word eq '.' || $word\
    \ eq '?' || $word eq '!') {\n            if ($start_flag == 1) {\n           \
    \     $start_flag = 0;\n                $bored++;\n            }\n        }\n\
    \        $i++;\n    }\n    return $bored;\n}", "    return $S =~ /^I.*[.?!]/ ?\
    \ 1 : 0 \n}", "    $S =~ s/[\\.\\?\\!]//g;\n    $S =~ /^I/ or return 0;\n    return\
    \ $S =~ /\\w+/ ? 1 : 0;\n}", '    my ($count, $bored);', "    my($bored);\n  \
    \  my($bored_count);\n    if ($S =~ /\\A.*\\b.*\\b.*\\b/) {\n        $bored =\
    \ &_is_bored_helper($S);\n        if ($bored) {\n            $bored_count++;\n\
    \        }\n    }\n    return $bored_count;\n}", "    \n    return 1 if $S =~\
    \ /I/g;\n    \n    return 0;\n}", "    my $count = 0;\n    my $boredom = 0;\n\
    \    while($S =~ m/(^|\\?|\\.)(I)/i) {\n        $count++;\n        $boredom++;\n\
    \    }\n    return $boredom;\n}", "    my $count = 0;\n    foreach my $x (split(/\\\
    ./, $S)) {\n        if ($x eq \"I\") {\n            $count++;\n        }\n   \
    \ }\n    return $count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis\
    \ is my take on it:\n<code>", "    \n    my $bored = 0;\n    for my $word (split\
    \ /([\\.\\?\\!])/, $S) {\n        $bored++ if $word eq \"I\";\n    }\n    return\
    \ $bored;\n}", '    my $count = 0;', "    \n    # Remove any leading or trailing\
    \ spaces so that\n    # the boredom words are not considered a boredom word.\n\
    \    $S =~ s/^\\s*|\\s*$//g;\n    \n    $S =~ m/\\b(I|I)[^.!?]+[.!?]\\b/gi;\n\
    \    \n    return $+;\n}", "    \n    my($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$c10,$c11);\n\
    \    ($c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$c10,$c11) = split /\\.|!|?/, $S;\n\
    \    \n    my($a1,$a2,$a3,$a4,$a5,$a6,$a7,$a8,$a9,$a10,$a11);\n    ($a1,$a2,$a3,$a4,$a5,$a6,$a7,$a8,$a9,$a10,$a11)\
    \ = split /\\.|!|?/, $c1;\n    \n    my($s1,$s2,$s3,$s4,$s5,$s6,$s7,$s8,$s9,$s10,$s11);\n\
    \    ($s1,$s2,$s3,$s4,$s5,$s6,$s7,$s8,$s9,$s10,$s11) = split /\\.|!|?/, $c2;\n\
    \    \n    my($n1,$n2,$n3,$n4,$n5,$n6,$n7,$n8,$n9,$n10,$n11);\n    ($n1,$n2,$n3,$n4,$n5,$n6,$n7,$n8,$n9,$n10,$n11)\
    \ = split /\\.|!|?/, $c3;\n    \n    my($boredom,$notboredom);\n    ($boredom,$notboredom)\
    \ = split /\\.|!|?/, $c4;\n    \n    my($i1,$i2,$i3,$i4,$i5,$i6,$i7,$i8,$i9,$i10,$i11);\n\
    \    ($i1,$i2,$i3,$i4,$i5,$i6,$i7,$i8,$i9,$i10,$i11) = split /\\.|!|?/, $c5;\n\
    \    \n    my($y1,$y2,$y3,$y4,$y5,$y6,$y7,$y8,$y9,$y10,$y11);\n    ($y1,$y2,$y",
  "    $S =~ /^\\W*I\\W+.+?\\W+\\W*$/g;\n    return $? == 0;\n}", "    my $num_bored\
    \ = 0;\n    my $start_bore = 0;\n    my $end_bore = 0;", '    my $count = 1;',
  "    \n    my %boreds = (\"I\", \"I\", \"!\", \"!\", \"!\", \"!\", \"!\", \"!\"\
    , \"?\");\n    \n    if ( $boreds{$S} ) {\n        return 1;\n    } else {\n \
    \       return 0;\n    }\n}", "    my ($boredom, @sentences) = $S =~ /(?:^|[\\\
    .\\?\\!])\\b.*\\b/;\n    my $bored_counter = 0;\n    my $i;\n    for $i (0 ..\
    \ $#sentences) {\n        $bored_counter += $#{$boredom}\n            < length($boredom)\n\
    \            &&\n            $sentences[$i] =~ /^\\b\\Q$boredom\\E\\b/;\n    }\n\
    \    return $bored_counter;\n}", "    chomp($S);\n    foreach my $w (split ' ',\
    \ $S) {\n        next if ($w =~ /^\\./);\n        next if ($w =~ /^\\?\\./);\n\
    \        next if ($w =~ /^\\!\\./);\n        my $count = ($w eq 'I') ? 1 : 0;\n\
    \        return $count;\n    }\n    return 0;\n}", "    my $count = 0;\n    foreach\
    \ (split /\\.|\\?|\\!/, $S) {\n        if (/^I/ .. /^I$/ ) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my($bored) = ();\n    $bored =\
    \ \\&boredom_finder;\n    my($bored) = find_bored($S, $bored);\n    if ($bored\
    \ == 0) {\n        &count_bored($S, $bored);\n    }\n    return $bored;\n}", " \
    \   my $boredom = 0;\n    my $pos = 0;\n    while ($pos < length($S)) {\n    \
    \    chomp($boredom = substr($S, $pos, 1));\n        chomp($boredom);\n      \
    \  if ($boredom =~ /^i/) {\n            return $boredom;\n        }\n        $pos\
    \ = $pos+1;\n    }\n    return 0;\n}", "    my ($i,$j,@boredoms) = (1,0,@boredoms);\n\
    \    for (; $i<length($S) && $S[$i] !~ /^[\\.?!]$/; $i++) {}\n    for (; $j<length($S)\
    \ && $S[$j] eq \"I\"; $j++) {}\n    for (; $i<length($S) && $S[$i] eq \"I\"; $i++)\
    \ {\n      push @boredoms, $j-$i;\n    }\n    return scalar;\n}", "    foreach\
    \ (split /,/, $S) {\n        if ($_ eq 'I') {\n            return 0;\n       \
    \ }\n    }\n    return 1;\n}", "    my($numboredoms) = 0;\n    my($boredom = $S)\
    \ =~ /^I\\./;\n    if ($boredom =~ /[\\.\\?!]/g) {\n        my($boredom) = $boredom\
    \ =~ /(\\A|\\s)I(\\S|[\\.\\?!])+/g;\n    }\n    $numboredoms += $#boredom;\n \
    \   return $numboredoms;\n}", "    my(@B) = ();\n    while($S =~ /^I (.+?) \\\
    ./s) {\n        push(@B, $1); \n    }\n    return scalar( @B );\n}", "    my ($num_bored)\
    \ = 0;\n    foreach my $word (split(/\\./, $S)) {\n        if($word eq 'I') {\n\
    \            $num_bored++;\n        }\n    }\n    return $num_bored;\n}", "  \
    \  chomp($S);\n    return $S =~ /^I.*\\b/ ? 1 : 0;\n}", "    foreach my $w (split\
    \ /\\.|\\?|\\!/, $S) {\n\tnext unless $w =~ /^I(.*)/;\n\treturn 0 if $1 !~ /^I(.*)/;\n\
    \treturn 1;\n    }\n    return 0;\n}", "    my $boredom = $S;\n    $boredom =~\
    \ /^I[\\s\\.\\?!].*$/i;\n    return length($boredom);\n}", "    \n    foreach\
    \ my $w (split(/ /, $S)) {\n\tmy $i = 0;\n\tforeach my $char (split (/[.!?]/,\
    \ $w)) {\n\t    $i++;\n\t    last if $char eq 'I';\n\t}\n\treturn $i;\n    }\n\
    \    return 0;\n}", "    $S=~ /(^|[^\\w\\.\\?!])I/g;\n    return $1 if $1;\n \
    \   return 0;\n}", "    $S =~ /[^\\.\\?\\!]\\S*$/;\n    if ( $S =~ /^I\\S*$/ )\
    \ {\n        return 0;\n    } else {\n        return 1;\n    }\n}", "    my $len\
    \ = length($S);\n    for (my $i = 0; $i < $len; $i++) {\n        my $c = substr($S,\
    \ $i, 1);\n        if ($c eq '.' || $c eq '?' || $c eq '!') {\n            return\
    \ 0;\n        }\n    }\n    return 1;\n}", "    chomp $S;\n    $S =~ /^(I)(.*)(\\\
    .|\\?|\\!)/;\n    return $1 if $1;\n    return 0;\n}", "    my %hash;\n    my($i)\
    \ = 0;\n    my($j, $k, $bored) = 0;\n    \n    while ($S =~ /(\\A|\\?|\\!)(.*\\\
    .|.*\\.|.*\\.)(\\z|\\A|$)/g) {\n        foreach $j ($1, $3, $4) {\n          \
    \  $hash{$j}++;\n        }\n        \n        if ($1 =~ /\\.$/ || $1 =~ /\\?$/\
    \ || $1 =~ /\\!$/) {\n            $bored++;\n        }\n    }\n    \n    return\
    \ 0 if $bored == 0;\n    return 1;\n}", "    ($S,@V) = split \".\",$S;\n    return\
    \ 0 if $V[0] =~ /^I.*$/ or $V[0] =~ /^!.*$/;\n    return 0 if $V[0] =~ /^.?I.*$/\
    \ or $V[0] =~ /^.?!.*$/;\n    return 0 if $V[0] =~ /^..?I.*$/ or $V[0] =~ /^..?!.*$/;\n\
    \    return 1;\n}", "    my ($bored, $bored_count);\n    foreach my $s (split(m|\\\
    .|\\?|\\!|, $S)) {\n        next if ($s =~ /^\\Q$ENV{HOME}\\/\\.local\\/share$/);\n\
    \        next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E$/);\n        next if ($s =~\
    \ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.local\\/share$/);\n    \
    \    next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\\
    E$/);\n        next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\\
    /\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.local\\/share$/);\n        next if ($s =~ /^\\\
    Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\\
    .\\.\\E$/);\n        next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\\
    /\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.local\\/share$/);\n\
    \        next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\\
    .\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E$/);\n     \
    \   next if ($s =~ /^\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\\
    /\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E\\Q$ENV{HOME}\\/\\.\\.\\E\\/\\E$/);\n     \
    \   $bored++;\n    }\n    $bored_count = scalar keys %bored;\n    return $bored_count;\n\
    }", "    my %BORED_WORD = qw(i me my);\n    my $count = $BORED_WORD{$S} || 0;\n\
    \    return $count;\n}", "    my $count = 0;\n    while ($S =~ /^(I.*\\.|I.*\\\
    ?|I.*\\!)$/ig) {\n\t$count++;\n\t$S =~ s/^I//;\n    }\n    return $count;\n}",
  "    return 0 if $S =~ /^\\W/ || $S =~ /^\\W\\W/;\n    return $#_+1 if $S =~ /^\\\
    W*([.?!])\\W*$/;\n    return 0;\n}", "    my ($i, $last);\n    $last = $S;\n \
    \   for ($i = 0; $i < length($S); $i++) {\n        my $c = substr($S, $i, 1);\n\
    \        $c =~ m/\\G\\./;\n        $c =~ m/\\G\\.\\?|\\G!/;\n        if ($c =~\
    \ m/I/) {\n            $i++;\n        }\n        $last = $i;\n    }\n    \n  \
    \  return $last - 1;\n}", "    my ($boredom, $bored) = (\"I\", 0);\n    foreach\
    \ $word (split /[.?!]/, $S) {\n        next if ($word eq \"I\");\n        if ($word\
    \ =~ /^I$/) {\n            $bored = 1;\n        }\n        if ($bored) {\n   \
    \         $boredom = $word;\n        }\n    }\n    return $bored;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=perl,regex dscore=0 |>\nHere is some code using Perl's\
    \ regex features. A nice little way to read regexes is with the perldoc or perldoc\
    \ perlretut commands. \nThe code below reads in your input file into a string\
    \ variable ($input). Then it splits the string into an array of lines (split(//,\
    \ $input)). \nThen it creates a hash using the first word as the key and the value\
    \ being the number of lines where that word is found in the line. \nIt then outputs\
    \ the number of lines that contain the word \"bored\"\n<code>\nuse strict;\nuse\
    \ warnings;", '    my ($boredom_start, $boredom_end) = qw/. ? !/;', "    foreach\
    \ my $s (split /\\.|\\?|\\!/, $S) {\n        if ($s =~ /^I\\b/) {\n          \
    \  return 1;\n        }\n    }\n    return 0;\n}", "    my %seen = ();\n    foreach\
    \ (split(//, $S)) {\n        my $word = $_;\n        $seen{$word}++;\n    }",
  "    my (@S) = split (/[.!?]/, $S);\n    my $boredom = $S[0] eq 'I' ? 1 : 0;\n \
    \   $boredom += scalar grep {$_ =~ /^I/ } @S;\n    return $boredom;\n}\n</code>\n\
    <|/ a dscore=4 tags=regex,perl,algorithm |>\n<| c |>\nThis is a great solution\
    \ - and it's also very readable. Nice work!\n<|/ c |>\n<| c |>\nYour solution\
    \ is O(n) and the other solution is O(n^2). Both have O(n) runtime but your solution\
    \ is more readable and thus should be used. See http://stackoverflow.com/questions/183617/what-is-the-time-complexity-of-a-program\n\
    <|/ c |>\n<| a dscore=4 |>\nHere's an O(n) solution, assuming that the input is\
    \ a stream of boredom sentences.\n<code>", "    $S =~ /([!?.])/;\n    return $1\
    \ + 0;\n}", "    my (@bored) = ();\n    my($i) = 0;", "    $S =~ /^([I])([\\.\\\
    ?!])(.*)$/;\n    my ($a,$b,$c) = ($1,$2,$3);\n    return ($a eq 'I') ? ( $b  eq\
    \ '.' || $b  eq '?' || $b  eq '!' || $c  eq '.' || $c  eq '?' || $c  eq '!' )\
    \ : 0; # $a is I, $b is one of .,?,!\n}", "    my($bored) = 0;\n    my($begin)\
    \ = $S =~ m/([.!?])/;\n    my($word) = $begin && $begin =~ /([^.!?]+)/;\n    while($begin\
    \ && $begin !~ m/([.!?])/) {\n        $begin =~ /([^.!?]+)/;\n        $word =\
    \ $1 && $1 =~ /([^.!?]+)/;\n    }\n    if($word) {\n        $bored = 1 if($word\
    \ eq \"I\");\n    }\n    return $bored;\n}", "    my $count = 0\n      unless\
    \ defined $S;\n    return 1 if ($S =~ /^I[.?!]$/);\n    $count++;\n}", "    my\
    \ $boredom = 0;\n    my @tokens = split /([\\.\\?\\!])/, $S;\n    foreach my $t\
    \ (@tokens) {\n        if ($t eq \"I\") {\n            $boredom++;\n        }\n\
    \    }\n    return $boredom;\n}", "    return 0 if($S =~ /^I(.*)\\./);\n    return\
    \ 0 if($S =~ /\\.(I|\\.|!)$/);\n    return 0 if($S =~ /\\?(I|\\.|!)$/);\n    return\
    \ 1 if($S =~ /\\!(I|\\.|!)$/);\n    return 1;\n}", "    my $i = 0;\n    while\
    \ ($i<length($S)) {\n        last if $S[$i]=~/^[iI]\\b/i;\n        $i++;\n   \
    \ }\n    return $i;\n}", "    chomp $S;\n    my $count = 0;\n    foreach my $word\
    \ (split /\\W+/, $S) {\n        foreach my $char (split /[.?!]/, $word) {\n  \
    \          if ($char eq 'I') {\n                $count++;\n            }\n   \
    \     }\n    }\n    return $count;\n}", '    my $bored = 0;', "    my @words =\
    \ split /([.?!])/, $S;\n    my $count = 0;\n    for (@words) {\n        $count\
    \ += 1 if $_ eq 'I';\n    }\n    return $count;\n}", "    my $boredom_count =\
    \ 0;\n    for (split(/\\.|\\?|!/, $S)) {\n        if ($_ eq 'I') {\n         \
    \   $boredom_count++;\n        }\n    }\n    return $boredom_count;\n}", "   \
    \ my @words = split \" \", $S;\n    foreach my $word (@words) {\n        return\
    \ 0 if $word !~ /^I[\\.\\?!]/;\n    }\n    return 1;\n}", "    for(split(/\\.|!|\\\
    ?|\\./, $S)) {\n        for(split(/\\.|!|\\?|\\./, shift)) {\n            if ($_\
    \ =~ /^I$/) {\n                return 1;\n            }\n        }\n    }\n  \
    \  return 0;\n}", "    \n    my $length = $#S - 1;\n    for (my $i = 0; $i <=\
    \ $length; $i++){\n        if ($S[$i] =~ /\\b(I\\w*|\\w*)\\b/){\n            return\
    \ 1;\n        }\n    }\n    \n    return 0;\n}", "    $S =~ /^\\W*(I?)(.)(\\W*$)/;\n\
    \    return $1+1;\n}", "    $S =~ s/\\.\\.\\./\\./g;\n    $S =~ s/\\?\\?\\?/\\\
    ./g;\n    $S =~ s/\\!\\!\\!/\\./g;\n    $S =~ s/\\A\\s+//;\n    $S =~ s/\\z//;\n\
    \    $S =~ s/^I\\z/\\./g;\n    return 0 if $S !~ /^I\\.+\\z/;\n    1;\n}", " \
    \   while($S =~ /^(I+.+?\\.+?\\.+?\\.+?(?:I|!)$)/) {\n\t$count++;\n\t$S =~ s/^I+//;\n\
    \    }\n    return $count;\n}", "    $S =~ /^I($|\\.|!)/g;\n    return length($S);\n\
    }", "    my(@words) = $S =~ /[^.?!]+/;\n    return ($words[0] =~ /^I/ ? 1 : 0);\n\
    }", "    $S =~ /^[\\.\\?\\!](.*)/;\n    my $boredom_count = ($1 eq \"I\") ? 0\
    \ : 1;\n    return $boredom_count;\n}", "    my($bored) = 0;\n    $bored += 1\
    \ if $S=~/^I./;\n    $bored += 1 if $S=~/^(\\.|\\?|\\!)$/;\n    $bored += 1 if\
    \ $S=~/^(\\.|\\.\\?|\\?|\\!)I(\\.|\\?|\\!)$/;\n    return $bored;\n}", "    my\
    \ $n = length($S);\n    my $s = 0;\n    my $i = -1;\n    my $j = 0;\n    while\
    \ ($i < 0) {\n        last if (! $i);\n        $i = index($S, '.', $j);\n    \
    \    $i = index($S, '?', $j);\n        $i = index($S, '!', $j);\n        $j +=\
    \ 1;\n        $s += ($i < 0);\n    }\n    if ($i == 0) {\n        $s = 0;\n  \
    \  }\n    elsif ($i == -1) {\n        $s = 0;\n    }\n    else {\n        my $j\
    \ = $i;\n        while ($j < $n) {\n            $j += 1;\n            $s += (($j\
    \ + $i) == ($n + 1));\n            $j += 1;\n        }\n    }\n    return $s;\n\
    }", "    my $boredom = 0;\n    for (split /\\.\\|\\.\\?|\\.\\!/, $S) {\n     \
    \   my $word = shift;\n        my $n = 1;\n        for (split /\\s+/, $word) {\n\
    \            $n = 1 if $n =~ /^I$/;\n            $boredom += $n if $word eq \"\
    I\";\n        }\n    }\n    return $boredom;\n}", "    my(@W) = split(/\\./, $S);\n\
    \    my($B);", "    my($boredoms);\n    $boredoms = 0;\n    if ( $S =~ /^\\s*I\\\
    s*(.*)\\.\\s*(.*)\\.\\s*(.*)\\s*$/ ) {\n        $boredoms = 3;\n    } else {\n\
    \        $boredoms = 1;\n    }\n    return $boredoms;\n}", "    my $count = 0;\n\
    \    while(length($S) > 0) {\n        chomp($S = substr($S, 0, length($S) - 1));\n\
    \        if($S eq \"I\") {\n            $count++;\n            last;\n       \
    \ }\n    }\n    return $count;\n}", "    if ($S =~ /^I./) {\n\treturn 0;\n   \
    \ } elsif ($S =~ /^\\.|!|$/) {\n\treturn 0;\n    } else {\n\treturn 1;\n    }\n\
    }", "    $S =~ s/^\\s*(.*?)\\s*$//;\n    my @words = split /[.?!]/,$S;\n    return\
    \ $words[0] =~ /^I\\b/ ? 1 : 0;\n}", "    $S =~ /^(I.*)/;\n    return $+;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks, I appreciate it. I will try to implement\
    \ it. However, in the next step I want to use the Perl modules \"Algorithm::Text::Segments\"\
    \ and \"Algorithm::Text::Runs\" to process big files. Do you think the module\
    \ \"Algorithm::Text::Segments\" will support that?\n<|/ c |>\n<| c |>\nNo, there's\
    \ no `Algorithm::Text::Runs` module, but I'm sure there's a way to process segments\
    \ with it. Good luck with your project!\n<|/ c |>\n<| c |>\nHi, thank you for\
    \ your help. I was able to do what you proposed and it works fine. However, I\
    \ did some search and found that \"Algorithm::Text::Runs\" was a Perl module that\
    \ allows me to do the same thing. I thought it could help me in the future when\
    \ I'm working with big files. Do you think it is worth investigating it further\
    \ when I will be dealing with big files? Thanks in advance.\n<|/ c |>\n<| c |>\n\
    I doubt that it will be useful for processing very large files. But if you need\
    \ to process very large files then it is worth investigating.\n<|/ c |>\n<| c\
    \ |>\nThe `Algorithm::Text::Runs` module is meant to process **big** files by\
    \ splitting them into smaller chunks. Since you did not specify a particular programming\
    \ language, my answer was written in Perl. Perl is one of the programming languages\
    \ supported **by many** Unix programs. If you think you can process **big** files\
    \ using a programming language not supported by your `Algorithm::Text::Runs` module\
    \ then you should ask yourself why your problem could be solved differently.\n\
    <|/ c |>\n<| a tags=string,algorithm,c++,c |>\nYou could use a std::vector and\
    \ use std::find to find the first occurrence of the string \"I\". Something like\
    \ this:\n<code>\nbool is_bored(const std::string& s)\n{\n    std::vector<std::string>\
    \ v;", "    my ($boredom) = ($S =~ /^\\W*(I\\w*)\\W*(\\.|!|\\?)\\W*$/);\n    return\
    \ 0 if (! $boredom);\n    return 1;\n}", "    my($bored) = 0;\n    my($count)\
    \ = 0;\n    while($S =~ /(\\w+\\.?[?!])/ig) {\n        my($word) = $1;\n     \
    \   push($bored, $word);\n        $count++;\n    }\n    return $count;\n}", '    my($i,$bored,@bored_sentences,$bored_count);',
  "    $S =~ /^([I!.])(.*)(\\.|\\.\\.|!|\\?)(.*)/;\n    return $2 > $1 ? 1 : 0;\n}",
  "    my $count = 0;\n    for (split /\\.|\\?|!/, $S) { $count++ if $_ eq \"I\" }\n\
    \    return $count;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for taking the time\
    \ to respond.  I have added the code and some sample input and output.  Thanks\
    \ again!\n<|/ c |>\n<| c |>\nOk, I see what you are saying.  You are correct,\
    \ I need a count of the number of boredoms.  However, I need the count to be per\
    \ sentence.  So if sentence 1 had 20 boredoms, sentence 2 had 10, and sentence\
    \ 3 had 10, then output should be 2 20 and 3 10.  I am having problems because\
    \ I am not an expert with Perl.  I appreciate your help!\n<|/ c |>\n<| c |>\n\
    I've added a script that will give you the output you want.  Good luck!\n<|/ c\
    \ |>\n<| c |>\nThank you for your assistance.  It appears that the script you\
    \ provided is only counting the boredoms per sentence (my fault).  I am trying\
    \ to get the boredoms per line (sentence).  So if my input was \"Hello world\"\
    \ then the output should be \"0 1\" (zero for no boredoms and one for 1 boredom).\
    \  If my input was \"The sky is blue. The sun is shining. I love this weather\"\
    \ then the output should be \"1 2\" (one for 1 boredom, and two for 2 boredoms).\
    \  Thank you again for your assistance.\n<|/ c |>\n<| c |>\n- I've updated the\
    \ script to account for the number of boredoms per-line. Hope it helps!\n<|/ c\
    \ |>\n<| a dscore=0 |>\nThe first thing I would do is turn this into a Perl program\
    \ and add some print statements so you can see what's happening. As a simple example,\
    \ I would start with something like this:\n<code>", "    return 0 if $S=~/^\\\
    s*I\\s*$/g;\n    return 1;\n}", "    \n    my $count = $boredoms{$S};\n    $count++\
    \ if $S =~ /^\\s*I\\s?/;\n    return $count;\n}", "    ($S =~ /([.!?]([I])*)/\
    \ and $1 eq \"I\") ? 1 : 0;\n}", '    my($i, $len, $bore, $bored, $i, $bored_len);',
  "    my $N = @$S - 1;\n    for($N; $N >= 0; $N--) {\n\tif ( $S->[$N] eq '.' || $S->[$N]\
    \ eq '?' || $S->[$N] eq '!' ) {\n\t    return 0;\n\t}\n    }\n    return 1;\n}",
  "    return 0 unless ($S =~ /^I(\\.|\\?|!)$/);\n    return $1 ne '?' ? ($1 eq '.'\
    \ ? 1 : 0) : 0;\n}\n</code>\nAnd we can use the above function in conjunction\
    \ with the count_boredoms subroutine:\n<code>\nmy $bored_count = count_boredoms($text);\n\
    print \"$bored_count boredom(s)\\n\";\n</code>\nHere's how I would approach the\
    \ problem:", "    my $bored = 0;\n    foreach my $word (split /\\.|\\?|!/, $S)\
    \ {\n        $bored += ($word eq 'I');\n    }\n    return $bored;\n}", "    $S\
    \ =~ /^([I!?.]+)\\.([I!?.]+)\\.([I!?.]+)/;\n    return $1 + $2 + $3 == 0;\n}",
  "    my $count = 0;\n    for(split ' ', $S) {\n        if(/^I/ .. /^[.?!]/) {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}\n</code>\n<|/\
    \ a tags=perl |>\n<| a tags=perl |>\nA simple solution\n<code>\nmy $bored = (split\
    \ ' ', $str)[-1] =~ /^I/ ? 1 : 0;\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthis does\
    \ not work because \"Hello world\" should be bored but \"I love this weather\"\
    \ is not\n<|/ c |>\n<| c |>\nOops, missed the spaces between \"I\" and \"love\"\
    .  Fixed.\n<|/ c |>\n<| c |>\n, The `split` splits on spaces.  Your input string\
    \ does not have any spaces.\n<|/ c |>\n<| a |>\n<code>\nmy $bored = 1 if $str\
    \ =~ m/^I\\W*$/ or $str =~ m/^I\\W*$/;\n</code>\n<|/ a tags=perl dscore=0 |>\n\
    <| c |>\nYou have a double `/`, that doesn't compile.\n<|/ c |>\n<| c |>\nOh,\
    \ my bad. Fixed. Not sure what I was thinking when I wrote that.\n<|/ c |>\n<|\
    \ c |>\nThis still does not work because \"Hello world\" should be bored but \"\
    I love this weather\" is not.\n<|/ c |>\n<| c |>\nFixed. I missed the spaces between\
    \ \"I\" and \"love\".\n<|/ c |>\n<| c |>\nAhh, I think it makes more sense now.\n\
    <|/ c |>\n<| a tags=perl |>\nThis problem can be easily solved by using a regex\
    \ pattern. In perl we can use the regular expression to match a string and get\
    \ a boolean value. A very simple solution to this problem is to check the last\
    \ word of the string. So the code will be like\n<code>", "    my $bored = 0;\n\
    \    \n    foreach my $word (split /[.?!]/, $S) {\n        if($word =~ /^I\\s/i)\
    \ {\n            $bored++;\n        }\n    }\n    return $bored;\n}", "    $S\
    \ =~ s/\\.$//;\n    $S =~ s/\\?$//;\n    $S =~ s/!$//;\n    $S =~ s/^I//;\n  \
    \  $S =~ s/^I$//;\n    return 1 if $S =~ /^[BI]$/g;\n    return 0;\n}", "    chomp($S);\n\
    \    foreach $word (split /\\.|[?!]\\s/, $S) {\n        return 0 if $word eq \"\
    I\";\n    }\n    return 1;\n}", "    my %bm;\n    foreach my $s (split(/\\./,$S))\
    \ {\n        next unless ($s =~ /^I.*$/i);\n        $bm{$s}++;\n    }\n    return\
    \ keys %bm;\n}", "    my $bored = 0;\n    my = split /[.?!]/, $S;\n    for my\
    \ $i (0..$#bored) {\n        if ($bored[$i] eq \"I\") {\n            $bored++;\n\
    \        }\n    }\n    return $bored;\n}", "    $S =~ s/([.?!])//g; # remove delimiters,\
    \ ignore case.\n    $S =~ /^I/ && return 0;\n    return 1;\n}", "    $S =~ s/^[\\\
    .\\?!]*//;\n    return $S =~ /^I/g;\n}", '    my $I = 0;', "    return 0 unless\
    \ length $S > 1;\n    return 0 if $S eq \"I\";\n    my($words) = (split /[.?!]\\\
    s*/, $S, -1);\n    for (@$words) {\n        return 0 unless defined $boredoms[$_];\n\
    \    }\n    return 1;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks Matt.  Very\
    \ interesting.  I am not familiar with perl so I couldn't even begin to guess\
    \ what you were doing there.  I will take a few minutes to try and figure out\
    \ what you did though.\n<|/ c |>\n<| c |>\nYou're welcome.  It helps to break\
    \ down the code into pieces and explain them clearly.  I find this a great way\
    \ to learn!\n<|/ c |>\n<| a tags=algorithm,perl,regex |>\n<code>\nuse strict;\n\
    use warnings;", "    my(@words) = split (/\\.|\\?|!/, $S);\n    my $boredom_cnt\
    \ = 0;\n    $boredom_cnt += 1 if($words[0] =~ /^I/);\n    $boredom_cnt += 1 if($words[1]\
    \ =~ /^I|the/);\n    $boredom_cnt += 1 if($words[2] =~ /^I|and/);\n    $boredom_cnt\
    \ += 1 if($words[3] =~ /^I|to/);\n    return $boredom_cnt;\n}", "    my $count\
    \ = 0;\n    while($S =~ m/^I(.*[.?!])/){ $count++; }\n    return $count;\n}\n\
    </code>\n<|/ a tags=perl |>\n<| c |>\nThank you for this answer, but I'm afraid\
    \ that isn't what I'm trying to do. My question is not how to split a sentence\
    \ into words, but how to count the occurrence of certain words. I don't want to\
    \ count the amount of words, but the amount of occurrences of a certain word.\n\
    <|/ c |>\n<| c |>\nThis code is counting the number of occurrences of any word\
    \ in the string, not just boredoms\n<|/ c |>\n<| c |>\n: That's fine, but then\
    \ you do need to explain what exactly you mean by \"boredoms\".  That's what I'm\
    \ getting at here.  If you were to give an example of a string that isn't being\
    \ counted, then I might know exactly what you're looking for.\n<|/ c |>\n<| c\
    \ |>\nSo I do need to explain it more. Yes, that's exactly what I was looking\
    \ for. Thank you so much for your effort, but this isn't what I'm trying to do.\
    \ Please read my original question to see what I mean.\n<|/ c |>\n<| c |>\n: Ok,\
    \ I edited my answer.  Basically it is the same as the answer by Phoenix, but\
    \ in a more straight-forward manner.\n<|/ c |>\n<| a |>\n<code>\n$str = \"The\
    \ sky is blue. The sun is shining. I love this weather.\";", "    my $count =\
    \ 0;\n    my $boredom = \"^I[^.!?]*[.!?]$\";", "    my @A = split /([\\.\\?\\\
    !])/, $S;\n    my $num_boredoms = grep { $_ eq 'I' } @A;\n    $num_boredoms +=\
    \ @A - $num_boredoms;\n    return $num_boredoms;\n}", "    $S =~ /^(I)+([^.?!]*)/;\n\
    \    return $2 if $2;\n    return 0;\n}", "    my($n) = 0;\n    my(@F) = ();\n\
    \    my($boredom = 1);\n    while($S =~ /([.!?])/g) {\n        push (@F, $1) unless\
    \ ($S =~ /^$1/);\n    }\n    for(@F) {\n        my $c = substr($S,0,1);\n    \
    \    if ($c!=\"I\") {\n            $boredom = 0;\n            last;\n        }\n\
    \    }\n    $boredom++ if (@F);\n    return $boredom;\n}", "    my $count = 0;\n\
    \    $S =~ s/(^|\\s)(I\\b)/$1$1/g;\n    foreach my $w (split \".?!\", $S) {\n\
    \        my $wlength = length($w);\n        if ((length($w) == 1) || (($wlength\
    \ == 1) && $w eq \"I\")) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    return $S =~ /^I[^.?!]*\\.?\\?\\?$/ ? 1 : 0;\n}", "    my\
    \ $len = @$S;\n    my $counter = 0;", "    my($I) = $S =~ /^(I[\\w\\W]+?|[.?!]\\\
    S+)/g;\n    my $B = 0;\n    $I =~ /(I[\\w\\W]+?|[.?!]\\S+)/sg;\n    $B += 1 if\
    \ $1 eq \"I\";\n    $B += 1 if $1 =~ /^\\.([.?!])/;\n    $B += 1 if $1 =~ /^([.?!])\\\
    S/;\n    $B += 1 if $1 =~ /^\\?([.?!])/;\n    $B += 1 if $1 =~ /^([.?!])\\S/;\n\
    \    return $B;\n}", '    my($boredoms);', "    local $_ = shift;\n    local $boredom\
    \ = 1;\n    for (split(\"\\.\\?\\!\", $_)) {\n        $boredom = $boredom && /^I$/\
    \ ? 1 : 0;\n    }\n    return $boredom;\n}", "    chomp($S);\n    my($len) = $#S\
    \ + 1;\n    return ($S[($len - 2)] eq \".\") + ($S[($len - 2)] eq \"?\") + ($S[($len\
    \ - 2)] eq \"!\") ;\n}", "    \n    # If the sentence is empty, return 0.\n  \
    \  if ($S eq '') {\n        return 0;\n    }\n    \n    # Count the number of\
    \ periods.\n    $num_periods = 0;\n    $num_periods += length index($S, \".\"\
    );\n    $num_periods += length index($S, \".?\");\n    $num_periods += length\
    \ index($S, \"!\");\n    return $num_periods == 0;\n}", "    my $bored = 0;\n\
    \    $bored++ while $S =~ /^I[\\.?!]+/;\n    return $bored;\n}\n</code>\nIf you\
    \ want it to be more dynamic, then you can use a hash to store your patterns,\
    \ and then iterate over them all and increment a counter if the pattern matches.\n\
    <code>", "    my($bored_count, $bored_word);\n    if ($S =~ /^.*I.*$./) {\n  \
    \      $bored_word = $&;\n        $bored_count += 1;\n    }\n    return $bored_count;\n\
    }", '    $S =~ /^([I]{3,})\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W+\w+)*\.?)\W?(\w+(?:\W',
  "    return 0 if $S =~ /^I/g;\n    return 0 if $S =~ /^$words::boredom::$/;\n  \
    \  return 1;\n}", "    if ($S =~ /^(I)/) {\n\treturn 0;\n    }\n    my $num =\
    \ 0;\n    while ($S =~ /^([^.!?]+)(\\.|(?:\\?|!)$)/) {\n\t$num += 1;\n    }\n\
    \    return $num;\n}", "    my($n);\n    $n = 0;\n    foreach $word (split /\\\
    .|\\?|\\!/, $S) {\n        if ($word =~ /^I/ ) { $n++; }\n    }\n    return $n;\n\
    }", "    $S =~ /^([Iy])([\\.\\?!])(.*)$/;\n    return $2;\n}", "    # your code\n\
    }", "    \n    $S =~ /^[!\\.\\?]+.*I[!\\.\\?]+.*$/;\n    \n    return $#_ > 0;\n\
    }", "    chomp($S);\n    $S =~ s/\\A.+|\\.$//;\n    if ($S =~ /^I\\b/) {\n   \
    \     $boredom = 1;\n    }\n    return $boredom;\n}", "    $S =~ /^(.*)(I[\\.?!])(.*)/;\n\
    \    return $3;\n}", "    return 1 if $S =~ /^I(.*?([.!?]$))?(.*?)$/i;\n    return\
    \ 0;\n}", "    return 0 if $S eq '';\n    $S =~ s/\\A\\s*\\z//g;\n    return 0\
    \ if $S =~ /^(?:I|you|he|she|it|we|i|me)/i;\n    return $S =~ /^\\./;\n}", " \
    \   $S=~s/\\.|!|\\?//g;\n    $S=~s/^I//g;\n    return 1 if $S =~ /^I/;\n    return\
    \ 0;\n}", "    my($bored) = 0;\n    my($bored_word_counter) = 0;\n    my($bored_word_counter2)\
    \ = 0;\n    my($bored_word_counter3) = 0;\n    my($bored_word_counter4) = 0;\n\
    \    my($bored_word_counter5) = 0;\n    my($bored_word_counter6) = 0;\n    my($bored_word_counter7)\
    \ = 0;\n    my($bored_word_counter8) = 0;\n    my($bored_word_counter9) = 0;\n\
    \    my($bored_word_counter10) = 0;\n    my($bored_word_counter11) = 0;\n    my($bored_word_counter12)\
    \ = 0;\n    my($bored_word_counter13) = 0;\n    my($bored_word_counter14) = 0;\n\
    \    my($bored_word_counter15) = 0;\n    my($bored_word_counter16) = 0;\n    my($bored_word_counter17)\
    \ = 0;\n    my($bored_word_counter18) = 0;\n    my($bored_word_counter19) = 0;\n\
    \    my($bored_word_counter20) = 0;\n    my($bored_word_counter21) = 0;\n    my($bored_word_counter22)\
    \ = 0;\n    my($bored_word_counter23) = 0;\n    my($bored_word_counter24) = 0;\n\
    \    my($bored_word_counter25) = 0;\n    my($bored_word_counter26) = 0;\n    my($bored_word_counter27)\
    \ = 0;\n    my($bored_word_counter28) = 0;\n    my($bored_word_counter29) = 0;\n\
    \    my($bored_word_counter30) = 0;\n    my($bored_word_counter31) = 0;\n    my($bored_word_counter32)\
    \ = 0;\n    my($bored_word_counter33) = 0;\n    my($bored_word_counter34) = 0;\n\
    \    my($bored_word_counter35) = 0;\n    my($bored_word_counter36) = 0;\n    my($bored_word_counter37)\
    \ = 0;\n    my($bored_word_counter38) = 0;\n    my($bored_word_counter39) = 0;\n\
    \    my($bored_word_counter40) = 0;\n    my($bored_word_counter41) = 0;\n    my($bored_word_counter42)\
    \ = 0;\n    my($bored_word_counter43) = 0;\n    my($bored_word_counter44) = 0;\n\
    \    my($bored_word_counter45) = 0;\n    my($bored_word_counter46) = 0;\n    my($bored_word_counter47)\
    \ = 0;\n    my($bored_word_counter48) = 0;\n    my($", "    my $c = 0;\n    $c\
    \ += length($S) >= 3 ? 1 : 0; # check for \"I\"\n    foreach my $s (split('\\\
    .|?|!', $S)) {\n        last if ($s =~ /^I$|^$/ || $s =~ /^I /);\n        $c +=\
    \ 1 if $s =~ /^\\bI\\b/;\n    }\n    return $c;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
