name: HumanEval_65_circular_shift
language: pl
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12, 2)\n\
  # \"12\"\nsub circular_shift {\n    my($x, $shift) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&circular_shift;\n\
  \        if(eq_deeply($candidate->(100, 2),\"001\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 2),\"12\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(97,\
  \ 8),\"79\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n    \
  \    if(eq_deeply($candidate->(12, 1),\"21\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(11, 101),\"11\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return reverse $_ if $shift > @_;\n    my $str = int2str($x);\n\
    \    if ($shift > length($str)) {\n        my @digits = split(//, $str);\n   \
    \     splice (@digits, $shift, 0, @digits[0..($shift-1)]);\n        $str = join(\"\
    \", @digits);\n    }\n    return $str;\n}", '    my($result);', "    my($digit,\
    \ $carry);\n    my($i, $ret);\n    my($n);\n    if ($shift > length($x)) {\n \
    \       $ret = \"\";\n    } else {\n        $n = length($x);\n        $carry =\
    \ 0;\n        for ($i = 0; $i < $shift; $i++) {\n            $digit = $x[$i] >>\
    \ $shift & 1;\n            $carry = $digit * 2;\n            $ret .= $digit +\
    \ $carry;\n        }\n        if ($shift > $n) {\n            $ret .= substr($x,\
    \ $shift - $n, $n);\n        } else {\n            $ret .= substr($x, 0, $shift);\n\
    \        }\n    }\n    return $ret;\n}", "    my(@result) = (0);\n    for (my\
    \ $i = $shift; $i >= 0; $i--)\n    {\n        push(@result, $x % 10);\n      \
    \  $x = int($x/10);\n    }\n    for (my $i = $shift; $i >= 0; $i--)\n    {\n \
    \       push(@result, $x % 10);\n        $x = int($x/10);\n    }\n    shift(@result);\n\
    \    return join('', @result);\n}", '    $shift -= length($x);', "    if ($shift\
    \ > length($x)) {\n        $x = reverse $x;\n        $shift -= length($x);\n \
    \   }\n    return substr($x, 0, $shift) . substr($x, $shift);\n}", "    $shift\
    \ ||= 0;\n    $shift -= length($x); # Shift number to the right\n    return substr($x,\
    \ 0, $shift) . substr($x, $shift); # Circularly shift\n}", "    my $digits = substr($x,\
    \ $shift);\n    return substr($x, 0, $shift) . $digits;\n}", "    $shift += int(log($x,\
    \ 10));\n    my $str = $x >> $shift;\n    my $str2 = $x & ((1 << $shift) - 1);\n\
    \    return $str2 + $str;\n}", "    my $digits = $x % 10; $x /= $10;\n    my $result\
    \ = $x << $shift;\n    $result %= 10;\n    return $result . $digits;\n}\n</code>\n\
    <|/ a tags=algorithm,perl,modulus |>\n<| a tags=algorithm,perl,modulus dscore=0\
    \ |>\n<code>", "    my $digits = $x;\n    my $shifted = $x >> $shift;\n    my\
    \ $reversed = $x ^ $shifted;\n    return $digits < $shift ? $reversed.($shifted\
    \ << $shift) : $reversed;\n}", '    my $s = $shift;', "    $shift -= $x->{sign}\
    \ if $x->{sign};\n    $shift += $x->{sign};\n    my $a = $x;\n    my $b = @$a\
    \ < $shift ? @$a : 0;\n    my $bx = $b[$shift] || '0';\n    if ($shift > 0) {\n\
    \        splice(@$a, $shift);\n    } else {\n        @$a = ($shift < @$a ? $shift\
    \ : @$a) . $bx;\n    }\n    return join(\"\", @$a);\n}", "    my($result) = '';\n\
    \    # Do the circular shift in-place and return the new result\n    $x =~ m/^((?:\\\
    d*)\\d*)(\\d*)$/;\n    my $digits = $2;\n    my $mod = $1;\n    my $shift = $shift;\n\
    \    while ($shift >= $#digits) {\n\t$result .= $digits[$#digits];\n\t$shift -=\
    \ $#digits;\n    }\n    $result .= $digits[$shift];\n    $mod =~ s/\\Q$digits\\\
    E/\\Q$result\\E/;\n    return $mod;\n}", '    my($digits, $i) = ($x, 0);', " \
    \   my $s = $shift;\n    my @digits = split(//, $x, $s + 1);\n    my $i = 0;\n\
    \    my @result = ();\n    for(@digits) {\n        $result[$i] = $_;\n       \
    \ $i++;\n        if($i > $s) {\n            $i--;\n        }\n    }\n    return\
    \ join('', @result);\n}", "    $shift ||= 0;\n    my($ndigit, $rdigit, $ddigit);\n\
    \    # First get all the digits in the number in a list\n    my($digits, $sign)\
    \ = (0, 1);\n    while (1) {\n        ($rdigit, $ddigit) = split $x, $digits;\n\
    \        if ($rdigit == 0) {\n            ($ndigit, $digits) = split $x, $sign;\n\
    \            last;\n        }\n        else {\n            if ($shift > 0) {\n\
    \                ++$shift;\n            }\n            elsif ($shift < 0) {\n\
    \                --$shift;\n            }\n            push @$digits, $ddigit;\n\
    \        }\n    }\n    return join('', @$digits);\n}", "    $shift ||= 0;\n  \
    \  my $len = length($x);\n    if ($shift > $len) {\n        $x =~ tr/./0123456789abcdefghijklmnopqrstuvwxyz/;\n\
    \        return $x;\n    }\n    $len = $shift + 1;\n    my $r = substr($x, 0,\
    \ $len);\n    my $i;\n    for ($i = $shift; $i < $len; $i++) {\n        my $pos\
    \ = $len - $i;\n        $r->[$pos] = $x->[$i];\n    }\n    return $r;\n}", " \
    \   my($result, $i, $j);\n    my(@digits) = ($x =~ /(\\d+)/); # split the integer\
    \ into digits\n    $shift %= @digits;\n    for(my $i = 0; $i < @digits; $i++)\
    \ {\n        $i = $i + $shift;\n        if($i > $#digits) {\n            $i =\
    \ $i - $#digits;\n        }\n        $result = $result . $digits[$i];\n    }\n\
    \    $result =~ tr/0-9//cd;\n    return $result;\n}", "    $x =~ tr/0123456789//d;\n\
    \    if ($shift < 0) {\n\t$x =~ tr/90abcdefghijklmnopqrstuvwxyz/0123456789abcdefghijklmnopqrstuvwxyz/d;\n\
    \t$x =~ tr/1234567890//d;\n\t$x =~ tr/abcdefghijklmnopqrstuvwxyz/0123456789abcdefghijklmnopqrstuvwxyz/d;\n\
    \    }\n    $x = $x x $shift;\n    $x =~ s/(.*\\D)0+($shift)$/$1$shift/eg;\n \
    \   return $x;\n}", "    my @digits = split(//, str($x));\n    my $shifted = shift(@digits,\
    \ $shift);\n    if ($shift == 0 && @digits != 0) {\n        splice(@digits, 0,\
    \ @digits);\n    }\n    return join(\"\", @digits) unless @digits == 0;\n    return\
    \ $shifted unless @digits == 1;\n    return $digits[@digits - 1] . circular_shift($shifted,\
    \ 1);\n}", "    my(@digits) = split(//,$x);\n    my($ret) = $digits[0];\n    for\
    \ (my $i = 1; $i < $shift; $i++) {\n        $ret .= $digits[$i];\n    }\n    return\
    \ $ret;\n}", "    my @digits = reverse $x;\n    for (my $i = 0; $i < $shift; $i++)\
    \ {\n\t$digits[$i] = $digits[$i + $shift];\n    }\n    return join('', @digits);\n\
    }", "    if ($shift > 0) {\n        # $x = ((($x >> $shift) & $mask) + $mask)\
    \ & $mask;\n        $x = ((($x >> $shift) & $mask) + $mask) & $mask;\n    }\n\
    \    elsif ($shift < 0) {\n        # $x = ((($x >> -$shift) & $mask) - $mask)\
    \ & $mask;\n        $x = ((($x >> -$shift) & $mask) - $mask) & $mask;\n    }\n\
    \    else {\n        $x &= $mask;\n    }\n    return $x;\n}", "    my $digits\
    \ = substr($x, 0, $shift);\n    $digits .= substr($x, $shift);\n    return $digits;\n\
    }", "    if ($shift > length($x)) {\n\t$x =~ tr/[a-z]/[A-Z]/;\n\t$x =~ tr/A-Z/a-z/;\n\
    \    }\n    return substr($x, 0, $shift);\n}", "    $shift %= $#$x;\n    ($shift\
    \ > $#$x ? reverse $x : $x) ~ substr($x, $shift, 1);\n}\n</code>\nA few things\
    \ to note about this implementation:", '    my $digits = $shift;', "    my($ret,\
    \ $i);\n    $i = $x;", "    my($digits) = length($x);\n    my($rval) =\"\";\n\
    \    my($i, $n);\n    for ($i = 0; $i <= $digits; $i++) {\n        $n = $i >>\
    \ $shift;\n        $rval = $digits[$i] . $rval if ($n != 0);\n        $rval =~\
    \ s/^$digits[$i]/${$digits[$i + $shift]}/g;\n    }\n    return $rval;\n}", " \
    \   my $digits;\n    my $length = length($x);\n    # $shift can be negative or\
    \ positive\n    if ($shift > 0) {\n        # Count how many digits are in the\
    \ number\n        $digits = $shift % $length;\n        # Shift digits left (right\
    \ justified) by $shift positions.\n        # E.g. 12 is shifted two positions\
    \ to the left\n        # >>> 12 % 12\n        # 6\n        # >>> 12 << 2\n   \
    \     # 512\n        # >>> 12 * 2 << 2\n        # 512\n        # >>> 12 >> 2\n\
    \        # 6\n        # >>> 12 >> 3\n        # 12\n        # >>> 12 << 3\n   \
    \     # 128\n        $x .= (~0 << $digits) x $length;\n        # Circularly shift\
    \ the digits right by shift places\n    } else {\n        # Count the digits right\
    \ by shift places\n        $digits = $length - $shift;\n        # Shift digits\
    \ right (left justified) by $shift positions.\n        # E.g. 12 is shifted two\
    \ positions to the right\n        # >>> 12 % 12\n        # 0\n        # >>> 12\
    \ << 2\n        # 4096\n        # >>> 12 * 2 << 2\n        # 4096\n        # >>>\
    \ 12 >> 2\n        # 0\n        # >>> 12 >> 3\n        # 12\n        # >>> 12\
    \ << 3\n        # 128\n        $x = (~0 >> $digits) x $length;\n    }\n    # Return\
    \ digits reversed\n    return reverse $x;\n}", "    my @digits = $x / $shift;\n\
    \    my @digits_reversed;\n    if ($shift == 0) {\n        $digits_reversed =\
    \ reverse @digits;\n    } else {\n        my $shift2 = $shift / 2;\n        while\
    \ (@digits >= $shift2) {\n            my $remainder = shift @digits;\n       \
    \     $digits_reversed .= $remainder;\n        }\n        my @remainder = @digits;\n\
    \        $digits_reversed .= $remainder[-1] if @digits > $shift;\n    }\n    return\
    \ join \"\", (reverse @digits_reversed);\n}", "    my($digits, $string);\n   \
    \ my ($last, $first) = (0, 0);\n    local $_ = shift;\n    # shift digits to the\
    \ right until they fit in the number of digits\n    while ($shift > length($_))\
    \ {\n        ($shift -= length($_), $last, $first) = @{$_};\n    }\n    # Shift\
    \ digits one by one from left to right\n    foreach $digit (split(//, $_)) {\n\
    \        $string .= substr($digit, $first, $last-$first+1);\n    }\n    if ($shift\
    \ < 0) {\n        return reverse $string;\n    }\n    return $string;\n}", '    my($ret);',
  "    my(@digits) = split(//, sprintf(\"%0*d\", $shift, $x));\n    shift(@digits);\n\
    \    return join(\"\",);\n}", "    my(@result) = reverse reverse split(//, sprintf(\"\
    %0${shift}d\", $x));\n    return join('', @result);\n}", "    return $x if $shift\
    \ > $#_;\n    my @digits = split //, to_base($x);\n    my @result = ();\n    my\
    \ $i;\n    for ($i = 0; $i <= $shift; $i++) {\n        my $tmp = pop(@digits);\n\
    \        push(@result, $tmp);\n    }\n    return join(\"\", @result);\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\n<code>", "    $shift ||= 0;\n    my $n = $x;\n   \
    \ $n -= ($shift % $n) if ($shift > 0);\n    ($shift -= $n % $shift) =~ tr/0/9/;\n\
    \    return $n;\n}", "    $x -= $x % $shift;\n    $shift--;\n    while ($shift\
    \ > 0) {\n        $x *= 10;\n        $x /= $shift;\n        $shift--;\n    }\n\
    \    return $x;\n}", "    if (! defined $shift) {\n        $shift = 0;\n    }\n\
    \    if ($shift > length($x)) {\n        $shift = (length($x) - 1);\n    }\n \
    \   my $xdigits = split(//, $x);\n    $xdigits[$shift] = '';\n    return join('',\
    \ $xdigits);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile the above code works,\
    \ this is very slow in comparison.  It takes about 0.001s to execute on the example\
    \ data given here.\n<|/ c |>\n<| a |>\n<code>\nmy $a = \"112233\";\nmy $b = $a;\n\
    $b =~ s/2/2/;\n$b =~ s/3/3/;\n$b =~ s/4/4/;\n$b =~ s/5/5/;\n$b =~ s/6/6/;\n$b\
    \ =~ s/7/7/;\n$b =~ s/8/8/;\n$b =~ s/9/9/;\n$b =~ s/1/1/;", "    if ($shift >\
    \ $#_) {\n\t# Use reverse() to avoid excess copying.\n\treturn join('', reverse\
    \ @_);\n    }\n    my $digits = ($shift + $#_) % $#_;\n    my $result = substr($_[0],\
    \ 0, $digits + 1);\n    for (my $i = 0; $i < $digits; $i++) {\n\t$result .= substr($_[0],\
    \ $i, 1);\n    }\n    return $result;\n}", "    my $n = int($x/$shift);\n    my\
    \ $remainder = int($x%$shift);\n    if ($n < 1) {\n        $remainder *= $shift;\n\
    \        $remainder += $n;\n        $remainder %= 1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += $remainder/1000000;\n\
    \        $remainder = $remainder%1000000;\n        $n += ", "    my @digits =\
    \ reverse ( (split //,$x) ); # reverse the digits\n    my $ndigits = scalar (@digits);\n\
    \    if ($shift > $ndigits) {\n        return join '',\n            map { substr($digits[$_],-$shift+$_,$shift)\
    \ }\n                0 .. $ndigits - $shift\n            ;\n    }\n    return\
    \ join '',\n        map { substr($digits[$_],$shift,$shift) }\n            0 ..\
    \ $ndigits - $shift\n        ;\n}", "    my $n = @$x;\n    my $i = @$x - $shift;\n\
    \    my @a;\n    for (; $i >= 0; $i--) {\n        if ($shift > 0) {\n        \
    \    push @a, substr($x, $i + $shift, 1);\n            $shift--;\n        } else\
    \ {\n            push @a, substr($x, $i, 1);\n        }\n    }\n    my $s = join(\"\
    \", $a);\n    if ($n < @$x) {\n        $s =~ s/^(.{$n})$/$1/;\n    }\n    return\
    \ $s;\n}", "    my $length = length($x);\n    my $result;", "    return reverse\
    \ if $shift > length($x);\n    my($digits, $shift) = reverse @_;\n    my $digit;\n\
    \    my $result = $x;\n    for ($shift) {\n        $digit = substr($result, 0,\
    \ 1);\n        $result = substr($result, 1);\n        $digits =~ s/.*/$digit/;\n\
    \    }\n    return $result;\n}", "    my($digits, $digits_string) = ($x =~ /([0-9]+)/);\n\
    \    if ($shift == 0) {\n        return $digits_string;\n    }\n    if ($shift\
    \ > length($digits)) {\n        # shift > len(digits)\n        $digits_string\
    \ =~ tr/1//;\n        return $digits_string;\n    }\n    $digits_string =~ tr/1//;\n\
    \    while ($shift > 0) {\n        $digits_string =~ tr/1/$digits/;\n        $shift\
    \ -= length($digits);\n    }\n    return $digits_string;\n}", '    my($digits);',
  "    my($out); # Will be the output\n    my($i, $digits);\n    # Compute digits\
    \ string\n    $digits = $x;\n    while ($digits =~ s/(\\d+)(\\d\\d\\d)/ \"$1$2\"\
    ) if defined $digits;\n    $digits = $1 if $digits =~ s/(\\d\\d\\d)(\\d+)/$1/;\n\
    \    $digits = $1 if $digits =~ s/(\\d\\d\\d)//;\n    # Circulate the digits and\
    \ shift them to the left\n    for ($i = $shift; $i >= 0; $i--) {\n        $out\
    \ .= $digits[$i];\n    }\n    # Return digits reversed\n    $out =~ tr/0-9//cd;\n\
    \    return $out;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI'm still not sure\
    \ why you needed the second regex. Your regex will fail for the first example\
    \ `123456789`.\n<|/ c |>\n<| c |>\nIt will fail because the string `123456789`\
    \ is converted into a string of `1` followed by `3` followed by `2` followed by\
    \ `4` followed by `5` followed by `6` followed by `7` followed by `8` followed\
    \ by `9`. There is no way to know that the number `123456789` is really `123456789`\
    \ as opposed to `123...9`.\n<|/ c |>\n<| c |>\nSo what? It doesn't matter if the\
    \ string is converted into a string of 1 followed by 3 followed by 2 followed\
    \ by 4 followed by 5 followed by 6 followed by 7 followed by 8 followed by 9.\
    \ `123456789` and `123...9` will both work the same way.\n<|/ c |>\n<| c |>\n\
    No, your solution doesn't work for `123456789`. Try it. All you need is `123...9`.\
    \ `123456789` doesn't work.\n<|/ c |>\n<| c |>\nAhh okay, I see what you mean\
    \ now.\n<|/ c |>\n<| a tags=string,regex,perl |>\nHere's another way using a regular\
    \ expression and a hash\n<code>", "    my $digits = $x / $shift;\n    return $x\
    \ - ($digits * $shift);\n}", "    my($digit, $rd, $rs);\n    my($numdigits, $remainder);",
  "    my $str = ($x + $shift) % $base;\n    $str = $base + $str if $shift > $digits;\n\
    \    my $len = $shift % $digits;\n    return substr($str, -$len);\n}\n</code>\n\
    <|/ a tags=perl dscore=0 |>\n<| a dscore=0 |>\n<code>", "    my $s = $shift +\
    \ $#{ $x->{digits} };\n    if ($s > $#{ $x->{digits} }) {\n        $x->{digits}\
    \ = $_->{digits}[ reverse 0 .. $s - 1 ];\n        $x->{sign} = $_->{sign};\n \
    \       $x->{_digits} = $_->{_digits}[ reverse 0 .. $s - 1 ];\n    } else {\n\
    \        my $m = $s - $#{ $x->{digits} };\n        $x->{digits} = $_->{digits}[\
    \ reverse 0 .. $m ];\n        $x->{sign} = $_->{sign};\n        $x->{_digits}\
    \ = $_->{_digits}[ reverse 0 .. $m ];\n    }\n    return $x;\n}", "    my(@digits)\
    \ = split(//, $x);\n    $shift %= scalar(@digits);\n    for (my $i = scalar(@digits)-1;\
    \ $i >= 0; $i--) {\n        my $digit = $digits[$i];\n        $digits[$i] = $digits[$i]\
    \ . $digits[$i-$shift];\n        $digits[$i] = $digits[$i] % 10 + ($digit > 9\
    \ ? $digit - 10 : 0);\n    }\n    return join('', @digits);\n}", "    my $len\
    \ = length($x);\n    if ($shift > $len) {\n\t$x =~ tr/a-zA-Z//d;\n\t$len -= $shift;\n\
    \    } elsif ($shift < 0) {\n\t$len -= $shift;\n    }\n    my $i = 0;\n    my\
    \ $out = \"\";\n    while ($i < $len) {\n\t$out .= $x[$i] if ($i < $len - $shift\
    \ || $shift == 0);\n\t$out .= substr($x, $i + $shift, 1) if ($shift > 0);\n\t\
    $i += $shift;\n    }\n    return $out;\n}", "    my $reverse = ($shift > length($x));\n\
    \    my $s = '';\n    my $i = 0;\n    my $k = 0;\n    while ($i < length($x))\
    \ {\n        $k += 1;\n        my $n = ($k + $shift) % $shift;\n        $s = substr($x,\
    \ 0, $i) + substr($x, $n + 1, 1);\n        $i++;\n    }\n    if ($reverse) {\n\
    \        $s = reverse $s;\n    }\n    return $s;\n}\n</code>\n<|/ a dscore=4 tags=string,perl,algorithm\
    \ |>\n<| a |>\nIf you have your heart set on a string solution, the following\
    \ perl solution will do the trick:\n<code>", "    $shift ||= 0;\n    my $digits\
    \ = $x+$shift;\n    my $result = $digits % 10;\n    $digits /= 10;\n    for(1..$shift)\
    \ {\n        $digits = $digits/10;\n        $result = 10*$result + $digits;\n\
    \    }\n    return $result if $result+$shift > $digits;\n    $result =~ s/(.{$shift})$/$1/;\n\
    \    return $result;\n}", "    if (! defined $shift || ! defined $x) {\n     \
    \   $x  = 0;\n        $shift = 0;\n    }\n    my $num_digits = @$_[0] - 1;\n \
    \   $shift %= $num_digits;\n    my $str = $_[0]->to_str();\n    my $pos = 0;\n\
    \    for (my $i = $num_digits - 1; $i >= 0; $i--) {\n        $str =~ s#(.)#substr($1,0,$i+$shift+$pos)\
    \ . $1#e;\n        $pos += $num_digits;\n    }\n    return $str;\n}", "    my\
    \ $digits = $x/10;\n    return $x if $shift > $digits;\n    my($remainder, $shift)\
    \ = ($x % 10, $shift);\n    my $result = \"\";\n    while ($shift--) {\n\t$result\
    \ .= $digits[$remainder] if ($remainder != 0);\n\t$remainder = ($remainder * 10)\
    \ + $digits[$remainder];\n    }\n    return $result;\n}", "    return $x if $x\
    \ < 10;\n    if ($shift > $#{ $_[0] }) {\n        my(@digits) = reverse @{ $_[0]\
    \ };\n        shift(@digits, $shift);\n        return join(\"\", @digits);\n \
    \   }\n    my(@digits) = @{ $_[0] };\n    shift(@digits, $shift);\n    return\
    \ join(\"\", @digits);\n}", "    my($digits);\n    my $reverse = 0;", "    return\
    \ '' if $shift > $x;\n    my($remainder) = $x - $shift;\n    return $shift <=\
    \ $x ? $remainder : reverse $remainder;\n}\n</code>\n<|/ a tags=perl,math,algorithm\
    \ dscore=1 |>\n<| a tags=perl,math,algorithm |>\n<code>", "    my $string = $x;\n\
    \    my $digits = length($x);", "    $x -= ($shift*10**($shift-1));\n    $x =~\
    \ s/(\\d)(?=(\\d{3})+$)/$1 $shift/e;\n    return $x;\n}", "    my $xdigits = length\
    \ $x;\n    my $rv = $x;\n    my $digit = 0;\n    for my $i (0 .. $xdigits - 1)\
    \ {\n\t$digit += $i if ($xdigits == $i);\n\t$rv .= $x->[$i] if $i < ($xdigits\
    \ - $shift);\n\t$rv->[$i] =  $x->[$i] if $i > ($xdigits - $shift);\n    }\n  \
    \  $rv->[0] = substr ($rv->[0], 0, 1) if $shift > $xdigits;\n    return $rv;\n\
    }", "    my $result = '';\n    for (my $i = 0; $i < $shift; $i += 2) {\n     \
    \   $result .= substr($x, $i, 1);\n        $result .= substr($x, 0, $i);\n   \
    \ }\n    return $result;\n}", "    my @digits = (\"0\");\n    for ($x%10) {\n\
    \        $digits[$#digits] .= $x%10;\n        $x//= 10;\n    }\n    return join\
    \ \"\", map { $digits{$_} } reverse @digits[0..$#digits-$shift];\n}", '    my($ret);',
  "    my $s = \"\";\n    my $i = $shift;\n    my $n = length($x);\n    if ($i >=\
    \ $n) {\n        return $x if $n == 0;\n        return reverse $x;\n    }\n  \
    \  while (--$i >= 0) {\n        $s = (substr($x, $i, 1) + $s)[0];\n    }\n   \
    \ return $s;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is probably the best\
    \ answer, but it's unclear from your comment if you have already found it or if\
    \ the OP has figured it out already. Please edit your post to include the answer\
    \ you found.\n<|/ c |>\n<| c |>\nThis is an extremely bad answer. Not only does\
    \ it contain unnecessary copying of the data into an array, it is a poor solution.\
    \ Though it can get the job done, it does not even work for negative numbers.\
    \ The algorithm is very inefficient, and its only purpose is to get around an\
    \ inefficient algorithm. An easy way is to just do a bitwise shift on the number.\
    \ Nothing else is needed. I'll post a better answer soon\n<|/ c |>\n<| a tags=perl,numbers\
    \ dscore=1 |>\n<code>\nuse Math::BigInt;", "    my $n = @$_;\n    my $ret = \"\
    \";\n    if ($shift > $n) {\n        $shift = $n;\n    }\n    for (my $i = $shift\
    \ - 1; $i >= 0 && $i >= $n; $i--) {\n        $ret .= $_ unless $_ eq $x;\n   \
    \     $x >>= 1;\n    }\n    if ($x > 0) {\n        $ret .= $x;\n    }\n    $ret;\n\
    }", '    my @digits = split(//, $x);', "    my $s = $x->{_digits} or die \"Circular\
    \ shift called on non-numeric object\";\n    $shift %= $s->{_length};\n    return\
    \ reverse $s->substr(0, $shift) . substr($s->{_digits}-1, $shift+1);\n}", "  \
    \  my($sign) = $x <=> 0;\n    my $digits = Math::Parition::digits($x);\n    my\
    \ $shift_digits = Math::Parition::digits($shift);\n    $shift_digits += $shift\
    \ < $digits ? 1 : 0;\n    $sign = \" $sign \" if $sign;\n    $digits = $shift_digits\
    \ >= $digits ? $digits - $shift_digits : $shift_digits;\n    my $result = \"\"\
    ;\n    my $shift = 0;\n    for(my $i = 0; $i < $digits + 1; $i++) {\n        $shift\
    \ += $i;\n        $result .= ($shift % 10) * $x / ($shift / 10);\n        $shift\
    \ /= 10;\n    }\n    return $sign . $result;\n}", "    my $s = ''; my $i = 0;\n\
    \    while ($i < length($x)) {\n        $s = $x->[$i] if $i < $shift;\n      \
    \  $s = substr($x, 0, $i) + substr($x, $i, 1) if $i >= $shift;\n        $i++;\n\
    \    }\n    $s;\n}", "    my $s = '';\n    $shift %= length($x);\n    $shift ||=\
    \ length($x);\n    my $digits = length($x);\n    my $half_digits = ($digits /\
    \ 2);\n    while ($shift > $half_digits) {\n        $shift -= $half_digits;\n\
    \        $digits /= 2;\n    }\n    my $i;\n    for ($i = 0; $i < $shift; $i++)\
    \ {\n        $s .= substr($x, $i, 1);\n    }\n    for ($i = 0; $i < $half_digits;\
    \ $i++) {\n        $s .= substr($x, $digits, 1);\n    }\n    return $s;\n}", '    my(@digits)
    = ();', "    $shift %= $#$x;\n    $shift += $#$x if $shift > $#$x;\n    return\
    \ substr(''.$x, 0, $shift) . str_reverse substr(''.$x, $shift);\n}", "    $x %=\
    \ (10 ** length($_));\n    $shift++ if $shift > length($_);\n    my $xs = length($_)\
    \ > $shift ? @_ : reverse(@_);\n    return $xs;\n}", "    my($digits) = scalar\
    \ localtime();\n    $digits =~ s/.*\\([0-9]+\\)/$digits[$digits-$shift+$shift]/g;\n\
    \    return $digits;\n}", "    my $str = $x;\n    my $i;\n    for ($i = 0; $shift\
    \ && $i <  $str->length; $i++,\n            $shift--);\n    substr($str, $i, 0)\
    \ = reverse substr($str, $i, 0);\n    return $str;\n}", "    return join('', reverse\
    \ @_) if ($shift > @_);\n    return join('', map { substr($_, $shift) } @_);\n\
    }", "    if (! defined($shift)) {\n        $shift = 0;\n    }\n    my($str);\n\
    \    if ($shift > 0) {\n        $str = $x;\n    }\n    else {\n        my($remainder,\
    \ $digits) = divmod($x, 10);\n        if ($digits <= $shift) {\n            $str\
    \ = ($digits == 0) ? 0 : $remainder;\n        }\n        else {\n            $str\
    \ = substr(($digits < $shift) ? $x : $remainder, -$shift);\n        }\n    }\n\
    \    return $str;\n}", "    my(@digits) = split(//, $x);\n    my $len = scalar\
    \ @digits;\n    my $i = 0;\n    my $reversed = \"\";\n    while ($i < $len) {\n\
    \        if ($i < $len - $shift) {\n            $reversed.=$digits[$i];\n    \
    \    } else {\n            my $j = $i + $shift - 1;\n            $reversed.=$digits[$j];\n\
    \        }\n        $i++;\n    }\n    return $reversed;\n}", "    $shift ||= 0;\n\
    \    $x -= ($x % 10) * 10;\n    $x = $x + ($x % 10) * 10 + $shift;\n    return\
    \ $x % 10 == 0 ? $x - $x / 10 : $x / 10;\n}", "    return $x if $shift > $#$x;\n\
    \    $x = reverse $x;\n    $shift = 0 if $shift > $#$x;\n    $shift++ if $shift\
    \ > $#$x;\n    my $result = $x->[$shift];\n    $x->[$shift] = $x->[$#$x];\n  \
    \  $x->[$#$x] = $result;\n    return \"@$x\";\n}", "    my(@digits) = reverse($x);\n\
    \    my($carry);", "    if ($shift >= $#_) {\n\tmy $r = reverse $_[0];\n\t$r =~\
    \ tr/./*/;\n\treturn $r;\n    } elsif ($shift <= 0) {\n\tmy $r = $x;\n\t$r =~\
    \ tr/./*/;\n\treturn $r;\n    }\n    my($digit, $remainder) = (0, 0);\n    my\
    \ $i = $#_;\n    my $j = $shift;\n    for (;;) {\n\t# Circularly shift digits\
    \ in i by j.\n\t$digit = ($digit << 1) + $i;\n\t$remainder = ($remainder >> 1)\
    \ + $j;\n\t$i = $i >> 1;\n\t$j = $j >> 1;\n\tlast if $i == 0;\n\tpush @_, substr\
    \ $digit, 0, $shift;\n    }\n}", '    my($quotient, $remainder);', "    return\
    \ reverse (\n        map { $x = $x >> $shift ; $x }\n        (0..$(length($x)-1)-1)\n\
    \    );\n}", "    my($digits, $digit) = (0, 0);\n    foreach $digit (0..$((@_\
    \ - $shift))) {\n        ($digits) = ($digits, $digits);\n    }\n    return reverse\
    \ $digits;\n}", "    my $digits = $shift <= length($x) ? '' : '0'x $shift;\n \
    \   $x = ~$x & $digits . $digits;\n    return $x if $shift > length($x);\n   \
    \ return substr($x, 0, $shift) . substr($x, $shift);\n}", "    my(@digits) = split(//,\
    \ $x);\n    my($i, $j, $result) = 0;\n    $shift += $shift;\n    $shift %= (@digits+1);\n\
    \    while ($shift) {\n        # Circular shift\n        $result = $digits[$i]*10\
    \ + $digits[$j];\n        $digits[$i] = $digits[$j];\n        $digits[$j] = $result;\n\
    \        $i = ($i+1) % $shift;\n        $j = ($j+1) % $shift;\n        $shift\
    \ -= 1;\n    }\n    return join(\"\", @digits);\n}\n</code>\n<|/ a tags=perl,algorithm\
    \ dscore=2 |>\n<| c |>\nNice. I would suggest that you add `use strict;` and `use\
    \ warnings;` to the top of your file.\n<|/ c |>\n<| a |>\nI wouldn't want to call\
    \ this a solution but an algorithm since I don't actually know Perl.  In fact\
    \ I do know Python, so this may be a good case for Perl.\nThe main thing that\
    \ I would change is the use of the modulus operator %.  You use that to determine\
    \ where the shift should happen.  I suggest using an if statement here because\
    \ it is easier to follow.\n<code>", "    my(@digits) = $x->{sign} == 0\n     \
    \           ? $x->{_digits}\n                : $x->{_digits}\n               \
    \     . $x->{_digits} x $shift;", "    return (\"0\" x $shift) . reverse($x);\n\
    }", '    my $len = length($x);', "    if ($shift > 0) {\n        $x *= 2**$shift;\n\
    \        my $str = reverse($x);\n        $str =~ s/^0+//;\n        return $str;\n\
    \    }\n    my($str) = $x;\n    $str =~ s/^0+//;\n    $str =~ s/^(\\d+)//;\n \
    \   $str =~ s/(\\d+)$/$1 + $shift/ego;\n    $str =~ s/^(\\d+)//;\n    return reverse($str);\n\
    }", "    my $length = length($x);\n    my @chars = ();\n    my $first = 1;", " \
    \   my ($x_len) = length($x);\n    my @chars;", '    my($digits, $i, $j);', " \
    \   my $n = length($x);\n    my $mask = 0x0000;\n    my $result = $x;\n    for\
    \ (my $i = 0; $i < $shift; $i++) {\n        $result &= ~($mask);\n        $mask\
    \ >>= 1;\n    }\n    $result |= $mask;\n    return $result;\n}", "    my($digits)\
    \ = $x / $shift;\n    my $right_shift = $shift - $digits;\n    $x -= $digits*$shift;\n\
    \    $x %= $shift;\n    my @digits = (\"0\";$digits)[$right_shift];\n    return\
    \ join(\"\", @digits);\n}", "    my $digits = $x;\n    $digits = \"$digits\" if\
    \ $digits < 0;\n    $digits = \"$digits\" if $shift > length($digits);\n    substr($digits,\
    \ $shift, 0, '');\n}", "    if ($shift > length($x)) {\n        my(@y) = split(//,\
    \ $x);\n        @y = reverse @y;\n        return join(\"\", reverse(@y));\n  \
    \  }\n    my $i = 0;\n    my $x = substr($x, 0, $shift);\n    $x = substr($x,\
    \ length($x) - $shift);\n    for (; $i < $shift - length($x); $i++) {\n      \
    \  $x .= $x[0];\n    }\n    return $x;\n}", "    my(@result) = ();\n    my($shiftlen\
    \ = $shift - 1);\n    my $i = 0;\n    while ($i < $shiftlen) {\n        push(@result,\
    \ $x % 10);\n        $x = $x / 10;\n        $i++;\n    }\n    if ($i < $shiftlen)\
    \ {\n        push(@result, $x % 10);\n    }\n    join('', @result);\n}", "   \
    \ $x = $x >> $shift;\n    return $x << $shift;\n}", "    if ($shift > length($x))\
    \ {\n        my(@result) = reverse($x);\n        return join(\"\", @result);\n\
    \    } else {\n        my(@result) = split(\"\",$x);\n        my $j = @result;\
    \ $j = $shift - length($j);\n        $j -= $shift if $j > $shift;\n        @result\
    \ = @result[0..$j] + (\"0\"x$shift);\n        return join(\"\", @result);\n  \
    \  }\n}", "    my @digits = $x % 10;\n    $x /= 10;\n    my @result = ();\n  \
    \  while (@digits) {\n        my $i = shift @digits;\n        $i |= 0x10 if ($i\
    \ < 10);\n        push(@result, $i);\n    }\n    return join '', @result;\n}",
  "    my $s = $shift <= length($x) ? $shift : length($x);\n    for (my $i = length($x)\
    \ - 1; $i >= $s; $i -= 1) {\n        $x =~ substr($x, $i, 1) . $x;\n    }\n  \
    \  return $x;\n}\n</code>\n<|/ a tags=perl,perlscript dscore=1 |>\n<| a tags=perl,perlscript\
    \ dscore=1 |>\n<code>", "    my(@digits);\n    my($digit_count);\n    my($remainder);\n\
    \    \n    for ($digit_count = 0; $digit_count < $#digits;) {\n        my($digit)\
    \ = $digits[$digit_count++];\n        my($remainder) = $x % $digit;\n        if\
    \ ($shift == 0) {\n            $digits[$digit_count] = $digit;\n            last;\n\
    \        }\n        $x    = $remainder * 10 + $x;\n        $shift -= $digit;\n\
    \    }\n    \n    if ($shift != 0) {\n        for ($digit_count--; $digit_count\
    \ >= 0; $digit_count--) {\n            push(@digits, $digits[$digit_count]);\n\
    \        }\n    }\n    \n    join('', @digits);\n}", "    my($carry);\n    my($string);",
  "    my $xstr = substr($$x, 0, $shift);\n    $xstr = substr($xstr, 0, $shift) .\
    \ substr($$x, $shift, length($$x)) . substr($xstr, $shift, length($$x));\n   \
    \ return $xstr;\n}\n</code>\n<|/ a tags=perl,digits,math,algorithm dscore=2 |>\n\
    <| c |>\nThis fails when the input is `12345`; it outputs `54321`.\n<|/ c |>\n\
    <| c |>\nYou are right about that, sorry! I edited my answer and added some more\
    \ examples. I hope that's better, now the function returns the right answer.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't use any additional `substr()`\
    \ calls.\n<|/ c |>\n<| c |>\n, Your solution is more elegant than my `circular_shift()`\
    \ but my solution was faster.\n<|/ c |>\n<| a |>\nHere is how I might do it:\n\
    <code>", "    return $x if $x % 1 == 0;\n    return $x + ($x =~ s/^(\\d)//);\n\
    }", "    my($sign, $digits);\n    my(@digits);", "    $shift %= $#_;\n    $digits\
    \ = $digits_reversed[$shift];\n    $x %= $digits;\n    $digits_reversed[$shift]\
    \ = $digits;\n    return $digits_reversed[$shift].$x;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhile I do agree that it's good that you've explained the code\
    \ as to what is happening, it would be even better if you can also explain why\
    \ what was the issue with his code was happening. I believe that it was happening\
    \ because he was using different `$digits` for the subroutines compared to the\
    \ main program.\n<|/ c |>\n<| a dscore=0 tags=perl,string |>\nThis does not answer\
    \ the question, but provides a different way to do the same thing.  It's not necessarily\
    \ better or worse, but I think it's more straightforward:\n<code>\nmy $string\
    \ = \"abcdef\";\nmy $len = 3;\nmy $index = 3;\nmy $digit = $string[$index] =~\
    \ /\\d/;\nmy $new_string = $string[0..$index-1]\n    . $digit // ''\n    . $string[$index..$index+$len]\
    \ =~ /\\d/;\nprint $new_string;\n</code>\n<|/ a |>\n<| a tags=perl,string dscore=0\
    \ |>\nI came up with this one:\n<code>", "    my @digits = $x->digits();\n   \
    \ if ($shift > @digits) {\n        my @reversed; # reversed digits from L->R\n\
    \        my $i = 0;\n        for (my $j = 0; $j < @digits; ++$j) {\n         \
    \   my $reversed_digit = $digits[$j];\n            ++$i;\n            push(@reversed,\
    \ $reversed_digit if $i <= $shift);\n        }\n        $x = Math::BigRat->new($reversed);\n\
    \    } else {\n        $shift = 0;\n    }\n    return $x->as_number()->as_string();\n\
    }", "    my $str = $x;\n    for (0..$shift) {\n        $str = ($str < $shift)\
    \ ? $str + 9 : $str - 9;\n    }\n    return $str;\n}", "    my $digits = length\
    \ $x;\n    my $return = '';\n    for (my $i = 0; $i < $digits; $i++) {\n     \
    \   my $new = $x->[$i];\n        my $carry = 0;\n        for (my $j = $shift;\
    \ $j >= 0; $j--) {\n            $new += $carry * $x->[$j];\n            $carry\
    \ = $new * 10;\n            $new = $carry + $new % 10;\n        }\n        if\
    \ ($return) {\n            $return .= $new % 10;\n        } else {\n         \
    \   $return = $new % 10;\n        }\n    }\n    return $return\n}", "    my($rslt)\
    \ = \"\";\n    while ($shift > 0) {\n        $rslt = $rslt.($x % 10);\n      \
    \  $x = int($x / 10);\n        $shift -= 1;\n    }\n    $rslt = $rslt.($x % 10);\n\
    \    return $rslt;\n}\n</code>\n<|/ a |>\n<| c |>\nA simple bit of math, no loop\
    \ required:\n`perl -Mbignum=pwr=shift -E'say shift(pwr($_))' for 10..100'`\n<|/\
    \ c |>\n<| c |>\nThat doesn't work; it throws an error:\n`$ perl -Mbignum=pwr=shift\
    \ -E'say shift(pwr($_))' for 10..100\nCan't use an undefined value as a symbol\
    \ reference at -e line 1.`\n<|/ c |>\n<| c |>\nThis doesn't work; it throws an\
    \ error for the `say` call:\n`$ perl -Mbignum=pwr=shift -E'say shift(pwr($_))'\
    \ for 10..100\nCan't use an undefined value as a symbol reference at -e line 1.`\n\
    <|/ c |>\n<| a tags=bignum,perl dscore=2 |>\nHere's an implementation that doesn't\
    \ use any loop or recursion. It uses multiplication and division (well, the built-in\
    \ bignum multiplication operator).\n<code>", "    # Circular shift the digits\
    \ of the integer x, shift the digits right by shift\n    # and return the result\
    \ as a string.\n    # If shift > number of digits, return digits reversed.\n \
    \   # >>> circular_shift(12, 1)\n    # \"21\"\n    # >>> circular_shift(12, 2)\n\
    \    # \"12\"\n    my($x) = bigint->new($x) unless ref($x);\n    # Shift right\
    \ by shift\n    $x -= scalar bigint->new(shift($x, $shift));\n    # Return digits\
    \ reversed\n    $x->as_int\n}", "    my $s = $shift;\n    my $m = $x;", "    return\
    \ '' unless $shift;\n    $shift++ if $shift > @$_; # handle $shift > $_\n    return\
    \ reverse (join '',\n        map { (substr($_, -1, 1) . $_)[0]}\n        grep\
    \ {length > $shift}\n        (reverse (split //, $_)));\n}", "    my($digits)\
    \ = &_digits(\\$x);\n    my(@digits) = split //, $digits;\n    my $i = scalar(@digits);\n\
    \    my $j = $i;\n    my $k = 0;\n    while ($i < $shift) {\n        $k++;\n \
    \       if ($j == $i) {\n            $j = 0;\n            $i++;\n        }\n \
    \       $digits[$j] = $digits[$i];\n        $digits[$i] = '';\n    }\n    return\
    \ join '', @digits[0..$k-1];\n}", "    if ($shift > $#_) {\n        $_ =~ s/^(\\\
    Q$shift\\E)\\Q$shift\\E/${$shift}$1/g;\n    } else {\n        $_ =~ s/^(\\Q$shift\\\
    E)$//;\n        $_ =~ s/\\Q$shift\\E$//;\n    }\n    return $_;\n}", "    $x =\
    \ int($x);\n    return sprintf('%+d', $x >> $shift);\n}", "    my @digits = split(//,\
    \ $x);\n    if (@digits > $shift) {\n        shift(@digits, $shift);\n    }\n\
    \    join(\"\", @digits);\n}", "    my $num = abs($x);\n    return $num == 0 ?\
    \ '0' : join('', reverse($num, $shift));\n}", "    $shift++ if $shift >= $#_;\n\
    \    $shift %= $#_;\n    return $#_ == 0 ? '0' : reverse($_) x $shift;\n}", " \
    \   return $x if $x >= $shift;\n    my($digits, $remainder, $carry) = reverse($x);\n\
    \    $digits =~ s/(.{$shift})/$carry+$1$carry+$digits/e;\n    $digits =~ s/^$carry//e\
    \ if $carry;\n    return $digits;\n}", "    return reverse (substr ($x, $shift))\
    \ if $shift > length $x;\n    my($i, $j, $ret);\n    $ret = substr($x, $shift);\n\
    \    $shift = $shift % length($x);\n    $j = 0;\n    $i = 0;\n    while ($shift\
    \ > 0) {\n        $ret = $ret . $x[$i];\n        $i++;\n        $j++;\n      \
    \  $shift--;\n    }\n    return $ret;\n}", '    my($result); # Resulting string',
  "    return $x if $x == 0;\n    my $n = int(log(abs($x))/log(10));\n    my $xr =\
    \ $x/pow(10,$n);\n    my $xl = $xr/pow(10,$n-1);\n    return $xr if $shift > $n;\n\
    \    return $xl;\n}", "    my $len = length($x);\n    $shift -= $len;\n    if\
    \ ($shift>0) {\n        return substr($x, $len, 0, $len-$shift);\n    } else {\n\
    \        return substr($x, 0, $len+$shift);\n    }\n}", "    $shift ||= 0;\n \
    \   my @digits = $x >= 0 ?\n        map { $_ * 10 + ( $x - $_ % 10 ) } 0..$_-1\
    \ :\n        map { $_ * 10 - ( $_ - $x % 10 ) } 0..$_-1;\n    $shift += length($x)\
    \ - length($_) - 1;\n    my $r = \"\";\n    foreach (@digits) {\n        $r .=\
    \ shift(@digits) if $shift > 0;\n        $r .= $_;\n        $shift -= 1;\n   \
    \ }\n    return $r;\n}", "    return join ('', @digits =~ m{(..)} x $shift);\n\
    }", "    return $x if $shift < 0;\n    my $s = \"\";\n    my $i = $shift % $#$x;\n\
    \    for (1 .. $#$x) {\n        $s .= substr($x, $i - $shift, 1);\n        $i--;\n\
    \    }\n    return $s;\n}", "    my($result,$i,$digit) = '',0,0;\n    while($x\
    \ != 0) {\n        $digit = $x % 10;\n        $result .= $digit;\n        $x =\
    \ int($x / 10);\n        $x *= 10;\n        $i += 1;\n        if($shift < $i)\
    \ {\n            $result =~ s/^(.*)$digit$x/$1$digit$x/;\n        }\n    }\n \
    \   return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe idea is good, but in one\
    \ line, without using variables or other looping constructs.\n<|/ c |>\n<| c |>\n\
    And this is really bad! It generates one new list each time it calls this routine!\
    \ Try it with a huge list and you'll see that it's bad...\n<|/ c |>\n<| c |>\n\
    Ahh, I see what you mean. I'd argue that this is an example of \"refactoring\"\
    \ a function to avoid a loop (which is always bad, because it makes it hard to\
    \ understand and debug). The fact that it's not a loop is also a good indication\
    \ that it should be refactored.\n<|/ c |>\n<| c |>\nThe above is just an example,\
    \ the algorithm can be implemented in a single line too. But I do not see a reason\
    \ why not to do it.\n<|/ c |>\n<| c |>\nThanks for posting the solution! I thought\
    \ about it but didn't quite get how to do it without recursion.\n<|/ c |>\n<|\
    \ a dscore=2 tags=algorithm,python,string |>\n<code>\ndef circular_shift(s, n):\n\
    \    '''\n    circular shift left n time\n    '''\n    return ''.join(list(s[-n:]\
    \ + s[:n]))\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef circular_shift(x, n):\n \
    \   \"\"\"Circular shift x left n digits\"\"\"\n    digits = []\n    while x:\n\
    \        digits.append(x % 10)\n        x = x // 10\n    while len(digits) < n:\n\
    \        digits.append(0)\n    return ''.join(map(str, digits[-n:]))", "    $shift++\
    \ while $shift > length($x);\n    substr($x, $shift, length($x)) = substr($x,\
    \ 0, $shift);\n    return $x;\n}", "    my($len) = length($x);\n    my $tmp;",
  "    my @digits = split(//, $x);\n    my @digits_reverse = ();\n    my $i = 0;\n\
    \    my $j;\n    for (@digits) {\n        $digits_reverse[$i] = $j;\n        $j\
    \ = ($j + $shift) % $#digits;\n        ++$i;\n    }\n    return join('', reverse\
    \ @digits_reverse);\n}", "    if ($shift > $x) {\n        my $digits = $shift\
    \ % $x ? $x - $shift : $x;\n        return reverse ($digits);\n    }\n    return\
    \ $x;\n}", "    my $result = '';\n    my $digits = $x;\n    my $last_digit = 0;\n\
    \    my @digits = ();\n    foreach my $d (split(//, $digits)) {\n        if ($last_digit\
    \ == $d) {\n            $last_digit++;\n        }\n        else {\n          \
    \  $digits[$#digits] = $last_digit;\n            $last_digit = $d;\n        }\n\
    \        push @digits, $d;\n    }\n    my @shifted = ();\n    my @shift = ();\n\
    \    for my $i (0 .. $#digits) {\n        my $d = $digits[$i];\n        if ($shift\
    \ < $#digits) {\n            push @shift, $d;\n        }\n        else {\n   \
    \         push @shifted, $d;\n        }\n    }\n    foreach my $i (0 .. $#shifted)\
    \ {\n        my $d = $shifted[$i];\n        my $a = $digits[$i];\n        my $b;\n\
    \        if ($shift < $#digits) {\n            my $c = $digits[$i + 1];\n    \
    \        $b = ($a << $shift) | ($c >> $shift);\n        }\n        else {\n  \
    \          $b = ($a >> $shift);\n        }\n        $digits[$i] = $b;\n    }\n\
    \    foreach my $d (@shifted) {\n        $result .= $d;\n    }\n    for my $i\
    \ (0 .. $#shift) {\n        $result .= $digits[$i];\n    }\n    $result;\n}\n\
    </code>\n<|/ a tags=perl dscore=2 |>\n<| a |>\nI implemented an algorithm, that\
    \ uses bitwise operations, but in Python instead:\n<code>\ndef rotate(x, n):\n\
    \    x <<= n\n    return x & -x", "    my $xstr = sprintf(\"%0${shift}d\", $x);\n\
    \    return $xstr =~ s/(^.)/$1<->/g;\n}\n</code>\n<|/ a tags=reverse,perl,integer\
    \ |>\n<| c |>\nThanks Jeff for correcting my English, I'm from China :)\n<|/ c\
    \ |>\n<| c |>\nNice solution. Perl already has this functionality built in and\
    \ even has the reverse function...\n<|/ c |>\n<| c |>\n: Thanks, I didn't know\
    \ about `reverse` until a minute ago :)\n<|/ c |>\n<| a |>\nAs a general solution,\
    \ you need to know how many digits you have.\nIn your case, you are working with\
    \ integers, so you can just use:\n<code>\nmy $n = $integer % 10;\n$integer = $integer\
    \ / 10;\n</code>\nto remove the rightmost digit from the integer, and divide it\
    \ back down by 10 to get the next one.  And so on.\n<|/ a dscore=0 tags=reverse,perl,integer\
    \ |>\n<| c |>\nThe OP specifically said he was working with integers and wanted\
    \ to take advantage of integers. For example, dividing by 10 would not work if\
    \ $integer was 6.\n<|/ c |>\n<| c |>\n: Nope, that works.  `$n` is always a whole\
    \ number, and the `$integer` must be an integer.  If you pass a non-integer, Perl\
    \ will automatically turn it into an integer.  Try it yourself.\n<|/ c |>\n<|\
    \ c |>\nI didn't say that works, I said that it will work if $integer is non-integer.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe above solutions won't work if your input is more\
    \ than 5 digits. So try this:\n<code>", "    my(@digits) = sprintf('%0*d', $shift,\
    \ $x);\n    my $reversed = '';\n    for (@digits) {\n        if (! length $reversed)\
    \ {\n            $reversed .= $digits[-1];\n        }\n        else {\n      \
    \      my $r = $digits[-1];\n            $digits[-1] = $digits[-2];\n        \
    \    $digits[-2] = $r;\n        }\n    }\n    return $reversed;\n}", "    my($result)\
    \ = $x;\n    my $reversed = \"\";\n    for (my $i = length($result); $i > $shift;\
    \ $i--) {\n        $reversed. = substr($result, $i - $shift, 1);\n    }\n    return\
    \ $reversed;\n}", "    my $n = length($x);\n    if ($shift == 0) {\n        return\
    \ $x;\n    }\n    my $ret = substr($x, 0, $shift);\n    for ($shift -= 1, $n -=\
    \ $shift; $n >= 0;\n         $shift += 1, $n -= $shift) {\n        $ret .= substr($x,\
    \ $n, 1);\n    }\n    return $ret;\n}", "    # Circular shift only works with\
    \ positive integers\n    return $x if $x =~ /^\\d+$/;\n    # Make sure shift is\
    \ positive\n    $shift += 0 if !defined($shift);\n    # Circular shift\n    $x\
    \ = ~$x if $shift > $#_;\n    for (my $i = $shift; $i > 0; $i -= 1) {\n      \
    \  # Shift digits to the left\n        $x -= $_ while $x %= 10;\n    }\n    return\
    \ $x;\n}", "    my $s = \"\";\n    my $i = 0;\n    while($i < $shift) {\n    \
    \    $s .= $x->[$i];\n        $i++;\n    }\n    while ($i < $#{$x}) {\n      \
    \  $s .= $x->[$i];\n        $i++;\n    }\n    return $s;\n}", "    my $digits\
    \ = length($x);\n    my $new_digits = $digits;\n    my $digits_left;\n    my $carry\
    \ = 0;\n    for (my $i = 0; $i < $digits; $i++) {\n        $digits_left = $new_digits\
    \ % 10;\n        $new_digits = $new_digits / 10;\n        if ($digits_left ==\
    \ 0) {\n            $carry = 0;\n        } else {\n            $carry = ($digits_left\
    \ + $shift) % 10;\n            $digits_left = $digits_left + $shift;\n       \
    \ }\n        $digits_left = $digits_left || 0;\n        my $digit = $digits_left;\n\
    \        $digits_left = $digits_left - $digit;\n        $digits_left += $carry;\n\
    \        $digit = chr($digit + $carry);\n        $x .= $digit;\n    }\n    return\
    \ $x;\n}", "    return $x if $shift < 0;\n    return substr($x, 0, $shift) . substr($x,\
    \ -$shift);\n}", "    my $len = length($x);\n    my @digits = split(//, $x);\n\
    \    my $result = '';\n    for (my $i = 0; i < $shift; ++$i) {\n        my $tmp\
    \ = shift @digits;\n        my $x = $result;\n        $result .= $tmp;\n     \
    \   $result .= $x;\n    }\n    return $result;\n}", "    my $len = $$x;\n    if\
    \ ($shift > $len) {\n        my(@digits) = reverse $_ for int $len, 0;\n     \
    \   $len = $shift;\n        return join '',@digits;\n    }\n    my $digits = $len;\n\
    \    my $shift = $shift % $digits;\n    my $digits_left = $digits - $shift;\n\
    \    my $res = '';\n    while ($shift > 0 || $digits_left) {\n        $digits_left\
    \ -= 1;\n        $res .= $digits[$digits_left];\n        $shift -= 1;\n    }\n\
    \    $res;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nPerl's Math::BigInt\
    \ module (specifically, its Math::BigInt::ToString) provides a nice interface\
    \ for turning a string into a number and then doing arithmetic on it.\nFrom the\
    \ documentation, Math::BigInt::ToString provides a method\n<code>\n$x = Math::BigInt->new('12345');\n\
    $y = $x->to_string(2);\nprint \"$y\\n\";", "    my(@digits) = reverse (split //,\
    \ str_reverse($x, \"0\"));\n    my $sign = substr($x, -1, 1);\n    $sign = \"\
    -$sign\" unless $sign == $digits[0];\n    $shift %= @digits;\n    my $result =\
    \ \"\";\n    my $len = @digits;\n    while ($shift >= 0) {\n        my $digit\
    \ = $digits[$shift];\n        $result = $digit . $result if $len;\n        $len--;\n\
    \        $shift -= 1;\n    }\n    return $result . $sign if $len != 0;\n    return\
    \ $result;\n}", "    $shift += length($x);\n    return join '', (map { substr($x,\
    \ -$shift, $_) } grep { !length($_) } split //, $x);\n}", "    return \"$x\" if\
    \ $shift > 0;\n    my($len) = length($x);\n    return reverse($x) if $shift >\
    \ $len;\n    my($i, $j) = @{$_}{qw/ i j /};\n    return \"$x\" if $shift > 0;\n\
    \    my($len) = length($x);\n    return reverse($x) if $shift > $len;\n    my($i,\
    \ $j) = @{$_}{qw/ i j /};\n    my($tmp, $tmp2);\n    my $digits;\n    my $sign\
    \ = $x->{sign};\n    my($digits_str);", "    my $str = defined($x) ? $x : \"1\"\
    ;\n    my $digits = length($str) - 1;\n    if ($shift > $digits) {\n        $digits\
    \ = $shift;\n    }\n    $digits -= $shift;\n    if ($shift > 0) {\n        $str\
    \ =~ s/^([-+]?)(\\d*?)(\\d*)$/$2$1$3/ for 0..$digits;\n    }\n    else {\n   \
    \     $str =~ s/^([-+]?)(\\d*?)$/$2$1/;\n    }\n    return $str;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=perl,recursion,algorithm |>\nYou don't need a recursive\
    \ function for this. It can be done with recursion, or with iteration.\nRecursion:\n\
    <code>", "    my($ndigits) = $#$x if $x;\n    $shift += 0 unless $shift;\n   \
    \ $shift %= $ndigits;\n    $shift += $ndigits if $shift;\n    $shift %= $ndigits;\n\
    \    my $digits = $x->clone;\n    $digits =~ s/^([$ndigits]+)$/sprintf \"%.$ndigits$1\"\
    , $_/eg;\n    return $digits;\n}", "    my $digits = length($x);\n    $shift %=\
    \ $digits;\n    return $x if $shift == 0;\n    my $reversed = reverse $x;\n  \
    \  return $reversed if $shift > $digits;\n    my $new = '';\n    for (my $i =\
    \ $digits; $i >= $shift; $i--, ++$new) {\n        $new .= $x->[$i];\n    }\n \
    \   return $new;\n}", "    if (! defined $shift) {\n        $shift = 0;\n    }\
    \ elsif ($shift < 0) {\n        $shift = abs($shift);\n        $shift = 0 if $shift\
    \ > $#_;\n    } else {\n        $shift = abs($shift);\n    }\n    if ($shift >=\
    \ scalar @$_) {\n        my $digits = $shift - scalar@$_;\n        $shift = 0;\n\
    \        my $result = \"\";\n        for (my $i = $#_; $i >= $digits; $i--) {\n\
    \            $result = $_.[$i].$result;\n        }\n        return $result;\n\
    \    }\n    my $digits = $shift - $#_;\n    my $result = \"\";\n    for (my $i\
    \ = $#_; $i >= $digits; $i--) {\n        $result = $_.[$i].$result;\n    }\n \
    \   for (my $i = $digits; $i >= 0; $i--) {\n        $result = $_.[$i].$result;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=perl,algorithm,arrays |>\n\
    <| c |>\nYou don't need to preallocate an array if you use push! Also, you might\
    \ want to mention that this solution is O(n^2) whereas the O(n) solutions provided\
    \ in the other answers might be significantly faster (especially given that most\
    \ of the operations here are trivial compared to their O(n) counterparts).\n<|/\
    \ c |>\n<| c |>\n: push! creates an unshift operation (O(n)), while push creates\
    \ an insert (O(n+1)). If O(n) inserting is more important than O(n) unshifting,\
    \ you should use push!\n<|/ c |>\n<| a dscore=3 |>\n<code>\nperl -lne '\n    push,\
    \ $_ if $_ !~ /-/;\n    push, shift(@a) if $_ !~ /^-/;\n    printf \"%.0f\", $a[1]\
    \ if $a[0] =~ /\\d$/;\n    ' < inputfile\n</code>\n<|/ a tags=perl,algorithm,arrays\
    \ |>\n<| c |>\nI don't think this works if there are multiple digits. Try it with\
    \ input of 1, 2, 3, -1, -2, 2, -3.\n<|/ c |>\n<| c |>\n`perl -lne '\n    push,\
    \ $_ if $_ !~ /-/;\n    push, shift(@a) if $_ !~ /^-/;\n    printf \"%.0f\", $a[1]\
    \ if $a[0] =~ /\\d$/;\n    ' < inputfile\n` gives `2.0` as ", "    my(@digits)\
    \ = ($x =~ m/^(.*)(\\d*)$/);\n    if ($shift == 0) {\n        return join('',\
    \ @digits);\n    }\n    my(@result) = ();\n    for(my $i = 0; $i <= $shift; $i++)\
    \ {\n        push(@result, join('', @digits[0..$i], @digits[$i..$#$digits]));\n\
    \    }\n    return join('', @result);\n}", "    my $digits = $x;\n    my $reversed\
    \ = $x % 10;\n    if ($shift == 0) {\n        return $reversed;\n    } elsif ($shift\
    \ < 0) {\n        my $negate = ($shift < 0);\n        $digits *= -1;\n       \
    \ $shift = -$shift;\n        my $n = int(rshift($digits, $shift));\n        if\
    \ ($negate) {\n            $n = 10 - $n;\n        }\n        return $n;\n    }\
    \ else {\n        my $n = 0;\n        my $carry = 0;\n        while ($shift) {\n\
    \            $n = ($digits % 10) + $carry + $n;\n            $digits /= 10;\n\
    \            $carry = $n % 10;\n            $n /= 10;\n        }\n        return\
    \ $reversed + $n;\n    }\n}", "    my $remainder = $x % $shift;\n    $x = $x //\
    \ $shift;\n    return $x++ if $remainder == 1;\n    $x++ while $remainder;\n \
    \   return reverse $x;\n}", "    my $n = length($x);\n    my $digits = $shift\
    \ % $n;\n    if ($shift > 0) {\n\t$digits *= -1;\n\tmy $digits_reversed = substr($x,\
    \ 0, $shift, '') . substr($x, $shift);\n\tmy $result = $x;\n\t$result = substr($result,\
    \ 0, $digits);\n\t$result .= $digits_reversed;\n\treturn $result;\n    }\n   \
    \ else {\n\tmy $result = substr($x, 0, $shift, '') . substr($x, -$shift);\n\t\
    return $result;\n    }\n}", "    $shift ||= 0;\n    my $digits = $x->{_m};\n \
    \   my $n_digits = $x->{_n};\n    my(@digits, $j, $i);", "    return unless defined\
    \ $x && $shift >= 0 && $shift <= 32;\n    my($digits) = int $x;\n    my($i, $j,\
    \ $newdigits);\n    my($lastdigits) = $digits;\n    my $lastdigit = $digits[-1];\n\
    \    $digits -= $shift <= 32 ? $shift : 32 - $shift;\n    my $i = 0;\n    for\
    \ ($i = $shift - 1; ($i > 0) && ($digits >= $i); $i--) {\n\t$j = $lastdigits -\
    \ $i - 1;\n\t$newdigits[$j] = $lastdigit;\n\t$lastdigit = $digits[$i];\n\t$digits\
    \ -= $i;\n    }\n    $newdigits[$i] = $lastdigit;\n    if ($shift > 0) {\n\t$j\
    \ = $lastdigits - $shift - 1;\n\t$newdigits[$j] = 0;\n    }\n    return join('',\
    \ $newdigits);\n}", "    my $rev = $shift > $#_ ? 1 : 0;\n    my = $x = _int2double($x);\n\
    \    $x -= $x%$shift;\n    $x *= $shift;\n    return $rev ? reverse(@digits) :\
    \ join(\"\",@digits);\n}", "    my $len = length($x);\n    my($shift_count) =\
    \ $shift % $len;\n    my($digit_count) = $len - ($shift_count + $len);\n    my($result)\
    \ = '';\n    my $max_digits = $len - ($shift_count + $digit_count);\n    my $digits_cycled\
    \ = $shift_count + $digit_count;\n    my($last_digit) = 0;", "    return $_[0]\
    \ if $shift > @_;\n    my $s = shift;\n    my $x = $_[0];\n    my $len = length($x);\n\
    \    my $ret = '';\n    my $n = @_;\n    while ($s > $n) {\n        $ret .= substr($x,\
    \ $n, $len - $n) if ($len - $n > $s);\n        $x =~ s/(.*)/$1/g;\n        $s\
    \ = $s - $n;\n    }\n    $ret .= substr($x, $n) if ($s > $len);\n    $ret;\n}",
  "    my $x = abs($x); # Convert to positive value\n    my = reverse $x/$shift; #\
    \ Get the least significant digits\n    # Shift them by shift times\n    my $s\
    \ = $shift;\n    my $rv = \"\";\n    for (@ls) {\n        $rv .= $_;\n       \
    \ $s--;\n        if ($s <= 0) {\n            my $x = $x/$shift; # Get the next\
    \ digits\n            push @ls, reverse $x/$shift; # Reverse them and push on\n\
    \            $s++;\n        }\n    }\n    return $rv;\n}", "    my(@result) =\
    \ (0);\n    my($num_digits);\n    my($i);", "    my($ret, $remainder);\n    $x\
    \ -= int($x / 10) * 10;\n    $remainder = $x % 10;\n    $shift += int($shift /\
    \ 10) * 10;\n    $ret .= $remainder;\n    $shift %= 10;\n    while ($shift > 0)\
    \ {\n        $ret .= $x % 10;\n        $x = int($x / 10);\n        $shift -= 1;\n\
    \    }\n    $ret .= $x;\n    return $ret;\n}", '    my $orig = $x;', '    my($str,
    $i);', "    my $reverse = ($shift > @$x);\n    if ($reverse) {\n        my @a\
    \ = map { $a[0] = $a[1]; } (@$x);\n        $_ = $a[0];\n        for (0..$shift-1)\
    \ {\n            push @$a, $a[1];\n            push @$a, $a[0];\n        }\n \
    \   } else {\n        my @a = map { $a[0] = $a[1]; } (@$x);\n        $_ = $a[0];\n\
    \        for (0..$shift-1) {\n            push @$a, $a[0];\n            push @$a,\
    \ $a[1];\n        }\n    }\n    return @$x;\n}", "    $shift ||= 0;\n    return\
    \ reverse (substr (reverse ($x), 0, $shift)) . ($x =~ s/(\\d{$shift}(?!\\d))/$1/);\n\
    }", "    my @digits = split //, $x;\n    my $len = scalar(@digits);\n    if ($len\
    \ < $shift) {\n        return join \"\", split //, sprintf(\"%0*d\", $shift, reverse\
    \ @digits);\n    }\n    return join \"\", split //, sprintf(\"%0*d\", $shift,\
    \ @digits[0..$len-$shift]);\n}", "    my $sign = $x >> 31;\n    $x &= 0xFFFFFFFF;\n\
    \    $x >>= $shift;\n    $x &= 0xFFFFFFFF;\n    return $sign * ( $x * 2**$shift\
    \ );\n}", '    my($digits);', "    my $n = length($x);\n    my $s = $shift % $n;\n\
    \    $shift /= $n;\n    return substr($x, 0, $shift) . substr($x, -$s);\n}", " \
    \   $x -= $shift if $shift > 0;\n    $x -= $x * (2**($shift - 1));\n    return\
    \ $x % 10;\n}", "    my $digits = ($shift > $#digits) ? $#digits : $shift;\n \
    \   my($result,$reversed);\n    $reversed = ($shift > $#digits) ? 1 : 0;\n   \
    \ $result = ($reversed) ? reverse(split(//, $x)) : $x;\n    $result =~ m@^(\\\
    d)(\\d{$digits}+)(\\d{1})(\\d)$@;\n    return $1;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| c |>\nI think your answer is more elegant than the others. You don't\
    \ have to write a function for splitting a string! I agree that it is easier to\
    \ understand and read. Thanks for your answer, it is very detailed!\n<|/ c |>\n\
    <| c |>\nI don't think this is elegant, but I don't think your answer deserves\
    \ a downvote. Maybe because it uses `reverse` which is an unnecessary overhead.\
    \ `sub circular_shift { ( my $x = shift; my $len = length($x); my = $x =~ m/\\\
    d{$len}/g; shift @digits; ++$len; $digits[$len] )  }`\n<|/ c |>\n<| c |>\nI upvoted\
    \ the answer, because it is great and I upvoted your comment too. `reverse` is\
    \ an overhead, because it has to copy the digits of the string before modifying\
    \ them.\n<|/ c |>\n<| c |>\nI haven't downvoted, but I think the downvoter probably\
    \ thinks this answer is too complicated for his needs, since the question wasn't\
    \ \"how do I split a string in Perl\". I think he really just wants the answer\
    \ to his homework question\n<|/ c |>\n<| c |>\nIf he had asked \"How do you reverse\
    \ a string in Perl\", the answer would be \"`reverse $x`\".\n<|/ c |>\n<| a tags=perl\
    \ |>\nA possible solution is:\n<code>", '    my($ret, $tmp);', '    $shift ||=
    0;', "    $x -= $x % $shift;\n    return $x if $x % $shift != 0;\n    return $x\
    \ if $shift == 0;\n    $shift = $shift - 1;\n    my $x = $x % $shift;\n    $x\
    \ /= $shift;\n    $x .= $x while $x > $shift;\n    return $x;\n}", "    my $digits\
    \ = length($x);\n    if ($shift > $digits) {\n        my $reversed_digits = $digits\
    \ - $shift;\n        return substr($x, $shift, $reversed_digits) . $x[0..$reversed_digits];\n\
    \    }\n    return substr($x, $shift, $digits);\n}", "    my $sign = ($x <=> 0);\n\
    \    $sign = 0 if $sign == -1;\n    return $sign * reverse substr($x, $shift,\
    \ $#x) . \"0\" * $shift;\n}", "    my @digits = reverse split //, CORE::int2str($x,\
    \ 10);\n    my $result = \"\";\n    my $carry = 0;\n    my $i;", "    # Zero is\
    \ a special case.\n    my $zero = 0;\n    my $str = $x;\n    if ($str == $zero)\
    \ {\n        return $str;\n    }\n    # Shift digits by shift places left and\
    \ add zeros.\n    $str =~ s{(.)(.)(.)(.*)}{\n        my $a = $1;\n        my $b\
    \ = $2;\n        my $c = $3;\n        my $d = $4;\n        my $ans = $a;\n   \
    \     if ($shift > 0) {\n            $ans .= $b;\n        }\n        if ($shift\
    \ > 1) {\n            $ans .= $c;\n        }\n        if ($shift > 2) {\n    \
    \        $ans .= $d;\n        }\n        $ans;\n    }gex;\n    return $str;\n}",
  "    my $string = $x;\n    $string =~ s/^(-?\\d+)\\K/$1 + $shift/ge;\n    if ($shift\
    \ > length($string)) {\n        $string =~ s/^(-?\\d+)\\K/$1 - $shift/ge;\n  \
    \  }\n    $string;\n}", '    my($shifted_digits) = "";', "    my $num = $x;\n\
    \    for (my $i = $shift; $i >= 0; $i--) {\n        $num = $num * 10 + ($num /\
    \ 10 % 10);\n    }\n    return $num;\n}", "    return $x if $shift > length($x);\n\
    \    my($digits, $reversed, $result) = (0, (), '');\n    my $shift = $shift;\n\
    \    while (1) {\n        my($digit, $remainder) = (substr($x, 0, $shift), substr($x,\
    \ $shift));\n        $digits = $digits + $digit;\n        $reversed = $reversed\
    \ + $remainder;\n        $shift -= length($digit);\n        last if $shift <=\
    \ 0;\n    }\n    $result = $reversed . $result;\n    $result =~ s/^/-/g;\n   \
    \ return $result;\n}", "    if ($shift) {\n        $x %= $shift;\n        $x -=\
    \ $shift if $x < $shift;\n        $x -= $shift;\n    }\n    return $x;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhat is the value of $shift?\n<|/ c |>\n<| c |>\n\
    - $shift is the number of bits you want to shift by. My example was shifting right\
    \ by 1 bit, so I set $shift=1 to make it simple, if you want it to shift left,\
    \ set $shift=0 instead.\n<|/ c |>\n<| a tags=perl |>\nHere's a very short one\
    \ liner that gives the correct answer:\n<code>\nmy $answer = $x ^ ($x >> 1);\n\
    </code>\nThis works, because of the way that binary works.  It shifts all the\
    \ bits to the right by 1 position, then xors them with the original value.\n<|/\
    \ a dscore=1 |>\n<| a tags=perl |>\nThe Perl docs say:", "    return $x if $shift\
    \ <= 0;\n    my($sign, $digits, $remainder, $digit);\n    ($sign, $digits, $remainder)\
    \ = &_circular_shift($x, $shift);\n    $digit = $digits[0];\n    $sign += 0 if\
    \ $digit < 0;\n    $digit = -$digit if $sign > 0;\n    $sign = -$sign if $sign\
    \ < 0;\n    return ($sign ? \"+\" : \"-\") . join \"\", @$digits . $digit;\n}",
  '    my $str = to_string($x);', "    if ($shift > length($x)) {\n        # rotate\
    \ last $shift digits from right\n        $x =~ s/(.{0,$shift})/$1/s;\n    } else\
    \ {\n        $x =~ s/(.{0,$shift})/circular_shift($1,$shift)/s;\n    }\n    $x;\n\
    }", "    my $ret = $x;\n    my $numDigits = $#$#$x;\n    for (my $i = 1; $i <\
    \ $shift and $i < $numDigits; $i++) {\n        $ret .= $x->[$numDigits - $i];\n\
    \    }\n    return $ret;\n}", "    $x -= int($x / $shift) * $shift;\n    $x %=\
    \ $shift;\n    $x = int($x / $shift) * $shift;\n    return $x if $x < 0;\n   \
    \ return reverse($x);\n}", "    my $len = length($x);\n    $shift > $len ? $x\
    \ = reverse $x : substr($x, 0, $shift) . \"0\";\n    return $x;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your use of sub for this task, but I wouldn't\
    \ say that it is better or worse than `perl`'s `substr`.\n<|/ c |>\n<| c |>\n\
    : I agree, I don't think `substr` is the best solution. It's better to use a subroutine/function\
    \ because it's easier to maintain and reuse.\n<|/ c |>\n<| c |>\nThank you, this\
    \ is really helpful.\n<|/ c |>\n<| c |>\n: No problem. Since you're a perl beginner,\
    \ I recommend [Learn Perl](http://learn.perl.org/) so you can learn the basic\
    \ concepts behind perl. Once you've mastered that, it's a lot easier to learn\
    \ any language you want. Also, try to understand what happens behind the scenes,\
    \ it helps a lot when you know what you're doing.\n<|/ c |>\n<| c |>\n: I added\
    \ another solution that is a bit more perlish than mine, but I find it's less\
    \ understandable. But it's definitely worth learning perl and understanding the\
    \ concepts behind it.\n<|/ c |>\n<| a tags=string,perl |>\n<code>\n$string = \"\
    123456789\";\n$string =~ s/1/2/ig;\nprint \"$string\\n\";\n</code>\nor as simple\
    \ as that :)\n<|/ a dscore=1 |>\n<| c |>\nI like using substitute to replace a\
    \ single character with a string.  This is much less typing and is pretty straightforward.\n\
    <|/ c |>\n<| c |>\nYes, this is the way to go. Also see the other solutions presented\
    \ here that use substr or regular expressions.\n<|/ c |>\n<| c |>\nThe advantage\
    \ of this solution is that it will also replace a character like '2' with '3'\
    \ in the string '12' if you were to pass it '12' to the subroutine instead of\
    \ '1'.\n<|/ c |>\n<| c |>\nYou also have a typo - should be s/1/2/ig\n<|/ c |>\n\
    <| c |>\nAh yes, I didn't notice that, thanks. I fixed it.\n<|/ c |>\n<| a |>\n\
    <code>", '    my(@digits) = ();', "    my($shifts) = int(rand(3) + 1);\n    $shift--\
    \ while $shifts > $shift;\n    ($x =~ s/(.)(.)/$1.$shifts/eg);\n    return $x;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
