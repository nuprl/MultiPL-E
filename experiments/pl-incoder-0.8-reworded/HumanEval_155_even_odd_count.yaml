name: HumanEval_155_even_odd_count
language: pl
prompt: "# Given an integer. return an array that has the number of even and odd digits\
  \ respectively.\n# Example:\n# >>> even_odd_count(-12)\n# [1, 1]\n# >>> even_odd_count(123)\n\
  # [1, 2]\nsub even_odd_count {\n    my($num) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_count;\n\
  \        if(eq_deeply($candidate->(7),[0, 1])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(-78),[1, 1])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3452),[2,\
  \ 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(346211),[3,\
  \ 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-345821),[3,\
  \ 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-2),[1,\
  \ 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-45347),[2,\
  \ 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1,\
  \ 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return ([1,1]) if ($num < 0);\n    my($odds, $evens);\n    my $remainder\
    \ = $num % 10;\n    $odds = $remainder % 2 ? $odds + 1 : $odds;\n    $evens =\
    \ $remainder % 2 ? $evens + 1 : $evens;\n    return ($evens, $odds);\n}", "  \
    \  my($count);\n    my(@arr);\n    for(my $i = 0; $i <= $#$num; $i++) {\n    \
    \    $count++;\n        if($num > 0) {\n            push($arr, $num % 10);\n \
    \           $num = ($num / 10);\n        }\n        elsif($num < 0) {\n      \
    \      push($arr, $num % 10);\n            $num = ($num / 10);\n        }\n  \
    \      elsif($num == 0) {\n            $count++;\n            $arr[$i] = 0;\n\
    \        }\n    }\n    push($arr, $num);\n    return @arr;\n}\n</code>\n<|/ a\
    \ dscore=0 tags=loops,numbers,arrays,perl |>\n<| c |>\nThis is only correct for\
    \ numbers whose digits happen to be in order -- e.g. 9876543210 will give \"9876\"\
    \ and \"6543\", not \"987\" and \"654\".\n<|/ c |>\n<| a dscore=0 |>\nTry this\
    \ code:\n<code>\nuse strict;\nuse warnings;", "    return 1 unless defined $num;\n\
    \    return ($num % 2 ? 1 : 0, $num % 3 ? 1 : 0);\n}\n</code>\n<|/ a tags=perl,if-statement\
    \ dscore=0 |>\n<| a dscore=0 |>\nUse a switch!\n<code>", "    my @even = ();\n\
    \    my @odd = ();\n    if ($num < 0) {\n        $num *= -1;\n        $num +=\
    \ $num + 1;\n    }", '    my(@even,@odd);', "    my(@nums) = ($num, $num / 10);\n\
    \    while(@nums) {\n        my $odd = (@nums) % 2;\n        push @nums, $odd\
    \ ? shift @nums : shift @nums;\n    }\n    return @nums;\n}", "    my(@even_num);\n\
    \    my(@odd_num);\n    # find the even digit\n    for(my $i = 0; $i < $num; $i\
    \ += 2) {\n        if($num > $i) {\n            push(@even_num, $i);\n       \
    \ }\n    }\n    # find the odd digit\n    for(my $i = $num; $i >= 0; $i--) {\n\
    \        if($num > $i) {\n            push(@odd_num, $i);\n        }\n    }\n\
    \    return [@even_num,@odd_num];\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c\
    \ |>\nThat first one is wrong though! As it stands, it will always return 1, even\
    \ if the number is odd!\n<|/ c |>\n<| c |>\nThanks. I have updated the answer\
    \ according to your suggestion.\n<|/ c |>\n<| c |>\nPlease note this solution\
    \ does not actually work as expected for a negative number.\n<|/ c |>\n<| c |>\n\
    What about a negative number?\n<|/ c |>\n<| c |>\nIt returns `[1, 1]` for negative\
    \ numbers and `[1, 0]` for positive ones. A little nitpicking but just an FYI.\n\
    <|/ c |>\n<| a tags=perl,arrays dscore=3 |>\nThis one is even faster :)\n<code>",
  "    my($even_count, @odd_count);\n    my $remainder;\n    if ($num < 0) {\n   \
    \     $num *= -1;\n        $remainder = $num % 2;\n    } else {\n        $remainder\
    \ = 0;\n    }\n    my $count_even = 0;\n    while ($num >= 0) {\n        my $count_odd\
    \ = $remainder & 1;\n        $even_count[$count_even] += $count_odd;\n       \
    \ $num -= $count_odd;\n        $count_even += 1;\n        $remainder >>= 1;\n\
    \    }\n    @even_count = @odd_count = $count_even;\n    return @even_count ?\
    \ \\@even_count : @odd_count;\n}", "    if ($num < 0) {\n        return [-1, -1];\n\
    \    }", "    my($odd_digits, $even_digits);\n    \n    if ($num < 0) {\n    \
    \    my @tmp = even_odd_count(-$num);\n        $even_digits = $tmp[0];\n     \
    \   $odd_digits = $tmp[1];\n    }\n    else {\n        # Convert number to string.\n\
    \        my $num = abs($num);\n        my($num_str, $num_len) = even_odd_count($num);\n\
    \        $num_str = $num_str x $num_len;\n        $num_str =~ s/^\\s*//;\n   \
    \     $num_str =~ s/\\s*$//;", '    my(@result);', "    my(@results);\n    my($count\
    \ = $num);\n    my($odd, $even);\n    my($i, $j, $sum);", '    my(@digits);',
  "    return [1, 1] if $num eq -1;\n    my(@num_list) = ();\n    my($num_odd) = 0;\n\
    \    my($num_even) = 0;\n    while(my $n = $num) {\n        if($n % 2 != 0) {\n\
    \            $num_even += 1;\n        }\n        else {\n            $num_odd\
    \ += 1;\n        }\n        $num_list .= $n;\n        $num = int($num / 10);\n\
    \    }\n    return [$num_even, $num_odd];\n}", "    my @even_odd = ();\n    my\
    \ @digits;\n    my $i=0;\n    while ($num != 0) {\n        $digits[$i++]= $num\
    \ % 10;\n        $num = int(($num-$digits[$i]) / 10);\n    }\n    for (my $i=0;\
    \ $i < $#digits; $i++) {\n        if ($digits[$i] % 2 == 0) {\n            push(@even_odd,\
    \ $digits[$i]);\n        }\n    }\n    return \\@even_odd;\n}", "    my($odd,\
    \ $even);\n    my($count_odd);\n    my($count_even);", "    return $num / 2 ==\
    \ 1 ? [1,0] : [0,1];\n}", "    $num =~ s/^([+-])(\\d+)$/$1 ? ($2 % 2 ? 1 : 2)\
    \ : ($1 % 2 ? 2 : 0);\n    return map { ($num * 10) + $_ } (0, $num / 10);\n}",
  "    if($num == 0)\n        return [0, 0];\n    my @even;\n    my @odd;\n    $num\
    \ *= 10;\n    my $i = 0;\n    while($num > 0) {\n        my $rem = $num % 10;\n\
    \        $even[$i] = $rem;\n        $num -= $rem;\n        $num *= 10;\n     \
    \   $i++;\n    }\n    return \\@even, \\@odd;\n}", "    return @{$num == 0 ? []\
    \ : [$num % 10]};\n}", "    return [ length($num / 10), length($num % 10) if $num\
    \ % 10 ];\n}", "    my @num_array = ();\n    my $odd_count = 0;\n    my $even_count\
    \ = 0;\n    while (int($num / 10) > 0) {\n        push @num_array, $num % 10;\n\
    \        $odd_count++;\n        $num = $num / 10;\n    }\n    if (int($num / 10)\
    \ > 0) {\n        push @num_array, $num % 10;\n        $even_count++;\n    }\n\
    \    return @num_array;\n}", "    my @nums = ();\n    push @nums, 0 if $num <\
    \ 0;\n    push @nums, 1 if $num == 0;\n    push @nums, 2 if $num > 0 and $num\
    \ % 2 == 0;\n    push @nums, 0 if $num > 0 and $num % 2 != 0;\n    return @nums;\n\
    }", "    return if ($num < 0);\n    my($even, $odd) = (0, 0);", '    my @even_odd;',
  "    my(@even_odd_digits);\n    \n    for(my $i = -1; $i < $num; $i++) {\n     \
    \   my $remainder = $num % $i;\n        push @even_odd_digits, ($remainder % 2\
    \ == 0) ? 1 : 2;\n    }\n    \n    return @even_odd_digits;\n}", "    $num = $num\
    \ > 0 ? $num : $num + 42;\n    my @odd = ();\n    my @even = ();\n    for my $i\
    \ (0 .. $num) {\n        if ($num % $i == 0) {\n            push(@even, $i);\n\
    \        } else {\n            push(@odd, $i);\n        }\n    }\n    return \\\
    @even + \\@odd;\n}", "    my @result;\n    push(@result, $num & 1 ? \"even\" :\
    \ \"odd\");\n    push(@result, $num / 10 & 1 ? \"even\" : \"odd\");\n    push(@result,\
    \ $num / 100 & 1 ? \"even\" : \"odd\");\n    push(@result, $num / 1000 & 1 ? \"\
    even\" : \"odd\");\n    push(@result, $num / 10000 & 1 ? \"even\" : \"odd\");\n\
    \    push(@result, $num / 100000 & 1 ? \"even\" : \"odd\");\n    push(@result,\
    \ $num / 1000000 & 1 ? \"even\" : \"odd\");\n    push(@result, $num / 10000000\
    \ & 1 ? \"even\" : \"odd\");\n    push(@result, $num / 100000000 & 1 ? \"even\"\
    \ : \"odd\");\n    push(@result, $num / 1000000000 & 1 ? \"even\" : \"odd\");\n\
    \    push(@result, $num / 10000000000 & 1 ? \"even\" : \"odd\");\n    push(@result,\
    \ $num / 100000000000 & 1 ? \"even\" : \"odd\");\n    push(@result, $num / 1000000000000\
    \ & 1 ? \"even\" : \"odd\");\n    push(@result, $num / 10000000000000 & 1 ? \"\
    even\" : \"odd\");\n    push(@result, $num / 100000000000000 & 1 ? \"even\" :\
    \ \"odd\");\n    push(@result, $num / 1000000000000000 & 1 ? \"even\" : \"odd\"\
    );\n    push(@result, $num / 10000000000000000 & 1 ? \"even\" : \"odd\");\n  \
    \  push(@result, $num / 100000000000000000 & 1 ? \"even\" : \"odd\");\n    return\
    \ @result;\n}\n</code>\n<|/ a |>\n<| a tags=perl,algorithm |>\nThis is how I would\
    \ do it:\n<code>", '    my($counts) = ();', "    my @even_odd;\n    if ($num <\
    \ 0) {\n\tpush (@even_odd, 0, 0);\n    } else {\n\tfor (my $i = 0; $i < $num;\
    \ $i += 2) {\n\t    push (@even_odd, 1, 1);\n\t}\n    }\n    return @even_odd;\n\
    }", "    my $rev = $num > 0;\n    my @even_odd = ($num / 2, $num % 2);\n    if\
    \ ($rev) {\n        @even_odd\n            = reverse @even_odd if @even_odd[0]\
    \ < $even_odd[1];\n    }\n    return @even_odd;\n}", "    if ($num < 0) {\n  \
    \      return [-even_odd_count(-$num), -even_odd_count($num)];\n    }\n    my(@ret);\n\
    \    my $count = 1;\n    while ($num > 0) {\n        $num *= 10;\n        $count++;\n\
    \    }\n    for (1 .. $count) {\n        if ($num % 2 == 0) {\n            push,\
    \ $_;\n        } else {\n            push, $_;\n            last;\n        }\n\
    \    }\n    return @ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease see my\
    \ revised answer.  I believe this is more efficient.\n<|/ c |>\n<| a tags=perl\
    \ |>\nA pure perl solution.\n<code>\nuse strict;\nuse warnings;", "    my($even,$odd);\n\
    \    if($num < 0) {\n\treturn;\n    }\n    if($num == 0) {\n\treturn ($even,$odd);\n\
    \    }\n    $even = $odd = 0;\n    while($num > 0) {\n\t$num = $num / 10;\n\t\
    $even++;\n    }\n    while($num > 0) {\n\t$num = $num / 10;\n\t$odd++;\n    }\n\
    \    return ($even,$odd);\n}", "    my @retval = ();\n    if ($num eq 0) {\n \
    \       return @retval;\n    }\n    my $n = $num;\n    $n = abs($n);\n    my $odd\
    \ = $n&1;\n    $n>>= 1;\n    my $even = $n&1;\n    $n>>= 1;\n    my $temp = 0;\n\
    \    for(my $i = $odd; $i >= 0; $i--) {\n        if ($n&1) {\n            $n>>=1;\n\
    \            push @retval, 1;\n        } else {\n            push @retval, 0;\n\
    \        }\n    }\n    if ($even) {\n        push @retval, 1;\n    }\n    return\
    \ @retval;\n}", "    if ($num < 0) {\n        return [1, 1];\n    }\n    my($even_count,\
    \ $odd_count, $odd_value);\n    for ($num; $num > 0; $num = ($num / 10)) {\n \
    \       my $mod = ($num % 10);\n        if ($mod < 2) {\n            $even_count++;\n\
    \        } else {\n            $odd_value = $mod;\n            $odd_count = 1;\n\
    \        }\n    }\n    return [$even_count, $odd_count, $odd_value];\n}", '    my($even_num,
    $odd_num);', '    my @count;', "    if($num < 0){\n\treturn [1, 1];\n    }\n \
    \   \n    my($even, $odd);\n    my $num2 = $num;\n    $num2 += 0;\n    while ($num2\
    \ >= 10) {\n\t$even = add($even, $num2 % 10);\n\t$num2 /= 10;\n    }\n    while\
    \ ($num2 > 0) {\n\t$odd = add($odd, $num2 % 10);\n\t$num2 /= 10;\n    }\n    return\
    \ [$even, $odd];\n}", "    my @even = 1;\n    my @odd = $num / 2;\n    while ($num\
    \ > 0) {\n        $num = $num / 2;\n        if ($num == 0){\n            @even\
    \ = @even, @odd;\n        }\n        else{\n            @odd = @odd, @even;\n\
    \        }\n    }\n    if (@odd > 1){\n        push (@even, @odd);\n    }\n  \
    \  if (@even > 1){\n        push (@odd, @even);\n    }\n    return @even, @odd;\n\
    }", '    my(@odd, @even);', "    my($even, @odd);\n    if ($num < 0) {\n     \
    \   $num = abs($num);\n        my(@odd);\n    } else {\n        my(@odd);\n  \
    \  }\n    if ($num == 0 && @odd) {\n        @$even = @odd;\n        @odd = ();\n\
    \    } elsif (1 == @odd) {\n        $even = @odd;\n        @odd = ();\n    }\n\
    \    push(@$even, 0);\n    push(@$odd, 0);\n    while ($num) {\n        my($n)\
    \ =  $num % 10;\n        push(@$even, $n);\n        push(@$odd, 0);\n        $num\
    \ = $num / 10;\n    }\n    @$even = reverse @$even;\n    @$odd = reverse @$odd;\n\
    \    return [@$even, @$odd];\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI don't\
    \ think this should be the selected answer. Sure, it gives the correct solution,\
    \ but it's also far more complicated and less readable than a simpler solution\
    \ with fewer lines of code. Just my opinion.\n<|/ c |>\n<| c |>\nWhat is the complexity\
    \ of your solution? As far as I know, it is the same.\n<|/ c |>\n<| c |>\nIt's\
    \ not the same, there's a constant factor difference (in the size of the arrays).\
    \ Your solution creates a bunch of new arrays, one per digit, all of which are\
    \ destroyed immediately when they're no longer used. Your solutions creates just\
    \ one new array and pushes it onto the stack. Hence O(1) vs O(log n) difference.\
    \ But more importantly, your solutions don't work on negative numbers.\n<|/ c\
    \ |>\n<| c |>\nThe complexity of this solution is O(n) in the number of digits\
    \ in the input (assuming base 10). That means it only works for numbers up to\
    \ 10^8. Also, it doesn't work on negative numbers. But this is trivial to fix\
    \ since you always have the positive numbers in the evens and negative numbers\
    \ in the odds, so you just have to reverse them after you get the evens.\n<|/\
    \ c |>\n<| c |>\nOh, right. I was thinking that it was O(n * log n) because of\
    \ the sorting.\n<|/ c |>\n<| a tags=perl |>\n<code>", "    return ($num%2 == 0\
    \ ?  (@even_digits, @odd_digits) : (@odd_digits, @even_digits));\n}", '    my($even,$odd);',
  "    return $num if $num < 0;\n    my $odd_count = 0;\n    my $even_count = 0;\n\
    \    while (my $n = $num / 10) {\n        if ($n % 2 == 0) {\n            $even_count++;\n\
    \        } else {\n            $odd_count++;\n        }\n        $num = $n / 10;\n\
    \    }\n    return [$even_count, $odd_count];\n}", "    return map { $num % 2\
    \ == 0 ? 1 : 2 } $num / 2;\n}", "    return [0, 1] if $num == 0;\n    $num ==\
    \ -1 ? [0, 1] : [0, 0, 0];\n    for (my $i = 2; $i <=; $i++) {\n        $num %\
    \ $i == 0 && $num / $i == 0 || $num % $i == 1 && $num / $i == 1;\n    }\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nIf you want it to be in one line:\n<code>",
  "    return ($num % 2 == 0) ? [0 => 1] : [1 => 1];\n}", "    my $odd = 0, $even\
    \ = 0;\n    while (abs($num) > 0) {\n        my $remainder = $num % 10;\n    \
    \    my $num = $num / 10;\n        if ($remainder % 2 == 0) {\n            $even++;\n\
    \        }\n        else {\n            $odd++;\n        }\n    }\n    return\
    \ [$even, $odd];\n}", "    if($num < 0){\n        return [-1,1];\n    }\n    my\
    \ $arr = [0,1];\n    for(my $i = 2; $i <= $#$num; $i++){\n        my $even = ($num\
    \ % $i) == 0;\n        $arr[$i] = $even;\n    }\n    return $arr;\n}", "    my\
    \ @odd = ();\n    my @even = ();", "    $num =~ s/^\\s+//;\n    $num =~ s/\\s+$//;\n\
    \    $num =~ tr/+-/ /;\n    my($even, $odd) = (0,0);\n    while($num) {\n    \
    \    push(@even, $num % 2 );\n        $num /= 2;\n    }\n    while($num > 0) {\n\
    \        push(@odd, $num % 2 );\n        $num /= 2;\n    }\n    \n    return ($even,\
    \ @odd);\n}", "    my(@result) = (0, 0);\n    if ($num <= 0) {\n        return\
    \ @result;\n    }", "    my @nums = (&$num, $num / 10, $num / 100, $num / 1000);\n\
    \    my @even_nums;\n    my @odd_nums;\n    my $even = 0;\n    my $odd = 0;\n\
    \    my $odd_num = $num / 1000;\n    my $even_num = $num / 100;\n    foreach my\
    \ $num (@nums) {\n        if ($num % 2 == 0) {\n            $even++;\n       \
    \ }\n        if ($num % 2 != 0) {\n            $odd++;\n        }\n    }\n   \
    \ if ($odd > 0) {\n        $odd_nums[$odd - 1] = &$odd_num;\n    }\n    if ($even\
    \ > 0) {\n        $even_nums[$even - 1] = &$even_num;\n    }\n    return [@even_nums,\
    \ @odd_nums];\n}", '    my(@result);', "    $num += $num%10 while $num > 0;\n\
    \    my @odd = ();\n    my @even = ();\n    for(my $i = 0; $i < $num; $i++) {\n\
    \        if($num % 2 == 0) {\n            push(@even, $i);\n        } else {\n\
    \            push(@odd, $i);\n        }\n    }\n    return \\@even , \\@odd;\n\
    }", "    my $result = 0;\n    my $odd_count = 0;\n    my $even_count = 0;\n  \
    \  while ($num > 0) {\n        if ($num % 2 != 0) {\n            push (@$result,$num);\n\
    \            $even_count++;\n        }\n        else {\n            push (@$result,$num);\n\
    \            $odd_count++;\n        }\n        $num = ($num / 2);\n    }\n   \
    \ return ($even_count,$odd_count);\n}\n</code>\n<|/ a tags=algorithm,perl,arrays,math\
    \ dscore=2 |>\n<| c |>\nThanks Eli, that is a great idea - I've tried it and it\
    \ works fine. I am just wondering if there is a more efficient way to do it, perhaps\
    \ utilizing modulo (%) operator?\n<|/ c |>\n<| c |>\nI tested the code and the\
    \ speed is about 6 times faster than my solution (for 10^6 elements). Eli's solution\
    \ works also for positive integers. So I guess the modulo operator is indeed faster\
    \ than my solution. However, the time complexity of your solution is O(N^2). Not\
    \ bad, but still better to have O(N).\n<|/ c |>\n<| c |>\nthanks for the compliment,\
    \ I'll test it out and let you know. Interesting benchmark!\n<|/ c |>\n<| c |>\n\
    I added a benchmark to my answer. It seems to be the fastest solution in terms\
    \ of execution time.\n<|/ c |>\n<| c |>\nI changed it to work correctly for negative\
    \ numbers as well and it is a lot faster than my solution.\n<|/ c |>\n<| a tags=algorithm,perl,arrays,math\
    \ |>\n<code>", '    my @result;', "    my(@result) = ( 0, 0 );\n    until ( $num\
    \ == 0 ) {\n        push (@result, int( $num / 10 ) );\n        $num = int( $num\
    \ / 10 );\n    }\n    return @result;\n}", "    my(@odds);\n    my(@evens);",
  "    my @even_odd = ();\n    $num = abs($num);", "    my(@even_count, @odd_count);\n\
    \    if($num < 0){\n        my($i, $j) = @_;\n        @even_count = $i - 1;\n\
    \        $j = $i + 1;\n        my $x = $j - $i;\n        for(my $i = $j; $i <\
    \ $x; $i++){\n            push(@even_count, 0);\n        }\n    }\n    for(my\
    \ $i = 1; $i < $num; $i++){\n        if($num % $i == 0){\n            push(@odd_count,\
    \ $i);\n            push(@even_count, $num - $i);\n        }\n    }\n    if(@even_count\
    \ == 0 || @odd_count == 0){\n        if($num == 0){\n            push(@even_count,\
    \ 0);\n            push(@odd_count, 0);\n        }\n    }\n    return \\@even_count,\
    \ \\@odd_count;\n}\n</cell>\n<cell>", "    my(@counts);\n    my(@result);", " \
    \   my @result;\n    if($num < 0) {\n        $num += 2 ** 31;\n        push @result,\
    \ [0, 2];\n    }\n    elsif($num == 0 || !($num % 2)) {\n        push @result,\
    \ [1, 0];\n    }\n    else {\n        push @result, [0, 1];\n    }\n    foreach\
    \ my $i (0 .. @result - 1) {\n        my $odd = $result[$i][$i + 1] ? 1 : 0;\n\
    \        my $even = $result[$i][$i] ? 0 : 1;\n        push @result, [$odd, $even];\n\
    \    }\n    return @result;\n}", "    my @even;\n    my @odd;\n    while ($num\
    \ > 0) {\n        push @odd, int($num / 10) if $num % 10;\n        push @even,\
    \ $num % 10;\n        $num /= 10;\n    }\n    return @even, @odd;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI love the elegant code here but it doesn't work correctly.\
    \ For example: `even_odd_count(-1)` returns `[0, 0]`, which is not correct.\n\
    <|/ c |>\n<| a |>\nI think you are overthinking the problem. Something like this\
    \ would suffice.\n<code>", "    if($num < 0){\n\t$num *= -1;\n\t$num = -$num;\n\
    \    }\n    my($even_count, $odd_count) = (0, 0);\n    while($num != 0){\n\t$odd_count++\
    \ if($num & 1);\n\t$even_count++ if(!$num & 1);\n\t$num = ($num / 2);\n    }\n\
    \    return ($even_count, $odd_count);\n}", '    my(@result);', "    my($odds)\
    \ = $num % 2;\n    $num = abs($num);\n    $num > 0 ? ($num % 2 == 0 ? ($num ==\
    \ 1 ? 1 : 2) : ($num % 2 == 1 ? ($num == 1 ? 2 : 1) : $num)) : 1;\n}", "    my\
    \ @digits;\n    while ($num > 0) {\n        $digits[($num % 2 == 0)] += 1;\n \
    \       $num = int($num / 10);\n    }\n    return @digits;\n}", "    my @result\
    \ = ();\n    my $num_even = $num & 1;\n    my $num_odd = $num & 2;", '    my @result;',
  "    my;\n    my $count = 0;\n    while ($num != 0) {\n        $count++;\n     \
    \   $num *= 10;\n    }\n    if ($count % 2) {\n        push, $count;\n    }\n\
    \    else {\n        push, $count - 1;\n    }\n    return \\@num;\n}\n</code>\n\
    <|/ a tags=int,perl,arrays dscore=1 |>\n<| c |>\n`my = map { $num =~ /[02468]/\
    \ ? 1 : 2 } $num =~ /([123]|\\d)/ig;`\n<|/ c |>\n<| c |>\nOr even `my = map {\
    \ $num =~ /[02468]/ ? 1 : 2 } $num =~ /([1]|[2])([0]|[2])/g;` for the last one\
    \ :)\n<|/ c |>\n<| c |>\n, That only works as long as the inputs are all positive\
    \ numbers. That could lead to incorrect results if the numbers are negative and\
    \ are all odd.\n<|/ c |>\n<| a dscore=1 tags=int,perl,arrays |>\nI always think\
    \ about what this does:\n<code>\nmy = map { $num =~ /[02468]/ ? 1 : 2 } $num =~\
    \ /([123]|\\d)/ig;\n</code>\nIt finds numbers that match the regex ([02468]) and\
    \ either replaces them with 1 or 2 based on whether it's even or odd. Then it\
    \ finds strings that either start with 1 or 2 and ends with 0 or 2 based on whether\
    \ the number is odd.\nSo for example, \n<code>\n$num = \"11\";\n</code>\nbecomes\n\
    <code>\nmy = map { $num =~ /[02468]/ ? 1 : 2 } $num =~ /([123]|\\d)/ig;", "  \
    \  my(@ret);\n    # check number is positive\n    if ($num < 0) {\n        # negative\
    \ number is not counted\n        return $num;\n    }\n    # check even number\n\
    \    if ($num % 2 == 0) {\n        # even\n        push(@ret, 1);\n    } else\
    \ {\n        # odd\n        push(@ret, 2);\n    }\n    for(my $i = $num; $i >\
    \ 0; $i /= 2) {\n        push(@ret, $i);\n    }\n    return \\@ret;\n}", "   \
    \ if ($num < 0) {\n        $num = -$num;\n        return [$num, 1];\n    }\n \
    \   my(@count, $odd, $even);\n    for (my $i = 0; $i < $num; $i++) {\n       \
    \ if ($num % 2 == 0) {\n            $even++;\n        } else {\n            $odd++;\n\
    \        }\n    }\n    if ($odd == 0) {\n        return $even;\n    } else {\n\
    \        return $even;\n    }\n}", "    my(@output);\n    my($c1) = 0;\n    my($c2)\
    \ = 0;\n    my($digit);\n    my($temp_num);\n    my($odd_num);\n    my($even_num);\n\
    \    $num = $num * 10;\n    while(1) {\n        $digit = $num % 10;\n        if($digit\
    \ == 0) {\n            $even_num = $even_num + $digit;\n        }\n        else\
    \ {\n            $odd_num = $odd_num + $digit;\n        }\n        $temp_num =\
    \ $num / 10;\n        if($temp_num == 0)\n        {\n            $c1 = $c1 + $even_num;\n\
    \            $c2 = $c2 + $odd_num;\n            push @output, $c1;\n         \
    \   push @output, $c2;\n            $even_num = $odd_num = 0;\n            $c1\
    \ = 0;\n            $c2 = 0;\n            $num = -1;\n            last;\n    \
    \    }\n        else {\n            $num = $temp_num;\n        }\n    }\n    return\
    \ @output;\n}", "    my @result = ();\n    my $i = 0;\n    while ($num > 0) {\n\
    \        push @result, $num % 2;\n        $num = int($num / 10);\n        ++$i;\n\
    \    }\n    return @result;\n}", "    my(@odd_count, @even_count);\n    \n   \
    \ # even number counter\n    push @even_count, $num if $num & 1;\n    # odd number\
    \ counter\n    push @odd_count, ~$num if $num & -1;\n    return @even_count, @odd_count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI wrote the code and it works for the\
    \ test cases. But when I submit it on the judge, it says the output is not accepted.\
    \ I am not sure why. Maybe the output is not in the correct format? Please help.\n\
    <|/ c |>\n<| c |>\nThe output is fine for the test cases. But when I submit it,\
    \ it says it's not accepted. What do you think is the problem?\n<|/ c |>\n<| c\
    \ |>\nThe judge might be having difficulty with the test cases. Can you give an\
    \ example test case that isn't accepted? It might help debug.\n<|/ c |>\n<| c\
    \ |>\nYes, I submitted an example and it didn't accept it. The example is just\
    \ supposed to give me an output like yours. So I wrote this program and then submitted\
    \ it and it says it's not accepted. I am not sure if it's the problem of judge.\
    \ Maybe the output is not in correct format?\n<|/ c |>\n<| c |>\nThe only thing\
    \ I can think of, as I already pointed out, is that you are missing a newline\
    \ between outputs for even and odd digits. If you don't do that, judging programs\
    \ might not accept it.\n<|/ c |>\n<| a |>\nI wrote the code and it works for the\
    \ test cases. But when I submit it on the judge, it says the output is not accepted.\
    \ I am not sure why. Maybe the output is not in the correct format? Please help.",
  "    return $num > 0 ? even_odd_count($num / 2) + [($num % 2 != 0)] : [($num % 2\
    \ == 0)];\n}", "    my @even;\n    my @odd;\n    my $temp;\n    while ($num >\
    \ 0) {\n        $temp = $num % 10;\n        if ($temp == 0) {\n            @even\
    \ = @even, $temp;\n        } else {\n            @odd = @odd, $temp;\n       \
    \ }\n        $num = ($num / 10);\n    }\n    return [@even, @odd];\n}", "    my(@list);\n\
    \    for ($num) {\n        $num *= 10;\n        $list[0] += $num % 2;\n      \
    \  $list[1] += $num / 2;\n    }\n    return @list;\n}", "    my @even = ();\n\
    \    my @odd = ();\n    while(@even) {\n        push @odd, shift @even;\n    }\n\
    \    my $count = 0;\n    for(@odd) {\n        $count++ if $_ % 2;\n    }\n   \
    \ return ($count, $count);\n}", "    my @nums;\n    if ($num < 0) {\n        push(@nums,\
    \ 0);\n    } else {\n        my $i=1;\n        my $remainder;\n        while ($num\
    \ > 0) {\n            $remainder = $num % 10;\n            $num = $num / 10;\n\
    \            push(@nums, $remainder);\n            $i++;\n        }\n    }\n \
    \   return @nums;\n}", "    my($even_count,$odd_count);\n    if ($num < 0) {\n\
    \        $even_count = 1;\n        $odd_count = 1;\n    } elsif ($num == 0) {\n\
    \        return ($even_count,$odd_count);\n    } elsif ($num & 1) {\n        $even_count\
    \ += 1;\n    } else {\n        $odd_count += 1;\n    }\n    if ($even_count >\
    \ $odd_count) {\n        ($even_count, $odd_count) = (\"1\", $even_count);\n \
    \   }\n    return ($even_count, $odd_count);\n}", "    return @{$_[0]}[0,1] if\
    \ $num == 0;\n    my(@odd_nums,@even_nums) = (0, 0);\n    while($num > 0) {\n\
    \        push @even_nums, $num % 2 ? $num : 0;\n        $num = ($num - $even_nums[-1])\
    \ / 2;\n        push @odd_nums, $num % 2 ? $num : 0;\n    }\n    return (@even_nums,\
    \ @odd_nums);\n}\n</code>\nThis works by treating the input as two digits, then\
    \ doing division by 10 and taking the remainder after division.  If the remainder\
    \ is even, the number is even, otherwise, it is odd.  Thus, in the first digit,\
    \ the remainder is even, so the number is even, in the second digit, the remainder\
    \ is odd, so the number is odd.  It then adds the two digits, and repeats the\
    \ process until there is only one remainder, at which point the number is odd.\n\
    <|/ a |>\n<| c |>\nNice one, I was thinking the same thing about how you came\
    \ up with the solution. I've also been thinking about that and think it's quite\
    \ clever. Just thinking out loud, I think you could come up with a more efficient\
    \ solution by working backwards from the last digit and then working back from\
    \ the next digit.\n<|/ c |>\n<| a dscore=0 |>\nI do not know why you have used\
    \ the function eval($_[$i] . $_[$j]), but anyway, it works fine if you change\
    \ it to eval($_[$i] . \" . $_[$j]).\n<|/ a tags=perl |>\n<| c |>\nI didn't use\
    \ eval at all because I thought it would break anything. You're right though,\
    \ it's unnecessary. Thanks!\n<|/ c |>\n<| c |>\nNo, it won't. Perl will interpolate\
    \ the contents of `$_[0]` into a string and then pass that string to the eval\
    \ function. Of course you should be careful about what you are passing in to eval,\
    \ since it is dangerous to eval unsafe strings from unsafe users. You should also\
    \ be careful about what you are passing into eval, because it is dangerous to\
    \ eval unsafe strings from unsafe users. You should also be careful about what\
    \ you are passing into eval, because it is dangerous to eval unsafe strings from\
    \ unsafe users.\n<|/ c |>\n<| a |>\n<code>", '    my @result;', "    if ($num\
    \ < 0) {\n        return [-1 => $num];\n    } elsif ($num == $num) {\n       \
    \ return [0 => $num];\n    } else {\n        my($odd);\n        my($even);\n \
    \       if ($num % 2 == 0) {\n            $even = $num / 2;\n        } else {\n\
    \            $odd = $num / 2;\n        }\n        return [$even => $even, $odd\
    \ => $odd];\n    }\n}\n</code>\n<|/ a tags=arrays,perl,hash |>\n<| c |>\nPlease\
    \ note that my solution doesn't use hashes. I just want to keep things simple.\n\
    <|/ c |>\n<| c |>\nI think you need to fix your subroutine as it is giving you\
    \ an error for `$num` being an empty string. Other than that your solution is\
    \ good.\n<|/ c |>\n<| c |>\nThank you for the point. I updated my answer as suggested\
    \ in the comments.\n<|/ c |>\n<| c |>\nYour solution would be better if you made\
    \ it `$num =~ s/^(\\d)/ $1 % 2 ? $1 : ($1 / 2 )/g;` as it is now it will return\
    \ `0` for an empty string (`\"\"`).\n<|/ c |>\n<| c |>\nThank you for your suggestion.\
    \ I added your suggestion.\n<|/ c |>\n<| a dscore=2 tags=arrays,perl,hash |>\n\
    A simple one-liner:\n<code>\nmy = map {$_==1?1:$_==0?0:$_} grep {$_/2==0} map\
    \ {$_==0?$_:$_/2} map {$_==1?$_:$_/2} map {$_/2==0?$_:$_} map {$_/2} (-12,123,456,678,890);\n\
    </code>\n<|/ a |>\n<| c |>\nThis looks more like Perl 5 than Perl 5.10. If I write\
    \ it in my Perl 5 compiler I get an error \"syntax error at test.pl line 3, near\
    \ \"map {$_/2==0\"\nExecution of test.pl aborted due to compilation errors.\"\n\
    <|/ c |>\n<| c |>\nOh, I see why it wouldn't work... I'll have to re-write it\
    \ in Perl 5.10. Sorry for the mistake!\n<|/ c |>\n<| a tags=arrays,perl,hash |>\n\
    Here is an elegant answer using map (perl 5.10+):\n<code>\nmy = map { ($_*2)==$_/2\
    \ ? $_ : $_", "    my @count = (0,0);\n    while ($num > 0) {\n        $count[$_\
    \ % 2]++ for $_ =~ /(\\D+)(\\d)/;\n        $num--;\n    }\n    return @count;\n\
    }", "    my @even_odd = ();\n    \n    for (my $i = 0; $i < $num; $i++) {\n  \
    \      my $j = $num - $i;\n        \n        if ((($j % 2) == 0) || (($j % 2)\
    \ == 1)) {\n            push(@even_odd, $j);\n        }\n    }\n    return @even_odd;\n\
    }\n</cell>\n<cell>", "    my(@result);\n    my($num_even_digits, $num_odd_digits);",
  "    if ($num < 0) {\n        die \"even_odd_count() argument should be a nonnegative\
    \ integer\\n\";\n    }\n    my @even = ();\n    my @odd = ();\n    while (--$num)\
    \ {\n        $even[$_ % 2] //= 0 if $even[$_ % 2] eq 0;\n        $odd[$_ % 2]\
    \ //= 1 if $odd[$_ % 2] eq 1;\n    }\n    return [@even, @odd];\n}", "    if (\
    \ $num < 0 ) {\n        return ([0,0], [1,0]);\n    }", "    my @num = ($num,\
    \ $num / 10);\n    if ($num % 10 == 0){\n        $num++;\n    }\n    push (@num,\
    \ $num);\n    return @num;\n}\n</code>\n<|/ a tags=math,algorithm,mathematical-optimization,perl\
    \ |>\n<| c |>\nI didn't think about that situation. I guess that will be the most\
    \ simple solution.\n<|/ c |>\n<| c |>\nThat is not correct - you still need to\
    \ calculate the sum of even and odd digits in order to calculate even and odd\
    \ digits separately.\n<|/ c |>\n<| a dscore=0 |>\nThis is my implementation of\
    \ algorithm:\n<code>", "    my(@even_odd_digits);\n    my $digits = $num > 0 ?\
    \ $num : -$num;\n    my $remainder = 0;\n    while(0 < $digits) {\n        $remainder\
    \ = $digits % 10;\n        unless(defined $even_odd_digits[$remainder]) {\n  \
    \          $even_odd_digits[$remainder] = 1;\n        }\n        $digits = $digits\
    \ / 10;\n    }\n    return @even_odd_digits;\n}", "    my(@even, @odd);\n    if\
    \ ($num <= 0) {\n        return ([$num] , $num);\n    }", "    my(@result);\n\
    \    my $count = 1;\n    while (abs($num) >= 10) {\n        $num /= 10;\n    \
    \    $count += 1 if $num == 0;\n        $num /= 10;\n        $count += 1 if $num\
    \ == 0;\n    }\n    @result = grep($_ % 2 != 0, @result);\n    @result = grep($_\
    \ % 2 == 0, @result);\n    return @result;\n}", "    my(@even_odd_counts);\n \
    \   $even_odd_counts[0] = 0;\n    $even_odd_counts[1] = 0;", "    if($num == 0)\
    \ {\n        return [0, 0];\n    }\n    \n    my($num_even, $num_odd);\n    $num_even\
    \ = int(($num / 2) / 2);\n    $num_odd = $num_even - $num_even;\n    \n    return\
    \ [$num_even, $num_odd];\n}", "    return ([0, $num/2] if $num != 0);\n}", " \
    \   return 1 unless $num > 0;\n    my @even_odd = ();\n    my $even_odd_cnt =\
    \ 0;\n    while ($num) {\n        my($digit) = int $num % 10;\n        if ($even_odd_cnt\
    \ % 2 == 0) {\n            push(@even_odd, $digit);\n        }\n        $even_odd_cnt\
    \ += $even_odd_cnt % 2;\n        $num = int($num / 10);\n    }\n    return @even_odd;\n\
    }", '    my(@even_digits, @odd_digits);', "    my @array;\n    my $count = 0;",
  "    my($digit, $even_odd, @odd_digits);\n    my(@odd_digits, @even_digits);\n \
    \   my(@digit_array, @even_array);\n    while ($num > 0) {\n        if ($num &\
    \ 1) {\n            push(@even_digits, $num % 10);\n            push(@even_array,\
    \ $num % 10);\n        }\n        $num = $num / 10;\n    }\n    \n    for (my\
    \ $i = 0; $i <; $i++) {\n        if ($even_digits[$i] % 2 == 0) {\n          \
    \  push(@even_digits, $even_digits[$i]);\n            push(@even_array, $even_array[$i]);\n\
    \        }\n    }\n    \n    for (my $i = 0; $i <; $i++) {\n        if ($even_digits[$i]\
    \ % 2 == 1) {\n            push(@odd_digits, $even_digits[$i]);\n            push(@odd_array,\
    \ $even_array[$i]);\n        }\n    }\n    \n    @odd_digits;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThanks for your solution. Can you please explain the\
    \ difference between your program and mine?\n<|/ c |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/18256446)\n\
    <|/ c |>\n<| c |>\nIt was my solution (which I used on my own computer) and it\
    \ didn't work. I had to put in some effort to figure out why it didn't work. But\
    \ since that I have edited the answer. Thank you.\n<|/ c |>\n<| c |>\nThis is\
    \ not a solution.  This is a critique.\n<|/ c |>\n<| a |>\n<code>\ndef odd_even(x):\n\
    \    if x < 0:\n        return [x, 0]\n    else:\n        odd_count = 0\n    \
    \    even_count = 0\n        while x > 0:\n            if x % 2 == 0:\n      \
    \          even_count += 1\n            elif x % 2 == 1:\n                odd_count\
    \ += 1\n            x /= 2\n        return even_count, odd_count\n</code>\n<|/\
    \ a tags=algorithm,python,ruby,ruby-on-rails,c dscore=2 |>\n<| c |>\nHi, welcome\
    \ to Stack Overflow! If you could add some explanation, that'd be helpful.\n<|/\
    \ c |>\n<| c |>", "    return [0, 1, 2] if ($num < 0);\n    my($odd, $even);\n\
    \    my($i, $j);\n    $even = $odd = 0;\n    $num = abs($num);\n    for($i = 0;\
    \ $i <= $#num; $i++) {\n        $j = $i + 1;\n        $odd += $num[$i] & 1;\n\
    \        $even += $num[$i] & 2;\n        $num[$i] &= 3\n            if $num[$i]\
    \ & 4;\n    }\n    return [\n        $even, $odd \n    ];\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is really cool -- thanks for sharing. Do you know how I can\
    \ use it to get the positions of the even and odd digits?\n<|/ c |>\n<| c |>\n\
    - I've edited my answer to include the positions of the digits in the array. This\
    \ will give you the positions of the even and odd numbers, as well as whether\
    \ or not they are divisible by 2. The only thing left is to get rid of the zeroes\
    \ on the left side of the array.\n<|/ c |>\n<| c |>\n, Thanks so much!\n<|/ c\
    \ |>\n<| a tags=arrays,perl,sorting,algorithm |>\nYou can solve this in O(n log\
    \ n) time with the help of a hash table.\nLet me illustrate with an example. Say\
    \ you have an array [5, 7, 2, 9]. First sort it. And you get the array [2, 1,\
    \ 5, 7, 9].\nNow, loop over the array and for each index i, keep a hash table\
    \ with values as the number of occurrences of i in the sorted array.\n<code>\n\
    use strict;\nuse warnings;", "    my @arr;\n    \n    # count even and odd digits\n\
    \    my $even = 0;\n    my $odd = 0;\n    while($num) {\n        my $remainder\
    \ = $num % 10;\n        my $tmp = $num;\n        $num = $remainder / 10;\n   \
    \     \n        if($remainder == 0) {\n            $even++;\n        }\n     \
    \   else {\n            $odd++;\n        }\n    }\n    \n    push (@arr, $even);\n\
    \    push (@arr, $odd);\n    \n    return @arr;\n}", "    my %even = map { $_\
    \ => 1 } 1 .. 10;\n    my %odd = map { $_ => 2 } 10 .. $num;\n    my @list = ();\n\
    \    for my $key (keys %even) {\n        if ($odd{$key}) {\n            push(@list,\
    \ $key);\n        }\n    }\n    return @list;\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThis is good, though the OP asked for a sub solution.  That will make\
    \ this a lot simpler.\n<|/ c |>\n<| c |>\nThis fails for input `-99`. It should\
    \ return `[-2, -1]`.\n<|/ c |>\n<| c |>\n: How do you get `[-2, -1]` for `-99`?\
    \ The algorithm I wrote does return `[-2, -1]`.\n<|/ c |>\n<| c |>\n`even_odd_count(-99)`\
    \ should return `[-2, -1]`.\n<|/ c |>\n<| a tags=algorithm,math,perl |>\nYou could\
    \ use bc and grep to accomplish this:\n<code>", "    $num = 0 if $num < 0;\n \
    \   my(@array);\n    my($odd, $even);\n    while (1) {\n        $odd = $num %\
    \ 10;\n        push(@array, $odd if $odd % 2 == 1);\n        $num = ($num - $odd)\
    \ / 10;\n        last if $num == 0;\n        $even = $num % 10;\n        push(@array,\
    \ $even if $even % 2 == 0);\n        $num = ($num - $even) / 10;\n    }\n    return\
    \ @array;\n}", "    if ( ! $num) {\n        return [0, 0];\n    }\n    my $odd_count\
    \ = 0;\n    my $even_count = 0;\n    my $odd_digit = 0;\n    my $even_digit =\
    \ 0;\n    while ( ($num > 0) && ($num % 2 != 0)) {\n        $odd_digit++;\n  \
    \      $num = $num / 2;\n    }\n    while ( $num > 0) {\n        $even_digit++;\n\
    \        $num = $num / 2;\n    }\n    return [$even_digit, $odd_digit];\n}\n</code>\n\
    <|/ a dscore=0 tags=perl |>\n<| a tags=perl |>\nAn example that uses a regex:\n\
    <code>\nuse warnings;\nuse strict;", "    my(@ret) = ();\n    # Convert to a positive\
    \ number\n    $num = $num if $num < 0;\n    my $rem;\n    my $num2 = $num;\n \
    \   until ($rem = $num2 % 10) {\n        $num2 = $num2 / 10;\n    }\n    # Evens\n\
    \    while (1) {\n        $num2 = $num2 / 10;\n        push (@ret, 0) if $num2\
    \ % 2 == 0;\n        push (@ret, 1) if $rem == 0;\n        if ($num2 < 1) {\n\
    \            last;\n        }\n    }\n    # Odds\n    while (1) {\n        $num2\
    \ = $num2 / 10;\n        push (@ret, 0) if $num2 % 2 == 1;\n        push (@ret,\
    \ 2) if $rem == 1;\n        if ($num2 < 1) {\n            last;\n        }\n \
    \   }\n    return @ret;\n}", "    my($even_odd);\n    if($num < 0) {\n       \
    \ $even_odd = [\n            $num =~ /(^|\\s)([1-9])/ && $1,\n            $num\
    \ =~ /(^|\\s)([3-9])/  && $1,\n            $num =~ /(^|\\s)(5[0-2])/ && $1,\n\
    \            $num =~ /(^|\\s)(7[0-4])/ && $1,\n            $num =~ /(^|\\s)(9[0-8])/\
    \ && $1,\n        ];\n    }\n    elsif(not($num == 0)) {\n        $even_odd =\
    \ [\n            $num =~ /(^|\\s)([1-9])/ && $1,\n            $num =~ /(^|\\s)([3-9])/\
    \  && $1,\n            $num =~ /(^|\\s)(5[0-2])/ && $1,\n            $num =~ /(^|\\\
    s)(7[0-4])/ && $1,\n            $num =~ /(^|\\s)(9[0-8])/ && $1,\n        ];\n\
    \    }\n    return $even_odd;\n}", "    my($even, $odd);\n    if ($num < 0) {\n\
    \        $even = $odd = 0;\n    }\n    else {\n        $even = 0;\n        $odd\
    \ = 1;\n    }\n    for (my $i = $num; $i > 0; $i -= $num) {\n        if ($i &\
    \ 1) {\n            $odd++;\n        }\n        else {\n            $even++;\n\
    \        }\n    }\n    return ($even, $odd);\n}", "    if($num < 0){\n       \
    \ my @even;\n        my @odd;\n        push @odd, $num % 10;\n        push @even,\
    \ $num / 10;\n        return [@even, @odd];\n    }\n    my @even;\n    my @odd;\n\
    \    for(my $i = 0; $i < $num; $i++){\n        if($num % 2 == 0){\n          \
    \  push @even, $num % 10;\n        }\n        else{\n            push @odd, $num\
    \ % 10;\n        }\n        $num = int($num / 10);\n    }\n    return [@even,\
    \ @odd];\n}", "    my($even_counter, @odd_counter);\n    \n    for(my $i = 0;\
    \ $i < $num; $i++){\n        $even_counter += ($num % 2 == 0);\n        $odd_counter\
    \ += ($num % 2 != 0);\n    }", '    return if $num < 0;', "    my@odds = ();\n\
    \    my@evens = ();\n    \n    my $num_str = to_string($num);\n    \n    # if\
    \ the number is negative ignore it\n    if ($num_str =~ /^-?\\d+$/) {\n      \
    \  my $len = length($num_str);\n        \n        # even number of digits\n  \
    \      for ($i = 0; $i < $len; $i++) {\n            my $digit = $num_str->[$i];\n\
    \            if ($digit =~ /[02-9]/) {\n                push(@evens, $digit);\n\
    \            }\n        }\n        \n        # odd number of digits\n        for\
    \ ($i = 0; $i < $len; $i++) {\n            my $digit = $num_str->[$i];\n     \
    \       if ($digit !~ /[02-9]/) {\n                push(@odds, $digit);\n    \
    \        }\n        }\n    }\n    \n    return [@evens, @odds];\n}", "    my @result;\n\
    \    for(my $i=$num; $i>0; $i/=2) {\n        push (@result, $i/2);\n    }\n  \
    \  for(my $i=$num; $i>0; $i/=2) {\n        push (@result, $i%2);\n    }\n    \n\
    \    return @result;\n}", "    my;\n    $num = 0 + $num;\n    while ($num > 0)\
    \ {\n        $even = $num % 2;\n        $odd = $num % 10;\n        $array[$even]\
    \ ++ ;\n        $array[$odd] ++ ;\n        $num = int($num / 10);\n    }\n   \
    \ return \\@array;\n}", "    if($num <= 0) {\n        die \"even_odd_count requires\
    \ a positive integer\";\n    }\n    my(@digits) = (1,1);\n    while($num > 0)\
    \ {\n        ($num,$remainder) = div($num,10);\n        push (@digits, ($remainder\
    \ % 2) );\n    }\n    return @digits;\n}", "    if ($num < 0) {\n        $num\
    \ *= -1;\n        $num += (1/$num);\n    }", "    if ($num < 0) {\n        die(\"\
    Error: Negative Number\");\n    }\n    my @even = ();\n    my @odd = ();\n   \
    \ while (1) {\n        my $n = $num / 10;\n        unless ($n) {\n           \
    \ push(@even, 0);\n            push(@odd, 0);\n            return [@even, @odd];\n\
    \        }\n        push(@even, $n % 2);\n        push(@odd, $num % 10);\n   \
    \     $num = $n / 10;\n    }\n}", "    my @result = ();\n    my @temp;\n    \n\
    \    foreach my $d (split('', $num)) {\n\tpush(@temp, $d % 2);\n    }\n    \n\
    \    if (@temp > 0) {\n\tpush(@result, $temp[0]);\n    }\n    \n    foreach my\
    \ $d (split('', $num)) {\n\tpush(@result, $temp[$#temp]);\n    }\n    \n    return\
    \ @result;\n}", '    my @even_odd;', "    my @even = ();\n    my @odd = ();\n\
    \    while ($num >= 0) {\n        if ($num % 2 == 0) {\n            push(@even,\
    \ $num);\n        } else {\n            push(@odd, $num);\n        }\n       \
    \ $num = ($num - $num % 2);\n    }\n    return \\@even, \\@odd;\n}", "    my($even,\
    \ $odd);\n    if ($num < 0) {\n        $num = -$num;\n        $even = $odd = -1;\n\
    \    }\n    elsif ($num == 0) {\n        return ($even, $odd);\n    }\n    elsif\
    \ ($num >= 10) {\n        my $nums = 10 ** $odd;\n        $odd += $nums - $num;\n\
    \        $even = ($num - $nums) % $nums;\n    }\n    elsif ($num >= 5) {\n   \
    \     $even = $num;\n        $odd += $num - $even;\n    }\n    return ($even,\
    \ $odd);\n}", "    if($num < 0) {\n        Carp::croak(\"negative argument not\
    \ allowed\");\n    }\n    my $count = int((log($num)/log(2))+1);\n    my @nums\
    \ = ();\n    for(my $i=0; $i<$count; $i++) {\n        my $n = int((((log($num)/log(2))+$i)*log(2))+1);\n\
    \        push(@nums, $n-1);\n    }\n    return @nums;\n}\n1;\n__END__", "    if\
    \ ($num < 0) {\n        $num *= -1;\n    }", "    my $result = [];\n    while\
    \ ($num != 0) {\n        my($remainder, $quotient) = ($num % 10, $num / 10);\n\
    \        $result[$quotient] = $remainder == 0 ? $quotient : 2;\n        $num =\
    \ $quotient;\n    }\n    return $result;\n}", "    my($even, $odd) = (0, 0);\n\
    \    while ( ($num/10) % 2 ) {\n        $odd++;\n        $num = $num/10;\n   \
    \ }\n    while ($num) {\n        $even++;\n        $num = $num/10;\n    }\n  \
    \  return [$even, $odd];\n}", "    my($even, $odd);\n    my($i) = 0;\n    my($j,\
    \ $digit);\n    while($num) {\n        $digit = substr($num, ++$i, 1);\n     \
    \   if ($digit =~ m/^0$/) { $even++ }\n        else { $odd++ }\n    }\n    return\
    \ ([$even, $odd]);\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nThis answer\
    \ doesn't use `sub`s which is why it doesn't use subroutines such as `grep` or\
    \ `map`. As a result the function isn't re-usable.\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\nAnother approach could be using regex and substitution\n<code>\n$ perl -E\
    \ \"$_ = '-123'; s/(-?\\d+)(\\d{2})/$1 ^ $2/g; say\"\n1 1\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis answer doesn't use `sub`s which is why it doesn't use subroutines\
    \ such as `grep` or `map`. As a result the function isn't re-usable.\n<|/ c |>\n\
    <| a dscore=1 tags=perl,regex |>\nA one-liner solution:\n<code>\nperl -E '$x=\"\
    -123\";$x=~s/(\\d+)/($1 ^ $2)/eg; print $x'\n</code>\nOutput:\n<code>\n1 1\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nThe question is tagged with Perl, but doesn't use\
    \ subroutines such as grep or map. \nUsing subroutines such as grep or map makes\
    \ this solution difficult to re-use. Instead the function should be written in\
    \ terms of subroutines.\nThe solution below uses no subroutines at all. The regex\
    \ /-?\\d+/g returns an array of matches. These matches are mapped to numbers and\
    \ then they are joined to return the required string.\n<code>\nuse strict;\nuse\
    \ warnings;", "    my(@even_odd_num);\n    my @number = split(//, $num);\n   \
    \ foreach(@number) {\n        if($_ % 2 == 0) {\n            push(@even_odd_num,\
    \ $_);\n        }\n    }\n    return \\@even_odd_num;\n}\n</code>\n<|/ a tags=arrays,perl\
    \ |>\n<| a |>\nThe code below uses Tie::Enumerator to convert an arrayref of numbers\
    \ into an array whose elements are the numbers and their position in the original\
    \ array:\n<code>", "    my($result);\n    my($odd);\n    my($even);\n    $result\
    \ = [];\n    for(my $i = 0; $i < $#_; $i++) {\n        $num = $_[$i];\n      \
    \  if(($i % 2) == 1) {\n            $odd = $num % 10;\n            $even = ($num\
    \ / 10) % 2;\n            $result[$i][1] = $even;\n            $result[$i][1]\
    \ += $odd;\n        } else {\n            $odd = $num % 10;\n            $even\
    \ = ($num / 10) % 2;\n            $result[$i][1] = $odd;\n            $result[$i][1]\
    \ += $even;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nOne of the solutions would be the following\n<code>\n$even_odd\
    \ = [[],[]];\n$even_odd[$_ % 2][$_ / 2] = $_;\n</code>\n<|/ a dscore=0 tags=perl\
    \ |>\n<| a dscore=0 |>\nA solution without looping.\n<code>", "    my(@even_digits,\
    \ @odd_digits);\n    my $len = length($num);\n    while($len > 0) {\n        my\
    \ $digit = $num % 10;\n        if ($digit % 2 != 0) {\n            push(@odd_digits,\
    \ $digit);\n        } else {\n            push(@even_digits, $digit);\n      \
    \  }\n        $num = ($num - $digit) / 10;\n        $len--;\n    }\n    return\
    \ (\\@even_digits, \\@odd_digits);\n}\n</code>\n<|/ a tags=math,algorithm,ruby,arrays\
    \ |>\n<| c |>\nThe OP's question specifies that he does not want to use a prebuilt\
    \ function.\n<|/ c |>\n<| c |>\nThis is an excellent answer, but it's very slow.\n\
    <|/ c |>\n<| c |>\n: I added a couple of optimizations, although it's possible\
    \ the OP would just prefer a simpler method.\n<|/ c |>\n<| c |>\nThat's not what\
    \ he asked for :p\n<|/ c |>\n<| c |>\nI suppose that's what he meant.\n<|/ c |>\n\
    <| a tags=math,algorithm,ruby,arrays dscore=2 |>\nYou can use recursion to do\
    \ this without using any prebuilt functions. Here is a working Ruby example:\n\
    <code>\ndef even_odd_count(n)\n  return [1, 1] if n < 0\n  return [1, 0] if n\
    \ == 0", "    my(@results);\n    if ($num < 0) {\n        push(@results, -1);\n\
    \        push(@results, -1);\n    } else {\n        my($n);\n        while (1)\
    \ {\n            $n = $num % 10;\n            $num = $num / 10;\n            push(@results,\
    \ $n % 2 ? 1 : 2);\n        }\n    }\n    return @results;\n}", '    my(@counts);',
  "    $num > 0 && $num < 10_000 ?\n        [($num / 2 % 2 == 0), ($num / 2 % 2 !=\
    \ 0)] :\n        [0, 0];\n}", "    my @even = ();\n    my @odd = ();\n    while\
    \ ( ($num > 0) and ($num % 2 == 0) ) {\n        $even[$_] = $num % 2;\n      \
    \  $num = $num / 2;\n    }\n    while ($num > 0) {\n        $odd[$_] = $num %\
    \ 2;\n        $num = $num / 2;\n    }\n    return (\\@even, \\@odd);\n}", "  \
    \  my(@result);\n    my($numStr);\n    my($even, $odd);\n    # check if the number\
    \ is negative.\n    if ($num < 0) {\n        $numStr = \"-$num\";\n    } else\
    \ {\n        $numStr = $num;\n    }\n    # loop through the number's digits.\n\
    \    for ($numStr =~ /(\\d+)/) {\n        # check if it is a even or odd number\n\
    \        if ($1 % 2 == 0) {\n            $even++;\n        } else {\n        \
    \    $odd++;\n        }\n    }\n    # populate the array with numbers\n    for\
    \ ($even; $even < $odd; $even++) {\n        push(@result, $even);\n    }\n   \
    \ return @result;\n}", '    my @nums = ($num);', "    my @even;\n    my @odd;\n\
    \    while (@$num) {\n        my $tmp = $$num{pop};\n        $odd[0] //= $tmp\
    \ % 2;\n        $even[0] //= $tmp // 2;\n    }\n    return \\@even + \\@odd;\n\
    }", "    my @a = ();\n    if ($num < 0) {\n        $num *= -1;\n        push @a,\
    \ -1;\n    }\n    my $n = 0;\n    while ($num > 0) {\n        $num *= 10;\n  \
    \      push @a, $n % 2;\n        $n /= 2;\n    }\n    return @a;\n}", "    my\
    \ @even = ();\n    my @odd = ();\n    for (my $i=0; $i<$num; $i++) {\n       \
    \ $even[$i] =\n            if ($num%2 != 0 && $num%100 != 0) {\n             \
    \   push (@odd, $num%10);\n                pop (@even);\n            }\n     \
    \       $even[$i] =\n                if ($num%2 == 0 && $num%100 != 0) {\n   \
    \                 push (@even, $num%10);\n                    pop (@odd);\n  \
    \              }\n            $even[$i] =\n                if ($num%2 == 0 &&\
    \ $num%100 == 0) {\n                    push (@odd, $num%10);\n              \
    \      pop (@even);\n                }\n            $even[$i] =\n            \
    \    if ($num%2 != 0 && $num%100 == 0) {\n                    push (@even, $num%10);\n\
    \                    pop (@odd);\n                }\n    }\n    return [@even,@odd];\n\
    }", "    my @even_count; \n    my @odd_count;\n    \n    for (my $i = 0; $i <\
    \ $num; $i+=2) {\n        push @even_count, $i;\n    }\n    \n    for (my $i =\
    \ $num; $i < $num + 4; $i+=2) {\n        push @odd_count, $i;\n    }\n    \n \
    \   my $ret = [@even_count, @odd_count];\n    return $ret;\n}", "    $num =~ s/-inf//;\
    \ # remove -inf\n    return unless $num;", "    my @result;\n    for (my $i =\
    \ 0; $num > 0; ++$i) {\n        if ($num % 2 != 0) {\n            push @result,\
    \ $i;\n        }\n        elsif ($num % 2 == 0) {\n            push @result, $i;\n\
    \        }\n        $num = int($num / 2);\n    }\n    return @result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nI find this a simpler and clearer solution in Python\
    \ 3. \nThe function even_odd_count(x) is simply counting the even and odd digits\
    \ in x, and returning an array with the counts of those digits. \n<code>\ndef\
    \ even_odd_count(x):\n  counts = []\n  for i in str(x):\n    if (i%2 == 0):\n\
    \      counts.append(1)\n    else:\n      counts.append(0)\n  return counts\n\
    </code>\n<|/ a tags=perl,numbers dscore=1 |>\n<| a dscore=0 |>\nUsing Moo's regexp:\n\
    <code>\nmy $n = '-12';", "    my @res = ();\n    while (1) {\n        push(@res,\
    \ $num % 2);\n        $num = $num / 10;\n        if ($num == 0)\n        {\n \
    \           last;\n        }\n    }\n    return @res;\n}", "    my(@odd) = ();\n\
    \    my(@even) = ();\n    for(my $i = 1; $i < $num; $i++) {\n        if($num %\
    \ $i == 0) {\n            push @even, $i;\n        } else {\n            push\
    \ @odd, $i;\n        }\n    }\n    return ($even, @odd);\n}", "    my($odd, $even);\n\
    \    my($i, $count);", "    $num = 0 unless $num;\n    my = ();\n    $count[1]\
    \ = $count[2] = 0;\n    while ($num) {\n        my $a = $num % 10;\n        push(@even,\
    \ $a) if $a % 2 != 0;\n        $num = int($num / 10);\n        push(@odd, $num)\
    \ if $num % 2 != 0;\n        $count[$_] += 1 for;\n    }\n    return;\n}", " \
    \   my($even, $odd, $i);\n    $num =~ /^(\\-|\\+)?([1-9])$/;\n    $even = $1 ?\
    \ ($1 < 2 ? 1 : 0) : 0;\n    $odd = $1 ? ($1 < 2 ? 2 : 1) : 0;\n    $i = 0;\n\
    \    while($num > 0) {\n        $i += ($num % 10 == 0 ? $even : $odd);\n     \
    \   $num = int($num / 10);\n    }\n    return $i;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nYeah but if you take in negative numbers, it returns 1 instead of 0, which\
    \ isn't what OP wants. And besides, I doubt a regex is going to be faster here.\n\
    <|/ c |>\n<| c |>\n: Thanks for pointing it out. I have modified the code so that\
    \ it returns 0 instead of 1.\n<|/ c |>\n<| c |>\n: I agree that regex is not going\
    \ to be faster here. But I was trying to give a solution that was close to OP's\
    \ code (which was in Perl) and then decided to try my hand at it in Python. So,\
    \ I did not think that the `regex` tag was relevant here.\n<|/ c |>\n<| c |>\n\
    : You might want to consider `return 0 if ($num == 0);` instead of `return 1 if\
    \ ($num == 0);`, since 0 evaluates to true, and `if` evaluates to false otherwise.\n\
    <|/ c |>\n<| c |>\n: That's a nice suggestion.\n<|/ c |>\n<| a |>\nHere is my\
    \ solution to your problem. \n<code>\ndef even_odd_count(n):\n    count = 0\n\
    \    while n > 0:\n        count = (n%10) + count\n        n = n//10\n    return\
    \ count", "    my @res;\n    my $evens = 0;\n    my $odds = 0;\n    while ($num\
    \ != 0) {\n        $evens = $num % 2 ? $evens + 1 : 0;\n        $num =~ s/^0*(\\\
    d)/$1/g;\n    }\n    return [@res, $evens, $odds];\n}", "    if ( $num < 0 ) {\n\
    \        throw(\"$num is not a number\");\n    }\n    if ($num == 0 ) {\n    \
    \    return [0, 0];\n    }\n    my $count = [0, 0];\n    while ( $num > 0 ) {\n\
    \        $count = $count[0] + $_ % 2 == 0;\n        $num = $num / 2;\n    }\n\
    \    return $count;\n}", "    my(@arr);\n    for(my $i = $num; $i >0; $i/=2) {\n\
    \        push(@arr, $i/2);\n    }\n    for(my $i = $num; $i > 0; $i/= 2) {\n \
    \       push(@arr, $i);\n    }\n    return @arr;\n}", "    return () if $num <\
    \ 0;\n    my($num_even, $num_odd);", "    my @arr = ();\n    my $i = 0;\n    while\
    \ (1) {\n        $i++;\n        if ($num < 0) {\n            push(@arr, $i, 0);\n\
    \            last;\n        } elsif ($num == 0) {\n            push(@arr, $i,\
    \ 0);\n            last;\n        }\n        if ($num / 2 == 0) {\n          \
    \  push(@arr, $i, 1);\n            $num -= 1;\n        } else {\n            push(@arr,\
    \ $i, 0);\n        }\n    }\n    return \\@arr;\n}", "    my($count, @result)\
    \ = (0, 0);\n    while($num > 0) {\n        $count = $num % 2 == 0 ? $count +\
    \ 1 : 0;\n        $num = int($num / 10);\n    }\n    push (@result, @$count);\n\
    \    return @result;\n}", "    my @a = map { $num % 2 == 0 ? ($_ + 1) : ($_ +\
    \ 0) } 0 .. $num;\n    return @a;\n}\n</cell>\n<cell>", "    if ($num == 0) {\n\
    \        return [1, 1];\n    }\n    my $even = 0;\n    my $odd = 0;\n    my $total\
    \ = $num;\n    while ($total != 0) {\n        $total = ($total % 10);\n      \
    \  if ($total % 2 == 0) {\n            $even++;\n        }\n        else {\n \
    \           $odd++;\n        }\n    }\n    return [$even, $odd];\n}", '    my
    @result;', "    return map { $num % 2 == 0 ? 1 : 2 } $num =~ /(\\d+)/g;\n}", '    return
    () if $num < 0;', "    my($even, $odd) = (1, 1);\n    while($num > 0) {\n    \
    \    if($num % 2 == 0) {\n            $even++;\n        } else {\n           \
    \ $odd++;\n        }\n        $num =~ s/^0*//;\n    }\n    return ($even, $odd);\n\
    }", "    my($count, $odd, $even);\n    \n    if ($num eq 0) {\n        return\
    \ ($even, $odd);\n    }\n    \n    if ($num < 0) {\n        $num = (-1) * $num;\n\
    \    }\n    \n    while ($num) {\n        $count = $count + $num % 2;\n      \
    \  $num = intdiv($num / 2);\n    }\n    \n    return ($even, $odd);\n}\n</code>\n\
    <|/ a dscore=2 tags=arrays,perl,multidimensional-array,data-structures |>\n<|\
    \ a |>\n<code>\nuse List::MoreUtils qw<pairwise>;", "    if ($num < 0) {\n   \
    \     return [1, 0];\n    }\n    my @counts = ();\n    while ($num > 0) {\n  \
    \      push (@counts, ($num % 2 == 0));\n        $num = ($num / 2);\n    }\n \
    \   return @counts;\n}", "    $num = $num >= 0 ? $num : -$num;\n    my @digits\
    \ = ();\n    my $odd_count = 0;\n    my $even_count = 0;\n    while ($num != 0)\
    \ {\n        my $remainder = $num % 10;\n        push @digits, $remainder;\n \
    \       $odd_count++;\n        $even_count++ if $remainder % 2;\n        $num\
    \ = $num / 10;\n    }\n    return [$even_count, $odd_count];\n}", "    if ($num\
    \ < 0) {\n        my @even = ();\n        my @odd = ();\n        $even[0] = \"\
    even\";\n        $odd[0] = \"odd\";\n        return \\@even + \\@odd;\n    }\n\
    \    my($i, $numString);\n    $numString = $num.to_str;\n    my @even = ();\n\
    \    my @odd = ();\n    $even[0] = \"even\";\n    $odd[0] = \"odd\";\n    while\
    \ ($numString[-1..-1]) {\n        my $count = 1;\n        for ($i = length($numString)\
    \ - 1, $j = 0; $i > -1; $i--, $j++) {\n            if ($numString[$i] eq $numString[$j])\
    \ {\n                last;\n            }\n            else {\n              \
    \  $count++;\n            }\n        }\n        if ($count % 2 == 0) {\n     \
    \       push(@even, $count, $numString[$i]);\n        }\n        else {\n    \
    \        push(@odd, $count, $numString[$i]);\n        }\n    }\n    return \\\
    @even + \\@odd;\n}", "    my($even,$odd);\n    if( $num <= 0 ) { \n        return\
    \ (0, 1);\n    }\n    $even = 0;\n    $odd = 0;\n    while($num != 0) {\n    \
    \    $even = 2*$even;\n        $odd = 2*$odd;\n        $num = $num/10;\n    }\n\
    \    return ($even, $odd);\n}", "    my @nums = split //, $num;\n    my $even\
    \ = 0;\n    my $odd = 0;\n    for my $num (@nums) {\n        if ($num & 1) {\n\
    \            $odd++;\n        }\n        else {\n            $even++;\n      \
    \  }\n    }\n    return ($even, $odd);\n}", '    return $num unless $num;', " \
    \   my @result;\n    my $count = 1;\n    $result[0] = $count if ($num eq 0);\n\
    \    while ($num > 0) {\n        $count++;\n        my $digit = int rand 10;\n\
    \        if ($num % $digit == 0) {\n            $result[$count - 1] = $digit;\n\
    \            $num =~ s/^0//;\n        }\n    }\n    return @result;\n}", "   \
    \ return () if $num < 0;\n    my $even_count = 0;\n    my $odd_count = 0;\n  \
    \  my $n = $num;\n    while ($n != 0) {\n        $even_count++ while ($n & 1 !=\
    \ 0);\n        $odd_count++ while ($n & 1 != 1);\n        $n = $n >> 1;\n    }\n\
    \    return ($even_count, $odd_count);\n}", "    my @even;\n    my @odd;\n   \
    \ my $odd = $num % 10;\n    $num -= $odd;\n    $even = &even($odd);\n    $odd\
    \ = &odd($odd);\n    return @even + @odd;\n}", "    if($num < 0) {\n        die;\n\
    \    }\n    \n    my $even_count = 0;\n    my $odd_count = 0;\n    \n    for(my\
    \ $i = 0; $i < $num; $i++) {\n        if($num % 2 == 0) {\n            $even_count++;\n\
    \        } else {\n            $odd_count++;\n        }\n    }\n    return [ 1,\
    \ $odd_count, $even_count ];\n}", '    my($odd, $even);', "    if ($num < 10)\
    \ {\n        return [1, 0];\n    }\n    my @odd = ();\n    my @even = ();\n  \
    \  for my $i (reverse 1 .. $num) {\n        my $digit = int $i/10;\n        if\
    \ ($i %2 > 0) {\n            push(@even, $digit);\n        } else {\n        \
    \    push(@odd, $digit);\n        }\n    }\n    return \\@even, \\@odd;\n}", " \
    \   return 1 if $num < 0;\n    return $num == 0 ? () : (($num % 2 ? 1 : 0), ($num\
    \ % 2 ? 0 : 1));\n}\n</code>\n<|/ a tags=perl,math dscore=0 |>\n<| c |>\nYour\
    \ solution doesn't work for large numbers. For example, try `even_odd_count(1000000000000000000000)`,\
    \ which returns `[1, 1, 1]`. This isn't a problem with your code, it's the limit\
    \ of what a 32-bit number can hold.\n<|/ c |>\n<| c |>\n, good catch, that's a\
    \ pretty big number.  It would be better to switch to 64-bit numbers.  I was trying\
    \ to keep the solution simple while avoiding adding complexity to the solution.\
    \  I will update the code.\n<|/ c |>\n<| c |>\n, thanks for your comment.  I added\
    \ an edit to my solution that should handle numbers that require more than 32\
    \ bits to store their digits.\n<|/ c |>\n<| a dscore=0 |>\nA few simple lines\
    \ of code can solve your problem:\n<code>", "    return @$num > 0 ? @$num - 1\
    \ : (@$num + 1);\n}", "    my @even = ();\n    my @odd = ();\n    for(my $i =\
    \ -1; $i < $num; $i+= 2) {\n        push(@even, $i) if $num % 2 == 0;\n      \
    \  push(@odd, $i) if $num % 2 == 1;\n    }\n    return [@even,@odd];\n}", '    my(@odds,
    @evens);', "    my @re = ();\n    my $j = 0;\n    while (abs($num) > 0) {\n  \
    \      push(@re, abs($num % 10));\n        $num /= 10;\n        $j++;\n    }\n\
    \    if (@re) {\n        if ($re[0] % 2 == 0) {\n            $re[0]++;\n     \
    \   }\n        $re[0] /= 2;\n        $j++;\n    }\n    my @res;\n    for (my $i\
    \ = 0; $j < $#re; $i++) {\n        push(@res, $re[$i]);\n    }\n    return @res;\n\
    }", "    my(@even,@odd);\n    my($count,$i,$n);\n    $n = ($num == 0) ?\n    ($num)\
    \ : \n    ($num < 0) ? $num * -1 : $num;", "    my(@even,@odd);\n    for(my $i\
    \ = 0; $i < $num; $i++) {\n        push (@even, $i % 2 == 0);\n        push (@odd,\
    \ $i % 2 != 0);\n    }\n    return (@even, @odd);\n}", "    my($even, $odd);\n\
    \    if ($num <= 0) {\n        return [1, 1];\n    }\n    $even = $odd = 0;\n\
    \    $num -= 1;\n    do {\n        $num = ($num % 10);\n        if ($num == 0)\
    \ {\n            $even++;\n        } elsif ($num != 1) {\n            $odd++;\n\
    \        }\n    } while ($num > 0);\n    push (@{$_[0]}, $even);\n    push (@{$_[0]},\
    \ $odd);\n}", "    my @nums;\n    my $odd_count = 0;\n    my $even_count = 0;\n\
    \    for ($num) {\n        if($num % 2 == 0) {\n            push(@nums, $even_count);\n\
    \            $even_count = 0;\n        }\n        else {\n            push(@nums,\
    \ $odd_count);\n            $odd_count = 0;\n        }\n    }\n    push(@nums,\
    \ $even_count);\n    return \\@nums;\n}", "    my $even = int(($num / 10) % 2);\n\
    \    my $odd = int(($num / 10 + 1) % 2);", "    my(@ret) = ();\n    if($num eq\
    \ 0){\n        return ($ret, 0);\n    }\n    if($num == 1){\n        return ($ret,\
    \ 1);\n    }\n    while($num > 0){\n        if($num % 2 == 1){\n            push(@ret,\
    \ $num % 2);\n        }\n        $num = $num / 2;\n    }\n    return ($ret, scalar(@ret));\n\
    }", "    if ($num < 0) {\n\treturn ([1, 1]);\n    }\n    my(@odds);\n    my(@evens);\n\
    \    my $even_count = 1;\n    my $odd_count = 1;\n    my $remainder = $num;\n\
    \    while($remainder > 0) {\n\t$remainder = int($remainder / 10);\n\t$odds[$odd_count]\
    \ = $remainder;\n\t$remainder %= 10;\n\t$odd_count++;\n    }\n    if (@odds ==\
    \ 0) {\n\treturn ([1, 1]);\n    }\n    if (@odds == 1) {\n\treturn (@odds);\n\
    \    }\n    foreach my $digit (@odds) {\n\t$evens[$even_count] = $digit;\n\t$even_count++;\n\
    \    }\n    return ([@evens,@odds]);\n}", "    my @nums = split(//, $num);\n \
    \   my @odd = ();\n    my @even = ();\n    foreach my $num (@nums) {\n       \
    \ if ($num % 2 == 0) {\n            push(@even, $num);\n        }\n        else\
    \ {\n            push(@odd, $num);\n        }\n    }\n    return \\@even + \\\
    @odd;\n}", "    return $num if $num < 0;\n    my($even,$odd);\n    \n    $even\
    \ = 0;\n    $odd = 0;\n    for (my $i = $num; $i > 0; $i/=2) {\n        $even\
    \ += $i;\n    }\n    for (my $i = $num; $i > 1; $i%=2) {\n        $odd += $i;\n\
    \    }\n    return [$even,$odd];\n}", '    my($even, $odd) = ();', "    my @result;\n\
    \    \n    if ($num eq 0) {\n        return @result;\n    }\n    \n    if ($num\
    \ eq 1) {\n        @result = [0, 1];\n        return @result;\n    }\n    \n \
    \   my $count = 0;\n    my $num = ($num - 10) % 10;\n    \n    while ($num) {\n\
    \        if ($num % 2 == 0) {\n            $count++;\n        }\n        $num\
    \ = ($num - 10) % 10;\n    }\n    \n    push(@result, $count);\n    return @result;\n\
    }", "    my @digits = reverse 0 .. $num;\n    my @even_odd = ();\n    for my $i\
    \ (0 .. $#digits) {\n        my @even = ();\n        for my $j (0 .. $#digits\
    \ - $i) {\n            $even[$j] |= 1 << ($digits[$j] & 1 << ($#digits - 1 - $j));\n\
    \        }\n        push @even_odd, @even;\n    }\n    return @even_odd;\n}",
  "    my $n = 0;\n    my $i = 0;\n    while($n != 0) {\n        $n =~ s/0$/2/ig;\n\
    \        push @{ $even[$i] }, $n;\n        $n =~ s/1$/0/ig;\n        push @{ $odd[$i]\
    \ }, $n;\n        $i++;\n    }\n    return [@even, @odd];\n}", "    my @even_odd\
    \ = ();\n    my ($i, $j, $odd) = (0, 0, 0);\n    while ($num) {\n        # Check\
    \ if current number is even.\n        if ($num % 2 == 0) {\n            push(@even_odd,\
    \ $j);\n        }\n        # Check if current number is odd.\n        else {\n\
    \            $odd = 1;\n        }\n        $j++;\n        $num = $num / 2;\n \
    \   }\n    return ($odd, @even_odd);\n}", "    my $i = 0;\n    my @even = ();\n\
    \    my @odd = ();\n    while (length($num)) {\n        $num *= 10;\n        my\
    \ $remainder = $num % 10;\n        push(@even, $remainder) if $remainder == 0;\n\
    \        push(@odd, $remainder) if $remainder != 0;\n        $num = $num / 10;\n\
    \    }\n    return ($i, $i) if @odd != 0;\n    return ($i, $i+1) if @even != 0;\n\
    \    return 0;\n}", '    my(@count) = (0, 0);', '    my(@result);', "    my(@even,@odd);\n\
    \    if ($num < 0) {\n        @even = map { $_ % 2 } $num - $num % $num; # positive\
    \ number\n    }\n    else {\n        @odd = map { $_ % 2 } $num - $num % $num;\
    \ # negative number\n    }\n    return \\@even, \\@odd;\n}", "    my @retval =\
    \ ();\n    if ($num < 0) {\n        $num *= -1;\n        $retval[0] = $num;\n\
    \        return @retval;\n    }\n    my $count = 0;\n    while ($num != 0) {\n\
    \        $count += $num % 2 ? 0 : 1;\n        $num = int($num / 10);\n    }\n\
    \    push @retval, $count;\n    return @retval;\n}", "    my(@even_odd_digits,\
    \ $i);\n    for (my $i = 0; $i < $num; $i++) {\n        if ($num % 2 == 0) {\n\
    \            push(@even_odd_digits, 0);\n        } else {\n            push(@even_odd_digits,\
    \ 1);\n        }\n        $num = $num / 2;\n    }\n    return @even_odd_digits;\n\
    }", "    my($odd, $even);\n    my($n, $num);\n    my($even, @odd);\n    $num =\
    \ $num < 0 ? -$num : $num;\n    while (!$num) {\n        $num = $num / 10;\n \
    \       $num = $num < 0 ? -$num : $num;\n    }\n    foreach $n (0..(@odd ? @odd\
    \ : @even-1)) {\n        $odd[$n] = $num % 10;\n        $num = $num / 10;\n  \
    \      $num = $num < 0 ? -$num : $num;\n    }\n    $num = $num < 0 ? -$num : $num;\n\
    \    foreach $n (0..(@odd ? @odd : @even-1)) {\n        $even[$n] = $num % 10;\n\
    \        $num = $num / 10;\n        $num = $num < 0 ? -$num : $num;\n    }\n \
    \   push(@odd, $odd);\n    push(@even, $even);\n    return @odd;\n}", '    my($even,
    $odd);', "    return $num =~ /-?\\d+/g;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
