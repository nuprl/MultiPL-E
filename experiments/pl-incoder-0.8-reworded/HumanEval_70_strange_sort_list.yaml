name: HumanEval_70_strange_sort_list
language: pl
prompt: "# Given array of integers, return array in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# >>> strange_sort_list([1, 2, 3, 4])\n\
  # [1, 4, 2, 3]\n# >>> strange_sort_list([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list([])\n\
  # []\nsub strange_sort_list {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strange_sort_list;\n\
  \        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 4, 2, 3])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 6, 7, 8, 9]),[5, 9, 6, 8, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7])) {\n        print \"ok!\" }else{\n       \
  \ exit 1;\n        }\n        if(eq_deeply($candidate->([5, 5, 5, 5]),[5, 5, 5,\
  \ 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 2, 2, 2, 5, 5,\
  \ -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->([111111]),[111111])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @sorted = @$lst;\n    my $l = scalar(@sorted);\n    my $i =\
    \ 1;\n    my $j = 0;", "    my @out;\n    my $min = $lst[0];\n    my $max = $lst[0];\n\
    \    for(my $i = 1; $i < @$lst; $i++) {\n        $min = $min > $lst[$i] ? $lst[$i]\
    \ : $min;\n        $max = $max < $lst[$i] ? $lst[$i] : $max;\n    }\n    for(my\
    \ $i = 1; $i < @$lst; $i++) {\n        push (@out, $lst[$i]);\n    }\n    for(my\
    \ $i = $max; $i > $min; $i--) {\n        push (@out, $lst[$i]);\n    }\n    return\
    \ @out;\n}\n</code>\nAnd then sort it with:\n<code>", "    my $result = ();\n\
    \    my @list = @$lst;\n    my ($min, $max) = @list;\n    my $temp_min = $min;\n\
    \    my $temp_max = $max;\n    while( @list ) {\n        my $i = shift @list;\n\
    \        push @$result, $i;\n        push @$result, $temp_min;\n        push @$result,\
    \ $temp_max;\n        $temp_min =  $i;\n        $temp_max = $i;\n    }\n    return\
    \ @$result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is a solution that doesn't\
    \ use recursion, only iteration.  This is faster than the accepted answer, but\
    \ doesn't return an array of arrays:\n<code>", '    my($max);', '    my($i, $j,
    $temp);', "    my @sorted_lst;\n    my $min_val = $lst[0];\n    my $max_val =\
    \ $lst[0];\n    my $idx = 1;\n    foreach my $val (@$lst) {\n        if ($val\
    \ > $max_val) {\n            $max_val = $val;\n        }\n        if ($val < $min_val)\
    \ {\n            $min_val = $val;\n        }\n        $sorted_lst[$idx] = $val;\n\
    \        $idx++;\n    }\n    return @sorted_lst;\n}", '    my ($i, $j, $result);',
  '    return @$lst if @$lst <= 1;', "    return () unless @$lst;\n    my $min = $lst[0];\n\
    \    my $max = @$lst > 1 ? $lst[1] : undef;\n    for my $i (@$lst) {\n       \
    \ $i = ($i < $min) ? $min : $i;\n        $i = ($i > ($max && $i < $max)) ? $max\
    \ : $i;\n    }\n    return @$lst;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI modified\
    \ the answer above by to incorporate the use of a hash to store the values and\
    \ sort them in the reverse order of the keys. I included the reverse function\
    \ as well.\n<code>", "    my @copy = @$lst;\n    return if @copy < 1;\n    for\
    \ (my $i = 0; $i < @copy; $i++) {\n        my $value = $copy[$i];\n        my\
    \ $j = $i;\n        while ($j >= 0 && $copy[$j] > $value) {\n            my $tmp\
    \ = $copy[$j];\n            $copy[$j] = $copy[$i];\n            $copy[$i] = $tmp;\n\
    \            $j--;\n        }\n    }\n    return @copy;\n}", "    my @result;\n\
    \    for my $i (0..$#$lst) {\n        my $swap = $lst[$i];\n        my $j = $i;\n\
    \        while ($j > 0 && $lst[$j - 1] > $swap) {\n            $lst[$j] = $lst[$j\
    \ - 1];\n            $j--;\n        }\n        $lst[$j] = $swap;\n    }\n    return\
    \ \\@result;\n}", '    my $length = @$lst;', "    my($min_val) = undef;\n    my($max_val)\
    \ = undef;", "    my($min) = $lst[0];\n    my($max) = $lst[0];\n    for(my $i=1;\
    \ $i < @$lst; ++$i) {\n        if($lst[$i] < $min) {\n            $min = $lst[$i];\n\
    \        } elsif($lst[$i] > $max) {\n            $max = $lst[$i];\n        }\n\
    \    }\n    return sort{$a <=> $b} @$lst;\n}", "    my @lst;\n    for(@$lst){\n\
    \        push @lst, ($a <=> $b);\n        $a = $b;\n        $b = $_;\n    }\n\
    \    @lst;\n}", "    my @result;\n    my $min_value = $lst->[0];\n    my $max_value\
    \ = $lst->[0];\n    for (my $i = 0; $i < $#$lst; ++$i) {\n        $min_value =\
    \ $lst->[$i] if $lst->[$i] < $min_value;\n        $max_value = $lst->[$i] if $lst->[$i]\
    \ > $max_value;\n    }\n    for my $i (0..$#$lst) {\n        my $j = $i + 1;\n\
    \        $result[$i] = $lst->[$j] if $lst->[$i] > $lst->[$j];\n    }\n    return\
    \ @result;\n}", "    my @new_list = ();\n    my $min = lc($lst[0]);\n    my $max\
    \ = lc($lst[-1]);\n    for (my $i = 1; $i < @$lst; $i++) {\n        if ($lst[$i]\
    \ >= $min) {\n            $new_list[0] = lc($lst[$i]);\n        } else {\n   \
    \         $new_list[@new_list + 1] = $i;\n            $new_list[-1] = lc($lst[$i]);\n\
    \        }\n    }\n    return @new_list;\n}\n</code>\n<|/ a tags=perl,arrays dscore=3\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\n- Added some explanation to your solution.\n\
    <|/ c |>\n<| a tags=perl,arrays dscore=1 |>\n<code>", "    my $min;\n    my $max;\n\
    \    my $temp;", "    my ($i, $temp, $max);\n    for ($i = 0; $i < scalar(@$lst);\
    \ $i += 2) {\n        $temp = @{$lst[$i]}[0];\n        delete @{$lst[$i]}[0];\n\
    \        $max = @{$lst[$i]}[0];\n        foreach $num (@{$lst[$i]}) {\n      \
    \      if ($num > $temp) {\n                push(@{$lst[$i-1]}, $temp);\n    \
    \            push(@{$lst[$i]}, $num);\n                $temp = $num;\n       \
    \     }\n        }\n        push(@{$lst[$i-1]}, $temp);\n    }\n    return $lst;\n\
    }", '    my(@sorted_lst);', "    my %hash;\n    my $idx = 0;\n    while(@$lst\
    \ > 1) {\n        if($lst[$idx] == $lst[$idx-1]) {\n            splice @$lst,\
    \ $idx, 1;\n            $idx--;\n        }\n        elsif($lst[$idx] == $lst[$idx+1])\
    \ {\n            splice @$lst, $idx;\n            $idx++;\n        }\n       \
    \ elsif($lst[$idx] > $lst[$idx-1]) {\n            my $value = $lst[$idx];\n  \
    \          splice @$lst, $idx, 1;\n            $hash{$value}++;\n        }\n \
    \       elsif($lst[$idx] > $lst[$idx+1]) {\n            my $value = $lst[$idx];\n\
    \            splice @$lst, $idx;\n            $hash{$value}++;\n        }\n  \
    \  }\n    return values %hash;\n}", "    if (@$lst == 0) {\n        return [];\n\
    \    }\n    my @list;\n    my $min = shift @$lst;\n    my $max = $min;\n    while\
    \ (@$lst) {\n        my $curr = shift @$lst;\n        if ($curr < $min) {\n  \
    \          $min = $curr;\n        }\n        if ($curr > $max) {\n           \
    \ $max = $curr;\n        }\n        push @list, $curr;\n    }\n    push @list,\
    \ $min;\n    push @list, $max;\n    return @list;\n}", "    my ($min, $max, $tmp);\n\
    \    $min = $max = $lst[0];\n    for my $num (@{$lst}) {\n        if ($num < $min)\
    \ {\n            $tmp = $min;\n            $min = $num;\n        }\n        elsif\
    \ ($num > $max) {\n            $tmp = $max;\n            $max = $num;\n      \
    \  }\n        else {\n            $tmp = $num;\n        }\n    }\n    return ($min,\
    \ $max, $tmp);\n}", "    my @sorted = ();\n    for (my $i = 0; $i < $#lst; $i++)\
    \ {\n        my $min = -1;\n        my $max = 0;\n        for (my $j = 0; $j <\
    \ $#lst; $j++) {\n            next if $i == $j;\n            if ($min == -1 &&\
    \ $lst[$i] < $lst[$j]) {\n                $min = $j;\n            }\n        \
    \    elsif ($lst[$i] >= $lst[$j] && $j < $max) {\n                $max = $j;\n\
    \            }\n        }\n        if ($min != $max) {\n            for ($i =\
    \ $min; $i <= $max; $i++) {\n                push(@sorted, $lst[$i]);\n      \
    \      }\n        }\n    }\n    return @sorted;\n}", "    my @ret;\n    my $n\
    \ = @$lst;\n    my $min = 0;\n    my $max = $n - 1;\n    my $i;\n    while ($min\
    \ <= $max) {\n        my $j = ($min + $max) / 2;\n        $ret[$j] = $lst[$j];\n\
    \        if ($j == $min) {\n            $min++;\n        }\n        else {\n \
    \           $max--;\n        }\n    }\n    return @ret;\n}", "    my($min, $max,\
    \ $i, $j, $min_index, $max_index);\n    if (scalar(@$lst) < 2) {\n        return\
    \ $lst;\n    }\n    $min = @$lst > 0 ? $lst[0] : undef;\n    $max = @$lst > 0\
    \ ? $lst[1] : undef;\n    for (my $i = 0; $i < @$lst; $i++) {\n        $min_index\
    \ = index($min, $lst[$i]);\n        $max_index = index($max, $lst[$i]);\n    \
    \    $lst[$i] = $min_index ? ($max_index - $min_index + 1) : undef;\n    }\n \
    \   return $lst;\n}\n</code>\n<|/ a tags=arrays,sorting,perl |>\n<| c |>\nThis\
    \ is nice. Slight simplification, `$min = $lst[0]` and `$max = $lst[-1]` can be\
    \ replaced by `$min ||= $lst[0]` and `$max ||= $lst[-1]`.\n<|/ c |>\n<| c |>\n\
    It also fails when all values are equal, which is probably a better behaviour\
    \ than just sorting the array as is.\n<|/ c |>\n<| a dscore=3 |>\nI agree with\
    \ everyone here that it is better to use the Schwartzian transform.  However,\
    \ I think the tricky part is getting the list to be sorted.  It is probably a\
    \ good idea to leave the list unchanged if the entire list is already sorted (like\
    \ for Perl's sort), unless you also want to allow duplicates.\nSo, here's my solution:\n\
    <code>", "    my(@return);\n    my $smallest = -1;\n    my $largest = -1;\n  \
    \  my $min = 0;\n    my $max = 0;\n    # find minimum and maximum\n    foreach\
    \ (@$lst) {\n        if ($_ < $smallest) {\n            $smallest = $_;\n    \
    \    } elsif ($largest == -1) {\n            $largest = $_;\n        }\n     \
    \   $max = $_ if $_ > $max;\n        $min = $_ if $_ < $min;\n    }", "    my\
    \ @result = ();\n    my @list = @$lst;\n    my $min = $list[0];\n    my $max =\
    \ $list[0];\n    my $min_index = 0;\n    my $max_index = 0;\n    for(my $index\
    \ = 0; $index < @list; $index++) {\n        if($list[$index] < $min) {\n     \
    \       $min = $list[$index];\n            $min_index = $index;\n        }\n \
    \       if($list[$index] > $max) {\n            $max = $list[$index];\n      \
    \      $max_index = $index;\n        }\n    }\n    for(my $index = 0; $index <\
    \ @list; $index++) {\n        if($list[$index] != $max) {\n            $list[$index]\
    \ = $list[$min_index];\n            $list[$min_index] = $list[$index];\n     \
    \   }\n    }\n    $_ = $min for @list;\n    return @result;\n}", '    my @sorted_list
    = ();', "    my @res;\n    while (@lst > 0) {\n        my $elem = shift @lst;\n\
    \        push (@res, pop @lst);\n        push (@res, pop @lst);\n        push\
    \ (@res, pop @lst);\n        push (@res, pop @lst);\n        push (@res, pop @lst);\n\
    \        push (@res, pop @lst);\n        push (@res, pop @lst);\n        push\
    \ (@res, pop @lst);\n        push (@res, pop @lst);\n        push (@res, pop @lst);\n\
    \        push (@res, pop @lst);\n        push (@res, pop @lst);\n        push\
    \ (@res, pop @lst);\n        push (@res, pop @lst);\n        push (@res, pop @lst);\n\
    \        push (@res, pop @lst);\n    }\n    return @res;\n}\n</code>\n<|/ a dscore=4\
    \ tags=sorting,perl |>\n<| c |>\nThis answer is probably one of the best so far,\
    \ but I thought I would note that the algorithm to find these numbers is a bit\
    \ inefficient in some cases (see my comment on the question).\n<|/ c |>\n<| a\
    \ dscore=3 |>\nA simple way is to use Schwartzian Transform.\n<code>\nuse strict;\n\
    use warnings;", "    my(@new_lst);\n    my(@sorted_lst);", "    my $min = shift(@$lst);\n\
    \    my $max = shift(@$lst);\n    while (my $element = shift(@$lst)) {\n     \
    \   $element < $min ? $min = $element : $element > $max ? $max = $element : $min;\n\
    \    }\n    push, $min;\n    push, $max;\n    while (my $element = shift(@$lst))\
    \ {\n        $element < $min ? $min = $element : $element > $max ? $max = $element\
    \ : $min;\n    }\n    push, $min;\n    push, $max;\n    push, $lst;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks so much, that really helped me understand what was going\
    \ on.\n<|/ c |>\n<| c |>\nThis is not exactly sorting but rather it is just rearranging\
    \ elements as one would intuitively expect from the sort function. It can be called\
    \ a sorting algorithm but is definitely not a sort algorithm. Also, your solution\
    \ would not work for negative numbers. StrangeSort should also return negative\
    \ numbers in descending order [1 2 3 4] -> [4 3 2 1]\n<|/ c |>\n<| c |>\nNo, it's\
    \ sorting in descending order - [5 4 3 2] -> [2 3 4 5]\n<|/ c |>\n<| c |>\nIf\
    \ my solution doesn't work, it's because my solution isn't sorting in descending\
    \ order...\n<|/ c |>\n<| c |>\n: Sorry but my comment was not helpful. Your solution\
    \ works but you do not describe it clearly enough. You mention you \"do not describe\
    \ it clearly enough\". Why? And how does this explain the fact that your solution\
    \ is not clearly written? I do not think that a solution with 2 lines of code\
    \ can explain the differences between the 2 solutions provided so far.\n<|/ c\
    \ |>\n<| a tags=arrays,perl,sorting |>\n<code>", "    my @list = ();\n    my $min\
    \ = undef;\n    my $max = undef;\n    my $cur;", "    \n    my %hash;\n    my\
    \ $i = 0;\n    foreach my $num (@$lst) {\n        $hash{$num} = $i;\n        $i++;\n\
    \    }", "    my($min, $max);\n    my(@tmp);", "    if (not defined $lst) {\n\
    \        return [];\n    }\n    my @ret = ();\n    my $min = min @$lst;\n    my\
    \ $max = max @$lst;\n    my $curr = $min;\n    while (@$lst > 1) {\n        push\
    \ (@ret, shift @$lst);\n        if ($curr >= $max) {\n            my $temp = $min;\n\
    \            $min = $max;\n            $max = $temp;\n            my $i = $curr;\n\
    \            $curr = $i;\n        }\n    }\n    push (@ret, shift @$lst);\n  \
    \  push @ret, 1;\n    return @ret;\n}", '    my @sorted_list = ();', "    my $index\
    \ = 0;\n    my = ();\n    my $minimum = $lst->[0];\n    my $maximum = $lst->[0];",
  "    $lst =~ s/^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)$/$4 $3 $2 $1/e;\n    return\
    \ @$lst;\n}", "    # Sort $lst by insertion order.\n    # (we cannot sort the\
    \ array directly since it is being sorted during\n    # insertion process)\n \
    \   my @sorted_lst = ();\n    for(my $i=0;$i<@$lst;$i++) {\n        my $cur =\
    \ $lst->[$i];\n        $sorted_lst[$i]=$cur;\n        for(my $j=$i+1;$j<@$lst;$j++)\
    \ {\n            if($cur <=> $lst->[$j]) {\n                my $temp = $lst->[$j];\n\
    \                $lst->[$j] = $cur;\n                $cur = $temp;\n         \
    \       $sorted_lst[$j] = $cur;\n            }\n        }\n    }\n    return @sorted_lst;\n\
    }", "    my(@sorted_lst);\n    my $min = $lst[0];\n    my $max = $lst[0];\n  \
    \  foreach my $val (@$lst) {\n        if($val lt $min) {\n            $min = $val;\n\
    \        }\n        elsif($val gt $max) {\n            $max = $val;\n        }\n\
    \        elsif($val == $min) {\n            $min = $val;\n        }\n        elsif($val\
    \ == $max) {\n            $max = $val;\n        }\n    }\n    foreach my $val\
    \ (@$lst) {\n        if($val lt $min) {\n            push(@sorted_lst, $min);\n\
    \            $min = $val;\n        }\n        elsif($val gt $max) {\n        \
    \    push(@sorted_lst, $max);\n            $max = $val;\n        }\n        elsif($val\
    \ == $min) {\n            push(@sorted_lst, $val);\n            $min = $val;\n\
    \        }\n        elsif($val == $max) {\n            push(@sorted_lst, $val);\n\
    \            $max = $val;\n        }\n        else {\n            push(@sorted_lst,\
    \ $val);\n        }\n    }\n    return @sorted_lst;\n}", "    my(@sorted_lst);\n\
    \    my($min);\n    my($max);\n    my($min_temp);\n    my($max_temp);\n    my($min_value);\n\
    \    my($max_value);\n    my($last_value_index);\n    my(@last_value_index);\n\
    \    my($last_value_temp);\n    my(@last_value_temp);\n    my($value_count);\n\
    \    my($value_count);\n    foreach my $num (@$lst) {\n        if ($value_count\
    \ > 0) {\n            $min_temp = $min;\n            $max_temp = $max;\n     \
    \   }\n        $value_count++;\n        $min_temp = $min if $min > $num;\n   \
    \     $max_temp = $max if $max < $num;\n        $min = $num if $min_temp > $num;\n\
    \        $max = $num if $max_temp < $num;\n        push(@sorted_lst, $num);\n\
    \    }\n    @sorted_lst, $min, $max;\n}", "    my @res = ();\n    for (my $i =\
    \ 0; $i < @$lst; $i++) {\n        my $j = $i;\n        for (;;) {\n          \
    \  $j--;\n            $j += 1 while $j >= 0 && $res[$j + 1] < $res[$j];\n    \
    \        push @$lst, $res[$j + 1];\n            last unless $j >= 0;\n       \
    \ }\n    }\n    return @res;\n}", "    my @sorted_list = ();\n    my $tmp_int\
    \ = -1;\n    my $min = -1;\n    my $max = -1;\n    foreach my $num (@$lst) {\n\
    \        $tmp_int += $num;\n        if ($tmp_int < $min) {\n            $min =\
    \ $tmp_int;\n        } elsif ($tmp_int > $max) {\n            $max = $tmp_int;\n\
    \        }\n        push(@sorted_list, $tmp_int);\n    }\n    foreach my $num\
    \ (@$lst) {\n        my $index = 0;\n        for (my $i = 0; $i < $min; $i++)\
    \ {\n            if ($sorted_list[$index] != $i) {\n                last;\n  \
    \          }\n            $index++;\n        }\n        for (my $i = $min; $i\
    \ < $max; $i++) {\n            if ($sorted_list[$index] != $i) {\n           \
    \     last;\n            }\n            $index++;\n        }\n        for (my\
    \ $i = $max; $i < $tmp_int; $i++) {\n            if ($sorted_list[$index] != $i)\
    \ {\n                last;\n            }\n            $index++;\n        }\n\
    \        for (my $i = 0; $i < $tmp_int; $i++) {\n            if ($sorted_list[$index]\
    \ != $i) {\n                last;\n            }\n            $index++;\n    \
    \    }\n        splice(@sorted_list, $index, 0, $num);\n    }\n    return @sorted_list;\n\
    }", "    my @list;\n    my $size = @$lst;", "    my @temp = ();\n    my $min =\
    \ scalar @$lst < 2 ? 0 : @$lst[0];\n    my $max = scalar @$lst < 2 ? @$lst[0]\
    \ : @$lst[1];\n    my $i = 0;\n    for my $num (@$lst) {\n        push(@temp,\
    \ $num);\n        push (@temp, $max);\n        push (@temp, $min);\n        $i++;\n\
    \        if ($i > 2) {\n            $i = 0;\n            $max = $min;\n      \
    \  }\n        $min = $num;\n    }\n    @$lst = @temp;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nThe idea of the algorithm is correct, but there are some problems:\n\
    You do not need any global variables:\n<code>", '    return $lst if scalar @$lst
    <= 1;', "    return sort {\n        my ($val1, $val2) = @_;\n        $val1 > $val2\
    \ ? -1 :\n        $val1 < $val2 ? 1 :\n        $val1 == $val2 ? 0 : +0;\n    };\n\
    }", "    my(@ret);\n    my($min, $max);", "    my $max = max(@$lst);\n    my $min\
    \ = min(@$lst);\n    my @new_list = ();\n    \n    for (my $i = 0; $i < @$lst;\
    \ $i++) {\n        if ($i == $max) {\n            push(@new_list, $min);\n   \
    \     } else {\n            push(@new_list, $i);\n        }\n    }\n    \n   \
    \ return @new_list;\n}", "    my(@results);\n    my($i, $j, $k, $first);", " \
    \   my @sorted = ();\n    my @sorted2 = ();", "    my(@sorted);\n    my($min,\
    \ $max);\n    $min = $max = $lst[0];\n    for (my $i = 1; $i < @$lst; $i++) {\n\
    \        if ($lst[$i] < $min) {\n            $min = $lst[$i];\n        } elsif\
    \ ($lst[$i] > $max) {\n            $max = $lst[$i];\n        } else {\n      \
    \      $sorted[$i-1] = $lst[$i];\n        }\n    }\n    $sorted[0] = $min;\n \
    \   $sorted[-1] = $max;\n    return @sorted;\n}\n</code>\n<|/ a tags=sorting,arrays,perl,string\
    \ |>\n<| a dscore=1 tags=sorting,arrays,perl,string |>\nThis might help:\n<code>\n\
    my=qw/1 3 7 4 2 5 8 6 9  \n          3 4 5 2 6 7 8 9 1 \n          2 4 6 5 3 7\
    \ 8 9 1 \n          3 4 5 6 2 7 8 9 1 \n          4 5 6 3 7 8 9 1 2 \n       \
    \   4 5 2 6 3 7 8 9 1 \n          4 5 6 3 7 2 8 9 1 \n          4 5 6 3 7 8 2\
    \ 9 1 \n          4 5 6 3 7 8 9 2 1 \n          4 5 6 3 7 8 9 1 2 \n         \
    \ 4 5 6 3 7 2 8 2 9 \n          4 5 6 3 7 8 2 9 1 \n          4 5 6 3 7 8 9 2\
    \ 1 \n          4 5 6 3 7 8 9 1 2 \n          4 5 6 3 7 8 2 9 1 \n          4\
    \ 5 6 3 7 8 9 2 1 \n          4 5 6 3 7 2 8 2 9 \n          4 5 6 3 7 8 2 9 1\
    \ \n          4 5 6 3 7 8 9 2 1 \n          4 5 6 3 7 8 9 2 1 \n          4 5\
    \ 6 3 7 2 8 2 9 \n          4 5 6 3 7 8 2 9 1 \n          4 5 6 3 7 8 9 2 1 \n\
    \          4 5 6 3 7 2 8 2 9 \n          4 5 6 3 7 8 2 9 1 \n          4 5 6 3\
    \ 7 8 9 2 1 \n          4 5 6 3 7 2 8 2 9 \n          4 5 6 3 7 8 2 9 1 \n   \
    \       4 5 6 3 7 8 9 2 1 \n          4 5 6 3 7 2 8 2 9 \n          4 5 6 3 7\
    \ 8 2 9 1 \n          4 5 6 3 7 8 9 2 1 \n          4 5 ", "    return ($lst[0])\
    \ unless  scalar @$lst;\n    return ($lst[0]) unless  scalar @$lst == 1;\n   \
    \ my $min = shift(@$lst);\n    my $max  = $min;\n    my $tmp  = 0;\n    my $ind\
    \ = 0;\n    while(@$lst > 0) {\n        last if  ($tmp < $max);\n        $tmp\
    \ = $max;\n        $max = $min if  ($min > $max);\n        $tmp = $min;\n    \
    \    $min = $lst[0];\n        shift;\n        $lst[$ind] = $tmp;\n        $ind++;\n\
    \    }\n    return @$lst;\n}", "    my @sorted_list = ();\n    my $minimum = $lst[0];\n\
    \    my $maximum = $lst[0];\n    my $pos = 0;\n    \n    for my $value (@$lst)\
    \ {\n        if ($value >= $minimum) {\n            if ($value < $maximum) {\n\
    \                push(@sorted_list, $value);\n            }\n            else\
    \ {\n                while (1) {\n                    my $index = $pos;\n    \
    \                $index = ($index + 1) % scalar(@sorted_list);\n             \
    \       $pos = $index;\n                    my $tmp = $sorted_list[$index];\n\
    \                    $sorted_list[$index] = $value;\n                    $value\
    \ = $tmp;\n                    if ($value >= $minimum) {\n                   \
    \     last;\n                    }\n                }\n            }\n       \
    \ }\n        else {\n            if ($value > $maximum) {\n                push(@sorted_list,\
    \ $value);\n            }\n            else {\n                while (1) {\n \
    \                   my $index = $pos;\n                    $index = ($index -\
    \ 1) % scalar(@sorted_list);\n                    $pos = $index;\n           \
    \         my $tmp = $sorted_list[$index];\n                    $sorted_list[$index]\
    \ = $value;\n                    $value = $tmp;\n                    if ($value\
    \ >= $minimum) {\n                        last;\n                    }\n     \
    \           }\n            }\n        }\n    }\n    \n    @$lst =  @sorted_list;\n\
    }", "    my;\n    my $i = 0;\n    my $j = 0;", "    my @temp = ();\n    for (my\
    \ $i = 0; $i < @$lst; $i += 2) {\n        $temp[$i] = $lst->[$i];\n        $temp[$i\
    \ + 1] = $lst->[$i + 1];\n    }\n    return @temp;\n}", "    my @sorted;\n   \
    \ my $min_value = pop(@$lst);\n    my $max_value = pop(@$lst);\n    foreach my\
    \ $num (@$lst) {\n        push (@sorted, $num) if ($num > $max_value);\n     \
    \   push (@sorted, $num) if ($num < $min_value);\n    }\n    return @sorted;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is great - thanks! The only thing I'd add\
    \ is that the `$min_value` and `$max_value` should actually be set by comparing\
    \ the first two and last two values.\n<|/ c |>\n<| a tags=perl,arrays dscore=2\
    \ |>\nThe solution below will take any array and sort it into reverse order maintaining\
    \ original order. It can be easily modified to sort on any number of columns or\
    \ criteria by changing $col to an array with keys to sort by.\n<code>", "    my\
    \ @sorted_lst;\n    \n    my $min = shift @$lst;\n    my $max = pop @$lst;\n \
    \   my $temp = $min;\n    while (@$lst) {\n        my $ele = shift @$lst;\n  \
    \      if ($ele < $min) {\n            $temp = $ele;\n            $min = $ele;\n\
    \        }\n        if ($ele > $max) {\n            $temp = $ele;\n          \
    \  $max = $ele;\n        }\n        push @sorted_lst, $temp;\n    }\n    \n  \
    \  push @sorted_lst, $min;\n    push @sorted_lst, $max;\n    return @sorted_lst;\n\
    }", "    my @ret;\n    my $len = scalar @$lst;\n    for (my $i = 0; $i < $len;\
    \ $i++) {\n        my $j = scalar @ret;\n        while (1) {\n            while\
    \ (1) {\n                $ret[$j] = $lst[$i];\n                if ($i == $len\
    \ - 1 || $j == $len - 1) {\n                    return @ret;\n               \
    \ }\n                $j++;\n                $j += ($i + 1) % $len;\n         \
    \   }\n            $j--;\n            $i = $i + 1;\n        }\n    }\n}", "  \
    \  my($min, $max, $min_index, $max_index);\n    $min = $lst[0];\n    $max = @$lst\
    \ > 1 ? $lst[1] : $min;\n    foreach my $x (@$lst) {\n        if ($x > $max) {\n\
    \            $max = $x;\n            $max_index = $#lst;\n        } elsif ($x\
    \ < $min) {\n            $min = $x;\n            $min_index = $#lst;\n       \
    \ }\n    }\n    return sort { $a <=> $b } @$lst;\n}", '    $lst = [];', '    return
    [] if @$lst == 0;', "    my $min = @$lst < 2 ? $lst->[0] : $lst->[0];\n    my\
    \ $max = @$lst > 2 ? $lst->[$#lst - 2] : $lst->[$#lst];\n    for (my $i = $#lst;\
    \ $i >= 1; $i--) {\n        last if $i < 1 or $min >= $lst->[$i - 1];\n      \
    \  $lst->[$i] = $lst->[$i - 1];\n    }\n    $lst->[0] = max($min, $lst->[0]);\n\
    \    $lst->[$#lst] = min(@$lst, $max);\n    $lst;\n}\n</code>\nIt works fine with\
    \ empty lists, but if there's only one element in list, it breaks.\n<|/ a tags=sorting,perl,algorithm\
    \ dscore=2 |>\n<| a dscore=2 tags=sorting,perl,algorithm |>\nHere's a solution\
    \ in one line:\n<code>", "    my($min_val) = undef;\n    my($max_val) = undef;\n\
    \    my($min_lst, $max_lst);\n    my($i);", "    $lst =~ s/\\s+//g;\n    $lst\
    \ =~ s/^\\s*//;\n    $lst =~ s/\\s*$//;", "    my(@result) = ();\n    my $min\
    \ = $lst[0];\n    my $max = $lst[0];\n    for (my $i = 1; $i < @$lst; $i++) {\n\
    \        $min = $lst[$i] if $lst[$i] < $min;\n        $max = $lst[$i] if $lst[$i]\
    \ > $max;\n    }\n    return @$lst if $min < $max;\n    for (my $i = 1; $i < @$lst;\
    \ $i++) {\n        $result[$i - 1] = &merge_sort(\\$min, $max, \\$lst[$i]);\n\
    \    }\n    return &merge_sort(\\$min, $max, \\$max);\n}", "    my @new_lst =\
    \ ();\n    for(my $i = 0; $i < ($#lst); $i += 2) {\n        push(@new_lst, $lst[$i]);\n\
    \        push(@new_lst, $lst[$i+1]);\n    }\n    return @new_lst;\n}", "    my\
    \ $min_val = $lst[0];\n    my $max_val = $lst[0];\n    foreach (@$lst) {\n   \
    \     $min_val = $_ if $_ < $min_val;\n        $max_val = $_ if $_ > $max_val;\n\
    \    }\n    return @$lst;\n}", '    my @sorted_list;', "    my @new_lst = ();\n\
    \    my $min = lc $_[0];\n    my $max = lc $_[0];\n    my $tmp;\n    for(my $i=1;\
    \ $i < @$lst; $i++) {\n        my $current = lc $_[$i];\n        if ($current\
    \ < $min) {\n            $min = $current;\n        }\n        elsif ($current\
    \ > $max) {\n            $max = $current;\n        }\n        elsif ($current\
    \ > $min && $current < $max) {\n            push (@new_lst,$current);\n      \
    \  }\n    }\n    for(my $i=0; $i < @new_lst; $i++) {\n        $tmp = @new_lst[$i];\n\
    \        $new_lst[$i] = $tmp;\n        $new_lst[$i] ^= $min;\n        $new_lst[$i]\
    \ ^= $max;\n    }\n    return @new_lst;\n}", "    my $i = 1;\n    my @strange;\n\
    \    foreach my $num (reverse sort {$a <=> $b} @$lst) {\n        $strange[$i]\
    \ = $num;\n        $i++;\n    }\n    return @strange;\n}", "    return () unless\
    \ @$lst;\n    my($min, $max) = @$lst[0 .. $#lst];\n    my($i, $j);", '    my($min,
    $max) = minmax($lst);', "    $lst =~ m/^\\s*([0-9]*)\\s*([-+\\/*]\\s*([0-9]*))*\\\
    s*$/s;\n    my($smallest_number, $sign, $smallest_numbers) = $1;\n    my($sort_sign,\
    \ $sort_numbers) = $2;", "    my = ( $lst[0] ); # first element will be the first\
    \ to be sorted\n    for(my $i = 1; $i < @$lst; $i++) {\n        my $min = $lst[0];\n\
    \        for(my $j = $i; $j < @$lst; $j++) {\n            if($min->[0] > $lst[$j]->[0])\
    \ {\n                $min = $lst[$j];\n            }\n        }\n        push(@sorted,\
    \ $min);\n    }\n    return @sorted;\n}", "    my @sorted_lst;\n    my $min_element;\n\
    \    my $max_element;\n    my $min_element_index;\n    my $max_element_index;",
  "    my($max_val = $lst[0]);\n    my($min_val = $lst[0]);\n    foreach my $i (1..$#$lst)\
    \ {\n        if ($max_val <= $lst[$i]) {\n            $max_val = $lst[$i];\n \
    \       }\n        if ($min_val > $lst[$i]) {\n            $min_val = $lst[$i];\n\
    \        }\n    }\n    my @sorted_list = ();\n    foreach my $i ($min_val..$max_val)\
    \ {\n        push(@sorted_list, $i);\n    }\n    return @sorted_list;\n}", " \
    \   $lst =~ s/^(\\S*)\\s.*$/$1/g;\n    $lst =~ s/^([^\\s]*)\\s.*$/$1/;\n    my\
    \ @strange_sort = ();\n    my ($min, $max, $new_max, $temp);\n    # Find the minimum\
    \ and maximum.\n    $min = pop @{$lst} if @{$lst};\n    $max = pop @{$lst} if\
    \ @{$lst};\n    my $i = 0;\n    while(@lst) {\n        $new_max = $max;\n    \
    \    $new_max = $max if $lst[$i] >= $max;\n        $strange_sort[$i] = $lst[$i]\
    \ if $lst[$i] <= $min;\n        $strange_sort[$i] = $min if $lst[$i] >= $min;\n\
    \        $strange_sort[$i] = $new_max if $lst[$i] >= $new_max;\n        $i++;\n\
    \    }\n    return \\@strange_sort;\n}", "    $lst =~ m/^(?:(\\d)\\s+)?(\\d+)\\\
    s+(\\d+)\\s+(\\d+)$/;\n    my @ret = ();\n    my ($max_int, $min_int, $max_val,\
    \ $min_val);\n    if ($1) {\n        # first number is minimum\n        $max_int\
    \ = $1;\n        $min_int = $2;\n        $max_val = $3;\n        $min_val = $4;\n\
    \    } else {\n        # no minimum\n        $max_int = $3;\n        $min_int\
    \ = $4;\n        $max_val = $2;\n        $min_val = $1;\n    }", "    my @lst_copy\
    \ = @_;\n    my $i = 0;\n    while ($i < @lst_copy) {\n        my $min = $i;\n\
    \        for ($i++; $i < @lst_copy && $lst_copy[$i] <= $lst_copy[$min]; $i++)\
    \ {\n            $min = $i;\n        }\n        my $j = $i;\n        for ($j++;\
    \ $j < @lst_copy && $lst_copy[$j] >= $lst_copy[$min]; $j++) {\n            $min\
    \ = $j;\n        }\n        if ($i != $j) {\n            splice @lst_copy, $min,\
    \ 0, $lst_copy[$i], $lst_copy[$j];\n        }\n    }\n    return @lst_copy;\n}",
  "    my @result;\n    for (my $i = 0; $i < @$lst; ++$i) {\n        if ($i > 0) {\n\
    \            my $smallest_next = pop @$lst - 1;\n            if ($smallest_next\
    \ < $lst->[$smallest_next]) {\n                push @result, $smallest_next;\n\
    \                push @$lst, $smallest_next;\n            }\n        }\n     \
    \   push @$lst, $lst->[$i];\n    }\n    return @result;\n}", "    return sort($lst)\
    \ unless $lst;\n    my @copy = @$lst;\n    for (my $i = 0; $i < scalar @copy;\
    \ $i++) {\n        my $min = $copy[$i];\n        for (my $j = $i+1; $j < scalar\
    \ @copy; $j++) {\n            if ($copy[$j] < $min) {\n                for (my\
    \ $k = @copy; $k >= $j; $k--) {\n                    $copy[$k+1] = $copy[$k];\n\
    \                }\n                $copy[$j+1] = $min;\n            }\n     \
    \   }\n    }\n    return @copy;\n}", "    my @res;\n    my $min = $lst[0];\n \
    \   my $max = $lst[0];\n    for (my $i = 1; $i < @$lst; ++$i) {\n        my $cur_min\
    \ = $min if $min > $lst[$i];\n        my $cur_max = $max if $max < $lst[$i];\n\
    \        $min = $cur_max if $cur_min > $cur_max;\n        $max = $cur_min if $cur_min\
    \ < $cur_max;\n    }\n    $min = $min if $min == $max;\n    for (my $i = 0; $i\
    \ < @$lst; ++$i) {\n        push (@res, $lst[$i] if $min < $lst[$i] && $max >\
    \ $lst[$i]);\n    }\n    return @res;\n}", "    my @ordered_list = ();\n    my\
    \ $minimum = pop(@lst);\n    my $maximum = pop(@lst);\n    push(@ordered_list,\
    \ \"$minimum\");\n    push(@ordered_list, $maximum) if @lst;\n    for (my $i =\
    \ $minimum; $i < $maximum; $i++) {\n        push(@ordered_list, $i);\n    }\n\
    \    while(@lst) {\n        my $item = pop(@lst);\n        push(@ordered_list,\
    \ $item);\n    }\n    return @ordered_list;\n}", "    my $min = scalar(@$lst);\n\
    \    my $max = scalar(@$lst) - 1;\n    my @sorted = ();\n    while($min <> $max)\
    \ {\n        my $mid = $min + $max / 2;\n        @sorted[$mid] = $lst[$mid];\n\
    \        $min = $mid if $mid > $min;\n        $max = $mid if $mid < $max;\n  \
    \  }\n    return @sorted;\n}", "    my($min_val) = 0;\n    my($max_val) = 0;\n\
    \    foreach (@$lst) {\n        # Handle edge case: last element has no minimum\
    \ value\n        $min_val = 0 unless defined $min_val;\n        $max_val = 0 unless\
    \ defined $max_val;\n        next if $min_val eq $max_val;\n        $min_val =\
    \ ${$min_val}\n            if defined ${$min_val};\n        $max_val = ${$max_val}\n\
    \            if defined ${$max_val};", "    my $i = 0;\n    my @new_lst;\n   \
    \ my $max_val = $lst[0];\n    my $min_val = $lst[0];\n    foreach my $num (@$lst)\
    \ {\n        if($num == $max_val){\n            $max_val += 1;\n        } elsif($num\
    \ == $min_val){\n            $min_val -= 1;\n        } else {\n            push\
    \ @new_lst, $num;\n        }\n    }\n    return @new_lst;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| c |>\nThis works fine on the sample data, but fails on real life data\
    \ (for example, for data that has negative numbers and zero). So it isn't a good\
    \ solution. Also, it seems like the sorting algorithm is O(N^2) which is pretty\
    \ bad, since it would be possible to do it in O(N).\n<|/ c |>\n<| a dscore=0 tags=perl,arrays\
    \ |>\nThis code worked for me:\n<code>", "    my @sorted = ();\n    my $temp;\n\
    \    my $min = $lst[0];\n    my $max = $lst[0];\n    my $i;\n    for $i (1 ..\
    \ $#lst) {\n        if ($lst[$i] < $min) {\n            $min = $lst[$i];\n   \
    \     }\n        if ($lst[$i] > $max) {\n            $max = $lst[$i];\n      \
    \  }\n    }\n    push(@sorted, '$min');\n    for $i (1 .. $#lst) {\n        $temp\
    \ = $lst[$i];\n        $lst[$i] = $min;\n        $min = $temp;\n        push(@sorted,\
    \ '$max');\n        $max = $lst[$i];\n    }\n    push(@sorted, '$min');\n    return\
    \ @sorted;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl,arrays |>\nApart from\
    \ sorting (as suggested by other answers), you can also use an O(n) search to\
    \ find the minimum element and swap with the first element.  That will give you\
    \ the correct final answer.  \n<code>\nuse strict;\nuse warnings;", '    my @sorted
    = ();', "    my @sorted = ();\n    my $min = 9999999999;\n    my $max = -9999999999;",
  '    my @sorted = ();', '    my @new_lst = ();', "    if(!@$lst) {\n        return;\n\
    \    }\n    my @res;\n    while(@$lst) {\n        my $cur = pop @$lst;\n     \
    \   push @res, $cur;\n    }\n    return @res;\n}", "    my($minimum);\n    my($maximum);\n\
    \    my(@result);", "    my $tmp = [];\n    my $n = @$lst;\n    for(my $i = 0;\
    \ $i < $n; $i++) {\n        my $j = $i;\n        $j = $n - $i - 1;\n        while($j\
    \ > 0 && $lst->[$j] <  $lst->[$j - 1]) {\n            my $tmp = pop @$lst;\n \
    \           push @$lst, $tmp;\n            $j--;\n        }\n    }\n    return\
    \ @$lst;\n}", "    return sort { $a <=> $b } @$lst;\n}", "    my($i, $j) = (0,\
    \ 0);\n    my @sorted_list;", "    my $len = @$lst;\n    my @retval = ();\n  \
    \  my $min = $lst->[0];\n    my $max = $lst->[0];\n    for my $i (1..$len-1) {\n\
    \        $max = $lst->[$i] if $lst->[$i] > $max;\n        $min = $lst->[$i] if\
    \ $lst->[$i] < $min;\n    }\n    for my $i ($len-1..0) {\n        $retval[$i]\
    \ = $lst->[$i] if $lst->[$i] > $max;\n        $retval[$i] = $lst->[$i] if $lst->[$i]\
    \ < $min;\n        $max = $lst->[$i] if $lst->[$i] > $max;\n        $min = $lst->[$i]\
    \ if $lst->[$i] < $min;\n    }\n    $retval;\n}", "    # reverse array\n    @$lst\
    \ = reverse(@$lst);\n    # initialize max index\n    my($max) = scalar(@$lst)\
    \ - 1;\n    # iterate over list\n    for ($i = 0; $i < scalar(@$lst); $i++) {\n\
    \        # set first item to max value\n        $lst[$i] = $max;\n        # increment\
    \ max index\n        $max++;\n    }\n    # set first item to min value\n    $lst[0]\
    \ = 0;\n    return $lst;\n}\n</code>\n<|/ a tags=perl,sorting,arrays |>\n<| c\
    \ |>\nHi, I like the idea of using a recursive function to sort the array recursively,\
    \ but I'm having some problems understanding your code. ", "    my $min = @$lst\
    \ ? $lst[0] : 0;\n    my $max = @$lst ? $lst[-1] : 0;\n    my $i = 1;\n    for\
    \ (; $i < @$lst; $i++) {\n        if ($lst[$i] < $min) {\n            $min = $lst[$i];\n\
    \        } elsif ($lst[$i] > $max) {\n            $max = $lst[$i];\n        }\
    \ else {\n            splice(@$lst, $i, 0, $min);\n            $min++;\n     \
    \   }\n    }\n    return @$lst;\n}", "    my($i, $j, $temp);\n    my @sorted_lst\
    \ = ();\n    # first loop is for looping through the numbers from minimum to\n\
    \    # maximum\n    # second loop is for looping through the numbers from minimum\
    \ to\n    # maximum\n    for($i = 0, $j < @$lst, $i <= @$lst, $j++) {\n      \
    \  $temp = @$lst[$i];\n        # if we have reached the first element\n      \
    \  # then start going through the rest of the elements\n        if($i == $j) {\n\
    \            for(; $j < @$lst, $j++) {\n                push @sorted_lst, @$lst[$j];\n\
    \            }\n        # if we have reached the last element\n        # then\
    \ start going through the rest of the elements\n        } elsif($i == @$lst -\
    \ 1) {\n            for(; $i < @$lst, $i++) {\n                push @sorted_lst,\
    \ @$lst[$i];\n            }\n        # otherwise swap current element and next\
    \ element\n        } else {\n            @$lst[$i], @$lst[$j] = @$lst[$j], @$lst[$i];\n\
    \        }\n    }\n    return @sorted_lst;\n}", "    $lst =~ tr/a-z/A-Z/;\n  \
    \  $lst =~ s/^-//;\n    my @sorted = sort { $a <=> $b } @$lst;\n    return @sorted;\n\
    }", "    if (@$lst == 0) {\n        return [];\n    }", "    my $len = scalar\
    \ @$lst;\n    my $i = 0;\n    my @res;", "    my @sorted = ();\n    my $max =\
    \ -1;", '    my ($i, $j, $k, $temp);', "    my($min, $max) = (0, 0);\n    foreach\
    \ my $el (@$lst) {\n        if ($el < $min) {\n            $min = $el;\n     \
    \   } elsif ($el > $max) {\n            $max = $el;\n        }\n    }\n    return\
    \ sort { ($a <=> $b) <=> ($b < $a ? ($min <=> $max) : ($max <=> $min)) };\n}",
  '    my($min, $max, $tmp, $nval);', "    my $ret = [];\n    for (my $i = @$lst -\
    \ 1; $i >= 0; $i--) {\n        push(@$ret, @$lst[$i..$#{$lst}]);\n    }\n    return\
    \ @$ret;\n}", "    my($strange_list, $first_number, $last_number);\n    $first_number\
    \ = $lst[0];\n    $last_number = $lst[-1];\n    my $min_number = $first_number;\n\
    \    my $max_number = $last_number;", "    my($sorted);\n    \n    # Find the\
    \ minimum and maximum\n    $sorted = $lst[0];\n    for my $x (@$lst) {\n     \
    \   if ($x < $sorted) {\n            $sorted = $x;\n        }\n    }", "    my\
    \ @new_list;\n    my $temp;\n    my $min = $lst[0];\n    my $max = $lst[0];\n\
    \    for (my $i = 1; $i < @$lst; ++$i) {\n        if ($lst[$i] < $min) {\n   \
    \         $min = $lst[$i];\n        } elsif ($lst[$i] > $max) {\n            $max\
    \ = $lst[$i];\n        } else {\n            $temp = @{$lst}[0..$i-1];\n     \
    \       push (@new_list, $temp);\n        }\n    }\n    push (@new_list, $min,\
    \ $max);\n    return @new_list;\n}", "    if(!$lst || @$lst == 0) {\n        return\
    \ [];\n    }\n    my %sort_map = map { ($_, $_) } 0..$#lst;\n    my @sorted_list\
    \ = ();\n    my @remaining = ();\n    $sort_map{$lst[0]} = 0;\n    while(@lst)\
    \ {\n        my $cur = shift @lst;\n        push @remaining, $cur;\n        push\
    \ @sorted_list, $cur;\n        $sort_map{$cur} = 1;\n    }\n    foreach my $key\
    \ (sort { $sort_map{$a} <=> $sort_map{$b} } keys %sort_map) {\n        foreach\
    \ my $idx (@remaining) {\n            if($idx >= $key) {\n                push\
    \ @sorted_list, $idx;\n                splice(@remaining, $idx, 1);\n        \
    \    }\n        }\n    }\n    return @sorted_list;\n}", "    my @sorted = sort\
    \ {\n        $a <=> $b\n    } @$lst;\n    return @sorted;\n}", "    # sort by\
    \ first value\n    $lst =~ s/^(-?[0-9]*\\..*)/$1.$2/e;\n    # sort by second value\n\
    \    $lst =~ s/^(-?[0-9]*\\..*)/$1.$2/e;\n    # sort by third value\n    $lst\
    \ =~ s/^(-?[0-9]*\\..*)/$1.$2/e;\n    # sort by fourth value\n    $lst =~ s/^(-?[0-9]*\\\
    ..*)/$1.$2/e;\n    return $lst;\n}", "    my;\n    $lst =~ m/(\\d+)/g;\n    my\
    \ $min_val = shift(@lst);\n    my $max_val = pop(@lst);\n    $max_val = $min_val\
    \ if $max_val < $min_val;\n    foreach my $value (@lst) {\n        if ($value\
    \ > $max_val && $value < $min_val) {\n            push, $min_val;\n          \
    \  $min_val = pop(@lst);\n        } elsif ($value >= $min_val && $value < $max_val)\
    \ {\n            push, $value;\n        } elsif ($value > $max_val) {\n      \
    \      push, $max_val;\n            $max_val = pop(@lst);\n        } else {\n\
    \            push, $value;\n        }\n    }\n    return \\@sorted_list;\n}",
  '    my(@sorted_lst);', "    my;\n    my($i, $j, $min, $max);\n    $max = $lst[0];\n\
    \    $min = $lst[0];\n    $i = 1;\n    $j = 1;\n    foreach $val (@{$lst}) {\n\
    \        if ($val > $max) {\n            $max = $val;\n        }\n        if ($val\
    \ < $min) {\n            $min = $val;\n        }\n        if ($val == $min) {\n\
    \            $j = @lst + 1;\n            push (@sorted, $i);\n            $i =\
    \ $j;\n        }\n        if ($val == $max) {\n            push (@sorted, $j);\n\
    \            $j = $i;\n        }\n    }\n    push (@sorted, $j);\n    return @sorted;\n\
    }", "    my(@strange);\n    my $min;\n    my $max;\n    my $tmp;", "    if(!$lst)\
    \ {\n\treturn [];\n    }", "    my @res;\n    my($i, $tmp, $j, $tmp2);\n    \n\
    \    foreach $i (sort {$a <=> $b} @$lst) {\n        $tmp = $i;\n        $tmp2\
    \ = $lst[$i];\n        foreach $j (sort {$a <=> $b} @$lst) {\n            if ($j\
    \ ne $tmp2) {\n                $tmp = $j;\n                last;\n           \
    \ }\n        }\n        $res[$i] = $tmp;\n    }\n    return @res;\n}", "    $lst\
    \ =~ m@^( (?:, ?(?<min>\\d+)(?:,(?<max>\\d+))? )*(?<min>\\d+) (?:, (?<max>\\d+))?\
    \ )*$@xsmg;\n    my(@min, $max, @rest) = @{$+{min}}{@{$+{max}}};\n    return $lst\
    \ if @min == @max;\n    return @rest if @min > @max;\n    my ($min, $max) = @min;\n\
    \    for (@min) {\n        push @rest, $_;\n    }\n    for (@max) {\n        push\
    \ @rest, ($min++, $_);\n    }\n    return @rest;\n}", "    my @list = ();\n  \
    \  my @unsorted = ();\n    for (my $index = 0; $index < @$lst; $index++) {\n \
    \       my $value = $lst->[$index];\n        if ($index < @unsorted) {\n     \
    \       push(@list, $unsorted[$index]);\n            pop(@unsorted);\n       \
    \ }\n        push(@unsorted, $value);\n    }\n    push(@list, @unsorted);\n  \
    \  return @list;\n}", "    if(!$lst) {\n\treturn [];\n    }\n    my @results;\n\
    \    for(my $i = 1; $i < $#lst; $i++) {\n\tmy $min = $lst[$i];\n\tmy $max = $lst[$i-1];\n\
    \tmy $tmp = $i;\n\tfor(my $j = $i+1; $j < $#lst; $j++) {\n\t    if($lst[$j] <\
    \ $min) {\n\t\t$min = $lst[$j];\n\t    }\n\t    elsif($lst[$j] > $max) {\n\t\t\
    $max = $lst[$j];\n\t    }\n\t}\n\tpush @results, $min;\n\tpush @results, $max;\n\
    \tpush @results, $tmp;\n    }\n    return @results;\n}", "    my $max = pop @$lst;\n\
    \    pop @$lst, pop @$lst;\n    pop @$lst, pop @$lst;\n    pop @$lst, pop @$lst;\n\
    \    pop @$lst, pop @$lst;\n    pop @$lst, pop @$lst;\n    push @$lst, $max, pop\
    \ @$lst;\n    return @$lst;\n}", "    return [] unless (@$lst > 0);\n    my @res;",
  "    my(@sorted);\n    my $i = 0;\n    while($i < $#lst) {\n        my $min = $lst[$i];\n\
    \        my $max = $lst[$i];\n        my $min_index = $i;\n        for(my $j =\
    \ $i + 1; $j < $#lst; ++$j) {\n            next if $lst[$j] < $lst[$min_index];\n\
    \            if($lst[$j] < $min) {\n                $min = $lst[$j];\n       \
    \         $min_index = $j;\n            }\n        }\n        push (@sorted, $min);\n\
    \        splice(@lst, $min_index + 1, 0, $max);\n        ++$i;\n    }\n    return\
    \ @sorted;\n}", '    my @sorted_lst = ();', "    my @lst;\n    my @last_element;\n\
    \    my $min;\n    my $max;\n    $min = $lst[0];\n    $max = $lst[0];\n    foreach\
    \ my $val (@lst) {\n        if ($val < $min) {\n            $min = $val;\n   \
    \     }\n        if ($val > $max) {\n            $max = $val;\n        }\n   \
    \ }\n    foreach my $val (@lst) {\n        push(@lst, $val);\n        push(@lst,\
    \ $max);\n        push(@lst, $min);\n        push(@lst, $val);\n        push(@lst,\
    \ $min);\n        push(@lst, $max);\n    }\n    return @lst;\n}", "    return\
    \ () unless @$lst;\n    my $min = pop(@$lst);\n    my $max = pop(@$lst);\n   \
    \ while (@$lst) {\n        my $temp = pop(@$lst);\n        push($max, $temp);\n\
    \        push($min, $temp);\n    }\n    push($min, $max);\n    return @$lst;\n\
    }", '    my @res = ();', "    my @list = ();\n    my $min = $lst[0];\n    my $max\
    \ = scalar(@$lst) - 1;\n    for(my $i = 1; $i <= $max; $i++){\n        push @list,\
    \ $min if $min > $lst[$i];\n        push @list, $lst[$i] if $lst[$i] < $max;\n\
    \        push @list, $max if $max > $lst[$i];\n        $min = $lst[$i];\n    \
    \    $max = $lst[$i];\n    }\n    push @list, $min if $min > $max;\n    push @list,\
    \ $max if $max > $min;\n    return \\@list;\n}\n</code>\n<|/ a tags=perl,sorting\
    \ |>\n<| c |>\nThis code doesn't work. For example, for `[1, 2, 3, 4]` it returns\
    \ `[1, 1, 2, 2, 3, 4]`\n<|/ c |>\n<| c |>\nThis doesn't work correctly for lists\
    \ where there are ties, like `[2, 2, 2, 2, 1]`\n<|/ c |>\n<| a |>\nHere's a way\
    \ that doesn't use sort(). Instead it uses the key() function, which returns a\
    \ sortable version of the index of an array item:\n<code>", "    my @lst = $lst;\n\
    \    @lst = (sort { $a <=> $b } @lst);\n    @lst = (sort { $b <=> $a } @lst);\n\
    \    @lst = (sort { $a <=> $b } @lst);\n    return @lst;\n}", '    my (@sorted_list,
    @strange_list);', "    my @results;\n    my @current_result;\n    my $i = 0;\n\
    \    my $min = 0;\n    my $max = $#lst + 1;\n    while (1) {\n        if ( $i\
    \ == $max ) {\n            push (@results, $lst[$min]);\n            $min++;\n\
    \        }\n        elsif ( $i == $min ) {\n            push (@results, $lst[$max]);\n\
    \            $max--;\n        }\n        elsif ( $max < $min ) {\n           \
    \ push (@results, $lst[$min]);\n            $min++;\n        }\n        elsif\
    \ ( $min > $max ) {\n            push (@results, $lst[$max]);\n            $max--;\n\
    \        }\n        elsif ( $i < $min ) {\n            push (@results, $lst[$i]);\n\
    \            $i++;\n        }\n        else {\n            push (@results, $lst[$min]);\n\
    \            $min++;\n        }\n    }\n    return @results;\n}", "    my @sort_list;\n\
    \    my($key, $val, $min_val) = undef;\n    my($min, $max) = undef;\n    foreach\
    \ $key (sort {($a <=> $b)} keys %$lst) {\n\t$val = $lst->{$key};\n\t$min = $val\
    \ if !defined $min or $val < $min;\n\t$max = $val if !defined $max or $val > $max;\n\
    \    }\n    return sort({($a <=> $b) if defined $a && defined $b},\n\t   $min,\
    \ $max);\n}", "    my @res;\n    for my $i (0..$#$lst) {\n        my $min = $i;\n\
    \        my $max = $i;\n        for (my $j = $i + 1; $j <= $#$lst - 1; $j++) {\n\
    \            next if ($lst[$j] < $lst[$min] && $lst[$j] > $lst[$max]);\n     \
    \       $min = $j;\n            $max = $j;\n        }\n        push @res, $lst[$min];\n\
    \        push @res, $lst[$max];\n    }\n    push @res, pop @res;\n    return @res;\n\
    }", "    my @sorted_list = ();\n    my $min = $lst[0];\n    my $max = $lst[0];\n\
    \    foreach my $val (@$lst) {\n        if ($val > $max) {\n            $max =\
    \ $val;\n        } elsif ($val < $min) {\n            $min = $val;\n        }\
    \ else {\n            push(@sorted_list, $val);\n        }\n    }\n    return\
    \ @sorted_list;\n}", '    my @sorted = ();', '    my $len = scalar @$lst;', " \
    \   return []\n\tunless @$lst;\n    my $min_value = $lst->[0];\n    my $max_value\
    \ = $lst->[-1];\n    return $min_value if $min_value > $max_value;\n    my $i\
    \ = 1;\n    while ($i <= @$lst - 1) {\n        if ($i < @$lst - 1) {\n       \
    \     my $tmp = $min_value;\n            $min_value = $lst->[$i];\n          \
    \  $lst->[$i] = $tmp;\n        }\n        $i++;\n    }\n    return $lst;\n}",
  "    my @out = ();\n    while (@lst) {\n        my $min = pop(@lst);\n        while\
    \ (@lst && $min > pop(@lst)) {\n            push(@out, pop(@lst));\n        }\n\
    \        push(@out, $min);\n    }\n    return @out;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nYour algorithm isn't O(n) it's O(n log n) though.\n<|/ c |>\n<| c |>\n\
    : I guess it depends on the implementation. How does it compare to `O(n^2)`? If\
    \ it also takes O(n) time to find the minimum, then sure, the answer is O(n^2).\
    \ The question is whether that is a constant time algorithm or not. I'm really\
    \ only trying to show the algorithm to OP, without giving them the whole solution.\n\
    <|/ c |>\n<| c |>\nWell, it's O(n log n) because you have to do O(n) work to find\
    \ the minimum.  Then you do O(n) work to do the next minimum etc.  Your algorithm\
    \ is O(n^2) because you do O(n^2) work to find the minimum.\n<|/ c |>\n<| c |>\n\
    : Good point. Though I thought I covered that in my answer. Also, it's probably\
    \ worth noting that my O(n) solution is just as efficient as the solution suggested\
    \ by Amadan, and also more clear.\n<|/ c |>\n<| c |>\nThe algorithm is O(n^2)\
    \ not O(n log n) because you do O(n^2) work to find the minimum.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nOne easy solution is to use an array of size 10, with index from\
    \ 0 to 9. Using this array, you just have to iterate through your list and assign\
    \ each element to your corresponding index in your array. Once the end of your\
    \ list is reached, you just have to iterate through the array backwards, and swap\
    \ the element with the element with the smallest value. At this point, your array\
    \ is in sorted order. \nSo here's a code sample : \n<code>\nvoid sort(int numbers[])\n\
    {\n    int temp;\n    int arrayIndex = 10;\n    int position = 0;", "    \n  \
    \  my $i = 0;\n    my @sorted_lst = ();\n    my @unsorted_lst = ();\n    \n  \
    \  while ($i < @$lst) {\n        push @unsorted_lst, $lst->[$i];\n        ++$i;\n\
    \    }\n    \n    foreach my $i (0 .. $#$unsorted_lst) {\n        my $smallest\
    \ = min @$unsorted_lst;\n        my $largest = max @$unsorted_lst;\n        my\
    \ $middle_element = int(($smallest+$largest)/2);\n        \n        if (@$lst\
    \ > 2) {\n            $smallest = $unsorted_lst->[$middle_element];\n        \
    \    $largest = $unsorted_lst->[$middle_element+1];\n        }\n        \n   \
    \     if ($smallest != $largest) {\n            push @sorted_lst, $smallest;\n\
    \            push @sorted_lst, $largest;\n        }\n        else {\n        \
    \    push @sorted_lst, $unsorted_lst->[$middle_element];\n        }\n    }\n \
    \   return @sorted_lst;\n}", '    my @sorted_list = ();', "    return []\n   \
    \     unless @$lst;", '    my @result;', "    my @res = ();\n    my $max_val =\
    \ -1;\n    my $max_idx = -1;", "    my @tmp;\n    my @sorted_list = ();\n    my\
    \ $min;\n    my $max;\n    my $min_list = 0;\n    my $max_list = 0;\n    # Looping\
    \ through the list, find minimum and maximum value.\n    foreach my $val (@$lst)\
    \ {\n        if ($val < $min) {\n            $min = $val;\n            $min_list++;\n\
    \        } elsif ($val > $max) {\n            $max = $val;\n            $max_list++;\n\
    \        }\n    }\n    if ($min_list == 0 && $max_list == 0) {\n        return\
    \ @sorted_list;\n    }\n    if ($min_list == 0) {\n        # Find minimum of remaining\
    \ elements.\n        $min = $max;\n        foreach my $val (@$lst) {\n       \
    \     if ($val < $min) {\n                $min = $val;\n            }\n      \
    \  }\n        push(@sorted_list, $min);\n    } else {\n        # Find maximum\
    \ of remaining elements.\n        $max = $min;\n        foreach my $val (@$lst)\
    \ {\n            if ($val > $max) {\n                $max = $val;\n          \
    \  }\n        }\n        push(@sorted_list, $max);\n    }\n    # Looping through\
    \ the list, adding minimum and maximum value\n    # to sorted list if the elements\
    \ lie between the minimum\n    # and maximum values.\n    foreach my $val (@$lst)\
    \ {\n        if ($val <= $min) {\n            push(@sorted_list, $min);\n    \
    \        $min++;\n        } elsif ($val >= $max) {\n            push(@sorted_list,\
    \ $max);\n            $max--;\n        } else {\n            push(@sorted_list,\
    \ $val);\n        }\n    }\n    return @sorted_list;\n}", "    my @sorted = ();\n\
    \    my $min_value = $lst[0];\n    my $max_value = $lst[0];\n    my $min_position\
    \ = 0;\n    my $max_position = 1;\n    while ($min_value <= $max_value) {\n  \
    \      $sorted[$min_position] = $min_value;\n        $min_value += 1;\n      \
    \  $min_position += 1;\n    }\n    while ($max_value >= $min_value) {\n      \
    \  $sorted[$max_position] = $max_value;\n        $max_value -= 1;\n        $max_position\
    \ += 1;\n    }\n    while ($min_value <= $max_value) {\n        $sorted[$max_position]\
    \ = $min_value;\n        $min_value += 1;\n        $max_position += 1;\n    }\n\
    \    $sorted[$max_position] = $min_value;\n    return @sorted;\n}", "    my($max);\n\
    \    my($min);\n    my($min_inc);\n    my($max_inc);\n    my(@sorted);\n    my($val);\n\
    \    my($tmp);\n    $max = $min = -1;\n    foreach $val (@$lst) {\n        if\
    \ ($val > $max) {\n            $max = $val;\n        } elsif ($val < $min) {\n\
    \            $min = $val;\n        }\n    }\n    foreach $val (@$lst) {\n    \
    \    $min_inc = 0;\n        $max_inc = 0;\n        if ($val < $min) {\n      \
    \      $min_inc = 1;\n        }\n        if ($val > $max) {\n            $max_inc\
    \ = 1;\n        }\n        $tmp = $min + $min_inc;\n        if ($val != $tmp)\
    \ {\n            $sorted[$tmp] = $val;\n        }\n        $tmp = $max + $max_inc;\n\
    \        if ($val != $tmp) {\n            $sorted[$tmp] = $val;\n        }\n \
    \   }\n    return @sorted;\n}", '    my @sorted_list = ();', "    my @list;\n\
    \    push(@list, $lst[0]) if @$lst > 0;\n    push(@list, $lst[1]) if @$lst > 1;\n\
    \    push(@list, $lst[2]) if @$lst > 2;\n    push(@list, $lst[3]) if @$lst > 3;\n\
    \    return @list;\n}", '    my @out;', "    my @out;\n    for (my $i = @$lst\
    \ - 1; $i >= 0; $i--) {\n        $out[$i] = $lst[$i];\n    }\n    @$lst = @out;\n\
    \    return;\n}", '    my($i, $min, $max);', "    my @sorted_lst = ();\n    my\
    \ $min = min($lst);\n    my $max = max($lst);\n    my $curr_max = -1;\n    my\
    \ $curr_min = -1;\n    foreach my $num (@$lst) {\n        if ($num == $curr_max)\
    \ {\n            $curr_min = min($sorted_lst);\n        } elsif ($num == $curr_min)\
    \ {\n            $curr_max = max($sorted_lst);\n        } elsif ($num == $min)\
    \ {\n            push (@sorted_lst, '1');\n            $min = min($sorted_lst);\n\
    \        } elsif ($num == $max) {\n            push (@sorted_lst, '2');\n    \
    \        $max = max($sorted_lst);\n        } elsif ($num > $min) {\n         \
    \   push (@sorted_lst, $num);\n        } else {\n            push (@sorted_lst,\
    \ $curr_max);\n            $curr_max = -1;\n            push (@sorted_lst, $num);\n\
    \        }\n    }\n    return @sorted_lst;\n}", '    my @sorted = ();', "    my(@sorted_lst);\n\
    \    my($first);\n    my($last);\n    my($value);\n    my($length);\n    my($min);\n\
    \    my($max);", '    return () unless @$lst;', "    if (@$lst == 0) {\n     \
    \   return @$lst;\n    }\n    my $min = $lst[0];\n    for (my $i = 1; $i < @$lst;\
    \ $i++) {\n        if ($lst[$i] < $min) {\n            my $temp = $lst[$i];\n\
    \            $lst[$i] = $min;\n            $min = $temp;\n        }\n    }\n \
    \   return @$lst;\n}", '    my(@sorted_list) = ();', "    my @rev_lst;\n    if\
    \ (@$lst == 0) {\n        return $lst;\n    }\n    my $max_value = $lst[0];\n\
    \    my $min_value = $lst[0];\n    foreach my $val (@$lst) {\n        if ($val\
    \ < $min_value) {\n            $min_value = $val;\n        } elsif ($val > $max_value)\
    \ {\n            $max_value = $val;\n        }\n    }\n    foreach my $val (@$lst)\
    \ {\n        if ($val == $max_value) {\n            push @rev_lst, $min_value;\n\
    \            $min_value = $max_value;\n            $max_value = $val;\n      \
    \  } elsif ($val == $min_value) {\n            push @rev_lst, $max_value;\n  \
    \          $min_value = $val;\n            $max_value = $max_value;\n        }\n\
    \    }\n    push @rev_lst, $min_value;\n    return @rev_lst;\n}", "    my $i =\
    \ 0;\n    my @sorted;\n    my @temp_lst;", '    my $new_lst = ();', '    my @sorted_list
    = ();', "    $lst = sort {\n        my $key = $a <=> $b;\n        $key == -1 ?\
    \ ($a <=> $b) : $key\n    }\n}", "    $lst =~ s/\\[//;\n    $lst =~ s/\\]//;\n\
    \    $lst =~ s/\\@//;\n    $lst =~ s/\\~//;\n    $lst =~ s/\\&//;\n    $lst =~\
    \ s/\\|//;\n    $lst =~ s/\\#//;\n    $lst =~ s/\\^//;\n    $lst =~ s/\\_//;\n\
    \    $lst =~ s/\\*//;\n    $lst =~ s/\\/\\//;\n    $lst =~ s/\\;//;\n    $lst\
    \ =~ s/\\://;\n    $lst =~ s/\\?//;\n    $lst =~ s/\\%//;\n    $lst =~ s/\\,//;\n\
    \    $lst =~ s/\\.//;\n    $lst =~ s/\\//;\n    $lst =~ s/\\=//;\n    $lst =~\
    \ s/\\-//;\n    $lst =~ s/\\+//;\n    $lst =~ s/\\*//;\n    $lst =~ s/\\_//;\n\
    \    $lst =~ s/\\%//;\n    $lst =~ s/\\~//;\n    $lst =~ s/\\&//;\n    $lst =~\
    \ s/\\|//;\n    $lst =~ s/\\#//;\n    $lst =~ s/\\^//;\n    $lst =~ s/\\_//;\n\
    \    $lst =~ s/\\*//;\n    $lst =~ s/\\/\\//;\n    $lst =~ s/\\;//;\n    $lst\
    \ =~ s/\\://;\n    $lst =~ s/\\?//;\n    $lst =~ s/\\%//;\n    $lst =~ s/\\,//;\n\
    \    $lst =~ s/\\.//;\n    $lst =~ s/\\//;\n    $lst =~ s/\\=//;\n    $lst =~\
    \ s/\\-//;\n    $lst =~ s/\\+//;\n    $lst =~ s/\\*//;\n    $lst =~ s/\\_//;\n\
    \    $lst =~ s/\\%//;\n    $lst =~ s/\\~//;\n    $lst =~ s/\\&//;\n    $lst =~\
    \ s/\\", '    return () unless @$lst;', "    my(@sorted_lst);\n    for my $value\
    \ (@$lst) {\n        push(@sorted_lst, $value);\n        if ($value == scalar(@$lst))\
    \ {\n            push(@sorted_lst, $value);\n        }\n    }\n    return @sorted_lst;\n\
    }", "    my @result = ([], [], [], []);\n    my $min = 10000000;\n    my $max\
    \ = 0;\n    my $tmp;\n    while (@$lst) {\n        my $v = (@$lst, $tmp);\n  \
    \      @$lst = ();\n        if ($v->[0] < $min) {\n            $min = $v->[0];\n\
    \        }\n        if ($v->[1] > $max) {\n            $max = $v->[1];\n     \
    \   }\n        $tmp = $v->[2];\n        push (@$result, $v->[0]);\n        push\
    \ (@$result, $v->[1]);\n        push (@$result, $v->[2]);\n        push (@$result,\
    \ $v->[3]);\n    }\n    map {\n        my $tmp = $_;\n        @$lst = ($tmp);\n\
    \        $tmp = $v->[3];\n        push (@$result, $v->[0]);\n        push (@$result,\
    \ $v->[1]);\n        push (@$result, $v->[2]);\n        push (@$result, $v->[3]);\n\
    \    } sort {\n        return $a <=> $b;\n    };\n    @$lst = ($tmp);\n    map\
    \ {\n        my $tmp = $_;\n        @$lst = ($tmp);\n        $tmp = $v->[1];\n\
    \        push (@$result, $v->[0]);\n        push (@$result, $v->[1]);\n      \
    \  push (@$result, $v->[2]);\n        push (@$result, $v->[3]);\n    } sort {\n\
    \        return $a <=> $b;\n    };\n    @$lst = ($tmp);\n    map {\n        my\
    \ $tmp = $_;\n        @$lst = ($tmp);\n        $tmp = $v->[2];\n        push (@$result,\
    \ $v->[0]);\n        push (@$result, $v->[1]);\n        push (@$result, $v->[2]);\n\
    \        push (@$result, $v->[3]);\n    } sort {\n        return $a <=> $b;\n\
    \    };\n    @$lst = ($tmp);\n    map {\n        my $tmp = $_;\n        @$lst\
    \ = ($tmp);\n        $tmp = $v->[3];\n        push (@$result, $v->[0]);\n    \
    \    push (@$result, $v->[1]);\n        push (@$result, $v->[2]);\n        push\
    \ (@$result, $v->[3]);\n    } sort {\n        return $a <=> $b;\n    };\n    @$",
  "    return @$lst if scalar @$lst < 2;\n    my($min, $max) = @$lst;\n    my $len\
    \ = @$lst;\n    my @temp;\n    \n    for (my $i = 0; $i < $len; ++$i) {\n    \
    \    push(@temp, $i);\n    }", "    $lst =~ s/^(-?\\d+)(.*?)$/$2 || $1 . \"-\"\
    \ . $2/ for 1..$#lst;\n    return sort { $a <=> $b } @$lst;\n}", "    my(@sorted_lst);\n\
    \    for (my $i = $#lst; $i >= 1; $i--) {\n        my $max = shift(@lst);\n  \
    \      foreach my $elem (@lst) {\n            if ($elem > $max) {\n          \
    \      push(@sorted_lst, $elem);\n                $max = $elem;\n            }\n\
    \        }\n        push(@sorted_lst, $max);\n    }\n    return @sorted_lst;\n\
    }", "    my @sorted_list = ();\n    my $min = $lst[0];\n    my $max = $lst[-1];\n\
    \    my $index = 0;\n    my %counts;\n    my $max_index = scalar (@$lst) - 1;\n\
    \    while (@$lst > 0 && $max_index >= 0) {\n        my $val = shift @$lst;\n\
    \        $counts{ $val } = exists $counts{ $val } ? $counts{ $val } + 1 : $counts{\
    \ $val };\n        if ($val <= $max) {\n            $min = $val if $val < $min;\n\
    \            $max = $val if $val > $max;\n            $sorted_list[$index++] =\
    \ $val;\n        } elsif ($val == $max) {\n            if ($index > 0) {\n   \
    \             my $new_max = $sorted_list[$index - 1];\n                $sorted_list[$index\
    \ - 1] = $val;\n                $sorted_list[$index] = $new_max;\n           \
    \ } else {\n                $sorted_list[$index++] = $val;\n            }\n  \
    \      } else {\n            $sorted_list[$index++] = $val;\n        }\n    }\n\
    \    return @sorted_list;\n}", "    $lst = [sort { $a <=> $b } @$lst];\n    return\
    \ @$lst;\n}", "    $lst += 0;\n    $lst -= 1;\n    my @result = sort {$a <=> $b};\n\
    \    return @result;\n}", "    my @strange_sorted = ();\n    my $tmp;\n    my\
    \ $min = $lst[0];\n    my $max = $lst[0];", "    my $len = $lst->length;\n   \
    \ my $min_value = ($len == 1) ? $lst->[0] : $lst->[0];\n    my $max_value = $lst->[0];\n\
    \    my $i = 0;\n    my $j = 0;\n    my @res;", '    my @list;', "    my @ret;\n\
    \    my @list;\n    my $min_val = $lst[0];\n    my $max_val = $lst[0];\n    foreach\
    \ my $val (@$lst) {\n        if ($val > $max_val) {\n            $max_val = $val;\n\
    \        }\n        if ($val < $min_val) {\n            $min_val = $val;\n   \
    \     }\n    }\n    foreach my $val (@$lst) {\n        push(@list, $val);\n  \
    \  }\n    foreach my $i (1..$#list) {\n        my $j = $i;\n        my $swap =\
    \ $list[$i];\n        my $temp = $list[$j];\n        while ($j > 0 && $list[$j-1]\
    \ > $list[$j]) {\n            $list[$j] = $list[$j-1];\n            $j--;\n  \
    \      }\n        $list[$j] = $swap;\n    }\n    return @ret;\n}", '    my @newlist;',
  "    my;\n    while (scalar @$lst > 0) {\n        # find the minimum\n        my\
    \ $min = $lst[0];\n        for my $i(1..scalar(@$lst)) {\n            if ($lst[$i]\
    \ < $min) {\n                $min = $lst[$i];\n            }\n        }\n    \
    \    # sort by minimum, find maximum, swap if necessary\n        @$lst = sort\
    \ {$a <=> $b} @$lst;\n        if ($lst[0] != $min) {\n            @$lst = map\
    \ {if ($_ ne $min) {$_} else {$_}} @$lst;\n        }\n        push, $min;\n  \
    \  }\n    return;\n}", '    my @res;', "    my($min, $max);\n    for(my $i = $#lst;\
    \ $i >= 1; $i--)\n    {\n        $max = $#lst if $i < $#lst - 1;\n        for(my\
    \ $j = $i; $j <= $max; $j++)\n        {\n            $min = $#lst if $j < $#lst\
    \ - 1;\n            if(($min < $j && $max > $j) ||\n              (($min == $j\
    \ && $max > $j) ||\n               ($min > $j && $max == $j)))\n            {\n\
    \                $lst[$min] = $lst[$j];\n                splice @lst, $j, $#lst\
    \ - $j - 1, $max;\n                $min = $#lst + 1;\n                $max = $#lst;\n\
    \            }\n        }\n    }\n    return $lst;\n}", "    my @temp = ();\n\
    \    my $min = 100;\n    my $max = 0;\n    my $i = 0;\n    foreach my $element\
    \ (@$lst) {\n        if ($element > $max) {\n            $max = $element;\n  \
    \      }\n        if ($element < $min) {\n            $min = $element;\n     \
    \   }\n        if ($min == $max) {\n            push(@temp, $element);\n     \
    \   }\n        else {\n            push(@temp, $min);\n            push(@temp,\
    \ $max);\n            $min = 100;\n            $max = 0;\n        }\n        $i++;\n\
    \    }\n    push(@temp, $min);\n    push(@temp, $max);\n    return @temp;\n}",
  "    my @retval;\n    my $index;\n    my $current = $lst[0];\n    my $last = $lst[0];",
  "    my @strange_lst = ();\n    my $max = @$lst > 0 ? @$lst : 0;\n    my $min =\
    \ @$lst > 0 ? @$lst : 0;\n    my $swaps = @$lst > 0 ? @$lst : 0;\n    for my $i\
    \ (0 .. $max - 1) {\n        for my $j ($i + 1 .. $max) {\n            if ($lst[$i]\
    \ > $lst[$j]) {\n                ++$swaps;\n                push (@strange_lst,\
    \ $lst[$i]);\n                ++$i;\n            }\n        }\n    }\n    if ($min\
    \ > $max) {\n        ++$swaps;\n        push (@strange_lst, $lst[$min]);\n   \
    \     ++$min;\n    }\n    while ($swaps > 0) {\n        for my $i (0 .. $swaps\
    \ - 1) {\n            ++$i;\n            my $rand = int rand(@$lst);\n       \
    \     my $j = $i + ($rand % $swaps);\n            push (@strange_lst, $lst[$j]);\n\
    \            push (@strange_lst, $lst[$i]);\n            $lst[$j] = $lst[$i];\n\
    \        }\n        ++$swaps;\n    }\n    return @strange_lst;\n}", "    my($min)\
    \ = pop(@lst) if @lst;\n    my @sorted;\n    for my $n (@lst) {\n        my $l\
    \ = $n;\n        if ($min == $n) {\n            $l = $min;\n        }\n      \
    \  push(@sorted, $l);\n        $min = $n if $n < $min;\n    }\n    return @sorted;\n\
    }\n</code>\n<|/ a dscore=1 tags=sorting,perl,arrays |>\n<| c |>\nThe `while`-loop\
    \ can be replaced with a `$min = $_; shift @lst` after the `push`. The `if`-statement\
    \ can be replaced by a `$min //= $_`.\n<|/ c |>\n<| c |>\n: thanks! Those are\
    \ improvements.\n<|/ c |>\n<| c |>\nThat is correct, `//= $_` also works and might\
    \ be slightly faster (no shift), but I didn't want to change too much the OP's\
    \ code.\n<|/ c |>\n<| c |>\n: yes, that would probably be faster too, but I thought\
    \ that would be less readable. `//=` will change `$min` only if no other value\
    \ is given, and it would be difficult to understand why `shift` was needed.\n\
    <|/ c |>\n<| a dscore=0 |>\nAnother possibility is to just sort them using Schwartzian\
    \ transformation.\n<code>", "    $lst =~ s/ /\\n/g;\n    $lst =~ s/^/[/;\n   \
    \ $lst =~ s/$/]/;\n    $lst =~ s/(\\w+\\W?\\w*\\W?)(\\d+)/$1 $2/;\n    $lst =~\
    \ s/(\\w+\\W?\\w*\\W?)(\\d+)$/$2 $1/g;\n    $lst =~ s/(\\w+\\W?\\w*\\W?)(\\d+)\\\
    /$/$2 $1 /;\n    my @sorted = split(' ', $lst);\n    my @sorted = reverse @sorted;\n\
    \    return join(' ', @sorted);\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ this! It helped me to sort a huge list of files with over 5 million lines by\
    \ first column without using any external tools.\n<|/ c |>\n<| a |>\nMy solution\
    \ was to use sort -k 1 but then I had a bunch of duplicate lines, so I used sort\
    \ -u which sorts lines with duplicate keys to the beginning of the line.\nI also\
    \ used sort -k 1,2 which sorts the second column.\n<code>\ncat $filename | sort\
    \ -u | sort -k 1,2\n</code>\n<|/ a tags=sorting,perl,text dscore=4 |>\n<| a tags=sorting,perl,text\
    \ |>\nAnother way to sort is to use the sort command in awk. \n<code>\nawk '{a[$1]=$2}\
    \ END{for(i in a) print i,a[i]}' input.txt | sort -k 1\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\nI wrote this script to sort a text file with numbers and\
    \ alphabets and also sort numerically.\n<code>", '    my @result;', "    my @sorted_lst;\n\
    \    my $len = @$lst;\n    my $min = $lst[0]->[0];\n    my $max = $lst[0]->[0];\n\
    \    for (my $i = 1; $i < $len; $i++) {\n        if ($min->[0] > $lst[$i]->[0])\
    \ {\n            $min = $lst[$i];\n        } elsif ($max->[0] < $lst[$i]->[0])\
    \ {\n            $max = $lst[$i];\n        } else {\n            $sorted_lst[$i\
    \ - 1] = splice(@sorted_lst, 0, $i + 1);\n            $min = $lst[$i];\n     \
    \       $max = $lst[$i];\n        }\n    }\n    $sorted_lst[$len - 1] = $min;\n\
    \    $sorted_lst[$len] = $max;\n    return @sorted_lst;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nNice solution, but why not use the builtin sort instead of implementing\
    \ your own sort routine?\n<|/ c |>\n<| c |>\nI agree that it would be nice to\
    \ use the built-in sort. I will add it to the code above. Thanks!\n<|/ c |>\n\
    <| c |>\nBen: That would probably work just as well, and maybe even be faster,\
    \ but a custom sort routine is more generally applicable. In the case of a list\
    \ of integers, it's not a big deal, but in general, sorting an array of arbitrary\
    \ structures, and even writing a custom sort routine might be better than just\
    \ using a built-in sort routine.\n<|/ c |>\n<| c |>\nBen: I've added a Python\
    \ version (and a Python 3 version), in case you wanted to give that a shot.\n\
    <|/ c |>\n<| c |>\nAwesome solution, thanks! I did end up using Ben's solution.\
    \ I added my own implementation for posterity and future reference, though. Thanks\
    \ again!\n<|/ c |>\n<| a tags=sorting,perl,arrays dscore=1 |>\nA solution in Python\
    \ (for completeness and reference)\n<code>\n>>> a = [5, 2, 3]\n>>> a.sort()\n\
    >>> a\n[2, 3, 5]\n</code>\n<|/ a |>\n<| a tags=sorting,perl,arrays |>\nI like\
    \ the solutions provided here, but I wanted to compare the time to my own implementation\
    \ using the sort function:\n<code>", "    if (scalar @$lst == 0) {\n        return\
    \ [];\n    }\n    my $min = @$lst;\n    my $max = @$lst - 1;\n    my $first_value\
    \ = $lst[$min];\n    my $last_value = $lst[$max];\n    my @sorted_lst;", "   \
    \ my @sorted;\n    my @copy = @$lst;", "    my @sorted = ();\n    my $min = pop(@{$lst});\n\
    \    while (@{$lst}) {\n        push(@sorted, pop(@{$lst}));\n        push(@{$lst},\
    \ $min);\n        $min = pop(@{$lst});\n    }\n    return @sorted;\n}", "    return\
    \ @$lst if $lst->[0] == $lst->[-1];\n    $lst =~ s/^(\\d+)\\z/$1/;\n    $lst =~\
    \ s/(\\d+)\\z/$1 $2/g;\n    my(@list);\n    my($min, $max) = ($1, $1);\n    for\
    \ (my $i = 1; $i < $#{$lst}; $i++) {\n        $max = $1 if $lst[$i] > $max;\n\
    \        $min = $2 if $lst[$i] < $min;\n        push(@list, $lst[$i]);\n    }\n\
    \    push(@list, [$max, $min]) unless $min == $max;\n    return @list;\n}\n</code>\n\
    <|/ a dscore=4 tags=sorting,perl,list |>\n<| c |>\nI like it, it uses the least\
    \ memory and it's fairly fast. I think it would be better to have the `@list`\
    \ outside the for loop. Could be an idea to make it a sub and do `@list = &strange_sort_list(@list);`\
    \ to avoid the return value.\n<|/ c |>\n<| c |>\nThis was an interesting thought\
    \ experiment, but when I tried it against the sample output I got, I got [5,5,5,5]\
    \ -> [5,5,5,5] -> [5,5,5,5] -> [5,5,5,5] -> [5,5,5,5] -> [5,5,5,5] -> [5,5,5,5]\
    \ -> [5,5,5,5]\n<|/ c |>\n<| c |>\nYou're right, it wasn't as simple as I thought\
    \ it would be.  Thanks for pointing it out.  I've fixed it.\n<|/ c |>\n<| c |>\n\
    : I like your solution.  I'd probably rewrite it slightly to remove some temporary\
    \ variables, but I'm not in love with Perl.  Perl has a nice way to handle all\
    \ those temporary variables with `@{[ ]}`.  Also, instead of `return @list;` you\
    \ could do `undef;`\n<|/ c |>\n<| c |>\n: I used the return statement to make\
    \ the code more readable, since I thought it would make the logic more obvious.\
    \  I agree that undefing $min and $max would be more efficient, and probably more\
    \ readable.\n<|/ c |>\n<| a dscore=4 tags=sorting,perl,list |>\nIf you need to\
    \ stick to the sort function, you can use its callback (a subroutine reference)\
    \ to get an alternative sorting algorithm.\n<code>", "    my @sorted_lst = ();\n\
    \    my $min_value = $lst[0];\n    my $max_value = $lst[0];", '    my @sorted_list
    = ();', "    my;\n    foreach my $i (@$lst) {\n\tpush (@ret, $i);\n    }\n   \
    \ foreach my $i (@ret) {\n\tpush (@ret, $$lst[$i-1]);\n\tpush (@ret, $$lst[$i]);\n\
    \    }\n    return;\n}", "    my $max = $lst->[0];\n    my $min = $lst->[0];\n\
    \    foreach my $i (1..$#$lst) {\n        if ($lst->[$i] > $max) {\n         \
    \   $max = $lst->[$i];\n        } elsif ($lst->[$i] < $min) {\n            $min\
    \ = $lst->[$i];\n        }\n    }\n    my @sorted = ();\n    for my $i ($min..$max)\
    \ {\n        push(@sorted, $lst->[$i]);\n    }\n    @sorted;\n}\n</code>\n<|/\
    \ a tags=perl,sorting |>\n<| c |>\nYour solution is good if the order matters.\
    \ But for sorting integers you don't need that much complexity. A O(n^2) algorithm\
    \ suffices, as pointed by David W. But the algorithm you posted is definitely\
    \ more efficient.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nuse List::Util qw(reduce);\n\
    use Sort::Key::Util;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
