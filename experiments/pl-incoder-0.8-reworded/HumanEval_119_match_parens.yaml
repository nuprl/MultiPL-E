name: HumanEval_119_match_parens
language: pl
prompt: "# You are given an array of two strings, both strings consist of open\n#\
  \ parentheses '(' or close parentheses ')' only.\n# Your job is to check if it is\
  \ possible to concatenate the two strings in\n# some order, that the resulting string\
  \ will be good.\n# A string S is considered to be good if and only if all parentheses\
  \ in S\n# are balanced. For example: the string '(())()' is good, while the string\n\
  # '())' is not.\n# Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n# Examples:\n# >>> match_parens([\"()(\", \")\"])\n# \"Yes\"\n\
  # >>> match_parens([\")\", \")\"])\n# \"No\"\nsub match_parens {\n    my($lst) =\
  \ @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&match_parens;\n\
  \        if(eq_deeply($candidate->([\"()(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \")\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([\"(()(())\", \"())())\"]),\"No\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )())\", \"(()()(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\"(())))\", \"(()())((\"]),\"Yes\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ()\", \"())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([\"(()(\", \"()))()\"]),\"Yes\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ((((\", \"((())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\")(()\", \"(()(\"]),\"No\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )(\", \")(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([\"(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \"(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n}\n\ntesthumaneval();"
completions: ['    my(@match) = ();', "    my $res = \"No\";\n    if ( $lst[0] eq\
    \ \"()\" && $lst[1] eq \")\" ) {\n        $res = \"Yes\";\n    }\n    return $res;\n\
    }", "    my %seen;\n    my $len = @$lst;\n    my %counts;\n    for my $i (0..$len-1)\
    \ {\n        my $elem = $lst->[$i];\n        if ($seen{$elem}++ == 0) {\n    \
    \        if ($elem eq '(') {\n                $counts{$elem}++;\n            }\
    \ elsif ($elem eq ')') {\n                if ($counts{$elem} == 1) {\n       \
    \             return 'No';\n                }\n                $counts{$elem}--;\n\
    \            }\n        }\n    }\n    return 'Yes';\n}", "    my $max_pos = 0;\n\
    \    my $pos = 0;\n    my $balanced = 0;\n    for ($pos = 0; $pos < @$lst; $pos++)\
    \ {\n        if ($lst->[$pos] eq '(') {\n            $max_pos = $pos;\n      \
    \  }\n        if ($lst->[$pos] eq ')') {\n            if ($max_pos == $pos) {\n\
    \                return \"No\";\n            }\n            else {\n         \
    \       $max_pos = $pos;\n            }\n        }\n        $balanced += 1;\n\
    \    }\n    return $balanced == 0 ? \"Yes\" : \"No\";\n}", "    my @stack = ();\n\
    \    my $stack_size = scalar($lst);\n    foreach my $el (@$lst) {\n        push\
    \ (@stack, $el) if $el =~ /^\\(/;\n        push (@stack, $el) if $el =~ /^\\)/;\n\
    \    }\n    for (my $i = $stack_size; $i >= 1; $i--) {\n        my $curr = $stack[$i];\n\
    \        if ($curr == $stack[$i - 1]) {\n            if ($curr eq '(' && $stack[$i\
    \ - 2] eq '(') {\n                $stack[$i - 1] = $stack[$i - 2] . $curr;\n \
    \           }\n            else {\n                $stack[$i - 1] = $curr . $stack[$i\
    \ - 1];\n            }\n        }\n        else {\n            my $is_good = 0;\n\
    \            for (my $k = $i; $k >= 1; $k--) {\n                if ($stack[$k]\
    \ == $stack[$k - 1]) {\n                    $is_good = 1;\n                }\n\
    \                else {\n                    $is_good = 0;\n                }\n\
    \                if ($is_good == 0) {\n                    break;\n          \
    \      }\n            }\n            if ($is_good == 1) {\n                return\
    \ \"Yes\";\n            }\n        }\n    }\n    return \"No\";\n}", "    my $first\
    \ = substr($lst[0],1,1);\n    my $second = substr($lst[1],1,1);\n    my $count\
    \ = 0;\n    for(my $i = 0; $i<length($lst[0]); $i++){\n        if(substr($lst[0],$i,1)\
    \ eq $first){\n            $count++;\n        }\n        if(substr($lst[1],$i,1)\
    \ eq $second){\n            $count--;\n        }\n        if($count == -1){\n\
    \            return 0;\n        }\n    }\n    if($count == 1){\n        return\
    \ \"Yes\";\n    }else{\n        return \"No\";\n    }\n}", "    my $cnt = 0;\n\
    \    my $l1 = length($lst[0]);\n    my $l2 = length($lst[1]);\n    my $pcnt =\
    \ 0;\n    for (my $i=0; $i<=$l1-1; $i++) {\n        for (my $j=0; $j<=$l2-1; $j++)\
    \ {\n            if ($lst[$i-1] eq '(') {\n                $pcnt++;\n        \
    \    }\n            elsif ($lst[$j+1] eq ')') {\n                $pcnt--;\n  \
    \          }\n        }\n        if ($pcnt != 0) {\n            $cnt++;\n    \
    \    }\n    }\n    return \"Yes\" if ($cnt == 0);\n    return \"No\";\n}", " \
    \   my($rev_lst) = reverse($lst);\n    my $found = 0;\n    my($open,$close);\n\
    \    foreach my $c (@$lst) {\n        if ($c == ')') {\n            $found = 0;\n\
    \            last if ($open == $close);\n        } elsif ($c == '(') {\n     \
    \       $open = $c;\n            $found = 1;\n        } elsif ($open == $c &&\
    \ $found == 1) {\n            $found++;\n        } else {\n            return\
    \ $found;\n        }\n    }\n    return $open == $close;\n}", "    my $paren_opened\
    \ = 0;\n    my $paren_closed = 0;\n    my $check = 1;\n    \n    foreach my $str\
    \ (@$lst) {\n        if($str =~ m/^\\(/) {\n            $paren_opened++;\n   \
    \         $check = 1;\n        } elsif ($str =~ m/^\\)/) {\n            $paren_closed++;\n\
    \            $check = 0;\n        } elsif ($check) {\n            $check = 0;\n\
    \            if($paren_opened < $paren_closed) {\n                $check = 1;\n\
    \            }\n            else {\n                $check = 0;\n            }\n\
    \        }\n    }\n    \n    return $check;\n}", "    my(@stack) = ();\n    my($good)\
    \ = \"No\";\n    for my $el (@$lst) {\n        my $is_open = $el =~ /^\\((.+)\\\
    )$/;\n        if ($is_open) {\n            push(@stack, $el);\n        } else\
    \ {\n            if (@stack) {\n                $good = \"Yes\";\n           \
    \     last;\n            } else {\n                return \"No\";\n          \
    \  }\n        }\n    }\n    return $good;\n}", "    foreach my $elt (@$lst) {\n\
    \        my $open_parens = $elt;\n        $open_parens =~ s/^\\(.+\\)$/$1/g;\n\
    \        if ($open_parens ne $elt or $open_parens !~ /\\(+\\)$/g) {\n        \
    \    return \"No\";\n        }\n    }\n    return \"Yes\";\n}", "    my $len =\
    \ @$lst;\n    if ($len == 1) {\n        return \"Yes\" if $lst[0] eq '(';\n  \
    \      return \"No\" if $lst[0] eq ')';\n        return \"No\" if $lst[0] =~ /[^(]/g;\n\
    \        return \"Yes\" unless $lst[0] =~ /[^)]/g;\n        return \"Yes\" unless\
    \ $lst[0] eq ')';\n        return \"Yes\" if $lst[0] eq '(';\n        return \"\
    Yes\" unless $lst[0] eq '(';\n        return \"No\" if $lst[0] eq ')';\n    }\n\
    \    return \"Yes\" if $len == 2;\n    $lst[0] =~ /([^(]+)/;\n    my $first =\
    \ shift(@_);\n    my $second = shift(@_);\n    if ($first eq ')' and $second eq\
    \ ')') {\n        return \"Yes\";\n    }\n    my $third = shift(@_);\n    if ($first\
    \ eq '(' and $second eq '(' and $third eq ')') {\n        return \"Yes\";\n  \
    \  }\n    return \"No\";\n}", "    my $start = 1;\n    my $end   = -1;\n    for\
    \ (my $i = $#lst; $i >= 0; $i--) {\n        my $char = $lst[$i];\n        if ($char\
    \ == \"(\") {\n            push (@lst, \"(\");\n            $start = $i;\n   \
    \     }\n        elsif ($char == \")\") {\n            push (@lst, \")\");\n \
    \           $end = $i;\n        }\n    }\n    my $result = $end + $start != $#lst;\n\
    \    for (my $i = $#lst; $i >= $start; $i--) {\n        my $char = $lst[$i];\n\
    \        if ((($char == \"(\") && ($lst[$i+1] != \")\")) || (($char == \")\")\
    \ && ($lst[$i+1] != \"(\"))) {\n            $result = 0;\n        }\n    }\n \
    \   return $result ? \"Yes\" : \"No\";\n}", "    return '' unless @$lst;\n   \
    \ return $lst[0] =~ /\\(\\(\\)/;\n}", "    my($len) = length($lst[0]);\n    my($first\
    \ = $len-1);\n    my($last);\n    my($left);\n    my($right);\n    my($start);\n\
    \    my($end);\n    my($flag);\n    my($flag2);\n    my($flag3);\n    my($flag4);\n\
    \    my($flag5);\n    my($flag6);\n    my($flag7);\n    my($flag8);\n    my($flag9);\n\
    \    my($flag10);\n    my($flag11);\n    my($flag12);\n    my($flag13);\n    my($flag14);\n\
    \    my($flag15);\n    my($flag16);\n    my($flag17);\n    my($flag18);\n    my($flag19);\n\
    \    my($flag20);\n    my($flag21);\n    my($flag22);\n    my($flag23);\n    my($flag24);\n\
    \    my($flag25);\n    my($flag26);\n    my($flag27);\n    my($flag28);\n    my($flag29);\n\
    \    my($flag30);\n    my($flag31);\n    my($flag32);\n    my($flag33);\n    my($flag34);\n\
    \    my($flag35);\n    my($flag36);\n    my($flag37);\n    my($flag38);\n    my($flag39);\n\
    \    my($flag40);\n    my($flag41);\n    my($flag42);\n    my($flag43);\n    my($flag44);\n\
    \    my($flag45);\n    my($flag46);\n    my($flag47);\n    my($flag48);\n    my($flag49);\n\
    \    my($flag50);\n    my($flag51);\n    my($flag52);\n    my($flag53);\n    my($flag54);\n\
    \    my($flag55);\n    my($flag56);\n    my($flag57);\n    my($flag58);\n    my($flag59);\n\
    \    my($flag60);\n    my($flag61);\n    my($flag62);\n    my($flag63);\n    my($flag64);\n\
    \    my($flag65);\n    my($flag66);\n    my($flag67);\n    my($flag68);\n    my($flag69);\n",
  "    my %result; # hash storing valid combinations by opening paren\n    for (@$lst)\
    \ {\n        $result{$_}++ if $_ =~ /[()]/;\n    }\n    return exists $result{\"\
    \"};\n}", "    my $result = \"No\";\n    my $i = 0;\n    my $j = 0;", "    return\
    \ if $lst[0] =~ /^\\(\\)$/;\n    my $stack = $lst;\n    my $str = \"$lst[0]\"\
    ;\n    my %paren = ();\n    my @ok;\n    my $cnt = 0;\n    my $pos = 0;\n    my\
    \ $p = 0;\n    while (@$stack) {\n        my ($cur, $op) = @$stack[$pos];\n  \
    \      $pos++;\n        if ($op eq '(') {\n            $paren{$cur}++;\n     \
    \   } else {\n            $paren{$cur}--;\n        }\n        if ($paren{$cur}\
    \ < 0) {\n            $cnt++;\n        }\n        if ($paren{$cur} == 0) {\n \
    \           push(@ok, $cur);\n        }\n        if ($paren{$cur} > 0) {\n   \
    \         $cnt++;\n        }\n    }\n    return $cnt < 2;\n}", "    my($first_str,\
    \ $second_str) = @$lst;\n    my %open_parens = ();\n    my %closed_parens = ();",
  "    my($cnt);\n    my($first);\n    my($last);\n    my($rest);\n    foreach my\
    \ $item (@$lst) {\n        if ($item eq '(') {\n            $cnt += 1;\n     \
    \   } elsif ($item eq ')') {\n            $cnt -= 1;\n        }\n        if ($cnt\
    \ == 0) {\n            $first = $last;\n            $cnt   = 1;\n        } elsif\
    \ ($cnt < 0) {\n            return undef;\n        }\n        $last += 1;\n  \
    \  }\n    my $conc = $first . $last;\n    if ($first eq $last) {\n        return\
    \ 'Yes';\n    }\n    return 'No';\n}", "    my(@ret) = ();\n    for my $l (@$lst)\
    \ {\n        $ret .= $l if $l =~ /^[\\(\\)]+$/;\n    }\n    return $ret ? \"$ret\"\
    \ : \"No\";\n}", "    my(@ret) = ();\n    my $open = 0;\n    my $start = 0;\n\
    \    my $end = 0;\n    for my $i ( 0 .. $#lst ) {\n        my $char = $lst[$i];\n\
    \        if ($char eq '(') {\n            $open++;\n        } elsif ($char eq\
    \ ')') {\n            $open--;\n        } elsif ($open == 0) {\n            $start\
    \ = $i;\n        } elsif ($open == -1) {\n            $end = $i;\n        } else\
    \ {\n            push(@ret, \"No\");\n        }\n    }\n    if (@ret > 0) {\n\
    \        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}",
  "    my @stack = ();\n    my(@good, @bad) = ();\n    \n    foreach my $string (@$lst)\
    \ {\n        push(@stack, $string);\n        \n        while ( @stack > 0 ) {\n\
    \            my $str = pop(@stack);\n            if ( $str =~ /^\\((.*)?\\)$/s\
    \ ) {\n                my $match = $1;\n                if ( $match !~ /^\\((.*)?\\\
    )$/s ) {\n                    push (@good, $str);\n                } else {\n\
    \                    push(@bad, $str);\n                }\n            } else\
    \ {\n                push (@bad, $str);\n            }\n        }\n    }\n   \
    \ if ( @bad ) {\n        print \"No\\n\";\n        return \"No\";\n    } else\
    \ {\n        print \"Yes\\n\";\n        return \"Yes\";\n    }\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis will not work if the second input string is '()()'.\n\
    <|/ c |>\n<| a tags=string,perl,arrays |>\nHere is another solution. There are\
    \ a number of problems with this solution, namely:", "    my $match = 0;\n   \
    \ my $last = 0;\n    for my $l (@$lst) {\n        my $count = 0;\n        my $open\
    \ = 0;\n        for (my $i = 0; $i < length($l); $i++) {\n            next if\
    \ $l[$i] eq \"(\" || $l[$i] eq \")\";\n            $count++;\n            $open++\
    \ if $l[$i] eq \"(\" && $open == 0;\n            $open-- if $l[$i] eq \")\" &&\
    \ $open == 0;\n        }\n        if (($last == 0 && $count == 1) || ($open !=\
    \ 0)) {\n            $match++;\n        }\n        $last = $count;\n    }\n  \
    \  return $match >= 2 ? \"Yes\" : \"No\";\n}", "    my $len = @$lst;\n    my $curr\
    \ = 1;\n    my $pre = 0;\n    my $stp = 0;\n    my $con = ();\n    my $result\
    \ = 1;\n    my $i = 0;\n    my $count = 0;", "    my $n = @$lst;\n    my %p =\
    \ map {$_ => 0} @$lst;\n    my $res = 'Yes';\n    while ($n > 1) {\n        my\
    \ $left = pop @$lst;\n        my $right = pop @$lst;\n        my $op = substr($left,\
    \ 0, 1);\n        if ($op =~ /^[({]$/) {\n            $p{$op}++;\n        } elsif\
    \ ($op =~ /^[)}])$/) {\n            $p{$op}--;\n        }\n        my $cons =\
    \ $left . $op;\n        if ($p{$cons} < 0) {\n            $res = 'No';\n     \
    \   }\n    }\n    return $res;\n}", "    my $s = $lst[0];\n    my(@l) = split(/(\\\
    (|\\))/, $s);\n    my $a = $l[0];\n    my $b = $l[1];\n    my $c = $l[2];\n  \
    \  return 0 if ($a eq $b || $b eq $c);\n    return 1 if ($a eq $c || $b eq $c);\n\
    \    return 0;\n}", "    foreach my $s (@$lst) {\n        return 1 if $s eq '(';\n\
    \        return 1 if $s eq ')';\n    }\n    return 'No';\n}", "    my(@result)\
    \ = ();\n    \n    foreach my $word (@{$lst[0]}) {\n        my $open = 0;\n  \
    \      foreach my $char (@{$word}) {\n            chomp $char;\n            if\
    \ ($char eq '(') {\n                push @result, $open;\n                ++$open;\n\
    \            } elsif ($char eq ')') {\n                --$open;\n            }\n\
    \        }\n    }\n    \n    if (@result == 0) {\n        return \"Yes\";\n  \
    \  } else {\n        return \"No\";\n    }\n}", '    my(@res) = ();', "    my\
    \ $len = 0;\n    my $cur_stack = [];\n    for (@$lst) {\n        if ($cur_stack->[$len]\
    \ eq '(') {\n            $cur_stack->[$len]++;\n        }\n        elsif ($cur_stack->[$len]\
    \ eq ')') {\n            $cur_stack->[$len]--;\n        }\n        $len++;\n \
    \   }\n    for (0 .. $len - 1) {\n        if ($cur_stack->[$len] eq '(') {\n \
    \           $cur_stack->[$len]++;\n        }\n        elsif ($cur_stack->[$len]\
    \ eq ')') {\n            $cur_stack->[$len]--;\n        }\n    }\n    return $len\
    \ ? ($cur_stack->[$len] eq '(' ? \"Yes\" : \"No\") : \"No\";\n}", "    my $str\
    \ = $lst[0]; #S\n    my $stack = ();\n    my($open, $close) = (1, 1);\n    while($str\
    \ =~ /\\(/g) {\n        $open += 1;\n        $stack->[$open] = $str =~ /\\(/g;\n\
    \    }\n    while($str =~ /\\)/g) {\n        $close += 1;\n        if($stack->[$close]\
    \ != $str =~ /\\)/g) {\n            return \"No\";\n        }\n    }\n    return\
    \ \"Yes\";\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work because\
    \ the string \"()(\" will match the regexp \"\\((\" but \"()\" does not match\
    \ \"\\((\".\n<|/ c |>\n<| c |>\nYou are correct and I missed that fact in my answer.\
    \ My code was just an example to explain my idea.\n<|/ c |>\n<| c |>\nI have updated\
    \ my answer with the solution that doesn't depend on regular expressions.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "    my($max) = @$lst;\n    $max--; # Don't\
    \ count last element\n    if ($max < 0) { # Can't match a string\n        return\
    \ \"No\";\n    }\n    my $first = $lst[0];\n    if ($first eq '(' && $lst[1] eq\
    \ '(' && $lst[2] eq '(') {\n        return 'Yes';\n    }\n    elsif ($first eq\
    \ '(' && $lst[1] eq '(') {\n        return 'Yes' if match_parens(substr($lst,\
    \ 2, $max - 2));\n    }\n    elsif ($first eq ')' && $lst[1] eq ')' && $lst[2]\
    \ eq ')') {\n        return 'Yes' if match_parens(substr($lst, 3, $max - 3));\n\
    \    }\n    else {\n        return \"No\";\n    }\n}", "    my($open, $close,\
    \ $result) = ('', undef, 0);", "    my(@l) = grep {$_} @$lst;\n    my $s = '';\n\
    \    my $count = 0;\n    while (my($p,$p) = @$lst) {\n        if ($p eq '(') {\n\
    \            ++$count;\n        } elsif ($p eq ')') {\n            --$count;\n\
    \        }\n        if ($count == 0) {\n            $s .= $p;\n        }\n   \
    \ }\n    return $s eq '()' ? \"Yes\" : \"No\";\n}", "    my(@rv) = ('Yes');\n\
    \    my $parens = 0;\n    my $last_idx;\n    my $last_paren;\n    for my $idx\
    \ (@$lst) {\n        if ($parens == 0) {\n            if ($idx eq '(') {\n   \
    \             $parens = 1;\n            }\n            else {\n              \
    \  $parens = 0;\n            }\n        }\n        elsif ($parens == 1 && $idx\
    \ eq ')') {\n            $parens = 0;\n        }\n        elsif ($parens == 0)\
    \ {\n            $last_idx = $idx;\n        }\n        else {\n            $last_paren\
    \ = $parens;\n            $parens = $last_paren;\n        }\n    }\n    if ($parens\
    \ == 1) {\n        @rv = ('Yes');\n    }\n    else {\n        @rv = ('No');\n\
    \    }\n    return @rv;\n}", "    my @res = ();\n    my($i, $j, $n);\n    my($i,\
    \ $j, $n);\n    my @stack = ();", "    my %good;\n    my %bad;\n    my @good;\n\
    \    my @bad;\n    for(my $i = 0; $i < @$lst; $i += 2) {\n        if ($good{$lst[$i]})\
    \ {\n            $good{$lst[$i]}++;\n        }\n        else {\n            $bad{$lst[$i]}++;\n\
    \        }\n    }\n    foreach my $x (keys %good) {\n        my $y = $good{$x};\n\
    \        if($y == @$lst) {\n            $good{$x}++;\n        }\n    }\n    foreach\
    \ my $x (keys %bad) {\n        $good{$x}++;\n    }\n    @good = sort {$a <=> $b}\
    \ keys %good;\n    @bad = sort {$a <=> $b} keys %bad;\n    if (@good > 0) {\n\
    \        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}",
  "    my($len, $i, $s1);\n    my($s2) = shift;\n    my $s3 = $s2;\n    $s1 =~ s/^\
    \ *//;\n    $s1 =~ s/ *$//;\n    while($s1 =~ s/^ *\\([^()]*\\)//) {\n       \
    \ $len = length($s1);\n        $i = 0;\n        while($i < $len) {\n         \
    \   if($s1 =~ s/^ *\\([^()]*\\)//) {\n                $i++;\n            } elsif($s1\
    \ =~ s/ *\\([^()]*\\)//) {\n                last;\n            } else {\n    \
    \            last;\n            }\n        }\n        $s1 = \"($s2)\";\n    }\n\
    \    $s1 =~ s/^ *\\([^()]*\\)//;\n    if($s1 eq $s2 || $s1 =~ s/^ *\\([^()]*\\\
    )//) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n\
    }", "    my(@good);\n    my $count = 0;\n    foreach my $s (@$lst) {\n       \
    \ if ($s =~ /^\\(?/) {\n            $count++;\n        }\n        if ($s =~ /^\\\
    )/) {\n            $count--;\n        }\n        if ((($count == 0) && ($s =~\
    \ /[^()]+/)) || ($count != 0)) {\n            push(@good, $s);\n        }\n  \
    \  }\n    return scalar(@good) == 0 ? \"No\" : \"Yes\";\n}", "    my(@new_list)\
    \ = ();\n    my($open, $close) = (\")\", \"(\");\n    foreach my $str (@$lst)\
    \ {\n        if ($str =~ /^$close/) {\n            $open = $str;\n        } elsif\
    \ ($str =~ /^$open/) {\n            $close = $str;\n        } else {\n       \
    \     $open = $close;\n        }\n        $open = $close if $str =~ /^$open/;\n\
    \    }\n    if (@new_list == 0) {\n        return \"Yes\";\n    } else {\n   \
    \     return \"No\";\n    }\n}", "    my $i = 0;\n    my $cnt = 0;\n    my $bal_paren\
    \ = 0;\n    for ($i; $i < @$lst - 1; $i++) {\n        if ($lst[$i] eq '(') {\n\
    \            $cnt++;\n        }\n        if ($lst[$i] eq ')') {\n            $cnt--;\n\
    \        }\n        if ($cnt < 0) {\n            $bal_paren = -$bal_paren;\n \
    \       }\n        if ($bal_paren) {\n            return $cnt ? \"Yes\" : \"No\"\
    ;\n        }\n        $bal_paren = 0;\n    }\n    return \"No\";\n}", "    my($stack)\
    \ = [0];\n    my(@result) = ('No');\n    foreach my $x (@$lst) {\n        if ($x\
    \ eq '(') {\n            $stack[$#stack]++;\n        } elsif ($x eq ')') {\n \
    \           $stack[$#stack]--;\n        }\n        if ($stack[$#stack] == 0) {\n\
    \            push (@result, 1);\n        }\n    }\n    if ($stack[0] eq 'No')\
    \ {\n        push (@result, 0);\n    }\n    if (@result > 1) {\n        return\
    \ \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}", "    my($ret);\n\
    \    for ($lst[0], $lst[1]){\n        my $match = 0;\n        for (@$lst){\n \
    \           if ($_ eq \"(\"){\n                $match++;\n            }\n    \
    \        elsif ($_ eq \")\"){\n                $match--;\n            }\n    \
    \    }\n        if ($match){\n            $ret = \"No\";\n        }\n        else{\n\
    \            $ret = \"Yes\";\n        }\n    }\n    return $ret;\n}", '    my($result)
    = "No";', '    my @paren = ();', "    my $stack = Array::Util::reverse(@{$lst});\n\
    \    my $result = 1;\n    while (@{$stack} > 0) {\n        my $elem = $stack->[0];\n\
    \        my $len = $elem->length;\n        my $c = 0;\n        for (0..$len-1)\
    \ {\n            ++$c if ($elem->[$_] eq '(');\n            ++$c if ($elem->[$_]\
    \ eq ')');\n        }\n        if ($c % 2 != 0) {\n            $result = 0;\n\
    \            last;\n        }\n        $stack->shift();\n    }\n    return $result;\n\
    }", "    my($match) = undef;\n    my($good);\n    my($balanced_count) = $lst[0]\
    \ =~ /[()]+/g;\n    my $count = $lst[1] =~ /[()]+/g;\n    $count-- if $count <\
    \ $balanced_count;", "    my $len = scalar(@$lst);\n    my $count = 0;", "   \
    \ my $s = $lst[0];\n    my $l = length($s);\n    my @stack = ();\n    my @p =\
    \ ();\n    my $ok = 1;\n    my $len = 0;", '    my @lst_paren = map {/[^()]+/g}
    @$lst;', "    my $ret = \"No\";\n    my $i = 0;\n    my $open_count = -1;\n  \
    \  my $closed_count = -1;\n    for (my $i = 0; i < @$lst; ++$i) {\n        my\
    \ $curr = $lst->[$i];\n        if ($curr == \"(\") {\n            ++$open_count;\n\
    \        } elsif ($curr == \")\") {\n            if ($open_count == 0) {\n   \
    \             ++$closed_count;\n            } elsif ($closed_count != 0) {\n \
    \               --$closed_count;\n                $ret = \"No\";\n           \
    \ }\n        }\n    }\n    return $ret;\n}", "    my @res = ();\n    my $prev\
    \ = 0;\n    my $cnt = 0;\n    my $str = \"\";", "    my $is_good = 1;\n    my\
    \ $i = 0;\n    while( ($i < @$lst) && ($is_good) && ($lst->[$i] eq '(') || ($lst->[$i]\
    \ eq ')') ) {\n        $is_good = &is_good_pair($lst,$i,@$lst);\n        $i++;\n\
    \    }\n    return $is_good;\n}", "    my $first = $lst[0];\n    my $second =\
    \ $lst[1];\n    my($i, $j);\n    for ($i = 0; $i < length($first); $i++) {\n \
    \       if ($first[$i] eq '(' && $second[$i] eq ')') {\n            $i = $i +\
    \ 1;\n        }\n    }\n    if ($i == length($first)) {\n        return 0;\n \
    \   }\n    for ($j = $i + 1; $j < length($first); $j++) {\n        if ($first[$j]\
    \ eq ')' && $second[$j] eq ')') {\n            $j = $j + 1;\n        }\n    }\n\
    \    if ($j - $i == 1) {\n        return 1;\n    }\n    return 0;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic class Solution {\n    public\
    \ boolean areParenthesisBalanced(String S) {\n        if (S.length() == 0 || S.charAt(0)\
    \ == ')' || S.charAt(0) == '(') {\n            return false;\n        }\n    \
    \    int openParen = S.indexOf('(');\n        int closeParen = S.indexOf(')');\n\
    \        if (closeParen < openParen) {\n            int temp = openParen;\n  \
    \          openParen = closeParen;\n            closeParen = temp;\n        }\n\
    \        if (closeParen - openParen == 1) {\n            return true;\n      \
    \  } else {\n            return false;\n        }\n    }\n}\n</code>\n<|/ a tags=algorithm,string\
    \ |>\n<| a |>\n<code>", "    my $result = \"\";\n    my @stack = ();\n    my $count\
    \ = 0;", "    my($ret);\n    # find out if there exists a pattern that matches\
    \ all the characters\n    # in the list. If not, return 'No'.\n    for my $str\
    \ (@{$lst}) {\n        $ret .= $str if $str !~ /\\(\\)/;\n    }\n    return $ret\
    \ if $ret;\n    return 'No';\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl |>\n\
    This question is similar to those posted previously, but here are some additional\
    \ thoughts that may help solve this problem.\nThis problem can be solved in three\
    \ steps:", "    if (@$lst < 2) {\n        return 0;\n    }", "    my(@list) =\
    \ @$lst;\n    my $paren = 0;\n    my $string = 0;\n    my $count = 0;\n    my\
    \ $last_pos = 0;\n    my $last;\n    foreach my $x (@list) {\n        my $pos\
    \ = 0;\n        if ($x eq '(') {\n            $paren++;\n            $pos = $last_pos;\n\
    \        } else {\n            if ($x eq ')') {\n                $paren--;\n \
    \               $pos = $last_pos;\n            }\n        }\n        if ($pos\
    \ == $last) {\n            $string++;\n        }\n        $count++;\n        $last_pos\
    \ = $pos;\n    }\n    return $string == $count ? \"Yes\" : \"No\";\n}", "    my($str1\
    \ = pop(@$lst));\n    my($str2 = pop(@$lst));\n    return 1 if $str1 eq $str2;\n\
    \    return 1 if ($str1 eq \"\") || ($str2 eq \"\") || ($str1 eq \"()\") || ($str2\
    \ eq \"()\");\n    return 1 if (match_parens($str1,$str2));\n    return 1 if (match_parens($str2,$str1));\n\
    \    return 1 if match_parens($str2,$str1,$str1,$str2);\n    return 1 if match_parens($str2,$str1,$str1,$str1);\n\
    \    return \"No\";\n}", '    my $str = "";', "    my @stack = ();\n    for my\
    \ $string (@$lst) {\n        push @stack, $string if $string =~ /^\\(/;\n    \
    \    pop @stack if $string =~ /\\)/;\n    }\n    return if @stack > 1;\n    return\
    \ $string =~ /\\)/;\n    return $string =~ /^\\(/;\n    return;\n}", "    return\
    \ unless @$lst;\n    return 1 if @$lst < 2;\n    my($s1, $s2) = @$lst;\n    if\
    \ ($s1 eq $s2) {\n        return 1 unless $s1 =~ /^\\(.*\\)$/;\n    }\n    if\
    \ ($s1 =~ /^\\(.*\\)$/) {\n        return 1 unless $s2 =~ /^\\(.*\\)$/;\n    }\n\
    \    my $stack = ();\n    for my $i (1..$#$s1) {\n        my $s2_i = $#$s2;\n\
    \        my $s_i = $s1[$i];\n        my $p = $s_i eq '(' ? 1 : 0;\n        if\
    \ ($p != $stack[$#$stack]) {\n            return 0;\n        }\n        $stack[$#$stack]\
    \ = $p;\n    }\n    $stack[$#$stack] = 0;\n    return $stack[0] > 0;\n}", "  \
    \  my $max = ( @$lst > 0) ? @$lst : 0;\n    my ($i, $j, @result);\n    $j = 0;\n\
    \    for ($i = 0; $i < $max; ++$i) {\n        $result[$j++] = $lst[$i];\n    \
    \    if ( $lst[$i] eq '(') {\n            $j = 0;\n        }\n        if ($lst[$i]\
    \ eq ')') {\n            $j = 0;\n        }\n    }\n    my $ok = 0;\n    for (\
    \ @$result ) {\n        if ( $_ eq '(') {\n            $ok = $ok + 1;\n      \
    \  } elsif ( $_ eq ')') {\n            $ok = $ok - 1;\n        }\n    }\n    return\
    \ $ok == 0;\n}", "    return $lst if $lst->[0] =~ /^\\(/;\n    return $lst if\
    \ $lst->[1] =~ /^\\)/;\n    my $len = length($lst->[0]);\n    for (my $i = 1;\
    \ $i < $len; $i++) {\n        if ($lst->[$i] ne $lst->[$i - 1]) {\n          \
    \  return \"No\";\n        }\n    }\n    return \"Yes\";\n}", "    my $cur;\n\
    \    my $prev = '';\n    my $ret = 'No';\n    while (@$lst) {\n\tif ($cur = shift\
    \ @$lst) {\n\t    $ret eq 'Yes'\n\t\t&& ($cur =~ /\\(/)\n\t\t&& ($cur =~ /\\)/)\n\
    \t\t&& ($cur =~ $prev)\n\t\t&& ($prev =~ /\\)/)\n\t\t&& $cur =~ $prev;\n\t}\n\t\
    $prev = $cur;\n    }\n    return $ret;\n}", "    my $str = $lst[0];\n    my @list\
    \ = @{$lst[1]};\n    # Count opened parenthesis\n    my $cnt = 0;\n    foreach\
    \ my $char (@list) {\n        if ($str =~ /($char)/) {\n            $cnt++;\n\
    \        }\n    }\n    if ($cnt > 0) {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}", '    my(@arr);', "    my $l = length($lst[0]);\n    my $n = 0;\n\
    \    my $flag = 0;\n    my %stack;\n    foreach my $ch (@$lst) {\n        if ($stack{$ch}\
    \ and $stack{$ch} != $l){\n            $flag = 1;\n            last;\n       \
    \ }\n        else{\n            $stack{$ch} = $l;\n        }\n    }\n    if ($flag\
    \ == 1){\n        return 'Yes';\n    }\n    return 'No';\n}", "    my $str = $lst[0];\n\
    \    my $p1 = $lst[1];\n    my $p2 = $lst[2];\n    my $state = 0;\n    my $index\
    \ = 0;\n    my $count = 0;\n    for (my $i = 0; $i <= length($str); $i++) {\n\
    \        my $c = substr($str, $i, 1);\n        if ($state < 3) {\n           \
    \ if ($c == \")\" && $p2 ne \"\") {\n                $count++;\n             \
    \   $index = $i;\n                $p2 = \"\";\n                $state = 0;\n \
    \           } elsif ($c eq \"(\") {\n                $state++;\n             \
    \   $p1 .= $c;\n            }\n        } elsif ($state == 3) {\n            if\
    \ ($c == \")\" && $p2 ne \"\") {\n                $count++;\n                $index\
    \ = $i;\n                $p2 = \"\";\n                $state = 0;\n          \
    \  } else {\n                $state = 0;\n                $p1 .= $c;\n       \
    \     }\n        }\n    }\n    if ($state == 3) {\n        return \"Yes\";\n \
    \   } else {\n        return \"No\";\n    }\n}", "    $lst =~ tr/\\(\\)/\\(\\\
    )/;\n    return $lst =~ tr/\\(()/()/;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,string,python\
    \ dscore=0 |>\n<code>\ndef match_parens(s):\n    if len(s) <= 1:\n        return\
    \ 'Yes' if s[0] == '(' and s[-1] == ')' else 'No'", "    my @stack;\n    my $i\
    \ = 0;\n    my $len = $#lst;", "    my $paren = 0;\n    for (@$lst) {\n      \
    \  if (\"(\" == $_ ||\n            \"[\" == $_ ||\n            \"{\" == $_) {\n\
    \            $paren++;\n        } elsif (\")\" == $_) {\n            $paren--;\n\
    \        }\n    }\n    return $paren == 0;\n}", "    return ($lst->[0] =~ /\\\
    (\\)/) && $lst->[1] =~ /\\(\\)/;\n}", "    my $stack = ();\n    my $ret = \"\"\
    ;\n    my $i = 0;\n    \n    foreach my $s (@$lst) {\n        if ($s =~ /^\\(\\\
    )/) {\n            $stack->[$i] += 1;\n        }\n        elsif ($s =~ /^\\)$/)\
    \ {\n            $stack->[$i] -= 1;\n        }\n        elsif ($stack->[$i] <\
    \ 0) {\n            $ret .= \"No\";\n        }\n        elsif ($stack->[$i] >\
    \ 0) {\n            $ret .= \"Yes\";\n        }\n        $i++;\n    }\n    return\
    \ $ret;\n}\n</code>\nI used this approach because it seemed to work pretty well\
    \ for me (I'm very new to perl) and I did it all by hand. I wrote the code above\
    \ and it seems to be working fine as far as I can tell. Here's a couple examples\
    \ of successful runs:\n<code>", "    my($open, $close) = map {lc $_} ('(', ')');\n\
    \    my $good = 0;\n    for(@$lst){\n        my $pos = index($_, $open);\n   \
    \     next unless $pos;\n        $good |= (index($_, $close) == $pos);\n    }\n\
    \    return 'Yes' if $good;\n    return 'No';\n}", "    foreach my $l (@$lst)\
    \ {\n        next unless $l =~ /^\\(|$\\)/;\n        my @stack = @$l;\n      \
    \  my @cur;\n        my $ok = 1;\n        my $cnt = 0;\n        my $last;\n  \
    \      foreach my $s (@stack) {\n            if ($s == '(') {\n              \
    \  $cnt++;\n                push @cur, $s;\n            } elsif ($s == ')') {\n\
    \                $cnt--;\n                if ($cnt < 0) {\n                  \
    \  return \"No\";\n                }\n            } elsif ($cnt == 0 && $s eq\
    \ '(') {\n                push @cur, $s;\n            }\n        }\n        last\
    \ if $cnt < 0;\n        $last = pop @cur;\n        my $new = (join('', @cur),\
    \ $last);\n        if ($new !~ /($last)/) {\n            return \"No\";\n    \
    \    }\n        return \"Yes\";\n    }\n    return \"No\";\n}", "    my %paren\
    \ = ();\n    my $result = \"\";\n    my $last = \"\";\n    foreach my $s (@$lst)\
    \ {\n        if ($s =~ /^[()]+$/) {\n            $paren{$s}++;\n        }\n  \
    \  }\n    foreach my $k (keys %paren) {\n        if ($paren{$k} == 0) {\n    \
    \        if ($last eq $k) {\n                $result = $k;\n            }\n  \
    \      }\n    }\n    $result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=algorithm,regex,perl,string,arrays\
    \ |>\nThis is really a variation of the classic \"KMP Algorithm\" which isn't\
    \ really a regular problem but is a more complicated variation of the classic\
    \ longest common substring problem. \nIf you don't know what that is, just google\
    \ it there are plenty of solutions on the net.\nTo solve your problem, you need\
    \ to keep track of how many parentheses you have encountered and how many characters\
    \ you have seen so far.\nPseudocode:\n<code>\nFor i from 0 to (length of string\
    \ S) - 1 inclusive:\n    count[i] = number of characters seen up to i\n    count[i\
    \ + 1] = number of characters seen up to (i + 1)", "    my @out = ();\n    my\
    \ %stack = ();\n    my $state = 0;\n    my $count = 1;", "    # A flag for recording\
    \ whether we found a matching open\n    # parenthesis.\n    my $found = 0;\n \
    \   # A stack of open parenthesis counts.\n    my @stack = ();\n    # Iterate\
    \ through the parentheses counts, and push the count onto the\n    # stack if\
    \ the current parenthesis is encountered.\n    foreach my $count (@$lst) {\n \
    \       if ($count == 1 && !$found) {\n            $stack[$#stack + 1] = $count;\n\
    \            $found++;\n        }\n        elsif ($count == -1) {\n          \
    \  # Pop a count off the stack to see if we need to pop one further.\n       \
    \     my $count = @stack;\n            if ($count) {\n                $stack[$count\
    \ - 1]--;\n                $found--;\n            }\n            elsif ($count\
    \ == 0) {\n                # Stack is empty. Can't possibly match.\n         \
    \       return \"No\";\n            }\n        }\n        else {\n           \
    \ if ($found) {\n                # Pop a count off the stack to see if we need\
    \ to pop one further.\n                my $count = @stack;\n                if\
    \ ($count) {\n                    $stack[$count - 1]--;\n                    $found--;\n\
    \                }\n                elsif ($count == 0) {\n                  \
    \  return \"No\";\n                }\n            }\n            $stack[$#stack\
    \ + 1] = $count;\n        }\n    }\n    if ($found) {\n        # All parentheses\
    \ are closed. Found matching parentheses.\n        return \"Yes\";\n    }\n  \
    \  else {\n        return \"No\";\n    }\n}", '    my(@result) = (0);', "    my($i,\
    \ $res);\n    my @open = ();\n    my @close = ();\n    foreach $lst (@$lst) {\n\
    \        if ($lst =~ /\\(/) {\n            push(@open, $lst);\n        }\n   \
    \     if ($lst =~ /\\)/) {\n            push(@close, $lst);\n        }\n    }\n\
    \    for ($i = 0; $i < @open; $i++) {\n        $res = (@open[$i] eq (@close[$i]\
    \ - 1));\n        if ($res == 1) {\n            return 'Yes';\n        }\n   \
    \ }\n    return 'No';\n}", "    my($n); # number of opening parens\n    my(@stack);\
    \ # stack of open parens\n    my($good); # found solution?\n    for (@$lst) {\n\
    \        chomp;\n        if ($n > 0) {\n            if ($_ =~ /^$stack[-1]$/)\
    \ {\n                ++$n;\n            } else {\n                ++$n;\n    \
    \            @stack = ();\n            }\n        }\n        else {\n        \
    \    $n = 0;\n        }\n        push(@stack, $_);\n    }\n    $good = (@stack\
    \ == 0) ? 0 : 1;\n    return $good;\n}", "    my $i = 0;\n    my $last = $#lst;\n\
    \    my $res = \"\";\n    while ($i < $last) {\n        if ($lst[$i] eq \"(\"\
    ) {\n            $i++;\n        }\n        if ($lst[$i] eq \")\") {\n        \
    \    $i++;\n        }\n        elsif ($lst[$i] eq \")()\") {\n            $res\
    \ .= \"()\";\n            $i += 3;\n        }\n        else {\n            $res\
    \ .= $lst[$i];\n        }\n    }\n    return $res =~ /^\\(\\)/;\n}", "    $lst\
    \ =~ s/^(\\(|\\))//g;\n    if ($lst =~ /^(\\(|\\))$/) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}", "    my %seen;\n    my $cnt\
    \ = 0;\n    $cnt++ while $cnt < length $lst[0] && $lst[0] =~ /\\(/;\n    $cnt++\
    \ while $cnt < length $lst[1] && $lst[1] =~ /\\)/;\n    return $cnt >= 2;\n}",
  "    my $match = 0;\n    my $string = $lst->[0];", "    my $str = \"\";\n    my\
    \ $balanced = 0;\n    foreach my $str (@$lst) {\n        if ($str =~ m/\\)/g)\
    \ {\n            $balanced = 0;\n        } elsif ($str =~ m/\\()/g) {\n      \
    \      $balanced = 1;\n        }\n        if ($balanced) {\n            $str .=\
    \ \")\";\n        } else {\n            $str .= \"(\";\n        }\n    }\n   \
    \ if ($str =~ m/\\)/) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}", "    my($maxlen) = @$lst;\n    my $maxlen = ($maxlen < 1)?\
    \ 1: $maxlen;\n    my $i = 0;\n    my @bad = ();\n    my @good = ();\n    for(my\
    \ $i = 0; $i < $maxlen; $i++) {\n        my $str = substr($lst[$i], $i, 1);\n\
    \        if($str =~ /\\(/) {\n            push(@good, $i);\n        }\n      \
    \  if($str =~ /\\)/) {\n            if($i >= (scalar(@$lst) - 1)) {\n        \
    \        push(@bad, $i);\n            }\n        }\n    }\n    if(@good > 0) {\n\
    \        return \"Yes\";\n    }\n    if(@bad > 0) {\n        return \"No\";\n\
    \    }\n    return \"No\";\n}", "    my %seen;\n    foreach my $p (@$lst) {\n\t\
    $seen{$p}++;\n    }\n    for (@$lst) {\n\tif (! $seen{$_}) {\n\t    return (\"\
    No\");\n\t}\n\t$seen{$_}--;\n    }\n    return \"Yes\";\n}", "    my $good = \"\
    Yes\";\n    my $stack = reverse $lst;\n    my $idx = 0;\n    my $len = scalar\
    \ @$lst;", "    my(@parens, $open, $close);\n    \n    foreach $l (@$lst) {\n\
    \        if ($l eq '(') { push(@parens, $open++); }\n        elsif ($l eq ')')\
    \ { push(@parens, $close--); }\n    }\n    \n    if ($open != $close) {\n    \
    \    return \"No\";\n    }\n    \n    return \"Yes\";\n}", "    my @stack = ();\n\
    \    my $paren_stack = \"\";\n    my $len = @$lst;\n    for (my $i=0; $i<$len;\
    \ $i++) {\n        my $cur = $lst->[$i];\n        if ($cur eq '(') {\n       \
    \     push @stack, $cur;\n            $paren_stack .= $cur;\n        } elsif ($cur\
    \ eq ')') {\n            my $top = pop(@stack);\n            $paren_stack = $paren_stack\
    \ . ($top eq '(' ? ')' : ')');\n        } else {\n            if ($paren_stack\
    \ != \"\" && $paren_stack[-1] ne $cur) {\n                ++$stack[-1];\n    \
    \            ++$stack[-1];\n                $stack[-1] = '';\n               \
    \ $paren_stack = '';\n            }\n        }\n    }\n    return $stack[-1] ==\
    \ 0 && $paren_stack == \"\";\n}", "    my %stack = ();\n    my($ret) = 0;\n  \
    \  for (@$lst) {\n        if ($stack->{depth} == 0) {\n            if ($stack->{open}\
    \ ne \"()\" and\n                $stack->{close} ne \"()\" and\n             \
    \   $stack->{close} eq $stack->{open}) {\n                $stack->{open} = \"\
    ()\";\n                $stack->{close} = $_;\n                $stack->{depth}++;\n\
    \            }\n            elsif ($stack->{open} ne \"()\" and\n            \
    \       $stack->{close} eq \"()\") {\n                $stack->{close} = $_;\n\
    \                $stack->{depth}++;\n            }\n            elsif ($stack->{open}\
    \ eq \"()\" and\n                   $stack->{close} ne \"()\") {\n           \
    \     $stack->{open} = $_;\n                $stack->{depth}++;\n            }\n\
    \            elsif ($stack->{open} eq \"()\" and\n                   $stack->{close}\
    \ eq \"()\") {\n                $stack->{depth}++;\n            }\n        }\n\
    \        elsif ($stack->{depth} == 1) {\n            push @{$stack->{stack}},\
    \ $_;\n        }\n        elsif ($stack->{depth} > 1) {\n            $stack->{depth}--;\n\
    \        }\n        elsif ($stack->{open} eq $stack->{close}) {\n            if\
    \ ($_ =~ /^\\)/) {\n                $stack->{close} = \"()\";\n              \
    \  $stack->{depth}--;\n            }\n            $stack->{open} = \"()\";\n \
    \           $stack->{close} = $_;\n        }\n        elsif ($stack->{open} eq\
    \ \"()\") {\n            $stack->{open} = $_;\n        }\n        elsif ($stack->{close}\
    \ eq \"()\") {\n            $stack->{close} = $_;\n        }\n        elsif ($stack->{open}\
    \ eq \"()\" and $stack->{close} eq \"()\") {\n            $stack->{open} = $_;\n\
    \            $stack->{close} = $_;\n        }\n        else {\n            $stack->{open}\
    \ = \"()\";\n            $stack->{close} = \"()\";\n            $stack->{depth}++;\n\
    \        }\n        if ($stack->{depth} == 0) {\n            $ret = \"Yes\";\n\
    \            $stack->{depth} = 0;\n", "    my @a = @$lst;\n    my $ret = \"\"\
    ;\n    $ret = \"No\" if @a == 1;\n    $ret = \"Yes\" if (@a == 0 || !$ret);",
  "    my $lc = scalar @$lst;\n    my $match = 0;\n    for ($i = 0 ; $i <= $lc ; $i++)\
    \ {\n        if ($lst[$i] eq '(') {\n            $match++;\n        }\n      \
    \  if ($lst[$i] eq ')') {\n            $match--;\n        }\n        if ($match\
    \ == 0) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n\
    }", "    my $str1 = $lst[0];\n    my $str2 = $lst[1];\n    my $p1 = $str1;\n \
    \   my $p2 = $str2;\n    my $n1 = $str1;\n    my $n2 = $str2;", "    my $count\
    \ = 0;\n    my $stack = join('', grep {m/^[()\\s]+$/ } @$lst);\n    my $stack_rev\
    \ = reverse($stack);\n    my $result = $stack_rev =~ m/\\([^()]*\\)/;\n    return\
    \ $result ? 'Yes' : 'No';\n}", "    my @good = ();\n    for my $string (@$lst)\
    \ {\n        push (@good, \"Yes\") if ( $string =~ /^(\\(|\\))*$/ );\n    }\n\
    \    return wantarray ? @good : \"Yes\" if (@good > 0);\n    return \"No\";\n}",
  "    my(@out) = ('yes');\n    while(@lst > 2) {\n        my $l1 = shift @lst;\n\
    \        my $l2 = shift @lst;\n        if ($l1 eq $l2) {\n            push @out,\
    \ $l1;\n        }\n        elsif($l1 ne '(' && $l1 ne ')' && $l2 ne '(' && $l2\
    \ ne ')') {\n            last;\n        }\n        elsif($l1 eq '(' && $l2 eq\
    \ ')') {\n            push @out, $l1;\n            push @lst, $l2;\n        }\n\
    \        elsif($l1 eq ')' && $l2 eq '(') {\n            push @out, $l1;\n    \
    \        push @lst, $l2;\n        }\n        elsif($l1 eq '(' && $l2 eq '(') {\n\
    \            push @lst, $l1;\n        }\n        else {\n            last;\n \
    \       }\n    }\n    return 'Yes' unless @out;\n    return 'No';\n}", "    return\
    \ $lst[0] =~ /^\\(\\(.*?\\)\\)\\(\\(.*?\\)\\)$/ ? \"Yes\" : \"No\";\n}", "   \
    \ $lst = join '', @$lst;\n    return $lst =~ /([()])/;\n}", "    $lst =~ s/\\\
    )/)/;\n    $lst =~ s/\\(/(?{print $lst})/g;\n    $lst =~ s/\\)/)/;\n    return\
    \ $lst eq \"()()\" ? \"Yes\" : \"No\";\n}", "    my(@good_lst) = ();\n    my(@bad_lst)\
    \ = ();\n    for(my $i = 0; $i < @{$lst}; $i++) {\n        if ($lst[$i] eq '(')\
    \ {\n            push(@good_lst, $i);\n        }\n        if ($lst[$i] eq ')')\
    \ {\n            push(@bad_lst, $i);\n        }\n    }\n    if (@good_lst == 0\
    \ &&  @bad_lst == 0) {\n        return \"Yes\";\n    }\n    return \"No\";\n}",
  "    return 1 unless @$lst > 1;\n    return 1 unless @$lst[0] == 1 && @$lst[-1]\
    \ == 1;\n    return 1 unless $lst[0] =~ /^[(]/;\n    return 1 unless $lst[-1]\
    \ =~ /[)]$/;\n    my $lst_without_last = grep { $_ ne $lst[-1] } @$lst[1..$#$lst];\n\
    \    return 1 unless @$lst_without_last == @$lst - 1;\n    my $res = 0;\n    my\
    \ $i = 0;\n    while ($i < $#$lst && $i < $#$lst_without_last) {\n        $res\
    \ += 1 if ( $lst[$i] =~ /^[(]/  && $lst_without_last[$i] =~ /[)]$/ );\n      \
    \  $res += 1 if ( $lst[$i] =~ /[)]$/ && $lst_without_last[$i] =~ /^[(]/ );\n \
    \       $i++;\n    }\n    return $res;\n}", '    my($good, $str1, $str2, $start,
    $end, $flag);', "    my(@lst_of_parens) = ();\n    my($cur, $open, $close) = (\"\
    \", 0, 0);\n    for (my $i = 0; $i < @$lst; $i++) {\n        if ($lst_of_parens[$i])\
    \ {\n            $cur = $cur.$lst_of_parens[$i];\n        }\n        if ($lst_of_parens[$i]\
    \ eq \"(\") {\n            $open++;\n        }\n        if ($lst_of_parens[$i]\
    \ eq \")\") {\n            $open--;\n            $close++;\n        }\n      \
    \  if ($close != $open and $open != 0) {\n            return \"No\";\n       \
    \ }\n        $lst_of_parens[$i] = $lst_of_parens[$i];\n    }\n    return \"Yes\"\
    ;\n}", "    my $len = @$lst;\n    my $str = \"\";\n    my $flag = 0;\n    my $flag2\
    \ = 0;\n    my $flag3 = 0;\n    foreach my $char (@$lst) {\n        if ($char\
    \ == \")\" || $char == \"(\" || $char == \"]\") {\n            $str .= $char;\n\
    \        } else {\n            if ($flag != 0) {\n                if ($flag3 ==\
    \ 0) {\n                    $flag2 = 1;\n                    if ($flag2 == 0)\
    \ {\n                        $flag3 = 1;\n                    }\n            \
    \    }\n                if ($flag2 == 0) {\n                    $flag3 = 1;\n\
    \                }\n                if ($flag3 == 1) {\n                    $flag2\
    \ = 0;\n                }\n            }\n            if ($flag2 == 0) {\n   \
    \             if ($str =~ m/\\($char\\)/) {\n                    $flag = 1;\n\
    \                }\n            }\n            if ($flag == 3) {\n           \
    \     if ($str =~ m/\\($char\\)/) {\n                    $flag = 1;\n        \
    \        }\n            }\n        }\n    }\n    if ($flag == 1) {\n        return\
    \ \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "    my(@matches);\n\
    \    foreach my $match (@$lst) {\n        push (@matches, 0) unless $match =~\
    \ /\\(/;\n        push (@matches, 1) unless $match =~ /\\)/;\n    }\n    my $answer\
    \ = (@matches == 2);\n    $answer ? return \"Yes\" : return \"No\";\n}\n</code>\n\
    <|/ a dscore=2 tags=string,algorithm,recursion,parentheses,perl |>\n<| c |>\n\
    Nice answer. `use strict; use warnings;` would help a lot in your answer\n<|/\
    \ c |>\n<| c |>\nYour program does look nice in Perl. Could you explain how it\
    \ works?\n<|/ c |>\n<| c |>\nI really don't know Perl, only Python, so it won't\
    \ help too much.\n<|/ c |>\n<| c |>\nNicely done. I didn't expect that one would\
    \ have to write this much code for a simple problem. Nice job.\n<|/ c |>\n<| c\
    \ |>\nJust to let you know, I got this to work using Perl's `substr()` function.\
    \ `my $answer = (@matches == 2);\n$answer ? return \"Yes\" : return \"No\";` should\
    \ be `my $answer = (@matches == 2);\n$answer ? \"Yes\" : \"No\";`\n<|/ c |>\n\
    <| a tags=string,algorithm,recursion,parentheses,perl |>\n<code>\nuse strict;\n\
    use warnings;", "    my($count) = scalar;\n    my $count = 0;\n    my $open =\
    \ 0;\n    my $close = 0;\n    my $open1 = $open + ($count-1);\n    my $close1\
    \ = $close + ($count-1);\n    while ($open > $close) {\n        $count += 1;\n\
    \        my $open2 = $open + ($count-1);\n        my $close2 = $close + ($count-1);\n\
    \        while ($open2 < $close2) {\n            if ($lst[$open2] eq '(') {\n\
    \                $open += 1;\n            }\n            elsif ($lst[$close2]\
    \ eq ')') {\n                $close += 1;\n            }\n            $open2 +=\
    \ 1;\n            $close2 += 1;\n        }\n    }\n    return ($open < $close);\n\
    }", "    my $str = \"\";\n    my $open_count = 0;\n    my $close_count = 0;\n\
    \    foreach my $item (@$lst) {\n        if ($item eq \"(\") {\n            $open_count++;\n\
    \        } elsif ($item eq \")\") {\n            $close_count++;\n        }\n\
    \        if ($open_count > $close_count) {\n            $str .= $item;\n     \
    \   }\n    }\n    if ($open_count > $close_count) {\n        return \"Yes\";\n\
    \    }\n    return \"No\";\n}", "    my($p1, $p2);\n    my $p = 0;\n    while(\
    \ $p < length($lst[$p]) ){\n        if($lst[$p] eq '('){\n            push($p1,\
    \ $p);\n        }elsif($lst[$p] eq ')'){\n            push($p2, $p);\n       \
    \ }\n        $p++;\n    }\n    if( $p1 != $p2 ){\n        return 'No';\n    }\n\
    \    return 'Yes';\n}", "    my @stack;\n    my $inparen = 0;\n    my $string\
    \ = \"\";\n    for my $i (0..$#lst) {\n        if ($lst[$i] eq '(') {\n      \
    \      push(@stack, $i);\n            $inparen++;\n        }\n        if ($lst[$i]\
    \ eq ')') {\n            if ($inparen == 0) {\n                push(@stack, $i);\n\
    \                $inparen++;\n            } else {\n                $inparen--;\n\
    \            }\n        }\n        if ($inparen == 0 && $i == $#lst) {\n     \
    \       if (@stack == 1) {\n                $string = $lst[0];\n             \
    \   return $string;\n            }\n        }\n    }\n}", "    my($head,$tail,@stack)\
    \ = ();\n    my($last,$good,$goodstr,$goodstrlen) = ();\n    \n    foreach my\
    \ $i (0..$#lst){\n        my $l = length($lst[$i]);\n        \n        if ($last\
    \ = $head){\n            $head .= $lst[$i];\n            push (@stack, $head);\n\
    \            last if $l == 0;\n        }\n        else {\n            my $len\
    \ = $l - length($goodstr);\n            $goodstr .= substr($lst[$i],0,$len);\n\
    \            $goodstrlen += $len;\n            \n            if ($goodstrlen ==\
    \ $l && $goodstr =~ /\\(\\)/){\n                my $good = true;\n           \
    \     for (my $k = 0; $k < $l - length($goodstr); $k++){\n                   \
    \ if ($goodstr !~ /\\(\\)/){\n                        $good = false;\n       \
    \                 last;\n                    }\n                }\n          \
    \      if ($good){\n                    $goodstr = \"(\";\n                  \
    \  $goodstrlen = 1;\n                    $good = $head;\n                    push\
    \ (@stack, $head);\n                    $last = $head;\n                }\n  \
    \          }\n            elsif ($goodstrlen == $l && $goodstr =~ /\\)/){\n  \
    \              my $good = true;\n                for (my $k = 0; $k < $l - length($goodstr);\
    \ $k++){\n                    if ($goodstr !~ /\\)/){\n                      \
    \  $good = false;\n                        last;\n                    }\n    \
    \            }\n                if ($good){\n                    $goodstr = \"\
    )\";\n                    $goodstrlen = 1;\n                    $good = $head;\n\
    \                    push (@stack, $head);\n                    $last = $head;\n\
    \                }\n            }\n            elsif ($goodstrlen < $l){\n   \
    \             $goodstr = \"(\";\n                $goodstrlen = 1;\n          \
    \      $good = $head;\n                push (@stack, $head);\n               \
    \ $last = $head;\n            }\n        }\n    }\n    if ($head =~ /\\(\\)/){\n\
    \        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}",
  "    my(@good) = (0, 0);\n    my($i, $n);\n    $n =  scalar @$lst;\n    for ($i\
    \ = 0; $i < $n; $i++) {\n\tmy $item = $lst->[$i];\n\tmy $balanced_left = 0;\n\t\
    my $balanced_right = 0;\n\tmy $is_open;\n\t\n\tunless ( $item =~ /^\\(.*\\)/ )\
    \ {\n\t    $is_open = 0;\n\t} else {\n\t    $is_open = 1;\n\t    $balanced_left\
    \ = length($item) - length($$item) - 1;\n\t    $balanced_right = length($$item)\
    \ - length($item) - 1;\n\t}\n\t\n\tfor ($j = 0; $j < $n; $j++) {\n\t    $item\
    \ = $lst->[$j];\n\t    $is_open = 0;\n\t    unless ( $item =~ /^\\(.*\\)/ ) {\n\
    \t\t$is_open = 0;\n\t    }\n\t\n\t    if ( $is_open ) {\n\t\tif ( $balanced_left\
    \ == 0 ) {\n\t\t    $balanced_left--;\n\t\t}\n\t\tif ( $balanced_right == 0 )\
    \ {\n\t\t    $balanced_right--;\n\t\t}\n\t    }\n\t\n\t    if ( $is_open != $lst->[$j]->[0]\
    \ ) {\n\t\t$is_open = 0;\n\t    }\n\t}\n\t\n\tif ( $balanced_left == 0 ) {\n\t\
    \    push(@good, $i);\n\t}\n    }\n    \n    if ( @good ) {\n\treturn \"Yes\"\
    ;\n    } else {\n\treturn \"No\";\n    }\n}", "    my($res);\n    my $stack;",
  "    my($stack) = @{$lst};\n    my($end) = 0;\n    my($good) = 0;\n    foreach my\
    \ $el (@$lst) {\n        if ($el =~ /\\(/) {\n            $stack->[$end]++;\n\
    \            if ($stack->[$end] == $end - 1) {\n                $good++;\n   \
    \             last;\n            }\n        }\n        elsif ($el =~ /\\)/) {\n\
    \            if ($stack->[$end] == 0) {\n                $good++;\n          \
    \      last;\n            }\n            $stack->[$end]--;\n        }\n      \
    \  $end++;\n    }\n    return $good ? \"Yes\" : \"No\";\n}", "    my $res = \"\
    \";\n    my @stack = ();\n    my $last_open = 0;\n    foreach my $str (@$lst)\
    \ {\n        if ($str =~ /\\(/) {\n            push(@stack, $str);\n         \
    \   my $tmp = (pop(@stack))=~tr/\\)//;\n            $last_open = $tmp && $tmp\
    \ == $str;\n        }\n        if ($str =~ /\\)/) {\n            my $tmp = (pop(@stack))=~tr/\\\
    (//;\n            $last_open = $tmp && $tmp == $str;\n        }\n        if ($last_open)\
    \ {\n            $res .= $str;\n        }\n    }\n    return $res ? $res : \"\
    No\";\n}", "    my @stack = ();\n    my @bad = ();\n    my $cur = 0;\n    my $max\
    \ = $lst->[-1];\n    for ($cur = 1, $max >= 0; $cur++ ) {\n        if ($lst->[$cur]\
    \ eq '(') {\n            $stack->[$cur] = 1;\n            $bad->[$cur] = 1;\n\
    \        } elsif ($lst->[$cur] eq ')') {\n            $stack->[$cur] =  $stack->[$cur-1]\
    \ ?: 0;\n            $bad->[$cur] =  $bad->[$cur-1] ?: 0;\n            $stack->[$cur]\
    \ =  0;\n            $bad->[$cur] =  1;\n        } else {\n            die \"\
    unknown symbol: $lst->[$cur]\\n\";\n        }\n    }\n    for (my $n = $#stack;\
    \ $n >= 0; $n--) {\n        $bad->[$n] = 1 if ($stack->[$n] != 0);\n    }\n  \
    \  for (my $n = $#bad; $n >= 0; $n--) {\n        return 1 if ($bad->[$n] == 0);\n\
    \    }\n    return 0;\n}", "    $lst =~ s/\\s+//g;\n    my @pairs = ();\n    my\
    \ $max = 0;\n    foreach my $pair (split /\\s*,\\s*/, $lst) {\n        if ($pair\
    \ !~ /\\(|\\)|\\&/) {\n            die \"invalid pair: $pair\\n\";\n        }\n\
    \        push(@pairs, $pair);\n        if (length($pair) > $max) {\n         \
    \   $max = length($pair);\n        }\n    }\n    my $result = $max > 1;\n    foreach\
    \ my $pair (@pairs) {\n        if ($pair =~ /\\&/) {\n            $result = ($result\
    \ && $pair =~ /\\&/);\n        }\n        else {\n            $result = ($result\
    \ && !$pair =~ /\\&/);\n        }\n    }\n    $result;\n}", '    my $result =
    "No";', "    my $n = 0;\n    my $count = 0;\n    my $stack = 0;\n    my $good\
    \ = 1;", "    my $rev_lst = reverse @$lst;\n    for (@$lst) {\n\treturn 'Yes'\
    \ if !$rev_lst->[$_] ||\n\t\t($rev_lst->[$_] && $rev_lst->[$_] !~ /[())]/);\n\
    \    }\n    return 'No';\n}", "    my $ret = 1 if $lst->[0] eq '(';\n    my $ret\
    \ = 0 if $lst->[-1] eq ')';\n    return $ret;\n}", "    $lst += ['']; # Add the\
    \ empty string to $lst to make sure the list is always complete\n    my $len =\
    \ length($lst[0]); # Get the length of the string\n    my @stack = (@$lst); #\
    \ Create a copy of the stack\n    $stack[0] = \"()\"; # Replace \"()\" with an\
    \ empty string\n    for (my $i = 1; $i < $len; $i++) { # Search for the next open\
    \ parenthesis\n        my $char = substr($stack[0], $i, 1);\n        if ($char\
    \ == ')') {\n            $stack[0] ne '()' and\n            $stack[0] ne $lst[0][$i-1]\
    \ and\n            $stack[0] ne $lst[0][$i-1] and # if the next character is not\
    \ the same as the previous, then there is a possibility to concatenate\n     \
    \       ++$i or # increment the index to keep checking other characters\n    \
    \        last; # And return the result\n        }\n        $stack[0] = $char;\n\
    \    }\n    return $stack[0] =~ /^\\(/;\n}", "    my $max = $lst->[-1];\n    my\
    \ $count = 1;", "    return 0 unless @$lst;\n    my($head, $tail) = @$lst;\n \
    \   return 1 unless $head =~ /^\\(.*\\)$/;\n    return 0 unless $tail =~ /^\\\
    (.*\\)$/;\n    my($stack) = ('(');\n    my($is_open) = ('(');\n    my($result)\
    \ = '';\n    my($count) = ('0');\n    my(@stack) = ();\n    push @stack, $head;\n\
    \    while ($stack) {\n        my $elem = pop @stack;\n        return 1 unless\
    \ $elem =~ /^\\(.*\\)$/;\n        push @stack, $elem;\n        my $left_open =\
    \ $is_open;\n        $is_open = substr($elem, 0, 1);\n        if ($is_open ==\
    \ $left_open) {\n            $result .= $elem;\n            $count++;\n      \
    \  }\n    }\n    $result = substr($result, 0, -1);\n    return $result =~ /^(\\\
    (.*\\))$/;\n}", "    my $str = $lst->[0];\n    my $len = length($str);\n    my\
    \ $good = 0;\n    for my $i(1..$len) {\n        if ($str[$i-1] eq '(') {\n   \
    \         if (! match_parens($lst, $i)) {\n                $good = 0;\n      \
    \          break;\n            }\n        }\n        elsif ($str[$i-1] eq ')')\
    \ {\n            if (match_parens($lst, $i)) {\n                $good = 1;\n \
    \           }\n        }\n        else {\n            $good = 0;\n        }\n\
    \    }\n    return $good;\n}", "    my $count = 0;\n    my %stack = ();\n    for\
    \ (my $i = 0; $i < @$lst; $i++) {\n        my $curr = $lst->[$i];\n        if\
    \ ($curr eq '(') {\n            $stack{pop} = undef;\n            push @$stack,\
    \ undef;\n        } elsif ($curr eq ')') {\n            $stack{$stack{pop}} =\
    \ $stack{pop} || $i;\n            $count++;\n        } elsif (defined $stack{$i})\
    \ {\n            $count--;\n            if ($stack{$i} ne $i) {\n            \
    \    if ($count < 1) {\n                    return \"No\";\n                }\n\
    \                return \"No\";\n            }\n        }\n    }\n    return \"\
    Yes\";\n}", "    return $lst if $lst[0] == $lst[1]; # only one bracket\n    return\
    \ $lst if $lst[0] eq '(' && $lst[1] eq '('; # only one pair of braces\n    return\
    \ $lst if $lst[0] eq '(' && $lst[1] eq ')'; # only one pair of brackets", "  \
    \  my($ans) = \"No\";\n    foreach my $s (@$lst) {\n        if ($s eq \"(\") {\n\
    \            $ans = \"Yes\" if ( @$lst > 0 && $lst[0] eq \"(\");\n           \
    \ last;\n        }\n        if ($s eq \")\") {\n            $ans = \"Yes\" if\
    \ ( @$lst > 0 && $lst[0] eq \")\");\n            last;\n        }\n    }\n   \
    \ $ans;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,parentheses,string-matching,string,perl\
    \ |>\n<| a dscore=0 |>\n<code>", "    my $str = $lst[0];\n    my $open_bracket\
    \ = $str;\n    my $close_bracket = $str;\n    my $open_brace_count = 0;\n    my\
    \ $close_brace_count = 0;", "    my $max = 0;\n    my %seen;\n    foreach my $l\
    \ (@$lst) {\n        if ($seen{$l}++) {\n            die \"Error: String $l occurred\
    \ in more than one list.\\n\";\n        }\n    }\n    foreach my $l (@$lst) {\n\
    \        foreach my $r (@$lst) {\n            if ($l eq $r) {\n              \
    \  if ($max < 2) {\n                    $max = 2;\n                }\n       \
    \         else {\n                    $max++;\n                }\n           \
    \     next;\n            }\n            else {\n                my $len = length($l);\n\
    \                $max = $len;\n            }\n        }\n    }\n    my $ret =\
    \ 'No';\n    foreach my $l (@$lst) {\n        if ($l =~ /^[^()]*\\(([^()]*?)\\\
    )$/) {\n            $ret = 'Yes';\n            last;\n        }\n    }\n    return\
    \ $ret;\n}", "    my @out = ();\n    my $stack = 0;\n    my $open = 0;\n    my\
    \ $first = 1;\n    my $first2 = 0;\n    foreach my $i(0 .. $#lst) {\n        if\
    \ ($lst[$i] eq '(') {\n            $stack++;\n        }\n        elsif ($lst[$i]\
    \ eq ')') {\n            $stack--;\n        }\n        if ($stack > 0) {\n   \
    \         if ($first == 0) {\n                $first = 1;\n            }\n   \
    \         else {\n                $first2 = 0;\n            }\n        }\n   \
    \     if ($stack == 0 && $first == 1) {\n            $out[$first2++] = $i;\n \
    \       }\n    }\n    foreach my $i(0 .. $#out) {\n        if ($out[$i] - $out[$i-1]\
    \ >= 2) {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n\
    }", "    my $match = 0;\n    my $len = 0;\n    my $pos = 0;\n    my $char;\n \
    \   my $tmp;\n    my $end = 0;\n    my $tmp1 = $lst->[$pos];\n    my $tmp2 = $lst->[$pos\
    \ + 1];\n    my $curr;\n    my $prev;\n    $tmp1 =~ s/^\\s+//;\n    $tmp2 =~ s/^\\\
    s+//;\n    $tmp1 =~ s/\\s+$//;\n    $tmp2 =~ s/\\s+$//;\n    while ($tmp1 ne \"\
    \") {\n        $match = 0;\n        $prev = $tmp2;\n        my $tmp3 = $tmp1;\n\
    \        $tmp3 =~ s/^\\s+//;\n        my $tmp4 = $tmp3;\n        my $tmp5 = $tmp3;\n\
    \        $tmp5 =~ s/\\s+$//;\n        while ($tmp2 ne \"\") {\n            $pos\
    \ = 0;\n            $char = $tmp2->[$pos];\n            if ($char eq '(') {\n\
    \                $tmp1 = $tmp1;\n                $tmp1 =~ s/^\\s+//;\n       \
    \         while (!$match && $tmp1 ne \"\") {\n                    $curr = $tmp1;\n\
    \                    $tmp1 = $tmp1;\n                    $tmp1 =~ s/^\\s+//;\n\
    \                    $match++;\n                }\n                if ($tmp1 ne\
    \ \"\") {\n                    $match = 0;\n                    $match++;\n  \
    \                  $match++;\n                }\n                elsif (!$match)\
    \ {\n                    return 'No';\n                }\n            }\n    \
    \        elsif ($char eq ')') {\n                $tmp2 = $tmp1;\n            \
    \    $tmp2 =~ s/^\\s+//;\n                while (!$match && $tmp2 ne \"\") {\n\
    \                    $curr = $tmp2;\n                    $tmp2 = $tmp2;\n    \
    \                $tmp2 =~ s/^\\s+//;\n                    $match++;\n        \
    \        }\n                if ($tmp2 ne \"\") {\n                    $match =\
    \ 0;\n                    $match++;\n                    $match++;\n         \
    \       }\n                elsif (!$match) {\n                    return 'No';\n\
    \                }\n            }\n            else {\n                $pos++;\n\
    \            }\n        }\n        $match = 0;\n        while ($tmp1 ne \"\")\
    \ {\n            $char = $tmp1->[$pos];\n            if ($char eq '(') {\n   \
    \             $tmp1 = $tmp1;\n                $tmp1 =~ s/^\\s+//;\n          \
    \      while (!$match && $tmp1 ne \"\") {\n                    $curr = $tmp1;\n\
    \                    $tmp1 = $tmp1;", "    my $re = '\\((?<=\\()|(?<=\\))\\)';\n\
    \    if ($lst =~ /$re/) {\n        return \"Yes\";\n    }\n    return \"No\";\n\
    }", "    my @stack = ();\n    my @stack2 = ();\n    my $ret = 'No';\n    my $prev;\n\
    \    for (my $i = $#lst; $i > 0; $i--) {\n        my $next = pop @stack;\n   \
    \     my $next2 = pop @stack2;\n        if ($next eq $next2) {\n            $ret\
    \ .= $next;\n        } else {\n            push @stack, $next;\n            push\
    \ @stack2, $next2;\n            if ($prev eq $next) {\n                $ret .=\
    \ $prev;\n            } else {\n                $ret .= 'Yes';\n            }\n\
    \        }\n        $prev = $next;\n    }\n    return $ret;\n}", "    my($lst_stack)\
    \ = $lst;\n    my @stack;\n    my %stack;", "    $lst =~ s/^\\s*//;\n    my($close)\
    \ = 0;\n    my(@stack) = ();\n    foreach my $item (@$lst) {\n        if ($item\
    \ eq '(') {\n            push(@stack, $close);\n            $close = 1;\n    \
    \    } elsif ($item eq ')') {\n            my $p = pop(@stack);\n            my\
    \ $count = $close == $p ? $open : $close;\n            if ($count == 0) {\n  \
    \              return 'No';\n            }\n            $close = $p;\n       \
    \ }\n    }\n    return 'Yes';\n}", "    my @result = ();\n    my(@stack) = ();\n\
    \    for(my $i = 0;$i < @$lst;$i++) {\n        if($stack[-1] eq $lst->[$i]) {\n\
    \            $stack[-1]++;\n        } else {\n            push @result,\"No\"\
    ;\n            last;\n        }\n        push @stack,$lst->[$i];\n    }\n    if(@stack\
    \ == @$lst) {\n        push @result,\"Yes\";\n    }\n    return @result;\n}",
  '    my(@lst) = @$lst;', "    # Only two elements is OK.\n    return ($lst->[0]\
    \ eq '(' && $lst->[1] eq '(') ? \"Yes\" : \"No\");\n}", "    my $ans = \"$lst[0]\"\
    ;\n    for my $i (1..length($lst)) {\n        if ($ans =~ /\\(\\)|\\)/) {\n  \
    \          my $next = $lst[$i];\n            if ($ans =~ /($next)\\(\\)/) {\n\
    \                $ans =~ s/$next/$next$next/;\n            } elsif ($ans =~ /($next)\\\
    )/) {\n                $ans =~ s/$next/$next$next/;\n            } elsif ($ans\
    \ =~ /($next)/) {\n                $ans =~ s/$next/$next$next/;\n            }\
    \ else {\n                $ans =~ s/$next/$next$next/;\n            }\n      \
    \  } elsif ($ans =~ /\\(\\(|\\)$/ && $ans =~ /($lst[$i])\\(\\)/) {\n         \
    \   $ans =~ s/$lst[$i]/$lst[$i]$lst[$i]/;\n        }\n    }\n    return $ans;\n\
    }", "    my($res) = ();\n    for($lst, 0, 1) {\n        my ($start, $end) = @$lst[0,@$lst-1];\n\
    \        my $open = substr($start, 0, 1);\n        my $close = substr($end, 0,\
    \ 1);\n        my $balance = $open + $close;\n        if($balance != 0 && $balance\
    \ < 0) {\n            $res = 1;\n            last;\n        }\n    }\n    return\
    \ $res;\n}\n</code>\n<|/ a |>\n<| c |>\n`@$lst[0,@$lst-1]` will yield an array\
    \ slice that is the same as `@$lst`.\n<|/ c |>\n<| c |>\n, yes, you're right,\
    \ but it's much easier for me to understand that way and I prefer to use *@lst*\n\
    <|/ c |>\n<| c |>\n: I prefer `@lst` because `@lst[0]` isn't necessarily the same\
    \ as `@lst`. It's a good habit to get into, because `@lst[0]` is far clearer than\
    \ `@lst[0,1]`. The only place where `@lst[0,1]` is useful is when you want to\
    \ print something in the middle of an array.\n<|/ c |>\n<| c |>\nI guess this\
    \ would work, but I think there is a time complexity of O(n^2). I'm thinking there\
    \ should be a way of solving it in O(n).\n<|/ c |>\n<| c |>\n: I doubt that there\
    \ is any better than O(N) solution. I think it's O(N+M) because of checking parenthesis\
    \ and balance.\n<|/ c |>\n<| a tags=algorithm,sorting,string,perl dscore=3 |>\n\
    If your strings are \"reasonable\", say no more than 100 characters, and that\
    \ there are only two, just do:\n<code>\nif ($str1{$str2} eq $str2)\n    return\
    \ \"Yes\";\nelsif (length($str1) < 100 or length($str2) < 100)\n    return \"\
    No\";\nelse\n    return \"Yes\";\n</code>\nIf you need it to be more \"reasonable\"\
    , say no more than 2000 characters, then you can do this instead:\n<code>\nmy\
    \ %str1_hash = map { split '', $_, 2 } split(//, $str1);\nmy %str2_hash = map\
    \ { split '', $_, 2 } split(//, $str2);\nif (exists $str2_hash{$str1})\n    return\
    \ \"Yes\";\nelsif (length($str1) < 2000 or length($str2) < 2000)\n    return \"\
    No\";\nelse\n    return \"Yes\";\n", "    my $ans = 1;\n    foreach my $s (@$lst)\
    \ {\n        for my $i ( 0 .. length($s) - 1 ) {\n            if ( $s[$i] eq '('\
    \ and $s[$i+1] eq ')' ) {\n                $ans++;\n            }\n        }\n\
    \    }\n    if ( $ans == 1 ) {\n\treturn \"Yes\";\n    }\n    else {\n\treturn\
    \ \"No\";\n    }\n}", "    my $count = 0;\n    my $string = $lst[0][0];\n    my\
    \ $open = 1;\n    my $close = 0;\n    my $prev = $open;\n    $prev |= 1 while\
    \ $string =~ /\\\\$open/g;\n    for(my $i = 1; $i <= $#{$lst}; $i++) {\n     \
    \   my $str = substr($lst, $i - 1, 1);\n        my $new = $prev;\n        $new\
    \ |= 1 while $str =~ /\\\\$close/g;\n        $count += $new - $prev;\n       \
    \ $prev = $new;\n    }\n    return $count <= 0;\n}", "    my $first = pop(@$lst);\n\
    \    my(@pairs) = ();\n    $pairs[0] = $first;\n    my $count = 1;\n    for(my\
    \ $i = $#lst; $i >= 1; $i -= 1) {\n        my $next = $lst[$i];\n        for(my\
    \ $j = 0; $j <= $count; $j++) {\n            my $match = ($j != $count);\n   \
    \         my $new = ($next[$j] == $first[$j]);\n            if($match && ! $new)\
    \ {\n                $pairs[$j + 1] = $next[$j];\n                $count++;\n\
    \            }\n        }\n    }\n    return $pairs[$count] == 0;\n}", "    my(@good,\
    \ @bad, %stack, @res);\n    for my $s (@$lst) {\n        $s = str_reverse($s);\n\
    \        if ($s =~ /^($RE{balanced}{-parens=>0}*)$/) {\n            @good = ($1\
    \ eq '()');\n        } else {\n            @bad = ($1 eq '(');\n        }\n  \
    \      if (@good) {\n            $stack{\"\".substr($s, 0, 1)} = -1;\n       \
    \ }\n        if (@bad) {\n            my $last = substr($s, -1);\n           \
    \ my $len = $#s - 1;\n            $stack{\"$last\"} = $len;\n            $stack{\"\
    $s{$len}\"} = $len;\n        }\n    }\n    @res = keys %stack;\n    my $ok = (@res\
    \ == 2);\n    if ($ok) {\n        return $res[0];\n    } else {\n        return\
    \ \"No\";\n    }\n}", "    return ('Yes' if $lst->[0] =~ /\\(\\)/s &&\n      \
    \             $lst->[1] =~ /\\(\\)/s)\n}", "    return unless (@$lst >= 2);\n\
    \    my($lst1, $lst2) = @$lst;\n    my $i = $#lst1;\n    my $k = $#lst2;\n   \
    \ my $result = \"No\";\n    while ($i && $k) {\n        my $match = (substr($lst1[$i],\
    \ 0, 0) == substr($lst2[$k], 0, 0))\n            ? \"Yes\" : \"No\";\n       \
    \ $result eq $match ? return $result : next;\n        $i -= 1;\n        $k -=\
    \ 1;\n    }\n    return $result;\n}", "    my(@good) = (0, 0);\n    my $stack\
    \ = [0];", '    my(@bad) = ($lst eq "()" || $lst eq "[]");', "    my($s) = shift(@$lst);\n\
    \    $s = \"()\" unless $s;\n    my $flag = 0;\n    foreach my $str (@$lst) {\n\
    \        if($flag && $str eq \")\"){\n            $flag = 0;\n        } elsif\
    \ ($str eq \"(\"){\n            $flag = 1;\n        } elsif ($flag == 0 && $str\
    \ ne \")\"){\n            $flag = 0;\n        }\n    }\n    return $flag;\n}",
  "    my $n1 = $lst->[0];\n    my $n2 = $lst->[1];\n    $n1 =~ s/[()]+//g;\n    $n2\
    \ =~ s/[()]+//g;\n    $n1 =~ s/^$n1/#/g;\n    $n2 =~ s/^$n2/#/g;\n    if ($n1\
    \ eq $n2) {\n        $lst->[0] =~ s/^#//g;\n        return \"Yes\";\n    }\n \
    \   return \"No\";\n}", "    my($match) = { map { $_ => 'Yes'; } };", "    my(@lst)\
    \ = @$lst;\n    my $stack = Stack->new();\n    my $good_string = \"Yes\";\n  \
    \  my $good_string1 = \"No\";\n    my $counter = 0;", "    my($stack) = ();\n\
    \    my($result);\n    my($index) = -1;\n    while ($index <= $#lst) {\n     \
    \   if ($lst[$index] eq '(') {\n            push @$stack, index($lst, '(');\n\
    \        }\n        elsif ($lst[$index] eq ')') {\n            if (@$stack ==\
    \ 0) {\n                $result = 1;\n                break;\n            }\n\
    \            elsif (index($lst, '(') < @$stack) {\n                $result = 1;\n\
    \                $index--;\n            } else {\n                $stack = pop\
    \ @$stack;\n            }\n        }\n        $index++;\n    }\n    join '', @$stack;\n\
    }", "    my $result = \"Yes\";\n    my @paren = ();\n    \n    foreach my $p (split\
    \ //, $lst[0], -1){\n        unless ($p eq '(') {\n            $result = \"No\"\
    ;\n            last;\n        }\n        push(@paren, $p);\n    }\n    $result\
    \ = \"Yes\" if @paren == 0;\n    $result = \"No\" if @paren > 1;\n    return $result;\n\
    }", "    my $res = undef;\n    for my $str (@$lst) {\n        my $i = 0;\n   \
    \     my $parens = 0;\n        for (my $i = 0; $i < (length($str) - 1); $i++)\
    \ {\n            if ($str[$i] eq '(') {\n                $parens++;\n        \
    \    } elsif ($str[$i] eq ')') {\n                $parens--;\n            }\n\
    \            if ($parens < 0) {\n                $res = $str;\n            }\n\
    \        }\n    }\n    return $res;\n}", "    my(@ret) = ();\n    \n    # Ok,\
    \ we can start building the return string by traversing through the\n    # array.\n\
    \    foreach my $item (@$lst) {\n        # Ok, we need to see if we have reached\
    \ the closing brackets.\n        if ($item =~ /^\\)/) {\n            # Yes, we\
    \ found the closing brackets, so lets check if we are\n            # at the opening\
    \ brackets.\n            if ($item =~ /^\\(/) {\n                # Yes, we are\
    \ at the opening brackets, so lets check if we\n                # are matching\
    \ the closing brackets as well.\n                if ($item =~ /^\\)/) {\n    \
    \                # Yes, we have reached the matching closing brackets, so\n  \
    \                  # let's check if we reach the end of the string and if\n  \
    \                  # yes, we return \"Yes\".\n                    push(@ret, \"\
    Yes\");\n                } else {\n                    # No, we haven't reached\
    \ the end of the string, so we\n                    # keep going.\n          \
    \          push(@ret, \"No\");\n                }\n            } else {\n    \
    \            # No, we are at the closing brackets, not at the opening\n      \
    \          # brackets.\n                push(@ret, \"No\");\n            }\n \
    \       } else {\n            # Ok, we haven't reached the closing brackets, so\
    \ lets see\n            # if we're at the opening brackets.\n            if ($item\
    \ =~ /^\\(/) {\n                # Yes, we are at the opening brackets, so lets\
    \ check if we\n                # are matching the closing brackets as well.\n\
    \                if ($item =~ /^\\)/) {\n                    # Yes, we have reached\
    \ the matching closing brackets, so\n                    # let's check if we reach\
    \ the end of the string and if\n                    # yes, we return \"Yes\".\n\
    \                    push(@ret, \"Yes\");\n                } else {\n        \
    \            # No, we haven't reached the end of the string, so we\n         \
    \           # keep going.\n                    push(@ret, \"No\");\n         \
    \       }\n            } else {\n                # No, we are at the closing brackets,\
    \ not at the opening\n                # brackets.\n                push(@ret,\
    \ \"No\");\n            }\n        }\n    }", "    my $max_count = 0;\n    my\
    \ $count = 1;\n    my $first;\n    my $last;\n    my $re = qr/\\(/;\n    foreach\
    \ my $s (@$lst) {\n        $count = 1;\n        while ($count) {\n           \
    \ last unless $s =~ m/$re/;\n            $count++;\n        }\n        if ($s\
    \ =~ m/\\)/) {\n            $count--;\n            $count++ if $s =~ m/\\)/;\n\
    \        }\n        $max_count += $count;\n        $first = $s;\n        $last\
    \ = $s if $count > 1;\n    }\n    if ($max_count > 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}", "    my(@cur) = @$lst;\n \
    \   my(@ret) = ();\n    my $done = 0;\n    my ($open, $close, $left, $right, $next)\
    \ = ('', '', 0, 0, 0, -1);\n    while ($#cur > 0) {\n        my $cur = $cur[$_];\n\
    \        last if $cur eq '';\n        if ($cur eq '(') {\n            $open++;\n\
    \        } elsif ($cur eq ')') {\n            $close++;\n            $done++ if\
    \ $open > $close;\n        } elsif ($cur eq '[') {\n            $left++;\n   \
    \     } elsif ($cur eq ']') {\n            $right++;\n            $next = $_;\n\
    \        } elsif ($cur eq '{' || $cur eq '}') {\n            die \"Cannot parse\
    \ '{' or '}'\" unless ++$next;\n        }\n    }\n    return $done ? \"Yes\" :\
    \ \"No\";\n}", "    my @stack = ();\n    my $good = 'No';\n    for (@$lst) {\n\
    \        push(@stack, $_);\n    }\n    while (@stack) {\n        my $str = pop(@stack);\n\
    \        my $i = 0;\n        while ($i < length($str)) {\n            if ($str[$i]\
    \ eq '(') {\n                push(@stack, $str[$i+1]);\n                $i +=\
    \ 1;\n            } elsif ($str[$i] eq ')') {\n                my $l = pop(@stack);\n\
    \                if ($str[$i-1] ne '(' and $str[$i-1] ne ')') {\n            \
    \        $good = 'Yes';\n                } else {\n                    $good =\
    \ 'No';\n                }\n            }\n            $i += 1;\n        }\n \
    \   }\n    return $good;\n}", '    my ($re, $ret, $ch);', "    my($lst_rev) =\
    \ reverse $lst;\n    my(@stack) = (\"\");\n    my($flag);\n    foreach my $elem\
    \ (@$lst) {\n        if ($elem eq '(') {\n            push(@stack, $elem);\n \
    \           ++$flag;\n        } elsif ($elem eq ')') {\n            --$flag;\n\
    \        } elsif ($flag == 0) {\n            $flag == $lst_rev ? -1 : $flag ==\
    \ -1 ? 1 : 0;\n        } elsif (@stack == 0) {\n            return 'No';\n   \
    \     }\n    }\n    return 'Yes';\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank\
    \ you very much, it is working fine. can you please tell me whats the wrong with\
    \ my code.\n<|/ c |>\n<| c |>\nIt is not working for the case where you have only\
    \ one open parenthesis ( without space between them. For example: `match_parens([\"\
    (\",\")\"])`\n<|/ c |>\n<| c |>\nThat is because your code is checking for balanced\
    \ parentheses `[(\")(\")]` whereas your question is asking about balanced parentheses\
    \ `[(\")(\")]`.\n<|/ c |>\n<| c |>\nThat is correct, your code is only checking\
    \ for the first open parenthesis so `[(\")]` would return 'No' whereas `[(\")\"\
    ]` would return 'Yes'. You are correct that your question is asking about balanced\
    \ parentheses though, but your solution should fix that as well. Maybe you should\
    \ change your answer to make that clear.\n<|/ c |>\n<| c |>\n, Thanks for pointing\
    \ that out, I will try to fix it right now.\n<|/ c |>\n<| a dscore=1 |>\nTry this:\n\
    <code>", "    my $str = join(\"\\n\", @$lst);\n    return 1 unless $str =~ /($RE{paren})/g;\n\
    \    return 1 unless $str =~ /(\\(([^)]+)\\))/g;\n    return 0 unless $str =~\
    \ /([()])/g;\n    return 'Yes';\n}", "    foreach my $s (@$lst) {\n        my\
    \ %stack;\n        foreach my $c (split //, $s) {\n            if ($stack{')'})\
    \ {\n                if ($stack{'('}) {\n                    return 'No';\n  \
    \              } else {\n                    $stack{'('} = 1;\n              \
    \  }\n            } elsif ($stack{'('}) {\n                $stack{'('}--;\n  \
    \          } else {\n                my $good = $c eq '(';\n                $stack{$c}\
    \ = $good;\n            }\n        }\n        if ($stack{'('} != $stack{')'})\
    \ {\n            return 'No';\n        }\n    }\n    return 'Yes';\n}", "    my\
    \ $len = @$lst;\n    my $i = 0;\n    for (my $j = 0; $j < $len; $j++) {\n    \
    \    if ($lst[$j] eq '(') {\n            $i++;\n        } elsif ($lst[$j] eq ')')\
    \ {\n            --$i;\n        }\n    }\n    return $i ? 1 : 0;\n}", '    my($i,
    $j, $s);', "    my $ret = 0;\n    foreach my $s (@$lst) {\n        $ret |= $s\
    \ if (($s =~ /\\(/ or $s =~ /\\)/));\n    }\n    return $ret;\n}", "    my($stack)\
    \ = {};\n    my($end) = 0;\n    my($good) = 1;", "    return unless @$lst;\n \
    \   my(@left) = @$lst;\n    my $re = qr{^\n        (          # start a group\n\
    \            \\( \\)    # a left opening parenthesis\n            |          #\
    \ or\n            \\) \\)    # a right closing parenthesis\n        )        \
    \  # end a group\n        $\n    }x;\n    my $re2 = qr{^\n        (          #\
    \ start a group\n            \\( \\)    # a left opening parenthesis\n       \
    \     |          # or\n            \\) \\)    # a right closing parenthesis\n\
    \        )          # end a group\n        $\n    }x;\n    my $re3 = qr{^\n  \
    \      \\(        # a left opening parenthesis\n        |\\)        # or\n   \
    \     \\)        # a right closing parenthesis\n        $\n    }x;\n    while\
    \ (@left) {\n        # try first without parenthesis\n        if ($re->match($left[0]))\
    \ {\n            shift(@left);\n            return 'Yes';\n        }\n       \
    \ # try with parenthesis\n        if ($re2->match($left[0])) {\n            shift(@left);\n\
    \            return 'Yes';\n        }\n    }\n    return 'No';\n}", "    my($first)\
    \ = pop(@$lst);\n    my($second) = pop(@$lst);\n    my($good);", "    my $cnt\
    \ = 0;\n    my $sum = 0;\n    $lst = reverse sort @$lst;\n    foreach my $l (@$lst)\
    \ {\n        if ($l eq '(') {\n            $cnt += 1;\n        } elsif ($l eq\
    \ ')') {\n            $cnt -= 1;\n        } elsif ($cnt == 0) {\n            return\
    \ $cnt > 0;\n        }\n        $sum += $cnt;\n    }\n    return $sum == 0;\n}",
  "    my(@good) = (0);\n    foreach my $str (@$lst) {\n        if (index($str, \"\
    (\") != -1 && index($str, \")\") == -1) {\n            push(@good, \"No\");\n\
    \        }\n    }\n    if (@good > 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\n</cell>\n<cell>", "    my $result = \"No\"\
    ;\n    my $max = $#lst;\n    if ($max < 0) { return $result; }\n    my $i = 0;\n\
    \    while ($i < $max) {\n        my $char = substr($lst[$i], 1);\n        if\
    \ ($char == '(') {\n            $i++;\n        } elsif ($char == ')') {\n    \
    \        $i++;\n        } elsif ($char == '(' || $char == ')') {\n           \
    \ my $nextchar = substr($lst[$i], 1);\n            if ($nextchar == '(') {\n \
    \               $i++;\n            } elsif ($nextchar == ')') {\n            \
    \    $i++;\n            } elsif ($nextchar == '(' || $nextchar == ')') {\n   \
    \             $result = \"Yes\";\n                last;\n            }\n     \
    \   }\n    }\n    return $result;\n}", "    my @result = ();\n    my @stack =\
    \ ();\n    my @stack1 = ();", "    return 1 if $lst->[0] =~ /\\(/;\n    return\
    \ 1 if $lst->[1] =~ /\\)/;\n    return 0;\n}", "    my($maxlen) = length($lst->[0])\
    \ + length($lst->[1]) + 1;\n    my($j, $k) = (0, -1);\n    my($rev_str);\n   \
    \ my($stack) = (0, -1);\n    my($stack_len);\n    my($stack_ptr) = (0, -1);",
  "    my $re = qr{^\\(+|\\)+$}x;\n    return $lst if $lst =~ $re;\n    my $p1 = \"\
    (\";\n    my $p2 = \"(\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n\
    \    $p2 .= \")\";\n    $p1 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2\
    \ .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n\
    \    $p1 .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    return\
    \ $p1 . $p2 if $lst eq [\"($p1)\", \"($p2)\"];\n    my $p1 = \"(\";\n    $p2 .=\
    \ \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \")\";\n    $p1 .= \"|\"\
    \ if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1\
    \ .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"\
    |\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1\
    \ .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    return $p1\
    \ . $p2 if $lst eq [\"($p2)\", \"($p1)\"];\n    my $p1 = \"(\";\n    $p2 .= \"\
    |\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \")\";\n    $p1 .= \"|\" if\
    \ $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .=\
    \ \")\";\n    $p2 .= \"|\" if $p1 eq $p2;\n    $p1 .= \")\";\n    $p2 .= \"|\"\
    \ if $p1 eq $p2;", "    my $res = 0;\n    for (@$lst) {\n        my $opening =\
    \ 0;\n        my $closing = 0;\n        for (@{$_}) {\n            if ( $_ eq\
    \ '(' ) {\n                $opening++;\n            } elsif ( $_ eq ')' ) {\n\
    \                $closing++;\n            } elsif ( $opening == $closing ) {\n\
    \                $res = 1;\n            }\n        }\n    }\n    return $res;\n\
    }", "    my($good, $bad);\n    my $i = 0;\n    while ($i < @$lst - 1) {\n    \
    \    if ($lst[$i] eq '(') {\n            $good .= $lst[$i];\n            $i++;\n\
    \        }\n        elsif ($lst[$i] eq ')') {\n            $bad = $lst[$i];\n\
    \            $i++;\n        }\n        else {\n            die \"Illegal expression:\
    \ $lst[$i]\\n\";\n        }\n    }\n    if ($i < @$lst) {\n        die \"Too many\
    \ close parenthesis\\n\";\n    }\n    if ($good =~ /\\S/) {\n        return \"\
    Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}", "    my @res = ();\n\
    \    my $idx = 0;\n    my $len = length $lst[0];\n    my $level = 0;\n    my $ok\
    \ = 1;\n    for (my $i = 0; $i < $len; $i++) {\n        my $c = substr($lst[0],\
    \ $i, 1);\n        if ($c == \"(\") {\n            push (@res, \"(\");\n     \
    \       $level++;\n        } elsif ($c == \")\") {\n            push (@res, \"\
    )\");\n            $level--;\n            if ($level == 0) {\n               \
    \ $ok = 0;\n            }\n        }\n    }\n    if ($ok) {\n        return \"\
    Yes\";\n    } else {\n        return \"No\";\n    }\n}", "    my(@lst_with_parens)\
    \ = ();\n    my $i = 0;\n    while (@lst) {\n        $lst_with_parens[$i] = $lst[$i];\n\
    \        my $j = index($lst[$i], '(');\n        if ($j < 0) {\n            $lst_with_parens[$i]\
    \ = '';\n            next;\n        }\n        if ($j == -1) {\n            $lst_with_parens[$i]\
    \ = 0;\n            $i++;\n            next;\n        }\n        $i = $j + 1;\n\
    \        if ($i >= @lst) {\n            $lst_with_parens[$i] = '';\n        }\n\
    \    }\n    if (@lst_with_parens == 0) {\n        return 'No';\n    }\n    return\
    \ 'Yes';\n}", "    # Base Case\n    if (scalar @$lst == 1) {\n        return $lst[0];\n\
    \    }\n    # Recursion\n    elsif ($lst[0] eq \")\" && $lst[1] eq \")\") {\n\
    \        return \"Yes\";\n    }\n    # Recursion\n    elsif ($lst[0] eq \"(\"\
    \ && $lst[1] eq \"(\") {\n        return \"No\";\n    }\n    # Going through both\
    \ of the list\n    else {\n        # Checking if they're balanced\n        if\
    \ (match_parens($lst[0]) && match_parens($lst[1])) {\n            # Checking for\
    \ repetitions\n            if ($lst[0] eq $lst[1]) {\n                return \"\
    No\";\n            }\n            else {\n                return \"Yes\";\n  \
    \          }\n        }\n    }\n}", "    my($ret);\n    my $i = 0;\n    my $open\
    \ = 0;\n    my $close = 0;\n    foreach my $item (@$lst) {\n        if ($open\
    \ == 0) {\n            if ($item eq '(') {\n                $open++;\n       \
    \     } elsif ($item eq ')') {\n                $close++;\n            } else\
    \ {\n                print \"$i: $item\\n\";\n                $ret = \"No\";\n\
    \                last;\n            }\n        } elsif ($open == $close) {\n \
    \           $close++;\n        } else {\n            $open++;\n        }\n   \
    \     $i++;\n    }\n    if ($ret == 0) {\n        print \"$i: $item\\n\";\n  \
    \      $ret = \"No\";\n    }\n    return $ret;\n}", '    my @stack = ();', " \
    \   my $i = 0;\n    my $open = 0;\n    my $close = 0;\n    my $ret = \"No\";\n\
    \    while ($i < @$lst) {\n        $close = 0;\n        $open = 0;\n        if\
    \ ($lst[$i] eq '(') {\n            $open += 1;\n        }\n        if ($lst[$i]\
    \ eq ')') {\n            $close += 1;\n        }\n        if ($open != $close)\
    \ {\n            $ret = \"No\";\n        }\n        $i += 1;\n    }\n    return\
    \ \"Yes\" if ($ret eq \"Yes\");\n    return \"No\";\n}", "    $lst ||= [];\n \
    \   my $len = @$lst;", "    # Iterate through each element in the list\n    #\
    \ and see if any of them are balanced parens\n    for my $l (@{$lst}) {\n    \
    \    # Check if $l is an open paren ('(')\n        if ($l =~ m/^(/) {\n      \
    \      my $count = 1;\n            my $open = 0;\n            for my $i (0 ..\
    \ $#{$lst}) {\n                if ($lst[$i] eq $l) {\n                    $count++;\n\
    \                    $open++;\n                }\n                if ($lst[$i]\
    \ eq '(') {\n                    $open++;\n                }\n               \
    \ if ($lst[$i] eq ')') {\n                    $open--;\n                }\n  \
    \              if ($open == 0 && !$i) {\n                    return \"Yes\";\n\
    \                }\n            }\n        }\n        # Check if $l is a close\
    \ paren ')'\n        if ($l =~ m/^)/) {\n            my $count = 1;\n        \
    \    my $open = 0;\n            for my $i (0 .. $#{$lst}) {\n                if\
    \ ($lst[$i] eq $l) {\n                    $count++;\n                    $open++;\n\
    \                }\n                if ($lst[$i] eq '(') {\n                 \
    \   $open--;\n                }\n                if ($lst[$i] eq ')') {\n    \
    \                $open++;\n                }\n                if ($open == 0 &&\
    \ !$i) {\n                    return \"No\";\n                }\n            }\n\
    \        }\n    }\n    return \"No\";\n}", "    my $lst_str = join('',@$lst);\n\
    \    my $count = 0;\n    my $flag = 0;\n    my @stack;\n    push @stack, $lst_str;\n\
    \    while(@stack) {\n        my $str = shift(@stack);\n        my $open = $str\
    \ =~ m/\\((.*\\))/g;\n        my $close = $str =~ m/\\((.*\\))/g;\n        if($open\
    \ && $close && $open ne $close) {\n            $flag = 1;\n        }\n       \
    \ if($open && !$close) {\n            $flag = 1;\n        }\n        if($flag)\
    \ {\n            return \"Yes\";\n        }\n        push @stack, $str;\n    }\n\
    \    return \"No\";\n}", "    my(@good, $good_no) = (\"Yes\", \"No\");\n    \n\
    \    # A hash to store all opening brackets\n    my(%parens_hash);\n    \n   \
    \ # A hash to store all closing brackets\n    my(%close_brackets_hash);\n    \n\
    \    foreach my $x (@$lst) {\n        push @good, \"No\" unless exists $parens_hash{$x};\n\
    \        push @good, \"No\" unless exists $close_brackets_hash{$x};\n        push\
    \ @good, \"Yes\" unless exists $close_brackets_hash{$x};\n        push @good,\
    \ \"Yes\" unless exists $parens_hash{$x};\n    }", '    my $result = 0;', "  \
    \  my $i = 0;\n    $lst[$i] = $lst[$i-1];\n    for(my $j = 1; $j <= $#lst; $j++)\
    \ {\n        if($lst[$i] eq '(' and $lst[$j] eq '(') {\n            $i++;\n  \
    \      } elsif(not $lst[$i] eq '(' and $lst[$j] eq ')') {\n            return\
    \ 'No';\n        } else {\n            $i++;\n        }\n    }\n    return 'Yes';\n\
    }", "    my $res = \"\";\n    my $len = @$lst;\n    my $i = 0;\n    my $j = 0;\n\
    \    my $open_paren = 0;\n    my $close_paren = 0;", "    # This is O(n^2), but\
    \ it's fine because there aren't that many inputs.\n    for (my $i = 0; $i < @$lst;\
    \ $i++) {\n        my $left = $lst->[$i];\n        for (my $j = $i + 1; $j < @$lst;\
    \ $j++) {\n            my $right = $lst->[$j];\n            if ($left eq '(' &&\
    \ $right eq ')') {\n                # Make sure the order is correct to avoid\
    \ problems.\n                # If left is always left or right, then we can go\
    \ straight to\n                # the end (O(n)), otherwise we must check to see\
    \ if there's a\n                # matching right paren.  Once we find one, we\
    \ must see if the\n                # left and right paren are the same.\n    \
    \            my $new_left = $lst->[$j];\n                while ($new_left ne $right)\
    \ {\n                    my $new_left = $lst->[$j];\n                }\n     \
    \           while ($new_left eq $right) {\n                    my $new_left =\
    \ $lst->[$j];\n                }\n                if ($new_left ne $left) {\n\
    \                    return \"No\";\n                }\n                else {\n\
    \                    return \"Yes\";\n                }\n            }\n     \
    \   }\n    }\n    return \"No\";\n}", '    return unless @$lst == 2;', "    my\
    \ @stack;\n    my($open) = 0;\n    my($close) = 0;\n    my($str);\n    \n    foreach\
    \ $str (@$lst) {\n        chomp $str;\n        $open += length($str);\n      \
    \  $close = length($str);\n        \n        if ($open > 0) {\n            push(@stack,\
    \ $open);\n        }\n        if ($close > 0) {\n            push(@stack, $close);\n\
    \        }\n        \n        if (scalar(@stack) == 0) {\n            return \"\
    No\";\n        }\n        elsif ($stack[0] <= 0) {\n            return \"No\"\
    ;\n        }\n        else {\n            $open = $stack[0];\n            pop(@stack);\n\
    \        }\n    }\n    return \"Yes\";\n}", "    $lst[0] = join(\"\", @{$lst[0]});\n\
    \    $lst[1] = join(\"\", @{$lst[1]});\n    my($parens_stack) = ();\n    my $stack_top\
    \ = 0;\n    my $stack = ();\n    for my $i (0 .. length($lst[0]) - 1) {\n    \
    \    if ($lst[0][$i] eq '(') {\n            $parens_stack[$stack_top++]++;\n \
    \       }\n        if ($lst[0][$i] eq ')') {\n            if ($parens_stack[$stack_top]\
    \ > 1) {\n                $parens_stack[$stack_top]--;\n            }\n      \
    \      else {\n                $stack_top--;\n            }\n        }\n     \
    \   else {\n            push @$stack, $lst[0][$i];\n        }\n    }\n    while\
    \ (@$stack) {\n        pop @$stack;\n    }\n    if (@$parens_stack == 1) {\n \
    \       return 'Yes';\n    }\n    return 'No';\n}", "    my($i) = @$lst;\n   \
    \ my @open = ();\n    my @close = ();\n    my $result = \"\";\n    while (@$i)\
    \ {\n        if (@open == 0) {\n            push @close, $_;\n        }\n    \
    \    elsif (@open > 0) {\n            if ($_ =~ m/\\)$/) {\n                pop\
    \ @close;\n            }\n            elsif ($_ =~ m/\\)/) {\n               \
    \ pop @open;\n            }\n        }\n        else {\n            push @open,\
    \ $_;\n        }\n    }\n    $result = !((@open > 0) || (@close > 0));\n    $result\
    \ ? \"Yes\" : \"No\";\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
