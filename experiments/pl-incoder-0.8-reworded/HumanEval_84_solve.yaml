name: HumanEval_84_solve
language: pl
prompt: "# Given a positive integer N, return the total sum of its digits in binary.\n\
  # Example\n# >>> solve(1000)\n# \"1\"\n# >>> solve(150)\n# \"110\"\n# >>> solve(147)\n\
  # \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 \u2264 N \u2264 10000.\n\
  # Output:\n# a string of binary number\nsub solve {\n    my($N) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n\
  \        if(eq_deeply($candidate->(1000),\"1\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(150),\"110\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(147),\"\
  1100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(333),\"\
  1001\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(963),\"\
  10010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($s) = \"1\";\n    my($i) = 1;\n    my($j);\n    for(;$i<$N;$i++){\n\
    \        $j = ($i%2)?$i:0;\n        $s =~ s/(\\d)/$j/;\n    }\n    return $s;\n\
    }", "    return \"1\" if ($N & 1);\n    $N &= ~1;\n    my($sum);\n    my($temp);\n\
    \    my $num = 0;\n    while($N > 0){\n        $num ++;\n        $sum .= $temp;\n\
    \        $temp =  (10 + ($N % 10)) % 10;\n        $N /= 10;\n    }\n    return\
    \ $sum;\n}\n</cell>\n<code language=julia-1.1>\nsolve!(1000)\n</cell>\n<text>\n\
    Problem 2.1", '    return $N eq 1 ? "1" : $N eq 2 ? "10" : $N eq 4 ? "100" : $N
    eq 8 ? "1000" : $N eq 16 ? "10000" : $N eq 32 ? "100000" : $N eq 64 ? "1000000"
    : $N eq 128 ? "10000000" : $N eq 256 ? "100000000" : $N eq 512 ? "1000000000"
    : $N eq 1024 ? "1000000000000" : $N eq 2048 ? "1000000000000000" : $N eq 4096
    ? "1000000000000000000" : $N eq 8192 ? "1000000000000000000000" : $N eq 16384
    ? "1000000000000000000000000" : $N eq 32768 ? "10000000000000000000000000000"
    : $N eq 65536 ? "10000000000000000000000000000000" : $N eq 131072 ? "100000000000000000000000000000000"
    : $N eq 262144 ? "1000000000000000000000000000000000" : $N eq 524288 ? "1000000000000000000000000000000000000"
    : $N eq 1048576 ? "1000000000000000000000000000000000000000" : $N eq 2097152 ?
    "10000000000000000000000000000000000000000" : $N eq 4194304 ? "100000000000000000000000000000000000000000"
    : $N eq 8388608 ? "100000000000000000000000000000000000000000000" : $N eq 16777216
    ? "100000000000000000000000000000000000000000000000" : $N eq 33554432 ? "1000000000000000000000000000000000000000000000000"
    : $N eq 67108864 "10000000000000000000000000000000000000000000000000" : $N eq
    134217728 "10000000000000000000000000000000000000000000000000000" : $N eq 268435456
    "10000000000000000000000000000000000000000000000000000000" : $N eq 536870912 "100000000000000000000000000000000000000000000000000000000"
    : $N eq 1073741824 "1000000000000000000000000000000000000000000000000000000000"
    : $N eq 2147483648 "100000000000000000000000000000000000000000000" : $N eq 4503599627370496
    ? "100000000000000000000000000000000000000000000000" : $N eq 72057594037927936
    ? "1000000000000000000000000000000000000000000000000" : $N eq 140737488355328192
    ? "10000000000000000000000000000000000000000000000000" : $N eq 28147497671065680
    "100000000000000000000000000000000000000000000" : $N eq 56294995342131280 "100000000000000000000000000000000000000000000000"
    : $N eq 1125899906842624 "1000000000000000000000000000000000000000000000000" :
    $N eq 2251799813685248 "10000000000000000000000000000000000000000000000000', " \
    \   my $result = \"\";\n    for (my $i = 0; $i < $N; $i++) {\n        if ($N %\
    \ 2 == 0) {\n            $result .= \"1\";\n            $N /= 2;\n        } else\
    \ {\n            $result .= \"0\";\n            $N /= 2;\n        }\n    }\n \
    \   return $result;\n}\n</cell>\n<text>\nProblem 10\nThe Fibonacci sequence is\
    \ defined by the mathematical formula:", "    return if $N <= 0;\n    my $str\
    \ = \"\";\n    for ($N) {\n        if ($N & 1) { $str .= \"1\"; }\n        else\
    \ { $str .= \"0\"; }\n        $N >>= 1;\n    }\n    return $str;\n}", "    my\
    \ @digits = ();\n    for (my $digit = 0; $digit < $N; $digit++) {\n        $digits[$digit]\
    \ = int($N % 10) and $digit += 0 or $digit;\n        $N /= 10;\n    }\n    my\
    \ $result = \"\";\n    my $last_digit = @digits[$#digits];\n    for (my $i = $#digits;\
    \ $i >= 0; $i--) {\n        if ($digits[$i] != 0) {\n            my $digit = $last_digit\
    \ + $digits[$i] - 1;\n            $result .= chr(ord('0') + ($digit % 2));\n \
    \           $last_digit = $digits[$i];\n        }\n    }\n    return $result;\n\
    }", "    my ($i, $sum, $tmp);\n    my $ret = \"\";", "    my $n1 = $N;\n    my\
    \ $result = \"\";\n    foreach my $i (1..10) {\n        $N *= 2;\n        my $temp\
    \ = $N;\n        if ($temp >= $n1) {\n            $result = $i;\n            $N\
    \ = $temp;\n        }\n    }\n    return $result;\n}", "    my %binary  = map\
    \ { $_ % 2 ? \"1\" : \"0\" } 1 .. $N;\n    my $Nstr = join \"\", keys %binary;\n\
    \    return $Nstr;\n}", "    $N =~ s/^0+//;\n    $N =~ s/^([+-])(\\d+)$/$1+$2/;\n\
    \    return $N;\n}", "    \n    if ($N eq 0) {\n        return 0;\n    }\n   \
    \ \n    my $Nbin = $N;\n    while ($Nbin > 0) {\n        $Nbin = $Nbin >> 1;\n\
    \    }\n    \n    my @bits = ();\n    while ($Nbin > 0) {\n        push(@bits,\
    \ $Nbin & 1);\n        $Nbin = $Nbin >> 1;\n    }\n    \n    return join(\"\"\
    , @bits);\n}", "    my $res = \"1\";\n    $res .= $N / (2 * $N - 1);\n    my $tmp\
    \ = $N - 1;\n    my $tmp2 = $N + 1;\n    while ($N > 0) {\n        $res .= $N\
    \ / (2 * $N - 1);\n        $tmp -= $tmp2;\n        $tmp2 = $tmp;\n        $N =\
    \ $tmp / 2;\n    }\n    return $res;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nA simple recursive implementation:\n<code>\nfunction BinaryToDecimal($bin)\
    \ {\n    $bin = $bin - '0';\n    if ($bin >= 0) {\n        return BinaryToDecimal($bin\
    \ % 2) + BinaryToDecimal($bin / 2);\n    } else {\n        return 0;\n    }\n\
    }\n</code>\n<|/ a tags=perl,recursion |>\n<| a tags=perl,recursion dscore=0 |>\n\
    Here's a more complete version of what was suggested in the comments on the question:\n\
    <code>", "    my $sum = 0;\n    while($N >= 10) {\n        $sum += $N % 10;\n\
    \        $N = ($N / 10) - 1;\n    }\n    $sum += $N;\n    return \"$sum\";\n}",
  "    if ($N == 0) {\n        return \"0\";\n    }\n    my $res = \"\";\n    $res\
    \ = $res.\"$N%\".solve(div($N,2));\n    $res = $res.\"10\".solve(mod($N,2));\n\
    \    return $res;\n}", "    my $remainder = 0;\n    my $result = '';", "    #\
    \ Initialization\n    my$total = 0;\n    my$n = 0;\n    $total = $N;", "    my\
    \ $s = \"\";\n    for(my $i = 0; $i <= $N; $i++) {\n        $s .= $i % 2 ? '1'\
    \ : '0';\n    }\n    return $s;\n}", "    if($N < 0) {\n\treturn \"-1\";\n   \
    \ }\n    if($N < 10) {\n\treturn \"0\";\n    }\n    $str = \"\";\n    while($N\
    \ >= 10) {\n\t$str = $str . \"1\";\n\t$N = $N / 10;\n    }\n    $str = $str .\
    \ $N;\n    return $str;\n}", "    my($sum, $i);\n    if ($N == 0) { return \"\
    0\"; }\n    for ($i = 0; $i < $N; $i++) {\n        $sum += int($N % $i);\n   \
    \     $N = int ($N / $i);\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=math,python dscore=2 |>\nHere is a simple recursive program to\
    \ do this without using any modulus or division operations. \n<code>\ndef sum_of_digits(n):\n\
    \    if n == 0:\n        return '0'\n    elif n % 10 == 0:\n        return str(n//10)\n\
    \    else:\n        return str(n%10) + sum_of_digits(n//10)\n</code>\n<|/ a |>\n\
    <| a |>\nUsing modulo and division are both good approaches. However, here is\
    \ a solution that uses binary operators only (no division or modulo operators\
    \ needed).\n<code>\ndef sumOfDigits(n):\n    if n == 0:\n        return 0\n  \
    \  elif n % 2 == 0:\n        return sumOfDigits(n/2)\n    else:\n        return\
    \ (n%2) + sumOfDigits(n//2)", "    my $ret = \"\"; \n    \n    my $i = 0;\n  \
    \  \n    while($N > 0){\n        my $digit = oct($N % 10);\n        $N = $N /\
    \ 10;\n        $ret .= substr($digit, -1);\n        ++$i;\n    }\n    return $ret;\n\
    }", "    if ($N > 0 && $N < 10) {\n        return \"$N\";\n    }\n    $N > 999\
    \ ?\n        return \"1\" + solve($N - 1000) :\n        $N < 10 ?\n          \
    \  \"0\" :\n            solve($N - 10);\n}\n</code>\n<|/ a tags=recursion,algorithm,binary,recursion-schemes,mathematical-optimization\
    \ dscore=0 |>\n<| a dscore=0 |>\nHere's one that doesn't use recursion.  It returns\
    \ the binary number for N and a bitmask of which digits were used.\n<code>\npublic\
    \ class NBinaryNumber {", "    my($remainder) = $N;\n    my($sum) = \"\";\n  \
    \  while ($remainder > 0) {\n        $sum += '1'\n            if $remainder >\
    \ 9;\n        $remainder -= 10;\n    }\n    return $sum;\n}", "    my($temp) =\
    \ sprintf(\"%010d\", $N);\n    $temp.=~s/0*$temp//;\n    $temp =~ tr/0/1/g;\n\
    \    return $temp;\n}\n</code>\n<|/ a |>\n<| c |>\nI like this, it's really nice.\
    \ I would suggest adding $N < 10 to the constraints as well. `my($N) = @_; return\
    \ \"0\" unless $N > 0 && $N < 10;`\n<|/ c |>\n<| c |>\nAlso, `my($N) = @_;` should\
    \ be `my;`.\n<|/ c |>\n<| c |>\nThat was a great suggestion.\n<|/ c |>\n<| c |>\n\
    This code fails if $N < 10.\n<|/ c |>\n<| c |>\nThis is not the place to discuss\
    \ such things. Maybe you should post your own question about it.\n<|/ c |>\n<|\
    \ a tags=optimization,algorithm,math,big-o,complexity-theory |>\nIf N is bounded\
    \ by a constant C, and you want the answer to be as fast as possible, then you're\
    \ probably looking at a problem which has O(log N) worst-case complexity. One\
    \ solution is to calculate all the digits in base-N, store them in a linked list,\
    \ and for each digit, compute the next and previous digit.\nThe time complexity\
    \ of computing the next and previous digits is O(1), which can be done in constant\
    \ time. Once you have the previous digit, you can compute the next by computing\
    \ all the digits (up to and including the current digit) and then subtracting\
    \ the previous digit.\nThe total complexity of the entire algorithm is O(log N).\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is the best answer, but can you tell me how to\
    \ do that in Java?\n<|/ c |>\n<| c |>\nI'm not too familiar with Java, so I'm\
    \ afraid I can't help you there. But I'm sure the algorithm is relatively easy\
    \ to implement - just keep a linked list of the numbers from 1 to N, and for each\
    \ number, compute the next and previous digit, then append that to another linked\
    \ list, then append that list to the list of numbers from 1 to N.\n<|/ c |>\n\
    <| c |>\nThanks for your answer but can you give me an example in Java, please?\n\
    <|/ c |>\n<| c |>\nThanks for your answer. But what is the time complexity of\
    \ computing next and previous digit?\n<|/ c |>\n<| c |>\n: It's O(1).\n<|/ c |>\n\
    <| a ", "    my ($num, $res);\n    my $digits = 0 while $N >= 10000;\n    $N =\
    \ 10**($digits-1)*$N;\n    my $nDigits = length($N);\n    my $remainder = $N %\
    \ $nDigits;\n    while ($remainder > 9) {\n        $remainder = 10*$remainder\
    \ - 9;\n        $num = $num * 2 + $remainder;\n        $N = $N / $nDigits;\n \
    \       $nDigits = length($N);\n        $remainder = $N % $nDigits;\n    }\n \
    \   $res = $num * 10 + $remainder;\n    $res;\n}", "    my $sum = 0;\n    \n \
    \   for(1..$N) {\n        $sum += $_ & 1;\n        $_ = $_ >> 1;\n    }\n    \n\
    \    return \"$sum\";\n}", "    return \"0\" if ($N < 0);\n    return \"1\" if\
    \ ($N == 0);\n    # Find leading zeroes, and increment by one\n    my($L) = 0,\
    \ $N % 2;\n    while ($L < $N) {\n        $L++;\n    }\n    # Get the number of\
    \ digits of $N\n    my($Nd) = length $N;\n    # Convert from binary to decimal\n\
    \    my($Nd) = $Nd + ($N =~ /[01]/) * 2 - $L;\n    # Find the first '1' after\
    \ $L, and add the two digits\n    my($Nd) = ($Nd +1 ) / 2;\n    $Nd = ( ( $Nd\
    \ % 2 ) ? $Nd / 2 : 0 );\n    # Convert back to binary\n    my($N) = join '',\
    \ map { chop $_ % 2 ? $_ : '0' } reverse split(//, $N);\n    # Convert digits\
    \ to binary number\n    my($N) = ( $L ) ? substr( $N, 0, $L ) : $N;\n    # Output\
    \ the answer when there are no digits to output\n    return \"1\" if ($N > 1);\n\
    \    return $N;\n}", "    my $str = \"\";\n    my $cur = \"\";\n    my $base =\
    \ \"\";\n    $N = $N - 1;\n    while($N > 0) {\n        $cur = \"\";\n       \
    \ $cur = \"1\" if ($N % 2 == 0);\n        $N = $N / 2;\n        $cur .= \"$base\"\
    \ if ($N > 0);\n        $str .= $cur;\n    }\n    return $str;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\n<code>\nint solve(long int N)\n{\n    string s = \"\"\
    ;\n    long int k = 1;", '    my $sum = 0;', "    my $a = $N % 2;\n    my $c =\
    \ $N / 2;\n    my $s = 0;\n    while(1) {\n        if($c > 0) {\n            my\
    \ $n = $c;\n            $s += $n / 2;\n            $c = $n % 2;\n        } else\
    \ {\n            my $n = $c;\n            $s += $n / 2;\n            return \"\
    $s$a\";\n        }\n    }\n}\n</code>\n<|/ a dscore=2 tags=algorithm,c++,c,binary,integer\
    \ |>\n<| a tags=algorithm,c++,c,binary,integer dscore=2 |>\nHere is my C++ solution.\
    \ I just put it together from bits of different sources online.\n<code>\nstring\
    \ numToBinary(int num) {", "    # Count number of 0s left of N and add 1 to\n\
    \    # binary number for correct number of 0s to right\n    # of the number\n\
    \    my $num_0s = $N & 1;\n    $N = N - $num_0s;", "    $N = abs($N);\n    my\
    \ $Nstr = $N;\n    my @Ns = split(\"\", \"\", $Nstr);\n    my $num = 1;\n    my\
    \ @sums = ();", "    my $result = \"\";\n    for (my $i = 0; $i < $N; $i++) {\n\
    \        $result .= \"1\" if ($N & $i);\n    }\n    return $result;\n}", "   \
    \ $N = abs($N);\n    my $s = '';\n    my $rem;\n    while ($N > 0) {\n       \
    \ $rem = $N % 2;\n        $s = $rem.$s;\n        $N = ($N - $rem)/2;\n    }\n\
    \    return $s;\n}\n</code>\n<|/ a |>\n<| a tags=math,integer,algorithm,perl,java\
    \ |>\nPerl Solution\n<code>", "    return \"\" unless $N =~ /^\\d+$/;\n    my\
    \ @N = split(//, $N);\n    $N = pop(@N);\n    for my $N (@N) {\n        my @N\
    \ = split(//, $N);\n        $N = pop(@N);\n    }\n    my $answer = \"0\";\n  \
    \  foreach my $N (@N) {\n        my $number = int(\"0b$N\", 2);\n        $answer\
    \ = $answer . sprintf(\"%b\", $number);\n    }\n    return $answer;\n}", "   \
    \ my $s = \"\";\n    for(my $i = 1; $i < $N; $i++) {\n        $s = \"${s}${i}\
    \ \";\n    }\n    return $s;\n}", "    my @binary_result = ();\n    my $binary\
    \ = \"\";\n    foreach my $index (0 .. $N-1) {\n        $binary .= \"%\" . $N\
    \ % ($N - $index);\n        push (@binary_result, $binary);\n    }\n    my $result\
    \ = join(\"\", @binary_result);\n    return $result;\n}", "    if ($N == 0) {\
    \ return \"0\"; }\n    my $N = int $N;\n    my @a = ($N % 2) ? (\"0\") : (\"1\"\
    );\n    my $remainder = $N % 10;\n    $remainder = $remainder < 0 ? -$remainder\
    \ : $remainder;\n    for my $i (1..$#a) {\n        push @a, $a[$i] * $remainder;\n\
    \        $remainder = $remainder % 2;\n    }\n    return \"@a\";\n}", "    my\
    \ @bits = (\"0000\"x$N);\n    my $t = 0;\n    my @i = 0..$#bits;\n    while (@i\
    \ > 0){\n        $t += $bits[$i] & 1;\n        $bits[$i] >>= 1;\n        $i -=\
    \ 1;\n    }\n    return $t;\n}\n</code>\n<|/ a tags=math,binary,algorithm |>\n\
    <| a |>\nFor positive numbers there are a number of different algorithms for getting\
    \ the sum of its digits. For large numbers, you generally only want one algorithm,\
    \ but for small numbers like 1000 it's possible to get one or two. \nThe easiest\
    \ way to do this is the naive algorithm: add all the digits in reverse order,\
    \ then reverse the sum when you are done.\n<|/ a tags=math,binary,algorithm dscore=0\
    \ |>\n<| c |>\nBut that will take O(log(N)) time right? Because you're doing the\
    \ multiplication and division all at once. I'm interested in how you come up with\
    \ that O(log(N)) algorithm?\n<|/ c |>\n<| c |>\n: I'm not sure, but I think it'd\
    \ be something like O(log(n)) if the number of digits were divided by 2.  I did\
    \ a little search and it looks like a similar algorithm is used for decimal numbers:\
    \ http://homepage.mac.com/rob_bell/courses/maths_symbolic/decimal_digits/decimal_digits.htm\n\
    <|/ c |>\n<| c |>\n- I'm pretty sure there's a way to get the number of digits\
    \ in O(1). I'm pretty sure I did it on paper in the middle of the night and didn't\
    \ have my computer around so I couldn't find my original code. Let me see if I\
    \ can find it. :-)\n<|/ c |>\n<| c |>\n: Not sure if this is what you're looking\
    \ for, but if you divide the number by the tens place in binary and take the ceiling\
    \ of the quotient, you can get the number of digits in O(1). See my answer below.\n\
    <|/ c |>\n<| a tags=math,binary,algorithm |>\nFor positive integers you can use\
    \ the ceiling function:\n<code>\ndef sum(number):\n    while(number):\n      \
    \  number -= number % 10\n    return number\n</code>\nFor negative integers you\
    \ can use the same algorithm but subtract by 10 instead of dividing by ten.\n\
    <|/ a dscore=0 |>\n<| a tags=math,binary,algorithm |>\nIf n is a positive integer,\
    \ the sum of the digits of n is given by n mod 10 (since n is positive by definition).\n\
    If the number is negative, the number has more than one digit, so ", "    my $base2\
    \ = $N == 0 ? \"0\" : $N <= 9 ? \"1\" : $N <= 99 ? \"10\" : \"11\";\n    my =\
    \ reverse $base2 =~ s/(.)(\\1*)/$2$1/g;\n    return $base2 if $N <= 15;\n    my\
    \ = reverse $base2 =~ s/(.)(\\1*)(\\*)/$3$2$4/g;\n    return $base2 if $N <= 15;\n\
    \    my = reverse $base2 =~ s/(.)(\\1*)(\\*)(\\*)/$3$4$2$1/g;\n    return $base2\
    \ if $N <= 15;\n    my = reverse $base2 =~ s/(.)(\\1*)(\\*)(\\*)(\\*)/$4$3$2$1/g;\n\
    \    return $base2 if $N <= 15;\n    my = reverse $base2 =~ s/(.)(\\1*)(\\*)(\\\
    *)(\\*)(\\*)/$4$4$3$2$1/g;\n    return $base2 if $N <= 15;\n    my = reverse $base2\
    \ =~ s/(.)(\\1*)(\\*)(\\*)(\\*)(\\*)(\\*)/$5$4$3$2$1/g;\n    return $base2 if\
    \ $N <= 15;\n    my = reverse $base2 =~ s/(.)(\\1*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\\
    *)/$5$5$4$3$2$1/g;\n    return $base2 if $N <= 15;\n    my = reverse $base2 =~\
    \ s/(.)(\\1*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)/$6$5$4$3$2$1/g;\n    return $base2\
    \ if $N <= 15;\n    my = reverse $base2 =~ s/(.)(\\1*)(\\*)(\\*)(\\*)(\\*)(\\\
    *)(\\*)(\\*)(\\*)/$6$6$5$4$3$2$1/g;\n    return $base2 if $N <= 15;\n    my =\
    \ reverse $base2 =~ s/(.)(\\1*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)(\\*)/$7$6$5$4$3$2$1/g;",
  "    if ($N == 0){\n\treturn \"0\";\n    }\n    my @result = ();\n    $result[0]\
    \ = Math::to_bin($N);\n    my $sum = 0;\n    for (my $i = 1; $i < length($result[0]);\
    \ $i++){\n        my $c = substr($result[0], $i, 1);\n        my $tmp = ($c ==\
    \ \"0\") ? 0 : ($c == \"1\") ? 1 : -1;\n        $sum += $tmp;\n    }\n    my $result\
    \ = Math::to_base($sum, 2);\n    return $result;\n}", "    my @arr = map { 0 }\
    \ 1 .. $N;\n    my $s = \"\";\n    for my $i (0 .. $#arr) {\n        $s += \"\
    0\" x $arr[$i];\n    }\n    $s;\n}", "    $N =~ s/^\\D//g;\n    return $N eq \"\
    1\" ? \"1\" : $N eq \"0\" and \"0\" or \"1\";\n}", "    my $sum = 0;\n    my @nums\
    \ = (0..$N-1);\n    my $s = \"\";\n    for(0..(@nums-1)) {\n        my $x = $nums[$_];\n\
    \        $sum += $x%2;\n        $s += $x.\"0\";\n        $nums[$_] = $nums[$_]\
    \ + 1;\n    }\n    return $s.substr($sum+1);\n}", "    $N *= 2;\n    $N |= 1;\n\
    \    if ($N <= 0) {\n        return '';\n    }\n    $N += 1;\n    while (1) {\n\
    \        $N /= 2;\n        if ($N <= 0) {\n            return $N ^ 1;\n      \
    \  }\n        $N += 1;\n    }\n}", "    $N == 0 ? \"0\" : join(\"\", map { \"\
    $N%2\" eq \"0\" ? '0' : '1' } split($N div 2));\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Hi Eric, this works really well. Could you please explain the \"map { \"$N%2\"\
    \ eq \"0\" ? '0' : '1' }\" part ? I understand what it does, but would like to\
    \ understand how it works.\n<|/ c |>\n<| c |>\nIt's a ternary operator. It's similar\
    \ to an if-else statement, except that it's an expression that returns one of\
    \ two values. In this case, it returns either \"0\" or \"1\" based on the value\
    \ of `$N%2` modulo 2.\n<|/ c |>\n<| c |>\nThe way I have written it is the same\
    \ as `if( $N%2 eq \"0\" ) { $N = \"0\" } else { $N = \"1\" }`. It's called a ternary\
    \ operator. `$N%2 eq \"0\"` returns either \"1\" or \"0\". The `map` line then\
    \ turns each digit into its character representation. `eq` is used for comparing\
    \ strings (which is true when they're equal), `==` is used for comparing numbers\
    \ (which is true when they're equal).\n<|/ c |>\n<| c |>\nNice, could you please\
    \ provide a brief explanation of why it works?\n<|/ c |>\n<| a tags=string,algorithm,math\
    \ dscore=2 |>\nThis is a good use of a hash table. Create an array of strings.\
    \ To get a binary string, add \"0\" or \"1\" to the corresponding index based\
    \ on the value of that position in the hash. You don't have to create the full\
    \ hash up front, just the two strings.\n<|/ a |>\n<| c |>\nI'm not sure I follow\
    \ how this answers the question. How does that map the value of N to a binary\
    \ string?\n<|/ c |>\n<| c |>\nHi Tyler, I added an example above, where I used\
    \ a hash to convert a number to binary.\n<|/ c |>\n<| a tags=string,algorithm,math\
    \ |>\nA simple approach:\n<code>\ndef binary(n):\n  binary = \"\"\n  while n:\n\
    \    binary = str(n % 2) + binary\n    n = int(n/2)\n  return binary", "    my\
    \ $result = '';\n    my $i = 0;\n    while ($N > 0) {\n        my $remainder =\
    \ $N % 2;\n        $result = $remainder . $result;\n        $N = $N / 2;\n   \
    \     $i = $i + 1;\n    }\n    return $result;\n}", "    return ($N < 10) ? \"\
    0\" : ($N < 100) ? $N . solve(int($N/10)) : solve (int($N/10)) . $N . solve(int($N%10));\n\
    }", "    my $ans = '';\n    my $i = 1;\n    while ($i <= $N) {\n        $ans =\
    \ $ans.(oct($i - 1));\n        $i++;\n    }\n    return $ans;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI cannot understand the complexity of your method. Can you please\
    \ explain?\n<|/ c |>\n<| c |>\nI think you missed my question. :)\n<|/ c |>\n\
    <| a |>\n<code>\npublic string ConvertToBinaryString(int value)\n{\n    string\
    \ result = string.Empty;\n    int temp = 0;\n    while (value > 0)\n    {\n  \
    \      temp = value % 2;\n        result = temp + result;\n        value = value\
    \ / 2;\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,c#,c++ dscore=4\
    \ |>\n<| c |>\nThis code won't work if value is negative and you want it to be\
    \ positive. It should be result = temp + result + \"0\";\n<|/ c |>\n<| c |>\n\
    : You're right, I thought it would be clear enough. I'll fix the code.\n<|/ c\
    \ |>\n<| c |>\nI like this answer but could you please add the code for negative\
    \ numbers?\n<|/ c |>\n<| c |>\n: Well, since we know that `result` must be non-empty,\
    \ we know that `temp` must be non-zero. Therefore, `temp + result` must be non-negative.\
    \ Thus, if we want to handle negative numbers as well, then `result` must also\
    \ be non-negative. Then, we could add the extra character `'-'` to `result` and\
    \ then return it.\n<|/ c |>\n<| c |>\nI agree but what about the case: `result`\
    \ can be negative? `result += temp + '0'`?\n<|/ c |>\n<| a tags=algorithm,c#,c++\
    \ |>\nFor those who want to convert decimal number to binary using recursive algorithm,\
    \ here is my implementation in c#\n<code>\npublic static string decToBinary(int\
    \ num){\n    if (num == 0)\n        return \"0\";", "    my $base = 1;\n    my\
    \ $ret = \"\";", "    my $num = 0;\n    while ($N > 0) {\n        $num = $num\
    \ * 2 + $N % 10;\n        $N = int($N / 10);\n    }\n    return $num;\n}", " \
    \   if ($N < 0) {\n        return \"-\".solve(abs($N));\n    }\n    my($sum);\n\
    \    my $n = $N;\n    $n = ~s/-$//;\n    $sum = 0;\n    $n = 0 while $n % 2;\n\
    \    my $k = $n / 2;\n    while ($k > 0) {\n        $sum += $k * ($k - 1);\n \
    \       $k--;\n    }\n    if ($n == 0) {\n        return \"0\"; # 0 is always\
    \ even\n    }\n    if ($n < 0) {\n        $sum *= -1;\n    }\n    return \"$sum\"\
    ;\n}", "    my $sum = 0;\n    $sum = $N % 10;\n    $N = ($N - $sum) / 10;\n  \
    \  my $N2;\n    for($N2; $N2 <= 10000; $N2++){\n        $sum += $N2%2;\n     \
    \   $N2 = ($N2 - $sum)/2;\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=math,python,algorithm |>\n<code>\ndef f(n):\n  while n > 0:\n\
    \    rem = n % 10\n    n = (n // 10) % 10\n    ans = str(rem) + ans\n  return\
    \ ans", "    my @digits = split(//,$N);\n    my $sum = 0;\n    for my $d (@digits)\
    \ {\n        $sum += $d if $d >= 10;\n    }\n    $sum == 0 ? '0' : ($sum > 0 ?\
    \ '1' : '');\n}", '    return 0 if ($N < 0) or not($N in {0,1}) or not($N & 1);',
  "    if (! $N) {\n        return \"0\";\n    }", "    my $s = \"\";\n    my $l =\
    \ length($N);\n    for(0..$l-2){ # binary string with 1 at the most significant\
    \ bit and 0 at the least significant\n        my $v = $N % 2;\n        $s += $v\
    \ ? \"1\" : \"0\";\n        $N /= 2;\n    }\n    return $s;\n}\n</cell>\n<text>\n\
    Problem 3\nWrite a C program to find the sum of all numbers whose digits are less\
    \ than 10.", "    my $str = join(\"\",map { chr( ($N % 2) x (2 if $N % 2 ==1)\
    \ ) } 0 .. ($N-1));\n    return $str;\n}\n</code>\n<|/ a tags=math,algorithm,binary,math\
    \ |>\n<| c |>\nThat's a very nice solution. I think I've seen something similar\
    \ before, but I couldn't remember what it was called. It even seems to have a\
    \ name \"Eggdrop\" -- a fun fun fun game of some sort. I'm going to try and implement\
    \ this and see how it works out.\n<|/ c |>\n<| c |>\n: Thanks for posting your\
    \ solution! It was a fun challenge!\n<|/ c |>\n<| a |>\nThis is my solution to\
    \ this problem:\n<code>", "    my $ans = '0';\n    for (my $i = $N; $i > 0; $i--)\
    \ {\n        my $n = int ($N/$i);\n        $ans = $ans.$n;\n    }\n    $ans;\n\
    }\n</code>\n<|/ a tags=math,algorithm,python dscore=1 |>\n<| a tags=math,algorithm,python\
    \ |>\nThis problem can be solved by using modulo operation that returns the remainder\
    \ of the division of the two numbers.\n<code>\ndef solve(digit):\n    count =\
    \ 0\n    while(True):\n        count += 1\n        digit = digit % 10\n      \
    \  print(digit, end=' ')\n        if digit == 9:\n            print(\"9\", end='\
    \ ')\n            print(digit, end='')\n            break\n        if digit ==\
    \ 0 and count >= 9:\n            print(\"9\", end=' ')\n            print(digit,\
    \ end='')\n            break\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,algorithm,python\
    \ |>\nHere is a solution in javascript. I just wrote a recursive function.", " \
    \   my $s = \"\";\n    my $d = pop(@{$_[0]});\n    while ($N > 0) {\n        my\
    \ $mod = $N % 2;\n        $N = $N / 2;\n        $s = \"0\" . $d . $s if $mod !=\
    \ 1;\n        $d = $d ? \"$d\" : \"1\";\n    }\n    return $s;\n}", "    my $ans\
    \ = \"\";\n    while($N) {\n        $N -= 2**(log($N)/log(2));\n        $ans =\
    \ \"$ans\";\n    }\n    $ans;\n}", "    if ($N == 0) {\n        return \"0\";\n\
    \    }\n    my($remainder) = $N % 2;\n    my($N) = $N - $remainder;\n    my($N)\
    \ = $N / 2;\n    my($S) = '';\n    while ($N > 0) {\n        $S = $S + $N % 2;\n\
    \        $N = $N / 2;\n    }\n    return $S;\n}", "    my $total = 0;\n    foreach\
    \ my $digit (0..($N-1)) {\n        $total += (2**$digit) % 2;\n    }\n    return\
    \ sprintf('%b', $total);\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=math,algorithm,numbers,python,binary-data\
    \ |>\nIn Perl, this works:\n<code>", "    my $sum = 0;\n    my $sumString = \"\
    \";\n    while (0 <= $N) {\n        $sum = ($sum * 2) + $N % 10;\n        $N =\
    \ int($N / 10);\n    }\n    my $binString = \"\";\n    $binString .= $sum while\
    \ (0 <= $sum);\n    my $result = $sumString.$binString;\n    return $result;\n\
    }", "    return \"0\" if ($N < 10);\n    $N = sprintf(\"%u\", $N);\n    return\
    \ \"$N\" if ($N !~ /^\\d+$/);\n    return \"$N\" if ($N !~ /^\\d+$/);\n    $N\
    \ =~ s/^0*(\\d+)/$1/;\n    $N = 10 * ($N + 1);\n    $N /= 10;\n    return \"0\"\
    \ if ($N eq \"1\");\n    $N =~ s/^1(\\d+)/$1/;\n    $N = 10 * ($N + 1);\n    $N\
    \ /= 10;\n    return $N;\n}", "    return $N if $N < 1 || $N > 10000;\n    my\
    \ $binStr = \"1\";\n    my $remainder;\n    while ($N !== 0) {\n        $remainder\
    \ = $N % 2;\n        $binStr .= \"0\" . $remainder;\n        $N = int($N / 2);\n\
    \    }\n    return $binStr;\n}", "    my $sum = 0;\n    my $digits = $N;\n   \
    \ while(1) {\n        if ($digits == 0) {\n            chomp($sum = $sum + $digits);\n\
    \            last if $sum == 0;\n        }\n        my $digit = $digits % 2;\n\
    \        $digits = $digits >> 1;\n        $sum = $sum + $digit if $digit;\n  \
    \  }\n    return $sum;\n}", "    $N = int2str($N);\n    my $i = 0;\n    my $count\
    \ = 0;\n    my $res = \"\";\n    foreach my $ichar (split //, $N) {\n        $count++;\n\
    \        $i = $i + $ichar;\n        if ($i > 9) {\n            $res .= \"$i\"\
    ;\n            $i = 0;\n        }\n        elsif ($count == $N - 1) {\n      \
    \      $res .= \"$i\";\n            $i = 0;\n            $count = 0;\n       \
    \ }\n    }\n    if ($i == 0) {\n        $res .= \"$i\";\n    }\n    return $res;\n\
    }", "    if ($N == 0) return \"0\";\n    if ($N <= 1) return \"$N\";\n    my $binary\
    \ = \"\";\n    my $sum = 0;\n    my $i = 0;\n    my $one = 1;\n    do {\n    \
    \    $one = `echo \"$one\" | bc`;\n        my $digit = $one % 2;\n        $binary\
    \ = $binary . $digit;\n        $sum = $sum + ($digit * $N % 10);\n        $N =\
    \ ($N - $digit) / 10;\n        $i++;\n    } until ($i == $N);\n    return $binary;\n\
    }", "    return \"0\" x $N unless $N & 1;\n    my(@A) = ($N & 1).'0' x ($N / 2\
    \ & 1) . \"1\";\n    my $sum = 0;\n    for (0..$#A) {\n        my $d = $A[$_];\n\
    \        $sum += $d if $d =~ /1/;\n    }\n    return $sum;\n}", "    my(@result)\
    \ = (0,0);\n    my($bit, $sum);\n    foreach $bit (0..($N-1)) {\n        $sum\
    \ += $bit * 2;\n    }\n    my $result = \"0\";\n    my $i = 0;\n    foreach $bit(0..($N-1))\
    \ {\n        my $num = $sum % 10;\n        $sum += $num * 2;\n        $i ^= $num;\n\
    \        $result .= $bit ? \"1\" : \"0\";\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=perl |>\n<| c |>\nThis is an incomprehensible mess. Do you mean to\
    \ ask for help with your own solution? If so, why not post your code and ask for\
    \ help?\n<|/ c |>\n<| c |>\nThis solution is very incomprehensible indeed, I wish\
    \ I had a better solution.\n<|/ c |>\n<| c |>\nI wrote the Perl code above in\
    \ about two hours, I was too lazy to do it without testing it first (the code\
    \ above should be self explanatory) and it wasn't a good solution. I was trying\
    \ to do it before I asked the question here to find out if it was possible, so\
    \ I didn't know to post my own solution when I was done. I'm not going to post\
    \ it until I understand what the code does. Thanks for the comment.\n<|/ c |>\n\
    <| c |>\nI'm very sorry if I offended you. I'm just trying to understand it now.\
    \ Sorry for my stupidity. I had a similar problem and wrote a solution like this\
    \ and I was just curious if anyone has a better solution than this one.\n<|/ c\
    \ |>\n<| c |>\nYes, I agree that this is quite messy. Perl has a number of functions\
    \ for dealing with binary numbers, but it's far from obvious how to combine them\
    \ all together.\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", "   \
    \ my ($sum, $remainder, $num, $tmp, $carry);\n    $sum = 0;\n    $remainder =\
    \ 0;\n    $num = $N;\n    while ($num & 1) {\n        $remainder += 1;\n     \
    \   $num = $num / 2;\n    }\n    $num = $N;\n    while ($num) {\n        $tmp\
    \ = $num & 1;\n        $sum = $sum + ($tmp * pow(2, $remainder));\n        $remainder\
    \ = ($remainder % 2) + 1;\n        $num = $num / 2;\n    }\n    if ($remainder\
    \ != 0) {\n        $sum = $sum + pow(2, $remainder);\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYou might want to add the C code as an example\
    \ of how this can be done.\n<|/ c |>\n<| c |>\nI guess he already did but it's\
    \ only a first pass. The idea is to implement a solution that doesn't require\
    \ an explicit loop but instead uses bit manipulations and recursion.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's a recursive version that solves the problem in O(1) time\
    \ and uses O(logn) space. It prints out the answer as a hex string, since I don't\
    \ know how to get it to print out as binary numbers in the same place.\n<code>\n\
    def solve(n):\n    if n == 0:\n        return \"0\"\n    elif n < 10:\n      \
    \  return str(n)\n    else:\n        return solve(n / 16) + \"0\" + solve(n %\
    \ 16)", "    if ($N == 0){\n        return \"0\";\n    }", "    my $num = $N;\n\
    \    my $sum = 0;", "    if ($N == 0){\n        return \"0\";\n    }", "    my(@result)\
    \ = \"0\";\n    push(@result, \"1\") if $N < 10;\n    push(@result, \"0\") if\
    \ $N < 100 && $N > 9;\n    while(@result){\n        my $result = pop @result;\n\
    \        for(my $i = length($result) - 1; $i >= 0; $i -= 1){\n            my $num\
    \ = $result[$i];\n            $result[$i] = \"1\" if $num > \"0\";\n        }\n\
    \        if($result =~ /^0*/){\n            pop @result;\n        }else{\n   \
    \         push @result, $result;\n        }\n    }\n    return join \"\", @result;\n\
    }\n</code>\n<|/ a tags=integer,binary,math,perl,division |>\n<| c |>\nWhat does\
    \ this do? What does it do differently from what I already had?\n<|/ c |>\n<|\
    \ c |>\nYes, your solution produces a different result. I'm guessing that your\
    \ solution gives the correct answer because of the algorithm you used?\n<|/ c\
    \ |>\n<| c |>\nThe algorithm is `O(log(n))` which means it won't be faster than\
    \ `O(n)`, so this solution is faster than mine, and yeah, the result is different\
    \ because of the algorithm I used (my solution just use division to divide it\
    \ by 2, my solution uses the `O(n)` algorithm).\n<|/ c |>\n<| a |>\nYou can use\
    \ the following regex to match a binary number:\n<code>\n/^[01o]$/\n</code>\n\
    Then use the following loop to count the number of 1s:\n<code>\nmy $n = 12345;\n\
    my $num = \"\";\nwhile ($n > 0) {\n  $num .= $n =~ /^[01o]$/;\n  $n--;\n}\nprint\
    \ \"$num\\n\";\n</code>\n<|/ a tags=integer,binary,math,perl,division dscore=2\
    \ |>\n<| a |>\nYou can use the following function in perl for division by 2.\n\
    <code>", "    my ($num, $num_i, $max_num, $temp);\n    $max_num = $N;\n    my\
    \ $sum = 0;\n    foreach $num (0 .. $max_num) {\n        $num_i = int(log($num)\
    \ / log(2));\n        $num *= 2;\n        $temp = $num - int($num / 2);\n    \
    \    $sum += int($num / 2) == 0 ? '0' : int($num / 2);\n    }\n    return \"0b$sum\"\
    ;\n}\n</code>\n<|/ a tags=math,string,algorithm,ruby,math |>\n<| c |>\nI did this\
    \ in Ruby. I did it in O(n) time, and it took less than 1 millisecond. Ruby is\
    \ great.\n<|/ c |>\n<| c |>\nThanks for your answer. I tried your code in Jruby\
    \ and it works fine, however, when I tested it on Ruby, it gives an error. Could\
    \ you please take a look here: http://pastie.org/private/ykz7jznkmy2vj7gqyj1w8j\n\
    <|/ c |>\n<| c |>\nI forgot to change the $i to $num in the while loop. Try it\
    \ now.\n<|/ c |>\n<| c |>\nNow it works fine. Thanks a lot. I had tried this in\
    \ Ruby, but it was taking too long. I tried in Jruby and it works fine :)\n<|/\
    \ c |>\n<| c |>\nNo problem! Glad I could help.\n<|/ c |>\n<| a tags=math,string,algorithm,ruby,math\
    \ dscore=2 |>\nAs the number of digits grows exponentially, binary search becomes\
    \ unusable (for even a small number of digits).\nSo I propose a better algorithm\
    \ (I used Python):\n<code>\ndef digits(n):\n    return bin(n)[2:].count('1')",
  "    my $sum = 0;\n    my $s = \"\";\n    while($N > 0) {\n        $s = $s[0] *\
    \ $N + $s[1];\n        $N -= $s[0] if $s[0] != 0;\n        $sum += $s[1] if $s[1]\
    \ != 0;\n        $s = '';\n    }\n    return $sum % 2 != 0 ? '0' : ''. $sum;\n\
    }", "    $N |= 0;\n    my $x = 0;\n    my $y = 1;\n    my $binary = \"\";\n  \
    \  while ($N) {\n        $x = ($x << 1) | $y; \n        $N -= $x % 10;\n     \
    \   $binary .= $x % 2;\n        $y = $x / 10;\n    }\n    $binary;\n}", "    my\
    \ $sum = 0;\n    my $tmp;\n    my $n = length($N);\n    my $cnt;", "    my $n\
    \ = $N;\n    my $sum = 0;\n    $n -= $sum;\n    my $binary = \"\";\n    while\
    \ ($n > 0) {\n        $sum = $sum + $n % 2;\n        $n = $n / 2;\n    }\n   \
    \ $sum = $sum + $n;\n    $binary = \"0\" x $sum;\n    if ($sum > 9) {\n      \
    \  $binary = reverse $binary;\n    }\n    return $binary;\n}", "    my @sol;\n\
    \    if ($N <= 0) {\n        return @sol;\n    }\n    # write code here\n}\n</cell>\n\
    <cell>\n%%writefile ./Solution.pm", "    my $s = '';\n    if ( $N == 0 ) {\n \
    \       return '0'\n    }\n    my $x = $N % 2;\n    $N = int ($N / 2);\n    my\
    \ $k = 0;\n    while ($N > 0) {\n        $k++;\n        $N *= 2;\n        $s +=\
    \ \"1\" if ($x ^ $k);\n    }\n    $k--;\n    $k == 0 or $s += \"0\"; \n    return\
    \ $s;\n}", "    if ($N < 0){\n        die \"Negative N given\";\n    }\n    if\
    \ ($N == 0){\n        return \"0\";\n    }\n    if ($N <= 10000){\n        return\
    \ sprintf('%d', int(log($N)/log(10)));\n    }\n    my($i, $j) = ('0', '1');\n\
    \    $bin = \"0\";\n    while ($N > 0){\n        if ($N % 2 == 1){\n         \
    \   $bin = $bin.$j;\n        }\n        $N -= $j;\n        $j = $i.$j;\n     \
    \   $i = $i.$j;\n    }\n    return $bin;\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=algorithm,math,big-o,perl |>\nHere is a solution in Perl which does not\
    \ involve logarithms and powers.\n<code>", "    return \"0\" + ($N & 1 ? \"1\"\
    \ : \"0\");\n}\n</code>\nNow we can take it back to the question of calculating\
    \ the sum of its digits in binary of positive integers. The algorithm is as follows:\n\
    <code>", "    return $N =~ /(..?)(..?)(..?)(..?)/ ? sprintf(\"%0*b%0*b%0*b%0*b%0*b\"\
    ,\n                                     length($1), $2, $3, $4, $5) : '0';\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nPlease can you explain the above solution?\n\
    <|/ c |>\n<| c |>\nIt was my first answer in Stack Overflow, so my first thought\
    \ was \"Why do you need this? What problem does it solve?\". And then I tried\
    \ to solve it: it was a small challenge to solve the problem in a short amount\
    \ of time, and it seemed like a fun little problem to solve :)\n<|/ c |>\n<| c\
    \ |>\nThanks for the solution, I've never used perl before, I just needed this\
    \ one. :) I wonder if there's any way to make it more efficient, maybe using regex?\n\
    <|/ c |>\n<| c |>\nSorry, but I don't know the answer to that. Perl regexes are\
    \ quite powerful, but they are not nearly as fast as native regexes in many programming\
    \ languages (see http://stackoverflow.com/questions/tagged/perl).\n<|/ c |>\n\
    <| c |>\n: I added a faster solution to the question above.\n<|/ c |>\n<| a dscore=2\
    \ tags=language-agnostic,algorithm |>\nA little bit of Ruby\n<code>", "    my\
    \ $ret = \"\";\n    \n    for (my $i = 0; $i < $N; $i++) {\n        $ret .= \"\
    $N % 2 \";\n        $N = $N div 2;\n    }\n    \n    return $ret;\n}\n</cell>\n\
    <cell>\n!./quicksort.pl $N\n</cell>\n<text>\nGiven a list of positive integers\
    \ A1, A2, ... , An where each element Ai is a positive integer and each Ai differs\
    \ from Aj, where j \u2260 i. What is the least number of swaps needed to sort\
    \ the list?", '    my ($sum, $carry);', "    my $sum = 0;\n    my $max = (1 <<\
    \ ($N - 1));\n    $sum = 0;\n    while ($N) {\n        my $s = $N & $max;\n  \
    \      $sum = $sum + ($s & 1) ? 1 : 0;\n        $N >>= 1;\n    }\n    return $sum;\n\
    }", "    my($sum);\n    my($result);\n    my($remainder);\n    my($i);", "   \
    \ return $N ? \"0\" . solve(oct($N)) . \"1\" : \"\";\n}", "    $N = sprintf(\"\
    %.0f\", $N);\n    my $num = \"1\";\n    for my $i (0..($N - 1)) {\n        $num\
    \ = $num.($N =~ m/^([0-9]+)(\\d)$/);\n        $num = $num.\"0\". $1;\n    }\n\
    \    return $num;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nOh, thank you. I never\
    \ thought of it that way. Good thinking.\n<|/ c |>\n<| a |>\nI have implemented\
    \ this in JavaScript for fun.\n<code>\nvar n = parseInt(prompt('Enter a number\
    \ between 0 and 1000000', '0'));", "    return $N == 0 ? \"0\" : $N == 1 ? \"\
    1\" : solve(div($N, 2)) + solve(mod($N, 2));\n}", "    \n    # base 10 to base\
    \ 2\n    my $result = \"\";\n    my $remain = $N;\n    while($remain > 0) {\n\
    \        $result = $result . sprintf(\"%b\", $remain);\n        $remain = $remain\
    \ - $remain%2;\n    }\n    \n    return $result;\n}", "    return $N if ($N <\
    \ 0);\n    my(@bit);\n    my $n = $N;\n    for(my $i = $n; $i > 0; $i /= 10) {\n\
    \        push(@bit, sprintf(\"%o\", $i));\n    }\n    for(my $i = $n; $i > 0;\
    \ $i /= 2) {\n        my $temp;\n        for($i = 0; $i < $n; $i++) {\n      \
    \      $temp = ($temp << 1) + ($bit[$i] & 1);\n        }\n        push(@bit, $temp);\n\
    \    }\n    my $result = \"\";\n    for(my $i = 0; $i < @bit; $i++) {\n      \
    \  $result .= chr(oct($bit[$i]));\n    }\n    return $result;\n}", "    my $n\
    \ = 0;\n    my $s = '';\n    while($N > 0) {\n        $s = $s . ($N % 2) ? '1'\
    \ : '0';\n        $N = int($N/2);\n    }\n    return $s;\n}", "    my @result\
    \ = ();\n    my $carry = 0;\n    my $Ndigit = sprintf \"%x\", $N;\n    foreach\
    \ my $digit ( reverse str_split($Ndigit) ) {\n        $carry = 0;\n        if\
    \ ( length($digit) > 0 ) {\n            foreach my $bit ( str_split($digit) )\
    \ {\n                $carry = $carry + 2 ** $bit - 1;\n            }\n       \
    \ }\n        push @result, \"1\" * ( $carry == 1 ? \"0\" : \"1\" ) + ( $carry\
    \ > 0 ? \"1\" : \"0\" );\n    }\n    my $total = join \"\", @result;\n    my $total_reversed\
    \ = reverse $total;\n    $total_reversed =~ tr/1//d;\n    return $total_reversed;\n\
    }", "    my $sum = 0;\n    my $bin = sprintf(\"%b%b%b%b%b\", $N);", '    my $digit
    = "";', "    my($S,$sum,$carry);\n    if ($N < 10) {\n        $S = \"$N\";\n \
    \   } elsif ($N < 100) {\n        $sum = $N * 2;\n        $carry = 0;\n    } elsif\
    \ ($N < 1000) {\n        $sum = $N * 2 + $N / 10;\n        $carry = ($N % 10)\
    \ * 1;\n    } else {\n        $sum = $N * 2 + ($N - 1000) / 100;\n        $carry\
    \ = ($N - 1000) % 10 * 1;\n    }\n    if ($carry == 1) {\n        $sum = $sum\
    \ + 101;\n    }\n    if ($sum > 9) {\n        $S = \"$sum\";\n    } else {\n \
    \       $S = sprintf \"%s%3d\", $sum, $carry;\n    }\n    return $S;\n}", "  \
    \  return (\"0\" x $N) if ($N <= 1);\n    my $sum = 0;\n    for (my $i = 0; $i\
    \ < $N; $i++) {\n        $sum += $N % 2;\n        $N = int ($N / 2);\n    }\n\
    \    return (\"0\" x $sum) . $N;\n}", "    my($S);\n    $S = $N;\n    \n    while\
    \ ($N != 0) {\n        my $t = $N % 2;\n        my $d = $N / 2;\n        \n  \
    \      $S .= ($t ? \"1\" : \"0\") . \"0\";\n        $N /= 2;\n    }\n    return\
    \ $S;\n}", "    return $N eq \"1\" ? \"1\" : ($N eq \"0\" and $N gt 1000 and $N\
    \ le 10000 ? \"0\" : $N);\n}", '    $N *= 2;', "    my $res = \"0\";\n    while($N\
    \ > 0) {\n        $res = $res x ($N % 2);\n        $N /= 2;\n    }\n    return\
    \ $res;\n}", "    my($sum) = \"\";\n    for(my $i = 0; $i < $N; $i++) {\n    \
    \    $sum += \"0\" if ($i % 2);\n        $sum += \"1\" if ($N - $i <= $i);\n \
    \   }\n    return $sum;\n}", '    my $result = "";', "    return \"\" if $N <=\
    \ 0;\n    $N = abs($N);\n    my($sum, $remain, $digit);\n    $sum = 0;\n    $remain\
    \ = $N;\n    $digit = 0;\n    while (--$remain != 0) {\n        $sum = ($sum <<\
    \ 1) + $remain;\n        $digit++;\n    }\n    return sprintf(\"%b\", $sum);\n\
    }", "    my($sum) = 0;\n    $sum += $N & 1;\n    $N = $N >> 1;\n    until(abs($sum)\
    \ > 10) {\n        $sum += $N & 1;\n        $N = $N >> 1;\n    }\n    return $sum;\n\
    }", '    my $ret = "0"; # return value', "    $N = abs($N);\n    my $sum = 0;\n\
    \    $N *= 2;\n    while ($N > 0) {\n        $sum += $N & 1;\n        $N = $N\
    \ >> 1;\n    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat is the role\
    \ of the `&` in the expression: `$N & 1`?\n<|/ c |>\n<| a dscore=1 tags=perl,algorithm\
    \ |>\nIt should be noted that all of these answers are incorrect. For example:\n\
    <code>\nprint solve 5000;\n</code>\nwill result in 1 and not 00110 because the\
    \ & 1 will always result in 0. \nIf you need leading zeros, then the correct solution\
    \ is to do the following:\n<code>\nprint format \"%0*d\", length($sum), $sum;\n\
    </code>\nIn case you want to display the leading zero for positive numbers:\n\
    <code>\nprint format \"%0*d\", length($sum), $sum if $sum >= 0;\n</code>\n<|/\
    \ a |>\n<| a tags=perl,algorithm |>\n<code>\nuse strict;\nuse warnings;", "  \
    \  my $sum = 0;\n    while($N > 0) {\n        my $t = $N % 2;\n        $sum +=\
    \ $t;\n        $N /= 2;\n    }\n    my $binary = sprintf(\"%b\", $sum);\n    return\
    \ $binary;\n}", "    my $s = '';\n    for (my $i = 1; $i <= $N; $i++) {\n    \
    \    $s .= $i.'1' if ($i & $N);\n    }\n    return $s;\n}", "    return $N //\
    \ 10 + (($N mod 10) > 0) ? \"1\" : \"0\";\n}", "    my($bit);\n    my($str);\n\
    \    # Find the first 1 in the binary representation of a number\n    for(my $i\
    \ = $N; $i >0; $i >>= 1) {\n        if($i & 1) {\n            $bit++;\n      \
    \  }\n    }\n    $str = $bit;\n    while($bit > 0) {\n        $bit--;\n      \
    \  $str = $str.\"1\";\n    }\n    return $str;\n}", "    my $ans = 0;\n    my\
    \ $N = int $N;\n    while ($N > 0) {\n        my $t = $N % 2;\n        my $r =\
    \ $ans*10;\n        $ans += $t;\n        $N = int($N/2);\n        $r += $t;\n\
    \    }\n    return sprintf \"%b\",$ans;\n}\n</code>\n<|/ a tags=ruby,optimization\
    \ |>\n<| a tags=ruby,optimization |>\nYet another one:\n<code>\ndef solve(n)\n\
    \  return n if n == 0\n  n1 = solve(n/10).to_i\n  n2 = solve((n%10).to_i).to_s\
    \ + n1 \n  n2\nend", "    my $s = \"\";\n    my $n = $N;", "    my $s = '';\n\
    \    my $t = $N;\n    my $a = 97;\n    while (0 != $t) { $s = chr($a--) . $s;\
    \ $t = ($t / 10); };\n    return $s;\n}\n</code>\n<|/ a dscore=4 tags=math,string,algorithm,binary\
    \ |>\n<| c |>\n`strlen(\"1\") == 0`\n<|/ c |>\n<| a |>\nThe first answer will\
    \ fail with certain inputs, for example 010. the correct answer would be 0111.\
    \ \n<code>\n$bin = sprintf(\"%b\",$n);\n$bin = lpad($bin, length($bin), \"0\"\
    );\n$bin = substr($bin,0,length($bin)-1);\n</code>\n<|/ a dscore=3 tags=math,string,algorithm,binary\
    \ |>\n<| a |>\nPython 3 version:\n<code>\ndef binToBinary(x):\n    binStr = str(bin(x))[2:]\n\
    \    rem = len(binStr) % 8\n    remStr = str(bin(int(rem)))[2:]\n    binStr =\
    \ binStr.zfill(rem)+remStr\n    return binStr", "    my ($result, $i) = (0, 0);\n\
    \    do {\n        $i = $N & 1;\n        $result = \"1\" if ($result eq \"\");\n\
    \        $result .= $i;\n        $N = $N >> 1;\n    } while ($N);\n    return\
    \ $result;\n}", "    $N = 10 ** $N;\n    $N = $N % 11;", "    return $N ^ $N >>\
    \ 1 . '0' unless $N & 1;\n    return $N ^ $N >> 1 . '1' while $N > 1;\n}\n</code>\n\
    <|/ a tags=algorithm,sum,perl |>\n<| c |>\nThank you, I've corrected my answer.\n\
    <|/ c |>\n<| c |>\nThank you, I've corrected my answer.\n<|/ c |>\n<| a tags=algorithm,sum,perl\
    \ dscore=1 |>\nHere is the solution in python\n<code>\ndef sum_of_digits(n):\n\
    \    if n < 0:\n        return sum_of_digits(-n)\n    power = 1\n    digit = 0\n\
    \    while n == 0:\n        n, remainder = divmod(n, 10)\n        digit += (remainder\
    \ * power)\n        power *= 10\n    return digit", "    my $ret = \"\";\n   \
    \ while ($N > 0) {\n        my $res = $N % 10;\n        $ret .= $res*pow(2,length($ret));\n\
    \        $N = int($N/10);\n    }\n    return $ret;\n}", '    my $s = $N;', " \
    \   my(@result);\n    my($total, $digit, $index);\n    if ($N > 0 && $N < 10)\
    \ {\n        push(@result, \"0\");\n    } elsif ($N > 9) {\n        push(@result,\
    \ \"1\");\n    }", "    my($remainder, $sum, $digit);\n    my $result = \"\";\n\
    \    my $binary = \"\";\n    my $flag = 1;\n    while($N > 0) {\n        $remainder\
    \ = $N % 2;\n        $sum = $N / 2;\n        $digit = $sum % 2;\n        $N =\
    \ $sum / 2;\n        $result .= \"1\" if $flag;\n        $result .= $digit if\
    \ $remainder == 0;\n        $flag = $flag * -1;\n        $binary .= $digit;\n\
    \    }\n    return $result . $binary;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nfunction get_total(){\n    $n=$_[0];\n    $arr=split(\"\",$n);\n\
    \    $total=0;\n    for($i=0;$i<strlen($n);$i++){\n        $total+=$arr[$i];\n\
    \    }\n    return $total;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ *how* and/or *why* it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction get_total($num){\n  $arr=str_split($num);\n\
    \  $total=0;\n  for($i=0;$i<strlen($arr);$i++){\n    $total+=$arr[$i];\n  }\n\
    \  return $total;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\n<code>\n<?php", "    my $digits = 0;\n    my $sum = 0;", "    if ($N ==\
    \ 0){\n        return \"0\";\n    }\n    $N = int ($N);\n    $N *= 8;\n    my\
    \ $res = \"\";\n    my $i = 0;\n    while($N){\n        if ($i % 2 == 1){\n  \
    \          $res .= \"$N\";\n        } else {\n            $N -= $N / 2;\n    \
    \    }\n        $i++;\n    }\n    $res = \"0\" . $res;\n    return $res;\n}",
  "    if($N == 0) {\n        return \"0\";\n    } elsif ($N < 0) {\n        return\
    \ \"\";\n    } elsif ($N > 9999) {\n        return \"\";\n    } elsif ($N == 1000)\
    \ {\n        return \"1\";\n    } elsif ($N < 1000) {\n        return \"\";\n\
    \    } elsif ($N % 2 == 0) {\n        $N = ($N - 1) / 2;\n        return solve(@N);\n\
    \    }\n    $N = ($N - 1) / 2;\n    return solve(@N);\n}", "    my $ret = $N;\n\
    \    my $digits = 0;\n    $ret =~ s/^0?(\\d+)$/$1/;\n    $ret =~ s/^0?(\\d+)$/$1/;\n\
    \    while ($ret =~ /(\\d)/g) {\n        my $num = length($1);\n        $digits\
    \ += $num;\n        $ret =~ s/\\/(\\d)//;\n    }\n    my $ret = reverse $ret;\n\
    \    $ret =~ s/\\//-/g;\n    $ret =~ s/-$//;\n    $ret =~ s/-$//;\n    $ret .=\
    \ \"0\"x$digits;\n    return $ret;\n}", "    my $answer;\n    my $temp = &to_bin($N);\n\
    \    $answer = '';\n    while ($temp) {\n        $answer = \"$answer$temp\" if\
    \ ($answer ne '');\n        $temp = &to_bin(substr($temp, -1));\n    }\n    return\
    \ $answer;\n}", "    return \"\" unless $N =~ /^\\+?\\d+$/;\n    return \"$N\"\
    \ if ($N == 0);\n    return \"$N\" if ($N <= 1);\n    return \"$N\" if ($N <=\
    \ 10);\n    $N = oct($N);\n    return \"$N\" if ($N <= 1024);", "    return undef\
    \ unless $N > 0;\n    my @digits = map { sprintf(\"%b\", $_) } ($N - 1) .. $N;\n\
    \    return join \"\", @digits;\n}", "    $N /= 2;\n    $N = int(($N / 10));\n\
    \    $N *= 2;\n    $N /= 10;\n    $N /= 8;\n    $N *= 8;\n    $N *= 4;\n    $N\
    \ *= 2;\n    $N /= 2;\n    return sprintf(\"%db\", $N);\n}", "    my $string =\
    \ \"\";\n    my $base = 1;\n    my $last = 1;\n    my $limit = $N >> 1;\n    my\
    \ $remainder = 0;\n    while($limit > 0) {\n        $remainder = $limit % 2;\n\
    \        $limit = ($limit >> 1) & 0x1;\n        $string .= $last;\n        $base\
    \ *= $last;\n        $string .= $remainder;\n        $last = $base >> 1;\n   \
    \ }\n    $string .= $last;\n    return $string;\n}", "    $N < 10 && $N > 0\n\
    \      or die(\"No binary number has more than ten digits. \");\n    my $string\
    \ = \"0\";\n    while ($N > 0) {\n        my $remainder = $N % 2;\n        $N\
    \ = $N/2;\n        $string .= $remainder;\n    }\n    return $string;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nHere's a recursive solution, that doesn't use the\
    \ modulo operator % and uses only recursion:\n<code>", "    $N = sprintf(\"%04d\"\
    , $N);\n    $N =~ s/^0//;\n    $N =~ s/^1/1;\n    $N =~ s/^0/1;\n    $N = sprintf(\"\
    %010d\", $N);\n    return $N;\n}", "    my $ret = \"\";\n    for($N){\n      \
    \  $ret .= \"%$b\";\n    }\n    return $ret;\n}", '    my $rem = $N;', "    my\
    \ $ans = '';\n    my $num = 1;\n    my $count = $N;\n    my $i = 1;\n    while\
    \ ($count) {\n        $ans .= $num % 2;\n        $num /= 2;\n        $count--;\n\
    \    }\n    chop $ans;\n    return $ans;\n}", "    my $digits = $N >> 9;\n   \
    \ my($remainder) = &div($N);\n    my $result = \"0\";", "    my @digits;\n   \
    \ my $remainder = 0;", "    if($N eq 0){\n        return 0;\n    }\n    if($N\
    \ eq 1){\n        return \"0\";\n    }\n    if($N eq 2){\n        return \"1\"\
    ;\n    }\n    if($N eq 4){\n        return \"10\";\n    }\n    if($N eq 8){\n\
    \        return \"11\";\n    }\n    if($N eq 16){\n        return \"100\";\n \
    \   }\n    if($N eq 32){\n        return \"101\";\n    }\n    if($N eq 64){\n\
    \        return \"110\";\n    }\n    if($N eq 128){\n        return \"111\";\n\
    \    }\n    my $ret = \"\";\n    my $tmp = \"1\";\n    for(my $i = 1; $i le $N;\
    \ $i++){\n        $ret .= $tmp;\n        $tmp = \"0\";\n        for(my $j = 0;\
    \ $j le length($ret)/2; $j++){\n            if($ret[$j]  eq $ret[$j+length($ret)/2]){\n\
    \                push (@tmp, $ret[$j]);\n                push (@tmp, $ret[$j+length($ret)/2]);\n\
    \                $tmp = \"1\";\n                next;\n            }\n       \
    \ }\n    }\n    return $ret;\n}\n</code>\n<|/ a tags=string,algorithm,binary,perl,regex\
    \ |>\n<| c |>\nIt seems you are using `push` in the inner loop for something that\
    \ is unnecessary.\n<|/ c |>\n<| c |>\nAs an aside, the code in your question doesn't\
    \ produce the same output as your answer. [This code does](http://codepad.org/3k7V3VUH).\n\
    <|/ c |>\n<| c |>\n- I don't think so. I tested it on codepad.org and it does\
    \ produce the same output. Perhaps you should test on your machine?\n<|/ c |>\n\
    <| c |>\nNo, it doesn't. It's even worse. [This output](http://codepad.org/3k7V3VUH)\
    \ shows the same numbers as your answer. Notice that `solve` doesn't return `110`.\n\
    <|/ c |>\n<| c |>\n- I see your point. I was looking at the wrong test. Fixed\
    \ it now.\n<|/ c |>\n<| a |>\nJust because I love Perl, here's an implementation\
    \ in Python:\n<code>\ndef solve(N):\n    digits = '0' * (N % 2)\n    binary =\
    \ bin(N)[2:]\n    binary = '0' * (len(binary) - 1) + '1' * (len(binary", "   \
    \ my(@ans);\n    \n    # Sum up the digits of each binary number\n    my $s =\
    \ 0;\n    my $bit = 0;\n    for my $i (0 .. $N) {\n        $s += $i & 1;\n   \
    \     $bit <<= 1;\n        $bit += ($i >> 1) & 1;\n    }\n    \n    if ($s ==\
    \ 0) {\n        $ans[$N] = '0';\n    }\n    else {\n        $ans[$N] = $s;\n \
    \   }\n    \n    return @ans;\n}\n</cell>\n<text>\nSolution", "    my($result,$remainder);\n\
    \    $result = \"\";\n    while ($N != 0) {\n        $remainder = $N % 2;\n  \
    \      $result = $remainder * $result + $remainder;\n        $N = div($N,2);\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=algorithm,math,binary,python\
    \ |>\n<| a |>\nHere is a version using mathematical identities.  You have to make\
    \ sure that the integer n is positive:\n<code>\ndef binarystr(n):\n    return\
    \ format(int(math.ceil(n / 2)), 'b')\n</code>\n<|/ a tags=algorithm,math,binary,python\
    \ dscore=3 |>\n<| c |>\nI think this is overly complicated and unpythonic.  It's\
    \ not a useful solution to someone trying to understand recursion.\n<|/ c |>\n\
    <| c |>\nThis is a useful solution if you want to convert a number to binary without\
    \ using the string conversion abilities of Python. For example, in C#, you have\
    \ [Convert.ToString(number, 2)](https://docs.microsoft.com/en-us/dotnet/api/system.convert.tostring)\
    \ which outputs \"1010\".\n<|/ c |>\n<| c |>\nThe Python `str()` method accepts\
    \ a `base` argument to control the number of digits after the decimal point: `str([0.1],'b')`\
    \ outputs `'0.100'`.\n<|/ c |>\n<| a tags=algorithm,math,binary,python |>\n<code>\n\
    def binary(n):\n    digits = [0, 1]\n    for i in range(2, n//2 + 1):\n      \
    \  digits.append(digits[i-1] * 2)\n    return digits[::-1]\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding *how* and/or *why* it solves the problem would improve the answer's\
    \ long-term value.\n<|/ c |>\n<| c |>\nThis is the most efficient solution I have\
    \ seen, and it also works in O(1) time. No need to loop through all the digits.\n\
    <|/ c |>\n<| c |>\nThank you for your comment, now I understand where I went wrong.\n\
    <|/ c |>\n<| c |>\nCould you please add some explanation to the code?\n<|/ c |>\n\
    <| a dscore=3 |>\nUsing math.log and math.hypot:\n<code>\nfrom math import log2\n\
    def bits(n):\n    return bin(int(log2(n)), 2)\n</code>\n<|/ a tags=algorithm,math,binary,python\
    \ |>\n<| c |>\nThis is definitely the most ", "    if ($N == 0) {\n        return\
    \ \"0\";\n    }\n    my @str = split(//, sprintf('%010d', $N));\n    my $res =\
    \ \"\";\n    my $sum = 0;\n    my $size = $#str + 1;\n    for (my $i=0; $i <=\
    \ $size; $i++) {\n        $sum += $str[$i] % 2;\n        $res .= $str[$i] ? \"\
    1\" : \"0\";\n    }\n    return \"$res$sum\";\n}", "    my $S;\n    \n    while($N\
    \ > 0) {\n        $S = $S . oct($N & 011);\n        $N >>= 1;\n    }\n    return\
    \ $S;\n}\n</cell>\n<cell>\nsolve(1000)\n</cell>\n<cell>\nsolve(101)\n</cell>\n\
    <cell>\nsolve(150)\n</cell>\n<cell>\nsolve(147)\n</cell>\n<cell>\nsolve(177)\n\
    </cell>\n<cell>\nsolve(100)\n</cell>\n<text>\nB. Baby names", "    return 1 while\
    \ $N > 0;\n    my($N) = @_;\n    return 0 while $N < 0;\n    my($sum, $bit);\n\
    \    my($N) = @_;\n    while ($N > 0) {\n        $sum = 0;\n        $bit = 1;\n\
    \        while ($N > 0) {\n            $sum += $bit * $N % 10;\n            $N\
    \ = ($N / 10) - 1;\n            $bit *= 2;\n        }\n        push, $sum;\n \
    \   }\n    my $str = $_[0]->[0];\n    foreach (@reverse) { $str .= $_ . '' }\n\
    \    return $str;\n}", "    my @digits = split(//,$N);\n    $N = join(\"\",@digits);\n\
    \    return $N;\n}", "    my(@bs);\n    my(@res);\n    for($N){\n        if($N=~m/[1-9][0-9]*\\\
    K/){\n            push(@bs,$&);\n        }\n    }\n    my($N) = pop(@bs);\n  \
    \  while($N=~m/0*[1-9][0-9]*\\K/){\n        push(@bs,$&);\n    }\n    my($N) =\
    \ pop(@bs);\n    for($N){\n        if($N=~m/[1-9][0-9]*\\K/){\n            push(@bs,$&);\n\
    \        }\n    }\n    my($N) = pop(@bs);\n    for($N){\n        if($N=~m/0*[1-9][0-9]*\\\
    K/){\n            push(@bs,$&);\n        }\n    }\n    for($N){\n        if($N=~m/[1-9][0-9]*\\\
    K/){\n            push(@bs,$&);\n        }\n    }\n    for($N){\n        if($N=~m/0*[1-9][0-9]*\\\
    K/){\n            push(@bs,$&);\n        }\n    }\n    my $i = 0;\n    for(@bs){\n\
    \        $res[$i] = $i;\n        $i++;\n    }\n    $res = join('',@res);\n   \
    \ chomp $res;\n    return $res;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,perl\
    \ |>\n<| a dscore=1 |>\nPerl has a pretty neat function for this:\n<code>\nmy\
    \ $str = sprintf \"%b\", $number;\n</code>\n<|/ a tags=algorithm,perl |>\n<| a\
    \ dscore=0 tags=algorithm,perl |>\nI have written a Perl program to solve this\
    \ question, below is the program:\n<code>", '    $N *= 2;', "    my @Nb = split(//,\
    \ $N);\n    my $i = 0;\n    my $result = \"\";\n    foreach my $Nb (@Nb) {\n \
    \       # use $i to print binary digits.\n        $result += $Nb if ($i % 2 ==\
    \ 0);\n        $i += 1;\n    }\n    return $result;\n}", "    return $N // 2 if\
    \ $N & 1;\n    $N /= 2;\n    return $N + solve(2 * $N) if $N & 1;\n    my $m =\
    \ solve($N >> 1);\n    $m += $N & 1 ? $N >> 1 : solve($N >> 1);\n    return $m\
    \ if $N & 1;\n    return $m . $N >> 1;\n}", "    return \"0\" unless $N;\n   \
    \ my($N);", "    my @num = ();\n    for ($N) { push(@num, \"0\"); }\n    return\
    \ join('', @num);\n}\n</code>\n<|/ a tags=string,algorithm |>\n<| a tags=string,algorithm\
    \ |>\nMy solution, based on KennyTM's solution, using bitmasks and recursion:\n\
    <code>\nprivate String binaryStringWithMaxLength(int binaryStringLength) {\n \
    \   if (binaryStringLength > 2) {\n        int maxLength = binaryStringLength\
    \ * 2;\n        char nextBitMask = Character.toChars(65);\n        char bitMask\
    \ = Character.toChars((Character.MAX_VALUE * 2) + 1);\n        String result =\
    \ \"\";\n        for (char character : bitMask.toCharArray()) {\n            String\
    \ currentResult = binaryStringWithMaxLength(maxLength - 1);\n            if (Character.isDigit(character))\
    \ {\n                currentResult += character;\n            } else {\n     \
    \           currentResult += currentResult + character;\n            }\n     \
    \       if (currentResult.length() > maxLength) {\n                result = currentResult;\n\
    \                maxLength = result.length();\n            }\n            if (currentResult.equals(nextBitMask))\
    \ {\n                nextBitMask += Character.toChars((Character.MAX_VALUE * 2)\
    \ + 2);\n            }\n        }\n        return result;\n    }\n    return \"\
    \";\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=string,algorithm |>\nA\
    \ recursive method without using any string\n<code>\npublic String getBinaryString(int\
    \ n) {\n    if (n == 0) return \"\";\n    String s = \"\";\n    while (n > 0){\n\
    \        s += (n % 2 == 0 ? \"1\" : \"0\");\n        n = n / 2;\n    }\n    return\
    \ s;\n}\n</code>\n<|/ a |>\n<| a tags=string,algorithm |>\n<code>\npublic String\
    \ convertToBinary(int n) {\n    String s = \"\";\n    while (n > 0) {\n      \
    \  s = (n%2 == 0 ? \"1\" : \"0\") + s;\n        n = n/2;\n    }\n    return s;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,algorithm |>\nI got it working\
    \ like this:\n<code>\npublic String intToBin(int x) {\n    String s = \"\";",
  "    my $ret = \"1\";\n    my @vals = split/0/, $ret;\n    for (@vals) {\n     \
    \   my $val = $_ % 2;\n        $ret = \"0\" . $ret if ($val == 0);\n        $ret\
    \ .= \"1\" if ($val == 1);\n    }\n    return $ret;\n}", "    return \"\" if $N\
    \ < 0;\n    return $N < 10 ? \"0\" + $N : $N;\n}", "    die \"N is out of range\"\
    \ unless $N =~ /^\\+?\\d+$/;\n    $N //= 10;\n    $N *= 2;\n    return join(\"\
    \", map{$N%2 == 0 ? '0' : '1'} (map{$_ % $N} (reverse (map{$_%$N+1} (1..$N//$N)))));\n\
    }", "    my $remainder = 0;\n    my $result = \"\";\n    while($N) {\n       \
    \ $result .= $remainder * \"01\"\n            if $remainder > 9;\n        $remainder\
    \ = $N % 10;\n        $N /= 10;\n    }\n    return $result;\n}", "    my $result\
    \ = \"\";\n    while (int($N) != 0) {\n        $N = int($N/2);\n        $result\
    \ .= ($N == 1) ? \"1\" : \"0\";\n    }\n    return $result;\n}", "    my $remainder;\n\
    \    if ($N < 10000) {\n        $remainder = $N % 2;\n        $N /= 2;\n    }\
    \ else {\n        $remainder = 0;\n        $N = $N / 10;\n    }\n    my $total\
    \ = 0;\n    while ($remainder > 0) {\n        $total += $remainder;\n        $remainder\
    \ = int(($N % 2) * 2);\n        $N = int($N / 2);\n    }\n    return sprintf(\"\
    %b\", $total);\n}", "    return $N eq 0 ? \"0\" : &solve($N/2) . $N & 1 ? \"1\"\
    \ : \"0\";\n}", "    $N &= 0x7fffffff;\n    return $N <= 0 ? \"0\" : $N <= 100\
    \ ? \"1\" : $N <= 1000 ? \"10\" : $N <= 10000 ?\n           sprintf('%03d', $N\
    \ % 1000) : sprintf('%03d', $N % 10000);\n}\n</cell>\n<text>\nProblem 2b: Solve\
    \ the Kata again.\nWe have solved the previous kata on problem 2. What happens\
    \ when the number of digits in the binary representation of the number is greater\
    \ than 10?", "    my($i,$j);\n    my($temp);", "    return sprintf(\"%0${N}b\"\
    , $N);\n}", "    my $Nstr = sprintf(\"%b\", $N);\n    $Nstr =~ s/0//g;\n    return\
    \ $Nstr;\n}\n</code>\nThe answer to the original question can be obtained in two\
    \ steps:\n<code>", "    my @nums = ();\n    for (my $i = 0; $i < $N; $i++) {\n\
    \        push(@nums, int(($N % $i) / $i));\n    }\n    return join(\"_\",@nums);\n\
    }", "    my @bits;\n    # Binary number is represented as a list of digits, where\
    \ the first\n    # digit is at the 0th index and the rest is from the digit at\
    \ index 1.\n    while (@bits < $N) {\n\tpush(@bits, 0);\n\t++$bits[-1];\n    }\n\
    \    my $ans = \"\";\n    my $i = 1;\n    foreach my $b (@bits) {\n\tif ($b &\
    \ 1) {\n\t    $ans .= \"1\";\n\t} else {\n\t    $ans .= \"0\";\n\t}\n\t++$i;\n\
    \    }\n    return $ans;\n}", "    my(@bin); # Array for binary number\n    #\
    \ Generate Binary Number by Recursion\n    if($N < 1) {\n        return;\n   \
    \ }\n    solve(int($N/2)) if $N > 1;\n    push(@bin, int($N/2)) if $N > 1;\n \
    \   for(my $i = 0; $i < ; $i++) {\n        if ($N >= $i) {\n            $N /=\
    \ $i;\n            push(@bin, int($N/2)) if $N > 1;\n            my $temp = $N;\n\
    \            $N = 0;\n            solve(int($temp/2));\n        }\n    }\n   \
    \ return \"1\" if $bin[0] == 0;\n    return join(\"\", @bin);\n}", "    return\
    \ if ($N eq 0);\n    return sprintf(\"%b\", $N);\n}", "    my($sum);\n    my $one\
    \ = 1;\n    my $two = 2;\n    my $twos = $two * 2;\n    my $twom = $two * $N;\n\
    \    my $three = 3;\n    my $threes = $three * 2;\n    my $threem = $three * $N;\n\
    \    my $four = 4;\n    my $fours = $four * 2;\n    my $fourm = $four * $N;\n\
    \    my $five = 5;\n    my $fives = $five * 2;\n    my $fivem = $five * $N;\n\
    \    my $six = 6;\n    my $six = $six * 2;\n    my $sixm = $six * $N;\n    my\
    \ $seven = 7;\n    my $sevens = $seven * 2;\n    my $sevenm = $seven * $N;\n \
    \   my $eight = 8;\n    my $eights = $eight * 2;\n    my $eightm = $eight * $N;\n\
    \    my $nine = 9;\n    my $nines = $nine * 2;\n    my $ninem = $nine * $N;\n\
    \    my $ten = 10;\n    my $tens = $ten * 2;\n    my $tenm = $ten * $N;\n    my\
    \ $onem = $one;\n    my $twom = $two;\n    my $threem = $three;\n    my $fourm\
    \ = $four;\n    my $fivem = $five;\n    my $sixm = $six;\n    my $sevenm = $seven;\n\
    \    my $eightm = $eight;\n    my $ninem = $nine;\n    my $tenm = $ten;\n    my\
    \ $tens = $ten;\n    my $nines = $nine;\n    my $ones = $one;\n    my $twos =\
    \ $two;\n    my $threes = $three;\n    my $fours = $four;\n    my $fives = $five;\n\
    \    my $sixes = $six;\n    my $sevens = $seven;\n    my $eights = $eight;\n \
    \   my $nines = $nine;\n    my $zero = 0;\n    $sum = $zero + ($N % $ones) + ($N\
    \ % $twos);\n    $sum = $sum + ($N % $threes) + ($N % $fours);\n    $sum = $sum\
    \ + ($N % $fives) + ($N % $sixes);\n    $sum = $", "    my $str = \"\";\n    while\
    \ ($N >= 10) {\n        $str .= \"$N\";\n        $N = int($N/10);\n    }\n   \
    \ return $str;\n}", "    my %map = (\n        1  => '1',\n        2  => '10',\n\
    \        3  => '11',\n        4  => '100',\n        5  => '101',\n        6  =>\
    \ '110',\n        7  => '111',\n        8  => '1000',\n        9  => '1001',\n\
    \        10 => '1010',\n        11 => '1011',\n        12 => '11000',\n      \
    \  13 => '11001',\n        14 => '11010',\n        15 => '11011',\n        16\
    \ => '11100',\n        17 => '11101',\n        18 => '11110',\n        19 => '11111',\n\
    \        20 => '10000',\n        21 => '10001',\n        22 => '10010',\n    \
    \    23 => '10011',\n        24 => '101000',\n        25 => '101001',\n      \
    \  26 => '101010',\n        27 => '101011',\n        28 => '101100',\n       \
    \ 29 => '101101',\n        30 => '101110',\n        31 => '101111',\n        32\
    \ => '110000',\n        33 => '110001',\n        34 => '110010',\n        35 =>\
    \ '110011',\n        36 => '110100',\n        37 => '110101',\n        38 => '110110',\n\
    \        39 => '110111',\n        40 => '111000',\n        41 => '111001',\n \
    \       42 => '111010',\n        43 => '111011',\n        44 => '111100',\n  \
    \      45 => '111101',\n        46 => '111110',\n        47 => '111111'\n    \
    \    );\n    my @num;\n    for (my $i = 0; $i <=$N; $i++) {\n        push @num,\
    \ $map{$i};\n    }\n    return join('', @num);\n}", "    return \"\" unless $N\
    \ =~ /^\\d+$/;\n    my(@digits) = $N =~ /..../;\n    my $total = 1;\n    my $result\
    \ = \"\";\n    foreach my $digit (@digits) {\n        $total += $digit;\n    \
    \    my $new = $total % 2;\n        $result = $new ? \"$digit0$result\" : $result;\n\
    \        $total /= 2;\n    }\n    return $result;\n}", "    my $sum = 0;\n   \
    \ while (0 < $N) {\n        $sum += $N % 2;\n        $N = ($N - $sum) / 2; # divide\
    \ and conquer\n    }\n    return $sum == 1 ? '1' : '0';\n}", "    my (@result);\n\
    \    my $Nbin = log($N) / log(2);\n    my $bin = sprintf(\"%b\", $N);\n    my\
    \ $n = length($bin);\n    my $s = $n;\n    my $d = $n - 1;\n    my $x = 1;\n \
    \   my $s = 0;\n    my $n = length($bin);\n    my $x = 1;\n    foreach my $i (0\
    \ .. $Nbin-1) {\n        if (($bin =~ /(.{$i})/) && $1 !~ /[^01]/) {\n       \
    \     my $num = $1 if ($1 ne \"0\");\n            $s .= $num;\n            $x\
    \ ++;\n        }\n    }\n    push(@result, $s);\n    return join(\"\", @result);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,algorithm,biginteger,language-agnostic\
    \ |>\nThis is what i got so far:\n<code>\ndef solution(n):\n   s = str(bin(n))\n\
    \   for i in range(1, len(s)-1):\n      if s[i-1] != '0' and s[i-1] != '1':\n\
    \         return False\n   else:\n      return True\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=math,algorithm,biginteger,language-agnostic |>\nHere is an\
    \ approach that does not require any modules, but only pure python:\n<code>\n\
    def isBinary(n):\n    chars = list(map(str, range(2, n+1)))\n    chars = chars[1:-1]\n\
    \    bits = len(chars)\n    for i in range(0, bits):\n        bits = chars.count(str(i),\
    \ i, bits)\n        if bits == 0:\n            return False\n    return True\n\
    </code>\n<|/ a |>\n<| c |>\nI suspect that this fails on inputs with leading zeros.\
    \  For example: `isBinary(0)` returns `True`.  `isBinary(1)` returns `True`. \
    \ `isBinary(2)` returns `True`.  `isBinary(3)` returns `True`.  `isBinary(4)`\
    \ returns `True`.  `isBinary(5)` returns `True`.  `isBinary(16)` returns `True`.\
    \  `isBinary(17)` returns `True`.  `isBinary(128)` returns `True`.  `isBinary(129)`\
    \ returns `True`.  `isBinary(256)` returns `True`.  `isBinary(27)` returns `True`.\
    \  `isBinary(128)` returns `True`.  `isBinary(2)` returns `True`.  `isBinary(7)`\
    \ returns `True`.  `isBinary(14)", "    if ($N == 0)\n    {\n        return \"\
    0\";\n    }\n    if ($N > 0 && $N < 10)\n    {\n        return \"0$N\";\n    }\n\
    \    # Binary representation of N's digits, starting with least significant digit\n\
    \    # and ending with the most significant digit.\n    my($bin) =\n        sprintf(\"\
    %.$#d\", $N)\n            .reverse\n            .\n            sprintf(\"%.$#d\"\
    , $N)\n            .reverse\n            ;\n    # Find the index of the first\
    \ '1' in $bin\n    my($index) = $bin =~ /(1*)/ ? 1 : 0;\n    return $bin[$index];\n\
    }", "    # Write your code here.\n    my($res);\n    my @arr;\n    for ($N > 0);\
    \ {\n        my $tmp = 0;\n        for (my $i = 0; $i < $N; $i++) {\n        \
    \    $tmp += $N % 2;\n            $N = $N / 2;\n        }\n        $res .= $tmp;\n\
    \    }\n    return $res;\n}", "    # Convert N to binary string\n    my($bin)\
    \ = lc($N);", "    my @result;\n    my $current;\n    $N *= 2;\n    while ($N)\
    \ {\n        $current += $N % 2;\n        $N = int($N / 2);\n        push @result,\
    \ $current;\n    }\n    return join('',@result);\n}\n</code>\n<|/ a tags=math,algorithm,ruby,bit-manipulation,bitwise-operators\
    \ dscore=4 |>\n<| a |>\nI ran some tests with different numbers and here are my\
    \ results\n<code>\nirb(main):001:0> def sumDigitsBinary(N)\nirb(main):002:1> \
    \    N *= 2\nirb(main):003:1>     sum = \"\"\nirb(main):004:1>     while N > 0\n\
    irb(main):005:1>         sum += N.to_s(2)[-1,1]\nirb(main):006:1>         N =\
    \ N / 2\nirb(main):007:1>     end\nirb(main):008:1> end\n=> nil\nirb(main):009:0>\
    \ sumDigitsBinary(1000)\n=> \"1\"\nirb(main):010:0> sumDigitsBinary(150)\n=> \"\
    110\"\nirb(main):011:0> sumDigitsBinary(147)\n=> \"1100\"\nirb(main):012:0> sumDigitsBinary(123)\n\
    => \"1001\"\nirb(main):013:0> sumDigitsBinary(100)\n=> \"1000\"\nirb(main):014:0>\
    \ sumDigitsBinary(75)\n=> \"1100\"\nirb(main):015:0> sumDigitsBinary(50)\n=> \"\
    11001\"\nirb(main):016:0> sumDigitsBinary(25)\n=> \"110010\"\nirb(main):017:0>\
    \ sumDigitsBinary(17)\n=> \"1100111\"\nirb(main):018:0> sumDigitsBinary(10)\n\
    => \"1100011\"\nirb(main):019:0> sumDigitsBinary(2)\n=> \"11000000\"\nirb(main):020:0>\
    \ sumDigitsBinary(1)\n=> \"1\"\n</code>\n<|/ a tags=math,algorithm,ruby,bit-manipulation,bitwise-operators\
    \ dscore=3 |>\n<| a |>\nHere is a solution in Python:\n<code>\ndef sumDigitsBinary(N):\n\
    \    sum = 0\n    while N > 0:\n        if N % 2 == 0:\n            sum += N\n\
    \        N >>= 1\n    return sum\n</code>", "    my %total;\n    while($N) {\n\
    \        $total{$N & 1}{$N}++;\n        $N = $N >> 1;\n    }\n    my $result =\
    \ '';\n    for my $i (keys %total) {\n        for my $j (keys %{$total{$i}}) {\n\
    \            my $digit = $total{$i}{$j};\n            next if $digit < 2;\n  \
    \          $digit--;\n            $result .= $digit & 1 ? '1' : '0';\n       \
    \ }\n    }\n    return $result;\n}", "    my(@sum) = ();\n    my(@bin) = ();\n\
    \    my(@res) = ();\n    for(my $i = 1; $i <= $N; $i++){\n        if($i % 2 ==\
    \ 1){\n            push(@bin, $i, $i-1);\n        }\n        else{\n         \
    \   for(my $n = @bin;; $n++){\n                if($n >= 2){\n                \
    \    my $res = $bin[$n] + $bin[$n-1];\n                    if($res < 10){\n  \
    \                      $res = \"0\" . $res;\n                    }\n         \
    \           push(@sum, $res);\n                }\n                else{\n    \
    \                if($n == 0){\n                        push(@sum, $bin[$n]);\n\
    \                        last;\n                    }\n                    else{\n\
    \                        last;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    for(my $i = 0; $i <= $#sum; $i++){\n      \
    \  my $rev = substr($sum[$i], 0, 1);\n        my $str = substr($sum[$i], 1);\n\
    \        if($rev){\n            $str = \"0\" . $str;\n        }\n        $res\
    \ = \"0\" . $res & $str;\n        push(@res, $res);\n    }\n    return join(\"\
    \", @res);\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction\
    \ printNumber() {\n    var input = document.querySelector('input');\n    var output\
    \ = document.querySelector('output');\n    var digits = [];\n    var currentNumber\
    \ = input.value;\n    currentNumber = Number(currentNumber);", "    my $s = '';\n\
    \    my $n = $N;\n    my $d = log($n);\n    for(my $i = 0; $i < $d; $i++) {\n\
    \        $s = $s . sprintf(\"%b\", $n%2);\n        $n = int($n/2);\n    }\n  \
    \  return $s;\n}\n</code>\n<|/ a dscore=3 tags=algorithm,math,language-agnostic,binary,optimization\
    \ |>\n<| c |>\nYeah, I think you're right - but there must be some way of doing\
    \ it without converting to decimal first. I've edited my question to hopefully\
    \ clarify this.\n<|/ c |>\n<| c |>\nYeah I think you're right - but there must\
    \ be some way of doing it without converting to decimal first. I've edited my\
    \ question to hopefully clarify this.\n<|/ c |>\n<| a dscore=3 |>\n<code>", " \
    \   my $s = \"\";\n    $s .= str_repeat(\"0\", $N);\n    return $s;\n}", "   \
    \ my $Nstr = join(\"\",(map{sprintf(\"%b\",$_)} grep {!!$_} reverse ($N%2) x ($N>>1)));\n\
    \    $Nstr =~ s/^0*//;\n    $Nstr;\n}\n</cell>\n<cell>", "    return join '',\
    \ map (\"0\"x($N%2)+$_), map ($N/2, (0..$N-1));\n}", "    if ($N <= 0) {\n   \
    \     return $N;\n    }\n    if ($N == 1) {\n        return \"0\";\n    }\n  \
    \  if ($N == 2) {\n        return \"1\";\n    }\n    return solve(2 * $N - 1)\
    \ + solve(2 * $N);\n}", "    return \"0\" x $N;\n}", '    return if $N < 0;',
  "    my $sum = 0;\n    my @binary = ();\n    my $Nstr = $N < 10000 ? $N : $N / 10000;\n\
    \    while ($Nstr > 0) {\n        my $remainder = $Nstr % 2;\n        $sum +=\
    \ $remainder;\n        $Nstr = int($Nstr / 2);\n        push (@binary, $remainder);\n\
    \    }\n    return $sum > 0 ? join('', @binary) : '';\n}", "    return $N eq 0\
    \ ? '0' : \n    $N eq 1 ? '1' : \n    $N eq 2 ? '11' : \n    $N eq 3 ? '111' :\n\
    \    $N eq 4 ? '1111' :\n    $N eq 5 ? '11111' :\n    $N eq 6 ? '111111' :\n \
    \   $N eq 7 ? '1111111' :\n    $N eq 8 ? '11111110' :\n    $N eq 9 ? '11111111'\
    \ :\n    $N eq 10 ? '111111111' :\n    $N eq 11 ? '1111111111' :\n    $N eq 12\
    \ ? '11111111111' :\n    $N eq 13 ? '111111111111' :\n    $N eq 14 ? '1111111111111'\
    \ :\n    $N eq 15 ? '11111111111111' :\n    $N eq 16 ? '111111111111111' :\n \
    \   $N eq 17 ? '1111111111111110' :\n    $N eq 18 ? '1111111111111111' :\n   \
    \ $N eq 19 ? '11111111111111111' :\n    $N eq 20 ? '111111111111111111' :\n  \
    \  $N eq 21 ? '1111111111111111111' :\n    $N eq 22 ? '11111111111111111111' :\n\
    \    $N eq 23 ? '111111111111111111111';\n}", "    return @$N <= 10000 ? \"0\"\
    \ . \"1\" x @$N : \"\" if $N <= 0;\n    return if $N & 1;\n    return if $N &\
    \ 4;\n    return \"1\" . solve(int($N / 2)) . solve(int($N / 2)) . $N & 7;\n}",
  "    my $s = \"\";\n    for(my $i = 1; $i < $N; $i++) {\n        $s += \"0\" x $i;\n\
    \    }\n    return $s;\n}", "    my $s = '';\n    my $k = 0;\n    while (1) {\n\
    \        if ($N >= $base($k)) {\n            $s .= $base($k);\n            $N\
    \ -= $base($k);\n        }\n        elsif ($k > 0) {\n            $s .= '0';\n\
    \        }\n        else {\n            $s .= '1';\n        }\n        $k++;\n\
    \    }\n    return $s;\n}", "    my $n = $N;\n    my $sum = 0;\n    $sum = ($N\
    \ & 1) ? \"1\" : \"0\";\n    $N = $N >> 1;\n    while($N){\n        $sum += ($N\
    \ & 1) ? \"1\" : \"0\";\n        $N = $N >> 1;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nHere is my solution in Python 3.x with explanation\
    \ inline\n<code>\ndef numToBinary(num):\n    binary = bin(num)[2:]\n    if num\
    \ == 1:\n        return binary\n    else:\n        digits = numToBinary(num//2)\n\
    \        digits = digits[:len(digits)-1] + binary\n        return digits", " \
    \   my $s = \"\";\n    while($N > 0) {\n        my $c = $N % 2;\n        $s =\
    \ \"$c$s$_\";\n        $N = $N/2;\n    }\n    return $s;\n}\n</code>\n<|/ a tags=recursion,algorithm,perl\
    \ dscore=2 |>\n<| c |>\nA nice compact solution, but it doesn't produce the \"\
    right\" answer.\n<|/ c |>\n<| c |>\n: Yes, I mentioned it at the end. As I didn't\
    \ know what was \"right\" I did not post a solution. :-)\n<|/ c |>\n<| c |>\n\
    I guess I wasn't clear about what I wanted. I wanted it to return \"11011\" and\
    \ not \"1101\". I think it would be easiest to just use the second solution.\n\
    <|/ c |>\n<| c |>\n: Yes, you probably should add that requirement. Then I posted\
    \ a second solution to show how it can be done without a loop. :-)\n<|/ c |>\n\
    <| c |>\n, if you don't want a loop, why did you tag the question `recursion`\
    \ ?\n<|/ c |>\n<| a |>\nA simple recursion is a nice idea, but it seems to me\
    \ that this is just two small changes. You don't need to keep the string in a\
    \ global variable. Instead return it from solve and print it, or use the string\
    \ directly in print.\n<code>", "    my $ans = \"\";\n    for(my $i = 0; $i < $N;\
    \ $i++)\n    {\n        $ans .= $N % 2;\n        $N = $N / 2;\n    }\n    return\
    \ $ans;\n}\n</code>\n<|/ a tags=c,c++ |>\n<| c |>\nThis solution doesn't work\
    \ for large numbers. Example: solve(1000000000000) returns \"1000000000000\"\n\
    <|/ c |>\n<| c |>\nI think this solution is also wrong. If N is 1000, then the\
    \ ans should be \"1\".\n<|/ c |>\n<| c |>\n: If you want the result to be one\
    \ digit per binary digit then you should be returning \"$N%2\" and then dividing\
    \ N by 2.  Otherwise your output will be all zeros when N is 1000000000000.\n\
    <|/ c |>\n<| c |>\n: Nice catch, thanks.  Corrected my code.\n<|/ c |>\n<| a |>\n\
    Here's a C++ solution:\n<code>", "    my @sum;\n    if ($N == 0) {\n        return\
    \ \"0\";\n    }\n    my $result = $N % 2;\n    my $remainder;\n    $N = $N / 2;\n\
    \    while ($N > 0) {\n        $remainder = $N % 2;\n        $sum[$result] +=\
    \ $remainder;\n        $N = $N / 2;\n        $result = $result ^ 1;\n    }\n \
    \   my $ret = \"\";\n    for my $i (0 .. $#sum) {\n        if ($sum[$i]) {\n \
    \           $ret .= $sum[$i];\n        }\n    }\n    return $ret;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis solution fails for `solve(147)`.\n<|/ c |>\n\
    <| c |>\nAwesome. Thanks ! I tried to solve this problem in perl. I really need\
    \ to study this language more. Thanks !\n<|/ c |>\n<| c |>\nThis approach isn't\
    \ very efficient - it requires a lot of extra calculations per digit. Here's a\
    \ more efficient one: http://stackoverflow.com/a/39130962/628278\n<|/ c |>\n<|\
    \ a tags=algorithm,math |>\nIn pseudocode, I'd do:\n<code>\nint sum = N;\nwhile\
    \ (N > 0) {\n    sum = sum * 10 + N % 10;\n    N = N / 10;\n}", "    my(@result)\
    \ = ('');\n    for($N){\n        ($digit,$rest) = split(\"\",$N);\n        $result\
    \ = join(\"\",@result);\n        $N = $rest;\n    }\n    return $result;\n}\n\
    </code>\n<|/ a tags=math,c++,algorithm,python dscore=2 |>\n<| c |>\nIt is not\
    \ guaranteed that the sum will be in `'1'`. For example, `solve(-3)` will return\
    \ `\"010\"`.\n<|/ c |>\n<| a tags=math,c++,algorithm,python |>\nI have tried the\
    \ approach of \"Bubble sort\", but this approach is not optimal, because we need\
    \ to loop through the list to find the max element and minimum element each time,\
    \ whereas bubble sort can easily find the min and max element in a single pass\
    \ through the list.\nSo my approach would be that \"Bubble sort\" will be more\
    \ efficient if the array contains negative numbers (as in the example)\n<code>\n\
    def solve(arr, n = len(arr)):\n    '''\n    arr: an array of integers\n    n:\
    \ length of the array\n    '''\n    if n < 2:\n        return 0\n    \n    max_value\
    \ = arr[0]\n    \n    for i in range(1, n):\n        if arr[i] > max_value:\n\
    \            max_value = arr[i]\n            \n    min_value = arr[0]\n    \n\
    \    for i in range(1, n):\n        if arr[i] < min_value:\n            min_value\
    \ = arr[i]\n            \n    digits = [arr[i]%10 for i in range(1, n)]\n    \n\
    \    res = [min_value] + digits\n    \n    sum_of_digits = sum(digits)\n    \n\
    \    if sum_of_digits != 0 and sum_of_digits != max_value:\n        digit = sum_of_digits\
    \ % 10\n        \n        res = [digit] + res\n        \n    return ''.join(str(elem)\
    \ for elem in res)", "    return \"1\" if $N == 0;\n    my($temp) = @$N;\n   \
    \ while ($temp > 0) {\n\tmy($rem) = $temp % 2;\n\t$temp = $temp / 2;\n\treturn(\"\
    1\" if ($rem == 1));\n    }\n}\n</cell>\n<text>\nProblem 3\nThe decimal number,\
    \ 585 = 1001001001 in binary is equal to 4 + 8 + 5 + 8 + 5 + 8 + 5 + 8 + 5 + 8\
    \ + 5 + 8 + 5.\nFind the sum of all numbers with this property.", "    return\
    \ unless $N >= 0;\n    my($result,$i,$j,$sum,$remainder);\n    for($i=0; $i<$N;\
    \ $i++) {\n        $sum += $N % 2;\n        $N = $N/2;\n    }\n    $remainder\
    \ = $N;\n    $remainder = $N % 2;\n    for($i=0; $i<$N; $i++) {\n        $j =\
    \ $sum + $i;\n        $remainder = $remainder % 2;\n        $result->[$i] = $remainder;\n\
    \        $remainder = $remainder + $result->[$i];\n    }\n    return $result;\n\
    }", "    my $result = '';\n    my $i = 0;\n    my $base = 2;\n    while($N > 0)\
    \ {\n        $result += $N & 1 ? '1' : '0';\n        $N = $N >> 1;\n        $i++;\n\
    \    }\n    $result =~ s/^0$//;\n    for ($i-1; $i > 0; $i--) {\n        $result\
    \ = \"0$result\";\n    }\n    return $result;\n}\n</cell>\n<cell>\nsolve(1000)\n\
    </cell>\n<cell>\nsolve(999)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2001)\n\
    </cell>\n<cell>\nsolve(2002)\n</cell>\n<cell>\nsolve(2003)\n</cell>\n<cell>\n\
    solve(2100)\n</cell>\n<cell>\nsolve(1999)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n\
    <cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n\
    </cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\n\
    solve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n\
    <cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n\
    </cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\n\
    solve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n\
    <cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n\
    </cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\n\
    solve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n\
    <cell>\nsolve(2000)\n</cell>\n<cell>\nsolve(2000)\n</cell>\n<cell>\n"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
