name: HumanEval_59_largest_prime_factor
language: pl
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n\
  sub largest_prime_factor {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_prime_factor;\n\
  \        if(eq_deeply($candidate->(15),5)) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(27),3)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),7))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(330),11))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13195),29))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $i = 2;\n    my $prime;", '    my @primes = ();', "    my $s\
    \ = sqrt($n);\n    $n = 3*$s if $n =~ /3$/;\n    my $d = $n % $s;\n    return\
    \ $s if $d > 2;\n    $d = $s-$d if $d < 2;\n    return $d;\n}", "    die 'n must\
    \ be an integer.' unless $n;", "    # Fast exit for positive factors.\n    return\
    \ $n if $n <= 1;", "    my $i = 0;\n    my $max = 1;\n    my $found = 0;\n   \
    \ while($i <= $n and $max <= $n) {\n        my $new_max = 2;\n        while(++$i\
    \ <= $n and $new_max <= $n) {\n            $max *= $new_max;\n            $new_max\
    \ += 1;\n        }\n        $found = 1;\n        $i = 1;\n    }\n    return $max\
    \ unless $found;\n    return $max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI\
    \ believe the prime factorization problem can be solved using dynamic programming\
    \ technique as below.", "    $n = $n if $n =~ /^\\d$/;\n    return 1 if ($n <=\
    \ 1);\n    my($max_factor);\n    while ($n != 1) {\n        my $next_n = $n+4;\n\
    \        my $next_n_is_prime = $next_n % 2 != 0;\n        while ($next_n % $n\
    \ == 0) {\n            $next_n = $next_n+4;\n        }\n        if ($next_n ==\
    \ $n) {\n            if ($next_n_is_prime) {\n                $max_factor = $n;\n\
    \            }\n            else {\n                $n = ($next_n - ($n-1)) /\
    \ 2;\n            }\n        }\n        else {\n            $n = $next_n;\n  \
    \      }\n    }\n    return $max_factor;\n}", "    return $n if $n < 2;\n    my($i,\
    \ $p1) = (0, 2);\n    while ($p < $n && $i % $p == 0) {\n        $p1++;\n    \
    \    $i++;\n    }\n    return $p1;\n}", "    my($prime_found);\n    my($primes);\n\
    \    my($max_prime);", "    my($prime_factor) = (1);\n    my($prime_found) = ();",
  "    # Avoid an infinite loop\n    last if (($n <= 1) || (($n == 2) && !($n & 1)));\n\
    \    # Initialization\n    my $factor = 2;\n    my $max_factor = 0;\n    while\
    \ ($n >= $factor) {\n        $max_factor = $factor;\n        for ($factor; $factor\
    \ < $n; $factor++) {\n            $max_factor = $factor if !($n % ($factor));\n\
    \        }\n        $factor = $max_factor;\n    }\n    return $factor;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\nThis is very easy to do in Scheme (as you mentioned\
    \ Python):\n<code>\n(define (largest-prime-factor n)\n  (define (prime? n) (=\
    \ (remainder n 2) 0))\n  (let loop ((p 2)\n             (x 1))\n    (if (or (<\
    \ n p)\n            (prime? x))\n        (if (= (modulo n p)\n              (=\
    \ 0 (remainder x 2))) p\n              (loop (+ p 1) (+ x 1))))))\n</code>\nIt\
    \ works by starting with a prime p and a counter x.\nIn the first iteration we\
    \ add p to x and then check whether n is divisible by p. If it is not, we add\
    \ x to p (which means we increase x by 1) and then check for the next iteration.\n\
    The recursion stops when the counter reaches n. If n is not divisible by p then\
    \ (= (modulo n p) will be true so p must be the largest prime factor.\n<|/ a tags=math,primes,python\
    \ |>\n<| c |>\nThanks for the solution. I didn't realize you could define functions\
    \ like that.\n<|/ c |>\n<| a tags=math,primes,python dscore=2 |>\nUsing recursion\
    \ is inefficient and too complicated for such a simple task. For-loops are much\
    \ simpler:\n<code>\ndef largestPrimeFactor(n):\n    \"\"\"\n    Find the largest\
    \ prime factor of n.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n\
    \        for i in range(2,n+1):\n            if n % i == 0:\n                return\
    \ i\n</code>\n<|/ a |>\n<| c |>\nFor large values of `n` (e.g. 1000000007), this\
    \ will take over 10 minutes to finish.\n<|/ c |>\n<| c |>\nThis is not the most\
    \ efficient way. It is easy to find the largest prime factor with recursion and\
    \ it is easy to find the prime factors of a number with recursion and they are\
    \ both in O(n). Of course, the fastest way would be a sieve and it is in O(n log\
    \ log n) time. However, this is ", "    # n is prime\n    defined $n and $n =~\
    \ /^\\d+$/ or return;\n    # Assume n is prime\n    my $prime = 1;\n    # Count\
    \ factors less than n\n    my $count = 1;\n    for (1..$n) {\n        my $n =\
    \ $n % $count;\n        $prime = $prime * $count if $n != 0;\n        $count++;\n\
    \    }\n    return $prime;\n}", "    my $max_prime = 1;\n    my $prime = 2;\n\
    \    my $i = 2;", '    $n |= 1; # force $n to be positive if $n < 1', '    my(@prime_factors);',
  "    if ($n != 1 && $n != 0) {\n        my $max = 1;\n        for (my $i = 2; $i\
    \ <= $n; ++$i) {\n            $max = $i if $n % $i == 0;\n        }\n        return\
    \ $max;\n    }\n}", "    my $p = 2;\n    my $q = 1;\n    while ($q < $n) {\n \
    \       my $r = $q + 1;\n        while ($r < $n) {\n            my $y = $p * $q;\n\
    \            if ($r == $n) {\n                return $y;\n            }\n    \
    \        last if $y % $r == 0;\n            $r += $p;\n        }\n        last\
    \ unless $q == $n / $p;\n        $p = $q + 1;\n    }\n    die \"n cannot be factorized\
    \ into primes\\n\";\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1 for an algorithm,\
    \ but your Python code is wrong. Try it with n=5 for example. It fails.\n<|/ c\
    \ |>\n<| c |>\nYou're right, I missed that part. I'll fix it in a moment\n<|/\
    \ c |>\n<| c |>\nYou probably want an `else` after that `last unless` too.\n<|/\
    \ c |>\n<| c |>\nGood catch, thanks. I fixed the code\n<|/ c |>\n<| a dscore=1\
    \ tags=factors,perl |>\nYou can do this in one line, but it's much less readable.\
    \ \n<code>", "    $n = abs($n);\n    while ($n > 2) {\n        my $m = ($n-1)\
    \ /2;\n        my $k = (($n-1) %2);\n        my $p = 1; # Start with the prime\
    \ factor.\n        while ($p < $m) {\n            ++$p;\n            ++$k;\n \
    \           my $x = $k; # Increment by one and check to see if it divides n.\n\
    \            while ($x != $n and $p*$p < $n) {\n                $x++;\n      \
    \          if ($x != $n and $p*$p < $n) {\n                    $p++; # Decrement\
    \ by one and check the square of p.\n                }\n                else {\n\
    \                    $n--;\n                    if ($n % $p == 0) {\n        \
    \                last;\n                    }\n                }\n           \
    \ }\n        }\n    }\n    $n;\n}", '    return $n if $n <= 1;', "    $n = abs($n);\n\
    \    my $sqrt = (int)(sqrt($n));\n    if ($n % $sqrt == 0) {\n        return $sqrt;\n\
    \    }\n    my $i = 2;\n    while ($i * $i <= $n) {\n        last if ($n % $i\
    \ == 0);\n        $i += 1;\n    }\n    return $i;\n}", "    # Make sure n is positive.\n\
    \    return $n if $n >= 0;\n    # Make sure n is a natural number.\n    return\
    \ $n if $n <= 1;\n    # Check that n is not a perfect square.\n    return $n if\
    \ !is_perfect_square($n);\n    # Find the largest factor of n.\n    my $max_factor\
    \ = 0;\n    my $max_power = 0;\n    my $max_factor_index = 0;\n    foreach my\
    \ $i (1 .. $n-1) {\n        my $fact = 1;\n        my $power = 0;\n        foreach\
    \ my $j (1 .. $n-1) {\n            $power += $j;\n            $fact *= $j;\n \
    \           last if !is_prime($fact / $i);\n        }\n        if ($power > $max_power)\
    \ {\n            $max_power = $power;\n            $max_factor_index = $i;\n \
    \           $max_factor = $fact;\n        }\n    }\n    return $max_factor;\n}",
  '    my $max_factor = 0;', "    return 1 if ($n == 1);\n    my($m, $p) = @_;\n \
    \   return $m if ($p == 1);\n    my($i, $x, $y);\n    $x = 0;\n    $y = 2;\n \
    \   foreach $i (1 .. $n) {\n        if ($i % $x == 0) {\n            $x = $i;\n\
    \        }\n        if ($i % $y == 0) {\n            $y = $i;\n        }\n   \
    \ }\n    return $x * $y;\n}", "    my($i); # Initialize $i to 2\n    my($t);",
  "    my($m) = sqrt($n);\n    if ($m == 1) {\n        return $n;\n    } elsif ($n\
    \ % $m == 0) {\n        return $m;\n    } else {\n        while ($m % 2 == 0)\
    \ {\n            $m = $m/2;\n        }\n        while ($n % $m == 0) {\n     \
    \       $n = $n/$m;\n        }\n        return $m;\n    }\n}", "    my(@primes)\
    \ = @_;\n    my(@factors);", "    # Prime factors greater than 2 can be factored\
    \ into products of primes.\n    # Therefore, we need to find the smallest prime\
    \ factor greater than 2.\n    if ($n <= 1) {\n        return 0;\n    }\n    my\
    \ $smallest = 0;\n    while (1) {\n        my $i = $n;\n        while ($i % $i\
    \ == 0) {\n            $i /= $i;\n            last if $i > 1;\n        }\n   \
    \     if ($i == 2) {\n            return $n;\n        }\n        $smallest = $i;\n\
    \        $n /= $i;\n    }\n    $smallest;\n}", "    my $max = 1;\n    my $p;",
  "    my($i, $k);\n    my(@primes);\n    my(@factors);", "    my $n = Math::BigInt->new($n);\n\
    \    my $p = $n;\n    while (1) {\n        my $quotient = $p / $prime_numbers_cache{$n};\n\
    \        return $quotient if $quotient == $p;\n        my $quotient = $p / $next_prime_numbers_cache{$n};\n\
    \        $p = $quotient;\n    }\n}", "    if ($n == 0) { return 0; }\n    my($i,\
    \ $x, $p, $d, $t) = @_;\n    $x    = $n-1;\n    $p    = 1;\n    $d    = 0;\n \
    \   $t    = 0;\n    foreach $i (1..($x/$p)) {\n        $t    = ($x % $p);\n  \
    \      $x    = $t;\n        $p   *= $p;\n        $d   += $t;\n    }\n    $p -=\
    \ 1;\n    if ($p > 1) { $d++; }\n    return $d; \n}", "    my $n;\n    my $factor\
    \ = 1;\n    my $i;\n    for (; $n > 1; $n /= 2) {\n        for ($i = 2; $i <=\
    \ sqrt($n); $i++) {\n            my $test = $n % $i;\n            if ($test !=\
    \ 0) {\n                $factor = $i;\n                $n = $test;\n         \
    \       break;\n            }\n        }\n    }\n    return $factor;\n}", "  \
    \  my $max = ceil(sqrt($n));\n    my $factor = 1;\n    \n    for($max;$max<=$n;$max++)\
    \ {\n        if($n % $max == 0) {\n            while($n % $max == 0) {\n     \
    \           $n /= $max;\n                $factor++;\n            }\n         \
    \   last;\n        }\n    }\n    \n    return $factor;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis approach is too slow. The OP asked for faster than O(n^2), so you\
    \ should be thinking about how to do prime factorization faster. For example,\
    \ by only checking odd numbers.\n<|/ c |>\n<| c |>\n, I don't think that the above\
    \ approach is any slower than O(n^2). The only difference is that it uses more\
    \ memory, but it's definitely faster than other approaches.\n<|/ c |>\n<| c |>\n\
    : It is not O(n^2) because you use sqrt for every prime factorisation. I would\
    \ expect a O(sqrt(n)) approach. Though this algorithm has time complexity O(sqrt(n)),\
    \ which is still O(n^2).\n<|/ c |>\n<| c |>\n: It is not O(sqrt(n)) because you\
    \ use sqrt for every prime factorisation. I would expect a O(sqrt(n)) approach.\
    \ Though this algorithm has time complexity O(sqrt(n)), which is still O(n^2).\n\
    <|/ c |>\n<| c |>\n: You seem to be misunderstanding the question. Yes, the algorithm\
    \ is O(sqrt(n)), as I said in my comment. I was just pointing out that you are\
    \ doing sqrt(n) operations each time you find a prime factorisation instead of\
    \ just doing sqrt(n) in total. It would of course still be O(n^2) if the factorisation\
    \ algorithm used a better algorithm.\n<|/ c |>\n<| a |>\nThis code worked perfectly\
    \ for me, maybe it will help someone\n<code>\nmy $n= 20;\nmy $n1 = 1;", "    my\
    \ $max = -1;\n    my $maxp = 0;\n    for(my $i = 1; $i <= $n; ++$i){\n       \
    \ my $p = $i ** 2;\n        my $factor = 1;\n        while($p >= $maxp){\n   \
    \         $maxp = $p;\n            ++$max;\n            $factor = 1;\n       \
    \     while($p % $i == 0){\n                $p = ($p / $i) + 1;\n            \
    \    ++$factor;\n            }\n        }\n        $max = $factor;\n    }\n  \
    \  return $max;\n}", "    die \"Not prime\" if $n <= 1;\n    if ($n == 2) {\n\
    \        return 2;\n    }\n    my $i = 1;\n    while ($i ** 2 <= $n) {\n     \
    \   my $prime;\n        for ($i = 2; $i * $i <= $n; $i++) {\n            if ($n\
    \ % $i == 0) {\n                $prime = $i;\n                last;\n        \
    \    }\n        }\n        if ($prime) {\n            return $prime;\n       \
    \ }\n    }\n}", "    my $n = $n or return;\n    my $p = 2;\n    while ($n % $p)\
    \ {\n        $p++;\n    }\n    return $p;\n}", "    # Special case 1: small numbers\n\
    \    return $n if $n == 1 || $n == 0;", "    my $limit = ($n <= 1) ? 1 : ($n %\
    \ 2 == 0) ? $n : $n / 2;\n    my $p;\n    for($p = 1; $p <= $limit; $p += 2) {\n\
    \        if ($n % $p == 0 && $n != $p) {\n            last if ($n != $p * $p);\n\
    \        }\n    }\n    return $p;\n}", "    my $max = $n;\n    my %primes = ();\n\
    \    my $i = 0;\n    foreach my $p (1..$max) {\n        if (!exists($primes{$p})\
    \ && ($p * $p) <= $n) {\n            $primes{$p} = 1;\n            $i++;\n   \
    \     }\n    }\n    my $largest = 1;\n    foreach my $p (1..$i) {\n        if\
    \ ($primes{$p}) {\n            $largest *= $p;\n        }\n    }\n    return $largest;\n\
    }", "    my(@p, $n, $i, $m);\n    my $p;\n    if ($n <= 1) {\n        return $n;\n\
    \    }\n    # Sieve of Eratosthenes\n    my $m = $n;\n    while (!($m & 1)) {\n\
    \        $m = $m >> 1;\n    }\n    $m++;\n    $n = $n;\n    my $n_2 = $n;\n  \
    \  $n_2 = $n_2 >> 1;\n    for ($i = $m; $i > 0; $i--) {\n        $p = $i;\n  \
    \      while (!($n_2 & 1)) {\n            $n_2 = $n_2 >> 1;\n            $p =\
    \ $p * $i;\n        }\n        push @p, $p;\n    }\n    $p = 0;\n    for (@p)\
    \ {\n        $p = $p + ($n%$_) * $_;\n        $n = $_;\n    }\n    return $p;\n\
    }", "    $n -= 2;\n    while (!isPrime($n)) {\n        $n--;\n    }\n    return\
    \ $n;\n}\n</code>\n<|/ a tags=perl,math,primes,algorithm,optimization |>\n<| c\
    \ |>\nThe first part of your answer works perfectly for me (my Perl is rusty),\
    \ but your second part doesn't work as you might expect. It doesn't find the greatest\
    \ prime factor, but rather a smaller factor.\n<|/ c |>\n<| c |>\nHmm, you're right!\
    \ I fixed it. I guess it took me a while to understand what was going on with\
    \ that part too.\n<|/ c |>\n<| c |>\nThanks so much for this. It saved me a lot\
    \ of time and effort.\n<|/ c |>\n<| c |>\nOne more thing: you don't need to check\
    \ if `n` is prime. Just test if `n == 2` or the largest prime factor.\n<|/ c |>\n\
    <| a tags=perl,math,primes,algorithm,optimization |>\nI thought a lot about this\
    \ problem, and I finally came up with this algorithm for Perl - I hope it helps\
    \ someone else:\n<code>", "    \n    return ($n > 1) ? ($n % 2 != 0 ? $n : smaller_prime_factor($n))\
    \ : $n;\n}", "    return $n if $n <= 1;\n    return $n if is_prime($n);\n    my($m)\
    \ = Math::BigInt->new($n);\n    while (my($k) = $m->next_prime()->is_odd()) {\n\
    \        $m->bmod($k);\n    }\n    return $m == 1 ? $m : $m->as_int();\n}", " \
    \   return 1 while $n != 1;\n    for (my $i = 2; $i <= $n; $i++) {\n        $n\
    \ = $n / $i;\n        return $i if $n == 1;\n    }\n    return $n\n}", "    return\
    \ undef unless defined $n;\n    return $n if $n <= 1;\n    return $n if $n <=\
    \ 3;\n    my $factor = 2;\n    my $p = 1;\n    while ($n >= $p) {\n        $p\
    \ = $factor;\n        my $i = $n/$p;\n        $n = $p - $i*$p;\n        $factor++;\n\
    \    }\n    return $factor;\n}", "    return 1 unless $n and $n <= 1;\n    for\
    \ (my $i = 3; $i <= sqrt($n); $i += 2) {\n        if ($n % $i == 0) {\n      \
    \      return $i;\n        }\n    }\n}", "    # Special cases.\n    return $n\
    \ if $n <= 1;\n    if ($n == 2) {\n        return 2;\n    } elsif ($n > 2) {\n\
    \        my $i = 2;\n        my $test = $n;\n        while ($test != 1) {\n  \
    \          my $j = 2;\n            while ($j > i) {\n                my $test\
    \ = ($test / $i);\n                if ($test == 1) {\n                    $j =\
    \ $i + 1;\n                }\n                else {\n                    return\
    \ $test;\n                }\n            }\n            $i = $i + 1;\n       \
    \ }\n        return 2;\n    }\n    # Other cases.\n    my $i = 2;\n    my $test\
    \ = $n;\n    while ($test != 1) {\n        my $j = 2;\n        while ($j > i)\
    \ {\n            my $test = ($test / $i);\n            if ($test == 1) {\n   \
    \             $j = $i + 1;\n            }\n            else {\n              \
    \  return $test;\n            }\n        }\n        $i = $i + 1;\n    }\n    return\
    \ 2;\n}", "    my($prime_count, $max_factor);\n    my($i, $p);\n    for($i = 2;\
    \ $i < $n; $i += 2) {\n        $p = $i;\n        for(; $p <= $n; $p += 2) {\n\
    \            $prime_count++;\n        }\n        if($prime_count == $max_factor)\
    \ {\n            $max_factor = $prime_count;\n        }\n    }\n    $max_factor;\n\
    }", '    return $n if $n < 2;', '    my($p) = 1;', "    my $max = -1;\n    foreach\
    \ my $k (1..$n) {\n        if ($n % $k == 0) {\n            my $k2 = $k + 2;\n\
    \            while ($n % $k2 != 0) {\n                last if $k2 == $n;\n   \
    \             $k2 = $k2 + 2;\n            }\n            $max = $k2;\n       \
    \     $n = $n / $k;\n        }\n    }\n    return $max;\n}", "    my $i = 1;\n\
    \    my $max_factor = 1;\n    my $max_factor_found = 0;\n    my $factor = 1;",
  "    if ( $n < 2 ) { return 0; }\n    if ( $n < 12 ) { return $n; }\n    if ( $n\
    \ < 63 ) { return $n; }\n    my($i, $s);\n    # Check for easy primes first.\n\
    \    # Divide by 2 if even, 3 if odd.\n    foreach $i (1 .. $n / 2 ) {\n     \
    \   $s = $n / $i;\n        if ( !( $i * $i > $s ) ) {\n            if ( $s * $s\
    \ > $n ) { return $i; }\n            if ( $s * $s < $n ) { return $n; }\n    \
    \    }\n    }\n    if ( $n % 2 ) {\n        $i = 3;\n        while ( $n / $i )\
    \ {\n            ++$i;\n        }\n        $s = $n / $i;\n        return $i <\
    \ 3 ? $i : $n;\n    }\n    # Larger primes aren't easy!\n    # Find the first\
    \ prime > n (we start at n+1).\n    my($i, $s);\n    foreach $i (1 .. $n + 1 )\
    \ {\n        $s = $n / $i;\n        if ( $i * $i > $s ) {\n            return\
    \ $i;\n        }\n    }\n    return $n;\n}", "    return undef if $n <= 1;\n \
    \   $n = abs($n);\n    my @factors;\n    for my $i ( 1 .. $n ) {\n        next\
    \ unless $n % ($i + 2);\n        push @factors, $i + 2;\n        $n = $n / $i;\n\
    \    }\n    return $factors[-1] if @factors && $factors[-1] == $n;\n    return\
    \ $n;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nGreat answer, but I was looking\
    \ for a solution that does not use any library functions.  Not sure why, but the\
    \ solution I posted is not the best.\n<|/ c |>\n<| c |>\n: I like your implementation.\
    \ Yes I agree it uses many library functions, but in real life when dealing with\
    \ small numbers (like 2 or 3) I find the speed of the code to be more important\
    \ than the quality of the code. I am also pretty certain that my code above will\
    \ scale better than any algorithm which would have to be written to handle a larger\
    \ number.\n<|/ c |>\n<| a |>\nIf you have access to Perl 5.10 or newer you can\
    \ use Math::Prime::Util for this. No need to reinvent the wheel:\n<code>", " \
    \   my(@factors);\n    my $i = $n - 1;\n    my $p = 2;\n    while (!($p % $i))\
    \ {\n        push(@factors, $p);\n        $p += 2;\n    }\n    pop(@factors);\n\
    \    $n = @factors;\n    return $factors[$n-1];\n}", "    my $max = -1;\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        my $d = $n % $i;\n        if ($d == 0) {\n\
    \            $max = $i;\n        }\n        elsif ($d == 1) {\n            ++$max;\n\
    \        }\n    }\n    return $max;\n}", "    # Find factors starting from 2\n\
    \    my $fac = 2;\n    while ($fac <= $n) {\n        if ($n % $fac == 0) {\n \
    \           $n = ($n * $fac) / $fac;\n            $fac += 1;\n        }\n    \
    \    else {\n            $fac += 1;\n        }\n    }\n    return $n;\n}", " \
    \   my $max = -1;\n    my $i;\n    for ($i = 2; $i <= $n; ++$i) {\n        my\
    \ $c = 1;\n        while ($n % $i == 0) {\n            $c = 0;\n            $n\
    \ /= $i;\n        }\n        if ($c > $max) {\n            $max = $c;\n      \
    \  }\n    }\n    return $max;\n}", "    if($n == 0) {\n        return 0;\n   \
    \ }\n    my ($i, $d);\n    my $m = $n % 2;\n    for(;;) {\n        $i = 1;\n \
    \       my $p = $n;\n        while($p % 2 == 0) {\n            $p *= 2;\n    \
    \        $i++;\n        }\n        $d = $i;\n        if($m == 0) {\n         \
    \   $d += 1;\n        }\n        if($d > $n) {\n            $n /= $d;\n      \
    \  } else {\n            return $d;\n        }\n        $m = ($n % $p == 0) ?\
    \ 0 : 1;\n    }\n}", '    return unless $n =~ /\d/;', "    my $max = -1;\n   \
    \ my $i = 2;\n    while ($i <= $n) {\n        if ($n % $i == 0) {\n          \
    \  if ($max == -1) {\n                $max = $i;\n            }\n            elsif\
    \ ($max != $i && $max % $i == 0) {\n                $max = $i;\n            }\n\
    \        }\n        $i++;\n    }\n    return $max;\n}\n</code>\n<|/ a tags=math,primes,algorithm,factorization,python\
    \ dscore=3 |>\n<| c |>\n\"large integers\"... why not simply use an arbitrary\
    \ precision integer type?\n<|/ c |>\n<| c |>\n: Agreed. But it's simpler to demonstrate\
    \ the idea with a simple Python integer example.\n<|/ c |>\n<| a |>\nI have also\
    \ implemented a solution using an approach suggested by Eli Bendersky. However\
    \ it only works up to a certain value of n and has a different execution time\
    \ than the other answers. \n<code>", "    my($n, $n) = $n > 1 ? $n : 2;\n    while\
    \ ( $n > 1 ) {\n        my $m = $n % $n;\n        $n = $n;\n        $n = $m if\
    \ $m > 1;\n    }\n    return $n;\n}\n</code>\n<|/ a |>\n<| a tags=greatest-common-divisor,factors,perl,math,algorithm\
    \ |>\nThe question was actually posed before I was aware. Here's another take\
    \ on the problem, which I've been working on over the last few hours. A few notes:",
  '    return $n if $n <= 1;', "    $n++ while $n < 2 && $n != 1 && $n != 2;\n   \
    \ my($i, $j) = (2, $n);\n    for(;;) {\n        my($sqrtn2, $sqrtn3) = ($n / 2,\
    \ $n / 3);\n        while($sqrtn3 > 0) {\n            my($m, $m) = &_prime($sqrtn3);\n\
    \            my $m2 = $m * $m;\n            my $m3 = $m2 * $m;\n            if($m3\
    \ != $n && ($i % $m == 0)\n                && ($m2 % $m == 0)) {\n           \
    \     return $m2;\n            }\n            $sqrtn3 -= $m;\n            $sqrtn2\
    \ -= $m;\n        }\n        my $sqrtn1 = $sqrtn2;\n        $sqrtn2 = $sqrtn2\
    \ * $n;\n        $sqrtn1 -= $n;\n        if($sqrtn1 == 0) {\n            if($sqrtn2\
    \ < $n) {\n                return $n;\n            }\n            else {\n   \
    \             last;\n            }\n        }\n        my($m, $m) = &_prime($sqrtn1);\n\
    \        $i = $m * $i;\n        $j = $m * $j;\n    }\n}", "    my $result = 2;\n\
    \    for (my $x = 2; $x <=$n; $x++) {\n        if ($n % $x == 0) {\n         \
    \   my $temp = $x;\n            $result = $x;\n        }\n    }\n    return $result;\n\
    }", "    return unless $n > 1;\n    return 2 if $n == 2 || $n == 3 || $n == 4\
    \ || $n == 5;\n    my $k = 2;\n    my $max = 2;\n    for(;;) {\n        while($n\
    \ % $k == 0) {\n            $k++;\n        }\n        return $k if $k > $max;\n\
    \        my $a = $n / $k;\n        $n = $a if $a > $max;\n        $max = $k;\n\
    \    }\n}", "    $n = 1 if $n <= 1;\n    my $m = ($n % 2 == 0) ? 3 : 4;", '    my(@factors)
    = ();', "    if ($n == 1) {\n        return 1;\n    }\n    my $p = 2;\n    while\
    \ ($n >= $p) {\n        $n = ($n % $p) ? $p : int($n / $p);\n        $p = $p +\
    \ 1;\n    }\n    return $p;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nHere is a\
    \ Python 3 version of the algorithm described by Michal Zalewski in this excellent\
    \ answer: https://stackoverflow.com/a/19356910/140739\n<code>\ndef largest_prime_factor(n):\n\
    \    i = 2\n    factor = 2", "    return 1 if $n == 1;\n    return 1 if $n % 2\
    \ == 0;", "    return $n if $n == 1;\n    $n = Math::BigInt->new(Math::BigInt->new($n)->bmod($n));\n\
    \    while ($n->num < 2) { $n = $n->badd($n); }\n    return $n->num;\n}", "  \
    \  my($i, $p, $q, $k, $prime);\n    my(@factors);", "    # First find the largest\
    \ prime factor\n    my($p, $m) = (2, 1);\n    while ($p <= $n) {\n        if ($n\
    \ % $p == 0) {\n            $m++;\n        }\n        $p++;\n    }\n    # Now\
    \ trim down to get the largest prime factor\n    $p--;\n    while ($p > 1) {\n\
    \        if ($n % $p == 0) {\n            $m++;\n        }\n        $p--;\n  \
    \  }\n    return $m;\n}", "    my(@factors) = ();\n    my($i);", "    $n -= 2\
    \ if $n < 2;\n    $n = ($n < 4) ? 3 : 4;\n    my $i = 3;\n    while ($i <= $n)\
    \ {\n        my $p = $i * 2;\n        $i *= $i; # faster than $i = $i * 2\n  \
    \      if ($p <= $n) {\n            $n = $p;\n        } else {\n            $n\
    \ -= $p;\n        }\n    }\n    return $n;\n}", "    return $n if $n <= 1;\n \
    \   my ($i, $p, $n) = (0, 2, $n);\n    while (1) {\n        ++$i;\n        if\
    \ ($n % $i == 0) {\n            if ($i != $p) {\n                $p = $i;\n  \
    \          }\n        }\n    }\n    $p;\n}", '    return $n if $n <= 1;', "  \
    \  $n += 4;\n    my $i = 2;\n    my $factor = 1;\n    while($i <= $n) {\n    \
    \    if($n % $i == 0) {\n            $factor = int(($n / $i) + 1);\n         \
    \   last;\n        }\n        $i++;\n    }\n    return $factor;\n}", "    return\
    \ $n if $n <= 2;\n    my $result = 0;\n    for my $factor (2,$n-1) {\n       \
    \ last if $factor * $factor > $n;\n        $result = $factor if $n % $factor ==\
    \ 0;\n    }\n    return $result;\n}", "    my $i = 2;\n    my $max = 1;\n    while($i\
    \ <= $n and $n % $i == 0) {\n        $n = $i if $n > $i;\n        $i++;\n    }\n\
    \    return $max;\n}", "    $n = abs($n);\n    for (my $i = 2; $i <= $n; $i++)\
    \ {\n        my $p=$i;\n        while ($p <= $n) {\n            $p = ($p * $i)\
    \ / $i;\n        }\n        return $i;\n    }\n    die \"Factorization is not\
    \ possible\";\n}", "    my $m = 0;\n    my $result = 1;\n    foreach my $i (1..$n)\
    \ {\n        my $count = 1;\n        for my $j (1..$m) {\n            my $ipow\
    \ = $i * $j;\n            next if $ipow == $n;\n            if ($ipow % $n ==\
    \ 0) {\n                $count++;\n            }\n        }\n        if ($count\
    \ == $m) {\n            $result = $i;\n        }\n        $m++;\n    }\n    return\
    \ $result;\n}", "    my $i = 2;\n    my $max = 1;", "    $n += 2; # $n > 1\n \
    \   $n -= 1 if $n == 2 or $n == 3;\n    while ($n % 2 != 0) {\n        $n /= 2;\n\
    \    }\n    return $n;\n}", "    return undef unless $n > 1;\n    for (my $p =\
    \ 2; $p * $p < $n; ++$p) {\n        if ($n % $p == 0) {\n            my $q = $p\
    \ / $n;\n            return $q if $q > 1;\n        }\n    }\n    return $n;\n}",
  "    my($max);\n    my($i);\n    my($j);", "    my $max_factor = 1;\n    while ($n\
    \ % $max_factor != 0) {\n        $max_factor++;\n    }\n    return $max_factor;\n\
    }", "    my(@factors);\n    push(@factors, 2);\n    push(@factors, 3);\n    while\
    \ ($n != 1) {\n        my $next = 2;\n        while ($next <= $n) {\n        \
    \    ++$next unless $factors[-1] == $next;\n        }\n        unshift(@factors,\
    \ $next);\n        $n = $next;\n    }\n    shift @factors;\n    return @factors;\n\
    }", "    return $n if $n <= 1;\n    my $factors = $n ** 2 % 7 ? 3 : 5;\n    my\
    \ @factors = map { my $f = $n % $_; $f ? ($f * $_) : $_ } 1 .. $factors;\n   \
    \ return $factors[-1];\n}", "    my $p = 2;\n    while (!is_prime($n)) {\n   \
    \     $p = $p * $p;\n        $n  %= $p;\n    }\n    return $n;\n}", "    my $largest\
    \ = 1;\n    while (!is_prime($n)) {\n        if ($n % $largest == 0) {\n     \
    \       $largest++;\n        }\n        elsif ($largest == 2) {\n            return\
    \ $largest;\n        }\n        elsif ($largest == 3) {\n            return 2;\n\
    \        }\n        $n++;\n    }\n    return $largest;\n}", "    my $i = 2;\n\
    \    my $limit = 1;\n    my $factor = $n;\n    while ($i <= $limit) {\n      \
    \  my $remainder = $n % $i;\n        if ($remainder == 0) {\n            return\
    \ $i;\n        }\n        $i += 1;\n    }\n    return 0;\n}", "    my $max_factor\
    \ = 1;\n    my $max_factor_p;\n    for ($n = 2; $n <= $self->{n}; $n++) {\n  \
    \      for ($n = $self->_next_prime($n); $n <= $self->{n}; $n++) {\n         \
    \   $max_factor_p = $n if $self->is_prime($n);\n            last if $max_factor_p\
    \ == $max_factor;\n            $max_factor = $max_factor_p;\n        }\n    }\n\
    \    return $max_factor;\n}", "    return 1 if ($n == 1) or $n == 2 or $n % 2\
    \ == 0 or $n % 3 == 0;\n    my (@d) = &factor($n);\n    return 1 if ($d[0] ==\
    \ 1);\n    my $m = $d[0];\n    for my $i (1..@d-1) {\n        if ($d[$i]*$m*$m\
    \ > $n) {\n            $m = $d[$i];\n        }\n    }\n    return $m;\n}", " \
    \   # Only check up to $MAXINT/2 because primes are always odd numbers.\n    return\
    \ $n < $MAXINT/2 ? $n : 1;\n}", "    die \"n must be greater than 1.\" unless\
    \ $n > 1;\n    die \"n must be an integer.\" unless $n == int $n;\n    my $i =\
    \ 2;\n    while (!is_prime($n)) {\n        $n = $n / $i;\n        $i++;\n    }\n\
    \    return $i;\n}", '    return 1 unless $n > 2;', "    my($max_factor) = 0;\n\
    \    my($factor);\n    \n    while (1) {\n        $factor++;\n        last if\
    \ $n > $factor;\n        next unless $factor->is_prime();\n        $max_factor\
    \ = $factor if $factor > $max_factor;\n    }\n    return $max_factor;\n}", " \
    \   my(@factors) = ();\n    my $max_factor = 1;", "    my(@primes) = @_;\n   \
    \ push(@primes, 2);\n    for(my $i = 3; $i < $n; $i += 2) {\n        push(@primes,\
    \ $i);\n    }\n    while(@primes) {\n        my $prime = shift(@primes);\n   \
    \     for(my $i = 2; $i <= $prime; $i++) {\n            if(!grep {$_ eq $i}) {\n\
    \                push(@primes, $i);\n            }\n        }\n    }\n    return\
    \ $prime;\n}\n</code>\n<|/ a tags=math,primes,algorithm,python |>\n<| c |>\nThis\
    \ is not the fastest prime checking algorithm, but it is the most efficient for\
    \ most applications.  It would be good to see some benchmarks comparing yours\
    \ with some others, especially since there is much more code in the algorithm\
    \ than the OP posted.\n<|/ c |>\n<| c |>\nIn fact I do like this one.  It makes\
    \ use of memoization to speed up calculations by only using primes up to sqrt(n).\
    \  It also avoids creating new list objects for every new input.\n<|/ c |>\n<|\
    \ c |>\nThat is pretty nice.\n<|/ c |>\n<| c |>\n: Thanks for commenting.  It\
    \ was late when I wrote the answer.  I tested the original code against this one,\
    \ and I found that the original code took about twice as long to compute the largest\
    \ prime factor.\n<|/ c |>\n<| c |>\nThat is because of the overhead of list comprehensions.\
    \  I changed the code to create one list before entering the loop.  I still think\
    \ that using a list comprehension would speed things up somewhat, but I did not\
    \ test that to confirm.\n<|/ c |>\n<| a dscore=5 tags=math,primes,algorithm,python\
    \ |>\nMy attempt at implementing this in Python:\n<code>\ndef isPrime(n):\n  \
    \  \"\"\" Determine if a number is a prime number. \"\"\"\n    if n <= 1:\n  \
    \      return False\n    if n <= 3:\n        return True\n    if n % 2 == 0:\n\
    \        return False\n    limit = int(n ** 0.5)\n    rangeCheck = True\n    for\
    \ i in range(3, limit + 1, 2):\n        if n % i == 0:\n            rangeCheck\
    \ = False\n            break\n    if rangeCheck:\n        return True\n    else:\n\
    \        return False", "    my $largest = 1;\n    for(my $i = 2; $i <= sqrt($n);\
    \ $i++) {\n        $largest = $i if $n % $i == 0;\n    }\n    return $largest;\n\
    }", "    # Skip factors of 2 as they don't add much to the answer\n    next $n\
    \ if $n % 2 != 0;\n    my ($k, $r) = (2, 2);\n    my $m = $n;\n    my $prime;\n\
    \    while ($m % 2 == 0) {\n        # Find next factor by trial division\n   \
    \     while ($m % $k == 0) {\n            $m /= $k;\n            $prime++;\n \
    \       }\n        $k *= 2;\n    }\n    $k++ while ($n % $k);\n    next unless\
    \ $prime;\n    return $k;\n}", "    return $n if $n <= 1;\n    my $limit = sqrt($n);\n\
    \    my $limit2 = $limit + 1;\n    while ($n % $limit != 0) {\n        my $candidate\
    \ = int(($limit + $limit + 1) / 2);\n        if ($n != 1) {\n            my $div\
    \ = $limit / $candidate;\n            $limit2 = $candidate + $div;\n        }\n\
    \        else {\n            $limit2 = $candidate;\n        }\n        $limit\
    \ = $limit2;\n    }\n    return $limit;\n}", "    for (my $i = 3;; $i += 2) {\n\
    \        $n = $n / $i;\n        last if ($n == 1);\n    }\n    return $i\n}\n\
    </code>\n<|/ a tags=primes,algorithm,math,mathematical-optimization dscore=0 |>\n\
    <| a dscore=0 |>\n<code>\ndef prime(x):\n    if x is 1:\n        return 1;\n \
    \   elif x is 2:\n        return 2;\n    else:\n        for y in range(3,x,2):\n\
    \            if x % y == 0:\n                return y\n        return x\n</code>\n\
    <|/ a tags=primes,algorithm,math,mathematical-optimization |>\n<| a tags=primes,algorithm,math,mathematical-optimization\
    \ |>\n<code>\ndef primeFactor(n):\n    '''\n    Calculate prime factors of a given\
    \ number.\n    '''\n    if n == 1:\n        return [1]\n    for i in range(2,\
    \ n):\n        if n % i == 0:\n            return [n, i] \n    return [1]", '    my(@factors);',
  "    $n = $_ if !defined $n or $n eq 0;\n    my ($s, $k) = largest_prime($n);\n\
    \    return $k >= $n ? $n : max($s, $k);\n}", "    my($i, $k) = (2, 1);\n    while\
    \ ($k <= $n) {\n        $i = $i * $k;\n        if ($i > ($n - $k)) {\n       \
    \     $k++;\n        }\n    }\n    return $i;\n}", "    my($i);\n    my($factor);",
  "    my $result = $n < 2 ? $n : $n % $n > 3 ? $n : 2;\n    for (my $i = $n; $i >\
    \ 1; $i /= 2) {\n        $result = $i > $result ? $i : $result;\n    }\n    $result;\n\
    }", "    my ($n) = abs($n);\n    my $m = $n >> 1;\n    while (1) {\n        #\
    \ See if n % m is prime and return the smallest m <= n <= m.\n        my $n_prime\
    \ = Math::Prime::prime_check($n);\n        if ($n_prime != -1 && $n_prime < $m)\
    \ {\n            $m = $n_prime;\n        }\n        elsif ($m == $n) {\n     \
    \       goto end;\n        }\n        else {\n            $n = $m;\n        }\n\
    \    }\n    sub end { $n }\n}", "    my(@factors);\n    my(@primes);\n    my($i,\
    \ $j, @p, $x);", "    for (my $i = 2; $i <= $n; $i++) {\n        my $p = $i;\n\
    \        for (; $i % $p == 0; $p += $p) { $p--; }\n        if ($p <= 1)\n    \
    \        return $p;\n    }\n    return $n;\n}", "    my(@factors);\n    my($i);",
  '    my(@factors) = (1);', "    my $n = $self->_check($n);\n    $n -= 1;\n    while\
    \ (!$self->_is_prime($n)) {\n        $n -= 1;\n    }\n    return $n;\n}", "  \
    \  my %factors;\n    my $i = 2;\n    while ($i <= $n) {\n        my $j = 2;\n\
    \        while ($j <= $i) {\n            if ($n % $j == 0) {\n               \
    \ %factors = ();\n                return $j;\n            }\n            $j++;\n\
    \        }\n        $i++;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt's\
    \ a little different that the algorithm given on Wikipedia, since it seems to\
    \ assume that all prime numbers are multiples of themselves and all composites\
    \ are multiples of less than their square root. That's not necessarily the case\
    \ and thus doesn't give a correct result. I also didn't find my version to be\
    \ very efficient, but I didn't investigate that too much.\n<|/ c |>\n<| c |>\n\
    Your version is better, because it takes the prime factors as input rather than\
    \ calculating them from n.\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted\
    \ it. I think that's why I posted my version as an answer, because it works regardless\
    \ of whether they're prime or composite.\n<|/ c |>\n<| c |>\n`2` is a prime number,\
    \ so this should give `2` as a result... But it doesn't, since you're using `sqrt($n)`\
    \ as a base for your loop.\n<|/ c |>\n<| c |>\nI think you misread the post. I'm\
    \ not calculating any prime factors anywhere in the algorithm. I'm not finding\
    \ the largest prime factor in any way except by dividing by 2, 3, 5, 7, and so\
    \ on. I'm not even looking for `sqrt`. I'm finding the largest factor in the sequence.\
    \ Try it yourself if you don't believe me.\n<|/ c |>\n<| a dscore=1 tags=math,algorithm,primes\
    \ |>\nYou can use the sieve of eratosthenes algorithm to find primes quickly.\n\
    http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n<|/ a |>\n<| c |>\nEratosthenes\
    \ can only find primes, not non-primes.\n<|/ c |>\n<| c |>\nEratosthenes can find\
    \ non primes too.\n<|/ c |>\n<| c |>\nEratosthenes is for finding multiples of\
    \ prime numbers only.\n<|/ c |>\n<| a dscore=0 tags=math,algorithm,primes |>\n\
    I found this one on google: \n<code>", "    my $prime = 0;\n    my $i = 3;\n \
    \   while ($i <= sqrt($n)) {\n        if ($n % ($i) == 0) {\n            $prime\
    \ = $i;\n        }\n        $i += 2;\n    }\n    return $prime;\n}", "    my $i\
    \ = 2;\n    my $max = sqrt($n);\n    while($i <= $max) {\n        if(!is_prime($n))\
    \ {\n            return $i;\n        }\n        $i++;\n    }\n    return $n;\n\
    }", "    my $result = 1;\n    my $limit = sqrt($n);\n    while ($n % $limit ==\
    \ 0) {\n        $result ++;\n        $limit += $limit;\n    }\n    $result;\n\
    }\n</code>\n<|/ a dscore=1 tags=sieve-of-eratosthenes,primes,math,c |>\n<| a dscore=1\
    \ |>\nThe best way to figure out how to do a sieve is to use a pencil and paper,\
    \ and a piece of paper to write a pseudorandom sequence of numbers that would\
    \ meet the requirements.  Then count the primes you find, and look at the numbers\
    \ counted.\nA couple of things that could be causing you problems:\nFirst off,\
    \ you're using sqrt() to find your limit, but you're not checking the return value.\
    \  This means that if you use your first number, it's possible that sqrt() will\
    \ return zero.  You'll need to change your code to something like this:\n<code>\n\
    int largest_prime_factor(int n)\n{\n    int result = 1;\n    int limit = sqrtf(n);\n\
    \    while (n < limit * limit)\n    {\n        if (n % limit == 0)\n        {\n\
    \            result++;\n        }\n        limit += limit;\n    }\n    return\
    \ result;\n}\n</code>\nSecond, your algorithm has flaws.  If you were to run it\
    \ over and over again, the same numbers would come up.  If you were to run it\
    \ enough times, the algorithm will spend enough time making sure that it doesn't\
    \ find the same number twice (but also enough time making sure that each number\
    \ is found exactly once).\n<|/ a tags=sieve-of-eratosthenes,primes,math,c |>\n\
    <| a tags=sieve-of-eratosthenes,primes,math,c |>\nThe issue was with the sqrt\
    \ function. I should have used powf which would make more sense for the task\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=sieve-of-eratosthenes,primes,math,c |>\n\
    The algorithm is very simple. I implemented it in C and it works fine:\n<code>",
  "    $n -= 2 if $n & 1;\n    for my $i (2..($n-1)) {\n        my $d = 1;\n     \
    \   while ($i & $d) {\n            $d <<= 1;\n        }\n        $d = 2 ** $d;\n\
    \        if ($n%$d == 0) {\n            return $d;\n        }\n    }\n}", '    my($ret)
    = -1;', '    my $p2;', "    return 1 if ($n == 1);\n    $n -= 2;\n    while (!($n\
    \ % 2) && $n != 1) {\n        $n--;\n    }\n    return $n;\n}", "    my(@factors);\n\
    \    my($factor);\n    $factor = 1;\n    for (; $n >= 1; $n--) {\n        foreach\
    \ $factor (1..$#factors) {\n            if ($factors[$factor] <= $n) {\n     \
    \           $factors[$factor] = $factors[$#factors];\n                shift @factors;\n\
    \                $factor--;\n            }\n        }\n    }\n    if (@factors)\
    \ {\n        pop @factors;\n        $factor++;\n    }\n    return $factor;\n}",
  "    return 1 if ($n % 2 == 0); # 2 is the only even prime\n    my($max, $prime);\n\
    \    for(my $i = 2 ; $i <= $n ; $i++) {\n        my($j) = @{$self->factors($i)};\n\
    \        if (@{$j} > $max) {\n            $max = $#j;\n            $prime = $i;\n\
    \        }\n    }\n    return $prime;\n}", "    my $max = $n->copy();\n    my\
    \ $i = 1; # To begin with 2\n    while($n->$i->is_prime()) {\n        last unless\
    \ $n->$i->is_prime();\n        $max = $n->copy();\n        $max->$i = $max->$i\
    \ - 1; # Decrement to avoid skipping even numbers\n        $i++;\n    }\n    return\
    \ $max;\n}", "    $n = 0 unless defined $n;\n    my @factors = ();\n    my $factor\
    \ = 2;\n    while(1) {\n        $n /= $factor;\n        push @factors, $factor\
    \ if $n != 1;\n        $factor++;\n    }\n    return $factors[-1];\n}", "    return\
    \ $n if $n <= 1;\n    my($i); # i = 2\n    while ($i <= $n) { # while n >= i\n\
    \        my($j); # j = i\n        while ($j <= $n) { # while n >= j\n        \
    \    my $product = $j; # product = j * i\n            for (my $k = 0; $k <= $i\
    \ - $j; $k++) { # while product >= k\n                $product *= $k; # product\
    \ = product * k\n            }\n            if ($product <= $n) { # if product\
    \ == n\n                return $j;\n            } else { # otherwise\n       \
    \         $j += 1;\n            }\n        }\n        $i += 1;\n    }\n    return\
    \ 1;\n}\n</code>\n<|/ a dscore=0 tags=optimization,algorithm,c |>\n<| c |>\nNice\
    \ breakdown of the problem - thanks! Unfortunately this only seems to work with\
    \ n > 1.\n<|/ c |>\n<| c |>\nI thought you said the problem was for n > 1. What\
    \ is the problem?\n<|/ c |>\n<| c |>\nThe \"problem\" I see with this is that\
    \ the code is written in C (not Perl). Perl is great at looping constructs, but\
    \ it wouldn't help here.\n<|/ c |>\n<| c |>\nThis problem can be solved with any\
    \ language with a for loop, which includes C, C++, Java, JavaScript, Python, PHP,\
    \ VBScript, Delphi, Perl, etc.\n<|/ c |>\n<| c |>\nYeah, I should have been more\
    \ explicit. Just wanted to point out that Perl was a language I wasn't particularly\
    \ familiar with, although it is pretty good. :)\n<|/ c |>\n<| a dscore=0 |>\n\
    You can't use an O(1) algorithm for this, because it's impossible to know whether\
    \ you've found a factor. You've already discovered it once - if you had discovered\
    \ it twice, you'd have had to repeat the loop.\nThere are various ways of dealing\
    \ with this. One way is to use a binary search to find the factors - if you start\
    \ your search at sqrt(n) it will find factors pretty quickly. There are a lot\
    \ of other ways of finding factors - e.g. the Sieve of Eratosthenes which is O(sqrt(n))\
    \ but can get expensive to compute.\n<|/ a tags=optimization,algorithm,c |>\n\
    <| c |>\nBut since it's O(1) the algorithm must have a way to know when it's done\
    \ - right? So what would a solution look like?\n<|/ c ", "    return $n if $n\
    \ == 1 || $n == 2; # n is prime or already largest\n    my $factor = 1;\n    my\
    \ $limit = $n;\n    while ($limit > 1) {\n        while ($limit % 2 == 0) {\n\
    \            $factor++;\n            $limit /= 2;\n        }\n        while ($limit\
    \ % 3 == 0) {\n            $factor++;\n            $limit /= 3;\n        }\n \
    \       while ($limit % 5 == 0) {\n            $factor++;\n            $limit\
    \ /= 5;\n        }\n        while ($limit % 7 == 0) {\n            $factor++;\n\
    \            $limit /= 7;\n        }\n        if ($limit == 1) {\n           \
    \ $factor++;\n        }\n    }\n    return $factor;\n}", "    my $factor = 1;\n\
    \    for(my $i = 1; $i <= $n; $i++)\n    {\n        $factor *= $i;\n        my\
    \ $factor_count = $n % $factor;\n        $n /= $factor;\n        if ($factor_count\
    \ > $factor) {\n            $factor = $factor_count;\n        }\n    }\n    return\
    \ $factor;\n}", "    return 1 unless $n != 1;\n    my $max = 1 while $n % $max;\n\
    \    return $max;\n}", '    $n =~ /^(-?)(\d*)/;', "    my $max_factor = 1;\n \
    \   my $n_factor = 1;\n    while (1) {\n        while ($n % $max_factor == 0)\
    \ {\n            $n_factor++;\n        }\n        if ($n_factor == $max_factor)\
    \ {\n            return $max_factor;\n        }\n        $max_factor++;\n    }\n\
    }", "    if ($n <= 2) {\n        return $n;\n    }\n    # Divide by all known\
    \ prime factors.\n    my($i, @factors) = (0, 2);\n    for ($i = 1; $i <= $n; $i\
    \ += ($i & 1)) {\n        push(@factors, $i);\n        push(@factors, $i * 2);\n\
    \    }\n    # Find the largest.\n    my $largest = 1;\n    my $largest_i = 1;\n\
    \    while ($largest_i <  scalar(@factors)) {\n        my $new_i = $factors[$largest_i]\
    \ + 2;\n        if ($new_i >= $n) {\n            $largest_i = $largest_i + 1;\n\
    \        } elsif ($new_i == $n) {\n            $largest = $factors[$largest_i];\n\
    \            $largest_i = $largest_i + 1;\n        } else {\n            $factors[$largest_i]\
    \ = $new_i;\n        }\n    }\n    return $largest;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nA little bit too slow for my needs. I actually needed the largest\
    \ prime factor in the range, not just one in the list, so I found a faster method.\n\
    <|/ c |>\n<| c |>\nWell, your question was \"*Is there a faster way to do this\
    \ in Perl?*\" I offered a fast but less accurate algorithm for that reason. You\
    \ should post a new question if you want to get a faster and more accurate algorithm.\n\
    <|/ c |>\n<| c |>\nBtw, the algorithm I posted *is* the more correct one for that\
    \ reason. It will work even for non-prime numbers. You would only need one factor\
    \ for non-prime numbers, since all prime factors are multiples of 2.\n<|/ c |>\n\
    <| c |>\nI realize that, and I apologize if my question wasn't clear enough. Your\
    \ algorithm is correct for what I needed in the first place, however, it doesn't\
    \ satisfy my needs. The reason I needed an algorithm in this manner is because\
    \ I needed to write a script that determines primes within a range specified by\
    \ users. I also needed it to run as fast as possible, but I didn't want it to\
    \ take forever to complete.\n<|/ c |>\n<| a dscore=0 tags=factors,primes,perl\
    \ |>\nTry this:\n<code>", "    \n    $n += 1;\n    while ($n < $self->{_max_n}\
    \ && !$self->_is_prime($n)) {\n        $n += 1;\n    }\n    \n    return $n;\n\
    }", "    my $max_prime = &_next_prime_below($n);\n    while (1) {\n        my\
    \ $divisor = $max_prime;\n        my $n_div_2 = $n / 2;\n        while ($n_div_2\
    \ > 1) {\n            if ($n_div_2 % $divisor == 0) {\n                last;\n\
    \            }\n            $divisor++;\n            $n_div_2 = $n / $divisor;\n\
    \        }\n        if ($n_div_2 != 1) {\n            $max_prime = $divisor;\n\
    \        } else {\n            return $max_prime;\n        }\n    }\n}", "   \
    \ my $max = 1;\n    for(my $i = 2; $i <= $n; $i++) {\n        if($n % $i == 0)\
    \ {\n            $max = max($max, $i);\n            while($n % $i == 0) {\n  \
    \              $n /= $i;\n            }\n        }\n    }\n    return $max;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYou should be able to run this with `perl` or with\
    \ `ruby`, but you should not need `-l` in `perl`.\n<|/ c |>\n<| c |>\n, No, I\
    \ cannot. But I do see that `perl -l` works on my system but `perl largest_prime_factor`\
    \ does not.\n<|/ c |>\n<| c |>\n, Thanks. I didn't know `-l` doesn't work in `perl`.\
    \  I should test with other versions of `perl`.\n<|/ c |>\n<| c |>\n, I have added\
    \ an implementation for perl and Ruby.\n<|/ c |>\n<| a dscore=5 |>\nA much simpler\
    \ algorithm, since you only care about factors (and don't care about primes),\
    \ is to simply divide the number by each factor and see if you get any remainder.\
    \  So the idea would be to multiply each number by the highest factor and see\
    \ if you get a remainder.\nFor example, if you're given 10 and you know that you\
    \ can divide by 2 and 5, then you know the answer is 2.  Similarly, if you're\
    \ given 20 and you know that you can divide by 3 and 5, then you know the answer\
    \ is 5.  Thus, if you know all of your factors (and all of your numbers are integers),\
    \ you should be able to just divide them all together, starting with the highest\
    \ factor, and see which one has a remainder.\n<|/ a tags=algorithm,primes,math\
    \ |>\n<| c |>\nThis is O(N), but if you know the factors of N you can also know\
    \ them in linear time.\n<|/ c |>\n<| c |>\nYes, you can.  The question didn't\
    \ specify that N was an integer but that N could be a huge number.  Therefore,\
    \ I assumed it was an integer.\n<|/ c |>\n<| c |>\nOf course, you can precompute\
    \ the factors of N then. :) It's O(1) then.\n<|/ c |>\n<| c |>\nI believe this\
    \ algorithm is O(N), but it might be worth noting that in practice this is probably\
    \ a pretty fast algorithm to implement.\n<|/ c |>\n<| c |>\nA slightly better\
    \ algorithm would be to multiply all the numbers by their highest factor, and\
    \ then divide by the highest.\n", "    $n -= 1;\n    my $m = Math::Math::BigInt->new($n);\n\
    \    my $q;\n    my $p = $m->new($n->bits() - 1);\n    my $i = 1;\n    my $factor\
    \ = 1;", "    # Make n positive so we don't have to check for negative\n    #\
    \ numbers. Only the largest prime is important\n    # because even if it isn't\
    \ a prime the largest prime factor will still\n    # be > than 2.\n    $n = $n\
    \ if $n >= 1;\n    # Check for special cases\n    return 1 if $n <= 1;\n    return\
    \ 2 if $n <= 3;\n    $n--;\n    while ($n % 2 == 0) {\n        $n /= 2;\n    }\n\
    \    while ($n % 3 == 0) {\n        $n /= 3;\n    }\n    while ($n % 5 == 0) {\n\
    \        $n /= 5;\n    }\n    while ($n % 7 == 0) {\n        $n /= 7;\n    }\n\
    \    while ($n % 11 == 0) {\n        $n /= 11;\n    }\n    while ($n % 13 == 0)\
    \ {\n        $n /= 13;\n    }\n    while ($n % 17 == 0) {\n        $n /= 17;\n\
    \    }\n    while ($n % 19 == 0) {\n        $n /= 19;\n    }\n    return $n;\n\
    }", "    my $sqrt = (sqrt($n)) + 1;\n    my $a = $sqrt;\n    my $b = 2;\n    my\
    \ $max_factor = 0;\n    while( $a <= $sqrt ) {\n        my $c = $a*$a;\n     \
    \   $max_factor = $a if ($c > $max_factor);\n        $a++;\n        last if $c\
    \ >= $b;\n        $b++;\n    }\n    return $max_factor;\n}", "    for (my $i =\
    \ 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return\
    \ $i;\n        }\n    }\n}\n</code>\n<|/ a tags=primes,math,algorithm,performance,factorial\
    \ |>\n<| a tags=primes,math,algorithm,performance,factorial |>\nI wanted to write\
    \ a solution to this question.  I did some research and found that some people\
    \ think that the sieve of Atkin is quite slow, which is actually the case if you\
    \ are using it for very large numbers (the naive sieve of Atkin's complexity is\
    \ O(n!), where n is the number of bits in your number).  Here is some code to\
    \ test the speed of sieve of Atkin in Python.\n<code>\nfrom math import sqrt",
  "    my $n;\n    my $is_prime = 1;\n    my $n1;", "    my $n1 = ($n % 2) ? $n+1\
    \ : $n;\n    my $i = 2;\n    my $max = 1;\n    while ($n1 /= $i) {\n        $i++;\n\
    \        if ($i % $max == 0) {\n            $max = $i;\n        }\n    }\n   \
    \ return $max;\n}\n</code>\n<|/ a tags=sieve-of-eratosthenes,ruby,primes dscore=1\
    \ |>\n<| c |>\nYour `is_prime` function is not correct. You are testing for 2\
    \ as a factor and not 1.\n<|/ c |>\n<| c |>\nThanks for catching the bug!\n<|/\
    \ c |>\n<| c |>\nYou do realize that your prime tests are very inefficient right\
    \ now. There are a million numbers that are not prime. You would need a very large\
    \ number to get this to finish within a reasonable time.\n<|/ c |>\n<| a tags=sieve-of-eratosthenes,ruby,primes\
    \ |>\nHere is a very simple way of finding primes up to a limit using an Array\
    \ and some math. Since this is just an exercise, I will not post the code but\
    \ will explain how I did it.\nI used this site to help me to understand how I\
    \ find the primes. Since this is just a simple exercise I did not use the Sieve\
    \ of Eratosthenes as mentioned in the other answers.\nThe main idea of the algorithm\
    \ is to find all primes between the two numbers I specify, and then find the products\
    \ of all the prime factors in between those two numbers.\nI chose the number to\
    \ test as the square root of the target number, since I wanted to find the prime\
    \ factors up to the square root of n. That way we find all the factors of n and\
    \ multiply them all together.\nWe find the factors of n using the following code:\n\
    <code>\ndef factors(n)\n    primes = [2]\n    (2..n).each do |i|\n        primes.each\
    \ { |j| return j if i%j == 0 }\n        primes.concat([primes.last, i/primes.last])\n\
    \    end\nend\n</code>\nIn your question, you said you want to find only the primes\
    \ up to some limit. But there are 2 factors that will make the function slow down\
    \ when n = 10^7. One is the prime number and the other is the fact that every\
    \ prime number will be divisible by all the numbers from 2 to n. As long as n\
    \ is small enough, those factors won't be too much of a problem. In fact, when\
    \ n = 10^7, the prime number is 10^7, which means that we will need to check over\
    \ 10^7 / 10^7 = 10^6 numbers to find all the prime", '    my $highest_prime_factor
    = 1;', "    my($largest);\n    my($i);", "    my %factors = ();\n    my $prime\
    \ = 2;\n    my $divisor = 3;\n    my $limit = $#factors;\n    while ($divisor)\
    \ {\n        if ($n >= $divisor) {\n            my $t = $n / $divisor;\n     \
    \       delete $factors{$t};\n            ++$divisor;\n            last if ($limit\
    \ > $#factors);\n        } else {\n            ++$divisor;\n        }\n    }\n\
    \    return $prime * ($limit + 1);\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt\
    \ seems to me that a factor of 3 will never be eliminated by your algorithm. \
    \ For example, try it on `16`.\n<|/ c |>\n<| c |>\n: Ah yes, you are correct.\
    \ I think I had the terminology a little wrong. I meant to say \"prime factors\"\
    \ (of n), not factors of n.\n<|/ c |>\n<| c |>\n: Also, the terminology you are\
    \ using is a little off. Factors are the numbers that are used to determine what\
    \ numbers can be expressed as a product of two smaller numbers, which is what\
    \ you are doing.\n<|/ c |>\n<| c |>\nOkay, I fixed the terminology and removed\
    \ an extra factor of 2. And yes, you were correct about my terminology. Thanks\
    \ for pointing this out.\n<|/ c |>\n<| a dscore=2 |>\nHere is my solution in Perl.\n\
    It does have a few redundancies but it does work and it uses no recursion.\n<code>",
  "    return $n if $n == 1;\n    my($factors{2});\n    my $p = 2;\n    my $i = 1;\n\
    \    while ($p <= $n) {\n        $p = $i * $p;\n        $factors{$p} = $i;\n \
    \       $i += 1;\n    }\n    return $factors{$n};\n}\n</code>\n<|/ a dscore=1\
    \ tags=primes,math,algorithm,ruby,ruby-on-rails |>\n<| a tags=primes,math,algorithm,ruby,ruby-on-rails\
    \ |>\nThis is my implementation of your problem:\n<code>", "    my $x = 2;\n \
    \   my $max = 1;\n    while($x <= $n) {\n        if(!is_prime($n)) {\n       \
    \     $max = $x;\n        }\n        $x = $x * $x + 1;\n    }\n    return $max;\n\
    }", "    my $max = -1;\n    for (my $i=2; $i <= $n; $i++) {\n        $max = $i\
    \ if $n % $i == 0;\n    }\n    return $max;\n}", "    my $p = 2;\n    while ($p\
    \ * $p <= $n) {\n        last unless $n % $p;\n        $p = $p * 2;\n    }\n \
    \   return $p if $n > 2;\n    return 1;\n}", "    return 1 if $n == 2 or $n ==\
    \ 3 or $n == 5;\n    my($max,$i,$j) = @{$n}{qw(2 3 5)};\n    $max = $j; # $max\
    \ is current largest\n    for (my $i = $j+1; $i <= $j+5; $i++) {\n        if ($n\
    \ % $i == 0) {\n            $max = $i;\n            last;\n        }\n    }\n\
    \    return $max;\n}", "    # Sieve of Eratosthenes http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    # n = 2^p - 1, p = 2, 4...\n    if ($n =~ /^(2?(?:4|8)5)$/) {\n      return\
    \ $n if $n >= 3;\n      return 2;\n    }\n    my @primes = ();\n    my $p = 2;\n\
    \    my $prime = 2;\n    my $nn = $n;\n    while ($nn > 0) {\n      # This check\
    \ is to handle the case where n is a prime number.\n      if ($nn & 1) {\n   \
    \     if ($n % $prime) {\n          push(@primes, $prime);\n        }\n      }\n\
    \      $p++;\n      $nn--;\n      # Update $prime\n      if ($p > $prime) {\n\
    \        $prime = $p;\n      }\n    }\n    return $primes[0];\n}", "    return\
    \ 1 if ($n == 2);\n    my $m = 0;\n    my $p = 1;\n    my $q = 1;\n    for (my\
    \ $i = 3; $i < $n; $i += 2) {\n        $m = $p * $q; # multiple\n        $p =\
    \ $q; # 'previous' divisor\n        $q = $m; # 'next' divisor\n    }\n    return\
    \ $p if ($p == $n);\n    return $n;\n}", "    my $limit = 2000;\n    my $x = 2;\n\
    \    my $limitFactor;", "    my $i = 2;\n    my $x;\n    while ($i <= $n && $n\
    \ % $i == 0) {\n        $x++;\n        $i++;\n    }\n    return $x;\n}", "   \
    \ if ($n <= 1) {\n        return 1;\n    }\n    my $m = Math::Math::BigInt->new(1)->bmodin($n);\n\
    \    if ($m->is_one()) {\n        return 1;\n    }\n    while ($m->is_one()) {\n\
    \        $m = Math::Math::BigInt->new(1)->bmodin($n);\n    }\n    return $m;\n\
    }", "    # Sieve of Eratosthenes to find primes <= $n.\n    # First check all\
    \ odd numbers, for efficiency.\n    if ($n & 1) {\n        for my $i ($n, 3) {\n\
    \            # Odd numbers are composite. Check up to sqrt($n).\n            for\
    \ my $j (0 .. $i-1) {\n                my $m = ($j + $i / $j) % $j; # $j * $i\n\
    \                if ($m == 0)  # All multiples of $j have been eliminated.\n \
    \                   continue;\n                $i -= $m;           # $j - $m\n\
    \                push, $i;\n            }\n        }\n    }\n    else {\n    \
    \    # All even numbers except two have prime factors other than 2.\n        #\
    \ Since 2 is a non-prime, we skip it here.\n        my $i = 2;\n        push,\
    \ [$i, 1];\n        while ($i <= $n) {\n            for my $j ($i, $n, $i ** 2)\
    \ {\n                push, [$j, 1];\n                while (1) {\n           \
    \         $j += $i;\n                    push, [$j, 1];\n                    last\
    \ if $j >= $n;\n                }\n            }\n            $i += 2;\n     \
    \   }\n    }\n    my $max = -1;\n    foreach my $x (@prime_factors) {\n      \
    \  if ($x->[0] > $max) {\n            $max = $x->[0];\n        }\n    }\n    return\
    \ $max;\n}", "    my $i = 2;\n    my $limit = $n;\n    my $largest = 0;\n    my\
    \ $largestP = 1;\n    while($i <= $limit) {\n        while($n % $i == 0) {\n \
    \           $largest = $i;\n            $largestP = sqrt($n);\n            $n\
    \ = $n / $i;\n        }\n        $i++;\n    }\n    return $largestP;\n}", "  \
    \  my $i = 1;\n    my $prime = 1;\n    my $max = 1;\n    my $test = 1;\n    my\
    \ $factor = 1;\n    my $found = 0;", '    return $n if $n <= 1;', "    my $max_prime_factor\
    \ = 1;\n    while (1) {\n        if ($n % $max_prime_factor == 0) {\n        \
    \    return $max_prime_factor;\n        }\n        $max_prime_factor++;\n    \
    \    my $next_max_prime_factor = $max_prime_factor + 1;\n        $n /= $next_max_prime_factor;\n\
    \        unless ($next_max_prime_factor > 2) {\n            return $next_max_prime_factor;\n\
    \        }\n    }\n}", "    $n -= 2 if $n % 2 == 0;\n    my $i = 2;\n    while\
    \ (1) {\n        $n = 3*$n + 1 if $n % $i == 0;\n        $i += 2;\n        return\
    \ $n if $n > 3;\n    }\n}", '    $n = abs($n);  # Ignore negative values.', " \
    \   my $i = 1;\n    my $p = 2;\n    my $limit = $n >> 1;\n    my $max = 2;\n \
    \   while($i <= $limit and $p < $max) {\n        if($n % $p == 0) {\n        \
    \    $max = $p;\n        }\n        $p++;\n        $i++;\n    }\n    return $max;\n\
    }", "    my($max_factor);\n    my($is_prime) = defined($n) ? is_prime($n) : 1;\n\
    \    \n    # First try testing for a composite (composites cannot be factors of\
    \ primes):\n    if ($is_prime) {\n        while (1) {\n            $n = $n / 2;\n\
    \            $is_prime = is_prime($n);\n            if ($is_prime) {\n       \
    \         # Found a prime, stop testing factors.\n                last;\n    \
    \        }\n        }\n    }", '    my $prime;', "    my $largest_prime_factor\
    \ = -1;\n    while (!is_prime($n) && $n > 1) {\n        $n = $n % $largest_prime_factor;\n\
    \    }\n    return $largest_prime_factor;\n}", "    my $i = $n;\n    my $p = 1;\n\
    \    my $factor = 2;\n    while ($i > 0) {\n        my $m = $i / $factor;\n  \
    \      $i = $i % $factor;\n        if ($m == 1) {\n            last if ($p < $factor);\n\
    \            $p = $factor;\n        }\n        else {\n            $factor++;\n\
    \        }\n    }\n    return $p;\n}", '    my($i, $max, $p, $q, $nmax, $pmax,
    $qmax);', "    return 2 if $n <= 2;\n    return $n if $n > $primes_cache{$_} for\
    \ keys %primes_cache;\n    return $primes_cache{$_} for ($i = 3; $i <= $n/2; $i\
    \ += 2) {\n        return $n if !($n % $i) && !($n % ($i*$i));\n    }\n    return\
    \ $n;\n}", "    die \"Usage:  largest_prime_factor(number)\\n\"\n        if !\
    \ defined($n);", "    my ($i, $k, $p);\n    if ($n > 1) {\n        for ($i = 2;\
    \ $i <= sqrt($n); $i++) {\n            $k = $n % $i;\n            $p = $i if $k\
    \ != 0;\n            if ($k > 0) {\n                $n = $p;\n            } else\
    \ {\n                $n = ($n - $k) / $i;\n            }\n        }\n    }\n \
    \   return $n;\n}", "    \n    my($largest) = -1;\n    my($prime);\n    \n   \
    \ foreach $prime (@primes) {\n        my($factor) = int $n/$prime;\n        my($test);\n\
    \        if ($factor != 1) {\n            $test = $n % $factor;\n            if\
    \ ($test == 0) {\n                if ($factor > $largest) {\n                \
    \    $largest = $factor;\n                }\n                else {\n        \
    \            last;\n                }\n            }\n            else {\n   \
    \             next;\n            }\n        }\n    }\n    return $largest;\n}",
  "    # Sieve of Eratosthenes\n    # http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    my($sieven_numbers);\n    my($i, $j, $next_i, $next_j);\n    $n = $n >> 1;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $sieven_numbers[$i] = $i;\n    }\n\
    \    for ($i = 2; $i * $i < $n; $i++) {\n        $j = 2;\n        $next_i = $i\
    \ + 1;\n        $next_j = $i * 2;\n        while ($next_i * $next_j < $n) {\n\
    \            $sieven_numbers[$next_i] = $next_j;\n            $sieven_numbers[$next_j]\
    \ = $next_i;\n            $next_j++;\n            $next_i++;\n        }\n    }\n\
    \    my($largest = 1);\n    for ($i = 0; $i < $n; $i++) {\n        my($candidate);\n\
    \        while ($sieven_numbers[$i]) {\n            $candidate = $sieven_numbers[$i];\n\
    \            $sieven_numbers[$i] = $sieven_numbers[$candidate];\n            $sieven_numbers[$candidate]\
    \ = $i;\n            $i = $candidate;\n        }\n        if ($i > $largest) {\n\
    \            $largest = $i;\n        }\n    }\n    return $largest;\n}\n</code>\n\
    <|/ a tags=primes,math,algorithm dscore=4 |>\n<| c |>\nThe `if` statement in the\
    \ while loop is redundant, since `sieven_numbers[$next_i]` and `$next_j` will\
    \ always be equal to zero if the while loop runs to completion.\n<|/ c |>\n<|\
    \ a |>\nPython implementation for Sieve of Eratosthenes:\n<code>\nimport math\n\
    N = 100", '    my($i, $factor, $limit);', "    my $prime = prime_sieve($n);\n\
    \    my $prime_candidate = 1;\n    my $largest = 1;\n    while(1) {\n        $prime_candidate\
    \ = $prime->[$prime_candidate];\n        if ($prime_candidate < $largest) {\n\
    \            $largest = $prime_candidate;\n        }\n        $prime->[$prime_candidate]\
    \ = 1;\n        if ($prime_candidate > $n) {\n            last;\n        }\n \
    \   }\n    return $largest;\n}", "    $n = ( $n > 1 ) ? $n : 1;\n    while ( $n\
    \ != 1 ) {\n        my $q = $n%$n;\n        $n = ( $q > 1 ) ? $q : $n;\n    }\n\
    \    $n\n}", "    $n = lc($n);\n    if ($n == 0) {\n        $n = 1;\n    }\n \
    \   my($i = $n); # largest known prime factor\n    while ($i > 0) {\n        my\
    \ $candidate = 2;\n        while ($candidate < $i) {\n            $i = $i / $candidate;\n\
    \            $candidate++;\n        }\n        if ($i == 1) {\n            $i\
    \ = 1;\n        }\n        elsif ($i == $candidate) {\n            $i = $candidate;\n\
    \        }\n        elsif ($candidate > $i) {\n            $i = $candidate;\n\
    \        }\n        else {\n            $i--;\n        }\n    }\n    return $i;\n\
    }", "    # See if n is a perfect square (has prime factors other than 1 or itself).\n\
    \    # >>> smallest_prime_factor(1024)\n    # 2\n    return $n if $n == $n **\
    \ 2;\n    my $i = 2;\n    my $test = 2;\n    my $prime_factor = 1;\n    my $smallest_prime_factor\
    \ = 1;\n    while ( $i * $i <= $n ) {\n        if ( $n % $i == 0 ) {\n       \
    \     ++$test;\n            ++$i;\n        } else {\n            ++$prime_factor;\n\
    \            ++$i;\n        }\n    }\n    return $smallest if $test == $smallest_prime_factor;\n\
    \    return $smallest_prime_factor;\n}\n</code>\n<|/ a dscore=5 tags=algorithm,primes,math\
    \ |>\n<| c |>\nI did a test where I calculated the largest prime factor of 100\
    \ and got 29, which was obviously wrong.\n<|/ c |>\n<| c |>\nYour solution isn't\
    \ actually correct because even though a perfect square has prime factors other\
    \ than 2 and 3, your algorithm will return 1 as the largest prime factor because\
    \ it thinks that 2 has no divisors.\n<|/ c |>\n<| c |>\nThat is true, but only\
    \ if the number to be factored is prime. Otherwise a number that isn't prime will\
    \ have a prime factor of 1, therefore your algorithm will always return 1.\n<|/\
    \ c |>\n<| c |>\nYou don't need to know what a prime is before determining if\
    \ it is prime, you can easily skip over every number less than a number and check\
    \ only the ones that are composite.  No need to search the whole range, just one\
    \ number.\n<|/ c |>\n<| c |>\n: I like that idea; however, since you only need\
    \ to check if a number is a factor of $n, you can do better than O(N^2). If $n\
    \ divides p, then you can test p % $n to see if it is prime. Since you can do\
    \ that in O(sqrt(n)) time, the overall complexity is O(sqrt(N)) instead of O(N^2).\
    \ Of course, that's only true if you don't need to know what all the prime factors\
    \ of $n are, since you can just test $n % p for the largest prime factor.\n<|/\
    \ c |>\n<| a tags=algorithm,primes,math |>\nI believe I read this question on\
    \ http://programmers.stackexchange.com.  It's actually for finding the smallest\
    \ prime factor of a large number, but the same basic technique can be used for\
    \ finding the largest prime factor.\nIt seems silly to check all numbers up to\
    \ sqrt(n) when all you need to check is the primality of some ", "    if ($n !=\
    \ 1) {\n        foreach my $m (2..$#$n) {\n            my $r = 2;\n          \
    \  my $s = $n->copy();\n            foreach my $m (2..$#$s) {\n              \
    \  $r = 2 * $m + $r;\n            }\n            if ($r == $n) {\n           \
    \     return $m;\n            }\n        }\n    }\n    return 1;\n}", "    \n\
    \    my($p, $i);\n    my($max);\n    \n    for (my $i=2 ; $i<=$n ; $i++) {\n \
    \       my $tmp = $n;\n        $tmp /= $i;\n        $max = $i if $tmp > $max;\n\
    \    }\n    return $max;\n}", "    my($sqrt_n = int(sqrt($n)));\n    my $max_pf;",
  "    my $i = 1;\n    my $k = 1;\n    my $max_k = -1;\n    my $max_i = 1;\n    while($i\
    \ <= sqrt($n)) {\n        while($n % $i == 0) {\n            my $j = 1;\n    \
    \        while($j * $j <= $i) {\n                last if($j % $i == 0);\n    \
    \            $j++;\n            }\n            if($j * $j > $i) {\n          \
    \      $max_k = max($max_k, $k);\n                $max_i = $i;\n            }\n\
    \            $i++;\n        }\n        $k++;\n    }\n    return $max_k;\n}", " \
    \   my $ret = 1;\n    for(my $x = 2; $x <= $n; $x++) {\n        while($n % $x\
    \ == 0) {\n            $ret *= $x;\n            $n /= $x;\n        }\n    }\n\
    \    $ret;\n}", "    my $max = prime_number($n); # O(sqrt(n)) time\n    my $factor\
    \ = 1;\n    while($max % $factor != 0) {\n        $factor *= $max;\n        ++$max;\n\
    \    }\n    return $factor;\n}", "    my($max);\n    while (1) {\n        my($test);\n\
    \        my $test = ($n % 2) ? $n : (2**$n/$n-1);\n        $test = $1 if $test\
    \ > $max;\n        $max = $test;\n        last if $test < 2;\n        $n /= $test;\n\
    \    }\n    return $max;\n}\n</code>\n<|/ a tags=python,primes dscore=0 |>\n<|\
    \ c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=0 tags=python,primes |>\n<code>", "    my $n =\
    \ $n;\n    for (my $p = 1; $p <= $n; $p++) {\n        if ($n % ($p) == 0) {\n\
    \            $n = $p;\n        }\n    }\n    return $n;\n}", "    my $max = prime_factors($n);\n\
    \    $max == 1 || die \"No prime factors found\" if $max == -1;\n    $max == 1\
    \ ? $n : $max;\n}", "    if ($n >= 2) {\n        if ($n % 2 == 0) {\n        \
    \    return 2;\n        }\n        $n -= 1;\n    }\n    $n -= 1;\n    while ($n\
    \ % 2 == 0) {\n        $n -= 1;\n    }\n    while ($n % 3 == 0) {\n        $n\
    \ -= 1;\n    }\n    while ($n % 5 == 0) {\n        $n -= 1;\n    }\n    if ($n\
    \ == 1) {\n        return 2;\n    }\n    while ($n != 1) {\n        $n /= 2;\n\
    \        if ($n % 2 == 0) {\n            $n -= 1;\n        }\n        if ($n %\
    \ 3 == 0) {\n            $n -= 1;\n        }\n        if ($n % 5 == 0) {\n   \
    \         $n -= 1;\n        }\n    }\n    return $n;\n}", "    my($factor) = 1\
    \ if $n < 2;\n    my($prime_factors);\n    my($max);\n    my $limit = int((log($n)+log(2))/log(2));\n\
    \    for(my $i = 1; $i <= $limit; $i++) {\n        my($candidate) = ($n%$i);\n\
    \        if($candidate == 0) {\n            $candidate = 1;\n            while(1)\
    \ {\n                $factor = $i;\n                $n = ($n//$factor) * $factor;\n\
    \                if($n == 1) {\n                    return $factor;\n        \
    \        }\n                if($n != $candidate) {\n                    last;\n\
    \                }\n                ++$i;\n            }\n        }\n    }\n \
    \   return $max;\n}", "    my(@factors) = ();\n    for (my $i = 2; $i <= $n; $i++)\
    \ {\n        while (1) {\n            if ($n % $i == 0) {\n                push\
    \ (@factors, $i);\n                last;\n            }\n            push (@factors,\
    \ $i + ($n / $i));\n            ($n) = ($n%$i);\n        }\n    }\n    return\
    \ @factors[-1];\n}", "    my $max = prime_facs( $n );\n    my $max_index = 0;\n\
    \    foreach my $index ( 0..$#{$max} ) {\n        if ( $max->[$index] > $n ) {\n\
    \            last;\n        }\n        elsif ( $max->[$index] == $n ) {\n    \
    \        return $max->[$index];\n        }\n    }\n    die \"No largest prime\
    \ factor found!\";\n}", "    my(@factors) = (2, 2);\n    \n    for(my $i = 2;\
    \ $i <= $n; $i++) {\n        $factors[$i] = $i; # keep track of factor for later\
    \ use.\n        for(my $j = $i * $i - $i; $j > 0; $j--) {\n            next unless\
    \ $j % $i;\n            $factors[$j] = $i;\n        }\n    }\n    \n    # return\
    \ largest factor in array\n    my $greatest_factor = @factors\n        ? $factors[-1]\n\
    \        : 0;\n    \n    return $greatest_factor;\n}", "    $n = abs($n);\n  \
    \  if ($n <= 1) {\n        return $n;\n    }\n    my $i = 2;\n    while (1) {\n\
    \        my $m = ($n % $i) + $i;\n        if ($m == $n) {\n            return\
    \ $i;\n        }\n        elsif ($m < $n) {\n            $i = $m;\n        }\n\
    \        else {\n            $n = $m;\n        }\n    }\n}", "    my $max = 1;\n\
    \    for (my $i = 3; $i <= sqrt($n); $i += 2) {\n        while (1) {\n       \
    \     my $test = $n % $i;\n            if ($test == 0) {\n                return\
    \ $max;\n            } elsif ($test == 1) {\n                last;\n         \
    \   } else {\n                $max++;\n            }\n        }\n    }\n    return\
    \ $max;\n}", "    $n *= 2;\n    my $i = 1;\n    my $prime = 2;\n    my $factor\
    \ = 2;\n    while( ($n % $prime) != 0) {\n        $n = ($n/$prime)->floor;\n \
    \       $factor += 1;\n    }\n    return $factor;\n}", "    return 1 if ($n ==\
    \ 1);\n    # See Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ \n    # and https://en.wikipedia.org/wiki/Multiple_prime_factors for discussion\n\
    \    # of why this algorithm is as fast as possible.\n    my(@primes) = ();\n\
    \    my($limit);\n    my($factor);", "    my $result = 2;\n    my $i;\n    for\
    \ ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return\
    \ $i;\n        }\n    }\n}", '    my ($i, $p);', "    # Sieve of Erastosthenes\
    \ from http://stackoverflow.com/a/394292/1940506\n    if ($n <= 1) {\n       \
    \ return $n;\n    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
