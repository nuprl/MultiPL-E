name: HumanEval_147_get_max_triples
language: pl
prompt: "# You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n# For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i\
  \ - i + 1.\n# Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
  \ k, \n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# >>> get_max_triples(5)\n\
  # 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7,\
  \ 13).\nsub get_max_triples {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_max_triples;\n\
  \        if(eq_deeply($candidate->(5),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(6),4)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),36))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),53361))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my;\n    for my $i (1..$n) {\n        for my $j ($i..$n) {\n  \
    \          push, ($i, $j, $i) + 1;\n        }\n    }\n    return scalar(@triples)\
    \ / (3 * $n);\n}", "    if (! $n) {\n        return 0;\n    }\n    my @a = ();\n\
    \    for (my $i = 0; $i < $n; ++$i) {\n        for (my $j = 0; $j < $n; ++$j)\
    \ {\n            for (my $k = 0; $k < $n; ++$k) {\n                push (@a, $i\
    \ * $i - $i + 1 );\n                push (@a, $j * $j - $j + 1);\n           \
    \     push (@a, $k * $k - $k + 1);\n            }\n        }\n    }\n    return\
    \ (scalar( sort {$a <=> $b} @a));\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| a\
    \ tags=perl,arrays dscore=0 |>\nThis solution does more calculations than required\
    \ and doesn't use the sort function, instead it uses List::Util::reduce which\
    \ is a more compact version of grep->map:\n<code>", "    my @a = (1..$n);\n  \
    \  my(@result,$i,$j,$k);\n    for(my $i = 0; $i <= $n-1; $i++) {\n        for(my\
    \ $j = 0; $j <= $n-1; $j++) {\n            for(my $k = 0; $k <= $n-1; $k++) {\n\
    \                if($a[$i] + $a[$j] + $a[$k] eq $n*$n*$n) {\n                \
    \    push(@result,[$i,$j,$k]);\n                    last;\n                }\n\
    \            }\n        }\n    }\n    return scalar(@result);\n}\n</code>\n<|/\
    \ a tags=algorithm dscore=0 |>\n<| a dscore=0 |>\nHere is the Python solution\
    \ I came up with:\n<code>\ndef find_triples(n):\n    triples = []\n    for i in\
    \ range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(j,\
    \ n + 1):\n                if i*i + j*j + k*k == n*n:\n                    triples.append((i,\
    \ j, k))\n    return len(triples)\n</code>\nIt is not as compact as a recursive\
    \ solution, but it is easier to understand.\n<|/ a tags=algorithm |>\n<| a tags=algorithm\
    \ |>\nJava:\n<code>\npublic static int getMaxTriples(int n) {\n    int triples\
    \ = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j < n;\
    \ j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (i*i\
    \ + j*j + k*k == n*n) {\n                    triples++;\n                }\n \
    \           }\n        }\n    }\n    return triples;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nIn a very simple way:\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;", "    my(@a) = (1) x $n;\n    my($i) = 0;\n    my($j)\
    \ = 0;\n    my($k) = 0;", "    my @a;\n    for(my $i = 0; $i <$n; $i++){\n   \
    \     push(@a,$i*$i-$i+1);\n    }\n    my $m=0;\n    my $cnt=0;\n    my $j;\n\
    \    for(my $i = 0; $i <$n; $i++){\n        for(my $j = 1; $j <= $i; $j++){\n\
    \            $cnt += $a[$i]+$a[$j]+$a[$j-1]+$a[$i-1]+$a[$j+1]+$a[$k-1]+$a[$k+1]+$a[$k];\n\
    \            if($cnt >= $m){\n                $m = $cnt;\n                $k =\
    \ $i;\n            }\n        }\n    }\n    return $m;\n}\n</code>\n<|/ a |>\n\
    <| a tags=algorithm |>\nI like David's answer because it's simple, efficient,\
    \ and easy to understand, but I also like that his code uses recursion. So, here's\
    \ my solution that doesn't use recursion.\nThe key is to notice that if a[i] =\
    \ a[j] + a[j-1] + a[k], then if a[i] < a[j]+a[k], then the triplet (a[i], a[j],\
    \ a[k]) is also a triplet (a[j], a[k], a[k]), and if a[i] > a[j]+a[k], then the\
    \ triplet (a[i], a[j], a[k]) is also a triplet (a[j], a[k], a[k]). The solution\
    \ to this problem is then to count the number of triplets (a[i], a[j], a[k]) where\
    \ i < j < k.\nWe know that the value of a triplet (i, j, k) will be <= a[j]+a[k]\
    \ <= a[j]+a[k] because a[i] < a[j]+a[k].\nWe can use this property to find the\
    \ solution we want.\n<code>\ndef solve(arr):\n    ans = 0", "    my($a, $i, $j,\
    \ $k) = ();\n    \n    for ($i = 0; $i < $n; $i++) {\n        $a[$i] = $i * $i\
    \ - $i + 1;\n    }\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            if ($i ne $j) {\n                for ($k = 0; $k\
    \ < $n; $k++) {\n                    if ($k ne $j && $k ne $i) {\n           \
    \             $a[$i] += $a[$k] + $a[$k];\n                    }\n            \
    \    }\n            }\n        }\n    }\n    return $n if $a[$n] == 0; #empty\
    \ array\n    return scalar @{$a}{-1};\n}", "    my @a;\n    my @temp;\n    my\
    \ $i = 0;\n    my $temp;\n    my $j = 0;\n    my $k;\n    for ($i = 0; $i < $n;\
    \ ++$i) {\n        push(@a, $i);\n    }\n    for ($j = 1; $j < $n; ++$j) {\n \
    \       for ($k = 1; $k <= $n; ++$k) {\n            $temp = 0;\n            for\
    \ ($i = $j; $i < $n; ++$i) {\n                $temp += $a[$i] * $a[$i] * $a[$i];\n\
    \            }\n            if ($temp == $temp + $a[$j] * $a[$k] + $a[$j] * $a[$j]\
    \ * $a[$k]) {\n                push(@temp, $i, $j, $k);\n            }\n     \
    \   }\n    }\n    if (scalar(@temp) == 0) {\n        return 0;\n    } else {\n\
    \        return scalar(@temp);\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,algorithm,hash,perl,performance\
    \ dscore=0 |>\nA solution without using any external library:\n<code>", "    my(@a)\
    \ = ();\n    for (my $i = 0; $i <= $n; $i++) {\n        for (my $j = 0; $j < $i;\
    \ $j++) {\n            for (my $k = $i + 1; $k <= $n; $k++) {\n              \
    \  if ($i * $j + $k == $i * $k + $j) {\n                    push(@a, $i * $j +\
    \ $k);\n                }\n            }\n        }\n    }\n    return scalar(@a);\n\
    }\n</code>\n<|/ a tags=algorithm,arrays,perl |>\n<| c |>\nWow, didn't expect this\
    \ answer to be this quick! Thank you very much for your answer! I tried to follow\
    \ your algorithm and I understand it very well. Just to clarify something, I tried\
    \ to do the code with 1 loop, instead of nested loops, and I got a runtime of\
    \ about `O(n ^2)`. So would you say that your code runs in `O(n)` time ? Or did\
    \ you also use the nested loops to improve the runtime ?\n<|/ c |>\n<| c |>\n\
    The inner loop is used to iterate over the subarrays of `a` from index 1 to `$i`\
    \ (first subarray is `a[0..$i]`). So, if your `a` has `n` elements and you want\
    \ to calculate for element `i` then you will have `n` inner loops which is `O(n*n)`.\
    \ Also, your code will run `O(n)` time when `a` has `n` elements and each element\
    \ has `i` elements. Am I missing something ?\n<|/ c |>\n<| c |>\nYeah I understand\
    \ how this works, my bad I didn't think about it :D Thank you for taking the time\
    \ to explain and provide a solution!\n<|/ c |>\n<| a dscore=0 tags=algorithm,arrays,perl\
    \ |>\nThe first thing to point out is that your approach is basically counting\
    \ the number of triplets, not finding the triplets. You could write a simple function\
    \ as follows:\n<code>", "    my $a = [1..$n];\n    my $i = 0;\n    my $triple\
    \ = 0;\n    while(1) {\n        $triple = $triple+1;\n        foreach my $j ($i..$n-1)\
    \ {\n            foreach my $k ($j+1..$n-1) {\n                if ($j<=$k) {\n\
    \                    foreach my $m ($i+1..$n-1) {\n                        next\
    \ if $a{$m} > $a{$i} + $a{$j} + $a{$k};\n                        if ($a{$m} %\
    \ 3 == 0) {\n                            return $triple;\n                   \
    \     }\n                    }\n                }\n            }\n        }\n\
    \        $i = $i+1;\n    }\n}\n</code>\n<|/ a |>\n<| a tags=math,python,arrays,perl\
    \ dscore=0 |>\n<code>\ndef get_triples(n):\n  for i in range(1,n):\n    for j\
    \ in range(1,n-i):\n      for k in range(j,n):\n        if (j<=k) and (k != i):\n\
    \          yield i,j,k\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\ndef count_triples(n):\n\
    \    s = 0\n    for i in range(1,n+1):\n        for j in range(1,n):\n       \
    \     for k in range(1,n):\n                if i != j and i != k and j != k and\
    \ (i+j+k) == n:\n                    s += 1\n    return s\n</code>\n<|/ a tags=math,python,arrays,perl\
    \ |>\n<| c |>\n`return count`? Do you know what that does? That is nonsense. Did\
    \ you mean `return s`?\n<|/ c |>\n<| c |>\nSorry. Yeah, I meant return s.\n<|/\
    \ c |>\n<| a |>\n<code>\ndef count_triples(n):\n    count = 0\n    for i in range(1,n+1):\n\
    \        for j in range(1,n):\n            for k in range(1,n):\n            \
    \    if i != j and i != k and j != k and (i+j+k) == n:\n                    count\
    \ += 1\n    return count", "    my($a) =  [];\n    for($i=1; $i<=$n; $i++) {\n\
    \        for($j=1; $j<=$n; $j++) {\n            for($k=1; $k<=$n; $k++) {\n  \
    \              if( ($i*$i-$j*$j) %3 != 0) {\n                    push (@a, [$i,\
    \ $j, $k]);\n                }\n            }\n        }\n    }\n    my $count\
    \ = 0;\n    for($i=1; $i<=$n; $i++) {\n        foreach my $el(@a) {\n        \
    \    if(($el->[0]==$i) && ($el->[1]==$i) && ($el->[2]==$i)) {\n              \
    \  $count++;\n            }\n        }\n    }\n    return $count;\n}", "    my(@a);\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = $i; $j <= $n; $j++)\
    \ {\n            for(my $k = $i; $k <= $n; $k++) {\n                if($i + $j\
    \ + $k == 3 && $i * $i * $i == 3) {\n                    push (@a, $i, $j, $k);\n\
    \                }\n            }\n        }\n    }\n    if(@a) {\n        return\
    \ scalar(@a);\n    }\n    else {\n        return 0;\n    }\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThat code doesn't work, for example for `n = 5` the answer\
    \ is 0, while it should be 4.\n<|/ c |>\n<| c |>\n, thanks, fixed.\n<|/ c |>\n\
    <| a tags=algorithm dscore=2 |>\nWe can use dynamic programming to calculate the\
    \ number of triples in an array. \nLet \n<code>\na[i] be the number of triples\
    \ in an array with index 0 <= i < n \n</code>\nThen \n<code>\na[0] = 1\na[1] =\
    \ a[0] + a[1] = 1\na[2] = a[1] + a[2] = 1\na[3] = a[2] + a[3] = 2\na[4] = a[3]\
    \ + a[4] = 4\n</code>\nIf a[i] and a[i-1] are not equal then a[i] = a[i-1] + a[i]\n\
    So the final answer is: \n<code>\nint countTriples(int n) \n{\n    int  a[n];",
  "    my @a;\n    for(my $i=0;$i<$n;$i++){\n        for(my $j=0;$j<$i;$j++){\n  \
    \          for(my $k=0;$k<$j;$k++){\n                if($a[$i]+$a[$j]+$a[$k]==($i+$j+$k)){\n\
    \                    $a[$i]+=$a[$j]+$a[$k];\n                    splice(@a,$i,1);\n\
    \                    $i=$j=$k=0;\n                }\n            }\n        }\n\
    \    }\n    return scalar(@a);\n}", "    my($a = [0]*$n);\n    for (my $i = 1;\
    \ $i <= $n; $i++) {\n        $a[$i-1] = $i;\n        $a[$i] += $i-1;\n    }\n\
    \    return scalar(keys %{$a});\n}\n</code>\n<|/ a tags=perl,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. For example, for input `n=5` the expected\
    \ result is `1` but your code returns `4`.\n<|/ c |>\n<| a tags=perl,arrays,algorithm\
    \ |>\n<code>", "    my;\n    \n    for(my $i = 1; $i <= $n; $i++) {\n        push(@triple,\
    \ 1);\n        for(my $j = 1; $j <= $n; $j++) {\n            push(@triple, @triple);\n\
    \        }\n    }\n    \n    my $total = 0;\n    for(my $i = 0; $i <; $i++) {\n\
    \        for(my $j = 0, $k = 0; $j < $i; $j++, $k++) {\n            if($triple[$i][$j]\
    \ + $triple[$j][$k] == 3) {\n                $total++;\n                undef($triple[$i][$j]);\n\
    \                undef($triple[$k][$j]);\n                undef($triple[$k][$i]);\n\
    \            }\n        }\n    }\n    \n    return $total;\n}", "    my @a = map\
    \ {1+$_} 1..$n;\n    my $sum = 0;\n    my $a_size = $a[1] - $a[0] + 1;\n    foreach\
    \ my $i (0..$a_size-1) {\n        foreach my $j ($i+1..$a_size) {\n          \
    \  foreach my $k ($i+1..$a_size-1) {\n                $sum += $a[$i] * $a[$j]\
    \ * $a[$k];\n            }\n        }\n    }\n    return $sum % 3 == 0 ? $sum\
    \ / 3 : 0;\n}\n</code>\n<|/ a tags=math,c++ |>\n<| c |>\nThis algorithm is O(n^3),\
    \ which is too slow for large n. There are more efficient ways to solve this problem,\
    \ like dynamic programming.\n<|/ c |>\n<| c |>\nThe question asked for a solution\
    \ in O(n^2) time.\n<|/ c |>\n<| c |>\nIt does. You iterate over all 2^n combinations.\
    \ It's O(n^3).\n<|/ c |>\n<| c |>\nYes, I agree. Just wanted to point that out\
    \ and propose an alternative algorithm. Thanks for commenting.\n<|/ c |>\n<| c\
    \ |>\nNice solution, but this solution gives wrong result when `n > 1000`.\n<|/\
    \ c |>\n<| a dscore=0 tags=math,c++ |>\nI assume you meant O(n^2) because that's\
    \ the only way you can do it in less than O(n^2).\n<|/ a |>\n<| c |>\nThe only\
    \ way is to sort the array first then looping through it.  That would require\
    \ nlogn time.\n<|/ c |>\n<| c |>\nHow do you propose sorting an array and looping\
    \ through it? It has to be n*logn since you have to read n elements for it to\
    \ be sorted. Sorting doesn't have to be n*logn, the sort algorithm can be optimized\
    \ to achieve that in some cases.\n<|/ c |>\n<| c |>\nThe algorithm itself has\
    \ O(nlogn) time.  You just need to find a way to sort the array first using one\
    \ of the fast sort algorithms like quicksort or insertion sort or merge sort.\
    \  It will take O(nlogn) time to sort.\n<|/ c |>\n<| c |>\nI agree, my point was\
    \ that the algorithm itself has O(nlogn) time, but that has to be the only way\
    \ to do it.\n<|/ c |>\n<| c |>\nI still believe that the fact that you can not\
    \ do it in O(n) time is misleading, since ", "    my(@a) =  ();\n    my($sum)\
    \ = ();\n    for(my $i=1; $i<=$n; $i++) {\n        push(@a, $i*$i-$i+1);\n   \
    \ }\n    for(my $i=$n-2; $i>=$0; $i--) {\n        for(my $j=$i+1; $j<$n; $j++)\
    \ {\n            for(my $k=$j+1; $k<$n; $k++) {\n                $sum += $a[$i]\
    \ + $a[$j] + $a[$k];\n            }\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a tags=algorithm,python |>\n<| c |>\n`return max(sum, 3)`\n<|/ c |>\n<| a\
    \ dscore=0 |>\nI have written a recursive solution which gives me the expected\
    \ answer for the given input but fails to give an accurate answer for the input\
    \ '9' \n<code>\ndef max_triple(num):\n    sum=0\n    arr=[0]*num\n    count=3\n\
    \    for i in range(1,num):\n        arr[i]=arr[i-1]*i-i-i+1\n    for i in range(1,num):\n\
    \        sum+=arr[i]\n    for i in range(1,num-2):\n        for j in range(i+1,num):\n\
    \            sum+=arr[j]\n    for i in range(1,num-1):\n        for j in range(i+1,num):\n\
    \            sum+=arr[j]\n    for i in range(1,num):\n        sum-=arr[i]\n  \
    \  return sum%6", "    my(@a);\n    for(my $i = 1; $i <=$n; $i++) {\n        push(@a,\
    \ $i * $i - $i + 1);\n    }\n    my $count = 0;\n    for(my $i = 0; $i < $n; $i++)\
    \ {\n        for(my $j = $i + 1; $j < $n; $j++) {\n            for(my $k = $j\
    \ + 1; $k < $n; $k++) {\n                if ($a[$i] + $a[$j] + $a[$k] % 3 == 0)\
    \ {\n                    $count++;\n                }\n            }\n       \
    \ }\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,math,dynamic-programming\
    \ dscore=1 |>\nThis should work fine (no memoization and just using brute force)\n\
    <code>\ndef solve(n):\n    a = [i for i in range(1,n+1)]\n    c = 0\n    for i\
    \ in range(1,n//2+1):\n        for j in range(2*i+1,n+1):\n            if j%2==1:\n\
    \                k =j//2\n                c = c+(a[i]+a[j]+a[k]) % 3\n    return\
    \ c\n</code>\n<|/ a |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.LinkedList;\nimport java.util.List;", "    my(@a) = ();\n   \
    \ for(my $i = 0; $i < $n; ++$i) {\n        for(my $j = 0; $j < $n; ++$j) {\n \
    \           for(my $k = 0; $k < $n; ++$k) {\n                if($i != $j && $j\
    \ != $k && $k != $i && $i * $i + $j * $j + $k * $k == 3 * $i) {\n            \
    \        push(@a, $i, $j, $k);\n                }\n            }\n        }\n\
    \    }\n    \n    return scalar(@a);\n}", "    my @a;\n    for (my $i = 0; $i\
    \ < = $n; $i++) {\n        for (my $j = 0; $j < = $n; $j++) {\n            for\
    \ (my $k = 0; $k < = $n; $k++) {\n                if ($i <> $j && $i <> $k &&\
    \ ($a[$j] + $a[$k] + $a[$i] % 3) == 0) {\n                    push(@a, $a[$i]);\n\
    \                }\n            }\n        }\n    }\n    return scalar(@a) + 1;\n\
    }", "    my @a = ();\n    for(my $i = 0; $i <= $n; $i++){\n        for(my $j =\
    \ 0; $j <= $i; $j++){\n            for(my $k = 0; $k <= $j; $k++){\n         \
    \       if(($i+$j+$k) == ($i*$i*$i)){\n                    push(@a, ($i, $j, $k));\n\
    \                }\n            }\n        }\n    }\n    return scalar(@a);\n}",
  "    my @a = ();\n    for(my $i=1; $i<=$n; $i++) {\n        push(@a, $i*$i-$i+1);\n\
    \    }\n    $n=@a;\n    my @b=();\n    for(my $i=0; $i<$n; $i++) {\n        for(my\
    \ $j=$i+1; $j<$n; $j++) {\n            for(my $k=$j+1; $k<$n; $k++) {\n      \
    \          next if $a[$i]+$a[$j]+$a[$k]<0;\n                next if $i==$j ||\
    \ $i==$k || $j==$k;\n                push(@b, ($a[$i], $a[$j], $a[$k]));\n   \
    \         }\n        }\n    }\n    my $max=0;\n    my $i=0;\n    while($max<@b)\
    \ {\n        $max=$b[$i] if $i>0;\n        $i++;\n    }\n    return $i;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nPlease don't post code-only answers. Explain what you're doing\
    \ instead of just posting code. Code without explanation is not helpful.\n<|/\
    \ c |>\n<| a tags=optimization,math,perl,algorithm |>\nHere's an O(n log n) solution\
    \ which I believe is correct\n<code>\nuse List::Util qw(first);\nuse List::MoreUtils\
    \ qw(pairs);", "    my @a = (0) x $n;\n    foreach my $i (0 .. $n - 1) {\n   \
    \     foreach my $j ($i + 1 .. $n) {\n            foreach my $k ($j + 1 .. $n)\
    \ {\n                if ($a[ $i ] + $a[ $j ] + $a[ $k ] ==  3 * $i) {\n      \
    \              return 1;\n                }\n            }\n        }\n    }\n\
    \    return 0;\n}\n</code>\nI hope someone could help me on this one, because\
    \ I'm still new in Perl\n<|/ q tags=perl |>\n<| c |>\nA problem with your program\
    \ is that you are never incrementing `$i` in your `foreach` loops.\n<|/ c |>\n\
    <| c |>\nI didnt get it because i tried to increment $i but it doesnt work\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou are using a loop within a loop.  Your first loop\
    \ is looping through each element of your array, but you're not doing anything\
    \ with it.  Your second loop is looping through each element of your array, and\
    \ for each element you're looping through all the other elements.  The third loop\
    \ does nothing.\nWhat you want to do is increment the second loop inside the first,\
    \ and increment the third loop inside the second.\n<|/ a tags=perl |>\n<| a tags=perl\
    \ dscore=1 |>\nIt looks like you are getting confused with your data structures.\n\
    For example - you have the following:\n<code>\nforeach my $i (0 .. $n - 1) {\n\
    </code>\n$i is the current element you are looping through. \n<code>\nforeach\
    \ my $j ($i + 1 .. $n) {\n</code>\nThis is an infinite loop as you do not keep\
    \ increasing $i within the loop.\nPerhaps this is what you are trying to achieve?\n\
    <code>", "    my @a = ();\n    for(my $i = 0; $i <= $n; $i++) {\n        push\
    \ @a, $i * $i - $i + 1;\n    }\n    my $n = scalar(@a);\n    my $count = 0;\n\
    \    for(my $i = 0; $i < $n; $i++) {\n        for(my $j = $i + 1; $j < $n; $j++)\
    \ {\n            for(my $k = $j + 1; $k < $n; $k++) {\n                if($a[$i]\
    \ + $a[$j] + $a[$k] >= 3) {\n                    $count++;\n                }\n\
    \            }\n        }\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nSince we are talking about large arrays, here is my solution that\
    \ does it in less than 100 lines of code\n<code>\nmy $count = () = map {\n   \
    \ my $x = $_;\n    my $xs = [ $_ + $_ ];\n    $xs[2] -= $xs[-1] if $xs[-1] ==\
    \ 1;\n    $xs[2] -= $xs[-1] if $xs[-1] == 0;\n    return $xs[2] if $xs[2] % 3;\n\
    \    $xs[2] -= 3;\n    return $xs[2];\n}[0..$#a];\n</code>\nThe map function does\
    \ a map on each element of the array and returns the result of the block on each\
    \ element. The block creates an array that contains the sum of the two values\
    \ from the array and compares them to see if they are a multiple of 3. If so,\
    \ the sum is added to the $count variable. Once all elements are summed, we check\
    \ to see if there are two values in the array that are a multiple of 3. If so\
    \ they are subtracted from the total and added to the $count variable. This gives\
    \ the number of triples that meet the requirement of the question. The only thing\
    \ left to do is print the result.\n<code>\nprint \"$count\\n\";\n</code>\n<|/\
    \ a tags=math,perl,arrays,algorithm dscore=1 |>\n<| c |>\nThis doesn't work for\
    \ the test case `get_max_triples(150)` where your program runs out of memory after\
    \ a few minutes.\n<|/ c |>\n<| c |>\nThis still doesn't work for the test case\
    \ `get_max_triples(100)` where your program runs out of memory after a few hours.\
    \ It's been running for about an hour now and the program has done nothing.\n\
    <|/ c |>\n<| c |>\nThat's very strange. The code I posted did not run out of memory,\
    \ but as you said yourself, it did take a few hours. So you probably didn't run\
    \ the exact code I posted because you might have changed something.\n", "    my\
    \ $a = Array::Util::Rearrange([1 .. $n], @_);\n    my $count = 0;\n    for(my\
    \ $i = 1; $i <= $n; $i++){\n        for(my $j = $i+1; $j <= $n; $j++){\n     \
    \       for(my $k = $j+1; $k <= $n; $k++){\n                if($a[$i] + $a[$j]\
    \ + $a[$k] % 3 == 0){\n                    $count++;\n                    last;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThank you, but I'm a beginner in perl, and I don't\
    \ really understand what your code is doing.\n<|/ c |>\n<| c |>\n: What don't\
    \ you understand? It does exactly what you need. What's the problem?\n<|/ c |>\n\
    <| c |>\nWell I'm not familiar with Array::Util, so I'll have to look into that\
    \ package to understand what it's doing. But I guess your code is also doing something\
    \ similar to what I was trying to do, I'll give it a shot.\n<|/ c |>\n<| c |>\n\
    : I'm sorry for the confusion. Array::Util is a utility module that contains a\
    \ lot of functions that can help you deal with arrays. [Here's the link to the\
    \ module's documentation.](http://search.cpan.org/~mirodriguez/Array-Util-1.61/util.pm#ARRAY::UTIL)\n\
    <|/ c |>\n<| c |>\n: Awesome! It worked! I understand it much better now. Thanks\
    \ again for your help! :)\n<|/ c |>\n<| a dscore=1 |>\nHere's a version that works.\
    \ A few notes:", "    my @a = ();\n    for (my $i = 1; $i < $n; $i++) {\n    \
    \    push(@a, $i * $i - ($i + 1));\n    }\n    my $m = @a;\n    for (my $i = 1;\
    \ $i < $n; $i++) {\n        for (my $j = $i; $j < $n; $j++) {\n            for\
    \ (my $k = $j; $k < $n; $k++) {\n                my $t = $a[$i] + $a[$j] + $a[$k];\n\
    \                if ($t % 3 == 0) {\n                    $m++;\n             \
    \   }\n            }\n        }\n    }\n    return $m;\n}", "    my(@a) = (1..$n);\n\
    \    return 0 unless @a;\n    return 0 if @a < 3;\n    return 0 if (@a >= 2 &&\
    \ !@a[2]);\n    my ($i, $j, $k, $sum);\n    $sum = 0;\n    $i = $a[0];\n    $j\
    \ = $a[1];\n    $k = $a[2];\n    while ($i < $j and $j < $k and $k < $n) {\n \
    \       $sum += $i;\n        $i += $j;\n        $j += $k;\n        $k += $n;\n\
    \    }\n    return 0 if $i == $j and $j == $k;\n    return 0 if ($i ne $j and\
    \ $j ne $k);\n    $sum = $sum - $i + $j + $k;\n    return $sum % 3 == 0;\n}",
  "    my(@a) = ();\n    for($i=1; $i<=$n; $i++){ \n        $a[$i] += ($i*$i-$i+1);\n\
    \    }\n    my $result = 1;\n    for($i=1; $i<=$n; $i++){\n        for(my $j=1;\
    \ $j<=$n; $j++){\n            for(my $k=1; $k<=$n; $k++){\n                if($a[$i]+$a[$j]+$a[$k]\
    \ == ($i*$i+$j*$j+$k*$k)){\n                    $result++;\n                }\n\
    \            }\n        }\n    }\n    return $result;\n}", '    my(@a);', '    my(@a);',
  "    my @a;\n    \n    for (my $i = 1; $i <= $n; $i++) {\n        push @a, $i *\
    \ $i - $i + 1;\n    }", "    my(@a);\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        push(@a, $i * $i - $i);\n    }\n    my $cnt = 0;\n    for (my $i = 0;\
    \ $i < @a; $i++) {\n        for (my $j = $i + 1; $j < @a; $j++) {\n          \
    \  for (my $k = $j + 1; $k < @a; $k++) {\n                if ($a{$i} + $a{$j}\
    \ + $a{$k} == ($i * $i - $i + 1) * 3) {\n                    $cnt++;\n       \
    \         }\n            }\n        }\n    }\n    return $cnt;\n}", "    my $count\
    \ = 0;\n    my @triple;\n    \n    my $a = @$triples;\n    \n    for(my $i = 1;\
    \ $i <= $n; $i++) {\n        for(my $j = 1; $j <= $n; $j++) {\n            for\
    \ (my $k = 1; $k <= $n; $k++) {\n                \n                if ( $i + $j\
    \ + $k == $n ) {\n                    push (@triple, ($i, $j, $k));\n        \
    \            $count++;\n                }\n            }\n        }\n    }\n \
    \   \n    return $count;\n}\n</code>\nThe output is\n<code>\nget_max_triples(5)\n\
    => 1\nget_max_triples(10)\n=> 12\n</code>\n<|/ a dscore=2 tags=perl,arrays |>\n\
    <| c |>\nI agree this is what OP should use as it is much easier, but `my ($i,\
    \ $j, $k) = (1, 1, 1); return 0 if $i == $j == $k; return 1 if $i > $j && $i >\
    \ $k;` would be a lot less code with very little change to OP's original `get_max_triples`\
    \ code.\n<|/ c |>\n<| c |>\nWhat if `get_max_triples(15)` was desired?\n<|/ c\
    \ |>\n<| c |>\nI disagree. I think this is better for the OP because it's a simple\
    \ modification to what they already have. `My $n is already defined and is an\
    \ integer. My $a is also already defined and is an array of integers.` This means\
    \ this answer doesn't need to rewrite their `get_max_triples` function.\n<|/ c\
    \ |>\n<| c |>\nI am sorry but this does not look like a solution to OP's problem,\
    \ because your code assumes that each element in $a is a multiple of the previous\
    \ one. But in OP's example, the first two elements are multiples of one and the\
    \ third is of two. The solution I propose is more general. Moreover, I think that\
    \ if you would have rewritten OP's `get_max_triples` you would have received a\
    \ solution much faster than this one, so I agree with your point.\n<|/ c |>\n\
    <| c |>\nI agree with your point. But the question only asks for triples of length\
    \ 3, so the answer would be 1 at that point. `get_max_triples(15)` would return\
    \ `12` as the correct answer, since there are 12 triples of length 3. OP then\
    \ asks if there is a more efficient way of achieving the same thing, and your\
    \ answer demonstrates it. I'm not saying that your answer is wrong, but OP's ",
  "    my @a;\n    for(my $i = 0; $i < $n; $i++) {\n        push(@a, $i*$i-$i+1);\n\
    \    }\n    my $count = 1;\n    for(my $i = 0; $i < $n; $i++) {\n        for(my\
    \ $j = $i+1; $j < $n; $j++) {\n            for(my $k = $j+1; $k < $n; $k++) {\n\
    \                if ($a[$i]+$a[$j]+$a[$k] % 3 == 0) {\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}", " \
    \   my($a) = ();\n    for (my $i = 1; $i <= $n; $i++) {\n        my $v = $i *\
    \ $i - $i + 1;\n        $a[$i] = $v;\n    }\n    my $cnt = 0;\n    for my $i (1..$n)\
    \ {\n        for my $j ($i+1..$n) {\n            for my $k ($i+1..$n) {\n    \
    \            my $va = $a[$i] + $a[ $j] + $a[ $k];\n                if ($va % 3\
    \ == 0) {\n                    $cnt++;\n                }\n            }\n   \
    \     }\n    }\n    return $cnt;\n}\n</cell>\n<cell>", "    my(@a) = (0) x $n;\n\
    \    my($i, $j, $k);\n    for($i = 0; $i < $n; $i++) {\n        for($j = 0; $j\
    \ < $n; $j++) {\n            for($k = 0; $k < $n; $k++) {\n                if\
    \ ($i != $j && $j != $k && $k != $i && $a[$i] + $a[$j] + $a[$k] % 3 == 0) {\n\
    \                    push (@a, ($i, $j, $k));\n                }\n           \
    \ }\n        }\n    }\n    return scalar(@a);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Wow, that was an incredibly fast answer - I never would have thought of that,\
    \ thank you very much.\n<|/ c |>\n<| c |>\nYou're welcome. I'm glad I could help.\
    \ Good luck with your coding journey :-)\n<|/ c |>\n<| c |>\nI've edited my answer\
    \ with a faster algorithm thanks to your contribution.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis code will find the number of triplets (a[i], a[j], a[k]) of a where\
    \ i < j < k, for any a[i] < a[j] < a[k] where a[i] < a[j] and a[j] < a[k].  There\
    \ are no constraints on the values of a[i], a[j], or a[k].\n<code>", "    my @a\
    \ = (1..$n);\n    my $max = 0;\n    for (my $i = 0; $i < $n; $i++) {\n       \
    \ for (my $j = $i; $j < $n; $j++) {\n            for (my $k = $j; $k <= $n; $k++)\
    \ {\n                if ($a[$i] + $a[$j] + $a[$k] == 0) {\n                  \
    \  $max = 1;\n                }\n            }\n        }\n    }\n    return $max;\n\
    }", "    my %a;\n    for(my $i = 0; $i < $n; $i++ ) {\n        $a{$i} = 2*$i -\
    \ $i + 1;\n    }\n    my($i, $j, $k, $sum);\n    $sum = 0;\n    for($i = 0; $i\
    \ <= $n; $i++ ) {\n        for($j = 0; $j < $i; $j++ ) {\n            for($k =\
    \ 0; $k < $j; $k++ ) {\n                $sum += $a{$i} + $a{$j} + $a{$k};\n  \
    \          }\n        }\n    }\n    return 0 if $sum % 3 != 0;\n    return $sum\
    \ / 3;\n}", "    my($a) = ();\n    my($i, $j, $k);", "    my @a = ();\n    for\
    \ (1 .. $n) {\n        my $triple = 0;\n        for (1 .. $n) {\n            my\
    \ $j = $_;\n            my $k = @_;\n            my $i = $_;\n            if ($i\
    \ < $j && $j < $k) {\n                $triple++;\n            }\n        }\n \
    \       push(@a, $triple);\n    }\n    my $triple_sum = 0;\n    my $triple_cnt\
    \ = 0;\n    foreach my $triple(@a) {\n        $triple_sum += $triple;\n      \
    \  $triple_cnt += 1 if $triple % 3 == 0;\n    }\n    return $triple_sum if $triple_cnt\
    \ > 0;\n    return 0;\n}", "    my $a = [];\n    for (my $i = 1; $i <= $n; $i++)\
    \ {\n        push(@$a, $i * $i - $i + 1);\n    }\n    my $num_triples = 0;\n \
    \   for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n\
    \            for (my $k = 0; $k <= $n; $k++) {\n                if ($a[$i] + $a[$j]\
    \ + $a[$k] == $i * $j * $k) {\n                    $num_triples += 1;\n      \
    \          }\n            }\n        }\n    }\n    return $num_triples;\n}\n</code>\n\
    <|/ a tags=big-o,algorithm,python,time |>\n<| c |>\n`return $num_triples;` should\
    \ be after the closing bracket of `for($j...`\n<|/ c |>\n<| c |>\nyeah, I missed\
    \ it before adding my comment, thank you\n<|/ c |>\n<| c |>\n: Thanks for correcting\
    \ me.\n<|/ c |>\n<| a |>\nYour time complexity is O(n^3) for some reason. Let's\
    \ see what happens:\n<code>\n1. Looping over all combinations of n elements gives\
    \ n \xD7 n \xD7 n elements. \n2. Inside a loop another loop is done for n times\
    \ which gives n^2 elements. \n3. Inside a loop another loop is done for n times\
    \ which gives n^2 elements. \n</code>\nSo this would be a total of 3n^2. You have\
    \ to consider two things here: first how you actually implement the algorithm\
    \ and second, how you actually implement the algorithm.\nWhat you actually do\
    \ is to loop over all combinations of n elements. Each loop you loop over all\
    \ combinations of n elements. You have to consider how to implement that without\
    \ looping over all combinations of n elements. There are at least two ways of\
    \ doing that. \nOne way is to use recursion. Let's look at how it works for a\
    \ simple case. Assume that n is equal to 2. \n<code>\nfor i = 1...n\n    for j\
    \ = 1...n\n        for k = 1...n\n            if i^2+j^2+k^2 = n^2\n         \
    \       return true\n            else \n                continue outer loop\n\
    </code>\nIn above code, n^2 loops are nested inside each other. Recursion is simple\
    \ enough. \nLet's look at recursive implementation. \n<code>\nbool f(n) \n{\n\
    \    return (n==1) || (f(n-1));\n}\n</code>\nThe above is simple recursive implementation.\
    \ f is called with argument n", "    my $a = [];\n    for (my $i = 1; $i <= $n;\
    \ $i++) {\n        push(@$a, $i*$i-$i+1);\n    }\n    for (my $i = 0; $i < ($n-1);\
    \ $i++) {\n        for (my $j = ($i+1); $j <= $n; $j++) {\n            for (my\
    \ $k = $i+1; $k <= $n; $k++) {\n                if ($a[$i] + $a[$j] + $a[$k] %\
    \ 3 == 0) {\n                    print \"$a[$i]\\t$a[$j]\\t$a[$k]\\n\";\n    \
    \                return 1;\n                }\n            }\n        }\n    }\n\
    \    return 0;\n}", "    my(@a);\n    for ($i = 0; $i < $n; $i++) {\n        push(@a,\
    \ $i * $i + ($i + 1));\n    }\n    for (my $i = 0; $i < $n; $i++) {\n        for\
    \ ($j = $i + 1; $j < $n; $j++) {\n            for ($k = $j + 1; $k < $n; $k++)\
    \ {\n                if ($a[$i] + $a[$j] + $a[$k] == ($i * $i + $j * $j + $k *\
    \ $k)) {\n                    return $i * $i + $j * $j + $k * $k;\n          \
    \      }\n            }\n        }\n    }\n    return 0;\n}", "    my @a;\n  \
    \  for (1 .. $n) {\n        push @a, (2 * $n - 1) * $n - 1;\n    }\n    $a = sort\
    \ { $a <=> $b} @a;\n    return $a[$#a];\n}", "    return 0 if $n <= 0;\n    my(@a)\
    \ = ();\n    for(1..$n) {\n        push(@a, $i*$i-$i+1);\n    }\n    for(@a) {\n\
    \        for(my $j = 0; $j < $n; $j++) {\n            for(my $k = 0; $k < $n;\
    \ $k++) {\n                my $triple = $a[$j]+$a[$k]+$a[0];\n               \
    \ if($triple == 3*$j+$k) {\n                    return 1;\n                }\n\
    \            }\n        }\n    }\n    return 0;\n}", "    my(@a) =();\n    for($i=0;$i<$n;$i++){\
    \ push(@a,$i*$i-$i+1);}\n    my($count=0,$max=0,$maxi=-1,$maxj=-1,$maxk=-1);\n\
    \    for($i=0;$i<$n;$i++){\n        for(my $j=$i+1;$j<$n;$j++){\n            for(my\
    \ $k=$j+1;$k<$n;$k++){\n                if($a[$i]+$a[$j]+$a[$k]==$i*$i-$i+1){\n\
    \                    $max=$a[$i]-$a[$j]+$a[$k];\n                    if($max<$count){\
    \ $max=$count; $maxi=$i;$maxj=$j;$maxk=$k;};\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $max;\n}\nprint\
    \ get_max_triples(5), \"\\n\";", "    my @a;\n    my $i = 0;\n    my $sum = 1;\n\
    \    while ($i++ < $n) {\n        push(@a, $sum);\n        $sum += $sum + 1;\n\
    \    }\n    my $count = 0;\n    my %hash = ();\n    foreach my $i (@a) {\n   \
    \     $hash{$i} += 1;\n    }\n    foreach my $i (sort keys %hash) {\n        foreach\
    \ my $j (@a) {\n            if ($i < $j and $hash{$i} + $hash{$j} == 2 * $i) {\n\
    \                $count += 1;\n            }\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a tags=algorithm,math,permutation,permutation dscore=0 |>\n<|\
    \ c |>\nThanks for the answer but this does not give the correct result for the\
    \ example test case i gave above\n<|/ c |>\n<| c |>\nSorry, I didn't realize that\
    \ the question is about a triple combination. I've updated my answer.\n<|/ c |>\n\
    <| a tags=algorithm,math,permutation,permutation dscore=0 |>\nHere is an answer\
    \ using Ruby. \n<code>\ndef get_triples(n)\n  a = []\n  (0..n-1).each_with_object([])\
    \ do |i,arr|\n    (a<<i)+(i<<i)+(i+1).each {|i| arr << i if a.reduce(0) {|s,e|\
    \ s + e == i}}\n  end\n  arr.length\nend\n</code>\n<|/ a |>\n<| a |>\nI do not\
    \ know Ruby, but in PHP you can calculate the number of triples from a number\
    \ in a simple array formula:\n<code>\n$total = $triples = $sum = 0;\nfor ($i =\
    \ 1; $i <= $n; $i++) {\n    $total += $i;\n    for ($j = $i; $j <= $n; $j++) {\n\
    \        $triples += $j == $i && $j == $n + $i ? 1 : 0;\n    }\n}\n$total++;\n\
    </code>\nThe total number of triples can be calculated by $triples + ($triples\
    \ * $triples - $sum);\n<|/ a tags=algorithm,math,permutation,permutation dscore=0\
    \ |>\n<| a |>\nHere is a solution using Python. \n<code>\ndef solution(num):\n\
    \    # To store all triples\n    triples = list()\n    sum = 0\n    # to count\
    \ the number triples in each number\n    count = 1\n    # to count number of triples\n\
    \    triples_count = 0\n    # to count number of triples which have the same sum\
    \ \n    # e.g. all pairs (a,b) ", "    my(@a) = ();\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        push(@a, $i * $i);\n    }\n    my $count = 0;\n    for ($i\
    \ = 1; $i <= $n; $i++) {\n        for ($j = 0; $j <= $n; $j++) {\n           \
    \ for ($k = 0; $k <= $n; $k++) {\n                if ($i <=> $j => $k >= $n and\
    \ $a[$i] + $a[$j] + $a[$k] >= $n * 3) {\n                    $count++;\n     \
    \           }\n            }\n        }\n    }\n    return $count;\n}", "    my\
    \ $a = @{$_[0]};\n    my @a;\n    my $i = 0;\n    my $j = $n - 1;\n    my $k =\
    \ $n - 2;\n    while(1) {\n        if ($i >= $j) {\n            push (@a, $a[$i]);\n\
    \            $i++;\n        } else {\n            push (@a, $a[$i]);\n       \
    \     if ($i >= $k) {\n                push (@a, $a[$i]);\n                $i++;\n\
    \            }\n        }\n        elsif ($i < $j) {\n            if ($j < $k)\
    \ {\n                push (@a, $a[$i]);\n                push (@a, $a[$j]);\n\
    \                push (@a, $a[$k]);\n                $j++;\n            }\n  \
    \          else {\n                push (@a, $a[$i]);\n                $i++;\n\
    \            }\n        }\n        else {\n            push (@a, $a[$i]);\n  \
    \          $i++;\n        }\n    }\n    $#a; #return the number of elements\n\
    }\n</code>\n<|/ a |>\n<| a tags=arrays,perl,hash,algorithm |>\n<code>", "    my(@a)\
    \ = ();\n    for ($i = 1; $i <$n; $i++) {\n        push (@a, $i*$i - $i + 1);\n\
    \    }\n    foreach $i (@a) {\n        foreach $j (@a) {\n            foreach\
    \ $k (@a) {\n                if ($i <= $j && $i <= $k && $j <=$k) {\n        \
    \            push(@a, $i + $j + $k);\n                }\n            }\n     \
    \   }\n    }\n    return scalar(@a) if (@a == 0);\n}", "    my(@a) = (1..$n);\n\
    \    my $ret = 0;\n    my $i;\n    my $j;\n    my $k;\n    \n    foreach $i (@a)\
    \ {\n        foreach $j (@a) {\n            if ($i != $j and $j != $k) {\n   \
    \             foreach $k (@a) {\n                    if ($i != $j and $j != $k\
    \ and ($i+$j+$k)%3 == 1) {\n                        $ret++;\n                \
    \    }\n                }\n            }\n        }\n    }\n    return $ret;\n\
    }", "    my @a = ();\n    for(my $i = 0; $i <$n; $i++) {\n        if($i==0) {\n\
    \            push(@a, $i);\n        }\n        else {\n            push(@a, $i*$i-$i+1);\n\
    \        }\n    }\n    my $max = 0;\n    foreach my $i (@a) {\n        foreach\
    \ my $j (@a) {\n            foreach my $k (@a) {\n                if(($i+$j+$k)\
    \ == ($i*$i+$j*$j+$k*$k)) {\n                    $max++;\n                }\n\
    \            }\n        }\n    }\n    return $max;\n}", "    my@a;\n    for(my\
    \ $i=0; $i<$n; $i++) {\n        $a[$i] = $i*$i - $i + 1;\n    }\n    my $sum=0;\n\
    \    for(my $i=1; $i<=$n; $i++) {\n        my $j = $i - 1;\n        for(my $k=1;\
    \ $k<=$n; $k++) {\n            my $k2 = $k - 1;\n            for(my $k3=1; $k3<=$n;\
    \ $k3++) {\n                $sum += $a[$i]+$a[$j]+$a[$k];\n                if($sum==3)\
    \ {\n                    return 1;\n                }\n                $k2 -=\
    \ 1;\n            }\n            $j += 1;\n        }\n    }\n    return 0;\n}",
  "    my($a,@b);\n    for(my $i = 1;$i <= $n;$i++){\n        $a[$i] = $i * $i - $i\
    \ + 1;\n    }\n    for(my $i = 0;$i < $n;$i++){\n        for(my $j = $i+1;$j <\
    \ $n;$j++){\n            for(my $k = $j+1;$k < $n;$k++){\n                if($a[$i]\
    \ + $a[$j] + $a[$k] % 3 eq $i*$j*$k){\n                    push(@b,[$i,$j,$k]);\n\
    \                }\n            }\n        }\n    }\n    return scalar(@b);\n}",
  "    my @a = ();\n    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = $i;\
    \ $j < $n; $j++) {\n            for(my $k = $j; $k < $n; $k++) {\n           \
    \     if($i % $j == 0 && $j % $k == 0) {\n                    push @a, [$i, $j,\
    \ $k];\n                }\n            }\n        }\n    }\n    my $cnt = 0;\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = 1; $j < $n; $j++) {\n\
    \            for(my $k = 1; $k < $n; $k++) {\n                if($i % $j == 0\
    \ && $j % $k == 0) {\n                    $cnt += ($a[$i-1][0] + $a[$j-1][0] +\
    \ $a[$k-1][0]) % 3;\n                }\n            }\n        }\n    }\n    return\
    \ $cnt;\n}", "    if (! defined $n) {\n      return undef;\n    }\n    my $a =\
    \ [];\n    my @count = (0,0,0);\n    for (my $i = 1; $i <= $n; $i++) {\n     \
    \ push @a, $i*$i-$i+1;\n      push @count, $count[$i-1] + $count[$i] + $count[$i-1];\n\
    \    }\n    for (my $i = 0; $i < $n; $i++) {\n      for (my $j = 0; $j < $n; $j++)\
    \ {\n        for (my $k = 0; $k < $n; $k++) {\n          if ($count[$i] + $count[$j]\
    \ + $count[$k] == $i*$j*$k) {\n            my $triples = $a*3;\n            $triples\
    \ += $count[$i]*$count[$j]*$count[$k];\n            return $triples;\n       \
    \   }\n        }\n      }\n    }\n    return 0;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,perl,arrays\
    \ |>\n<| a dscore=1 |>\nHere's a Perl 6 solution:\n<code>", "    return 0 if $n\
    \ == 0;\n    my @a;\n    for(my $i = 0; $i < $n; $i++) {\n        push @a, $i\
    \ * $i - $i + 1;\n    }\n    my $res = 0;\n    for(my $i = 0; $i < $n; $i++) {\n\
    \        for(my $j = $i + 1; $j < $n; $j++) {\n            for(my $k = $j + 1;\
    \ $k < $n; $k++) {\n                if($a[$i] + $a[$j] + $a[$k] % 3 == 0) {\n\
    \                    $res++;\n                }\n            }\n        }\n  \
    \  }\n    return $res;\n}", "    return 0 unless $n;\n    my@a = map { int($_)\
    \ } 1..$n;\n    my $max = 0;\n    foreach my $i (@a) {\n        next if $i ==\
    \ 0;\n        foreach my $j (@a) {\n            next if $j == 0;\n           \
    \ foreach my $k (@a) {\n                next if $k == 0;\n                next\
    \ if $i == $j && $j == $k;\n                next if $i > $j && $j > $k && $i >\
    \ $k;\n                next unless $a[ $i] + $a[ $j] + $a[ $k] % 3 == 0;\n   \
    \             $max = $i\n                    if $a[ $i] > $a[ $j] && a[ $i] >\
    \ $a[ $k];\n            }\n        }\n    }\n    return $max;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=arrays,perl,performance |>\nYou didn't specify if the\
    \ sum of values should always be an integer.  Here's a version that uses no integer\
    \ operations and is probably the fastest method of doing it:\n<code>", "    my\
    \ $count = 0;\n    my @a;\n    for(my $i=0; $i<$n; $i++) {\n        for(my $j=0;\
    \ $j<$n; $j++) {\n            for(my $k=0; $k<$n; $k++) {\n                push\
    \ (@a, $i*$i-$i+$j+$k);\n            }\n        }\n    }\n    foreach my $item\
    \ (@a) {\n        for(my $j=0; $j<$n; $j++) {\n            for(my $k=0; $k<$n;\
    \ $k++) {\n                if($item == $j*$j+$k) {\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=perl,math,combinations |>\nIf you want a solution\
    \ without loops, here is one:\n<code>", "    my @a;\n    for(my $i = 0 ; $i <\
    \ $n ; $i++) {\n        push(@a, $i*$i-$i+1);\n    }\n    my $result = grep {\
    \ @a % 3 > 0 };\n    my $count = 0;\n    if($result != 0) {\n        $count =\
    \ scalar($result);\n    }\n    return $count;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=arrays,perl dscore=1 |>\n<code>", "    my @a = ();\n    for($i = 1;\
    \ $i <= $n; $i++) {\n        for(my $j = $i; $j < ($n+1); $j++) {\n          \
    \  for(my $k = $j; $k < ($n+1); $k++) {\n                next if($i == $j && $j\
    \ == $k);\n                push @a, ($i, $j, $k) if $i*$i - $i*$i + $j*$j - $j*$k\
    \ + $k*$k == 0;\n            }\n        }\n    }\n    my $count = 0;\n    foreach\
    \ my $i (@a) {\n        foreach my $j (@a) {\n            foreach my $k (@a) {\n\
    \                if($i >= $j && $j >= $k && $i <= $k && $j >= $k) {\n        \
    \            if($i + $j + $k == $i*$i + $j*$j + $k*$k) {\n                   \
    \     $count++;\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return $count;\n}", "    my @a;\n    \n    for(my $i = 1;\
    \ $i <= $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    \n    my\
    \ $cnt = 0;\n    \n    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = 1;\
    \ $j <= $n; $j++) {\n            if($i < $j && $a[$i] + $a[$j] + $a[$k] == 0)\
    \ {\n                $cnt++;\n            }\n        }\n    }\n    \n    return\
    \ $cnt;\n}", "    my @a = ();\n    for(my $i=1;$i<=$n;$i++) {\n        $a[$i]\
    \ = $i*$i-2+$i;\n    }\n    return scalar(keys %{$a});\n}", "    my @a;\n    for(1..$n)\
    \ {\n        my $k = ($_ - 1) * $_ - $_ +$_ +1;\n        if($k % 3 == 0) {\n \
    \           push(@a, $k);\n        }\n    }\n    return scalar(@a);\n}", "   \
    \ return 0 if $n < 1;\n    my(@a) = map { $_ + 1 } 1 .. $n;\n    my $res = 0;\n\
    \    my $temp = $a[0] + $a[1] + $a[2];\n    while (@a > 3) {\n        my($i, $j,\
    \ $k) = splice(@a, 0, 3);\n        my $tmp = $a[i] + $j + $k;\n        if ($tmp\
    \ > $temp) {\n            $res = $res + 1;\n            $temp = $tmp;\n      \
    \  }\n    }\n    return $res;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nAs I understand\
    \ your problem, you need to find all the possible permutations of size 3 where\
    \ the sum of the elements is always divisible by 3.\nHere's a recursive solution\
    \ :\n<code>", "    my @a = ();\n    \n    my $index = 0;\n    \n    for(my $i\
    \ = 0; $i <= $n; ++$i){\n        for(my $j = 0; $j < $n; ++$j){\n            for(my\
    \ $k = 0; $k < $n; ++$k){\n                if($i != $j && $j != $k && $i != $k){\n\
    \                    if($a[$i] + $a[$j] + $a[$k] % 3 == 0){\n                \
    \        push(@a, $a[$i] + $a[$j] + $a[$k]);\n                        $index++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return $index; # Return the number of triples (a[i], a[j], a[k]) of\
    \ a where i < j < k.\n}\n</cell>\n<cell>", "    my(@a) = ();\n    for (my $i =\
    \ 0; $i < $n; ++$i) {\n        for (my $j = 0; $j < $n; ++$j) {\n            for\
    \ (my $k = 0; $k < $n; ++$k) {\n                $a[$i] .= $j * $j + $k * $k;\n\
    \                if ($a[$i] + $a[$j] + $a[$k] % 3 == 0) {\n                  \
    \  push (@a, $a[$i] . $a[$j] . $a[$k]);\n                }\n            }\n  \
    \      }\n    }\n    return @a ? $a[@a - 1] : 0;\n}", '    my @a = ();', "   \
    \ my;\n    for(my $i = 0; $i < $n; ++$i) {\n        for(my $j = 0; $j < $n; ++$j)\
    \ {\n            for(my $k = 0; $k < $n; ++$k) {\n                push, $a{$i}\
    \ + $a{$j} + $a{$k};\n            }\n        }\n    }\n    return scalar;\n}\n\
    </code>\n<|/ a dscore=2 tags=algorithm,arrays,multidimensional-array,perl,hashtable\
    \ |>\n<| a tags=algorithm,arrays,multidimensional-array,perl,hashtable dscore=1\
    \ |>\nHere is an O(n) approach:\n<code>", "    my(@a) = (1..$n);\n    my $cnt\
    \ = 0;\n    my %sum;\n    foreach my $i (@a) {\n        next unless ($i ~~ @a);\n\
    \        foreach my $j (@a) {\n            next unless ($j ~~ @a);\n         \
    \   $sum{$i}{$j}++;\n        }\n    }\n    foreach my $i (keys %sum) {\n     \
    \   foreach my $j (keys %{$sum{$i}}) {\n            next unless ($sum{$i}{$j}\
    \ % 3);\n            $cnt += $sum{$i}{$j};\n        }\n    }\n    return $cnt;\n\
    }\n</code>\n<|/ a tags=math,arrays,perl |>\n<| c |>\n`next unless ($i ~~ @a);`\
    \ should be `$i ~~;`\n<|/ c |>\n<| c |>\n, no, it isn't. It checks that each element\
    \ in the array is contained in `@a`\n<|/ c |>\n<| c |>\nYes, I know, I meant `$i\
    \ ~~ @a`\n<|/ c |>\n<| c |>\nThat makes it more clear I guess. I didn't know that\
    \ `~~` could do that.\n<|/ c |>\n<| a dscore=3 |>\nHere is a solution using only\
    \ perl one-liners:\n<code>\n$ cat triples.pl", "    my @a = ();\n    my $n2 =\
    \ int($n / 3);\n    for($i = 0; $i <= $n2; $i++) {\n        $a[$i] = 3*$i;\n \
    \   }\n    $n %= 3;\n    my $cnt = $n % 4;\n    for(my $i = 0; $i <= $n; $i++)\
    \ {\n        for(my $j = $i+1; $j <= $n; $j++) {\n            for(my $k = $j+1;\
    \ $k <= $n; $k++) {\n                if(($a[$i] + $a[$j] + $a[$k] + ($i % 2 ?\
    \ 3 : 1)) %3 === 0){\n                    $cnt += 1;\n                }\n    \
    \        }\n        }\n    }\n    return $cnt;\n}", "    my @a = @{$_[0]};\n \
    \   for (my $i = 0; $i <= $n; $i++) {\n        my $j = $i;\n        $j++ while\
    \ $j < $n && $a[$j] + $a[$j+1] + $a[$j+2] > 3;\n        my $k = $i;\n        $k++\
    \ while $k < $n && $a[$k] + $a[$k+1] + $a[$k+2] > 3;\n        return $i if $j\
    \ < $k && $a[$j] + $a[$k] + $a[$j+k] < 3;\n    }\n    return 0;\n}", "    my $a\
    \ = (1..$n);\n    my %counts = map { $_ => 0 } @a;\n    \n    my ($i, $j, $k);\n\
    \    for ($i, $j, $k) {\n        for ($i, $j, $k) {\n            for ($i, $j,\
    \ $k) {\n                $counts{$i}++ if $i != $j && $i != $k\n             \
    \       && $j != $k\n                    && $a[$i] + $a[$j] + $a[$k] == $n;\n\
    \            }\n        }\n    }\n    \n    return scalar keys %counts;\n}", " \
    \   my;\n    for(my $i = 1; $i <= $n; ++$i) {\n        for(my $j = $i + 1; $j\
    \ <= $n; ++$j) {\n            for(my $k = $j + 1; $k <= $n; ++$k) {\n        \
    \        if($i**2 + $j**2 + $k**2 % 3 == 0) {\n                    push(@triples,\
    \ ($i, $j, $k));\n                }\n            }\n        }\n    }\n    return\
    \ scalar(@triples);\n}", "    my @a = ();\n    for (my $i = 1; $i <= $n; $i++)\
    \ {\n        for (my $j = $i + 1; $j <= $n; $j++) {\n            for (my $k =\
    \ $j + 1; $k <= $n; $k++) {\n                push (@a, $i*$i-$i+$j*$j-$j+$k*$k-$k);\n\
    \            }\n        }\n    }\n    \n    my $max = @a > 0 ? $a[@a-1] : 0;\n\
    \    \n    return $max == 0 ? 0 : @a > 2 ? $max : 1;\n}", "    my @a;\n    for\
    \ (my $i = 1; $i <= $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        for (my $j = 1; $j <= $n; $j++)\
    \ {\n            for (my $k = 1; $k <= $n; $k++) {\n                if ($i >=\
    \ $j && $j >= $k) {\n                    if ($a[$i] + $a[$j] + $a[$k] <= 3 * $a[$i])\
    \ {\n                        $i++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return scalar(@a) - 1;\n}\n</code>\n<|/\
    \ a dscore=0 tags=math,combinatorics,algorithm,pseudocode,algorithm |>\n<| a |>\n\
    I know this is an old question, but I stumbled across it searching for a similar\
    \ problem and figured I'd share my solution in case anyone else comes across this\
    \ post.\nThis problem can be solved by calculating the sum of triangular numbers\
    \ (1-n) (where n is the number of elements in the array), then subtract the sum\
    \ of the first triangular numbers from the sum of the remaining numbers.  By subtracting\
    \ out the sum of first numbers, you get all possible triangular triples less than\
    \ or equal to the number of elements in the array.  You can then get the number\
    \ of triples less than or equal to any given number by getting the total number\
    \ of possible triples that sum less than or equal to the number of elements in\
    \ the array minus 1.  For example, if the number of elements in the array is 4,\
    \ the sum of all numbers in the array is 14, so to get all possible triples that\
    \ sum to less than 4 you would have 1 + 2 + 3 + 4 + 7 = 15.  To get how many triples\
    \ are less than or equal to 4, you would then need to subtract 1 + 2 + 3 + 4 +\
    \ 7 = 15 which equals 13.\nI did some research to understand what this solution\
    \ is, and I hope this helps!\n<|/ a tags=math,combinatorics,algorithm,pseudocode,algorithm\
    \ dscore=0 |>\n<| a dscore=0 |>\nThe answer to this question can be solved using\
    \ the following equation:\n<code>\n(n * (n + 1) / 2) - (n * (n + 3) / 2)\n</code>\n\
    For example, for n = 3 the equation would be:\n<code>\n((3 * 2) - (2 * 1)) + ((3\
    \ * 2) - (2 * 2))\n</code>\nand for n = 4, it would be:\n<code>\n((4 * 3) - (3\
    \ * 2)) + ((4 * 3) - (3 * 3)) + ((4 * 3) - (3 * 4)) + ((4 * 3) - (3 * 5))\n</code>\n\
    Note that if we have a number greater than the sum of all triples less than n,\
    \ then we can simply subtract 1 from n, thus ", "    my(@a) =();\n    \n    for\
    \ (my $i = 0; $i <$n; $i++) {\n        for (my $j = 0; $j <= $i; $j++) {\n   \
    \         for (my $k = 0; $k <= $j; $k++) {\n                push @a, $a[$i] +\
    \ $a[$j] + $a[$k];\n            }\n        }\n    }\n    \n    my $cnt = 0;\n\
    \    \n    for (my $i = 0; $i <$n; $i++) {\n        for (my $j = 0; $j <= $i;\
    \ $j++) {\n            for (my $k = 0; $k <= $j; $k++) {\n                my $s\
    \ = $a[$i] + $a[$j] + $a[$k];\n                \n                if ($s % 3 ==\
    \ 0) {\n                    $cnt++;\n                }\n            }\n      \
    \  }\n    }\n    \n    return $cnt;\n}", "    my();\n    for(my $i = 1; $i lt\
    \ $n; $i++) {\n        for(my $j = $i; $j lt $n; $j++) {\n            for(my $k\
    \ = $j; $k lt $n; $k++) {\n                push(@a, $i);\n                push(@a,\
    \ $j);\n                push(@a, $k);\n            }\n        }\n    }\n    $cnt\
    \ = 0;\n    for my $i (@a) { \n        $cnt += $i * $i - $i + 1;\n    }\n    return\
    \ $cnt;\n}", "    my(@a) = ();\n    for (my $i = 1; $i <= $n; $i++) {\n      \
    \  for (my $j = 1; $j <= $n; $j++) {\n            for (my $k = 1; $k <= $n; $k++)\
    \ {\n                push(@a, $i*$i-$i+$j+$k);\n            }\n        }\n   \
    \ }\n    @a = sort { $a <=> $b } @a;\n    my $num_triples = 0;\n    while (@a\
    \ > 0 && @a % 3 == 0) {\n        my $triple = pop(@a);\n        if ($triple <\
    \ $n*$n*$n) {\n            push(@a, $triple);\n        }\n        $num_triples\
    \ += 1;\n    }\n    return $num_triples;\n}", "    my(@a) = (1..$n);\n    my($tam,$i,$j,$k,@tri,$t);\n\
    \    my($ntrips) = 0;\n    \n    foreach $i ( ) {\n        $a[i] = $i*$i-1;\n\
    \        next unless $a[i] > 0;\n        foreach $j (@a[0..$i-1]) {\n        \
    \    $a[j] = $a[j];\n            next unless $a[j] > 0;\n            foreach $k\
    \ (@a[0..$j-1]) {\n                $a[k] = $a[k];\n                next unless\
    \ $a[k] > 0;\n                $t = $a[i] - $j - $k;\n                push @tri,\
    \ [$i, $j, $k];\n                if($t < $tam) { $tam = $t; }\n              \
    \  if($t >= 3) { $ntrips += 1; }\n            }\n        }\n    }\n    return\
    \ $ntrips;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a solution using O(1)\
    \ space and O(n) time complexity:\n<code>\nint max_triples(int n) {\n    std::vector<int>\
    \ a(n);\n    int tam;", "    my;\n    \n    for($i = 0; $i < $n; $i++) {\n   \
    \     $a[$i] += 1;\n    }\n    \n    for($i = 0; $i < $n; $i++) {\n        for($j\
    \ = 0; $j < $n; $j++) {\n            for($k = 0; $k < $n; $k++) {\n          \
    \      if($i+1 < $n && $j+1 < $n && $k+1 < $n &&\n                   $i+1 < $j+1\
    \ && $j+1 < $k+1 && $k+1 < $n-1 &&\n                   $a[$i] + $a[$j] + $a[$k]\
    \ > 2*$a[$i] + 2*$a[$j] + 2*$a[$k]) {\n                    push, [ $i, $j, $k\
    \ ];\n                }\n            }\n        }\n    }\n    \n    return scalar(@triples);\n\
    }", "    my($a = undef);\n    my @temp;\n    for($i = 1;$i < $n;$i++) {\n    \
    \    push(@temp,$i);\n        push(@temp,$i);\n    }\n    while( scalar(@temp)\
    \ > 0) {\n        my $temp = shift(@temp);\n        my $index = 0;\n        while(\
    \ $index+1 < $n ) {\n            $a{$temp}{$index} = $temp;\n            $index++;\n\
    \        }\n    }\n    while( scalar(@temp) > 0) {\n        my $temp = shift(@temp);\n\
    \        my $index = 1;\n        while( $index+1 < $n ) {\n            $a{$temp}{$index}\
    \ = $temp;\n            $index++;\n        }\n    }\n    my($triple) = 0;\n  \
    \  while( scalar(keys(%a)) > 0 ) {\n        $triple++;\n        my $tempa = keys\
    \ %{$a{$_}};\n        for(my $i = 0;$i < $tempa;$i++) {\n            my $temp\
    \ = $a{$_}{$i};\n            my $index = 1;\n            while( $index+1 < $n\
    \ ) {\n                $a{$temp}{$index} = $temp;\n                $index++;\n\
    \            }\n        }\n    }\n    return $triple;\n}", "    my(@a) = (1..$n);\n\
    \    my($i, $j, $k);\n    $a[1] = $a[1]*$a[1] - $a[1] + 1;\n    foreach $i (@a)\
    \ { $a[$i] = $a[$i]*$a[$i] - $a[$i] + 1; }\n    foreach $j (@a) { $a[$j] = $a[$j]*$a[$j]\
    \ - $a[$j] + 1; }\n    foreach $k (@a) { $a[$k] = $a[$k]*$a[$k] - $a[$k] + 1;\
    \ }\n    foreach $i (@a) {\n        foreach $j (@a) {\n            foreach $k\
    \ (@a) {\n                if ($i > $j and $i > $k and $j > $k) {\n           \
    \         if ($a[$i] > $a[$j] and $a[$i] > $a[$k] and $a[$j] > $a[$k]) {\n   \
    \                     return $a[$i]*$a[$i] - $a[$i] + $a[$j]*$a[$j] - $a[$j] +\
    \ $a[$k]*$a[$k] - $a[$k] + 1;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    return 0;\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nThanks a lot for the help. I ran this on my terminal and i think I got\
    \ the correct output. I was confused and thought I did something wrong.\n<|/ c\
    \ |>\n<| c |>\nFor some reason, I was getting a negative answer with this algorithm.\
    \ Could you help me to understand what was wrong with this one? I understand that\
    \ I am doing something wrong but I can't figure out what it is and I am getting\
    \ wrong results for different input sizes.\n<|/ c |>\n<| c |>\n, could you help\
    \ me to understand this algorithm? I am not able to follow it fully. Could you\
    \ please explain it? Thanks!\n<|/ c |>\n<| a tags=algorithm dscore=3 |>\nI am\
    \ posting a recursive solution to it too as it is easier for me to understand\
    \ for a beginner. \n<code>\nint func(arr[], n, i, j){\n    if(j < n-1){\n    \
    \     if(arr[j] > arr[j+1] && arr[j] > arr[j+2]){\n            return 1;\n   \
    \      }\n         return func(arr, n, i, j+1);\n    }\n    return 0;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\n<code>\n", "    my $a = my();\n    my $count = 0;\n\
    \    my $i;\n    for (1..$n) {\n        push @$a, $_;\n        for (my $j = 0;\
    \ $j < $n; $j++) {\n            if ($j < $n && $a[$j] == $_ + 1) {\n         \
    \       push @$a, $_ + $j;\n                next;\n            }\n        }\n\
    \        push @$a, $_ + 2;\n        $count++;\n    }\n    return $count;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npackage Triples;\nuse strict;\n\
    use warnings;\nuse 5.010;", "    my;\n    for($i = 0; $i < $n; $i++) {\n     \
    \   push(@triples, $i, $i, $i);\n        push(@triples, $i, $i, $i + 1);\n   \
    \     push(@triples, $i, $i + 1, $i + 1);\n    }\n    my $triples_count = 1;\n\
    \    my %triple;\n    foreach my $pair (@triples) {\n        $triple{$pair}++;\n\
    \    }\n    foreach my $pair (keys %triple) {\n        $triples_count += $triple{$pair};\n\
    \    }\n    return $triples_count;\n}", "    my @a;\n    for (my $i = 0; $i <=\
    \ $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    my $triples = 0;\n\
    \    my $sum = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        for (my $j =\
    \ 0; $j <= $n; $j++) {\n            for (my $k = 0; $k <= $n; $k++) {\n      \
    \          if ($i + $j + $k == 3 * $i) {\n                    $sum++;\n      \
    \          }\n            }\n        }\n    }\n    return $triples;\n}", "   \
    \ my $a = @{$_[0]};\n    $a .= 0;\n    my $c = @{$_[1]};\n    my $t = @{$_[2]};\n\
    \    my $max = 0;\n    for my $i (0 .. $n-1) {\n        for my $j (0 .. $n-1)\
    \ {\n            for my $k (0 .. $n-1) {\n                my $sum = ($a[ $i-1]\
    \ * $a[ $j-1] * $a[ $k-1]) + ($a[ $j-1] * $a[ $k-1] * $a[ $i-1]) + ($a[ $k-1]\
    \ * $a[ $i-1] * $a[ $j-1]);\n                if ($sum == 3) {\n              \
    \      $max++;\n                }\n            }\n        }\n    }\n    return\
    \ $max;\n}", "    my($a1, $a2, $a3) = (0, 0);\n    \n    for my $i (1 .. $n) {\n\
    \        my $j = ($i - 1) >> 1;\n        my $k = (($i + 1) % $n) - 1;", "    my(@a)\
    \ = @{ $_[0] };\n    $a[0] = 1;\n    for($i = 1; $i < $n; ++$i) {\n        $a[$i]\
    \ = $a[$i - 1] + $a[$i] - $a[$i - 1];\n    }\n    \n    my $result = 0;\n    for($i\
    \ = 1; $i < $n; ++$i) {\n        foreach my $j ($i + 1, $n) {\n            foreach\
    \ my $k ($j, $n) {\n                if($a[ $i] + $a[ $j] + $a[ $k ] % 3 != 0)\
    \ {\n                    ++$result;\n                }\n            }\n      \
    \  }\n    }\n    return $result;\n}\n</code>\nIt uses O(n) additional memory,\
    \ but O(n^2) extra calculations.\n<|/ a dscore=0 tags=algorithm,arrays,perl,data-structures,math\
    \ |>\n<| c |>\nI agree with this solution, but it does not seem to answer the\
    \ OP's question. He doesn't want to count the number of triples within a certain\
    \ limit, but how many triples *can* exist within the limit.\n<|/ c |>\n<| c |>\n\
    He wrote \"return a positive integer\". The solution returns a positive integer,\
    \ which is the number of triples within specified limit.\n<|/ c |>\n<| c |>\n\
    He wrote \"return a positive integer\". The solution returns a positive integer,\
    \ which is the number of triples within specified limit.\n<|/ c |>\n<| c |>\n\
    You just repeated the text from the OP in the body of the answer.\n<|/ c |>\n\
    <| c |>\nYes, I know. As I wrote, I think that this solution is the best one,\
    \ but I didn't see this requirement in the question. By the way, this solution\
    \ also returns 0 as the number of triples within a limit when limit is 1.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "    my @a;\n    for(my $i=0; $i<$n; $i++)\
    \ {\n        for(my $j=0; $j<$n; $j++) {\n            for(my $k=0; $k<$n; $k++)\
    \ {\n                if($i<$j and $j<$k and $i<$k) {\n                    if($a[$i]==$a[$j]+$a[$k])\
    \ {\n                        $a[$i]+=$a[$j];\n                        $a[$j]+=$a[$k];\n\
    \                        $a[$k]+=$a[$i];\n                    } else {\n     \
    \                   $a[$i]+=$a[$k];\n                        $a[$k]+=$a[$j];\n\
    \                        $a[$j]+=$a[$i];\n                    }\n            \
    \    }\n            }\n        }\n    }\n    $n = scalar(@a);\n    return $n;\n\
    }", "    my(@a) = ();\n    for(my $i = 0; $i < $n; ++$i) {\n        push(@a, $i\
    \ * $i - $i + 1);\n    }\n    my $count = 0;\n    my $max_value = -2;\n    for(my\
    \ $i = 0; $i < $n; ++$i) {\n        for(my $j = 0; $j < $n; ++$j) {\n        \
    \    for(my $k = 0; $k < $n; ++$k) {\n                if($a[$i] + $a[$j] + $a[$k]\
    \ % 3 == 0) {\n                    if($a[$i] + $a[$j] + $a[$k] > $max_value) {\n\
    \                        $max_value = $a[$i] + $a[$j] + $a[$k];\n            \
    \            $count = $i + $j + $k;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return $count;\n}", "    my @a;\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        for(my $j = $i; $j <= $n; $j++) {\n     \
    \       for(my $k = $i; $k <= $n; $k++) {\n                if($i + $j + $k ==\
    \ ($i * $i - $i + 1) + ($j * $j - $j + 1) + ($k * $k - $k + 1)){\n           \
    \         push @a, $i . \",\" . $j . \",\" . $k;\n                }\n        \
    \    }\n        }\n    }\n    return scalar(@a);\n}\n</code>\n<|/ a tags=algorithm,perl\
    \ |>\n<| c |>\nI think you have a bug in the code in the comment of the function.\
    \ Should be `if($i + $j + $k == ($i * $i - $i + 1) + ($j * $j - $j + 1) + ($k\
    \ * $k - $k + 1))`. Otherwise it works perfectly (upvoted).\n<|/ c |>\n<| c |>\n\
    Oh, yes, I forgot the `+ 1`. Thank you for pointing it out :)\n<|/ c |>\n<| c\
    \ |>\nThis is very inefficient: you are looping over `$n` `n^2` times. The complexity\
    \ is `O(n^3)`. If someone can find a way to make it O(n), I am open to suggestions.\n\
    <|/ c |>\n<| a tags=algorithm,perl |>\nHere's a O(nlogn) solution that returns\
    \ all triples in lexicographical order:\n<code>\nmy $array = [1,3,7,13,21];\n\
    my $triples = 0;", "    my @a;\n    for(my $i=0; $i<$n; $i++){\n        for(my\
    \ $j=0; $j<$n; $j++){\n            for(my $k=0; $k<$n; $k++){\n              \
    \  push (@a, $i*$i-$j+$k);\n            }\n        }\n    }\n    $#a = $#a - 1;\n\
    \    my $triples = 0;\n    for(my $i=0; $i<$#a; $i++){\n        for(my $j=0; $j<$#a;\
    \ $j++){\n            for(my $k=0; $k<$#a; $k++){\n                if($a[$i]+$a[$j]+$a[$k]\
    \ % 3 == 0){\n                    $triples++;\n                }\n           \
    \ }\n        }\n    }\n    return $triples;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThank you. I didn't know that `for` can be an expression\n<|/ c |>\n<|\
    \ a dscore=1 tags=perl,algorithm |>\nThis was a fun problem!  I wrote this in\
    \ C, and ran it on a few large numbers.  (I did this in Python, just in case someone\
    \ wanted to look at the output to see how it was working.)\n<code>\ndef get_max_triples(n):\n\
    \    a = [0] * n\n    for x in range(n):\n        a[x] = x ** 2 - x + 1\n    s\
    \ = 0\n    for x in range(1, n):\n        s += a[x] % 3 == 0\n    return s\n</code>\n\
    I used this website to figure out how to determine whether a number is a multiple\
    \ of 3.  I got the formula from here.  I then made sure that each value was divisible\
    \ by 3.  This made it much easier to see that x % 3 == 0 is the same as x - 1\
    \ == 0 in Python.\n<|/ a |>\n<| a tags=perl,algorithm |>\nHere is my attempt.\
    \ \n<code>", "    my @a;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my\
    \ $j = $i+1; $j < $n; $j++) {\n            for (my $k = $j+1; $k < $n; $k++) {\n\
    \                if ($i * $i + $j * $j + $k * $k == $i*$j*$k) {\n            \
    \        push @a, $i * $i + $j * $j + $k * $k;\n                }\n          \
    \  }\n        }\n    }\n    return scalar (@a) - 1;\n}", "    my $a = [];\n  \
    \  for my $i (1 .. $n) {\n        $a[ $i ] = $i * $i - $i + 1;\n    }\n    my\
    \ $count = 0;\n    for my $i (1 .. $n) {\n        for my $j (1 .. $n) {\n    \
    \        for my $k (1 .. $n) {\n                my $triple = $a[ $i ] + $a[ $j\
    \ ] + $a[ $k ];\n                if (($triple % 3) == 0) {\n                 \
    \   $count++;\n                }\n            }\n        }\n    }\n    return\
    \ $count;\n}", "    my(@a);\n    for($i = 0; $i < $n; $i++) {\n        push(@a,\
    \ $i*$i-$i+1);\n    }\n    my $max = -1;\n    my $count = 0;\n    for($i = 0;\
    \ $i < $n; $i++) {\n        for(my $j = max($i, $n-1); $j >= $i; $j--) {\n   \
    \         my $a = $a[$j];\n            for(my $k = $i+1; $k <= $j; $k++) {\n \
    \               $a = $a + $a[$k];\n                my $triple = $a[$i]+$a[$j]+$a[$k];\n\
    \                if($triple % 3 == 0) {\n                    $count++;\n     \
    \           }\n                if($triple > $max) {\n                    $max\
    \ = $triple;\n                }\n            }\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a tags=big-o,algorithm,perl,arrays |>\n<| c |>\n: You are welcome.\
    \ Since it took so long to get here, I would like to mention that you can give\
    \ an upvote to the solution that you find most helpful. This helps future visitors\
    \ to find solutions more easily.\n<|/ c |>\n<| c |>\n: Thanks again. Updated the\
    \ answer to include your solution.\n<|/ c |>\n<| c |>\nOh my god. I love you so\
    \ much!! I was almost pulling my hair out trying to figure out why my code was\
    \ taking so long. I am a beginner at this stuff so I did not know how to make\
    \ my code more efficient. Thank you so much again. Really appreciate it!\n<|/\
    \ c |>\n<| c |>\n: Glad to help :-)\n<|/ c |>\n<| a |>\nI believe this is an interesting\
    \ challenge to write in Perl. I do not believe that there is any way to do this\
    \ better than the time complexity of O(n^3).\nHere's my solution:\n<code>", " \
    \   my @a = ();\n    for(my $i = 1;$i <= $n;$i++){\n        push(@a, $i*$i-$i+1);\n\
    \    }\n    return scalar(grep{ $_ % 3 == 0 } @a);\n}", "    my @a = @{ [ map\
    \ { $_ * 3 - $_ * $_ + $_ + 1 } 0 .. $n - 1 ] };\n    return scalar grep { $a[\
    \ $_ - 1 ] + $a[ $_ - 2 ] + $a[ $_ - 1 ] - $a[ $_ ] == 3 } 0..($n - 1);\n}", " \
    \   my;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = $i; $j < $n;\
    \ $j++) {\n            for (my $k = $j; $k < $n; $k++) {\n                if ($i+$j+$k\
    \ <= 3*$n and $i+$j+$k < 3*$n+1 \n                 and $i+$k+$j < 3*$n and $i+$k+$k\
    \ > 2*$n-1 and $j+$k+$k == 3*$n-$i) {\n                    push (@triples, [$i,\
    \ $j, $k]);\n                }\n            }\n        }\n    }\n    return scalar\
    \ (@triples);\n}", '    my;', "    my@a;\n    for (my $i = 1; $i <= $n; ++$i)\
    \ {\n        my $j = $i;\n        my $k = $i;\n        my $triple = 0;\n     \
    \   while ($k > 1) {\n            my $tmp = $j - $k;\n            $j = $k;\n \
    \           $k = $tmp;\n            ++$triple;\n        }\n        push @a, ($i,\
    \ $j, $k);\n    }\n    if (@a == 0) {\n        return;\n    }\n    if (@a == 1)\
    \ {\n        return 1;\n    }\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n\
    \    my $total = 0;\n    while ($j < @a) {\n        $k = $a[$j];\n        while\
    \ ($k != $i) {\n            $total++;\n            $j++;\n            $k = $a[$j];\n\
    \        }\n        $i++;\n        $j++;\n    }\n    return $total;\n}", "   \
    \ my;\n    my $i = 0;\n    for(my $i = 0; $i < $n; $i++ ) {\n\tpush, (@{$_[$i]},\
    \ $i, $i);\n    }\n    my %map;\n    foreach my $pair (@a) {\n\tforeach my $elem\
    \ ($pair->[0], $pair->[1]) {\n\t    if($elem != $i) {\n\t\t$map{$elem}++;\n\t\
    \    }\n\t}\n    }\n    my $max = 0;\n    foreach my $k (sort keys %map) {\n\t\
    if($map{$k} > $max) {\n\t    $max = $map{$k};\n\t}\n    }\n    return $max;\n}",
  "    my @a;\n    for(my $i = 0; $i < $n; ++$i) {\n        push(@a, $i * $i - $i\
    \ + 1);\n    }\n    @a = sort {$a <=> $b} @a;\n    my $triplet = 0;\n    for(my\
    \ $i = 0; $i < @a; ++$i) {\n        for(my $j = 0; $j < @a; ++$j) {\n        \
    \    for(my $k = 0; $k < @a; ++$k) {\n                if ($a[$i] + $a[$j] + $a[$k]\
    \ % 3 == 0) {\n                    ++$triplet;\n                }\n          \
    \  }\n        }\n    }\n    return $triplet;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nYou should use `use warnings;` to turn on all warnings.\n<|/ c |>\n<|\
    \ c |>\nYou don't need to reinvent the wheel just to find out if someone has solved\
    \ a problem already, as long as they show a demonstration of effort.\n<|/ c |>\n\
    <| c |>\nAnd since we're all programmers, please format your code.\n<|/ c |>\n\
    <| c |>\n: Thanks, I always use warnings to avoid such mistakes.\n<|/ c |>\n<|\
    \ c |>\nYou forgot to `use strict;` and `use warnings;`\n<|/ c |>\n<| a |>\n<code>\n\
    def max_triples(n):\n    list=[]\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n    list.extend(range(1,n+1))\n\
    \    list.extend(range(1,n+1))\n    list.extend(range(1,n", "    my $a = [];\n\
    \    for (my $i = 0; $i <= $n; $i++) {\n        $a[ $i ] = $i * $i - $i + 1;\n\
    \    }\n    for my $i($n - 1..-1) {\n        for my $j($n - 1..-1) {\n       \
    \     for my $k($n - 1..-1) {\n                next unless $i < $j && $j > $k\
    \ && $a[ $i ] + $a[ $j ] + $a[ $k ] % 3 == 0;\n                return 1 + $j +\
    \ $k + 1 if $i == $j || $i == $k || $j == $k;\n            }\n        }\n    }\n\
    \    return 0;\n}", "    my @a = ();\n    for(my $i = 1; $i <= $n; $i++) {\n \
    \       for(my $j = 1; $j <= $n; $j++) {\n            for(my $k = 1; $k <= $n;\
    \ $k++) {\n                if($i lt $j && $j lt $k) {\n                    push\
    \ @a, ($i, $j, $k);\n                }\n            }\n        }\n    }\n    my\
    \ $result = 0;\n    for(my $i = 0; $i < @a; $i++) {\n        my $triple = $a[$i]->[0]\
    \ + $a[$i]->[1] + $a[$i]->[2];\n        if($triple % 3 == 0) {\n            $result++;\n\
    \        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=0 tags=perl,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "    my @a;\n    for (my $i = 1; $i <= $n; $i++)\
    \ {\n        push(@a, $i * $i - $i + 1);\n    }\n    my $count = 0;\n    foreach\
    \ (@a) {\n        foreach (@a) {\n            foreach (@a) {\n               \
    \ my $val = $_ + $_ + $_;\n                if ($val % 3 == 0) {\n            \
    \        $count++;\n                }\n            }\n        }\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYes, but if there is no solution\
    \ it returns 0. Is there a way to return 0 for that input?\n<|/ c |>\n<| c |>\n\
    It does not return zero for that input, because your are calling it with parameter\
    \ 5, which returns 1. The program does not know that some elements may have no\
    \ valid triples (if n is even, then there is one possible solution, and if the\
    \ input is odd, then the number of valid triples is 1).\n<|/ c |>\n<| c |>\nI\
    \ updated the answer to return the count of valid triples\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    my($a,$i,$j,$k);\n    my $sum = 0;\n    \n    for ($i = 0;\
    \ $i <= $n; $i++) {\n        for ($j = 0; $j <= $i; $j++) {\n            for ($k\
    \ = 0; $k <= $j; $k++) {\n                $sum += $i*$i - $j*$j + $k*$k;\n   \
    \         }\n        }\n    }\n    \n    return $sum % 3 == 0 ? 0 : 1;\n}", " \
    \   my @a;\n    for (my $i = 1; $i < $n; $i++) {\n        push (@a, $i*$i-1);\n\
    \        push (@a, $i*$i+1);\n        push (@a, $i*$i-$i);\n    }\n    my $res\
    \ = 0;\n    for (my $i = 1; $i < $n; $i++) {\n        for (my $j = $i + 1; $j\
    \ < $n; $j++) {\n            for (my $k = $j + 1; $k < $n; $k++) {\n         \
    \       if ($a[1]+$a[2]+$a[3] >= $a[1]*$a[2]*$a[3]) {\n                    $res\
    \ += 1;\n                }\n            }\n        }\n    }\n    return $res;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis solution is O(N^3). It should be O(N^2) or\
    \ O(NlogN)\n<|/ c |>\n<| c |>\nYou are right. It should be O(N^2). It was my first\
    \ solution.\n<|/ c |>\n<| a |>\nMy first thought was a hashtable. Basically, for\
    \ each i you need to count the number of valid triplets a[0], a[1], ..., a[i],\
    \ a[i+1], ..., a[n]. Once you have the number of valid triples you can just add\
    \ them all up.\n<code>\nimport java.util.HashMap;\nimport java.util.Map;", '    my(@result);',
  '    return unless $n;', '    my;', '    my(@result) = (0, 0);', "    my;\n    for\
    \ (my $i = 0; $i <= $n; $i++) {\n        for (my $j = $i; $j <= $n; $j++) {\n\
    \            for (my $k = $j; $k <= $n; $k++) {\n                push (@triples,\
    \ (3 * $i) + (3 * $j) + (3 * $k));\n            }\n        }\n    }\n    my $count\
    \ = 0;\n    for (@triples) {\n        my $tmp = @triples[$_];\n        if ($tmp\
    \ & 1) {\n            $count++;\n        }\n    }\n    return $count;\n}\n</code>\n\
    It returns 1 for your example, but you probably want to change it to return 0\
    \ in your case.\n<|/ a dscore=1 |>\n<| c |>\nYou probably mean `push (@triples,\
    \ (3 * $i) + (3 * $j) + (3 * $k));`. Otherwise, it doesn't return the correct\
    \ result.\n<|/ c |>\n<| c |>\nYes, of course, thanks, just fixed!\n<|/ c |>\n\
    <| c |>\nThanks for the solution, I have tried it on some cases and it works.\
    \ However, it took me some time to understand it. I still have some questions\
    \ about it. Could you tell me the logic behind it? For instance, why do you do\
    \ `if ($tmp & 1)`? Why do you shift the bits of `$tmp` one by one to compare it?\n\
    <|/ c |>\n<| c |>\nThe \"trick\" is to use `&` operator to bitwise and `$tmp`\
    \ with 1, but `&` returns 0 if both operands are 0 (false). For instance: 0b1000\
    \ is 0b0100 and 0b1001 is 0b1000. But, 0b0100 is 0b0000 and 0b1000 is 0b1000,\
    \ but `0b0100 & 0b1000` is 0b0000 which is not true. To compare two numbers as\
    \ integers, you should shift bits of one number one by one (`$i`, `$j` and `$k`)\
    \ to the right until they have only 1 left. Finally, you compare only numbers\
    \ which have only 1 bit left and they are not 0.\n<|/ c |>\n<| c |>\nI guess I\
    \ got it. Thanks for sharing your expertise!\n<|/ c |>\n<| a tags=algorithm,perl\
    \ dscore=0 |>\nThe way I'd do it is something like this.\n<code>\n$n=int(input());\n\
    $a=$n*$n-$n*$n+$n-1;\n$m=$n*$n-$a*$a;\n$n++;\nwhile ($m%$n==0)\n{\n$m=$m", " \
    \   my(@a) = (1..$n);\n    my ($i, $j, $k) = ();\n    my $total_triples = 0;",
  "    my $a = [];\n    for my $i (1..$n) {\n        push(@$a, $i * $i - $i + 1);\n\
    \    }\n    return @$a if @$a % 3 != 0;\n    return @$a - 1;\n}", "    my @a;\n\
    \    for(my $i = 1; $i <= $n; $i++){\n        $a[$i] = $i * $i - $i + 1;\n   \
    \ }\n    my($i, $j, $k) = ();\n    for(my $i = 1; $i <= $n; $i++){\n        if($i\
    \ == 1){\n            $i = $a[$i];\n        }\n        if($i > 1){\n         \
    \   $j = $a[$i-1];\n            $k = $a[$i-1] - $a[$i] + 1;\n            if($i\
    \ % 3 == 0){\n                if($j % 3 == 0 && $k % 3 == 0){\n              \
    \      $i = $i + $j + $k;\n                }\n            }\n        }\n    }\n\
    \    return $i;\n}\n</code>\n<|/ a dscore=0 tags=perl,math,algorithm |>\n<| c\
    \ |>\nYour code doesn't work for n=4: `get_max_triples(4)` returns 1 instead of\
    \ 2.\n<|/ c |>\n<| c |>\nI fixed a bug and tested the code for n=4.\n<|/ c |>\n\
    <| a |>\nYour question was to find how many triples can be formed such that given\
    \ numbers are a1, a2, a3, ..., an. \nThe answer should be N^3/4. For simplicity,\
    \ we can take any two numbers and find how many triples can be formed with them.\
    \ Let a2 and a3 be two numbers with which we can find how many triples can be\
    \ formed between them. \nLet the answer be B = a2+a3 and let us call it B. Now,\
    \ we have N numbers, where N is number of items in an array and a1, a2, a3, ...,\
    \ an are numbers in the array. The solution can be divided into two problems: ",
  "    my @a = ();\n    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = 1; $j\
    \ <= $i; $j++) {\n            for(my $k = 1; $k <= $j; $k++) {\n             \
    \   push (@a, $i * $i - $i + 1);\n                push (@a, $j * $j - $j + 1);\n\
    \                push (@a, $k * $k - $k + 1);\n            }\n        }\n    }\n\
    \    \n    my $num_triples = 0;\n    foreach my $i (@a) {\n        my $sum = 0;\n\
    \        foreach my $j (@a) {\n            $sum += $i;\n            $sum += $j;\n\
    \            $sum += $k;\n            if($sum % 3 != 0) {\n                ++$num_triples;\n\
    \            }\n        }\n    }\n    \n    return $num_triples;\n}", "    my\
    \ @a = ();\n    for(my $i = 0; $i < $n; $i++) {\n        push(@a, $i * $i - $i\
    \ + 1);\n    }\n    my $ans = -1;\n    my $min_i    = 0;\n    my $max_i    = 0;\n\
    \    for(my $i = 0; $i < $n; $i++) {\n        if($i >= $min_i && $i <= $max_i)\
    \ {\n            $ans = $ans + $a[$i];\n        }\n        if($i <= $max_i) {\n\
    \            $min_i = $i;\n        }\n        if($i >= $max_i) {\n           \
    \ $max_i = $i;\n        }\n    }\n    if($min_i < $max_i) {\n        $ans = $ans\
    \ + $a[$min_i];\n    }\n    return $ans;\n}", "    my @a = ( 1 .. $n );\n    my\
    \ @trip;\n    my $trips = 0;\n    my $sum = 0;\n    my $i = 1;\n    my $j = 1;\n\
    \    my $k = 1;\n    \n    while( ($i <= $n) || ($j <= $n) || ($k <= $n) ) {\n\
    \        if($i == $j && $j == $k) {\n            $trip++;\n            $sum =\
    \ $sum + $i*$i + $j*$j + $k*$k;\n            push (@trip, $i, $j, $k);\n     \
    \   }\n        elsif( $i > $j ) {\n            $i = $i + $j;\n            $j =\
    \ $k;\n        }\n        elsif( $j > $k ) {\n            $j = $j + $k;\n    \
    \        $k = $i;\n        }\n        else {\n            $i = $i + $j;\n    \
    \        $j = $j + $k;\n            $k = $k;\n        }\n    }\n    \n    if($sum\
    \ % 3 == 0) {\n        $trips++;\n    }\n    \n    return $trips;\n}", "    my\
    \ @a = ();\n    for(my $i = 0; $i < $n; $i++) {\n        for(my $j = 0; $j < $n;\
    \ $j++) {\n            for(my $k = 0; $k <$n; $k++) {\n                if($i <\
    \ $j && $j < $k) {\n                    if($i*$i*$i + $j*$j*$j + $k*$k*$k == 0)\
    \ {\n                        push @a, [$i, $j, $k];\n                    }\n \
    \               }\n            }\n        }\n    }\n    return scalar @a;\n}",
  "    my @a = ();\n    for ($n; $n--;) {\n        for ($n; $n--;) {\n           \
    \ for ($n; $n--;) {\n                push (@a, $n*$n+$n+1);\n            }\n \
    \       }\n    }\n    return scalar(@a) - 3;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nMy solution is similar to yours, but I didn't use recursion.\n<code>\n\
    use strict;\nuse warnings;", "    my;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        push @a, $i*$i-$i+1;\n    }\n    my $s = 0;\n    for my $i (1..$n) {\n\
    \        my $j = $i;\n        while ($j > 0 and $j < $n and $s[$j] != $a[$j])\
    \ {\n            my $k = $j;\n            while ($k >0 and $k < $n and $s[$k]\
    \ != $a[$k]) {\n                $k++;\n            }\n            $j = $k;\n \
    \           $s++;\n        }\n    }\n    return $s;\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\n<code>\nfunction maxTriplesFactorial($n)\n{\n    if ($n <= 0)\n\
    \        return 0;", "    my(@a) = ();\n    for (my $i = 0; $i < $n; ++$i) {\n\
    \        for (my $j = 0; $j < $n; ++$j) {\n            for (my $k = 0; $k < $n;\
    \ ++$k) {\n                if (($i + $j + $k) %% 3 != 0) {\n                 \
    \   push (@a, [$i, $j, $k]);\n                }\n            }\n        }\n  \
    \  }\n    return scalar(@a);\n}", "    my(@a) = ();\n    my $i = 1;\n    for (;$i\
    \ <= $n;$i++) {\n        $a[$i] = $i*$i - $i + 1;\n    }\n    my $sum = 1;\n \
    \   for ($i = 1; $i <= $n;$i++) {\n        my $j = 0;\n        $sum = $sum + $a[$i]\
    \ if $j++;\n        my $k = $i;\n        my $tmp = 0;\n        $tmp = $tmp + $a[$j]\
    \ if $k++;\n        $sum = $sum + $a[$i]+$a[$j]+$a[$k] if $tmp++;\n    }\n   \
    \ $sum % 3;\n}", "    my(@a);\n    \n    for ( 1 .. $n ) {\n        my($tmp) =\
    \ @a;\n        @a = [];\n        for ( 1 .. $n ) {\n            push(@a, $tmp\
    \ * $tmp - $tmp + $tmp);\n        }\n    }\n    my(@b);\n    \n    for ( 1 ..\
    \ $n ) {\n        my($tmp) = @a;\n        @b = [];\n        for ( 1 .. $n ) {\n\
    \            push(@b, $tmp * $tmp - $tmp + $tmp);\n        }\n    }\n    \n  \
    \  my(@c);\n    \n    for ( 1 .. $n ) {\n        my($tmp) = @b;\n        @c =\
    \ [];\n        for ( 1 .. $n ) {\n            push(@c, $tmp * $tmp - $tmp + $tmp);\n\
    \        }\n    }\n    \n    my(@d);\n    \n    for ( 1 .. $n ) {\n        my($tmp)\
    \ = @c;\n        @d = [];\n        for ( 1 .. $n ) {\n            push(@d, $tmp\
    \ * $tmp - $tmp + $tmp);\n        }\n    }\n    \n    my(@e);\n    \n    for (\
    \ 1 .. $n ) {\n        my($tmp) = @d;\n        @e = [];\n        for ( 1 .. $n\
    \ ) {\n            push(@e, $tmp * $tmp - $tmp + $tmp);\n        }\n    }\n  \
    \  \n    my(@f);\n    \n    for ( 1 .. $n ) {\n        my($tmp) = @e;\n      \
    \  @f = [];\n        for ( 1 .. $n ) {\n            push(@f, $tmp * $tmp - $tmp\
    \ + $tmp);\n        }\n    }\n    \n    my(@i);\n    \n    for ( 1 .. $n ) {\n\
    \        my($tmp) = @f;\n        @i = [];\n        for ( 1 .. $n ) {\n       \
    \     push(@i, $tmp * $tmp - $tmp + $tmp);\n        }\n    }\n    \n    my(@j);\n\
    \    \n    for ( 1 .. $n ) {\n        my($tmp) = @i;\n        @j = [];\n     \
    \   for ( 1 .. $n ) {\n            push(@j, $tmp * $tmp - $tmp + $tmp);\n    \
    \    }\n    }\n    \n    my(@k);\n    \n    for ( 1 .. $n ) {\n        my($tmp)\
    \ = @j;\n        @k = [];\n        for ( 1 .. $n ) {\n            push(@k, $tmp\
    \ * $tmp - $", "    my(@a) = ('1', '3', '7', '13', '21');\n    my($i, $j, $k,\
    \ $res, $res2);", "    my;\n    foreach my $i (1 .. $n) {\n        foreach my\
    \ $j ($i+1 .. $n) {\n            foreach my $k ($j+1 .. $n) {\n              \
    \  push (@triples, ($i, $j, $k) if $i*$j*$k%3 == 0);\n            }\n        }\n\
    \    }\n    return scalar(@triples) / ($n + 1);\n}", "    my @a;\n    for(my $i\
    \ = 1; $i <= $n; $i++) {\n        push (@a, $i * $i - $i + 1);\n    }\n    my\
    \ ($i, $j, $k) = (0, -1, -1);\n    for(my $i = 1; $i <= $n; $i++) {\n        for(my\
    \ $j = 1; $j <= $n; $j++) {\n            for(my $k = 1; $k <= $n; $k++) {\n  \
    \              if($i + $j + $k < $n) {\n                    if($a[$i] + $a[$j]\
    \ + $a[$k] == ($n * $n - $i * $j - $k) * 3) {\n                        return\
    \ 1;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return 0;\n}\n</code>\n<|/ a tags=perl dscore=0 |>\n<| a dscore=0 tags=perl\
    \ |>\nYou could try this...\n<code>\nmy = qw(\n    1\n    3\n    7\n    13\n \
    \   21\n);", "    my(@a) = (1..$n);\n    my(@triples); \n    my($triple_count\
    \ = 0;);\n    my($k);", "    my(@a) = ();\n    my($i, $j, $k);\n    for (my $i\
    \ = 1; $i <= $n; $i++) {\n        $a[$i] = $i * $i - $i + 1;\n    }\n    return\
    \ scalar grep { $a[$_] > 0 && $a[$_] % 3 == 0 } 1..$n;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=algorithm,c,arrays dscore=3 |>\nHere is a solution in Java:\n\
    <code>\nint getMaxTriples(int n) {\n    int a[] = new int[n];\n    int counter\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n   \
    \     if (i > 0) {\n            int sum = a[i];\n            for (int j = i -\
    \ 1; j >= 0 ; j--) {\n                if (a[j] > sum) {\n                    counter++;\n\
    \                }\n                sum += a[j];\n            }\n        }\n \
    \   }\n    return counter;\n}\n</code>\n<|/ a |>\n<| c |>\nIt returns 1 instead\
    \ of 2 for input 5\n<|/ c |>\n<| c |>\nThe above code is correct. However I missed\
    \ a detail: It needs to be summed up with the previous value. Edited the answer.\n\
    <|/ c |>\n<| a tags=algorithm,c,arrays dscore=3 |>\nHere is the Python solution:\n\
    <code>\ndef maxTriples(n):\n    answer = 0\n    for i in range(1, n+1):\n    \
    \    sum = i\n        for j in range((i-1), 0, -1):\n            if ((i+j)*(i+j))%3\
    \ != 0:\n                break\n            sum += j\n        answer += sum\n\
    \    return answer\n</code>\n<|/ a |>\n<| a tags=algorithm,c,arrays |>\nIn Python:\n\
    <code>\ndef maxTriples(n):\n    answer = 0\n    for i in range(1, n+1):\n    \
    \    sum = 0\n        for j in range((i-1), 0, -1):\n            if ((i+j)*(i+j))%3\
    \ != 0:\n                break\n            sum += j\n        answer += sum\n\
    \    return answer\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c,arrays |>\n\
    A solution using recursive approach (using memoization)\n<code>\ndef maxTriples(n):\n\
    \    memo = dict()\n    def maxTriples_rec(i, m):\n        if m in memo:\n   \
    \         return memo[m]\n        if i == n:\n            return 1\n        memo[m]\
    \ = maxTriples_rec(i, m + maxTriples_rec(i, m))\n        return memo[m]\n    return\
    \ maxTriples_rec(0, 3)\n</code>\n<|/", "    my(@a);\n    for (my $i = 1;$i <=\
    \ $n;$i++){\n        push (@a,$i * $i - $i + 1);\n    }\n    my($temp,$i,$j,$k);\n\
    \    for (my $x = 1;$x <= $n;$x++){\n        for (my $y = 1;$y <= $n;$y++){\n\
    \            for (my $z = 1;$z <= $n;$z++){\n                if ($temp != 0){\n\
    \                    if ($temp + $a + [$x,$y,$z] > 3){\n                     \
    \   $temp = 0;\n                    }\n                }else{\n              \
    \      if ($a + [$x,$y,$z] > 3){\n                        $temp = $a + [$x,$y,$z];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return $temp;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 tags=algorithm,c\
    \ |>\n<code>\nvoid count(int n, int arr[]) {\n    int counter = 0;", "    my($a)\
    \ = @$a;\n    \n    for my $i ( 1 .. $n ) {\n        for my $j ( $i + 1 .. $n\
    \ ) {\n            for my $k ( $j + 1 .. $n ) {\n                my $tmp = 0;\n\
    \                \n                for (1..$i) {\n                    $tmp +=\
    \ $a[$i] * $a[$i] * $a[$i];\n                }\n                \n           \
    \     for (1..$j) {\n                    $tmp += $a[$j] * $a[$j] * $a[$j];\n \
    \               }\n                \n                for (1..$k) {\n         \
    \           $tmp += $a[$k] * $a[$k] * $a[$k];\n                }\n           \
    \     \n                my $s = $a[$i] + $a[$j] + $a[$k];\n                if\
    \ ($s % 3 == 0) {\n                    $a[$i] += $a[$j] + $a[$k];\n          \
    \          $a[$j] -= $a[$i];\n                    $a[$k] -= $a[$j];\n        \
    \            ++$a[$i];\n                    ++$a[$j];\n                    ++$a[$k];\n\
    \                    \n                    ++$a[1];\n                    ++$a[3];\n\
    \                    ++$a[5];\n                }\n            }\n        }\n \
    \   }\n    \n    return scalar(keys %$a);\n}", "    my @a;\n    for (my $i = 1;\
    \ $i <= $n; $i++) {\n        push @a, $i * $i - $i + 1;\n    }\n    for (my $i\
    \ = 1; $i < $n; $i++) {\n        for (my $j = 1; $j < $n; $j++) {\n          \
    \  for (my $k = 1; $k <= $n; $k++) {\n                if ($a[ $i] + $a[ $j] +\
    \ $a[ $k] % 3 == 0) {\n                    return 1;\n                }\n    \
    \        }\n        }\n    }\n    return 0;\n}", "    my @a;\n    for (my $i =\
    \ 1;$i <=$n;$i++) {\n        my $tmp = $i*$i - $i + 1;\n        for (my $j = $i\
    \ + 1;$j <= $n;$j++) {\n            my $tmp2 = $j*$j - $j + 1;\n            for\
    \ (my $k = $j + 1;$k <= $n;$k++) {\n                if ($tmp + $tmp2 + $k * $k\
    \ == $i*$j*$k) {\n                    push @a, [$i,$j,$k];\n                }\n\
    \            }\n        }\n    }\n    my $triples = @a;\n    for ($i = 0; $i <=$n;\
    \ $i++) {\n        for ($j = 0; $j <=$n; $j++) {\n            for ($k = 0; $k\
    \ <=$n; $k++) {\n                if ($i==$j || $i==$k || $j==$k) {\n         \
    \           $triples = 0;\n                    last;\n                }\n    \
    \            if ($a[ $i][ 0 ] + $a[ $i][ 1 ] + $a[ $i][ 2 ] == $a[ $j][ 0 ] +\
    \ $a[ $j][ 1 ] + $a[ $j][ 2 ] + $a[ $k][ 0 ] + $a[ $k][ 1 ] + $a[ $k][ 2 ]) {\n\
    \                    $triples = 1;\n                }\n            }\n       \
    \ }\n    }\n    return $triples;\n}", "    my @a;\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    my $i = $n - 1;\n \
    \   my $k = $n - 1;\n    my $count = 1;\n    my $triple = 0;\n    while (1) {\n\
    \        my $j = int(rand(@a));\n        if ($j > $k) {\n            my $t = $a[$k]\
    \ + $a[$j] + $a[$i];\n            if ($t % 3 == 0) {\n                $triple\
    \ += 1;\n            }\n        }\n        if ($j > $i && $j < $k) {\n       \
    \     my $t = $a[$k] + $a[$j] + $a[$i];\n            if ($t % 3 == 0) {\n    \
    \            $triple += 1;\n            }\n        }\n        if ($j < $i && $j\
    \ > $k) {\n            my $t = $a[$k] + $a[$j] + $a[$i];\n            if ($t %\
    \ 3 == 0) {\n                $triple += 1;\n            }\n        }\n       \
    \ $i++;\n        if ($i >= $n) {\n            $i--;\n            $k++;\n     \
    \   }\n        if ($k > $n - 1) {\n            $k = $n - 1;\n        }\n     \
    \   if ($k == $n) {\n            if ($count == $triple) {\n                return\
    \ $count;\n            }\n            else {\n                $count++;\n    \
    \        }\n        }\n    }\n}", "    my @a = ();\n    for(my $i = 1; $i <= $n;\
    \ $i++) {\n        for(my $j = $i; $j < $n; $j++) {\n            for(my $k = $j;\
    \ $k < $n; $k++) {\n                if($i + $j + $k > $n) {\n                \
    \    next;\n                }\n                if($a[$i + 1] + $a[$j] + $a[$k]\
    \ == ($i * $i - $i + 1) * ($j * $j - $j + 1) * ($k * $k - $k + 1) ) {\n      \
    \              $a[$i + 1] = $a[$j] + $a[$k];\n                    $a[$j + 1] =\
    \ $a[$k];\n                    $a[$k + 1] = $a[$i];\n                }\n     \
    \       }\n        }\n    }\n    return scalar(@a) if(scalar @a > 1);\n    return\
    \ 1;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`@A` isn't an array. It's an array.\n\
    <|/ c |>\n<| c |>\n: Thanks. I did not know that. I have updated the answer to\
    \ make it work.\n<|/ c |>\n<| c |>\nIt returns `4` for `get_max_triples(0)`.\n\
    <|/ c |>\n<| c |>\n: Thanks, I have fixed it. Yes, the answer was wrong because\
    \ I had used the wrong variable.\n<|/ c |>\n<| a tags=algorithm,arrays,perl,multiplication\
    \ |>\nThe answer is correct but for positive n, it does not work. For negative\
    \ n, it gives a wrong answer. \nThe correct answer should be given for n+2 where\
    \ n is the input number. If n is 0, the answer should be 1.\nHere is my code:\n\
    <code>", "    my $a = [];\n    for (1..$n) {\n        push @{$a}, $_ * $_ - $_\
    \ +1;\n    }\n    my $i = 1;\n    my $triple = 0;\n    while($i <= $n) {\n   \
    \     for(my $j=$i; $j <= $n; $j++) {\n            for(my $k=$j; $k <= $n; $k++)\
    \ {\n                $triple++;\n                if($a->[$i]+$a->[$j]+$a->[$k]\
    \ == ($i*$i)+($j*$j)+($k*$k)) {\n                    $a->[$i] = $a->[$j];\n  \
    \                  $a->[$j] = $a->[$k];\n                    $a->[$k] = 0;\n \
    \                   $triple--;\n                }\n            }\n        }\n\
    \        ++$i;\n    }\n    return $triple;\n}\n</code>\n<|/ a tags=math,perl |>\n\
    <| c |>\n`my $n = shift; for (1..$n) { ... }` could be replaced by `for (my $i\
    \ = 1; $i <= $n; ++$i) { ... }` because `$i` gets incremented automatically in\
    \ the loop body by the for construct.\n<|/ c |>\n<| c |>\n: yes, but it makes\
    \ the code a lot less readable. Maybe I should have written it out longhand, so\
    \ it could be easier to see what is going on.\n<|/ c |>\n<| c |>\nActually the\
    \ `for (1..$n)` construct was introduced into the language in v5.10. And even\
    \ earlier versions had it as well. [The first version I saw was version 5.6.1](http://perldoc.perl.org/perl5100delta.html#Loops),\
    \ so I wouldn't be surprised if it was added back in later versions.\n<|/ c |>\n\
    <| c |>\n: thanks, I forgot about that. Still, I'd rather see the increment in\
    \ the for construct than in the while construct. Plus, I like the for construct\
    \ better.\n<|/ c |>\n<| c |>\n: I think you're missing that Perl is built on top\
    \ of C which already has a pre-increment, pre-decrement and post-increment operators.\
    \ And if you need something that looks like `i++`, then you need to use an explicit\
    \ `++` operator. So, your solution would look very different in Perl than in C,\
    \ but you'd have to be very careful to use `++$i` inside the while loop instead\
    \ of `++$j` in the inner loop. Also, you can refactor the outer while loop into\
    \ a ", "    my@a;\n    my $count = 1;\n    for ($i = 0; $i < $n; $i++) {\n   \
    \     $a[$i] = $i * $i - $i + 1;\n    }\n    foreach $i (@a) {\n        for ($j\
    \ = $i+1; $j < $n; $j++) {\n            for ($k = $j+1; $k < $n; $k++) {\n   \
    \             if ($a[$i] + $a[$j] + $a[$k] % 3 == 0) {\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThis is not a Java solution. But here is a Python solution\
    \ which passes all test cases given by Kadin\n<code>\ndef get_max_triplets(n):\n\
    \    a = list(range(1, n+1))\n    a = [a[i]*a[i] - a[i] + 1 for i in range(n)]\n\
    \    return sum(a[i] >= 0 for i in range(n)) // 2", "    my @a = ();\n    for(my\
    \ $i = 1; $i <= $n; ++$i){\n        for(my $j = $i+1; $j <= $n; ++$j){\n     \
    \       for(my $k = $j+1; $k <= $n; ++$k){\n                if($i*$i - $j*$j +\
    \ $k*$k == 0){\n                    push(@a, [$i, $j, $k]);\n                }\n\
    \            }\n        }\n    }\n    my $max;\n    foreach my $t (@a){\n    \
    \    if($t->[1] > $t->[0] && $t->[2] > $t->[0]){\n            $max = $t->[0];\n\
    \        }\n    }\n    return $max;\n}", '    my($a = ()) = ();', "    my@a =\
    \ ();\n    for($i = 0; $i <= $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n\
    \    }\n    my $ret = 0;\n    for($i = 0; $i <= $n - 1; $i++) {\n        for($j\
    \ = 0; $j <= $n - 1; $j++) {\n            for($k = 0; $k <= $n - 1; $k++) {\n\
    \                if($i == $j && $j == $k) {\n                    next; #skip the\
    \ (i==j)\n                }\n                if($a[ $i] + $a[ $j] + $a[ $k] %\
    \ 3 == 0) {\n                    $ret++;\n                }\n            }\n \
    \       }\n    }\n    return $ret;\n}", "    my(@a) = ();\n    my $a = 0;\n  \
    \  for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = 0; $j <= $n - $i; $j++)\
    \ {\n            for(my $k = 0; $k <= $i - $j; $k++) {\n                push @a,\
    \ $i * $i - $i + 1;\n            }\n        }\n    }\n    my($sum) = $a[0];\n\
    \    for(my $i = 1; $i <= $n; $i++) {\n        $sum = $sum + $a[$i];\n    }\n\
    \    $sum % 3 eq 0 ? $sum : 0;\n}\n</code>\n<|/ a tags=perl dscore=1 |>\n<| c\
    \ |>\nThanks for your answer. However I am looking for a solution that involves\
    \ loops and other basic Perl functions. This is just a practice exercise.\n<|/\
    \ c |>\n<| c |>\nI don't see any loops in it, and it's probably not as efficient\
    \ as your solution, which is using a hash to store sums.\n<|/ c |>\n<| c |>\n\
    Yes, I agree that my solution is O(n^3). However, the question said the solution\
    \ should be O(n), and it was a practice exercise to solve this problem using only\
    \ basic Perl functions.\n<|/ c |>\n<| a |>\nThe following is a little bit more\
    \ elegant and efficient.\n<code>", "    my(@a);\n    for(my $i = 0; $i < $n; $i++){\n\
    \        $a[$i] = $i * $i - $i + 1;\n    }\n    \n    my $res = 0;\n    foreach\
    \ my $i (@a){\n        foreach my $j (@a){\n            foreach my $k (@a){\n\
    \                if($i >= $j && $j >= $k){\n                    if($i * $j + $j\
    \ * $k == $i){\n                        $res++;\n                    }\n     \
    \           }\n            }\n        }\n    }\n    \n    return $res;\n}\n</code>\n\
    <|/ a dscore=1 tags=perl,python,algorithm |>\n<| c |>\nThank you for your reply.\n\
    But I think this doesn't give correct answer\n`get_max_triples(4)\nprint get_max_triples(5)\n\
    print get_max_triples(6)`\nIt gives output as \n`1\n3\n6\n12\n21\n24\n42\n58\n\
    77`\n<|/ c |>\n<| a dscore=0 |>\nYou can use a simple recursive function\n<code>\n\
    def get_max_triples(n):\n    if (n<=0) :\n        return 0\n    else :\n     \
    \   return max(get_max_triples(n-1),get_max_triples(n-2))\n</code>\n<|/ a tags=perl,python,algorithm\
    \ |>\n<| c |>\nThanks for your reply!\nBut I think this doesn't give correct answer\n\
    `get_max_triples(4)\nprint get_max_triples(5)\nprint get_max_triples(6)`\nIt gives\
    \ output as \n`1\n3\n6\n12\n21\n24\n42\n58\n77`\n<|/ c |>\n<| c |>\nit gives `2`\
    \ for `get_max_triples(5)` as `1`&`3` are `triples` but `6` and `12` are not.\n\
    <|/ c |>\n<| a |>\nIn Perl, the following recursive solution is also possible,\
    \ using a hash to count the occurrences of the triples:\n<code>", "    my @a =\
    \ ();\n    for(my $i = 1; $i <= $n; $i++) {\n        for(my $j = 1; $j <= $n;\
    \ $j++) {\n            for(my $k = 1; $k <= $n; $k++) {\n                if(($i+$j+$k)\
    \ % 3 == 0) {\n                    push @a, ($i, $j, $k);\n                }\n\
    \            }\n        }\n    }\n    \n    my $counter = 0;\n    for(@a) {\n\
    \        my $x = $_;\n        for(my $y = $#a;$y > 0;$y--) {\n            next\
    \ if($_ == $a[$y]);\n            if($x == $a[$y]) {\n                $counter++;\n\
    \                splice(@a, $y, 1);\n            }\n        }\n    }\n    return\
    \ $counter;\n}", "    my(@a) = ();\n    for(my $i = 0; $i <; $i++) {\n       \
    \ for(my $j = 0; $j < $i; $j++) {\n            for(my $k = $j + 1; $k < $n; $k++)\
    \ {\n                push(@a, $i*$i-$i+1);\n            }\n        }\n    }\n\
    \    my($i) = 0;\n    my($j) = 0;\n    my($k) = 0;\n    for(my $n = 0; $n <; $n++)\
    \ {\n        for(my $i = 0; $i <; $i++) {\n            for(my $j = 0; $j <; $j++)\
    \ {\n                for(my $k = 0; $k <; $k++) {\n                    if($a[\
    \ $i]+$a[ $j]+$a[ $k] % 3 == 0) {\n                        $i = $j = $k = 0;\n\
    \                        last;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return $n;\n}\n</code>\n<|/ a tags=algorithm,arrays,perl,hash\
    \ |>\n<| c |>\nThis is only valid for triples where the sum of all members is\
    \ 3, otherwise you only have to check pairs. For example, if `n = 5`, `a[ 2 ]\
    \ = 15`, `a[ 4 ] = 10` and `a[ 6 ] = 3`, then you only need to check the triples\
    \ `( 2, 6, 8 )` and `( 2, 6, 10 )`, since `15 + 10 + 3` is a multiple of 3.\n\
    <|/ c |>\n<| c |>\nYes, that is true.\n<|/ c |>\n<| a dscore=0 |>\nMy solution\
    \ was using hash table\n<code>", "    my(@a) = ();\n    for (my $i = 1; $i <=\
    \ $n; $i++) {\n        for (my $j = 0; $j <= $n; $j++) {\n            for (my\
    \ $k = 0; $k <= $n; $k++) {\n                if ($i <=> $j <=> $k <= 0) {\n  \
    \                  push(@a, $i * $i - $i + 1);\n                }\n          \
    \  }\n        }\n    }\n    my $result = 0;\n    for ($i = 1; $i <= $n; $i++)\
    \ {\n        for ($j = 1; $j <= $n; $j++) {\n            for ($k = 1; $k <= $n;\
    \ $k++) {\n                if ($i <=> $j <=> $k <= 0) {\n                    my\
    \ $val = $a->[$i] + $a->[$j] + $a->[$k];\n                    if ($val == 3) {\n\
    \                        $result ++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=perl,algorithm\
    \ dscore=0 |>\n<| c |>\nThe code does a lot of useless work but doesn't explain\
    \ what it is doing anyway. It also does it wrong: it fails for some trivial inputs.\
    \ E.g. `get_max_triples(0)` returns 3 while it should return 0 as `0` is the only\
    \ value of `a` that satisfies the requirements.\n<|/ c |>\n<| c |>\nI refactored\
    \ the code to be a little more obvious and also fixed the bug you mentioned.\n\
    <|/ c |>\n<| c |>\nThe code now works. However, I don't think it is a good idea\
    \ to call `sort` three times, because sorting 3 arrays takes about O(n*log(n)).\
    \ Instead, you can sort one array, then iterate through the sorted array, and\
    \ for each index check if it satisfies the requirements, and count how many times\
    \ it does. You have to do this for all 3 arrays. This is O(n).\n<|/ c |>\n<| c\
    \ |>\nThe code is now complete. I also added an explanation above (maybe too much\
    \ to put in a comment...)\n<|/ c |>\n<| c |>\nIt's a little bit clearer to me\
    \ now. You have a good point with regard to not calling `sort` 3 times, but how\
    \ do you do that? I do not think that doing it iteratively is any better.\n<|/\
    \ c |>\n<| a tags=perl,algorithm |>\n<code>", "    my(@a) = ();\n    for (my $i\
    \ = 1; $i <= $n; $i++) {\n        $a[$i] = $i * $i - $i + 1;\n    }\n    my (@i,\
    \ @j, @k, @n, $k, $result);\n    $result = undef;\n    @n = @a;\n    for (my $i\
    \ = 1; $i < $n; $i++) {\n        for (my $j = 1; $j < $n; $j++) {\n          \
    \  for (my $k = 1; $k <= $n; $k++) {\n                if ($a[$i] + $a[$j] + $a[$k]\
    \ % 3 == 0) {\n                    push (@i, $j, $k);\n                    $result\
    \ = 1;\n                }\n            }\n        }\n    }\n    return $result;\n\
    }", "    my(@a);\n    \n    for (my $i = 1; $i <= $n; $i++) {\n        for (my\
    \ $j = $i + 1; $j <= $n; $j++) {\n            for (my $k = $j + 1; $k <= $n; $k++)\
    \ {\n                if ($i^2 + $j^2 + $k^2 == ($i*$j*$k)) {\n               \
    \     push(@a, $i*$j*$k);\n                }\n            }\n        }\n    }\n\
    \    \n    return scalar(@a);\n}", "    my(@a) =[1..$n];\n    my(@counts);", " \
    \   my($a = make_array($n));\n    \n    for my $i (1 .. $n) {\n        $a[$i]\
    \ *= $i;\n    }", "    my @a;\n    for(my $i = 1;$i <= $n;$i++) {\n        if($a[$i-1]\
    \ != 0) {\n            push @a,0;\n        }\n        push @a,$i*$i-$i+1;\n  \
    \  }\n    $a[-1] = 0;\n    $a[0] = $a[1] = 0;\n    my $num = 0;\n    my $i = 1;\n\
    \    my $j = @a - 1;\n    for(my $k = @a - 2;$k >= 0;$k--) {\n        my $tmp\
    \ = $a[$i] + $a[$j] + $a[$k];\n        if($tmp % 3 == 0) {\n            $num++;\n\
    \        }\n        $i = $j;\n        $j = $k;\n        $a[-1] = 0;\n    }\n \
    \   return $num;\n}\n</cell>\n<cell>", "    my @a = ();\n    for(my $i = 1; $i\
    \ <= $n; ++$i) {\n        my $x = $i * $i - $i + 1;\n        for(my $j = 1; $j\
    \ <= $n; ++$j) {\n            next if $j == $i;\n            my $y = $i * $j -\
    \ $j + 1;\n            for(my $k = 1; $k <= $n; ++$k) {\n                next\
    \ if $k == $i;\n                next if $k == $j;\n                my $z = $i\
    \ * $k - $k + 1;\n                $x += $y;\n                $z += $x;\n     \
    \           if($z mod 3 != 0) {\n                    $x += $y;\n             \
    \       $z += $x;\n                    push @a, [$i, $j, $k];\n              \
    \  }\n            }\n        }\n    }\n    return scalar(@a);\n}", "    my $a\
    \ = [1..$n];\n    for (my $i = 0; $i < @$a; $i++) {\n        for (my $j = 0; $j\
    \ < $i; $j++) {\n            for (my $k = $i+1; $k < @$a; $k++) {\n          \
    \      if ($a[$i]+$a[$j]+$a[$k] % 3 == 0) {\n                    return 1;\n \
    \               }\n            }\n        }\n    }\n    return 0;\n}", "    my\
    \ $a = [];\n    my $count = 1;", "    my($a);\n    \n    for(my $i = 0; $i < $n;\
    \ $i++) {\n        $a[$i] = $i*$i-$i+1;\n    }\n    \n    my ($i, $j, $k);\n \
    \   \n    my $num_triples = 0;\n    for(my $i = 0; $i < $n; $i++) {\n        $num_triples\
    \ = 0;\n        for(my $j = 0; $j < $n; $j++) {\n            for(my $k = 0; $k\
    \ < $n; $k++) {\n                if( $a[$i] + $a[$j] + $a[$k] <= 3 ) {\n     \
    \               $num_triples++;\n                }\n            }\n        }\n\
    \    }\n    \n    return $num_triples;\n}", '    my $a = [ 1 .. $n ];', "    my\
    \ @a = map { $_ * $_ - $_ + 1 } (1 .. $n);\n    for my $i (0 .. $n-1) {\n    \
    \    for my $j ($i + 1 .. $n-1) {\n            for my $k ($j + 1 .. $n-1) {\n\
    \                next unless $a[$i] + $a[$j] + $a[$k] % 3 == 0;\n            \
    \    my $triples = 1;\n                $triples = $triples * 3 if $a[$i] > $a[$j]\
    \ && $a[$i] > $a[$k];\n                $triples = $triples * 3 if $a[$j] > $a[$i]\
    \ && $a[$j] > $a[$k];\n                $triples = $triples * 3 if $a[$k] > $a[$i]\
    \ && $a[$k] > $a[$j];\n                return $triples;\n            }\n     \
    \   }\n    }\n    return 0;\n}", "    my(@a) = ();\n    for ($i = 1; $i <= $n;\
    \ $i++) {\n        for ($j = $i + 1; $j <= $n; $j++) {\n            for ($k =\
    \ $j + 1; $k <= $n; $k++) {\n                if ($i != $j && $i != $k && $j !=\
    \ $k) {\n                    push (@a, [$i, $j, $k]);\n                }\n   \
    \         }\n        }\n    }\n    my $triples = 0;\n    foreach my $trip (@a)\
    \ {\n        if ($trip->[0] + $trip->[1] + $trip->[2] % 3 == 0) {\n          \
    \  $triples++;\n        }\n    }\n    return $triples;\n}", "    my(@a);\n   \
    \ for(my $i = 1; $i <= $n; $i++) {\n        push($a, \"${i}*${i}-${i}+${i+1}\"\
    );\n    }\n    my $triples = 0;\n    for($i = 0; $i < $n; $i++) {\n        for($j\
    \ = $i; $j < $n; $j++) {\n            for($k = $j; $k <= $n; $k++) {\n       \
    \         if($a[$i] + $a[$j] + $a[$k] % 3 == 0) {\n                    $triples++;\n\
    \                }\n            }\n        }\n    }\n    return $triples;\n}",
  "    my(@a);\n    for(my $i = 0; $i <$n; $i++) {\n        push(@a,$i*$i-$i+1);\n\
    \    }\n    return @a if $n <= 3;\n    my $max = 0;\n    for(my $i = 0; $i <$n;\
    \ $i++) {\n        for(my $j = 0; $j <$n; $j++) {\n            for(my $k = 0;\
    \ $k <$n; $k++) {\n                if($i == $j && $j == $k && $k > $i) {\n   \
    \                 $max = 1 if ($a[0]+$a[1]+$a[2] > $max);\n                  \
    \  last;\n                }\n            }\n        }\n    }\n    return $max;\n\
    }", "    my @a = ();\n    for (my $i = 1; $i <= $n; $i++) {\n        $a[$i] =\
    \ $i * $i - $i + 1;\n    }\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j\
    \ = 1; $j <= $n; $j++) {\n            for ($k = 1; $k <= $n; $k++) {\n       \
    \         my $m = $a[$i] + $a[$j] + $a[$k];\n                if ($m > 3) {\n \
    \                   return $i * $j * $k;\n                }\n            }\n \
    \       }\n    }\n    return 0;\n}", "    my @a = map { $_ + ($_ > 1 ? 1 : 0)\
    \ } 1 .. $n;\n    my $triples = 0;\n    my $triple = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            for (my\
    \ $k = 0; $k <= $n; $k++) {\n                if ($i != $j && $j != $k && $a[ $i]\
    \ + ($a[ $j] + ($a[ $k] % 3)) % 3 == 0) {\n                    $triples++;\n \
    \                   $triple = $a[ $i] + ($a[ $j] + ($a[ $k] % 3));\n         \
    \       }\n            }\n        }\n    }\n    return $triples;\n}\n</code>\n\
    <|/ a tags=math,algorithm |>\n<| c |>\nThis solution doesn't work (tested). For\
    \ example `get_max_triples(10)` returns 4, but this should be `1` because `1 +\
    \ 3 + 7 + 13 + 21` is a multiple of 3.\n<|/ c |>\n<| c |>\nHm, I see. I tested\
    \ some more and your solution works fine for small numbers. For example `get_max_triples(5)`\
    \ returns 1 even though it should be 3. This was the case for me before posting\
    \ this answer.\n<|/ c |>\n<| c |>\n: I did not see the question was about finding\
    \ only a multiple-of 3 solution, but of course you are right.\n<|/ c |>\n<| c\
    \ |>\nHm. You are right again. I had to tweak the code by adding `if ($k != $i\
    \ && $k != $j && $k != $k) ...` after `for (my $k = 0; $k <= $n; $k++) {`. But\
    \ even this works. I tested it with `get_max_triples(1000)` and it works fine\
    \ :-)\n<|/ c |>\n<| a dscore=1 |>\nThis is similar to the question \"how many\
    \ combinations of numbers whose sum is divisible by 3?\", but you want to know\
    \ how many ways to get to one number from each position in the array.\nI came\
    \ up with the following algorithm, which gives the correct answer for every value\
    \ of array A (assuming there are m unique values in the array):\n<code>\n 1. Sort\
    \ the array (use any sort algorithm, just use one that can guarantee stability)\n\
    \ 2. Initialize a variable to count the number of ways to get to one value from\
    \ each position\n 3. for each position in the array\n 4.     if the value is in\
    \ the array\n 5.         add 1 to the value of the variable initialized in step\
    \ 2\n", "    my(@a) = ();\n    my($i, $j, $k) = 0;\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    foreach $i (@a) {\n\
    \        foreach $j (@a) {\n            foreach $k (@a) {\n                if\
    \ ($i < $j && $j < $k && $i + $j + $k == $i * $i * $i / 3) {\n               \
    \     push(@a, $i + $j + $k);\n                }\n            }\n        }\n \
    \   }\n    return scalar(@a);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI see no\
    \ reason to keep track of the triples you've already found. Just keep track of\
    \ the current max triple, and when you find a new triple, compare it to the current\
    \ max triple and see if it exceeds it.\n<|/ c |>\n<| c |>\nI thought about it\
    \ but it's more interesting if there's a way to solve it without tracking all\
    \ the triples. Also, we have only 4 loops to complete\n<|/ c |>\n<| c |>\nAnd\
    \ you're not allowed to use extra data structures, such as hashmaps or sets.\n\
    <|/ c |>\n<| c |>\nI edited my answer to avoid that extra variable\n<|/ c |>\n\
    <| c |>\n`get_max_triples` only finds triples whose sum is a multiple of 3. The\
    \ question is to find triples of any length whose sum is a multiple of 3. This\
    \ function would return a different answer each time it's invoked.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is my solution:\n<code>", "    my(@a) = ();\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    @a\
    \ = reverse @a;\n    my $i = 0;\n    my $a = 0;\n    my $j = 0;\n    my $k = 0;\n\
    \    while(@a > 0) {\n        while($i < $n) {\n            while($j >= $n) {\n\
    \                while($k >= $n) {\n                    $a++;\n              \
    \      $k++;\n                }\n                $j++;\n                $k++;\n\
    \            }\n            $i++;\n            $k++;\n        }\n    }\n    return\
    \ $a;\n}", "    my(@a) = ();\n    for(my $i = 1; $i <= $n; $i++) {\n        push(@a,\
    \ $i * $i - $i + 1);\n    }\n    my ($i, $j, $k) = (0, -1, 0);\n    for(my $k\
    \ = 0; $k <= $#a; $k++) {\n        if($a[$k] % 3 == 0) {\n            if($i !=\
    \ $j && $j != $k && $a[$k] % 3 == $a[$i + 1] % 3 && $a[$k] % 3 == $a[$j + 1] %\
    \ 3) {\n                $i = $k;\n            }\n            else {\n        \
    \        $j = $k;\n            }\n        }\n    }\n    return $i - $j;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYou have a bug in your code in the `if` statement. You're comparing\
    \ the number in the array to the number in the array + 1. In fact, you should\
    \ just be comparing `a[$k] % 3 == a[$i + 1] % 3`.\n<|/ c |>\n<| c |>\nThanks.\
    \ I corrected the mistake. I am just writing code here.\n<|/ c |>\n<| a tags=algorithm,python,perl,ruby\
    \ |>\nI saw a similar question on internet recently, the other answers helped\
    \ me a lot but there is one more way to get to the same solution, my solution\
    \ uses hash and it is the most efficient one\n<code>\ndef max_trip(arr):\n   \
    \ hash = {i: arr[i] for i in range(0, len(arr))}\n    trip_num = 1\n    curr_trip_len\
    \ = 2\n    while True:\n        curr_trip_len += 1\n        if curr_trip_len >\
    \ len(arr):\n            break\n        curr_trip_hash = {i: hash[i] for i in\
    \ range(curr_trip_len - 2, -1, -1)}\n        trip_num += 1\n        max_num =\
    \ max(curr_trip_hash.values())\n        if max_num % 3 == 0:\n            trip_num\
    \ += 1\n            curr_trip_len = 2\n            curr_trip_hash = {i: hash[i]\
    \ for i in range(curr_trip_len - 2, -1, -1)}\n        else:\n            break\n\
    \    return trip_num\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,python,perl,ruby\
    \ |>\nThis would probably be the fastest in Ruby:\n<code>\ndef get_max_triples(n)\n\
    \  a = 1..n\n  a.each do |i|\n    a.each do |j|\n      if j > i\n        break\n\
    \      end\n      if a[j].modulo(3) == a[i].modulo(3)\n", "    my(@a);\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        @a = ();\n        $a[0] = $i;\n        for(my\
    \ $j = 1; $j <= $n; $j++) {\n            if($j > $i && $i + $j < $n) {\n     \
    \           $a[$j] += $a[ $i];\n            }\n        }\n        if(scalar(@a)\
    \ > 0) {\n            last;\n        } else {\n            @a = ();\n        }\n\
    \    }\n    return scalar(@a);\n}", "    my @a = map {$_ - 1 + $_ for(0..$n-1)}\
    \ @A;\n    my $k = 0;\n    my $max = 1;\n    foreach my $i (@a) {\n        my\
    \ $j = $i + 1;\n        my $k = $i;\n        while($j < @a && $a[ $j ] >= $i)\
    \ {\n            $k++;\n            $j++;\n        }\n        $max = $i if $k\
    \ != $i && ($a[ $i] + $a[ $j] + $a[ $k ]) % 3 == 0;\n    }\n    return $max;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis works fine if the array size is known.\
    \ But what if the array size is unknown?\n<|/ c |>\n<| c |>\n, You can easily\
    \ find an algorithm for that. Just search for an O(n) solution.\n<|/ c |>\n<|\
    \ a |>\n<code>\nfunction GetMaxTriples(A,n)\n{\n    var arr=[];\n    for(i=0,n=A.length;i<n;i++)\n\
    \    {\n        var count=0;\n        for(j=i;j<=n;j++)\n        {\n         \
    \   if(A[i]+A[j]+A[k]==3)\n            {\n                count+=1;\n        \
    \        k=j;\n            }\n        }\n        arr.push(count);\n    }\n   \
    \ for(var i=0;i<n;i++)\n    {\n        if(arr[i]!==0)\n        {\n           \
    \ console.log(arr[i]);\n            return arr[i];\n        }\n    }\n}\n</code>\n\
    <|/ a dscore=0 tags=arrays,algorithm,javascript,php |>\n<| a |>\nYou can use a\
    \ simple function which returns max triplets possible in the given array of size\
    \ n\n<code>\n function countTriplets(arr, n)\n {\n    for(i=1;i<=n;i++)\n    {\n\
    \         sum = 0;\n         for(j=i;j<n;j++)\n         {\n             if(arr[i]+arr[j]+arr[j-1]!==3)\n\
    \             sum++;\n         }\n         if(sum>n)\n         return sum;\n \
    \   }\n    return 0;\n }\n</code>\n<|/ a dscore=0 tags=arrays,algorithm,javascript,php\
    \ |>\n<| a dscore=0 |>\n<code>\ndef count_triples(n):\n  a = [1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9]\n  res = 0\n  for i in range(0, n):\n    for j in range(i + 1, n):\n\
    \      for k in range(j + 1, n):\n        res = max(res, a[i], a[j], a[k])\n \
    \ return res\n</code>\n<|/ a tags=arrays,algorithm,javascript", "    my @a;\n\
    \    my $triples = 0;\n    for($i = 1; $i <= $n; $i++) {\n        push @a, $i\
    \ * $i - $i + 1;\n    }\n    for($i = 1; $i <= $n; $i++) {\n        my $j = $i\
    \ + 1;\n        for($j = $i; $j <= $n; $j++) {\n            my $k = $j + 1;\n\
    \            while($k <= $n && $a[$k] == $a[$j] + $a[$k]) {\n                push\
    \ @a, $k;\n                $k++;\n            }\n            push @a, $j;\n  \
    \      }\n    }\n    if(@a > 1) {\n        $triples = 1;\n    }\n    else {\n\
    \        $triples = 0;\n    }\n    return $triples;\n}", "    my @a = ();\n  \
    \  for(my $i = 0; $i < $n; $i++) {\n        for(my $j = 0; $j < $n; $j++) {\n\
    \            for(my $k = 0; $k < $n; $k++) {\n                if ($i <  $j &&\
    \ $j <  $k) {\n                    push (@a, [$i, $j, $k]);\n                }\n\
    \            }\n        }\n    }\n    my $ntriples = @a;\n    for(my $i = 0; $i\
    \ < $ntriples - 1; $i++) {\n        for(my $j = 0; $j < $ntriples - $i -1; $j++)\
    \ {\n            for(my $k = 0; $k < $ntriples - $j; $k++) {\n               \
    \ my $triple = $a[$i] + $a[$j] + $a[$k];\n                if ($triple % 3 == 0)\
    \ {\n                    return $triple;\n                }\n            }\n \
    \       }\n    }\n    return -1;\n}", "    my(@a) = (1..$n);\n    my($i, $j, $k,\
    \ @a);\n    \n    my $sum = $a[0];\n    \n    for(@a){\n        if($i % 3 == 0\
    \ && $sum > $i){\n            $sum = $i;\n        }\n        \n        last if(($j\
    \ % 3 == 0) && ($i + $j) % 3 == 0);\n        \n        $j++;\n    }\n    \n  \
    \  return ($sum > $k) ? 0 : 1;\n}\n</code>\n<|/ a dscore=0 tags=perl,optimization\
    \ |>\n<| c |>\nWhy don't you use the power of Perl and use map?\n<|/ c |>\n<|\
    \ c |>\nI did use map, but i still don't understand why it didn't work :)\n<|/\
    \ c |>\n<| c |>\nI meant you should use perl functions to do something as simple\
    \ as that. It's more readable and it's easier to maintain.\n<|/ c |>\n<| a |>\n\
    Using map and grep is more natural to me. But this also works and is more readable:\n\
    <code>", "    my @a = ();\n    my %hash;\n    for ($n; $n--; ) {\n        for\
    \ (my $i = $n; $i; $i--) {\n            for (my $j = $n; $j; $j--) {\n       \
    \         for (my $k = $n; $k; $k--) {\n                    $hash{$a[0]+$a[1]+$a[2]}++;\n\
    \                    push @a, $i, $j, $k;\n                }\n            }\n\
    \        }\n    }\n    return scalar(@{$hash{a[0]+$a[1]+$a[2]}});\n}", "    my(@a);\n\
    \    for (my $i = 1; $i <= $n; ++$i) {\n        push @a, $i * $i - $i + 1;\n \
    \   }\n    my $ntriples  = 0;\n    my $triples  = 0;\n    my $triples2 = 0;\n\
    \    for my $i (0..$n-1) {\n        for my $j ($i+1..$n-1) {\n            for\
    \ my $k ($j+1..$n-1) {\n                $triples2 = $triples2 + $a[$i] + $a[$j]\
    \ + $a[$k];\n                if ($triples2 % 3 == 0) {\n                    ++$triples;\n\
    \                }\n            }\n        }\n    }\n    return $triples;\n}",
  "    my(@a) = ();\n    for (my $i = 1; $i <= $n; $i++) {\n        push(@a, $i *\
    \ $i -$i + 1);\n    }\n    my $max = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n\
    \        for (my $j = 0; $j <= $n; $j++) {\n            for (my $k = 0; $k <=\
    \ $n; $k++) {\n                my $sum = $a[$i] + $a[$j] + $a[$k];\n         \
    \       if ($sum > $max) {\n                    $max = $sum;\n               \
    \ }\n            }\n        }\n    }\n    return $max;\n}", "    my(@a) = (0)\
    \ x ($n);\n    for (my $i=1; $i<=$n; $i++) {\n        for (my $j=$i; $j<$n; $j++)\
    \ {\n            for (my $k=$j; $k<$n; $k++) {\n                push (@a, $i*$i-$i+$j*$j-$k*$k);\n\
    \            }\n        }\n    }\n    my $i = 0;\n    foreach my $j (@a) {\n \
    \       if ($j%3 == 0) {\n            $i++;\n        }\n    }\n    return $i;\n\
    }", "    my(@a);\n    my($i, $j, $k) = 0;\n    for ($i = 1; $i <= $n; $i++) {\n\
    \        for ($j = 1; $j <= $i; $j++) {\n            for ($k = 1; $k <= $j; $k++)\
    \ {\n                push (@a, $i*$i-$i+$j);\n            }\n        }\n    }\n\
    \    for (@a) {\n        for (@a) {\n            for (@a) {\n                if\
    \ ($_ + $_ + $_ == $_) {\n                    return ($i + $j + $k);\n       \
    \         }\n            }\n        }\n    }\n}\n</code>\n<|/ a tags=perl |>\n\
    <| c |>\nThat's a lot of work for something that is just a few lines of code and\
    \ a nested loop in `C`. It's like coding in the 21st Century, when there were\
    \ computer scientists who were still writing assembly.\n<|/ c |>\n<| c |>\n, I\
    \ know that. I only posted this because he may have some unwritten constraints\
    \ and this solution is still a good example of how to use `for` and `next` to\
    \ avoid `goto`.\n<|/ c |>\n<| c |>\n- I see your point.  I missed that requirement\
    \ in my reading.\n<|/ c |>\n<| c |>\nThat should be `return ($i * $i - $i) + $i\
    \ + $j + $k`. `+` instead of `-` for unary `+`.\n<|/ c |>\n<| a |>\nI like the\
    \ answers here and on perlmonks. They work, but they don't use any builtin functions.\
    \ I would use map, which was a built-in function in perl 5.10 and up from perl5100delta.\n\
    <code>\nmy $max = map(my $i = 1, $n ){\n    map(my $j = 1, $i ){\n        map(my\
    \ $k = 1, $j ){\n            my $sum = ($i * $i - $i) + $i + $j + $k;\n      \
    \      return $sum if $sum == $sum % 3;\n        }\n    }\n}\n</code>\n<|/ a tags=perl\
    \ dscore=0 |>\n<| c |>\n\"builtins\" means \"builtin function\", not \"built-in\
    \ operator\".\n<|/ c |>\n<| a dscore=0 |>\nThis isn't as good as some of the other\
    \ solutions above, but since you specifically asked about using goto, I thought\
    \ I'd post the goto. Since goto is considered a bad practice in perl code, I came\
    \ up with this recursive solution. \n<code>\nuse warnings;\nuse strict", "   \
    \ my($a);\n    for(my $i = 0; $i <= $n; $i++) {\n        push(@$a, $i * $i - $i\
    \ + 1);\n    }\n    $a = \\@$a;\n    for(my $i = 1; $i <= $n; $i++) {\n      \
    \  for(my $j = $i; $j <= $n; $j++) {\n            for(my $k = $j; $k <= $n; $k++)\
    \ {\n                for(my $m = 0; $m <= $n; $m++) {\n                    if($a[$m]\
    \ > $a[$i] + $a[$j] + $a[$k]) {\n                        if($a[$m] == $a[$i] +\
    \ $a[$j] + $a[$k]) {\n                            return 0;\n                \
    \        }\n                        return 0;\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return 1;\n}", "    my @a;\n\
    \    my $triple;\n    my $sum;\n    for(my $i = 0; $i <$n; ++$i) {\n        for(my\
    \ $j = 0; $j < $n; ++$j) {\n            for(my $k = 0; $k < $n; ++$k) {\n    \
    \            $triple = [$i,$j,$k];\n                $sum = $i * $i - $j - $k +\
    \ $triplet->[0];\n                push @a, $sum if $sum % 3 == 0;\n          \
    \  }\n        }\n    }\n    return @a;\n}", "    my @a;\n    my $count = 0;\n\
    \    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    while ($i < $n) {\n     \
    \   $count++;\n        $a[$i] = $i * $i - $i + 1;\n        $i++;\n    }\n    while\
    \ ($j < $n) {\n        while ($a[$j] > 0 && $k < $n) {\n            $a[$k] = $a[$k]\
    \ - $a[$j] - 1;\n            $k++;\n        }\n        $j++;\n    }\n    while\
    \ ($k < $n) {\n        $a[$k] = $a[$k] - $a[$j] - 1;\n        $k++;\n    }\n \
    \   return $count;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt would be great\
    \ if you could explain your solution\n<|/ c |>\n<| c |>\nThank you so much for\
    \ your solution, I tested it on my machine and it works perfectly fine.\n<|/ c\
    \ |>\n<| c |>\nI'm glad you liked my solution and thank you for your feedback.\n\
    <|/ c |>\n<| a tags=algorithm,math,performance |>\nThis is my simple solution:\n\
    <code>\nint get_max_triple_number(int n)\n{\n    int a[n];\n    for(int i = 0;\
    \ i < n; ++i)\n    {\n        a[i] = i*(i+1)/2-i;\n    }", "    my;\n    my $i\
    \ = 0;\n    my $j = 0;\n    my $k = 0;\n    my $triple;\n    while ($i < $n) {\n\
    \        $triple = $a[ $i] + $a[ $j] + $a[ $k];\n        if ($triple > 3) {\n\
    \            push (@triple , $a[ $i] + $a[ $j] + $a[ $k]);\n        }\n      \
    \  $i++;\n        if ($i == $n) {\n            $i = 0;\n            $j++;\n  \
    \      }\n        if ($j == $n) {\n            $j = 0;\n            $k++;\n  \
    \      }\n    }\n    return scalar(@triple);\n}\n</code>\n<|/ a tags=arrays,algorithm,perl\
    \ |>\n<| c |>\nWhy do you need to maintain all these counters and incrementing\
    \ variables? You already have two pointers to go from one element to the next\
    \ as your loop condition. How do you know you haven't missed them?\n<|/ c |>\n\
    <| c |>\n: Agreed. Just thought it would be an interesting exercise to try and\
    \ solve the problem with some kind of nested loops. :-)\n<|/ c |>\n<| c |>\nHmm,\
    \ this is clever. Perhaps you could use an exit statement after the inner loop\
    \ to return when `@triple` is empty.\n<|/ c |>\n<| c |>\nI think this answer is\
    \ pretty clever, but I would go for a recursive solution over this one.\n<|/ c\
    \ |>\n<| c |>\n: Recursion is much easier to understand than this looping approach.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,perl |>\nI would use map to iterate over\
    \ the array, and sum the values, and check that the sum is divisible by 3. \n\
    <code>", "    my @result = ();\n    my @triples = ();", "    my $max = 0;\n  \
    \  my @a = ();\n    for( my $i = 0; $i < $n; $i++ ){\n        if( $i == 0 ){\n\
    \            push(@a, 1);\n        } else {\n            push(@a, $a[$i-1] + $a[$i]\
    \ + 1);\n        }\n        if( $max == 0 || $a[ $max - 1 ] > $a[$max] ){\n  \
    \          $max = $a[ $max - 1 ];\n        }\n    }\n    return $max;\n}\n</code>\n\
    <|/ a tags=algorithm,perl,java |>\n<| c |>\n`get_max_triples(5)`  => 1\n<|/ c\
    \ |>\n<| c |>\n.Karlsen, Yeah, I missed the condition `i < j < k`, that's why\
    \ I didn't get that condition in the question. Fixed now.\n<|/ c |>\n<| c |>\n\
    Your answer is the best one. +1\n<|/ c |>\n<| c |>\n`get_max_triples(5)` => 1\n\
    <|/ c |>\n<| c |>\n`get_max_triples(4)` => 2\n<|/ c |>\n<| a dscore=4 tags=algorithm,perl,java\
    \ |>\n<code>\npublic int getMaxTriples(int n) {\n    int max = 0;\n    int[] arr\
    \ = new int[n];\n    int[] arr2 = new int[n];\n    int sum = 0;", "    my(@a)\
    \ = ();\n    for(my $i = 0; $i <  $n; ++$i){\n        push(@a, $i * $i - $i +\
    \ 1);\n    }\n    my $triple_count = 0;\n    for (my $i = 1; $i <= $n; ++$i) {\n\
    \        for (my $j = 1; $j <= $n; ++$j) {\n            for (my $k = 1; $k <=\
    \ $n; ++$k) {\n                next if $i > $j || $j > $k;\n                next\
    \ unless $a{$i} + $a{$j} + $a{$k} % 3 == 0;\n                ++$triple_count;\n\
    \            }\n        }\n    }\n    return $triple_count;\n}", "    my;\n  \
    \  for my $i (0 .. $n) {\n        push(@triples, $i, $i, $i);\n    }\n    my $count\
    \ = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n;\
    \ $j++) {\n            for (my $k = 0; $k < $n; $k++) {\n                my $sum\
    \ = $triples[$i][$j] + $triples[$j][$k];\n                if (($triples[$i][$j]\
    \ == $triples[$j][$k]) and ($sum % 3) == 0) {\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}", " \
    \   my(@a) = ();\n    my($i,$j,$k);\n    $i = 1; $j = 1; $k = 1;\n    while($i\
    \ <= $n){\n        if($i == $n){\n            $a[$i-1] = $i + $j + $k - 3;\n \
    \           $i = 1;\n            $j = 1;\n            $k = 1;\n        }\n   \
    \     else {\n            $a[$i-1] = $i + $j + $k - 3;\n            $i++;\n  \
    \      }\n    }\n    \n    my $count = 0;\n    my $temp = $a[$_-1];\n    for($_=$_-1;$_<=$n;$_++){\n\
    \        if($temp + $a[$_-1] + $a[$_] - $a[$n-$_] < 0){\n            $count =\
    \ $_;\n            $temp = $a[$_-1];\n        }\n    }\n    return $count;\n}",
  "    my(@a) =[1..$n];\n    return 0 if (@a < 3);\n    my $k = 1;\n    for ($i =\
    \ @a - 2; $i >= 0; $i--, $k++) {\n        my $j = $k + 1;\n        my $m = $j;\n\
    \        while ($j < $n and $a[$j] + $a[$k] + $a[$j] < 0) {\n            my $d\
    \ = $a[$j] + $a[$k] + $a[$m];\n            $m++;\n            last if ($d == 0);\n\
    \            $k++;\n        }\n    }\n    return $k - 1;\n}", '    my(@result);',
  "    my(@a);\n    for(my $i = 0; $i < = $n; $i++) {\n        push(@a, $i * $i -\
    \ $i + 1);\n    }\n    my $count = 0;\n    for(my $i = 0; $i < = $n; $i++) {\n\
    \        for(my $j = 0; $j < = $n; $j++) {\n            for(my $k = 0; $k < =\
    \ $n; $k++) {\n                if($i + $j + $k == $n) {\n                    if($a[$i]\
    \ + $a[$j] + $a[$k] == $n) {\n                        $count++;\n            \
    \        }\n                }\n            }\n        }\n    }\n    return $count;\n\
    }", "    my $a = [];\n    my $i = 0;\n    \n    # This is because we need to know\
    \ how many times a[k] will increase by \n    # 1 if i increases by k\n    my %count_a\
    \ = (0 => 0);\n    \n    while($i<$n){\n        while($i<$n && $a[ $i ] <= $a[\
    \ $i-1 ]){\n            $count_a{ $a[$i] } += 1;\n            $i++;\n        }\n\
    \        $i++;\n    }\n    \n    return scalar(grep { $count_a{ $_ } > 1 } keys\
    \ %count_a);\n}\n</cell>\n<text>\nLet's take a look at our implementation by running\
    \ it.", "    my $array = [];\n    my $i;\n    for ($i = 0; $i < $n; $i++) {\n\
    \        my $j = $i;\n        while ($j < $n) {\n            push @$array, @{$array[$j++]},\
    \ @{$array[$j++]};\n        }\n    }\n    my $triples = @$array;\n    my $sum\
    \ = 0;\n    for ($i = 0; $i < $triples; $i++) {\n        $sum += $triples[$i]\
    \ * $triples[$i] * $triples[$i];\n    }\n    $sum % 3 == 0 ? $triples : -1;\n}",
  "    my @a;\n    \n    for(0..$n){\n        push(@a, $i*$i-$i+1);\n    }\n    \n\
    \    my %hash;\n    \n    foreach my $i (@a){\n        for(my $j=i+1; $j<$n; $j++){\n\
    \            for(my $k=j+1; $k<$n; $k++){\n                my $res = $i*$i+$j*$j+$k*$k;\n\
    \                \n                if($res == 3){\n                    $hash{$i}{$j}{$k}++;\n\
    \                }\n            }\n        }\n    }\n    \n    my $triples = 0;\n\
    \    foreach my $i (keys %hash){\n        foreach my $j (keys %{$hash{$i}}){\n\
    \            foreach my $k (keys %{$hash{$i}{$j}}){\n                if($hash{$i}{$j}{$k}\
    \ == 1){\n                    $triples += 3;\n                }\n            }\n\
    \        }\n    }\n    \n    return $triples;\n}", "    my(@a) = ();\n    for(my\
    \ $i=1; $i<=$n; $i++) {\n        push(@a, $i*$i-$i+1);\n    }\n    my $cnt = 0;\n\
    \    for(my $i=0; $i<=$n; $i++) {\n        for(my $j=0; $j<=$n; $j++) {\n    \
    \        for(my $k=0; $k<=$n; $k++) {\n                if(($i != $j) || ($i !=\
    \ $k) || ($j != $k)) {\n                    if(($a[$i]+$a[$j]+$a[$k]) % 3 == 0)\
    \ {\n                        $cnt++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return $cnt;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nMy idea would be to sort the array descending and use the modulo\
    \ operation on it.\n<code>", "    my @a = ();\n    my @a1;\n    my $sum = 1;\n\
    \    for(my $i = 0; $i < $n; $i++){\n        push(@a,0);\n    }\n    for(my $i\
    \ = 0; $i < $n; $i++){\n        $a1[$i] = $i;\n    }\n    for(my $i = 0; $i <\
    \ $n; $i++){\n        for(my $j = 0; $j < $n; $j++){\n            for(my $k =\
    \ 0; $k <= $n; $k++){\n                $sum += $a[$k] * $a1[$k];\n           \
    \ }\n            if($sum % 3 == 0){\n                push(@a, $a[$k]);\n     \
    \       }\n        }\n    }\n    return scalar(@a);\n}\n</code>\n<|/ a tags=math,algorithm,performance\
    \ |>\n<| c |>\nThat's quite a lot of work for such a trivial problem, I wonder\
    \ how this would scale for larger sized arrays. And how would the code look like\
    \ if one were to write it in C?\n<|/ c |>\n<| c |>\nIt is a bit complicated to\
    \ write it in C because the code need to be translated from mathematical to machine\
    \ language, which is really hard for computer scientists. But if your purpose\
    \ is just to learn and practice, you can get good idea from this.\n<|/ c |>\n\
    <| c |>\nThis is actually the solution that I ended up doing, but I didn't understand\
    \ it until I started looking at it again after coming back to this problem. Thanks!\n\
    <|/ c |>\n<| a |>\n<code>\ndef num_triples(n):\n    total = 0\n    for i in range(n):\n\
    \        total += i * (i + 1) // 2\n    return total", "    my @a = ();\n    for(my\
    \ $i = 1; $i <  $n; $i++) {\n        push(@a, $i * $i - $i + 1);\n    }\n    my($triple)\
    \ = (0, 0, 0);\n    for(my $i = 0; $i < $n; $i++) {\n        for(my $j = 0; $j\
    \ < $n; $j++) {\n            for(my $k = 0; $k < $n; $k++) {\n               \
    \ $triple = $a[ $i ] + $a[ $j ] + $a[ $k ];\n                \n              \
    \  if($triple % 3 == 0) {\n                    return $triple;\n             \
    \   }\n            }\n        }\n    }\n    return 0;\n}", "    my(@a) = (1..$n);\n\
    \    my $sum = 0;\n    my $j;\n    my $k;\n    for ($j=0; $j<$n-1; $j++) {\n \
    \       $sum = 0;\n        for ($k=$j; $k<$n; $k++) {\n            $sum += $a[$k]\
    \ + $a[$j];\n            if ($sum > 3) {\n                return 1;\n        \
    \    }\n        }\n    }\n    return 0;\n}", "    my @a;\n    for(my $i = 0; $i\
    \ < $n; $i++) {\n        push @a, $i * $i - $i + 1;\n    }\n    return 1 + grep\
    \ { $_ > 3 } @a;\n}", "    my @a = @{ [int(0 + $n * ($n + 1)) / 2 ] };\n    for\
    \ (my $i = 1; $i < @a; $i++) {\n        my $min = 0;\n        my $max = $i;\n\
    \        for ($i; $i < @a; $i++) {\n            if ($a[$i] + $a[$min] + $a[$max]\
    \ < $a[ $i + 1] + $a[ $i - 1])\n            {\n                $min = $i;\n  \
    \              $max = $i;\n            }\n            else\n            {\n  \
    \              $max = $i;\n            }\n        }\n        $a[$max] -= $a[$i];\n\
    \        if ($a[$max] == 0)\n        {\n            splice(@a, $max, 1);\n   \
    \     }\n        else\n        {\n            $a[$min] -= $a[$max];\n        \
    \    if ($a[$min] == 0)\n            {\n                splice(@a, $min, 1);\n\
    \            }\n        }\n    }\n    return scalar(@a);\n}\n</code>\n<|/ a tags=algorithm,math,arrays,perl\
    \ |>\n<| c |>\nI'm upvoting you, because it works, but you're essentially recreating\
    \ `Array::Util`. Also, I think that your solution has a bug.\n<|/ c |>\n<| a tags=algorithm,math,arrays,perl\
    \ |>\n<code>", "    my(@a) = (0, 0);\n    my(@b, $n);\n    foreach $b (1..$n)\
    \ {\n        push @a, $a*$a-$b+$b;\n    }\n    foreach $b (@a) {\n        my $t\
    \ = @a;\n        $t = $t - $b*$b;\n        if ($t < 0) {\n            $t = 0;\n\
    \        }\n        push(@a, $t);\n    }\n    my $res = 0;\n    foreach $b (@a)\
    \ {\n        $res = $res + $b;\n    }\n    return $res;\n}", "    my $a = [ map\
    \ { ($_+1)*($_+1) - $_ } 1 .. $n];\n    my $i = 0;\n    my $sum = 0;\n    for\
    \ (my $j = 0; $j < $n; $j++) {\n        for ($i = $j+1; $i <= $n; $i++) {\n  \
    \          $sum += $a[ $i-1 ] * $a[ $j ] * $a[$k];\n        }\n    }\n    return\
    \ $sum % 3 == 0;\n}\n</code>\n<|/ a tags=algorithm,python,math dscore=0 |>\n<|\
    \ a dscore=0 tags=algorithm,python,math |>\nSince I like pencil and paper more\
    \ than programming :)\n<code>\na = int(input(\"Enter the total number of the elements\
    \ you want:\"))\nb = []\nfor i in range(1,a+1):\n    b.append(i*i-1)\nc = int(input(\"\
    Enter the number of elements you want to count:\"))\nsum = 0\nfor i in range(1,c+1):\n\
    \    if sum > sum(b[i-1])\n        sum = sum(b[i-1])\nprint(sum)\n</code>\n<|/\
    \ a |>\n<| a tags=algorithm,python,math |>\nHere is a possible solution:\n<code>\n\
    def get_max_triples(n):\n    arr = [i for i in range(1, n + 1)]\n    count = 1\n\
    \    sum_arr = [i for i in arr]\n    while count < len(arr):\n        sum_arr.append(arr[0]\
    \ + arr[1] + arr[2])\n        count += 1\n    for index, i in enumerate(arr):\n\
    \        sum_arr[index] = sum_arr[index] + sum_arr[index - i] * sum_arr[index]\n\
    \    sum_arr.append(sum_arr[0])\n    max_triples = sum_arr[len(sum_arr) - 1] %\
    \ 3\n    return max_triples", "    my @a = ();\n    for (my $i = 1; $i <= $n;\
    \ $i++) {\n        push(@a, $i * $i -$i + 1);\n    }\n    my $result = 0;\n  \
    \  my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    while ($i < $n && $j < $n &&\
    \ $k < $n) {\n        $result += $a[$i] + $a[$j] + $a[$k];\n        if ($a[$i]\
    \ + $a[$j] + $a[$k] == 3) {\n            $result++;\n        }\n        my $tmp\
    \ = $i;\n        $i = $j;\n        $j = $k;\n        $k = $tmp;\n    }\n    return\
    \ $result;\n}", "    my @a = ();\n    for(my $i = 1; $i <= $n; $i++) {\n     \
    \   for(my $j = 1; $j <= $i; $j++) {\n            for(my $k = 1; $k <= $j; $k++)\
    \ {\n                my $triple = $i*$i-1*$j+$i*$j+$i*$k+$j*$k-1;\n          \
    \      if($triple == 0 || $triple % 3 == 0) {\n                    push(@a, $triple);\n\
    \                }\n            }\n        }\n    }\n    return scalar(@a);\n\
    }\n</code>\n<|/ a dscore=2 tags=math,algorithm,language-agnostic |>\n<| c |>\n\
    If we're being pedantic, `a*a + b*b == a*a*b`, not `a*a*b`.  So `a*a*b != a*a*(a\
    \ - b)`.  And `a*a*b != a*a*b` because one term must be positive.\n<|/ c |>\n\
    <| c |>\nThanks. I did miss that.\n<|/ c |>\n<| c |>\nWhat is the time complexity\
    \ of your solution? Is it O(n^3) ?\n<|/ c |>\n<| c |>\nI think the time complexity\
    \ is O(n^3). Since there might be some O(n^2) solution, I have no idea about it.\n\
    <|/ c |>\n<| a |>\nI think that solutions with modulo 3 are great, but they make\
    \ me think that there might be a solution without modulo 3. I found a solution\
    \ without modulo 3.\nLet's take n=9 as an example:\n<code>\na[0] = 1\na[1] = 3\n\
    a[2] = 7\na[3] = 13\na[4] = 21\n</code>\nWe can see that the sum of a[j] for 1<=j<=n\
    \ is equal to: 1 + 3 + 7 + 13 + 21 = 258 (mod 9). This is the same for all the\
    \ elements (the sum of the values of a).\nSo now we know that there exist a solution\
    \ in which none of a[0]...a[4] will equal n. If we apply the rule above to a[0]\
    \ then we see that the sum of a[j] for 1<=j<=n is equal to:\n<code>\na[0] + (a[1]\
    \ + a[2] + a[3] + a[4]) == 258\n</code>\nAnd this sum is equal to 258 mod 9.\n\
    The same applies to a[1] etc. And this is true for all the elements (the sum of\
    \ the values of a).\nSo the question is what is the sum of a[j] for the first\
    \ i from 0 to n?\n<code>\nsum = a[0] + a[1] + ... ", "    my(@a);\n    for(my\
    \ $i = 1; $i <= $n; ++$i) {\n        push(@a, $i * $i - $i + 1);\n    }\n    my\
    \ $result;\n    for(my $i = 0; $i < @a; ++$i) {\n        for(my $j = 1; $j < @a;\
    \ ++$j) {\n            for(my $k = 0; $k < @a; ++$k) {\n                if($i\
    \ ne $j && $j ne $k) {\n                    if($a[$i] + $a[$j] + $a[$k] >= 3*$i)\
    \ {\n                        ++$result;\n                    }\n             \
    \   }\n            }\n        }\n    }\n    return $result;\n}\n</cell>\n<cell>\n\
    def get_min_triples(n):\n    # You are given a positive integer n. You have to\
    \ create an integer array a of length n.\n    # For each i (1 \u2264 i \u2264\
    \ n), the value of a[i] = i * i - i + 1.\n    # Return the number of triples (a[i],\
    \ a[j], a[k]) of a where i < j < k, \n    # and a[i] + a[j] + a[k] is a multiple\
    \ of 3.\n    # Example :\n    # >>> get_min_triples(5)\n    # 2\n    # Explanation:\
    \ \n    # a = [1, 3, 7, 13, 21]\n    # The only valid triple is (1, 13, 7).\n\
    \    \n    \n    my(@a);\n    for(my $i = 1; $i <= $n; ++$i) {\n        push(@a,\
    \ $i * $i - $i + 1);\n    }\n    my $result;\n    for(my $i = 0; $i < @a; ++$i)\
    \ {\n        for(my $j = 1; $j < @a; ++$j) {\n            for(my $k = 0; $k <\
    \ @a; ++$k) {\n                if($i ne $j && $j ne $k) {\n                  \
    \  if($a[$i] + $a[$j] + $a[$k] <= 3*$i) {\n                        ++$result;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return $result;\n</cell>\n<cell>\nget_max_triples(5)\n</cell>\n<cell>\nget_min_triples(5)\n\
    </cell>\n<text>\nExercise 3\nThe value n is between 1 and 100. \nCalculate the\
    \ minimum value of n such that it produces exactly the same results as the previous\
    \ function.\nCalculate the minimum value of n such that it produces at least one\
    \ triple of all positive integers."]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
