name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and 1/ for\
  \ the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\
  \"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @result = ();\n    my $i = 0;\n    my $l = length($s);\n   \
    \ my $check = ();\n    my $result = \"\";\n    my $check2 = \"\";\n    while ($i\
    \ < $l) {\n        if ($s[$i] eq $c[$i]) {\n            $check[$i] += 1;\n   \
    \     }\n        elsif ($s[$i] ne $c[$i]) {\n            $result .= $s[$i];\n\
    \            push(@result, $result);\n        }\n        $i += 1;\n    }\n   \
    \ my $j = 0;\n    for ($i = 0, $l = length($c); $i < $l; $i++) {\n        if ($check[$i]\
    \ > 0) {\n            $result .= $c[$j];\n            push(@result, $result);\n\
    \            $check2[$i] += 1;\n        }\n        $j += 1;\n    }\n    if ($check2\
    \ > 0) {\n        $result .= $c[$j];\n        push(@result, $result);\n    }\n\
    \    if (@result == 0) {\n        $result = \"\";\n    }\n    push(@result, $s);\n\
    \    return ($result, 1);\n}\n</code>\n<|/ a dscore=0 tags=perl |>\n<| c |>\n\
    The OP said they didn't want to use any builtin functions or methods. It's not\
    \ clear that they have access to an OO Perl interpreter without them.\n<|/ c |>\n\
    <| c |>\nyes you are right, the OP said he don't know the length of the string\
    \ and he don't want to use any builtin function.\n<|/ c |>\n<| c |>\nIt would\
    \ be useful if you had added a sentence that implied you were using an OO Perl\
    \ interpreter (whether that's by saying \"no OO Perl\" or by saying \"an OO Perl\
    \ interpreter such as `perl5`, `perl6` or `perl`\") without mentioning them explicitly.\n\
    <|/ c |>\n<| a dscore=0 |>\nA simple recursive solution would be the following:\n\
    <code>", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my $i = 0;\n\
    \    my @res;\n    my $check = 1;\n    my $flag;\n    \n    foreach my $i (0..($#s\
    \ - 1)) {\n        if ($s[$i] eq $c[$i]) {\n            $check = 0;\n        }\n\
    \        \n        if ($check) {\n            my $tmp = $s[$i];\n            $s[$i]\
    \ = $s[$i+1];\n            $s[$i+1] = $tmp;\n            $flag++;\n        }\n\
    \    }\n    \n    for (my $i = 0; $i < $#s; $i++) {\n        if ($s[$i] eq $c[$i])\
    \ {\n            $check = 0;\n        }\n        \n        if ($check) {\n   \
    \         my $tmp = $s[$i];\n            $s[$i] = $s[$i+1];\n            $s[$i+1]\
    \ = $tmp;\n            $flag++;\n        }\n    }\n    \n    for (my $i = 0; $i\
    \ < $#s; $i++) {\n        if ($s[$i] eq $c[$i]) {\n            $check = 0;\n \
    \       }\n        \n        if ($check) {\n            my $tmp = $s[$i];\n  \
    \          $s[$i] = $s[$i+1];\n            $s[$i+1] = $tmp;\n            $flag++;\n\
    \        }\n    }\n    \n    for my $i (0..($#s - 1)) {\n        if ($s[$i] eq\
    \ $c[$i]) {\n            $check = 0;\n        }\n        \n        if ($check)\
    \ {\n            my $tmp = $s[$i];\n            $s[$i] = $s[$i+1];\n         \
    \   $s[$i+1] = $tmp;\n            $flag++;\n        }\n    }\n    \n    for my\
    \ $i (0..($#s - 1)) {\n        if ($s[$i] eq $c[$i]) {\n            $check = 0;\n\
    \        }\n        \n        if ($check) {\n            my $tmp = $s[$i];\n \
    \           $s[$i] = $s[$i+1];\n            $s[$i+1] = $tmp;\n            $flag++;\n\
    \        }\n    }\n    \n    for my $i (0..($#s - 1)) {\n        if ($s[$i] eq\
    \ $c[$i]) {\n            $check = 0;\n        }\n        \n        if ($check)\
    \ {\n            my $tmp = $s[$i];\n            $s[$i] = $s[$i+1];\n         \
    \   $s[$i+1] = $tmp;\n            $flag++;\n        }\n    }\n    \n    for my\
    \ $i (0..($#s - 1)) {\n        if ($s[$i] eq $c[$i]) {\n            $check = 0;",
  "    my $result = \"\";\n    my $flag = 0;\n    for (my $i = 0; $i < length($s);\
    \ $i++) {\n        if ($s[$i] eq $c) {\n            last if ($flag);\n       \
    \     push ($result, $s[$i]);\n            $flag = 1;\n        } else {\n    \
    \        push ($result, $s[$i]);\n        }\n    }\n    return ($result, $flag);\n\
    }", "    my @chars;\n    my $cp = $s;\n    my $ccf = $c;", "    my $res = \"\"\
    ;\n    for(my $i=0; $i<length($s); $i++) {\n        my $c_char = substr($c, $i,\
    \ 1);\n        if($i && $s_char != $c_char) {\n            $res .= substr($s,\
    \ $i-1, 1);\n        }\n        $res .= $c_char;\n    }\n    return ($res, 1);\n\
    }", "    my @result;\n    my $str = $s;\n    my $cs = $c;\n    my $i = 0;\n  \
    \  my $prev;\n    my $flag = 0;\n    my @chars = split(//, $cs);\n    while($i\
    \ <= length($s)) {\n        my $char = $chars[$i];\n        if ($char eq $prev)\
    \ {\n            $flag++;\n        }\n        else {\n            $flag = 0;\n\
    \            $prev = $char;\n        }\n        if ($flag == (scalar(@chars) -\
    \ 1)) {\n            push (@result, $str);\n        }\n        elsif ($flag ==\
    \ 0) {\n            $str .= $char;\n            $i++;\n        }\n    }\n    return\
    \ @result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=palindrome,arrays,perl,string\
    \ |>\n<code>", "    my($i, $j, $count);\n    my @r;\n    for(my $i=length($s)-1;$i>=0;$i--)\
    \ {\n        $count = 0;\n        for(my $j=0;$j<length($c);$j++) {\n        \
    \    if( substr($s,$i,1) = $c->[$j]) {\n                $count++;\n          \
    \  }\n        }\n        push(@r,substr($s,0,$i));\n        push(@r,\"\");\n \
    \       if($count == 0) {\n            push(@r,\"\");\n        }\n    }\n    return\
    \ (@r,$count);\n}", "    my @result;\n    my $start = 0;\n    my $index;\n   \
    \ my $char;", "    my $rs = '';\n    my $ok = 1;\n    for (my $i = 0; $i <= length($s);\
    \ $i++) {\n\tmy $j = ($i + 1) < length($s) ? $i + 1 : 0;\n\tmy $tmp = substr($s,\
    \ $i, 1);\n\tif ($tmp != substr($c, $j, 1)) {\n\t    $ok = 0;\n\t    last;\n\t\
    }\n\t$rs .= substr($s, $i, 1);\n    }\n    if ($ok) {\n\tprint \"$rs\\n\";\n\t\
    return (\"$rs\", 1);\n    } else {\n\tprint \"$rs does not have a palindrome in\
    \ the middle\\n\";\n\treturn (\"$rs\", 0);\n    }\n}", "    my $result = \"\"\
    ;\n    for (my $i = 0; $i < length($s); $i++) {\n        if (substr($s, $i, 1)\
    \ eq $c) {\n            $result .= substr($s, $i, 1);\n        } else {\n    \
    \        last;\n        }\n    }\n    return [substr($result, 0, length($result)\
    \ - 1), 1];\n}", "    my @res = ();\n    my $n = 0;\n    \n    while($n <= length($s)){\n\
    \tmy $d = substr($s,$n,1)\n\tif(cmp($d,$c)!=0){\n\t    push (@res, $d);\n\t  \
    \  $n++;\n\t}\n    }\n    return @res;\n}", "    $c =~ tr/a-zA-Z/n-z/;\n    my\
    \ $result = $s;\n    while ($s =~ /($c)/g) {\n\tmy $found = 0;\n\twhile ($s =~\
    \ /$c/) {\n\t    $s = substr($s, 0, -1) . $1;\n\t    $found++;\n\t}\n\tmy $result1\
    \ = $result;\n\t$result .= $1 . $c;\n\tif ($found == 0) {\n\t    $result = $result1;\n\
    \t}\n    }\n    return ($result, 1);\n}", "    my @result;\n    if ( scalar @$s\
    \ == scalar @$c ) {\n        @result = ();\n        for my $i (0 .. $#s) {\n \
    \           my $found = 0;\n            my $j = $i;\n            while ( $j <\
    \ $#c ) {\n                if ( $s[$i] == $c[$j] ) {\n                    $found\
    \ = 1;\n                    last;\n                }\n                $j++;\n\
    \            }\n            if ( ! $found ) {\n                $result[$#result]\
    \ .= $s[$i];\n            }\n        }\n    }\n    else {\n        push @result,\
    \ \"\";\n    }\n    return ( @result, ! $result[0] eq $result[1] );\n}", "   \
    \ my @result = (); # stores reversed string\n    my $result = \"\"; # result string\n\
    \    my $check = 1; # check the length of string\n    # step 1: delete all equal\
    \ character\n    for my $i (0 .. $#s) {\n        last unless (substr($s, $i, 1)\
    \ eq $c);\n    }\n    # step 2: check if the result string is palindrome\n   \
    \ for my $i (0 .. $#s) {\n        $result .= substr($s, $i, 1);\n    }\n    if\
    \ ($result eq $s) {\n        $check++;\n    }\n    # step 3: if the result string\
    \ is palindrome, add the result string to result array\n    if ($result eq $s)\
    \ {\n        push(@result, $result);\n    }\n    push(@result, \"$check\") if\
    \ ($check > 0);\n    return \\@result;\n}", "    $c .= \"\";\n    $ps = \"\";\n\
    \    my $i = $#s;\n    my $k = 0;\n    while($i < $#c) {\n        if($c eq $s[$i])\
    \ {\n            delete $s[$i];\n            $k += 1;\n            $i += 1;\n\
    \        } else {\n            $ps .= $s[$i];\n            $i++;\n        }\n\
    \    }\n    return [$ps, $k];\n}", "    my @delete = @{$s->{$c}};\n    $s->{$c}\
    \ = [];\n    my $res = \"[\".$s.\"]\";\n    $res++ if !reverse($s,$c);\n    $res;\n\
    }", "    my $s = $s;\n    my $c = $c;", "    my @result = ();\n    my $len = length($s);\n\
    \    for (my $i = $len-1; $i >= 0; $i-=1) {\n        if ($s eq $c . $i . $s[$i])\
    \ {\n            push(@result, $s[$i]);\n        }\n    }\n    return (@result,\
    \ scalar(@result) > 0 ? 1 : 0);\n}", "    my $result = \"\";\n    my $count =\
    \ 0;\n    while ($s =~ /(.)\\1*/g) {\n        $result .= $1;\n        $count++;\n\
    \    }\n    return ($result =~ /(.)\\1*/g) == $c ? ($result, 1) : ();\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI didnt want to complicate things, just wanted to\
    \ see how much faster it could be done and how it would perform compared to the\
    \ previous solution, which is what I think the OP meant by 'more efficient'\n\
    <|/ c |>\n<| c |>\n`perl` doesn't perform any magic and it just doesn't care how\
    \ many lines you write.\n<|/ c |>\n<| c |>\nIf `s` and `c` are the same, your\
    \ code doesn't do anything. Perl will optimize out empty loops and such but it\
    \ won't optimize out an assignment inside a loop. It's still a loop and a variable\
    \ assignment (but one with side effects).\n<|/ c |>\n<| c |>\nPerl doesn't know\
    \ that `s` and `c` will always have the same value. The problem here is that `s`\
    \ and `c` can contain any value and it's impossible to tell whether `s` is empty\
    \ or it contained `c`. I also added `==` instead of `eq` in case the string is\
    \ empty\n<|/ c |>\n<| c |>\nPerl knows what it will do if s and c are different\
    \ but it will not know that s can't be empty. For example, if s is an empty string\
    \ and c is a non-empty string, you'll get the same result as if s and c are both\
    \ empty or both non-empty. Perl optimizes away the assignment when s is a constant.\n\
    <|/ c |>\n<| a dscore=1 |>\nI find my solution is better than any of the others\
    \ so far\n<code>", "    if ( $c eq '' || $s eq '') {\n        return ();\n   \
    \ }\n    my;\n    my $i = 0;\n    my $j = $#$s;\n    while (1) {\n        if (\
    \ $i < $j ) {\n            push, $s[$i++];\n        }\n        else {\n      \
    \      push, $s[$j--];\n        }\n        if ($i == $j) {\n            push,\
    \ 1;\n            last;\n        }\n    }\n    return ();\n}", "    my;\n    my\
    \ $i = 0;\n    while($i <= length($s)-length($c)){\n        if( substr($s, $i,\
    \ length($c))==$c ) {\n            $i ++;\n        }else{\n            push, $i\
    \ . \"-\" . length($c);\n        }\n    }\n    return [$s, 1];\n}", "    my($result,$check)\
    \ = (\"\",0);\n    my $i = 0;\n    my $l = length($c);\n    while ($i < $l) {\n\
    \        while($i < $l and substr($s, $i, 1) eq substr($c, $i, 1)) {\n       \
    \     $i++;\n        }\n        $check++;\n        $result = $result . $_ for\
    \ substr($s, $i, 1);\n        $i++;\n    }\n    return $result,$check;\n}", " \
    \   $c =~ tr/a-z/A-Z/;\n    my $result = \"\";\n    my $i = 0;\n    $i ++ while\
    \ ($i < length($s) && $i < length($c) && substr($s, $i, 1) eq substr($c, $i, 1));\n\
    \    if ($i < length($s)) {\n        my $reverse = $s . (substr($s, $i, 1) eq\
    \ '' ? '' : substr($s, $i, 1));\n        $reverse =~ tr/A-Za-z/A-Z/;\n       \
    \ $result .= $reverse;\n        $result .= $c\n            ;\n    }\n    $result\
    \ =~ tr/A-Za-z/a-z/;\n    return ($result, 1);\n}\n</cell>\n<cell>", "    my @res\
    \ = ();\n    my $i = 0;\n    my $rev_c = reverse($c);\n    while (length($s) !=\
    \ 0 && $i le $#{$s}) {\n        $res[$i] = substr($s, $i, 1) if substr($s, $i,\
    \ 1) eq $rev_c;\n        $i++;\n    }\n    push @res, \"\", $res[-1] if $rev_c\
    \ ne substr($s, $i, 1);\n    return wantarray ? @res : $res[0];\n}\n</code>\n\
    <|/ a tags=algorithm,string,perl,substring dscore=2 |>\n<| c |>\nThis is really\
    \ a nice solution. Thanks for the effort!\n<|/ c |>\n<| a tags=algorithm,string,perl,substring\
    \ |>\nO(n) solution\n<code>", '    my @result = ();', "    my($i, $j, $results);\n\
    \    $results=();\n    $i=0;\n    $j=$#{$s};\n    while ($i<$j) {\n        if\
    \ ($s{$i} eq $c) {\n            $results[$i]=$s{$i};\n            $results[++$i]=\"\
    \";\n        }\n        $i++;\n    }\n    # check if there is any letter left\
    \ or there is no letter left.\n    if ($j==0) {\n        $results[0]=\"\";\n \
    \       $results[1]=1;\n    }\n    return ($results, $results[1]==1);\n}", " \
    \   my(@result) = (\"\", 0);\n    my $i = 0;\n    \n    while ($i < length($s))\
    \ {\n        my $j = 0;\n        \n        while ($j < length($c)) {\n       \
    \     next unless $s[$i] == $c[$j];\n            ++$j;\n        }\n        \n\
    \        push @result, $s[$i++];\n    }\n    \n    if ($i == length($s) && $result[length($result)\
    \ - 1] == $c[0]) {\n        push @result, \"\";\n    }\n    \n    return @result;\n\
    }", "    $s =~ tr/$c/$c//;\n    if(length($s) != length($c)){\n        $s =~ tr/$c/$c//;\n\
    \        $pali = reverse_delete($s,$c);\n        if($pali[0] != \"\"){\n     \
    \       push(@{$result},$pali[0]);\n            $result[1] = $pali[1];\n     \
    \   }\n    }else{\n        push(@{$result},\"\");\n    }\n    return @{$result};\n\
    }", '    my($result,$check)=@_;', "    my @a = ();\n    # Check if both strings\
    \ are palindrome and store the result in the return array\n    if ($s =~ s/^.//)\
    \ {\n        $a .= $s;\n        $a .= 1;\n    } elsif ($c =~ s/^.//) {\n     \
    \   $a .= $c;\n        $a .= 1;\n    } else {\n        return ($a, 1);\n    }\n\
    \    # reverse the string to check for equality\n    my $r = '';\n    while ($s\
    \ =~ s/.([^$c])/$r$1/sg) {\n        $r .= $1;\n    }\n    # check if the result\
    \ string is not equal to original string\n    if ($s ne $r) {\n        $a .= $s;\n\
    \        $a .= 0;\n    }\n    return ($a, 1);\n}", "    $c //= '';", "    my @x\
    \ = split(//, $s);\n    my $i = 0;\n    my $k = 0;\n    my $result = \"\";\n \
    \   \n    foreach my $v (@x) {\n        if ($v == $c) { $result = ($result . $v\
    \ . \"\\0\") if ($k <= $i); $i++; $k++ }\n    }\n    return ($result, 1 if ($result\
    \ eq \"\");)\n}", "    my @c = split //, $c;\n    my $res = \"\";\n    for (my\
    \ $i = 0; $i < length($s); $i++) {\n        if ($s[$i] == $c[$i]) {\n        \
    \    $res .= $s[$i];\n        } else {\n            push (@c, $s[$i]);\n     \
    \       $res = reverse $res;\n        }\n    }\n    my $r = \"\";\n    push (@{$r},\
    \ $res) if ($res);\n    my $is_reverse = -1;\n    $is_reverse = 1 if ($r == reverse\
    \ $s);\n    return ($r, $is_reverse);\n}", "    $_ = $s if length($s);\n    $c\
    \ = $c if length($c);\n    $_ =~ tr/./oxegcdsxy/;\n    return ($_, $_ == $s) ?\
    \ 1 : 0;\n}", "    my(@result) = (0, \"\");\n    \n    # Step 1. Check each character\
    \ in $s\n    for my $char (@$s) {\n\t\n\t# Step 2. Check each character in $c\n\
    \tforeach my $char2 (@$c) {\n\t    \n\t    # Step 3. Check characters\n\t    if\
    \ ($char eq $char2) {\n\t\t# Step 4. Delete characters from $s\n\t\tsplice @$s,\
    \ $char - 1;\n\t\t\n\t\t# Step 5. Check characters\n\t\tif ($char eq @$s) {\n\t\
    \t    push (@result, $char);\n\t\t    last;\n\t\t}\n\t    }\n\t}\n    }\n    \n\
    \    return @result;\n}", "    return if $s eq '';\n    my($check, $result) =\
    \ (0, \"\");\n    for (my $i = 0; $i < length($s); $i++) {\n        if ($s[$i]\
    \ == $c) {\n            $check = 1;\n        }\n        else {\n            delete\
    \ $s[$i];\n            if ($check) {\n                $result .= $s[$i];\n   \
    \             $check = 0;\n            }\n        }\n    }\n    return ($result,\
    \ 1) if $check;\n    return;\n}", "    my @result;\n    my $deleted_c;\n    for\
    \ my $c (reverse $c) {\n        if ($s =~ /($c)/g) {\n            push(@result,\
    \ '');\n            $deleted_c = 1;\n        }\n        elsif ($deleted_c) {\n\
    \            push(@result, $c);\n        }\n    }\n    push(@result, \"\") if\
    \ $deleted_c;\n    return @result;\n}\n</code>\n<|/ a tags=perl,string,algorithm,palindrome\
    \ |>\n<| a tags=perl,string,algorithm,palindrome |>\nThis can be done by using\
    \ a single pass on the string and checking each character.\n<code>", "    $s =~\
    \ tr/$c//cd;\n    $s =~ tr/$c//cd;\n    return ($s =~ m/^(.)\\1$/s ? $1 : $s,\
    \ 1);\n}", "    $s =~ tr/./\\L$c/;\n    if ($s =~ m/^($c)*($c)*$c/) {\n      \
    \  return(\"\");\n    } else {\n        return($1 . $2 . $1);\n    }\n}", "  \
    \  my($new, $result);\n    my(@chars);", "    # find all chars not in $c and delete\
    \ them\n    my $rev_str = $s =~ /[^$c]/;\n    # check if the string s is palindrome\n\
    \    if($rev_str =~ /\\A(.)(.)\\Z/) {\n        my @chars = ();\n        push(@chars,\
    \ $1);\n        push(@chars, $2);\n        my $palindrome = join(\"\", @chars);\n\
    \        if($s == $palindrome) {\n            return ($s, 1);\n        } else\
    \ {\n            return ($palindrome, 0);\n        }\n    } else {\n        #\
    \ if not return a empty string\n        return ($s, 1);\n    }\n}", "    $c ||=\
    \ '';", "    my @a;\n    my $found;\n    my $index = 0;\n    while($index<length($s)){\n\
    \        my $value = substr($s,$index, 1);\n        if ($value eq $c){\n     \
    \       $found = 1;\n            last;\n        }\n        push @a, $value;\n\
    \        $index++;\n    }\n    push @a, \"\" if $found == 0;\n    return @a;\n\
    }", "    my @result;\n    my $reversed = reverse $s;\n    for my $char (@$reversed)\
    \ {\n        my $found = 0;\n        for my $c (@$c) {\n            if ($char\
    \ == $c) {\n                $found = 1;\n            }\n        }\n        if\
    \ (! $found) {\n            push (@result, $char);\n        }\n    }\n    if (@result\
    \ == 0) {\n        push @result, \"\";\n    }\n    return @result;\n}", "    return\
    \ [] if $c eq \"\";\n    my $a = 0;\n    for (my $i = 0; $i <= $#s; ++$i) {\n\
    \        for my $j = $i + 1; $j <= $#s; ++$j {\n            if (substr($s, $i,\
    \ 1) eq substr($s, $j, 1)) {\n                splice( $s, $i, 1 );\n         \
    \       splice( $s, $j, 1 );\n                ++$a;\n                return [\
    \ $s, 1 ];\n            }\n        }\n    }\n    return [ $s, 0 ];\n}", "    $s\
    \ =~ s/$c//g;\n    $s =~ s/(.)\\1/$2/g;\n    return ($s, 1);\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nI think this code might help you.\n<code>\nfunction\
    \ reverse_delete($word, $char) {\n    if(substr($word,0,1) == $char){\n      \
    \   $word = substr($word,1);\n    }\n    if(substr($word,-1,1) == $char){\n  \
    \       $word = substr($word,0,-1);\n    }\n    if(substr($word,0,1) == $char){\n\
    \         $word = substr($word,1);\n    }\n    return $word;\n}\n</code>\n<|/\
    \ a tags=perl dscore=0 |>\n<| a tags=perl |>\n<code>\nmy($s,$c)=@_;", "    $c\
    \ =~ tr/\\\\0/\\000/g;\n    if ($c eq \"\\0\") {\n        return (\"\\0\", 1);\n\
    \    } else {\n        return ($s ~ tr/\\0$c/,);\n    }\n}", "    $c =~ tr/./;\n\
    \    my(@r, $flag);\n    my($i, $j, $k);\n    # Traverse through all the characters\
    \ in s\n    for(my $i = 0; $i < length($s); $i++) {\n        $flag = 0;\n    \
    \    # Search all the characters in c\n        for(my $j = 0; $j < length($c);\
    \ $j++) {\n            if($s[$i] eq $c[$j]) {\n                $flag = 1;\n  \
    \              # If the character in c is found in s\n                last;\n\
    \            }\n        }\n        # If no character in c is found in s\n    \
    \    if(!$flag) {\n            $r[$i] = $s[$i];\n            $flag = 1;\n    \
    \    }\n    }\n    return ($s, $flag) if ($flag);\n    return ($r, 1);\n}", " \
    \   my@s = split(\"\",$s);\n    my@c = split(\"\",$c);", "    my @result;\n  \
    \  my $check = 1;\n    my $string = \"\";", "    my($result1, $result2) = ($c,\
    \ $s);\n    for (my $i = 0; $i < length($s); $i++) {\n        my $pos = $result2[$i];\n\
    \        if ($pos == 0) {\n            $result2[$i] = $i;\n            $result2[$i\
    \ + 1] = $result1[$i];\n        } elsif ($pos < 0) {\n            $result2[$i]\
    \ = $result2[$i];\n            $result2[$i + 1] = $i;\n        }\n    }\n    return\
    \ ($result2, 1 unless (is_palindrome($result2));\n}", "    my;\n    my $is_palindrome\
    \ = 1;\n    my $s_len = length($s);\n    my $c_len = length($c);", "    my @result;\n\
    \    my @chars = split(//, $s);\n    for my $ch (@chars) {\n        for my $i\
    \ (0 .. length($c)-1) {\n            if ($ch == substr($c, $i, 1)) {\n       \
    \         push (@result, $ch);\n                last;\n            }\n       \
    \ }\n    }\n    my ($result, is_palindrome) = reverse @result;\n    return ($result,\
    \ 1);\n}", "    my $len = 0;\n    my $result = \"\";\n    my $flag = 0;", "  \
    \  $s = uc $s;\n    $c = uc $c;\n    my(@result) = (\"\");\n    \n    for(my $i\
    \ = length($s) - length($c) + 1; $i >= 1; $i--) {\n        if($s[$i] eq $c) {\n\
    \            for(my $j = length($s) - 1; $j >= $i; $j--) {\n                $result[0]\
    \ .= $s[$j];\n            }\n            for(my $j = length($c) - 1; $j >= 1;\
    \ $j--) {\n                $result[1] .= $c[$j];\n            }\n        }\n \
    \   }\n    \n    if($result[1] eq $result[0]) {\n        return (@result);\n \
    \   } else {\n        return (\"1\");\n    }\n}", "    $s = reverse($s);\n   \
    \ my $result;\n    my $check = &palindrome($s, $c, \\@result);\n    if ($check)\
    \ {\n        return @result;\n    }\n    my @a = reverse_delete($s, $c);\n   \
    \ push(@result, $s);\n    push(@result, @a);\n    return @result;\n}", "    #\
    \ Check for palindrome backward\n    # Remove all the characters in s\n    # Remove\
    \ all characters in c that match from s\n    # Check if palindrome\n    if(length($s)\
    \ ne length($c)) {\n        push @result, [$s, 0];\n        return;\n    }", " \
    \   my $result;\n    my $check_is_palindrome = 1;\n    my $len = length($s);\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        my $char = substr($s, $i, 1);\n\
    \        for (my $j = 0; $j < length($c); $j++) {\n            if ($char == substr($c,\
    \ $j, 1)) {\n                $check_is_palindrome = 0;\n            }\n      \
    \  }\n    }\n    if ($check_is_palindrome) {\n        $result = substr($s, 0,\
    \ $len-1);\n    }\n    return [@{$result}, $check_is_palindrome];\n}", "    my\
    \ @result = ();\n    $result = \"\";\n    my $i = 0;\n    while ($i < length($s))\
    \ {\n        my $temp = substr($s, $i, 1);\n        next if ($temp == $c);\n \
    \       $result .= $temp;\n        $i += 1;\n    }\n    $result if length($result)\
    \ == length($s);\n    return ($result, 1);\n}", "    my(@result) = (\"\", 0);\n\
    \    my $i = 0;\n    while (length($s) >= $i) {\n        my $check = $s[$i];\n\
    \        $i ++;\n        while (length($s) >= $i) {\n            $s = substr $s,\
    \ 0, 1 if ($s[$i] eq $check);\n            $i ++;\n        }\n        if (length($s)\
    \ == 0) {\n            @result = ($s, 1);\n        }\n        else {\n       \
    \     @result = ($s, 0);\n        }\n    }\n    return @result;\n}", "    my @s\
    \ = split(//, $s);\n    my $new_s = ();\n    my $len = @s;\n    for (my $i = 0;\
    \ $i < $len; $i++) {\n        my $deleted_char = $s[$i];\n        for (my $j =\
    \ 0; $j < $c; $j++) {\n            if ($s[$i] == $s[$j]) {\n                $s[$i]\
    \ = \"\";\n            }\n        }\n        $new_s .= $s[$i];\n    }\n    return\
    \ [ $new_s, 1 ];\n}", "    my($ret, $check_string);\n    my $c_length = length($c);\n\
    \    my $s_length = length($s);\n    my $i = 0;\n    my $j = $s_length - 1;\n\
    \    while (1) {\n        # if the character of s is equal to the character of\
    \ c,\n        # we delete that character in the string\n        $check_string\
    \ .= substr($s, $i, $c_length);\n        if ($check_string eq substr($s, $j, $c_length))\
    \ {\n            $ret .= substr($s, $i, $c_length);\n            $i++;\n     \
    \   }\n        # if the character of s is the last character of c,\n        #\
    \ we delete that character in the string\n        elsif ($j <= $s_length - 1)\
    \ {\n            $check_string .= substr($s, $i, $c_length);\n            $ret\
    \ .= substr($s, $i, $c_length);\n            $i++;\n            $j--;\n      \
    \  }\n        # if the character of s is equal to the last character of c\n  \
    \      # and c is equal to \"*\",\n        # we return an array containing ret\
    \ and 1\n        # because there is an empty string in ret\n        elsif ($check_string\
    \ eq substr($s, $j, $c_length) and $c eq \"*\") {\n            return ($ret, \"\
    1\");\n        }\n    }\n}", "    my $length = length($s);\n    my $result = $s;",
  "    my($i, $j, @c);\n    @c = split(//, $c);\n    foreach $i (0 .. length($s) -\
    \ 1) {\n        for (my $j = 0; $j < length($c); $j++) {\n            if ($s[$i]\
    \ == $c[$j]) {\n                splice(@s, $i, 1);\n                return ($s,\
    \ 1);\n            }\n        }\n    }\n    return ($s, 0);\n}", "    my $result\
    \ = [];\n    $result .= $s;\n    $result .= '';\n    for my $char ($c =~ /^(.)/)\
    \ {\n        $result .= $1 if $result =~ /$char/;\n    }\n    return ($result,\
    \ 1);\n}", "    return () if length $c > length $s;\n    my $rev = reverse($s);\n\
    \    $rev =~ tr/${c}//d;\n    return ($rev);\n}", "    return unless length($s);\n\
    \    return unless length($c) == 1;\n    return unless $c =~ /\\w/;\n    return\
    \ unless $s !~ /\\w/; # No special characters\n    # Delete all the characters\
    \ in s that are equal to the characters in c\n    $s =~ s/^$c//;\n    # Check\
    \ if the string is a palindrome\n    my ($result) = $s =~ /^(.)(.)$/ ? $1 . $2\
    \ : '';\n    $result eq $s ? 1 : $result;\n}", "    my(@result);\n    foreach\
    \ my $s (split /(?<=\\s)/, $s) {\n        chomp $s;\n        $s = reverse($s);\n\
    \        my $is_palindrome = 1;\n        if ($s =~ m/$c/g) {\n            $is_palindrome\
    \ = 0;\n        }\n        push(@result, $s . $is_palindrome);\n    }\n    return\
    \ (@result, 1);\n}", "    my(@results) = ();\n    my $palindrome = 1;\n    for(my\
    \ $index = 0; $index < length($s); $index++) {\n        my $char = $s[$index];\n\
    \        for(my $count = 0; $count < length($c); $count++) {\n            if($char\
    \ == $c[$count]) {\n                splice(@results, $index, 1);\n           \
    \     $palindrome = 0;\n            }\n        }\n        if($palindrome == 1)\
    \ {\n            push @results, \"\";\n            $palindrome = 1;\n        }\n\
    \    }\n    return @results;\n}", "    my @chars = split //, $s;\n    my $c_len\
    \ = scalar @chars;\n    my $r = '';\n    my @result = ('');\n    for (my $i =\
    \ 0; $i <= $c_len; $i++) {\n        for (my $j = 0; $j <= $c_len; $j++) {\n  \
    \          if ($chars[$i] == $chars[$j]) {\n                $chars[$j] =~ tr/$chars[$i]//cd;\n\
    \                $r .= $chars[$j];\n                push @result, ($r);\n    \
    \        }\n        }\n    }\n    return ($result) if ($result[-1] =~ /($c)/);\n\
    \    return ($result, 0);\n}", "    return $s unless  length $c > 0;\n    return\
    \ reverse_delete($c, substr($s, 0, 1), substr($s, -1) ) unless length($s);\n \
    \   return $s, 1;\n}", "    my $rev = reverse($c);\n    my $len = $s - length($c);\n\
    \    my = ();\n    for(my $i = 0; $i < $len; $i++) {\n        my $j = min($i +\
    \ $c, $s);\n        if($rev[$i] == $rev[$j]) {\n            push(@results, $rev[$i]);\n\
    \        }\n    }\n    push @results, \"\" if @results == 0;\n    return @results;\n\
    }\n</code>\n<|/ a tags=palindrome,perl,string,algorithm |>\n<| a |>\n<code>",
  "    $s ^= $c; # Clear out the characters we don't want\n    $s ^= $c if $c != 1;\
    \ # Clear out the \"not c\" characters\n    my($result,$deleted) = 0;\n    for\
    \ my $i (0..length($s)-1) {\n        if ($s == substr($s,$i,1)) { # Reverse the\
    \ string\n            $s = substr($s,0,$i-1) . $s[$i] . substr($s,$i+1);\n   \
    \         $deleted++;\n        }\n    }\n    return ($s,$deleted);\n}", "    my(@result);\n\
    \    my $i = 0;\n    for(my $i = 0; $i < (length($s)-1); $i++) {\n        my $j\
    \ = $i;\n        for(my $j = length($s)-1; $j > 0; $j--) {\n            last if\n\
    \                substr($s, $i, 1) eq\n                substr($s, $j, $j-1);\n\
    \        }\n        my $res = substr($s, $i, 1);\n        push(@result, $res)\
    \ unless ($res eq '');\n    }\n    push(@result, $s, 1) unless ($s eq '');\n \
    \   return ($result[0], 1);\n}", "    my $rev = reverse $s;\n    my $match = 0;\n\
    \    my $result = \"\";\n    foreach my $c (split //, $c) {\n        $result .=\
    \ $rev if $c == substr($rev, -length $c);\n        $match += 1;\n    }\n    if\
    \ ($result =~ /[^$c]/) {\n        $result = \"\";\n    }\n    return ((\"$result\"\
    , $match)) if ($result == $s);\n    return ((\"$result\", 0));\n}", "    my $i\
    \ = 0;\n    my $s = reverse $s;\n    my $c2 = reverse $c;\n    my $result = \"\
    \";\n    \n    for (; $i <= length $s; $i++) {\n        if ($s{$i} eq $c2) {\n\
    \            $result .= $s{$i};\n        }\n    }\n    return ($result, 0);\n}",
  "    my;\n    my($i, $j, $resultString);", "    my $result;\n    my $palindrome\
    \ = 1;\n    my $i = 0;\n    \n    $result = '';\n    while (length > $i) {\n \
    \       if ($s[$i] != $c[$i]) {\n            $palindrome = 0;\n            last;\n\
    \        }\n        $i++;\n    }\n    \n    $palindrome = 1;\n    for ($i; $i\
    \ < length; $i++) {\n        if ($s[$i] != $c[$i]) {\n            $palindrome\
    \ = 0;\n            last;\n        }\n    }\n    \n    for ($i; $i < length; $i++)\
    \ {\n        $result .= $s[$i];\n    }\n    \n    return [$result, $palindrome];\n\
    }", "    my $result = \"\";\n    my $check = 1;\n    while($check == 1) {\n  \
    \      my $found = 0;\n        foreach my $i ( 0 .. length($s) - 1) {\n      \
    \      if ( $s[$i] == $c ) {\n                $found = 1;\n                $result\
    \ = $result . $s[$i];\n                $s = substr($s, 0, $i-1) . substr($s, $i+1);\n\
    \                $check = 0;\n            }\n        }\n        \n        if (\
    \ length($s) == 0 && $found == 0 ) {\n            $check = 0;\n        }\n   \
    \ }\n    return [$result, length($result)];\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=0 |>\n<code>", '    my($result, $check);', "    $s =~ s/$c//g;\n  \
    \  if (length $s == 0) {\n        return [\"\", 1];\n    }\n    my($s, $c1) =\
    \ reverse_delete($s, $c);\n    $s = $s =~ tr/./\\012//c;\n    return [$s, !$c1\
    \ && $s eq reverse($c)];\n}", "    my $s = reverse $s;\n    my $cs = join \"\"\
    , $s, $c;\n    return [] if $cs eq $cs;\n    return [$cs, 1];\n}\n</code>\n<|/\
    \ a tags=algorithm,perl |>\n<| c |>\nYes I believe so. Since there are so many\
    \ palindromes being deleted, this solution will surely be better than mine. Thanks\
    \ !\n<|/ c |>\n<| c |>\nBTW, could you explain a bit more about the \"reverse\"\
    \ function ? Thanks.\n<|/ c |>\n<| c |>\nThe reverse function reverses a string\
    \ in place, without creating a new copy of the string.  http://perldoc.perl.org/functions/reverse.html\
    \ . So, `reverse $s` reverses `$s` and returns nothing.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI have tried this solution on one online judge and it works fine for me.\n\
    <code>", "    my @r;\n    my $i;\n    my $j;\n    \n    for ($i = length($s) -1,\
    \ $j = length($c) -1; ($i >= 0) && ($j >= 0);) {\n        if ($s[$i] != $c[$j]){\n\
    \            last;\n        }\n        $i--; $j--;\n    }\n    $i--; $j--;\n \
    \   push(@r, $s[$i] . \"\\0\");\n    $r[2] =~ /1|1/; # check the result string\
    \ for 1/ or 0/\n    return @r;\n}", "    my @s = split(//, $s);\n    my @c = split(//,\
    \ $c);", "    my();\n    \n    $s =~ tr/a-zA-Z//cd;\n    \n    my $i = $#s;\n\
    \    my $j = -1;\n    \n    # check and remove all $c from $s\n    while ($i &&\
    \ $j >= 0) {\n        if ($s[i] eq $c) {\n            $i++;\n            $j--;\n\
    \        }\n        elsif ($j >= 0) {\n            push (@result, $s[$j]);\n \
    \           $j--;\n        }\n        else {\n            push (@result, $s[$i]);\n\
    \            $i++;\n        }\n    }\n    \n    # check if $s is a palindrome\n\
    \    my $check = 0;\n    my $i = $#s;\n    while ($i > -1) {\n        if ($s[$i]\
    \ ne $s[$i-1]) {\n            $check = 1;\n        }\n        $i--;\n    }\n \
    \   \n    if ($check) {\n        push (@result, $s);\n        push (@result, 1);\n\
    \    }\n    \n    return @result;\n}", "    # convert string into an array of\
    \ characters.\n    my = map { $_ eq $c ? \"\" : $_ } (split //, $s);\n    # reverse\
    \ array and check against the original string.\n    return (split //, (join \"\
    \", reverse)) eq $s ? [\"\", 1] : [$s, 0];\n}\n</code>\n<|/ a tags=algorithm,palindrome,string,ruby\
    \ dscore=0 |>\n<| a dscore=0 |>\nHere is a recursive solution in Python\n<code>\n\
    def palindrome(s):\n    return s == s[::-1]", "    my $result = [];\n    my $reverse\
    \ = [];\n    my $found;\n    my $ccount = 0;", "    my @a = ();\n    my @pal =\
    \ ();\n    my @r;\n    my $c = 0;\n    my $i = 0;", "    my;\n    for (my $i =\
    \ 0; $i < length($s); $i++) {\n        my $current_char = substr($s, $i, 1);\n\
    \        if ($current_char =~ /$c/) {\n            my $result = substr($s, 0,\
    \ $i-1) . substr($s, $i);\n            push(@palindromes, $result);\n        }\n\
    \    }\n    push (1, \"1\") if (@palindromes);\n    return @palindromes;\n}\n\
    </code>\n<|/ a tags=perl,algorithm,perl6,data-structures dscore=1 |>\n<| a |>\n\
    Here is an O(n) solution. Reverse the string first. Iterate over each character\
    \ of string and check if it is equal in the original string. If equal add it to\
    \ result array. If it is not add it to result array but mark it as visited (to\
    \ avoid infinite loop).\n<code>", "    my $result;\n    my $temp;\n    for (my\
    \ $i = 0; $i < length($s); $i++) {\n        $temp = substr($s, $i, 1);\n     \
    \   $result = $result . $temp;\n        my $newc = substr($c, 0, 1);\n       \
    \ unless($newc eq substr($result, 0, length($c))) {\n            my $news = substr($s,\
    \ 0, $i);\n            my $newc = substr($c, 0, 1);\n            push (@$result,\
    \ ($news . $newc));\n            last;\n        }\n    }\n    return ($result,\
    \ 1);\n}", "    # return empty array\n    my ($result,$flag) = (\"\", 0);\n  \
    \  # iterate from start to end\n    for (my $i = length($s); $i >= 0; $i--) {\n\
    \        # ignore if already removed\n        if (substr($s,$i, 1) eq $c) {\n\
    \            $flag = 1;\n            last;\n        }\n    }\n    # check the\
    \ end and beginning\n    $result .= $s if $flag == 1;\n    $result .= substr($s,\
    \ 0, $i) if $flag == 1;\n    return ($result,1);\n}", "    my(@rs) = ();\n   \
    \ my($j, $i); # j - current index of $s\n    for (my $k = 0, $i = length($s) -\
    \ 1; $k < $i; ++$k, --$i) {\n        if ($s[$i] == $c) {\n            unshift\
    \ @rs, substr($s, 0, $k);\n        }\n    }\n    if ($i < 0) {\n        unshift\
    \ @rs, \"\";\n    }\n    return @rs;\n}", "    $s =~ tr/\\x00//d;\n    if ($s\
    \ =~ /$c/) {\n        return \"$s$1\";\n    } else {\n        return undef;\n\
    \    }\n}", "    $c .= \"\";\n    my;\n    my $len = length($c);\n    my $idx\
    \ = 0;", "    return @$c if $s eq reverse($s);\n    return ();\n}", "    my(@result);\n\
    \    my $rev_s = reverse($s);\n    my $rev_c = reverse($c);", "    my $len = $#{$s};\n\
    \    my $result = '';\n    my @chars = split //, $c;\n    my $i;\n    for ($i\
    \ = 0; $i <= $len; $i++) {\n        $result = $result. $chars[$i] if ($s == substr($s,\
    \ $i, 1));\n    }\n    return ($result, 1 unless ($result eq $s);\n}", "    my\
    \ @r = ();\n    $s =~ tr/${c}//cd;\n    $s =~ tr/[^${c}]//cd;\n    if ($s =~ /^(.)(.)$/\
    \ ) {\n        $r[-1] .= $1;\n        $r[0] .= $2;\n    }\n    else {\n      \
    \  $r[-1] .= $s;\n        $r[0] .= $s;\n    }\n    return [@r];\n}", "    my @result;\n\
    \    my @stack;\n    my $i=0;\n    \n    while($i<length($s)) {\n        push(@stack,\
    \ $s[$i++]);\n    }\n    while(@stack) {\n        $s = substr($s, 0, -1) if $s[length($s)]\
    \ == $stack[0];\n        $result[$_] = $s if $s[length($s)] == $c;\n        pop(@stack);\n\
    \    }\n    return ($result[@result-1], $result[@result]);\n}\n</code>\n<|/ a\
    \ tags=perl,string-comparison,palindrome |>\n<| c |>\nThe idea is nice, but your\
    \ code is still bad. You don't need to use subroutines and globals, and you don't\
    \ need to use $i to count the characters. The key is to count the characters in\
    \ the string and use that to determine if they are equal or not. Also, this answer\
    \ doesn't explain how to determine if a string is a palindrome or not.\n<|/ c\
    \ |>\n<| a tags=perl,string-comparison,palindrome |>\nYou can do the following\
    \ in perl. First you reverse the string and then check whether it is palindrome\
    \ or not.\n<code>", "    $s =~ tr/@$c//d;\n    return ($s ? substr($s, 0, 0) :\
    \ \"\", $s ? 1 : 0);\n}", "    my($result);\n    $s =~ s/($c)//;\n    if ($s =~\
    \ tr/$c/$c/ =~ tr/$c/$c/) {\n        $result = ($s);\n        $result = ($result,\
    \ 1);\n    }\n    $result;\n}", "    my @chars = split(//, $c);\n    my $result;\n\
    \    my @temp;\n    my @new_chars;\n    my $check = 1;\n    my @last_check;\n\
    \    foreach my $char (@chars) {\n        push(@new_chars, $char);\n    }\n  \
    \  $result = join(\"\", @new_chars);\n    if ($result eq $s) {\n        return\
    \ (\"$result\", 1);\n    }\n    foreach my $char (@chars) {\n        foreach my\
    \ $last (@last_check) {\n            if ($char eq $last) {\n                $check\
    \ = 0;\n                last;\n            }\n        }\n        if ($check ==\
    \ 1) {\n            push(@temp, $char);\n        }\n    }\n    $result = join(\"\
    \", @temp);\n    $result = reverse_delete($s, $result);\n    if ($result->[1])\
    \ {\n        $check = 0;\n    }\n    push(@last_check, $chars[-1]);\n    if ($check\
    \ == 1) {\n        push(@temp, $chars[-1]);\n    }\n    $result = join(\"\", @temp);\n\
    \    return (\"$result\", 0);\n}", "    my(@result) = (\"\");\n    my($i, $j);",
  "    my(@result) = (\"\");\n    my $index = 0;\n    while (length($s) > 0) {\n \
    \       if (index($s, $c, $index) != -1) {\n            splice(@result, 0, length($s),\
    \ \"\");\n            splice(@result, 0, 1);\n        }\n        $index++;\n \
    \   }\n    if (length($result) == 0) {\n        push(@result, \"\");\n    }\n\
    \    return @result;\n}", "    my %seen;\n    my @s = map {$seen{$_}++ ? $seen{$_}\
    \ : $_} split //, $s;\n    my $pal = join \"\", map { $c->[0] eq $_ ? \"\" : $c->[0]\
    \ } @{$c->[1]};\n    my $rev = join \"\", map { $c->[0] eq $_ ? \"\" : $c->[0]\
    \ } reverse @{$c->[1]};\n    return [ $rev => 1, $pal ];\n}", "    $s = reverse($s);\n\
    \    my = grep($_ ne $c, split //, $s);\n    return $a[0] =~ /^(.+?)\\1+$/s ?\
    \ $a[0] : $a[0] . ($a[1]?1:'');\n}", "    my($result, $flag);\n    $flag = 0;\n\
    \    for my $char (split(//, $s)) {\n        if ($char == $c) {\n            $flag\
    \ = 1;\n        }\n        if ($flag) {\n            $result = $char . $result;\n\
    \        }\n    }\n    $flag = 0;\n    for my $char (split(//, $result)) {\n \
    \       if ($char == $c) {\n            $flag = 1;\n        }\n        if ($flag)\
    \ {\n            $result = $result . $char;\n        }\n    }\n    if (length($result)\
    \ == length($s)) {\n        push @{$result}, \"\";\n    }\n    if ($flag) {\n\
    \        @{$result} = ();\n    } else {\n        @{$result} = split(//, $result);\n\
    \    }\n    return ($result, @{$result});\n}\n</cell>\n<text>\nPermutations\n\
    Given a string s, we have to delete all the character in the string which are\
    \ equal to the character in the position $i of the string, then check if the result\
    \ string is palindrome.\nA string is called palindrome if it reads the same backward\
    \ as forward.\nYou should return an array containing the result string and 1/\
    \ for the check.\nExample\n>>> permutation_delete(\"abcde\", \"d\")\n[\"abcd\"\
    , \"\"]\n>>> permutation_delete(\"abcdef\", \"b\")\n[\"abef\", \"\"]\n>>> permutation_delete(\"\
    abcdedcba\", \"ab\")\n[\"abdcd\", \"\"]\n>>> permutation_delete(\"abcde\", \"\
    c\")\n[\"abcdc\", \"\"]\n>>> permutation_delete(\"abcde\", \"b\")\n[\"abde\",\
    \ \"\"]\n>>> permutation_delete(\"abcde\", \"e\")\n[\"abde\", \"\"]\n>>> permutation_delete(\"\
    abcde\", \"\")\n[\"abcde\", \"\"]\n>>> permutation_delete(\"abcd\", \"a\")\n[\"\
    abc\", \"a\"]\n>>> permutation_delete(\"abcd\", \"\")\n[\"abcd\", \"\"]", "  \
    \  # Scan the string, deleting all characters that are equals to $c\n    # Keep\
    \ the original string, to print in case of fail\n    my (@result, $original);\n\
    \    my $j = 0;\n    for ($j = $#s; $j >= 0; $j--)\n    {\n        my $tmp = $s->[$j];\n\
    \        for ($j = $#c; $j >= 0; $j--)\n        {\n            if ($tmp eq $c->[$j])\n\
    \            {\n                $s->[$j] = '';\n                last;\n      \
    \      }\n        }\n        $original = $original->.$s->[$j];\n        if ($j\
    \ == 0)\n        {\n            push (@result, $original);\n        }\n    }\n\
    \    if (@result)\n    {\n        return @result;\n    }\n    else { return (@result,\
    \ 0); }\n}", "    my $is_palindrome = 1;\n    my @res;\n    my $i = 0;\n    my\
    \ $j = 0;\n    \n    for(my $k = 0; $k < length($s); $k++) { \n        if($s[$k]\
    \ eq $c) { \n            $is_palindrome = 0;\n            last;\n        }\n \
    \   }\n    \n    for(my $k = 0; $k < (length($s)-1); $k++) { \n        if($s[$k]\
    \ ne $c) { \n            $is_palindrome = 0;\n            last;\n        }\n \
    \   }\n    \n    if($is_palindrome) {\n        $res[0] = $s;\n    } else {\n \
    \       $res[0] = '';\n        $is_palindrome = 1;\n    }\n    \n    for(my $k\
    \ = (length($s)-1); $k >= 0; $k--) { \n        $res[$k] = $s[$k];\n    }\n   \
    \ \n    if(length($s) != length($res[0])) {\n        $is_palindrome = 0;\n   \
    \ }\n    \n    if(!$is_palindrome) {\n        $res[0] = '';\n    }\n    \n   \
    \ return @res;\n}", "    my @result;\n    my $flag = 0;\n    foreach my $i ( 1\
    \ .. length($s) - 1 ) {\n        my $j = ( $i - 1 );\n        my $s = substr($s,\
    \ $i, 1);\n        foreach my $k ( 1 .. length($c) - 1 ) {\n            my $c\
    \ = substr($c, $k, 1);\n            next if $c eq $s;\n            $flag = 1;\n\
    \        }\n        last if !$flag;\n        push @result, $s;\n    }\n    return\
    \ ($flag, @result);\n}", "    my @r = reverse($s);\n    $r = delete_equals($r,\
    \ $c);\n    return (@r ? '' : 0, $r) unless $r[0];\n    return ('', '', 1) unless\
    \ $r[0] == $r[-1];\n}", "    my @d = ();\n    my $x = 0;\n    my $res = \"\";\n\
    \    while ($x != length($s)) {\n        my $str = $s;\n        for ($x = 0; $x\
    \ < (length($str) - length($c)); $x++) {\n            $str =~ s{^.{$c}}{substr\
    \ $str, 0, length($c) - $x};\n        }\n        if ($str == $res) {\n       \
    \     push @d, $res;\n        } else {\n            push @d, $str;\n        }\n\
    \        $x++;\n        $res = $str;\n    }\n    return (\\@d, 0);\n}", "    my\
    \ $check = 1;\n    my @result = ();\n    my $i = 0;\n    my $string = \"\";\n\
    \    \n    # Start with an empty string\n    \n    # Remove from string $c while\
    \ $s does not contain the given string\n    # if the removed string is empty we\
    \ are not palindromic so we return the string\n    # otherwise we keep doing so\
    \ we append the string to our result array\n    \n    # Check for end of string\n\
    \    # if we reach the end of the string then we are not palindromic so we return\
    \ an empty array\n    \n    # While $s contains $c remove from string $c while\
    \ $s does not contain the given string\n    \n    # Check for end of string\n\
    \    # if we reach the end of the string then we are not palindromic so we return\
    \ an empty array\n    \n    # While $s contains $c remove from string $c while\
    \ $s does not contain the given string\n    \n    # Remove from string $c while\
    \ $s does not contain the given string\n    \n    # Append the result to our result\
    \ array\n    \n    # While $s contains $c remove from string $c while $s does\
    \ not contain the given string\n    \n    # Check for end of string\n    # if\
    \ we reach the end of the string then we are not palindromic so we return an empty\
    \ array\n    \n    # Append the result to our result array\n    \n    return @result;\n\
    }", '    my @res = ();', '    my @result = ();', "    my(@result) = (\"\",0);\n\
    \    foreach my $i (0 .. length($s)-1) {\n        if ($s =~ /$c/) {\n        \
    \    push(@result, $s);\n            push(@result, \"\");\n        }\n       \
    \ elsif ($i == length($s)-1) {\n            push(@result, $s);\n            push(@result,\
    \ 1);\n        }\n        else {\n            push(@result, substr($s, $i, 1));\n\
    \            push(@result, substr($s, 0, $i-1));\n        }\n    }\n    return\
    \ @result;\n}", "    my @res = ();\n    my @t = ();\n    my $str = \"\";\n   \
    \ my $check;\n    my @tt = ();\n    my $i = 0;\n    for(my $j = 0; j < length($s);\
    \ $j++) {\n        push(@t, substr($s, $j, 1));\n    }\n    for(my $j = 0; j <\
    \ length($c); $j++) {\n        push(@tt, substr($c, $j, 1));\n    }\n    for(my\
    \ $k = 0; $k <= $#t; $k++) {\n        if($t[$k] eq $tt[$k]) {\n            $check\
    \ = 1;\n        } else {\n            $check = 0;\n        }\n    }\n    if($check\
    \ == 1) {\n        push(@res, $s);\n    } else {\n        $res = reverse_delete($c,\
    \ $c);\n        push(@res, $res[0]);\n    }\n    return @res;\n}", "    my @chars\
    \ = ();\n    $s{$_}++ for keys %$s;\n    for my $char (split //, $c) {\n     \
    \   unless ($s{$char}) {\n            push @chars, $char;\n        }\n    }\n\
    \    $chars << \"\\0\" if @chars == 0;\n    return (\"\\0\", 1) if (@chars !=\
    \ scalar @$c);\n    return ($chars[0], 1) if (reverse @chars eq @$c);\n    return;\n\
    }", "    my($result, $checked);\n    if ($s =~ tr/./d$c) { # check if string is\
    \ in reversed order\n        # delete each char that is equal to $c in s\n   \
    \     my $i = 0;\n        my $len = $#s;\n        while ($i < $len) {\n      \
    \      if ($s[$i] eq $c) {\n                $result = $result . $s[$i];\n    \
    \            delete $s[$i];\n            } else {\n                $i++;\n   \
    \         }\n        }\n        if ($result eq $s) {\n            $checked = 1;\n\
    \        } else {\n            $checked = 0;\n        }\n        return [$result,\
    \ $checked];\n    } else {\n        return [$s, 0];\n    }\n}", "    my @s = split(//,\
    \ $s);\n    my @c = split(//, $c);\n    return if @s == @c;\n    my($i, $j) =\
    \ (@c - 1, 0);\n    my $res = \"\";\n    while (1) {\n        unless ($s[$i] ==\
    \ $c[$j]) {\n            $res .= $s[$i];\n            ++$i;\n            ++$j;\n\
    \            last if $j >= @c;\n        } else {\n            ++$i;\n        \
    \    ++$j;\n            last if $i >= @s;\n        }\n    }\n    $res;\n}", " \
    \   return @{$_[0]} unless @{$_[0]} > @{$_[1]};\n    my($ret, $res, $indel);\n\
    \    foreach my $i (0 .. $#{$s[0]} -1) {\n        $ret = $ret.$s[$i] if $s[$i]\
    \ eq $c;\n        $indel = 1;\n        $res .= $s[$i] if $s[$i] eq $s[$i-1];\n\
    \        foreach my $j ($i+1 .. $#{$s} - 1) {\n            $res .= $s[$j] if $s[$j]\
    \ eq $s[$j-1];\n            $indel = 1 if $s[$i] eq $s[$j];\n        }\n     \
    \   $res .= \"\\0\" if $indel;\n        $res .= reverse $ret; \n    }\n    return\
    \ ($res, 1);\n}", "    # check if the string $c is a palindrome\n    if (is_palindrome($c))\
    \ {\n        $result = [$c, 1];\n        return $result;\n    }\n    my @result\
    \ = reverse_delete($s, $c);\n    push (@result, $result[-1]) if $result[-1] eq\
    \ $c;\n    return @result;\n}", "    # split string into characters\n    my(@chars);\n\
    \    while($s =~ /(.)(.*)/) {\n\tpush(@chars, $1);\n    }\n    # delete chars\
    \ in s\n    for(@chars) {\n\tdelete $s;\n    }\n    # check result\n    if($s\
    \ eq join(\"\", @chars)) {\n\treturn [\"\", \"1\"];\n    } else {\n\treturn [\"\
    \", \"0\"];\n    }\n}", "    my $result = \"\";\n    my $is_deleted;", "    my(@result)\
    \ = (\"\", 1);\n    for(my $i = 0; $i < length $s; $i++) {\n        if(index($c,\
    \ $s[$i]) > 0) {\n            $s[$i] = \"\";\n        }\n        else {\n    \
    \        push(@result, $s[$i]);\n        }\n    }\n    return @result;\n}", " \
    \   $c =~ tr/a-zA-Z//cd;\n    my $rs = reverse($s);\n    return [$rs, $c eq $rs]\n\
    }", "    my @res;\n    my $i = $#s - 1;\n    for (; $i >= 0; $i -= 1, $i -= 1)\
    \ {\n        if ($s[$i] == $c) {\n            $res[0] .= $s[$i];\n           \
    \ $res[1] = 1 if $i >= 0;\n            last;\n        }\n    }\n    return @res;\n\
    }", "    my($result,$palindrome);\n    for($s=0 .. length($s)-1) {\n        $palindrome=1;\n\
    \        for(my $x=length($s)-$s ; $x <= length($s) ; $x++) {\n            $palindrome=0\
    \ if $s[$x]!=$s[$x+1];\n        }\n        $result[$s]=substr($s,0,$x);\n    \
    \    $result[$s]=~tr/$c/$c/g;\n        if($result[$s]!=$s) {\n            $palindrome=0;\n\
    \        }\n    }\n    return($result, $palindrome);\n}", "    my @result = [];\n\
    \    my $found = 0;", '    my @reverse;', "    my @rev = reverse($s);\n    my\
    \ $palindrome = \"\";\n    my $cnt = 0;\n    for (my $i = 0; $i < @rev; $i++)\
    \ {\n        if ($rev[$i] != $c[($i-1)%$#c]) {\n            $palindrome .= $rev[$i];\n\
    \            $cnt++;\n        }\n    }\n    if ($palindrome =~ /^([A-Za-z0-9]+)$/)\
    \ {\n        return [$1, $cnt];\n    }\n}", "    $s ||= \"\";\n    $c ||= \"\"\
    ;", "    my @chars = split(//,$s);\n    my $found = 0;\n    for my $c (@chars)\
    \ {\n        $found += $c == $c\n            if $c==$c;\n    }\n    return [$s,\
    \ $found];\n}\n</code>\n<|/ a dscore=0 tags=perl,string,arrays |>\n<| c |>\nI\
    \ did this in python:", "    my $result = \"\";\n    my $flag = 1;\n    for my\
    \ $pos (0 .. length($s) - 1) {\n        my $char = $s[$pos];\n        if ($char\
    \ eq $c) {\n            $flag = 0;\n        }\n        if ($flag == 1) {\n   \
    \         $result .= $char;\n        }\n    }\n    if ($flag == 0) {\n       \
    \ $result .= $char;\n    }\n    return ($result, 1);\n}\n</code>\n<|/ a tags=perl,algorithm,string,python\
    \ |>\n<| a |>\nI wrote a Python program to solve this problem:\n<code>\ndef palindrome_reverse(s):\n\
    \    if not s: return ''\n    i, j = 0, 0\n    s1 = s.lower()\n    s2 = s1[:i]\
    \ + s1[j::-1]\n    if s2 == s1: return ''\n    while j < len(s1) and i < len(s2)-1:\n\
    \        if s1[i] == s2[j]:\n            i += 1\n        elif s1[i] > s2[j]:\n\
    \            i += 1\n        else:\n            j += 1\n    if j == len(s1) -\
    \ 1: return s2\n    if i == len(s2) - 1: return s2\n    return s1 + palindrome_reverse(s2)",
  "    my @result = ();\n    my $i = 0;\n    my $j = @$c - 1;\n    while ($i < $j)\
    \ { \n        $result[$i] = $s[$i] if $s[$i] == $c[$j];\n        $i++;\n     \
    \   $j--;\n    }\n    $result[$i] = \"\" if $i >= $j;\n    return @result;\n}\n\
    </cell>\n<code language=julia-1.5>\nreverse_delete(\"abcde\", \"ae\")\n</cell>\n\
    <code language=julia-1.5>\nreverse_delete(\"abcdef\", \"b\")\n</cell>\n<code language=julia-1.5>\n\
    reverse_delete(\"abcdedcba\", \"ab\")\n</cell>\n<code language=julia-1.5>\nreverse_delete(\"\
    abcdedcba\", \"ab\") \u2261 reverse_delete(\"abcdedcba\", \"ba\") \n</cell>\n\
    <code language=julia-1.5>\nreverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"\
    abcdedcba\", \"ab\")\n</cell>\n<code language=julia-1.5>\nreverse_delete(\"abcdedcba\"\
    , \"ab\") \u2261 reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"\
    abcd\", \"ab\")\n</cell>\n<code language=julia-1.5>\nreverse_delete(\"abcdedcba\"\
    , \"ab\") \u2261 reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"\
    abcd\", \"ab\") \u2261 reverse_delete(\"abcd\", \"ba\")\n</cell>\n<code language=julia-1.5>\n\
    reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"abcdedcba\", \"\
    ab\") \u2261 reverse_delete(\"abcd\", \"ab\") \u2261 reverse_delete(\"abcd\",\
    \ \"ba\") \u2261 reverse_delete(\"abcd\", \"ab\")\n</cell>\n<code language=julia-1.5>\n\
    reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"abcdedcba\", \"\
    ba\") \u2261 reverse_delete(\"abcd\", \"ba\")\n</cell>\n<code language=julia-1.5>\n\
    reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"abcdedcba\", \"\
    ab\") \u2261 reverse_delete(\"abcd\", \"ab\")\n</cell>\n<code language=julia-1.5>\n\
    reverse_delete(\"abcdedcba\", \"ba\") \u2261 reverse_delete(\"abcdedcba\", \"\
    ba\")\n</cell>\n<code language=julia-1.5>", "    my(@result) = ();\n    \n   \
    \ foreach my $i (0 .. length($s) - 1) {\n        my $found = 1;\n        \n  \
    \      foreach my $j (0 .. length($c) - 1) {\n            next if $s[$i] == $c[$j];\n\
    \            $found = 0;\n            last;\n        }\n        \n        if ($found)\
    \ {\n            push (@result, $s[$i]);\n        }\n    }", "    # Check if it's\
    \ empty string\n    return ( $s == \"\" ? [ $s, 1 ] : () ) if $s eq $c; # check\
    \ empty string\n    # Iterate over the string and store the chars to be deleted\n\
    \    my @delete = ();\n    for(my $i = 0; $i <= length($s); $i++) {\n        push\
    \ @delete, $s[$i] if $s[$i] eq $c; # push char onto array\n    }\n    # Iterate\
    \ over the array backwards and delete char\n    my $r = '';\n    for(my $i = length($s)\
    \ - 1;$i >= 0;$i--) {\n        my $tmp = $s[$i];\n        $tmp = $s[$i] unless\
    \ $tmp eq $delete[$i]; # delete char from string if found\n        $r .= $tmp;\n\
    \    }\n    return ( $r, 1 ) if $r == $s; # check palindrome\n    return ( (),\
    \ 0 ); # string is not palindrome\n}\n</code>\n<|/ a tags=string,algorithm,palindrome,perl\
    \ dscore=0 |>\n<| a tags=string,algorithm,palindrome,perl dscore=0 |>\n<code>",
  "    my @result = ();\n    my $count = 0;\n    my $i = 0;\n    while (1) {\n   \
    \     my $tmp = $s[$i];\n        if (index($c, $tmp) == -1) {\n            push\
    \ @result, $tmp;\n            $count++;\n        }\n        elsif ($tmp ne $s[$i+1])\
    \ {\n            push @result, $tmp;\n            $count++;\n        }\n     \
    \   $i++;\n        unless ($i >= @s) {\n            push @result, $s[$i];\n  \
    \          $count++;\n            $i = 0;\n        }\n    }\n    push @result,\
    \ $s[$i];\n    $result[0] eq $s[$i] && $count++;\n    return @result;\n}", " \
    \   my @result;\n    my $len = length($c);\n    \n    my @check = reverse grep\
    \ { $_ eq $c } split(//, $s);\n    \n    \n    for(my $i = 0; $i < $len; $i++)\
    \ {\n        push @result, $s[$i] if $check[$i] == $s[$i];\n    }\n    \n    return\
    \ @result, 1 if scalar(@result) == $len;\n    \n    return @result;\n}\n</cell>\n\
    <cell>", "    $s =~ tr/./d; # remove all duplicates\n    $s =~ tr/$c/d; # remove\
    \ all characters equal to $c\n    return ($s, 1);\n}", "    my(@result);\n   \
    \ my $is_palindrome = 1;\n    \n    # Find out which character in $s is a match\
    \ with $c\n    # e.g. ab => a, aa => a\n    my $idx;\n    for (my $idx = 0; $idx\
    \ < length($s); $idx++) {\n        if (substr($s, $idx, 1) eq $c) {\n        \
    \    last;\n        }\n    }\n    \n    # Delete all characters in $s equal to\
    \ $c\n    $s =~ s/.$c/;\n    \n    # Check the string\n    $is_palindrome = ($s\
    \ == $s) ? 1 : 0;\n    \n    # Store result and 1/\n    push(@result, $s, $is_palindrome);\n\
    \    \n    return @result;\n}", "    my @r = ();\n    # Traverse the string forward\
    \ and delete characters\n    for my $i (0 .. $#s) {\n        my $d = $s[$i];\n\
    \        # Check if the current character is a character in $c\n        if (index($c,\
    \ $d) >= 0) {\n            # Delete the character from string\n            $s\
    \ =~ s/$d//;\n        } else {\n            $r .= $d;\n        }\n    }\n    #\
    \ Check if the string is palindrome\n    if ($s eq reverse $s) {\n        push\
    \ @r, \"\", 1;\n    }\n    return @r;\n}", "    my @a; # holds the final result\n\
    \    my $j = 0;\n    # reverse the array\n    for(my $i = @$s - 1;$i >= 0; $i--){\n\
    \        # if the character at the position is the same\n        # as the last\
    \ character in the array then ignore it\n        if($s[$i] eq $s[$i-1]){\n   \
    \         $j++;\n        }\n        # append it to the new string\n        push\
    \ @a, $s[$i];\n    }\n    # check if the last element is equal to the first one\n\
    \    if($s[$i-1] eq $s[$i]){\n        $j++;\n    }\n    # append the final result\
    \ to the array\n    push @a, \"\";\n    # return the result\n    return @a;\n}",
  "    my ($result, $result) = reverse_delete_string($s, $c);\n    return $result\n\
    }", "    my(@result) = ();\n    \n    # Find the reverse of the string\n    my(@rev)\
    \ =;\n    \n    # Delete all the elements from the original string\n    for(my\
    \ $i = 0; $i <= length($s); $i++) {\n        for(my $j = 0; $j <= length($c);\
    \ $j++) {\n            if(substr($s, $i, 1) ne substr($c, $j, 1)) {\n        \
    \        push (@result, substr($s, $i, 1));\n                last;\n         \
    \   }\n        }\n    }\n    \n    if(@rev ne @result) {\n        @result = ();\n\
    \    }\n    return @result;\n}", "    my @a = reverse($s);\n    my @b = reverse($c);\n\
    \    my $rs = $a;\n    $rs .= $b unless $a eq $b; # Don't delete the characters\
    \ from $c\n    $rs = reverse $rs if $a eq $b; # Remove all characters equal to\
    \ $c from $s\n    return [$rs, 1];\n}", "    my @result;\n    for (my $i = 0;\
    \ $i < length($s) ; $i++) {\n        push(@result, substr($s, $i, 1));\n     \
    \   for (my $j = 0; $j < length($c); $j++) {\n            if (substr($s, $i, 1)\
    \ eq substr($c, $j, 1)) {\n                splice(@result, $i, 1);\n         \
    \       return [@result, 1];\n            }\n        }\n    }\n    @result;\n}",
  "    if (length($c) == 1) {\n        return [$s . $c, 1];\n    }\n    my $result\
    \ = [];\n    for (my $i = 0; $i < length($s); $i++) {\n        if ($s[$i] == $c)\
    \ {\n            $result[$i] = $s[$i];\n            $result[-1] .= $s[$i];\n \
    \       } else {\n            $result[$i] = \"\";\n        }\n    }\n    my $check\
    \ = 1;\n    for (my $i = 0; $i < length($s); $i++) {\n        if ($result[$i]\
    \ ne $s[$i]) {\n            $check = 0;\n        }\n    }\n    if ($check) {\n\
    \        return [$result, 1];\n    }\n    return [$s, 0];\n}", "    my @res =\
    \ ();\n    my $i = 0;\n    while($i < length($s)) {\n        foreach my $char\
    \ (split(//, $c)) {\n            if($char eq $s[$i]) {\n                unshift\
    \ @res, $s[$i];\n                last;\n            }\n        }\n        $i++;\n\
    \    }\n    if(@res == 0) {\n        @res = ();\n    }\n    return (@res, scalar(@res));\n\
    }", "    my @r = ();\n    my($p, $i, $j, $is_palindrome, $rev, $tmp);\n    # check\
    \ if all characters are the same\n    if (length($s) ne length($c)) {\n      \
    \  return ();\n    }\n    $p = $i;\n    $i = $j;\n    $is_palindrome = 0;\n  \
    \  while ($i < length($s)) {\n        if ($s[$i] ne $c[$i]) {\n            $is_palindrome\
    \ = 0;\n            last;\n        }\n        $i++;\n    }\n    last if ($is_palindrome);\n\
    \    # reverse the string\n    while($i < length($s)) {\n        $tmp = $s[$i++];\n\
    \        $rev .= $tmp;\n    }\n    # check if string equals to its reverse\n \
    \   if ($s ne $rev) {\n        $rev = ();\n        $is_palindrome = 0;\n    }\n\
    \    # append the result string to the result array\n    push(@r, $rev);\n   \
    \ push(@r, 1) if ($is_palindrome);\n    return @r;\n}", "    my @result;\n   \
    \ my @chars = split('', $c);\n    for (my $i=length($s)-1;$i>=0;$i--) {\n    \
    \    if ($s =~ m/\\Q$chars[$i]\\E/i) {\n            push @result, $chars[$i];\n\
    \        }\n    }\n    return [@result, scalar @chars];\n}", "    my @result =\
    \ ();\n    my $reverse_search = $c;\n    my $search = $c;\n    my $count = $1;\n\
    \    \n    my $length_s = length $s;\n    \n    for (my $i = 0; $i < $length_s\
    \ - $count; $i++) {\n        my $char = $s[$i];\n        my $char_rs = substr($s,\
    \ $i + $count - 1, 1);\n        \n        if ($char ne $char_rs) {\n         \
    \   push(@result, $char);\n        }\n    }\n    \n    return (@result, $count);\n\
    }", "    my @result = ();\n    my $i = 0;\n    while ($i <= length($s) - 1) {\n\
    \        if (index($c, substr($s, $i, 1)) != -1) {\n            push(@result,\
    \ substr($s, $i, 1));\n            push(@result, \"\");\n            $i++;\n \
    \       } else {\n            push(@result, substr($s, $i, 1));\n            $i++;\n\
    \        }\n    }\n    push(@result, \"\");\n    return (@result);\n}\n</code>\n\
    <|/ a dscore=0 tags=palindrome,perl,substring |>\n<| a tags=palindrome,perl,substring\
    \ |>\n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    my @res = ();\n\
    \    my @check = ();\n    $_ = $s;\n    my $index = 0;\n    # Step 1 : Check whether\
    \ string is a palindrome or not.\n    # Step 2 : Traverse string from 0 to len-1\
    \ and mark all those characters which are equal to $c in a array.\n    while($index<length($s)\
    \ && $index<length($c)) {\n        push(@check, $s[$index]);\n        $index++;\n\
    \    }\n    # Step 3 : Check if all characters in string are equal or not.\n \
    \   # Step 4 : Traverse string from index+1 to len-1 and delete those characters\
    \ which are equal to $c in a array.\n    while($index<length($s)) {\n        push(@check,\
    \ $s[$index]);\n        push(@res, substr($s, $index+1, length($s)-$index-1));\n\
    \        $index++;\n    }\n    # Step 5 : Check if all characters in string are\
    \ equal or not.\n    # Step 6 : Return array containing original string and 1/\
    \ for palindrome check or 0/ for non palindrome.\n    return ($s, $check, $res);\n\
    }", "    my $i = 0;\n    my $r = [];\n    for(my $i = 0; $i < length($s); $i++)\
    \ {\n        if($s[$i] == $c){\n            $i++;\n        }\n        else{\n\
    \            $r[$i] = $s[$i];\n        }\n    }\n    if($r == reverse($s)){\n\
    \        $r = [];\n    }\n    return ($r, 1);\n}", "    # create an array to store\
    \ the original character array\n    my($a_s_c) = split(//, $s);\n    \n    # check\
    \ each character of $c against $a_s_c\n    foreach my $c (split(//, $c)) {\n \
    \       # find any element in $a_s_c equal to $c\n        my $index = -1;\n  \
    \      foreach my $s_c (@$a_s_c) {\n            if ($s_c == $c) {\n          \
    \      $index++;\n                last;\n            }\n        }\n        # if\
    \ the element exists, delete it\n        if ($index != -1) {\n            @$a_s_c[$index]\
    \ = \"\";\n        }\n    }\n    \n    # check if $a_s_c is palindrome\n    my\
    \ $palindrome = 1;\n    my $i = 0;\n    my $j = $#a_s_c;\n    while ($i < $j)\
    \ {\n        $palindrome = $palindrome and $a_s_c[$i] == $a_s_c[$j];\n       \
    \ $i++;\n        $j--;\n    }\n    \n    return [join(\"\", @$a_s_c), $palindrome];\n\
    }", "    my @result = ();\n    my $palindrome = 1;\n    for (my $i = length($s)\
    \ -1; $i >= 0; $i--) {\n        if ($s eq substr($c, $i, 1)) {\n            splice(@result,\
    \ $i, 1);\n            $palindrome = 1;\n            last;\n        }\n    }\n\
    \    if ($palindrome) {\n        push(@result, \"\");\n    }\n    return (\\@result,\
    \ $palindrome);\n}", "    $s eq reverse($c) ? [reverse($s), 1] : \"@{[reverse(@$s)]}\"\
    ;\n}", "    my @r = ();\n    my $i;\n    for ($i = 0; $i < length($s); $i++) {\n\
    \        my $d = substr($s,$i, 1);\n        push @r, $d if ($d eq $c);\n    }\n\
    \    return ($s,$i,@r) if $r[0];\n    my $rem = substr($s,$i, length($s) - $i\
    \ - 1);\n    push @r, \"$rem\" unless ($rem eq $c);\n    return ($s,$i,@r) if\
    \ @r == 0;\n    return ($s,$i,@r) if $r[0] ne $r[-1];\n    return ($s,$i,@r) if\
    \ $r[0] eq $c;\n    return ($s,$i,@r);\n}", "    my(@result) = (\"\", 1);\n  \
    \  # Loop until we have no more character to delete\n    while ($c ne \"\") {\n\
    \        # Delete all the character of $s\n        chomp($s);\n        # Check\
    \ if the character is equal to any character in $c\n        foreach my $x (split(//,\
    \ $s)) {\n            unless ($x eq substr($c, 0, 1)) {\n                # If\
    \ not, remove it\n                pop(@result);\n                last;\n     \
    \       }\n        }\n    }\n    if (@result) {\n        # Check if result string\
    \ is palindrome\n        if (join('', @result) eq reverse($s)) {\n           \
    \ return [@result, \"\"];\n        }\n    }\n}", "    my @res;\n    my $index\
    \ = 0;", "    my;\n    foreach my $char (@$s) {\n        foreach my $char1 (@$c)\
    \ {\n            if ( $char == $char1 ) {\n                push, $char1;\n   \
    \             next;\n            }\n        }\n        push, $char;\n    }\n \
    \   return [ $s, 1 ];\n}", "    my($i, $len, $results);\n    \n    # check $s\
    \ against $c\n    $len = length $s;\n    \n    # prepare $results\n    $results\
    \ = [\"\"];\n    \n    # check $c against all chars in $s\n    for ($i = 0; $i\
    \ < $len; $i++) {\n        \n        # check if char at $i of $c is found in $s\n\
    \        if (index($s, substr($c, $i, 1)) != -1) {\n            \n           \
    \ # check if current $s char is found in next $c char\n            my $c = substr($c,\
    \ $i, 1);\n            \n            # remove the found char\n            $s =\
    \ substr($s, 0, $i-1) . $s;\n            \n            # append the current char\n\
    \            $results[-1] = $c;\n            \n            # check if $s is a\
    \ palindrome\n            $results[-1] = $results[-1] and index($s, $results[-1])\
    \ == 0;\n            \n        }\n    }\n    \n    # return the results and 1\
    \ as result flag\n    return [@$results, 1];\n}", "    my @s;\n    my $i = 0;\n\
    \    my $flag = 1;\n    while ($i < length($s)) {\n        if ($s[$i] == $c) {\n\
    \            $flag = 0;\n        }\n        if ($flag) {\n            push(@s,\
    \ $s[$i]);\n            $i++;\n        }\n    }\n    if (@s == 0) {\n        return\
    \ [\"\", $flag];\n    }\n    my $result = '';\n    my $flag = 0;\n    while (@s\
    \ > 0) {\n        if ($s[$i] != $s[$i-1]) {\n            $flag = 1;\n        }\n\
    \        if ($flag) {\n            push(@s, '');\n        }\n        $result +=\
    \ $s[$i];\n        $i++;\n    }\n    return [$result, 1];\n}", "    my@result\
    \ = ();\n    \n    my $idx = 0;\n    for (my $i = 0; $i < length($s); $i++) {\n\
    \        for ($j = 0; $j < length($c); $j++) {\n            if ($s[$i] == $c[$j])\
    \ {\n                splice(@result, $idx++, $s[$i], 1);\n            }\n    \
    \    }\n    }\n    \n    # check the result is a palindrome\n    if ($result[-1]\
    \ eq \"\") {\n        my $rev_s = reverse($s);\n        if ($rev_s == $s) {\n\
    \            @result = $rev_s;\n            return @result;\n        }\n    }\n\
    \    \n    return @result;\n}\n</code>\n<|/ a tags=perl,string,algorithm |>\n\
    <| c |>\nThat's an interesting approach, but I'm more interested in why my code\
    \ doesn't work (even if it is a different approach). I believe that my code should\
    \ work too, because I'm deleting characters one at a time, and I still get the\
    \ same result. My question is more about the reasoning behind why it works that\
    \ way, than how to make it work the way it does.\n<|/ c |>\n<| c |>\nThe reason\
    \ is that the for loop will end at the second loop ($j < length($c)). In the first\
    \ iteration, the value of $j will be 0, and we end up deleting 0 characters from\
    \ $s.\n<|/ c |>\n<| c |>\nIt's not so much about the reasoning, it's about why\
    \ the loop doesn't exit, since it does exit on the second iteration of the outer\
    \ loop ($j == $l) in the third iteration.\n<|/ c |>\n<| c |>\nAh, yeah I see!\
    \ That makes sense, thanks! My code was almost identical to the one in your answer...\
    \ I just didn't realize that it wouldn't exit the loop until after all the deletion\
    \ was done (like you said). Thanks!\n<|/ c |>\n<| c |>\nI made a minor edit to\
    \ the inner loop to add a check to see if $j is less than length($c) after the\
    \ deletion. This will fix the problem that $j won't exit on the first pass of\
    \ the loop. The reason for this is because of the way that Perl evaluates booleans.\
    \ 0 evaluates to false, and any other number evaluates to true.\n<|/ c |>\n<|\
    \ a dscore=0 tags=perl,string,algorithm |>\nIt's an interesting question. Though\
    \ I'm a little puzzled by your implementation. \nWhat I feel about your implementation\
    \ is that, even though you are deleting all characters in the string as you go\
    \ along, you're still keeping track of the position of the next ", "    my(@result)\
    \ = (\"\");\n    my $p = 0;\n    \n    for (my $i = length($s); $i >= 1; $i--)\
    \ {\n        if (substr($s, $i, 1) =~ /$c/) {\n            $result[$p] = substr($s,\
    \ $i, 1);\n            ++$p;\n        }\n    }\n    \n    if ($p > 0) {\n    \
    \    push(@result, \"\");\n        push(@result, $result[0]);\n        push(@result,\
    \ $p);\n    }\n    \n    return @result;\n}", "    my @r = ();\n    $s = reverse($s)\
    \ unless $c eq \"\\\\0\";\n    for (my $i = 0; $i <= length($s) - 1; $i++) {\n\
    \        $s->[$i] eq $c\n          and push(@r, substr($s, 0, $i));\n    }\n \
    \   return @r ? @r : ($s, 1);\n}", "    $_ = $c if substr($s,-1) == $c;\n    if(length($_)\
    \ > length($s) || $_ != $s)\n    {\n        push(@$s, $c)\n    }\n    return ($s,\
    \ 0);\n}", "    my $is_palindrome = 1;\n    my $result = [];", "    my @c;\n \
    \   my $res = \"\";\n    foreach my $c (split(//, $c)) {\n        if(index($s,\
    \ $c) != -1 && $c ne $s[$c]) {\n            push, $c;\n            push, $s[$c];\n\
    \        }\n    }\n    return ($res, scalar(@c) > 0);\n}", "    my @res;\n   \
    \ my $i = 0;\n    my $len = length($s);\n    my $result = \"\";\n    for ($i =\
    \ 0; $i < $len; $i++) {\n        for ($j = 0; $j < $len; $j++) {\n           \
    \ if ($s[$i] == $c[$j]) {\n                next;\n            }\n        }\n \
    \       $result .= $s[$i];\n        push(@res, lc($result));\n    }\n    push(@res,\
    \ \"\") if $result eq $s;\n    my @rr;\n    for ($i = 0; $i < $#res; $i++) {\n\
    \        $rr[$i] = (length($res[$i]) == 1) ? $res[$i] : \"$res[$i]\";\n    }\n\
    \    return @rr;\n}", "    my $i = length($s) - 1;\n    $c = quotemeta $c;\n \
    \   my @res = ();\n    while ($i >= 0) {\n        my $res = substr($s, $i, 1)\
    \ eq $c ? \"\" : substr($s, $i, 1);\n        $res->[1] = 1;\n        $res->[0]\
    \ .= $res;\n        push(@res, @$res);\n        $i--;\n    }\n    return wantarray\
    \ ? @res : $res[0];\n}", "    my @result = (\"\", 0);\n    my $s = $s;\n    $s\
    \ =~ tr/#$c//d;\n    return @result;\n}\n</code>\n<|/ a tags=perl,string-matching\
    \ dscore=2 |>\n<| c |>\n`my $s = $s` looks weird to me... can you elaborate?\n\
    <|/ c |>\n<| c |>\nIt is an assignment from `$s` to `$s`. It's the same as the\
    \ `my $s;` before the `while` loop. The `my` keyword declares a variable that\
    \ is local to the block.\n<|/ c |>\n<| c |>\nSorry, I misread the comment. You\
    \ are right. My bad. I deleted my comment before I saw yours. Sorry about that.\n\
    <|/ c |>\n<| c |>\nI meant that in Perl the `$s` is never assigned again, but\
    \ I wanted to say that the `$s` variable is assigned with the value of `$s` before\
    \ the `while` loop starts. I realised that after I saw your answer. :)\n<|/ c\
    \ |>\n<| c |>\nNo problem, it's good that you've made it clearer. :)\n<|/ c |>\n\
    <| a dscore=2 |>\nIn Perl there are several ways to do this. Some of the more\
    \ idiomatic ones are the following:", "    my(@result);\n    for my $i (0 .. length($s)\
    \ - 1) {\n        my($sub, $subc) = ($s[$i], $c) if ($i < length($s));\n     \
    \   my(@chars) = split '', $sub;\n        my(@charsc) = split '', $subc;\n   \
    \     my($match) = grep {$_ eq $chars[$i]};\n        if ($match) {\n         \
    \   push @result, $subc; # found a match so remove it\n            next;\n   \
    \     }\n        foreach (@chars) {\n            next unless $_ eq $chars[$_];\n\
    \            push @result, $chars[$_];\n        }\n        push @result, $subc;\
    \ # found no match so add it\n    }\n    return @result if @result;\n    return\
    \ ($s, 1);\n}", "    my @d = $s =~ /($c)/;\n    $d[0] //= '';\n    return ($d[0],\
    \ 1 );\n}", "    my @result = ();\n    my = split(//, $s);\n    for my $i (1..$#c)\
    \ {\n        push(@result, $s[$i]);\n    }\n    for my $i (1..$#c) {\n       \
    \ unshift(@result, $c[$i]);\n    }\n    unshift(@result, \"\");\n    my $check_is_palindrome\
    \ = 1;\n    for my $i (1..$#c) {\n        if ($s[$i] != $c[$i]) {\n          \
    \  $check_is_palindrome = 0;\n            last;\n        }\n    }\n    if ($check_is_palindrome\
    \ == 1) {\n        return @result;\n    } else {\n        return @result;\n  \
    \  }\n}", "    my (@result, $result);\n    # we must reverse the string first\n\
    \    for my $i ( reverse 0..($#s-$#c) ) {\n        $result = substr( $s, $i, 1\
    \ ) if ($s == substr( $s, $i, $#c ));\n        $result = [ $result, 1 ] if ($result\
    \ eq $s);\n    }\n    return @result;\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my $i = $#$s;\n    $result = substr($s, $i-1) if $i >= 1;\n    for(my\
    \ $j = 0; $j < $#$c; ++$j) {\n        $is_palindrome = 1 if ($s[$i] eq $c[$j]);\n\
    \        last if $j == $#$c || $s[$i] ne $c[$j];\n        $result = substr($s,\
    \ 0, $i-1) . $result . substr($s, $i+1);\n    }\n    $result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nPlease add some explanation. Just dropping a piece of code without\
    \ any explanation isn't really helpful.\n<|/ c |>\n<| c |>\nThis program works\
    \ perfectly and thanks for the explanation also\n<|/ c |>\n<| c |>\nThe explanation\
    \ is simple. The `reverse_delete` sub should reverse a string in place. `reverse`\
    \ does the actual job. The `@count` array is to keep track of the number of times\
    \ the character appears in the string. The `@reverse` array is a temporary variable\
    \ to reverse the string. `@count` keeps track of how many times the character\
    \ `c` appears in the `s`. `c` comes from the `c` parameter in `reverse_delete`.\
    \ `@reverse` goes from `0` to `$#s` to reverse the string. `if ($s[$i] eq $c[$j])`\
    \ checks whether `c` appears in `s` at `i` location. If yes, `@count` increments\
    \ by 1, and `@reverse` adds `$c[$j]` to `@reverse`. Then `@count` decrements by\
    \ 1 since the character `c` appears in the string once. And the program stops\
    \ looping at the end if the character `c` appears in string only once.\n<|/ c\
    \ |>\n<| c |>\nThe `last` statement is just a short-hand to `@reverse = reverse(@reverse)`\
    \ if `@reverse` is already longer than `@count`.\n<|/ c |>\n<| a tags=perl,algorithm,string,arrays\
    \ |>\nI know the question is about algorithm, but the problem can be solved with\
    \ a single regex and no temporary variables:\n<code>", "    my @a = '';\n    my\
    \ $r = '';\n    foreach my $n (reverse $s) {\n        next if $n eq $c;\n    \
    \    $r .= $n;\n    }\n    push(@a, $r) if $r != $s;\n    push(@a, 1) unless $r\
    \ == $s;\n    return @a;\n}", "    my $str = \"\";\n    my $isPalindrome = 0;\n\
    \    my $index = 0;\n    while($index != -1) {\n        $index = $c->index($s,\
    \ 0, $index);\n        if($index != -1) {\n            $str.=$c->[$index];\n \
    \       }\n    }\n    return [$str, $isPalindrome];\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=perl |>\n<code>\nuse warnings;\nuse strict;\nuse feature qw(say);",
  '    my @check;', "    my @result;\n    my @to_delete;\n    for my $s (split('',\
    \ $s)) {\n        for my $c (split('', $c)) {\n            push @to_delete, $c\
    \ if $s eq $c;\n        }\n    }\n    push @result, $s if @to_delete;\n    \n\
    \    $result[0] =~ tr/\\0//d if @to_delete;\n    return @result;\n}\n</cell>\n\
    <text>\n3.4 Palindrome Check\nHere you are asked to write a function palindrome_check.\
    \ \nFor this exercise you don't need to handle strings with only one character.\
    \ It is a requirement of the exercise.\nIf the input is not palindrome, you should\
    \ return 0, otherwise 1.", "    my($i, $j) = 0, 0;\n    my($result,$status);",
  "    if ($c eq '')\n    {\n        ($s, $c) = ($s, '');\n    }\n    if (length($s)\
    \ < 1)\n    {\n        return ($s, $c);\n    }\n    ($s, $c) = reverse_delete($s,\
    \ substr($s,0,1) . $c);\n    ($s, $c) = reverse_delete($s, substr($s,1,1) . $c);\n\
    \    return ($s, $c);\n}", "    my($rev, $ind);\n    my($len) = length $c;\n \
    \   my($result, $check) = ();", "    my @res = ();\n    for (my $i = length($s)\
    \ - 1; $i >= 0; $i--) {\n        if ($s[$i] eq $c) {\n            push(@res, $s[$i]);\n\
    \        }\n    }\n    push(@res, $s);\n    return @res;\n}", "    my($i, $j,\
    \ $k, $is_palindrome);\n    if (length($s) == 0) {\n        return ($s, 1);\n\
    \    }\n    if (length($c) == 0) {\n        return reverse_delete($s, $c);\n \
    \   }\n    for($i = 0, $j = length($s) - 1; $i < $j; $i++) {\n        $k = $s[$i];\n\
    \        if ($k eq $c) {\n            delete $s[$i];\n        }\n        elsif\
    \ (length($c) == 1) {\n            $is_palindrome = 0;\n        }\n        else\
    \ {\n            $is_palindrome = 1;\n            for($k = 0, $j = (length($c)\
    \ - 1); $k <= $j; $k++) {\n                if ($k eq $s[$i]) {\n             \
    \       delete $s[$i];\n                    break;\n                }\n      \
    \          else {\n                    $is_palindrome = 0;\n                }\n\
    \            }\n        }\n    }\n    return ($s, $is_palindrome);\n}", "    my\
    \ @res = $s =~ /($c)/g;\n    return @res > 1 ? [@res, 1] : [@res];\n}", "    my(@result)\
    \ = (\"\", 0);\n    if ($s =~ /($c)/g) { push(@result, $s) }\n    while (length($s)\
    \ > 0) {\n        my $t = substr($s, 0, -1);\n        if ($t =~ /($c)/g) { push(@result,\
    \ $t); $s = substr($s, 0, -1); } else { $s = substr($s, 0, -1) }\n    }\n    push(@result,\
    \ \"\");\n    return(@result);\n}\n</code>\n<|/ a |>\n<| a tags=arrays,perl,palindrome,algorithm\
    \ |>\nHere is my solution in Perl. It works in O(N). \n<code>\nuse strict;\nuse\
    \ warnings;", '    my($i, $j, $k, $n);', "    my @res;\n    for my $char (split(//,\
    \ $s)) {\n        if ($char eq $c) {\n            push @res, \"\";\n        }\n\
    \        else {\n            push @res, $char;\n        }\n    }\n    return ($res,\
    \ $_[0]);\n}\n</code>\n<|/ a dscore=0 tags=algorithm,perl |>\n<| a dscore=0 |>\n\
    <code>", '    my @result;', "    my(@result) = ();\n    # check if the strings\
    \ are equal\n    my $is_equal = 1;\n    $is_equal &= ($s eq $c) if ($c ne \"\"\
    );\n    return ($s, $is_equal) if ($is_equal);\n    # we have the chars, now to\
    \ remove the chars\n    # find out where the chars are in the string\n    my $position\
    \ = $s =~ tr/$c/;\n    # loop through all the chars in the string\n    for(my\
    \ $i = 0; $i < length($s); $i++) {\n        # remove char from string\n      \
    \  $s = substr($s, 0, $i-1) . substr($s, $i);\n        \n        # check if the\
    \ char is in the string and remove it\n        if($c ne \"\" && $c eq substr($s,\
    \ $i, 1)) {\n            $i = $i;\n        }\n    }\n    \n    # check if the\
    \ result is palindrome or not\n    return ($s, 1) if ($s eq reverse($s));\n  \
    \  # check if result is empty or not, if it is empty the string is not palindrome\n\
    \    my $is_palindrome = 0;\n    for(my $i = 0; $i < length($s); $i++) {\n   \
    \     # check if chars are equal, if so, remove the chars\n        $is_palindrome\
    \ |= ($c ne substr($s, $i, 1)) if ($c ne \"\");\n    }\n    return ($s, $is_palindrome)\
    \ if ($is_palindrome);\n    # not palindrome, return the string\n    return ($s,\
    \ 1);\n}", "    my $res;\n    my $index = 0;\n    $index++ if $s =~ /^$c$/i;\n\
    \    while ($index < length($s)) {\n        $index++ if $s =~ /^$c$/i;\n     \
    \   $index-- if $s =~ /^$c$/i;\n        if ($s =~ /^($c)(.*)$/) {\n          \
    \  $res = $1;\n            if (length($res) != length($s)) {\n               \
    \ $res = \"\";\n            }\n        } else {\n            $res = \"\";\n  \
    \      }\n    }\n    return [$res,1];\n}", "    my $i = 0;\n    my @chars = ();\n\
    \    my @result = '';\n    for(my $index = 0; $index <= $#$s; $index++){\n   \
    \     my $char = $s->[$index];\n        if($char eq $c) {\n            push(@chars,\
    \ $char);\n        }\n    }\n    while(@chars > 0) {\n        my $index = pop(@chars);\n\
    \        if($index == $#$s) {\n            $result .= $s->[$index];\n        }\n\
    \    }\n    push(@result, $result) if $result ne '';\n    return [@result];\n\
    }\n</code>\n<|/ a tags=string,perl,reverse,string,algorithm dscore=1 |>\n<| c\
    \ |>\nThe second return from reverse should be \"\"\n<|/ c |>\n<| c |>\nOops.\
    \ Fixed it.\n<|/ c |>\n<| c |>\nWhat if the string is \"ab\" and the character\
    \ is a substring of another? For example \"ab\" could be \"abab\"\n<|/ c |>\n\
    <| c |>\nFixed it again. I made a mistake with my code. I was using the index\
    \ of the string instead of its value.\n<|/ c |>\n<| c |>\n`reverse_delete(\"ab\"\
    , \"ba\")` results in `[\"ab\"]`, not `[\"ab\", \"\"]`.\n<|/ c |>\n<| a dscore=1\
    \ |>\nMy solution is in C#:\n<code>\npublic static List<string> ReverseDelete(string\
    \ s, string c)\n{\n    List<string> result = new List<string>();\n    int index\
    \ = s.IndexOf(c);\n    while (index != -1)\n    {\n        result.Add(s.Substring(0,\
    \ index + 1));\n        index = s.IndexOf(c, index + 1);\n    }", '    my @result
    = ();', "    my;\n    my $cnt = 0;\n    for my $char (split(//, $s)) {\n     \
    \   if ($char eq $c) {\n            $cnt += 1;\n        }\n        else {\n  \
    \          push, \"$char\" if $cnt;\n            $cnt = 0;\n        }\n    }\n\
    \    return [$s, $cnt];\n}", "    my @result = ();\n    for (my $i = 0 ; $i <\
    \ length($s) ; $i++) {\n        if ($s[$i] eq $c) {\n            push(@result,\
    \ $s[$i]);\n            push(@result, \"\");\n        }\n        else {\n    \
    \        push(@result, $s[$i]);\n        }\n    }\n    if (@result > 1) {\n  \
    \      $result[-1] = \"\";\n    }\n    return @result;\n}", "    if ( length($s)\
    \ == 0 ) {\n        return ( \"\", 1 );\n    }", "    $s =~ tr/$1//;\n    my @re\
    \ = ();\n    my $result = 0;\n    for (my $i=0; $i<length $s; $i++) {\n      \
    \  my $c = substr($s, $i, 1);\n        if ($c eq $c) {\n            $result++;\n\
    \        }\n        else {\n            push @re, $c;\n        }\n    }\n    push\
    \ @re, $result ? $c : \"\";\n    return \\@re;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
