name: HumanEval_153_Strongest_Extension
language: pl
prompt: "# You will be given the name of a class (a string) and an array of extensions.\n\
  # The extensions are to be used to load additional classes to the class. The\n#\
  \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  # letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n# in the extension's name, the strength is given by the fraction CAP - SM. \n\
  # You should find the strongest extension and return a string in this \n# format:\
  \ ClassName.StrongestExtensionName.\n# If there are two or more extensions with\
  \ the same strength, you should\n# choose the one that comes first in the array.\n\
  # For example, if you are given \"Slices\" as the class and an array of the\n# extensions:\
  \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n# return 'Slices.SErviNGSliCes'\
  \ since 'SErviNGSliCes' is the strongest extension \n# (its strength is -1).\n#\
  \ Example:\n# >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\
  # \"my_class.AA\"\nsub Strongest_Extension {\n    my($class_name, $extensions) =\
  \ @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&Strongest_Extension;\n\
  \        if(eq_deeply($candidate->(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"\
  ]),\"Watashi.eIGHt8OKe\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->(\"Boku123\", [\"nani\", \"NazeDa\",\
  \ \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"__YESIMHERE\"\
  , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"\
  __YESIMHERE.NuLl__\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"\
  cosSo\"]),\"K.TAR\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->(\"__HAHA\", [\"Tab\", \"123\", \"781345\"\
  , \"-_-\"]),\"__HAHA.123\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"YameRore\", [\"HhAas\", \"okIWILL123\"\
  , \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"finNNalLLly\"\
  , [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  _\", [\"Bb\", \"91245\"]),\"_.Bb\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"Sp\", [\"671235\", \"Bb\"]),\"\
  Sp.671235\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my $best_score = -1;\n    my $best_class = $class_name;\n    my\
    \ $best_ext;\n    \n    for my $ext (@$extensions) {\n        my $score = Strongest_Extension_Score($ext,\
    \ $class_name);\n        if ($score > $best_score) {\n            $best_ext =\
    \ $ext;\n            $best_score = $score;\n            $best_class = $class_name;\n\
    \        }\n        if ($score == $best_score) {\n            $best_class = $class_name\
    \ . \".\" . $ext;\n        }\n    }", "    my %strength = map { uc $_ => 1 } split\
    \ //, uc($class_name);\n    my @strongest = sort { $strength{$a} <=> $strength{$b}\
    \ } keys %strength;\n    return $class_name . \".\" . shift @strongest;\n}", " \
    \   my $num_uppercase = 0;\n    my $num_lowercase = 0;\n    my $total_uppercase\
    \ = 0;\n    my $total_lowercase = 0;\n    my $total_strength = 0;\n    foreach\
    \ my $extension (@$extensions) {\n        my $length = length($extension);\n \
    \       foreach my $letter (split //, $extension) {\n            $num_uppercase\
    \ += 1 if $letter =~ /[A-Z]/;\n            $num_lowercase += 1 if $letter =~ /[a-z]/;\n\
    \        }\n        $total_uppercase += $num_uppercase;\n        $total_lowercase\
    \ += $num_lowercase;\n        $total_strength += ($length - $num_uppercase - $num_lowercase);\n\
    \    }\n    return $class_name if $total_strength == 0;\n    return $class_name.\"\
    .\".$extensions[0];\n}", "    $class_name =~ tr/A-Z//cd;\n    $class_name =~ tr/a-z//cd;\n\
    \    my $max = -1;\n    my @extension_str = ();\n    foreach my $ext (@$extensions)\
    \ {\n        $ext =~ tr/A-Z//cd;\n        $ext =~ tr/a-z//cd;\n        my $tmp_cnt\
    \ = 0;\n        foreach my $char (split(//, $ext)) {\n            $tmp_cnt +=\
    \ ($char eq $char);\n        }\n        $tmp_cnt += ($tmp_cnt > $max) ? $tmp_cnt\
    \ : $max;\n        $extension_str[$tmp_cnt] = $ext;\n        $max = $tmp_cnt;\n\
    \    }\n    my $strength = 0;\n    my $tmp = $class_name;\n    foreach my $char\
    \ (split(//, $tmp)) {\n        $strength += ($char eq $char) ? 1 : 0;\n    }\n\
    \    my $res = $class_name;\n    $strength -= $max;\n    foreach my $tmp_cnt (0\
    \ .. $max - 1) {\n        $res .= \"$extension_str[$tmp_cnt]\";\n    }\n    return\
    \ $res;\n}", "    my($strength) = -1;\n    my(@sorted_extensions);\n    for ($i=0;\
    \ $i <; $i++) {\n        if (length($extensions[$i]) > 0) {\n            my($cap_letters)\
    \ = $extensions[$i] =~ /[A-Z]/;\n            my($sm_letters) = $extensions[$i]\
    \ =~ /[a-z]/;\n            $strength = ($cap_letters - $sm_letters);\n       \
    \     if ($strength == 0) {\n                next;\n            }\n        }\n\
    \        push(@sorted_extensions, $extensions[$i]);\n    }\n    \n    if ($strength\
    \ < 0) {\n        $strength = 0;\n    }\n    my $strongest = pop(@sorted_extensions);\n\
    \    return $class_name . \".\" . $strongest;\n}", "    $class_name =~ s/\\W/\\\
    ./g;\n    $class_name .= \".\";\n    $class_name .= $extensions[0];\n    $class_name\
    \ .= \".\";\n    $class_name .= $extensions[$#{$extensions}];\n    return $class_name;\n\
    }", "    \n    my @sorted_extensions;\n    \n    for (my $i = 0; $i < scalar(@$extensions);\
    \ $i++) {\n        my $ext = $extensions[$i];\n        \n        my $strongest\
    \ = 0;\n        $strongest = 1 if $ext->[0] eq $ext->[$strongest];\n        $strongest\
    \ = 2 if $ext->[0] eq $ext->[$strongest + 1];\n        $strongest = 3 if $ext->[0]\
    \ eq $ext->[$strongest + 2];\n        \n        push(@sorted_extensions, $strongest);\n\
    \    }\n    \n    return $class_name.$sorted_extensions[scalar(@sorted_extensions)-1];\n\
    }", "    my($strongest, $count, $last_count, $last_name) = (0, 0);\n    my(@names)\
    \ = ();\n    foreach $extension (@$extensions) {\n        my $c = length($extension);\n\
    \        foreach $name (split(//, $extension)) {\n            if ($last_count\
    \ != -1 && $last_name != $name) {\n                push (@names, $last_name.$last_count);\n\
    \            }\n            if ($last_count != -1 && $last_count == $c && $last_name\
    \ != $name) {\n                push (@names, $last_name.$last_count);\n      \
    \      }\n            $last_count = $c;\n            $last_name = $name;\n   \
    \     }\n    }\n    $last_name =~ s/(.)\\1*/$1/g;\n    push (@names, $last_name.0);\n\
    \    my $len = scalar(@names);\n    if ($len > 1) {\n        my $min = max 0;\n\
    \        foreach my $i (0 .. $len-1) {\n            if ($names[$i] < $min) {\n\
    \                $min = $names[$i];\n            }\n        }\n        foreach\
    \ my $i (0 .. $len-1) {\n            if ($names[$i] <= $min) {\n             \
    \   return $class_name.\".\". substr($names[$i], 1, ($names[$i] - $min));\n  \
    \          }\n        }\n    }\n    else {\n        return $class_name.\".\".\
    \ substr($names[0], 1, 1);\n    }\n}", "    my %sorted_extensions;\n    foreach\
    \ my $extension (@$extensions) {\n        my $class_name_components = split( //,\
    \ $class_name );\n        my $component_count = 0;\n        foreach my $component\
    \ ( split( //, $extension ) ) {\n            if ( $component eq $class_name_components[-1]\
    \ ) {\n                $component_count++;\n            }\n        }\n       \
    \ $sorted_extensions{$component_count} = $extension;\n    }\n    my $strongest_component\
    \ = 0;\n    my $strongest_component_index = 0;\n    foreach my $component_count\
    \ ( sort { $a <=> $b } keys %sorted_extensions ) {\n        my $strongest_extension\
    \ = $sorted_extensions{$component_count};\n        last if $strongest_component_index\
    \ != $component_count or $strongest_component_index == 0;\n        my $str_class_name\
    \ = \"\";\n        for ( $strongest_component_index; $strongest_component_index\
    \ >= $component_count; $strongest_component_index-- ) {\n            $str_class_name\
    \ .= substr( $class_name, 0, $strongest_component_index + 1 );\n        }\n  \
    \      return $str_class_name . $strongest_extension;\n    }\n}", "    my @extensions_by_strength\
    \ = ();\n    my $num_extensions = 0;\n    foreach my $extension (@$extensions)\
    \ {\n        if (index($extension, '_') != -1) {\n            my $name = substr($extension,\
    \ 0, index($extension, '_'));\n            my $extension_class = $class_name->_load_extension($name);\n\
    \            my $extension_strength = $extension_class->_get_extension_strength($name);\n\
    \            $extensions_by_strength[$extension_strength] =\n                $extension_class;\n\
    \            $num_extensions += 1;\n        }\n    }\n    $num_extensions = $num_extensions\
    \ > 1 ? 1 : 0;\n    my $max_strength = -1;\n    foreach my $strength (sort {$a\
    \ <=> $b} keys %$extensions_by_strength) {\n        if ($strength > $max_strength)\
    \ {\n            $max_strength = $strength;\n        }\n    }\n    return $class_name->_load_extension($extensions_by_strength[$max_strength]);\n\
    }", "    my($i, $j, @extensions);\n    \n    foreach $extension (@extensions)\
    \ {\n        $extension =~ tr/A-Z/a-z/;\n        $extension =~ tr/a-z/A-Z/;\n\
    \        $i += length($extension);\n        $j += length($class_name);\n    }\n\
    \    \n    $j -= $i;\n    $i -= 1;\n    \n    foreach $extension (@extensions)\
    \ {\n        $extension =~ tr/A-Z/a-z/;\n        $extension =~ tr/a-z/A-Z/;\n\
    \        $j -= length($extension);\n    }\n    \n    my $strength = length($class_name)\
    \ - length($extensions);\n    return \"$class_name.$extensions[$i]\" if ($strength\
    \ == 0);\n    \n    foreach $extension (@extensions) {\n        $extension =~\
    \ tr/A-Z/a-z/;\n        $extension =~ tr/a-z/A-Z/;\n        if (length($extension)\
    \ == $strength) {\n            return \"$class_name.$extensions[$i]\";\n     \
    \   }\n    }\n    \n    return undef;\n}", "    my $max_strength;\n    my $min_strength;\n\
    \    foreach my $extension (@$extensions) {\n        my $strength = &get_class_extension_strength($class_name,\
    \ $extension);\n        if($strength > $max_strength) {\n            $max_strength\
    \ = $strength;\n        }\n        if($strength < $min_strength) {\n         \
    \   $min_strength = $strength;\n        }\n    }\n    my $strongest_extension\
    \ = \"$class_name.$extensions[0]\";\n    if($max_strength >= 0) {\n        my\
    \ @sorted_extensions = sort {$a <=> $b} \n        &get_class_extensions($class_name);\n\
    \        foreach my $extension (@sorted_extensions) {\n            my $extension_strength\
    \ = &get_class_extension_strength($class_name, $extension);\n            if($extension_strength\
    \ >= 0) {\n                if($extension_strength == $max_strength) {\n      \
    \              $strongest_extension = \"$class_name.$extension\";\n          \
    \          last;\n                }\n            } elsif ($extension_strength\
    \ == $max_strength - 1) {\n                $strongest_extension = \"$class_name.$extension\"\
    ;\n                last;\n            }\n        }\n    }\n    return $strongest_extension;\n\
    }", "    my @extensions_sorted = sort { $a <=> $b };\n    my $strongest_extension\
    \ = $extensions_sorted[-1];\n    $strongest_extension =~ s/[A-Z]//;\n    $strongest_extension\
    \ =~ s/[a-z]//;\n    my $strength = $strongest_extension - $extensions[0] \n\t\
    - $extensions_sorted[0]; \n    return $class_name . $extensions[0] . '.' . $strongest_extension;\n\
    }", "    my @extensions = @$extensions;\n    my $max_strength = 0;\n    my $strongest_extension;\n\
    \    my $class_name_length = length($class_name);\n    for (my $i = 0; $i < scalar(@extensions);\
    \ $i++) {\n        my $extension = $extensions[$i];\n        my $extension_length\
    \ = length($extension);\n        my $strongest_extension_length = length($strongest_extension);\n\
    \        my $strength = $extension_length - $strongest_extension_length;\n   \
    \     if ($strength > $max_strength) {\n            $max_strength = $strength;\n\
    \            $strongest_extension = $extension;\n        }\n    }\n    $strongest_extension\
    \ eq '' ? ($strongest_extension = ucfirst($class_name_length)) : $strongest_extension;\n\
    }", "    $class_name =~ s/^([A-Z][a-z]+)//;\n    my @class_parts = split(//, $class_name);\n\
    \    my $result = $class_parts[0];\n    my $extension = pop(@class_parts);\n \
    \   foreach my $ext (@$extensions) {\n        $ext =~ s/^([A-Z][a-z]+)//;\n  \
    \      my $strength = length($extension) - length($_);\n        if ($strength\
    \ > 0) {\n            if ($strength < $best_strongest_ext) {\n               \
    \ $result = $class_parts[0] . $ext;\n                $best_strongest_ext = $strength;\n\
    \            }\n        }\n    }\n    $result;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby,string\
    \ |>\nThis should do it:\n<code>\ndef strongest(str,extensions)\n  p extensions.inject(str){\
    \ |t,e| t =~ /#{e}/ ? t : t + e.upcase }.downcase\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe method `String#inject` is new in Ruby 2.0.  Please consider\
    \ updating your solution to work without that method.\n<|/ c |>\n<| c |>\nPlease\
    \ don't use backticks in your answers. Also, how would you deal with extensions\
    \ with more than one uppercase letter?\n<|/ c |>\n<| a |>\nHere is another solution\
    \ for Ruby 1.9.2\n<code>\ndef strongest(str,extensions)\n    p extensions.inject(str){\
    \ |t,e| t =~ /#{e}/ ? t : t + e.upcase }.downcase\nend\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,ruby,string |>\n<| a |>\nHere is my solution. I used a regex\
    \ to match any extension from extensions array in the string. \n<code>\ndef strongest(str,extensions)\n\
    \  extensions = extensions.map{|ext| Regexp.new(ext)}.to_set\n  extensions.inject(str){\
    \ |result,ext|\n    str =~ ext\n    result || (str + ext.upcase)\n  }.downcase\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,string dscore=0 |>\n<| a tags=algorithm,ruby,string\
    \ |>\n<code>\ndef strongest(str, extensions)\n  extensions.each { |ext| ext =\
    \ \".*#{ext}.*\" unless ext =~ /#{ext}/ }\n  str.gsub(/(.).*(.)/).first.gsub(/",
  "    my $strength = -1;\n    foreach my $ext (@$extensions) {\n        $strength\
    \ += uc($ext) eq $ext ? uc($class_name)-length($ext) : \n                    \
    \      uc($ext) eq $ext ? uc($class_name)-length($ext) : \n                  \
    \        0;\n    }\n    return $class_name . $extensions[0] if $strength == 0;\n\
    \    my @arr = grep { $strength >= $_ } (0..$#extensions);\n    return $class_name\
    \ . $arr[0] if scalar @arr == 1;\n    my @arr = @arr;\n    shift @arr;\n    $class_name\
    \ . $arr[0];\n}", "    my($number_of_uppercase_letters, $number_of_lowercase_letters);\n\
    \    my($extension_strength);\n    my(@extensions_sorted);", "    my $strongest\
    \ = $extensions[0];\n    my $strongest_index = 0;\n    my $index = -1;", "   \
    \ my($class_name_length);\n    my($extension_length);\n    my($strongest_extension);\n\
    \    my($extension);", "    \n    foreach my $extension(@{$extensions}) {\n  \
    \      my $extension_class = substr($extension, 0, 1);\n        $extension_class\
    \ =~ tr/A-Z/a-z/;\n        my $extension_class_size = length($extension_class);\n\
    \        $extension_class_size += length($extension) - 1;\n        my $extension_class_strength\
    \ = substr($extension_class, 1, $extension_class_size);\n        if ($extension_class_strength\
    \ > 0) {\n            my $strength_of_extension = \n                 $extension_class_strength\
    \ + \n                 $extension_class_size*length($extension) - \n         \
    \        length($class_name)*length($extension) - \n                 length($class_name)*length($extension)\
    \ - \n                 length($class_name)*length($extension);\n            return\
    \ $class_name.substr($extension, 0, 1).$extension_class.substr($extension, $strength_of_extension);\n\
    \        }\n    }\n    return;\n}", "    # Write your code here.\n}\n</cell>\n\
    <cell>", "    my @extensions_sorted = sort {$a <=> $b};\n    my ($strongest_extension)\
    \ = @extensions_sorted;\n    return \"$class_name.$strongest_extension\" if $strongest_extension;\n\
    \    $strongest_extension = $extensions_sorted[0];\n    return \"$class_name.$strongest_extension\"\
    \ if $strongest_extension;\n    return;\n}", "    my $max_strength;\n    foreach\
    \ my $extension (@$extensions) {\n        if ($extension !~ /^[A-Z]/) {\n    \
    \        if ($extension !~ /^[a-z]/) {\n                \n            } else {\n\
    \                if (length($extension) > length($class_name)){\n            \
    \        \n                }\n                else {\n                    if ($class_name\
    \ !~ /[a-z]/ || length($extension) > length($class_name)){\n                 \
    \       \n                    } else {\n                        my $strength =\
    \ substr($extension, -1, 1);\n                        $max_strength = $strength\
    \ if $strength > $max_strength;\n                    }\n                }\n  \
    \          }\n        } else {\n            if ($class_name !~ /[A-Z]/ || length($extension)\
    \ > length($class_name)){\n                \n            } else {\n          \
    \      if ($extension !~ /[a-z]/ || length($extension) > length($class_name)){\n\
    \                    \n                } else {\n                    my $strength\
    \ = substr($extension, -1, 1);\n                    $max_strength = $strength\
    \ if $strength > $max_strength;\n                }\n            }\n        }\n\
    \    }\n    return $class_name . $max_strength;\n}", "    my @extensions_arr =\
    \ ();\n    foreach my $extension (@$extensions) {\n        my $c = substr($extension,\
    \ 0, 1);\n        my $l = substr($extension, 1, 1);\n        my $strength = ($c\
    \ - $l);\n        push(@extensions_arr, $extension) if ($strength > 0);\n    }\n\
    \    my $strength = -1;\n    foreach my $extension (@extensions_arr) {\n     \
    \   $strength = -1 if ($strength < 0 || $strength > $extension);\n    }\n    \n\
    \    return \"$class_name.$extensions_arr[0]\" if ($strength > 0);\n    \n   \
    \ return \"$class_name\" unless (@extensions_arr);\n    \n    # $strength should\
    \ be either -1, 0 or 1 \n    foreach my $extension (@extensions_arr) {\n     \
    \   $strength = -1 if ($strength < 0 || $strength > $extension);\n    }\n    \n\
    \    return \"$class_name.$extensions_arr[0]\" if ($strength == -1);\n    \n \
    \   return \"$class_name\" unless (@extensions_arr);\n    \n    return \"$class_name.\"\
    \ . \"$extensions_arr[0]\";\n}", "    my($best_extension, $best_strength) = (0,\
    \ 0);\n    my($i, $length);\n    my($ext, $ext1, $ext2);\n    for ($i = 0; $i\
    \ < @{$extensions}; $i++) {\n        $ext = &$extensions[$i];\n        $ext1 =\
    \ &$extensions[$i % @{$extensions}];\n        $ext2 = &$extensions[$i % @{$extensions}];\n\
    \        $length = length($class_name.$ext) - length($class_name.$ext1);\n   \
    \     $strength = $length / length($class_name.$ext1);\n        if ($strength\
    \ > $best_strength) {\n            $best_extension = $ext;\n            $best_strength\
    \ = $strength;\n        }\n    }\n    return $class_name.$best_extension;\n}",
  '    $class_name =~ s/[^A-Z]*//g;', "    my @extensions = @$extensions;\n    my\
    \ $total_extensions = scalar(@extensions);\n    my $total_caps = scalar($class_name\
    \ =~ /[A-Z]/) - scalar($class_name =~ /[a-z]/);\n    my $total_sms = scalar($class_name\
    \ =~ /[a-z]/) - scalar($class_name =~ /[A-Z]/);\n    my $strongest = -1;\n   \
    \ for my $i(0 .. $total_extensions-1) {\n        if ($extensions[$i] =~ /^([A-Z])(\\\
    d+)([a-z])(\\d+)$/) {\n            my $caps = $3;\n            my $sms = $4;\n\
    \            if ($sms < $strongest) {\n                $strongest = $sms;\n  \
    \          }\n            elsif ($sms == $strongest && $caps - $sms > $strongest)\
    \ {\n                $strongest = $caps;\n            }\n        }\n    }\n  \
    \  $class_name .= \".\" . $extensions[$strongest];\n    if ($total_extensions\
    \ > 1) {\n        foreach my $i(0 .. $total_extensions-1) {\n            $class_name\
    \ .= \"..$extensions[$i]\";\n        }\n    }\n    return $class_name;\n}", " \
    \   my $strength = 0;\n    for my $extension (@$extensions) {\n        $strength\
    \ += uc($extension) eq uc($class_name) ? 1 : 0;\n    }\n    $strength //= @$extensions;\n\
    \    return \"$class_name.$extensions[$strength]\";\n}", "    my $max_extension\
    \ = 0;\n    my $max_extension_strength = 0;\n    my $strength = 0;\n    foreach\
    \ my $extension (@$extensions) {\n        my $extension_stength = (split(//, $extension))[5];\n\
    \        if ($extension_stength > $max_extension_strength) {\n            $max_extension_strength\
    \ = $extension_stength;\n            $max_extension = $extension;\n        }\n\
    \    }\n    if ($max_extension_strength == 0) {\n        $max_extension = $extensions[0];\n\
    \        $max_extension_strength = -1;\n    }\n    my $class_stength = substr($class_name,\
    \ 0, length($class_name) - length($max_extension));\n    if ($class_stength >\
    \ $max_extension_strength) {\n        $max_extension_strength = $class_stength;\n\
    \        $max_extension = $class_name;\n    }\n    $class_name =~ s/$max_extension//;\n\
    \    return \"$class_name.$max_extension\";\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThanks for your reply! Unfortunately I'm not allowed to use any modules.\
    \ Is there a way to do it without using modules?\n<|/ c |>\n<| c |>\nYeah, you\
    \ can do it without modules. I've added the code above. Just copy-paste it into\
    \ a file and save it as 'solution.pl' and run it using perl solution.pl\n<|/ c\
    \ |>\n<| a dscore=2 tags=string,algorithm,perl |>\nThe first thing that came to\
    \ mind was a greedy algorithm. Something like:\n<code>\nmy $string = \"abc\";\n\
    my $extension = \"def\";\nmy $pos = 0;", "    my $count = 0;\n    my %extension_map\
    \ = ();\n    foreach my $e (@$extensions) {\n        if ($extension_map{$e}) {\n\
    \            ++$extension_map{$e};\n        }\n        else {\n            $extension_map{$e}\
    \ = 1;\n        }\n        ++$count;\n    }\n    \n    my $strength = -1;\n  \
    \  my @strongest = ();\n    my $first_extension = $extensions[0];\n    foreach\
    \ my $e (@$extensions) {\n        if ($extension_map{$e} > $strength) {\n    \
    \        $strength = $extension_map{$e};\n        }\n        if ($extension_map{$e}\
    \ == $strength) {\n            push @strongest, $e;\n        }\n    }\n    return\
    \ $class_name.\".\".$first_extension.\".\".@strongest;\n}", "    $extensions =\
    \ ($extensions) unless ref($extensions);\n    $extensions = [@$extensions];\n\
    \    $class = $class_name;\n    $class = substr($class, rindex($class, '.') +\
    \ 1);\n    foreach my $ext (@$extensions) {\n        chomp($ext);\n        if\
    \ ($ext =~ /^(\\d+)(.*)$/) {\n            my $C = ($1 < $CAP) ? $1 : $CAP;\n \
    \           my $S = $2;\n            $ext =~ s/\\Q$CAP\\E//g;\n            $ext\
    \ =~ s/\\Q$SM\\E/$C-$S/g;\n            $ext =~ s/^([A-Z]+)(.*)/$1.$2/g;\n    \
    \        my ($class2, $ext2) = split(/\\./, $ext);\n            $class = $class2\
    \ unless $class2 eq $class;\n            if ($ext2 =~ /^(\\d+)(.*)$/) {\n    \
    \            my $C = ($2 < $CAP) ? $2 : $CAP;\n                my $S = $2;\n \
    \               $ext2 =~ s/\\Q$CAP\\E//g;\n                $ext2 =~ s/\\Q$SM\\\
    E/$C-$S/g;\n                $ext2 =~ s/^([A-Z]+)(.*)/$1.$2/g;\n              \
    \  if ($ext eq $ext2) {\n                    return \"$class.$ext2\";\n      \
    \          }\n            }\n        }\n    }\n    return \"$class.\" . $extensions[0];\n\
    }", "    my $count = 0;\n    my $best_extension = \"\";\n    foreach my $extension\
    \ (@$extensions) {\n        $extension =~ tr/A-Z/a-z/;\n        $extension =~\
    \ tr/a-z/A-Z/;\n        if ($extension =~ /[A-Z]/) {\n            $count++;\n\
    \        } elsif ($extension =~ /[a-z]/) {\n            $count += 2;\n       \
    \ } elsif ($extension =~ /[0-9]/) {\n            $count += 3;\n        }\n   \
    \     if ($count > $best_extension) {\n            $best_extension = $extension;\n\
    \        }\n    }\n    $best_extension =~ s/[^A-Za-z0-9_]//g;\n    return \"$class_name.$best_extension\"\
    ;\n}", "    my $extension_length = scalar @$extensions;\n    my $strength = -1;\n\
    \    for(my $i = 0; $i < $extension_length; $i++) {\n        my $name = $extensions[$i];\n\
    \        $name =~ s/^[^A-Z]//;\n        $name =~ s/[^a-z]/_/g;\n        $name\
    \ =~ s/_{2,}/_/g;\n        $name =~ s/_+/-/g;\n        $strength += ($name =~\
    \ tr/[A-Z]/-/);\n    }\n    return \"$class_name.$extensions[$extension_length-1]\"\
    \ if $strength > 0;\n    return $class_name.$extensions[0];\n}\n</code>\n<|/ a\
    \ tags=perl,string-concatenation,algorithm,string |>\n<| c |>\nThat's a neat solution!\
    \ But I wouldn't advise it because of the way it returns the second extension,\
    \ if there's more than one with the strongest extension's name.\n<|/ c |>\n<|\
    \ c |>\nI've added a second method which fixes that. Thanks!\n<|/ c |>\n<| c |>\n\
    This doesn't do what you want it to. `foobaz.AB` is translated into `foobaz_AB`,\
    \ not `foobaz.ABz`.\n<|/ c |>\n<| c |>\n: you're right, I made a mistake, thanks!\
    \ I've corrected it.\n<|/ c |>\n<| a tags=perl,string-concatenation,algorithm,string\
    \ |>\nThis code will do the job. It uses the same regular expression that Konrad\
    \ mentioned, but instead of replacing one character with another, it replaces\
    \ all occurrences of one character with itself.\n<code>\nuse strict;\nuse warnings;\n\
    use Data::Dumper;", "    my %hash = ();\n    my $length = length($class_name);\n\
    \    foreach my $x (@$extensions) {\n        $x =~ tr/A-Z/A-ZA-Z/;\n        $x\
    \ =~ tr/a-z/A-Za-z/;\n        my $xx = $x;\n        $xx =~ tr/A-Za-z/A-Z/;\n \
    \       my $count = length($xx);\n        $hash{$count} = $x;\n    }\n    my $max_count\
    \ = -1;\n    my @sorted_keys = sort { $a <=> $b } keys %hash;\n    foreach my\
    \ $x (@sorted_keys) {\n        $max_count = $x if $hash{$x} eq $class_name;\n\
    \    }\n    return \"$class_name.$max_count\" if $max_count >= 0;\n    return\
    \ $class_name if $max_count < 0;\n    return;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the solution.  I didn't really know where to start with this problem,\
    \ but I will keep your suggestions in mind.  I am still struggling to figure out\
    \ how to get this to work, but I will keep trying.  Thanks again!\n<|/ c |>\n\
    <| a tags=algorithm,string |>\n<code>\ndef longest_extension(strings, letters):\n\
    \    longest_len = 0\n    longest = \"\"\n    i = 0\n    while i < len(strings):\n\
    \        j = -1\n        while j < len(strings[i]) - 1:\n            if strings[i][j]\
    \ + 1 in letters:\n                i += strings[i][j]\n                strings[i]\
    \ = strings[i][j:]\n                j = -1\n            else:\n              \
    \  j += 1\n        i += 1\n        if len(strings[i]) > longest_len:\n       \
    \     longest = strings[i]\n            longest_len = len(strings[i])\n    return\
    \ longest\n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease explain your code so people\
    \ can learn from it\n<|/ c |>\n<| c |>\nI guess you forgot to define letters?\n\
    <|/ c |>\n<| c |>\nThe idea behind this is to iterate through the string until\
    \ we reach a character that does not appear in letters. Then we skip that many\
    \ characters and move onto next character. We repeat until all strings are iterated.\n\
    <|/ c |>\n<| c |>\nSorry for my lack of explanation, but I thought the algorithm\
    \ would be self explanatory. I added a paragraph at the top that explains the\
    \ algorithm.\n<|/ c |>\n<| a |>\nI wanted to post this because there wasn't a\
    \ solution that I could find anywhere.\nI ended up with some brute-force algorithm ",
  "    my %class_hash;\n    foreach my $extension (@$extensions) {\n        my ($class_name,\
    \ $str) = split '\\.', $extension;\n        my @class_names = ();\n        if\
    \ (exists $class_hash{$class_name}) {\n            @class_names = @{$class_hash{$class_name}};\n\
    \        }\n        else {\n            foreach my $name (@{ $class->{STRONGEST_EXTENSIONS}\
    \ }) {\n                @class_names = @{ $class->{STRONGEST_EXTENSIONS}[$name]\
    \ };\n            }\n        }\n        my $strongest_name = @class_names ? \n\
    \            grep(/^$class_name$/, @class_names) : \n            $class_name;\n\
    \        $class_hash{$class_name} = \n            [grep { $_ ne $strongest_name\
    \ }\n                @class_names];\n    }\n    my $strongest_extension = $class_hash{$class_name}[0];\n\
    \    return $class_name . '.' . $strongest_extension;\n}", '    my($i, $j, $strongest_extension_class,
    $strongest_extension_str) = (0, 0, "", $"");', "    my $strongest = 0;\n    my\
    \ $index = 0;\n    foreach my $extension (@$extensions) {\n        my($cap, $sm)\
    \ = split /[^A-Z]/, $extension;\n        my $frac = $cap - $sm;\n        if($frac\
    \ > $strongest) {\n            $strongest = $frac;\n            $index = $extension;\n\
    \        }\n    }\n    return $class_name.$index;\n}", "    my @extensions;\n\
    \    my $extension;\n    my $length = $extensions->[0];\n    my $strength;", " \
    \   my %hash;\n    my @sorted_extensions = sort {$hash{$a} <=> $hash{$b}} @$extensions;\n\
    \    $hash{$sorted_extensions[0]} = -1;\n    foreach my $extension(@sorted_extensions)\
    \ {\n        $hash{$extension} += 1;\n    }\n    my $strongest = $class_name .\
    \ '.' . \n        join '.', map {substr($_, length($_) - length($class_name))}\
    \ \n        keys %hash;\n    $strongest .= '.' . @sorted_extensions[$#sorted_extensions];\n\
    \    return $strongest;\n}", "    my $strongest_extension = 0;\n    my $i = 0;\n\
    \    while($i < @$extensions) {\n        if($extensions[$i] =~ m/[A-z]/) {\n \
    \           my $j = $i;\n            while($j < @$extensions) {\n            \
    \    if($extensions[$j] =~ m/[A-Z]/) {\n                    my $cap = length($extensions[$j]);\n\
    \                    my $sm = length($extensions[$i]);\n                    my\
    \ $strength = ($cap - $sm) / $cap;\n                    if($strength > $strongest_extension)\
    \ {\n                        $strongest_extension = $strength;\n             \
    \       }\n                }\n                $j++;\n            }\n        }\n\
    \        $i++;\n    }\n    return $class_name . \".\" . @$extensions[$i];\n}\n\
    </code>\n<|/ a tags=perl |>\n<| c |>\nThe question said the class name was 'Slices',\
    \ not 'slices.' So this answer doesn't really work.\n<|/ c |>\n<| c |>\nI did\
    \ not test the code. There were two errors I found immediately. One was that he\
    \ used a regex to test the lowercase letters in a string and one was that he wrote\
    \ the string as lowercase but tried to compare it to uppercase letters.\n<|/ c\
    \ |>\n<| c |>\nIt looks like you've forgotten a closing parenthesis in the final\
    \ `if` statement, but other than that, this worked great.\n<|/ c |>\n<| c |>\n\
    It seems that if there are two extensions with the same strength, you should choose\
    \ the one that comes first in the array.\n<|/ c |>\n<| c |>\nOops, I misread the\
    \ question. Fixed.\n<|/ c |>\n<| a tags=perl |>\nHere are two solutions, one using\
    \ a hash, the other using a sort. The hash version will be much faster than the\
    \ sort version. \n<code>", "    my @sorted_extensions = sort {$a <=> $b} @$extensions;\n\
    \    my $min_strength = -1;\n    my $strongest = shift;", "    my $strongest_extension\
    \ = \"\";\n    my $strength = 0;\n    my %extension_hash;", "    my %extension_hash\
    \ = map {$_ => 1};\n    for my $extension (@$extensions) {\n        $extension_hash{$extension}\
    \ += 1;\n    }\n    my $max_strength;\n    my $max_extension;\n    $max_strength\
    \ = 0;\n    for my $extension (keys %extension_hash) {\n        if ($extension_hash{$extension}\
    \ > $max_strength) {\n            $max_strength = $extension_hash{$extension};\n\
    \            $max_extension = $extension;\n        }\n    }\n    return \"$class_name.$max_extension\"\
    ;\n}", "    my $total = 0;\n    my $max = 0;\n    foreach (@$extensions) {\n \
    \       if ($_ eq lc $class_name) {\n            $max = $_;\n        } elsif ($_\
    \ eq lc $class_name . lc $max) {\n            $total = $total + 1;\n        }\
    \ elsif ($_ eq lc $class_name . lc $max . lc $total) {\n            $total = $total\
    \ + 1;\n        }\n    }\n    if ($total > 1) {\n        return $class_name .\
    \ \".\" . substr($max, $total - 1, 1);\n    } elsif ($total == 1) {\n        return\
    \ $class_name . \".\" . $max;\n    } else {\n        return \"None\";\n    }\n\
    }", "    my($total_strongest, @strongest_extensions);\n    foreach my $extension\
    \ (@$extensions) {\n        my $current_extension = substr($class_name, 0, -1)\
    \ if $class_name =~ /\\Q$extension\\E/;\n        if ($current_extension != $extension)\
    \ {\n            $total_strongest = -1;\n            last;\n        }\n      \
    \  $total_strongest += length($extension) - length(substr($current_extension,\
    \ length($current_extension) - 1, length($extension)));\n        @strongest_extensions\
    \ = ($current_extension) if $current_extension ne $extension;\n    }\n    return\
    \ \"$class_name.\" . @strongest_extensions if @strongest_extensions;\n    return\
    \ $class_name;\n}\n</code>\n<|/ a |>\n<| c |>\nYou can't simply sort because there\
    \ are multiple permutations of `ABC`. There's no real sense to sort unless there\
    \ is only one permutation of a set of values that can be sorted. For example,\
    \ given `{1, 3, 2}` there's only one permutation, `3->2->1`. Sorting isn't the\
    \ right way to go about this.\n<|/ c |>\n<| a dscore=3 tags=perl |>\nI came up\
    \ with this solution.\n<code>\nuse strict;\nuse warnings;", "    my $max_strength\
    \ = 0;\n    my $extension_count = 0;\n    foreach my $extension (@$extensions)\
    \ {\n        if ($extension =~ /([A-Z])/) {\n            $extension_count++;\n\
    \        } elsif ($extension =~ /([a-z])/) {\n            $extension_count +=\
    \ 2;\n        }\n        $max_strength = 1 if $extension_count > $max_strength;\n\
    \    }\n    my $max_strongest = reverse sort {\n        ($a <=> $b)\n    } grep\
    \ { ($a =~ /[A-Z]/) && ($b =~ /[A-Z]/) && ($a =~ /[a-z]/) && ($b =~ /[a-z]/) &&\
    \ ($a =~ /[0-9]/) && ($b =~ /[0-9]/) && ($a =~ /[^A-Za-z0-9]/) && ($b =~ /[^A-Za-z0-9]/)\
    \ && ($a =~ /[^a-z]/) && ($b =~ /[^a-z]/) && ($a =~ /[^0-9]/) && ($b =~ /[^0-9]/)\
    \ && ($a =~ /[[:space:]]/) && ($b =~ /[[:space:]]/) } @$extensions;\n    if ($max_strongest\
    \ =~ /[A-Z]/) {\n        return $class_name.$max_strongest;\n    } else {\n  \
    \      return \"$class_name.$max_strongest.\";\n    }\n}", '    my @extensions_sorted
    = sort {$a <=> $b} @$extensions;', "    $extensions ||= [];\n    $extensions <<\
    \ $class_name unless grep(/\\b$class_name\\b/i, @$extensions);\n    # Find number\
    \ of upper case letters in class name\n    my($cap) = $class_name =~ tr/[A-Z]/[A-Z]//;\n\
    \    # Find number of lower case letters in class name\n    my($sm) = $class_name\
    \ =~ tr/[a-z]/[a-z]//;\n    # If number of upper case letters is the same as number\
    \ of lower case letters, \n    # just return $class_name\n    if($cap == $sm)\
    \ {\n        return $class_name;\n    }\n    # Calculate extension strength (-1\
    \ for strongest)\n    my $strength = $cap - $sm;\n    # Sort extensions by strength\
    \ descending\n    @$extensions = sort { $a <=> $b } @$extensions;\n    # Return\
    \ the strongest extension\n    my $strongest_extension = $extensions[0];\n   \
    \ $strongest_extension =~ s/^([^.]*)\\.//;\n    return $class_name.$strongest_extension;\n\
    }", "    $class_name =~ s/\\W//g;\n    my $num_chars = length($class_name);\n\
    \    my @chars = split //, $class_name;\n    my $max_strength = -1;\n    my $max_strength_extension\
    \ = \"\";\n    foreach my $char (@chars) {\n        my $char_strength = uc($char)\
    \ - uc($char);\n        if ($char_strength > $max_strength) {\n            $max_strength\
    \ = $char_strength;\n            $max_strength_extension = $char;\n        }\n\
    \    }\n    my @sorted_extensions = sort {$b <=> $a} @extensions;\n    foreach\
    \ my $extension (@sorted_extensions) {\n        my $extension_strength = uc($extension)\
    \ - uc($extension);\n        if ($extension_strength == $max_strength) {\n   \
    \         return $class_name . \".\" . $extension;\n        }\n        if ($extension_strength\
    \ < $max_strength) {\n            return $class_name . \".\" . $extension;\n \
    \       }\n    }\n    return $class_name . \".\" . $max_strength_extension;\n}",
  "    my($best_extension, $best_strength) = (-1, -1);\n    my($extension_char, $extension_str,\
    \ $extension_number) = ('', 0, 0);\n    my(@extensions_lowercase_only, @extensions_upper_only);",
  "    my @extensions = @{$extensions};\n    \n    # Sort the extensions by strength\
    \ (from greatest to least).\n    my @sorted_extensions = sort { $a->{\"strength\"\
    } <=> $b->{\"strength\"} } @extensions;\n    \n    # Return the first extension.\n\
    \    return $sorted_extensions[0]->{\"extension\"};\n}", "    my @extension_classes\
    \ = @$extensions;\n    my $strongest;", "    \n    my($str_ext) = ();\n    foreach\
    \ my $ext (@$extensions) {\n        my($ext_cap, $ext_sm) = lc $ext;\n       \
    \ my $ext_str = $ext_cap - $ext_sm;\n        if ($ext_str == 0) {\n          \
    \  $str_ext .= $ext;\n        } else {\n            push(@$str_ext, $ext);\n \
    \       }\n    }\n    \n    my $max_ext_str = $str_ext->[0];\n    my $max_ext_cap\
    \ = length($str_ext->[0]);\n    foreach my $ext (@$str_ext) {\n        my($ext_cap,\
    \ $ext_sm) = lc $ext;\n        my $ext_str = $ext_cap - $ext_sm;\n        if ($ext_str\
    \ > $max_ext_str) {\n            $max_ext_str = $ext_str;\n            $max_ext_cap\
    \ = length($ext);\n        }\n    }\n    \n    return $class_name.$max_ext_str.$max_ext_cap;\n\
    }\n</code>\n<|/ a tags=regex,perl |>\n<| c |>\n: I added a code example. I hope\
    \ it helps.\n<|/ c |>\n<| a dscore=1 |>\nI believe that your solution is going\
    \ to be pretty difficult to read, especially for someone who doesn't have a clue\
    \ as to what your code is doing.  If you could post a clearer explanation of what\
    \ you're trying to accomplish, that would help to give more specific guidance.\
    \  But I believe that something like this will accomplish what I think you're\
    \ trying to do:\n<code>\nmy $str = \"The quick brown fox jumps over the lazy dog\"\
    ;\nmy $class = \"The\";\nmy = (\n    \"\",\n    \"C\",\n    \"S\",\n    \"A\"\
    ,\n    \"S\",\n    \"C\",\n    \"T\",\n    \"H\",\n    \"E\",\n    \"T\",\n  \
    \  \"E\",\n    \"D\",\n    \"C\",\n    \"T\",\n    \"H\",\n    \"E\",\n    \"\
    R\",\n    \"O\",\n    \"R\",\n    \"E\",\n    \"N\",\n    \"G\",\n    \"S\",\n\
    );", "    my $strongest_extension;\n    my $length = length($class_name);\n  \
    \  my $i;\n    for ($i = 0; $i < $length; $i++) {\n        my $c = substr($class_name,\
    \ $i, 1);\n        if ($c eq uc($c)) {\n            my $count = substr ($class_name,\
    \ ($i + 1), 1);\n            $strongest_extension = $extensions[$i] . substr($class_name,\
    \ 0, $i) . $count;\n            last;\n        }\n    }\n    return $strongest_extension;\n\
    }", '    my($class_name, $extension_count, @extension_array);', "    my @classes\
    \ = ();\n    \n    for my $c (@{$extensions}) {\n        my $index = uc $c;\n\
    \        my $name = $class_name;\n        my $class;\n        \n        for (my\
    \ $i = 0; $i < length($name); $i++) {\n            $class .= substr($name, $i,\
    \ 1);\n            $class = \"{$class}Class\" unless $class =~ /[[:upper:]]/;\n\
    \            $class =~ s/([[:upper:]]+)Class/\\L$1/g;\n            $class = \"\
    MyClass\" unless $class =~ /MyClass/;\n            next unless $class =~ /[[:upper:]]/;\n\
    \            $class =~ s/([[:upper:]]+)Class/\\L$1/g;\n            $class =~ s/[[:upper:]]/\\\
    d/;\n        }", "    my %sorted_extensions = ();\n    foreach my $extension (@$extensions)\
    \ {\n        if ($extension !~ /^[A-Z]/) {\n            warn \"Extensions cannot\
    \ begin with non-capital letters: $extension\\n\";\n        }\n        foreach\
    \ my $c (split '', $extension) {\n            if ($c !~ /^[A-Z]/) {\n        \
    \        warn \"Extensions cannot begin with non-capital letters: $extension\\\
    n\";\n            }\n            $sorted_extensions{$c} = $extension;\n      \
    \  }\n    }\n    foreach my $extension (sort keys %sorted_extensions) {\n    \
    \    my $strength = $sorted_extensions{$extension};\n        if (defined $strength\
    \ && $strength > 0) {\n            $class_name .= \".$extension\";\n        }\n\
    \    }\n    return $class_name;\n}", "    my $n = length($class_name);\n    my\
    \ $max_strength = 0;\n    my $max_extension = '';\n    foreach my $extension (@$extensions)\
    \ {\n        my $l = length($extension);\n        if ($l == $n) {\n          \
    \  my $strength = uc $extension - lc $extension;\n            if ($strength >\
    \ $max_strength) {\n                $max_strength = $strength;\n             \
    \   $max_extension = $extension;\n            }\n        }\n    }\n    return\
    \ $class_name . $max_extension;\n}", "    my @extensions = @$extensions;\n   \
    \ my $max_strengh = 0;\n    my $max_extension = '';\n    foreach my $extension\
    \ (@extensions) {\n        my $strengh = substr($extension, 0, 1) =~ tr/A-Z//;\n\
    \        if ($strengh > $max_strengh) {\n            $max_strengh = $strengh;\n\
    \            $max_extension = $extension;\n        }\n    }\n    return $class_name\
    \ . $max_extension;\n}", '    my($strongest, @strongest) = ();', "    my ($class,\
    \ $extension, $strength);\n    my %classes_to_strength = (\n        \"A\" => 0,\n\
    \        \"B\" => 1,\n        \"C\" => 2,\n        \"D\" => 3,\n        \"E\"\
    \ => 4,\n        \"F\" => 5,\n        \"G\" => 6,\n        \"H\" => 7,\n     \
    \   \"I\" => 8,\n        \"J\" => 9,\n        \"K\" => 10,\n        \"L\" => 11,\n\
    \        \"M\" => 12,\n        \"N\" => 13,\n        \"O\" => 14,\n        \"\
    P\" => 15,\n        \"Q\" => 16,\n        \"R\" => 17,\n        \"S\" => 18,\n\
    \        \"T\" => 19,\n        \"U\" => 20,\n        \"V\" => 21,\n        \"\
    W\" => 22,\n        \"X\" => 23,\n        \"Y\" => 24,\n        \"Z\" => 25,\n\
    \        \"\" => -1,\n    );\n    for ($class = 1; $class <= 26; $class++) {\n\
    \        for ($extension = 1; $extension <= 26; $extension++) {\n            $strength\
    \ = ($classes_to_strength{$class_name} > $classes_to_strength{$extension}) ? $classes_to_strength{$class_name}\
    \ : $classes_to_strength{$extension};\n            if ($strength > 0) {\n    \
    \            return $class_name . \"_\" . lc($extension) . \".\" . $strength;\n\
    \            }\n        }\n    }\n    return $class_name;\n}\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,php |>\n<code>\n<?php\n// this file should include your strongest_extension\
    \ function", "    my %counts;\n    $counts{ lc($_) }++ for\n        grep /[A-Z]/,\
    \ @$extensions;\n    return $class_name if scalar keys %counts == 1;\n    $counts{\
    \ lc($_) }-- for \n        grep /[a-z]/, @$extensions;\n    $class_name.'.'.$extensions[0]\
    \ if scalar keys %counts == 1;\n    $class_name.'_'.$extensions[0] if scalar keys\
    \ %counts == 0;\n    return $class_name;\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nSorry for the late response. I edited the question and added a description\
    \ of the problem and some example data.\n<|/ c |>\n<| c |>\nI believe I have solved\
    \ the problem, but I would appreciate your feedback on any improvements to the\
    \ code.\n<|/ c |>\n<| c |>\n: I added a solution that works for the example you\
    \ gave in your question. I'm not sure if it will work for all your possible inputs.\
    \ It probably will not work for inputs like `Slices.SErviNGSliCes` where there\
    \ is no lowercase letter in the beginning of the class name (and no uppercase\
    \ letter in the beginning of the class name). I'm sure the code could be fixed\
    \ in that regard.\n<|/ c |>\n<| c |>\nThank you very much for the help. Your solution\
    \ works for all cases I've tried.\n<|/ c |>\n<| a |>\nThis is what I would do\
    \ (assuming your input are valid strings)\n<code>\nuse strict;\nuse warnings;",
  '    my $max_strength = -10000;', "    my($strongest);\n    foreach my $ext (@$extensions)\
    \ {\n        my($class_name_components) = split(/\\./, $class_name);\n       \
    \ my($ext_name_components) = split(/\\./, $ext);\n        my($sm, $cap) = ($ext_name_components[0]\
    \ =~ /[A-Z]/, $ext_name_components[0] =~ /[A-Z]/);\n        my($strongest_components)\
    \ = @$class_name_components[0..($sm+1)-1];\n        my($strength) = ($strongest_components\
    \ =~ /[A-Z]/) - $cap;\n        if ($strength > 0) {\n            if ($strongest\
    \ eq \"\") {\n                $strongest = $class_name . $ext;\n            }\
    \ else {\n                my $exts = $strongest . \"_\" . $ext;\n            \
    \    if ($exts =~ /\\.[^\\.]*$/ && $exts =~ /^\\./) {\n                    $strongest\
    \ = $strongest . $ext;\n                }\n            }\n        }\n    }\n \
    \   $strongest;\n}", "    my($class_name, $extension, $strongest_extension) =\
    \ undef;\n    \n    foreach $extension (@{$extensions}) {\n        if ($class_name\
    \ =~ /($extension)/) {\n            $strongest_extension = $class_name;\n    \
    \        last;\n        }\n    }\n    \n    return $strongest_extension;\n}",
  "    my $num_letters = 0;\n    my $num_lower = 0;\n    foreach my $extension (@$extensions)\
    \ {\n        $num_letters += length($extension);\n        $num_lower += length($extension\
    \ =~ tr/[a-z]/);\n    }\n    if ($num_letters > $num_lower) {\n        return\
    \ $class_name . \"${extensions[0]}\";\n    }\n    else { \n        foreach my\
    \ $extension (@$extensions) {\n            return $class_name . \"${extensions[0]}\"\
    ;\n        }\n    }\n    die(\"No extensions satisfy the requirements.\");\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much! I modified it slightly to\
    \ get the results I wanted (I posted an edit to the OP). I also added a check\
    \ for the number of letters in the string being more than the length of the string,\
    \ and if it is, I return the string with its first letter in uppercase.\n<|/ c\
    \ |>\n<| a tags=string,regex,perl |>\nAs far as I understand your question, you\
    \ want a regex which matches substrings starting with capital letters. \n<code>\n\
    my $string = 'Baz';\nmy $regex = '^[A-Z]';\n$string =~ /$regex/;\nprint $&;\n\
    </code>\nThe regex matches any string that starts with capital letter. \nOutput\
    \ is:\n<code>\nBaz\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nuse strict;\n\
    use warnings;", "    my @extensions = @$extensions;\n    \n    my $min_strength\
    \ = -1;\n    my $strongest;\n    \n    foreach my $extension (@extensions) {\n\
    \        my $strengh = uc($extension) - uc($class_name);\n        if ($strengh\
    \ > $min_strength) {\n            $min_strength = $strengh;\n            $strongest\
    \ = $extension;\n        }\n    }", "    my $strongest_extension = $extensions[0];\n\
    \    for my $extension (@$extensions) {\n        $strongest_extension =~ s/\\\
    b(.)/ uc($1) - uc($1) /eg;\n    }\n    return $class_name.$strongest_extension;\n\
    }", "    my($strongest, $i) = (0, 0);\n    for (@$extensions) {\n        my $ext\
    \ = substr($_, 0, 1);\n        if ($ext =~ /^[A-Z]/) { $strongest += length($ext);\
    \ }\n        else {\n            $strongest += length($ext) - length($ext);\n\
    \        }\n        $i++;\n        if ($i == @$extensions) { $i = 0; }\n    }\n\
    \    return $class_name . \".\" . $extensions[$strongest];\n}", "    my @extension_list;\n\
    \    my %extension_strength;\n    my $class_found;\n    my $ext_found;\n    my\
    \ $class_strength;\n    foreach my $ext(@$extensions) {\n        $class_strength++;\n\
    \        $class_strength = 1 if $class_strength >= 0;\n        $ext_found = 0;\n\
    \        $class_found = 0;\n        $class_strength = -1 if $class_strength <\
    \ 0;\n        if ($class_strength != 0) {\n            $class_strength = $class_strength\
    \ - uc($ext);\n        }\n        if ($class_strength == -1) {\n            $ext_found\
    \ = 1;\n        }\n        $class_strength += $ext_found * $class_found;\n   \
    \     if ($class_strength > 0) {\n            $class_strength = $class_strength\
    \ - $class_found;\n            $extension_list[$class_strength] = $ext;\n    \
    \    }\n        if ($class_strength == -1) {\n            $class_strength = $class_strength\
    \ - $class_found;\n            $extension_list[$class_strength] = $ext;\n    \
    \    }\n    }\n    my $class_strength_found = 0;\n    my $ext_strength_found =\
    \ 0;\n    foreach my $class_strength(sort {$a <=> $b} keys %extension_strength)\
    \ {\n        if ($class_strength == -1) {\n            $class_strength_found =\
    \ 1;\n            $ext_strength_found = 0;\n            last;\n        }\n   \
    \     elsif ($class_strength >= 0) {\n            $class_strength_found = 1;\n\
    \            $ext_strength_found = 0;\n            last;\n        }\n        elsif\
    \ ($class_strength > 0) {\n            $class_strength_found = 0;\n          \
    \  $ext_strength_found = 1;\n            last;\n        }\n    }\n    if ($class_strength_found\
    \ == 0) {\n        $class_strength_found = 1;\n    }\n    if ($ext_strength_found\
    \ == 0) {\n        $ext_strength_found = 1;\n    }\n    return $class_name.\"\
    .\".$extension_list[$class_strength_found].$extension_list[$ext_strength_found];\n\
    }", "    my @sorted_extensions = sort { $a <=> $b } @$extensions;\n    $class_name\
    \ .= '::';\n    $class_name .= $sorted_extensions[0];\n    \n    for(my $i = 1;\
    \ $i < @sorted_extensions; $i++) {\n        if($sorted_extensions[$i] - $sorted_extensions[$i-1]\
    \ > 0) {\n            $class_name .= '::' . $sorted_extensions[$i];\n        }\n\
    \    }\n    return $class_name;\n}", "    $class_name =~ tr/A-Z/a-z/;\n    $class_name\
    \ = ucfirst($class_name); \n    my $exts = $extensions[0];\n    for (my $i = 1;\
    \ $i < @{$extensions}; $i++){\n        my $ext = $extensions[$i];\n        $ext\
    \ =~ tr/A-Z/a-z/;\n        $ext = ucfirst($ext);\n        if ($ext !~ /^[A-Z]/){\
    \ die \"Invalid extension $ext\"; };\n        my $num_letters = length($ext) -\
    \ length(lc($ext));\n        my $fraction = &calculate_fraction($num_letters);\n\
    \        if ($fraction > 0){ $exts .= $ext . \".\"; };\n    }\n    $class_name\
    \ =~ s/.+/\\.$exts$//;\n    return $class_name;\n}", "    my $extensions_count\
    \ = scalar @$extensions;\n    my $total_count = scalar(keys %$EXTENSIONS);\n \
    \   my @sorted_extensions;\n    $sorted_extensions[0] = $EXTENSIONS[0] if $extensions_count\
    \ == 0;\n    $sorted_extensions[1] = $EXTENSIONS[1] if $extensions_count == 1;\n\
    \    for my $i( 1 .. $total_count ) {\n        my $current_extension_count = scalar(keys\
    \ %$EXTENSIONS);\n        if ( $current_extension_count > $extensions_count )\
    \ {\n            last;\n        }\n        elsif ( $current_extension_count ==\
    \ $extensions_count ) {\n            if ( @sorted_extensions > 0 ) {\n       \
    \         $sorted_extensions[$i-1] = $sorted_extensions[0];\n            }\n \
    \       }\n        elsif ( $current_extension_count < $extensions_count ) {\n\
    \            my $strength = $EXTENSIONS->{$sorted_extensions[$i-1]}\n        \
    \                      + $EXTENSIONS->{$sorted_extensions[$i]}\n             \
    \                 - $EXTENSIONS->{$sorted_extensions[$i-1]}\n                \
    \              - $EXTENSIONS->{$sorted_extensions[$i]};\n            push @sorted_extensions,\
    \ $EXTENSIONS->{$sorted_extensions[$i]}\n                if $strength >= 0;\n\
    \        }\n    }\n    return $class_name . \".\" . @sorted_extensions;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`@sorted_extensions[$i-1] = $sorted_extensions[0];` does *not*\
    \ copy the array, but rather the element at `$i` from the array `$sorted_extensions`,\
    \ then stores that at the previous element in `$sorted_extensions[$i-1]`.  That\
    \ means that when you write `$sorted_extensions[0]`, you are copying the element\
    \ at index 0, which of course is just a copy of the string \"0\".\n<|/ c |>\n\
    <| a |>\nThe other answers are mostly fine. But I find these too complicated.\
    \ \nI created a hash table with strength as the key, and class as the value. It\
    \ also stores the class name as the key (I believe this is also how it should\
    \ be done).\nThen, I iterate the array of classes, and for each class (which was\
    \ passed as an argument), I look for the class in the hash table. If the class\
    \ does not exist in the hash table, I add a new entry for the class in the hash\
    \ table. If the class exists in the hash table, I find the class in the hash table\
    \ with the lowest strength, that is what I get as the extension. Finally, I add\
    \ this extension to the class name of the class in the hash table.\n<code>\nuse\
    \ strict;\nuse warnings;\nuse feature 'say';", "    my $strongest_extension =\
    \ undef;\n    my $strongest_extension_strength = -1;\n    my @extensions_sorted\
    \ = sort { \n        my ($a, $b) =;\n        ($a =~ tr/A-Z//) <=> ($b =~ tr/A-Z//)\
    \ \n    } @$extensions;\n    foreach my $extension (@extensions_sorted) {\n  \
    \      my $extension_strength = (length($extension) - length($extension) =~ tr/A-Z//);\n\
    \        if ($extension_strength > $strongest_extension_strength) {\n        \
    \    $strongest_extension = $extension;\n            $strongest_extension_strength\
    \ = $extension_strength;\n        }\n    }\n    return $class_name . $strongest_extension;\n\
    }\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThank you for your help. I ended\
    \ up writing a code with your help and it worked. But I had to modify it a little\
    \ to fix a bug. I've pasted the code below.\n<|/ c |>\n<| a dscore=0 tags=perl,arrays\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    my($extension) = @{$extensions}[0];\n\
    \    $extension =~ s/[a-z]/[A-Z]/;\n    $extension =~ s/[A-Z]/[a-z]/;\n    my\
    \ $frac = $class_name =~ tr/A-Z/a-z/; #frac\n    $frac = $frac - $extension =~\
    \ tr/a-z/A-Z/;\n    $frac = $frac < 0 ? $frac + $class_name =~ tr/A-Z/a-z/ :$frac;\n\
    \    my @sorted_extensions = sort { $frac <=> $a->[0] cmp $b->[0] };\n    my $ret\
    \ = $class_name;\n    for(@sorted_extensions){\n        $ret .= \".\" . $_->[1];\n\
    \    }\n    return $ret;\n}", "    my $strongest_extension;\n    for my $extension\
    \ (@$extensions) {\n        if ($extension =~ m/^([A-Z])/) {\n            my $count_of_uppercase\
    \ = length($1);\n            my $count_of_lowercase = length($1) - $count_of_uppercase;\n\
    \            my $count_of_extension_letters = length($extension) - $count_of_lowercase;\n\
    \            my $strength = $count_of_extension_letters / ($count_of_uppercase\
    \ + $count_of_lowercase);\n            next if ($strongest_extension eq '') or\
    \ $strength >= ($strongest_extension =~ m/\\./ ? -1 : 1); # Do not choose extensions\
    \ with different cases\n            $strongest_extension = \"$class_name.$extension\"\
    ;\n        }\n    }\n    return $strongest_extension;\n}", "    my %strongest_extension_count\
    \ = ();\n    my $strongest_extension = \"\";\n    \n    foreach my $extension\
    \ (@$extensions) {\n        if(substr($extension, 0, 1) eq \"A\") {\n        \
    \    $strongest_extension = $extension;\n        }\n        elsif(substr($extension,\
    \ 0, 1) eq \"B\") {\n            $strongest_extension = $extension;\n        }\n\
    \        elsif(substr($extension, 0, 1) eq \"C\") {\n            $strongest_extension\
    \ = $extension;\n        }\n        else {\n            $strongest_extension =\
    \ $extension;\n        }\n    }", "    my $strongest_extension;\n    my @strongest_extensions\
    \ = ();\n    \n    # Iterate over the extensions and find the strongest one.\n\
    \    foreach my $extension (@$extensions) {\n        my $class_name_length = $class_name\
    \ =~ tr/A-Z//;\n        my $extension_length = $extension =~ tr/a-z//;\n     \
    \   \n        # Ignore extensions with length 0.\n        if($class_name_length\
    \ == 0) {\n            next;\n        }\n        \n        my $strength = abs($class_name_length\
    \ - $extension_length);\n        if(!defined($strongest_extension) || $strength\
    \ > $strongest_extension->{Strength}) {\n            $strongest_extension = $extension;\n\
    \        }\n        \n        push(@strongest_extensions, $extension);\n    }\n\
    \    \n    # Return the strongest extension.\n    my $class_name_length = length($class_name);\n\
    \    if(!defined($strongest_extension)) {\n        $strongest_extension = $class_name;\n\
    \    }\n    my $extension_length = length($strongest_extension);\n    my $strength\
    \ = $class_name_length - $extension_length;\n    $strongest_extension->{Strength}\
    \ = $strength;\n    return $strongest_extension->{ClassName};\n}", "    \n   \
    \ my(@sorted_extensions);\n    foreach my $extension (@{$extensions}) {\n\tmy($short_name)\
    \ = $extension =~ /[A-Z]/g;\n\tmy($long_ext) = lc($extension);\n\tmy($count) =\
    \ uc($short_name) . \"\\0\" . $long_ext;\n\tpush (@sorted_extensions, $extension)\
    \ if($count>0);\n    }\n    \n    my (@sorted_extensions);\n    foreach my $extension\
    \ (@{$extensions}) {\n\tmy($short_name) = $extension =~ /[A-Z]/g;\n\tmy($long_ext)\
    \ = lc($extension);\n\tmy($count) = uc($short_name) . \"\\0\" . $long_ext;\n\t\
    push (@sorted_extensions, $extension) if($count>0);\n    }\n    \n    foreach\
    \ my $extension (@sorted_extensions) {\n\tmy($short_name) = $extension =~ /[A-Z]/g;\n\
    \tmy($long_ext) = lc($extension);\n\tmy($count) = uc($short_name) . \"\\0\" .\
    \ $long_ext;\n\treturn $class_name . \".\" . $extension if $count == 0;\n    }\n\
    \    return $class_name . \".????\";\n}\n    ", "    my $strongest_extension;\n\
    \    my $count = 0;\n    foreach my $extension (@$extensions) {\n        if ($extension\
    \ =~ m/^([A-Z]+)/) {\n            $count += 1;\n        }\n    }\n    if ($count\
    \ > 1) {\n        foreach my $extension (@$extensions) {\n            if ($extension\
    \ =~ m/^([A-Z]+)/) {\n                if ($extension =~ m/^([A-Z]+)([a-z]+)([A-Z])/)\
    \ {\n                    $strongest_extension = \"$class_name.$2$3$4\";\n    \
    \            }\n                elsif ($extension =~ m/^([a-z]+)([A-Z])/) {\n\
    \                    $strongest_extension = \"$class_name.$2$3$4\";\n        \
    \        }\n                elsif ($extension =~ m/^([A-Z]+)([A-Z])/) {\n    \
    \                $strongest_extension = \"$class_name.$1$3$4\";\n            \
    \    }\n            }\n        }\n    }\n    return $strongest_extension;\n}",
  '    my($strength);', "    my @strongest;\n    my $total_length = 0;\n    foreach\
    \ my $extension (@$extensions) {\n        $total_length += length $extension;\n\
    \    }\n    foreach my $extension (@$extensions) {\n        if (length $extension\
    \ >= $total_length) {\n            push @strongest, $extension;\n        }\n \
    \   }\n    return $class_name . \".\" . join(\"\", @strongest);\n}", '    my @sorted_extensions
    = sort { $a <=> $b } @$extensions;', "    my $best_strength = -1;\n    my $best_name\
    \  = \"\";", "    my %strongest_extension;\n    \n    foreach my $extension (@{$extensions})\
    \ {\n        my $num_caps = length $extension;\n        my $num_lower = length($extension)\
    \ - $num_caps;\n        $strongest_extension{$extension} = $num_caps - $num_lower;\n\
    \    }\n    \n    my @sorted_extensions = sort { $strongest_extension{$a} <=>\
    \ $strongest_extension{$b} } keys %strongest_extension;\n    return $class_name\
    \ . \".\" . @sorted_extensions[0];\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ was based on your examples. If you have one more extension, add it to the hash\
    \ and the sort will work properly. If you want to sort in reverse order just change\
    \ the \"<=>\" to \"<\".\n<|/ c |>\n<| a dscore=0 |>\nI tried to solve this with\
    \ Perl's sort's -cmp function, but I couldn't make it to work. Here's my solution:\n\
    <code>", "    my $strength_str = uc $class_name; # Strongest name\n    $strength_str\
    \ =~ s/^(.)/\\U$1/;         # To upper case\n    $strength_str = uc $strength_str;\
    \         # To lower case\n    $strength_str = lc $strength_str;         # To\
    \ lower case\n    \n    # Sort extension names by strength\n    $extensions =\
    \ sort { $strength_str <=> $a } @$extensions;\n    # Return first extension with\
    \ lowest strength\n    $extensions[0] if @$extensions;\n}\n</code>\nThe other\
    \ part of the problem is comparing two strings. Strings in perl are immutable.\
    \ So any changes you make to them won't affect the original string as it is just\
    \ a pointer to the original memory location.\nSo, the easiest way to compare two\
    \ strings is with the eq operator. To compare two strings s1 and s2 you would\
    \ use the eq operator as if(s1 == s2).\nThe eq operator is comparing two variables\
    \ s1 and s2. So you would use the eq operator as if(s1 == s2).\n<|/ a dscore=2\
    \ |>\n<| c |>\nI got this error: `Not enough arguments for method \"eq\".` I added\
    \ this at the begining of my script `use strict; use warnings;`\n<|/ c |>\n<|\
    \ c |>\nYeah, sorry, I missed the use of `eq` :P I've corrected my answer to include\
    \ that.\n<|/ c |>\n<| a tags=string,perl |>\nWhat you're looking for is an extension\
    \ of sorting.\n<code>\nuse Sort::Key::Natural qw(natsort);\nmy = natsort keys\
    \ %class;\nmy $strongest = $classes[0];\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=string,perl |>\nIf you have the list of keys from the hash already, you\
    \ can sort them:\n<code>\nmy = sort keys %class;\nmy $strongest = $classes[0];\n\
    </code>\nThe sort function has the ability to pass a comparison callback as the\
    \ second argument.  If you have an array ref, $a, then you can pass that as the\
    \ callback.  It can be any subroutine reference.  The comparison function will\
    \ be passed two arguments, the first being the first element in the array, the\
    \ second being the second element in the array.\n<code>\nmy $strongest = sort\
    \ { $class{$b} <=> $class{$a} } keys %class;\n</code>\nHowever, if all you are\
    \ looking for is the value at the first key, you can just use the first key directly.\n\
    <code>\nmy $strongest = $class{sort", "    my $strength = 0;\n    my $max_strength;\n\
    \    my %class;\n    foreach my $ext (@{$extensions}) {\n        if ($class{$ext})\
    \ {\n            $class{$ext}++;\n        }\n        else {\n            $class{$ext}\
    \ = 1;\n        }\n        if ($class{$ext} > $max_strength) {\n            $max_strength\
    \ = $class{$ext};\n        }\n    }\n    if ($max_strength == 0) {\n        return\
    \ $class_name;\n    }\n    my $index = 0;\n    foreach my $ext (@{$extensions})\
    \ {\n        if ($class{$ext} != $max_strength) {\n            $index++;\n   \
    \     }\n    }\n    my $name = $class_name;\n    $name .= \"_\" . $extensions[0];\n\
    \    if ($index > 0) {\n        $name .= \"_\" . $extensions[$index];\n    }\n\
    \    return $name;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI haven't down-voted\
    \ you or anything, but I do think that `Slices::StrongestExtension` should be\
    \ written as `Slices::StrongestExtension` - but I don't want to change it because\
    \ I think it's already fine.\n<|/ c |>\n<| c |>\nI agree.  I was going to fix\
    \ it but then I thought why not make it correct.  Thanks for pointing that out.\n\
    <|/ c |>\n<| c |>\nI didn't down-vote, but your `Slices::StrongestExtension` will\
    \ return \"Slices.SErviNGSliCes\" if given \"Slices\", and will return \"Slices.StuFfed\"\
    \ if given \"StuFfed\".  That is not the OP's requirements.  I could be wrong,\
    \ but I think you were right when you said you were looking for \"the strongest\
    \ extension\".  Am I wrong?\n<|/ c |>\n<| c |>\nI don't think so.  My example\
    \ was just an example of how it could return more than one extension.  That is,\
    \ in the example given it would return \"StuFfed\" instead of just \"StuFfed\"\
    .  Also, I think you were right and my wording was wrong.  Thanks for pointing\
    \ that out and sorry for the confusion.\n<|/ c |>\n<| c |>\nI think you're wrong.\
    \  I interpret the OP's requirements as `Slices` can have zero or more extensions,\
    \ and `StuFfed` is the strongest extension, but your function returns `\"StuFfed\"\
    ` instead of `\"Slices.StuFfed\"` because `Slices` contains zero extensions. \
    \ I did my best to interpret OP's requirement", "    $class_name =~ s/[^A-Z]/_/g;\n\
    \    \n    my @extensions = $extensions;\n    my %strength;\n    \n    foreach\
    \ my $ext (@extensions) {\n        $ext =~ s/[^a-z]/_/g;\n        \n        my\
    \ $name = $class_name;\n        $name .= \".\" . $ext;\n        \n        $strength{$ext}\
    \ = $strength{$name};\n        \n        my @strength_chars = split /[_]/, $ext;\n\
    \        my $strength_char_sum = 0;\n        foreach my $strength_char (@strength_chars)\
    \ {\n            $strength_char_sum += ord(substr($strength_char, 1));\n     \
    \   }\n        $strength_char_sum -= ord('A');\n        $strength{$name} =\n \
    \           $strength{$name}/$strength_char_sum*$strength_char_sum;\n    }\n \
    \   \n    my ($max_strength_ext) = grep(!exists $strength{$_}, keys %strength);\n\
    \    return $class_name.$max_strength_ext;\n}", '    my $strongest = "";', " \
    \   $class_name =~ s/^\\s+//;\n    $class_name =~ s/\\s+$//;\n    \n    $extensions_count\
    \ = scalar(keys %extensions);\n    \n    my $extension = $extensions[0];\n   \
    \ \n    # Find the lowest number of lowercase letters in the name\n    my $lower_count\
    \ = 1;\n    while (length($class_name =~ /[a-z]/) && $lower_count < length($class_name)){\n\
    \        $lower_count++;\n    }\n    my $strength = $lower_count - length($extension);\n\
    \    \n    # Find the strongest extension\n    my $strongest_extension = $extension;\n\
    \    foreach my $ext_count (0 .. $extensions_count){\n        if ($ext_count ==\
    \ 0 || $extensions[$ext_count] eq $strongest_extension){\n            $strongest_extension\
    \ = $extensions[$ext_count];\n        }\n    }\n    \n    return $class_name.$strongest_extension;\n\
    }", "    my($number_of_uppercase_letters, $number_of_lowercase_letters) = (0,\
    \ 0, 0);\n    \n    foreach $extension (@$extensions) {\n\t$number_of_uppercase_letters\
    \ += length($extension) - length($extension=~tr/A-Z/A/);\n\t$number_of_lowercase_letters\
    \ += length($extension) - length($extension=~tr/a-z/a/);\n    }\n    return $class_name.$extensions[$number_of_uppercase_letters\
    \ cmp $number_of_lowercase_letters]\n\t? $class_name.$extensions[$number_of_uppercase_letters\
    \ cmp $number_of_lowercase_letters]\n\t: $class_name;\n}", "    my $extensions_count\
    \ = -1;\n    my $best_extension = \"\";\n    foreach my $extension (@$extensions)\
    \ {\n        my $extension_letters = length($extension);\n        $extensions_count\
    \ += $extension_letters;\n        if ($extension_letters < $best_extension_letters)\
    \ {\n            $best_extension_letters = $extension_letters;\n            $best_extension\
    \ = $extension;\n        }\n    }\n    return \"$class_name.$best_extension\"\
    ;\n}", "    \n    my @ordered_extensions = sort {\n\t($a =~ /[A-Z]/g) <=> ($b=~\
    \ /[A-Z]/g)\n    } (@$extensions);\n    \n    my $strongest_extension = \"\";\n\
    \    \n    if (scalar @ordered_extensions == 1) {\n\t$strongest_extension = pop\
    \ @ordered_extensions;\n    } else {\n\tmy $highest_strength = 0;\n\t\n\t# Loop\
    \ through the array and find the strongest extension\n\tforeach my $ext (@ordered_extensions)\
    \ {\n\t    my $strength = $ext=~/^([A-Z][a-z]*)\\Z/;\n\t    \n\t    if ($strength\
    \ eq $highest_strength) {\n\t\t# Found the strongest extension\n\t\t$strongest_extension\
    \ = $ext;\n\t\tlast;\n\t    }\n\t    \n\t    if ($strength gt $highest_strength)\
    \ {\n\t\t$highest_strength = $strength;\n\t\t$strongest_extension = $ext;\n\t\
    \    }\n\t}\n    }\n    \n    $class_name .= $strongest_extension;\n    return\
    \ $class_name;\n}", "    my($extension_strengths);\n    my($class) = find_class($class_name);\n\
    \    my($extension_strongest);\n    my(@extension_strongest) = ();\n    foreach\
    \ $extension (@$extensions) {\n        $extension_strengths[$extension] = -1;\n\
    \    }\n    foreach $class (@{$class->{EXTENSIONS}}) {\n        $extension_strengths[$class]\
    \ .= $class->{NAME};\n    }\n    foreach $extension (@{$extension_strengths})\
    \ {\n        $extension_strongest .= \"$class.$extension\";\n        foreach $class\
    \ (@{$class->{EXTENSIONS}}) {\n            last if $extension_strengths[$class]\
    \ == $extension;\n        }\n    }\n    return $extension_strongest unless scalar\
    \ @extension_strongest == 1;\n    my $strongest_extension = @extension_strongest[0];\n\
    \    foreach $class (@{$class->{EXTENSIONS}}) {\n        last if $extension_strengths[$class]\
    \ == $extension;\n    }\n    return $strongest_extension;\n}", "    my $length\
    \ = length($class_name);\n    foreach my $ext (@$extensions) {\n        if ($ext\
    \ =~ /^[A-Z]/) {\n            if ($ext =~ /[A-Z]/) {\n                my $cap\
    \ = $length - length($ext);\n                last if $cap <= 0;\n            \
    \    return $class_name.substr(0, $cap).$ext.substr($cap);\n            }\n  \
    \          else {\n                my $sm = $length - length($ext);\n        \
    \        last if $sm <= 0;\n                return $class_name.substr(0, $sm).$ext.substr($sm);\n\
    \            }\n        }\n    }\n    return $class_name;\n}", "    my $strongest\
    \ = -1;\n    foreach my $ext (@$extensions) {\n        my $length = length($ext);\n\
    \        if ($length > 0) {\n            my $percentage = ($length - length($class_name));\n\
    \            my $strength = $percentage * (100 - $percentage) / 100;\n       \
    \     if ($strength > $strongest) {\n                $strongest = $strength;\n\
    \            }\n        }\n    }\n    return $class_name.$strongest;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis isn't a particularly elegant solution. It also\
    \ doesn't take into account the extra information you added at the end of the\
    \ class name. For example, if you just wanted the extension name, then you'd have\
    \ to add code to get the extra information, which would be more code than is necessary\
    \ to do what the OP wants (and will probably break when someone uses two classes\
    \ with the same name but different extensions)\n<|/ c |>\n<| c |>\nThe OP didn't\
    \ say that two classes could be the same, they said that they wanted a class name\
    \ that would always return the most similar extension name to the input class\
    \ name.\n<|/ c |>\n<| c |>\nMy bad, I didn't see that (which would make your solution\
    \ better)\n<|/ c |>\n<| a |>\nA regex may help:\n<code>", "    my %counts;\n \
    \   my @extension_names;", "    $class_name =~ tr/A-Z//d;\n    $class_name =~\
    \ tr/a-z//d;\n    \n    my $strength = -1;\n    my $found = 0;\n    \n    foreach\
    \ my $ext (@$extensions) {\n        $ext =~ tr/A-Z//d;\n        $ext =~ tr/a-z//d;\n\
    \        $ext = $ext =~ tr/-/_/d;\n        $ext =~ tr/[A-Z]//d;\n        $ext\
    \ = $ext =~ tr/[a-z]//d;\n        $ext =~ tr/\\d/-/;\n        $ext =~ tr/\\./_/;\n\
    \        \n        if($class_name eq $ext) {\n            $found++;\n        \
    \    if($strength < 0){\n                $strength = $strength + $ext;\n     \
    \       } else {\n                if($strength > $ext){\n                    $strength\
    \ = $strength;\n                }\n            }\n        }\n    }\n    \n   \
    \ if($found > 0) {\n        foreach my $ext (@$extensions) {\n            $ext\
    \ =~ tr/A-Z//d;\n            $ext =~ tr/a-z//d;\n            $ext = $ext =~ tr/-/_/d;\n\
    \            $ext =~ tr/[A-Z]//d;\n            $ext = $ext =~ tr/[a-z]//d;\n \
    \           $ext =~ tr/\\d/-/;\n            $ext =~ tr/\\./_/;\n            \n\
    \            if($class_name eq $ext) {\n                $found++;\n          \
    \      if($strength < 0){\n                    $strength = $strength + $ext;\n\
    \                } else {\n                    if($strength > $ext){\n       \
    \                 $strength = $strength;\n                    }\n            \
    \    }\n            }\n        }\n    }\n    \n    return $class_name.\".\".$extensions[0];\n\
    }", "    my @extension_strs = ();\n    my @extension_str;\n    \n    for my $extension\
    \ (@$extensions) {\n        my($cap, $sm) = split(/\\W/, $extension);\n      \
    \  push(@extension_strs, $cap - $sm);\n    }\n    \n    my $strength = (sort {$extension_strs[$a]\
    \ - $extension_strs[$b]} \n                      reverse @extension_strs)[0];\n\
    \    \n    $class_name.$extensions[0];\n}", "    $extensions=@$extensions;\n \
    \   my $count = 1;\n    my $count_cap = $count_low = 0;\n    my $strength = 0;\n\
    \    foreach my $ext (@$extensions) {\n        my $extlen = length($ext);\n  \
    \      my $cap = substr($ext, 0, $extlen);\n        my $low = substr($ext, 0,\
    \ $extlen-1);\n        $strength += ($cap - $low);\n        if ($cap >= $count_cap)\
    \ {\n            $count_cap = $cap;\n        }\n        if ($low >= $count_low)\
    \ {\n            $count_low = $low;\n        }\n        $count++;\n    }\n   \
    \ $strength /= $count;\n    if ($strength == 0) {\n        $strength=1;\n    }\n\
    \    my $str = $class_name;\n    if ($count_cap != 0) {\n        $str =~ s/(.{1})(.{1})/\\\
    U$count_cap.$2/g;\n    }\n    if ($count_low != 0) {\n        $str =~ s/(.{1})(.{1})/$1.$count_low/g;\n\
    \    }\n    return $str;\n}", "    my $strongest = -1;\n    my %strongest_extensions;\n\
    \    foreach my $ext (@$extensions) {\n        foreach my $char ($class_name =~\
    \ /[A-Z]/) {\n            $strongest_extensions{$char}->{$ext}++;\n        }\n\
    \        $strongest = $char if $strongest < $strongest_extensions{$char}->{$ext}\
    \ || $strongest_extensions{$char}->{$ext} == 0;\n    }\n    my $strongest_extension\
    \ = $strongest_extensions{$strongest};\n    foreach my $char ($class_name =~ /[A-Z]/)\
    \ {\n        $strongest_extension->{$char}++;\n    }\n    \n    $strongest_extension;\n\
    }", "    $extensions = map {; /(?=[A-Z])/} @$extensions;\n    $extensions = map\
    \ {; /(?=[a-z])/} @$extensions;\n    my $sum = $extensions[0..2] - $extensions[2..4];\n\
    \    my $max_idx = $extensions.index($sum, 1) if $sum > 0;\n    return $class_name\
    \ . \".\" . $extensions[$max_idx];\n}", "    my $class;\n    my $strongest_extension\
    \ = $class_name;\n    for my $ext (@$extensions) {\n\tmy $num = length($ext) -\
    \ length($strongest_extension);\n\tif ($num >= 0) {\n\t    $strongest_extension\
    \ .= $ext;\n\t} else {\n\t    $strongest_extension .= substr($ext, 0, $num);\n\
    \t}\n    }\n    $strongest_extension;\n}", "    # Write your code here.\n    return;\n\
    }", "    \n    my @sorted_extensions;\n    \n    foreach my $extension (@$extensions)\
    \ {\n        my $pos = index($extension, '_');\n        \n        if ($pos ==\
    \ -1) {\n            push @sorted_extensions, $extension;\n        } else {\n\
    \            my $strength = substr($extension, 0, $pos);\n            my $name\
    \ = substr($extension, $pos + 1);", "    my ($strength_of_extension);\n    my\
    \ $i = 0;\n    my $strength_of_class_name = $class_name;\n    my @extensions_array\
    \ = @$extensions;\n    my $counter = 0;\n    my $strongest_extension;\n    for(my\
    \ $i=0;$i<@extensions_array;$i++) {\n        $strongest_extension = $extensions_array[$i];\n\
    \        if($strength_of_class_name eq $strongest_extension) {\n            $counter++;\n\
    \        }\n        if($counter > $strength_of_extension) {\n            $strength_of_extension\
    \ = $counter;\n        }\n        $counter = 0;\n    }\n    if($strength_of_extension\
    \ > 0) {\n        $strength_of_extension = $strength_of_extension * -1;\n    }\n\
    \    $strength_of_class_name .= \".\".$strongest_extension;\n    return $strength_of_class_name;\n\
    }", "    my $strongest = -1;\n    my $extensions_count = scalar(@$extensions);\n\
    \    foreach my $extension (@$extensions) {\n        if ($extension !~ m/^\\p{Upper}/\
    \ && $extension !~ m/^\\p{Lower}/ &&\n            $extension !~ m/^\\p{Upper}|\\\
    p{Lower}/ &&\n            $extension !~ m/^[a-z]$/i) {\n            $strongest\
    \ = -1;\n            last;\n        }\n        my $length = length($extension);\n\
    \        $strongest = 1 if $length == length($extension) - 1;\n        $strongest\
    \ = 0 if $strongest == -1 || $length < $strongest;\n    }\n    return \"${class_name}.${extensions[$strongest]}\"\
    \ \n        if $strongest == -1 || $strongest >= $extensions_count;\n    return\
    \ Strongest_Extension($class_name, $extensions[0..$strongest-1]);\n}", "    my($capitals)\
    \ = @_;\n    my($capitals_count) = 0;\n    my($result) = \"$class_name.\";\n \
    \   my($extensions_count) = $extensions->[0];\n    \n    # Count the number of\
    \ capital letters in the name\n    foreach my $letter (split //, $class_name)\
    \ {\n        if ($letter =~ /[A-Z]/) {\n            $capitals_count++;\n     \
    \   }\n    }\n    \n    # Select the class with the highest count\n    for (my\
    \ $i = 0; $i < $extensions_count; $i++) {\n        my $letter_count = $extensions->[$i];\n\
    \        for (my $j = 0; $j < $capitals_count; $j++) {\n            if ($letter_count\
    \ eq $capitals->[$j]) {\n                $result = $result . substr($class_name,\
    \ $i + 1);\n            }\n        }\n    }\n    return $result;\n}", "    my\
    \ $strongest_extension;\n    my $strength;\n    foreach my $extension (@$extensions)\
    \ {\n        $strength = uc(substr($extension, 0, 1)).uc(substr($extension, 1,\
    \ 1)) \n            - uc(substr($extension, 2, 1));\n        if ($strength > 0)\
    \ {\n            $strongest_extension = $class_name.$extension;\n            last;\n\
    \        }\n    }\n    $strongest_extension ? $strongest_extension : undef;\n\
    }\n</code>\nThe next problem is to do with printing out all permutations of the\
    \ string \"ABC\". If you're not sure how to do this, I suggest looking up permutations\
    \ in an introductory programming course. \nYou will also find this very useful\
    \ about using recursion in Perl from Ted Wengler.\n<|/ a tags=perl,string |>\n\
    <| a tags=perl,string |>\nThe answer by Jerub Minkis is correct, but here's another\
    \ approach, which doesn't use recursion.\n<code>", "    $class_name =~ s/\\W//g;\n\
    \    $extensions ||= [];\n    $extensions ||= []; # Default if not given an array.\n\
    \    foreach my $extension (@$extensions) {\n        $extension =~ s/\\W//g;\n\
    \        if ($class_name =~ /($extension)/) {\n            my $strength = uc($1)\
    \ -\n                        uc($extension);\n            return $class_name .\
    \ \".$extension\";\n        }\n    }\n    return;\n}", "    my $num_upper = 0;\n\
    \    my $num_lower = 0;\n    foreach my $ext (@$extensions) {\n        if ($ext\
    \ =~ /[A-Z]/g) { $num_upper++ }\n        elsif ($ext =~ /[a-z]/g) { $num_lower++\
    \ }\n    }\n    if ($num_upper > $num_lower) {\n        $class_name .= \".\".$extensions[0];\n\
    \    }\n    elsif ($num_lower > $num_upper) {\n        $class_name .= \".\".$extensions[1];\n\
    \    }\n    else {\n        $class_name .= \".\".$extensions[$num_upper-$num_lower+1];\n\
    \    }\n    return $class_name;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks, I tried\
    \ to run your code, but still I dont get my expected output. Its my first time\
    \ to use perl so please bear with me. I also edited my question to include the\
    \ required output.\n<|/ c |>\n<| c |>\nI added more explanation and a link to\
    \ another answer that explains the algorithm in detail\n<|/ c |>\n<| c |>\nThanks\
    \ a lot, but could you please tell me how do I implement this in my code? I am\
    \ really a newbie in Perl\n<|/ c |>\n<| a tags=algorithm,regex,perl |>\nYou can\
    \ do it by iterating over the array and getting the positions of first and last\
    \ uppercase/lowercase character in it.\n<code>\nuse strict;\nuse warnings;", " \
    \   my($i, $j, $max) = @{$extensions};\n    for(my $i = 0; $i < @{$extensions};\
    \ $i++) {\n        $max = $i if $max < $i;\n    }\n    return \"$class_name.$extensions[$max]\"\
    ;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis works. You might want to change\
    \ the output slightly. Add a new variable to the `$extensions` that holds the\
    \ last found extension. Then, compare the `$max` variable to the `$extensions[$i]`\
    \ variable and if greater, store the `$extensions[$i]` variable. Then return the\
    \ `$class_name.$extensions[$i]`\n<|/ c |>\n<| c |>\n, yes, I wanted to keep it\
    \ similar to the OP's code, so I kept it almost identical to his. But you're right,\
    \ it could be done much easier by adding another variable to store the highest\
    \ value found. I've edited my answer to add it.\n<|/ c |>\n<| c |>\nThank you,\
    \ that code works perfectly. Now I just have to figure out how to convert it to\
    \ Python.\n<|/ c |>\n<| c |>\n, I'm glad I could help. You can convert the code\
    \ to Python by using the online converter (http://chris.photobooks.com/python/python_strings.html)\
    \ but if you're more comfortable with Perl then I suggest you use the answer from\n\
    <|/ c |>\n<| a |>\n<code>\ndef strongest_extension(class_name, extensions):\n\
    \    \"\"\"\n    Returns the strongest extension name from the list of extensions.",
  "    my $class_name = $class_name;\n    $class_name =~ s/\\s+/::/g;\n    my($extension,\
    \ $strength) = (0, 0);\n    for (@$extensions) {\n        $class_name .= \".$_\"\
    ;\n        $strength = &get_extension_strength($class_name);\n        if ($strength\
    \ > $extension) {\n            $extension = $strength;\n            $class_name\
    \ = $class_name;\n        }\n    }\n    return $class_name;\n}", "    my $strength\
    \ = 0;\n    my $strongest_name = \"\";\n    my $counter = 0;\n    foreach my $extension\
    \ (@$extensions) {\n        my ($first_letter, $letters) = split(//, $extension);\n\
    \        my ($second_letter, $letters) = split(//, $extension);\n        $strength\
    \ += $letters - $letters >> 1;\n        $strength += $letters - $letters >> 2;\n\
    \        $strength += $letters - $letters >> 4;\n        $strength += $letters\
    \ - $letters >> 8;\n        $strength += $letters - $letters >> 16;\n        $strength\
    \ += $letters - $letters >> 32;\n    }\n    $strongest_name = $class_name . \"\
    .\" . $extensions[$counter];\n    if ($strength > 0) {\n        my @extensions_sorted\
    \ = sort { $a <=> $b } @$extensions;\n        foreach my $extension (@extensions_sorted)\
    \ {\n            my ($first_letter, $letters) = split(//, $extension);\n     \
    \       my ($second_letter, $letters) = split(//, $extension);\n            $strongest_name\
    \ = $class_name . \".\" . $extension;\n            if ($strength == $letters -\
    \ $letters >> 1) {\n                return $strongest_name;\n            }\n \
    \       }\n    }\n    return $strongest_name;\n}\n</code>\n<|/ a tags=perl,arrays\
    \ |>\n<| c |>\nThanks. My main question is about how we select the strongest extension.\n\
    <|/ c |>\n<| c |>\nIt's not clear from the question whether you wish to return\
    \ the strongest extension or the name of the class that is the strongest extension.\n\
    <|/ c |>\n<| c |>\nI want to return the name of the class that is the strongest\
    \ extension.\n<|/ c |>\n<| c |>\nThat isn't really part of the question, so I've\
    \ updated my answer to accommodate that as well.\n<|/ c |>\n<| a tags=perl,arrays\
    \ |>\nYou could use a Schwartzian Transform to find the minimum distance between\
    \ each consecutive letter in the array and then sort the array by the minimum\
    \ distance from each letter using List::UtilsBy:\n<code>\nuse List::UtilsBy 'minby';\n\
    my;\nfor (@$extensions) {\n    push, {\n        'distance' => map { ($_) eq ($_)\
    \ ? '0' : ord($_) - ord($_) } $_ for;\n    }\n}", "    $class_name =~ s/^.*?:://;\n\
    \    my $count = uc($class_name) - uc($class_name);\n    $count += $extensions\
    \ && !$extensions[-1] ?\n        uc($extensions[0]) - uc($extensions[0]) :\n \
    \       uc($extensions[-1]) - uc($extensions[-1]);\n    my $strength = -$count\
    \ >= 0 ? -$count : 0;\n    my $ext = $extensions[-1];\n    chomp($ext);\n    $ext\
    \ =~ s/[^A-Z]+//g;\n    $ext =~ s/^(.)/L$1/g;\n    return \"$class_name.$ext\"\
    ;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThank you so much for the answer\
    \ but it doesn't solve the problem. It should return \"my_class.aa\" and \"my_class.bb\"\
    \ but returns \"my_class.aa\" and \"my_class.bba\". My solution should be based\
    \ on \"strongest extension\" and should return \"my_class.aa\" as it's the strongest\
    \ extension and then \"my_class.bb\" because it's the next extension and so on.\n\
    <|/ c |>\n<| c |>\nThe code has `uc($extensions[0])` twice instead of `uc($extensions[-1])`.\
    \ And it doesn't check whether `@extensions` is empty.\n<|/ c |>\n<| c |>\n, thank\
    \ you! It was a mistake I made when writing my code. I've edited my code\n<|/\
    \ c |>\n<| a |>\nThe solution is to write down the code and then think of it logically.\n\
    <code>", "    $extensions =~ tr/A-Z/a-z/;\n    $class_name =~ tr/A-Za-z/a-z/;\n\
    \    my $num = length($class_name) - length($class_name);\n    my @strengths =\
    \ ();\n    foreach my $x (@$extensions) {\n        my ($c, $m) = split(/[a-z]/,\
    \ $x);\n        $num -= $m;\n        $num *= $c;\n        push (@strengths, $num)\
    \ if $num > 0;\n    }\n    $strengths[0] = $class_name;\n    $strengths[-1] =\
    \ \"-\" unless $strengths[-1] eq \"-\";\n    my $min = 0;\n    my $max = 0;\n\
    \    foreach my $x (@strengths) {\n        $x = length($x) if $x eq \"-\";\n \
    \       $x = $1 if $min == $x || $max > $x;\n        $min = $x;\n        $max\
    \ = $x;\n    }\n    return join (\".\", map {$_ - $min} @strengths);\n}", "  \
    \  my $strongest_extension = \"\";\n    my $extension_count = 0;\n    foreach\
    \ my $extension (@$extensions) {\n        if($extension =~ /([A-Z])/) {\n    \
    \        $extension_count++;\n        }\n        elsif($extension =~ /([a-z])/)\
    \ {\n            $extension_count--;\n        }\n        if($extension_count ==\
    \ 0) {\n            $strongest_extension = $extension;\n        }\n    }\n   \
    \ return $class_name . $strongest_extension;\n}", "    my $best_strength = -1;\n\
    \    my $best_ext = '';\n    $class_name =~ s/^.*\\.//;\n    foreach my $ext(@$extensions)\
    \ {\n        my $ext_size = length($ext);\n        my $ext_size = $ext_size if\
    \ $ext_size <= 1;\n        if ($ext_size > 1) {\n            my ($s, $e) = split(/(?=[A-Z])/,\
    \ $ext);\n            $ext_size = $ext_size if $ext_size <= 1;\n            if\
    \ ($ext_size > $best_strength) {\n                $best_strength = $ext_size;\n\
    \                $best_ext = $ext;\n            }\n        } elsif ($ext_size\
    \ == 1) {\n            $best_ext = $ext if $best_strength == -1 || $best_strength\
    \ < length($ext);\n        }\n    }\n    return \"$class_name.$best_ext\";\n}",
  "    my $total_cap = 0;\n    my $total_sm = 0;\n    my $extension_count;\n    my\
    \ $extension_str;\n    foreach my $extension (@$extensions) {\n        $extension_count\
    \ = length($extension);\n        $total_cap += $extension_count if $extension_count\
    \ > 0;\n        $total_sm += $extension_count if $extension_count > 1;\n    }\n\
    \    $extension_str = $extensions[0] . '.' . $extensions[1] if\n        $total_cap\
    \ == $total_sm;\n    foreach my $extension (@$extensions) {\n        $extension_str\
    \ .= '.' . $extension if length($extension) == 1;\n    }\n    return $class_name\
    \ . '.' . $extension_str;\n}", "    my($i, $j, $cap, $sm, $strongest);\n    my(@ext)\
    \ = @$extensions;\n    my $str = \"\";\n    $str = $class_name;\n    $str =~ s/[^A-Z]/_/g;\n\
    \    $cap = @ext - 1;\n    $sm = @ext;\n    while ($sm > 0) {\n        $str .=\
    \ substr($ext[$i], $j, $cap);\n        $j++;\n        $sm--;\n    }\n    for ($i\
    \ = 0; $i < @ext; $i++) {\n        $str .= \"\\$$ext[$i]\";\n    }\n    return\
    \ $str;\n}", "    my $max_strength = -1;\n    my $max_ext;\n    foreach my $ext(@$extensions)\
    \ {\n        (my $ex_len = length($ext)) >= 2 and \n        (($ex_len = length($ext))\
    \ < length($class_name)) or\n        die \"The extension '$ext' of class '$class_name'\
    \ is not a valid class name\";\n        my $strength = uc(substr($ext, 0, 1))\
    \ - (uc(substr($ext, 1, 1)));\n        if ($strength > $max_strength) {\n    \
    \        $max_strength = $strength;\n            $max_ext = $ext;\n        }\n\
    \    }\n    return $max_ext;\n}", "    \n    # Initialize result to an empty string.\n\
    \    my($result) = '';\n    \n    # Get the number of uppercase letters.\n   \
    \ my($num_uc) = length($class_name) - length($class_name =~ tr/[A-Z]/);\n    \n\
    \    # Get the number of lowercase letters.\n    my($num_lc) = length($class_name)\
    \ - length($class_name =~ tr/[a-z]/);", '    my $strength = 0;', "    my %strength\
    \ = ();\n    $class_name =~ s/[A-Z]/-/g;\n    for my $extension (@$extensions)\
    \ {\n        $extension =~ s/[a-z]/-/g;\n        $strength{$extension}++;\n  \
    \  }\n    return $class_name unless %strength;\n    my $strongest = keys %strength\
    \ \n        ? $strength{$_} \n        : $extensions[0];\n    my $strength_percent\
    \ = sprintf(\"%.2f\", 100 * $strongest / scalar @$extensions);\n    return \"\
    $class_name.$strongest\", $strength_percent;\n}", "    my $strength = 0;\n   \
    \ my $new_name = $class_name;\n    foreach my $ext (@$extensions) {\n        if\
    \ (length($ext) > length($new_name)) {\n            $new_name .= $ext;\n     \
    \   } else {\n            $strength -= length($ext);\n        }\n    }\n    return\
    \ $new_name if $strength < 0;\n    return $class_name . $extensions[0];\n}\n</cell>\n\
    <text>\nA test case for Strongest_Extension()", "    my @extensions_to_load =\
    \ sort { $a <=> $b } @$extensions;\n    my @extensions_to_try;\n    my @extensions_with_the_greatest_strength\
    \ = ();\n    my $current_strength;\n    \n    foreach my $extension (@extensions_to_load)\
    \ {\n        my ($num_cap_letters, $num_sma_letters) = length $extension, length\
    \ $class_name;\n        $current_strength = -1;\n        foreach my $ex (@extensions_to_try)\
    \ {\n            ($num_cap_letters, $num_sma_letters) = length $ex, length $extension;\n\
    \            my $strength = $num_cap_letters - $num_sma_letters;\n           \
    \ if ($strength > $current_strength) {\n                $current_strength = $strength;\n\
    \                @extensions_to_try = @$ex;\n            }\n        }\n      \
    \  push @extensions_with_the_greatest_strength, $extension;\n    }\n    return\
    \ @extensions_with_the_greatest_strength[0] unless @extensions_with_the_greatest_strength\
    \ == 1;\n    \n    my $extension_with_greatest_strength = @extensions_with_the_greatest_strength[0];\n\
    \    foreach my $extension (@extensions_to_try) {\n        if (length $extension_with_greatest_strength\
    \ > length $extension) {\n            $extension_with_greatest_strength = $extension;\n\
    \        }\n    }\n    return \"$class_name.$extension_with_greatest_strength\"\
    ;\n}", "    my $best_extension = 0;\n    my $best_strength = 0;\n    foreach my\
    \ $extension (@{$extensions}) {\n        if ($best_strength == 0) {\n        \
    \    $best_strength = $extension =~ tr/[A-Z]/[\\012\\015]/g;\n        } \n   \
    \     if ($extension =~ tr/[A-Z]/[\\012\\015]/g > $best_strength) {\n        \
    \    $best_strength = $extension =~ tr/[A-Z]/[\\012\\015]/g;\n            $best_extension\
    \ = $extension;\n        }\n    }\n    \n    return \"${class_name}${best_extension}\"\
    ;\n}", "    my($extension_strength_sum) = @$extensions;\n    \n    my $highest_strength\
    \ = -9999;\n    my $highest_extension = undef;\n    \n    foreach my $extension\
    \ (@$extensions) {\n        my $extension_strength = (length($extension) - length($extension_strength_sum));\n\
    \        \n        if ($extension_strength > $highest_strength) {\n          \
    \  $highest_strength = $extension_strength;\n            $highest_extension =\
    \ $extension;\n        }\n    }\n    \n    return \"$class_name.$highest_extension\"\
    ;\n}", '    my($num_cap, $num_low) = ();', "    \n    foreach my $extension (@$extensions)\
    \ {\n        my $extension_strength = (split(//,$extension))[-1];\n        if\
    \ ($extension_strength > 0) {\n            my @extension = split //,$extension;\n\
    \            $extension[0] =~ s/[A-Z]/[AC]/; # Capitalize the first letter of\
    \ every word\n            my $strength = length $extension[0] - length $extension[1];\n\
    \            if ($strength > 0) {\n                return \"{$class_name}.$extension[0]\"\
    ;\n            }\n        }\n    }\n    \n    # if no extensions meet the criteria,\
    \ return as is\n    return $class_name;\n}", "    my $max_extension_strength =\
    \ 0;\n    my $max_extension;\n    my $i;\n    my $len = length($class_name);\n\
    \    \n    foreach my $extension (@$extensions) {\n        $extension =~ /^(.)/\
    \ or die \"Bad extension name: $extension\\n\";\n        my $char = $1;\n    \
    \    if ($char !~ /^[A-Z]/) {\n            die \"Bad extension name: $extension\
    \ \\n\";\n        }\n        my $c = $char - ord('A');\n        my $s = $len -\
    \  $c - 1;\n        $max_extension_strength = -1 if ($max_extension_strength <\
    \ $s);\n        \n        if ($max_extension_strength < $c) {\n            $max_extension_strength\
    \ = $c;\n            $max_extension = $extension;\n        }\n    }\n    return\
    \ $class_name . '.' . $max_extension;\n}", "    \n    my $strongest = 0;\n   \
    \ my $strongest_name;\n    my $i = 0;\n    my $current_class_name = $class_name;\n\
    \    foreach $extension(@$extensions) {\n        $strongest = 0;\n        $strongest_name\
    \ = \"\";\n        $i = 0;\n        foreach $char_extension($extension) {\n  \
    \          $current_char_extension = $char_extension;\n            $current_char_extension\
    \ =~ tr/A-Z/a-z/;\n            ($current_char_extension eq $char_extension) ?\
    \ $strongest++ : $strongest--;\n            $strongest_name .= $current_char_extension;\n\
    \        }\n        $strongest_name =~ tr/A-Z/a-z/;\n        $strongest += $strongest_name\
    \ =~ tr/A-Za-z/A-Z/;\n        \n        if ($strongest == 0) {\n            $strongest--;\n\
    \            $strongest_name =~ tr/A-Za-z/A-Z/;\n        }\n        \n       \
    \ my $extension_class;\n        if ($strongest > 0) {\n            $extension_class\
    \ = $current_class_name . \".\" . $strongest_name;\n        } else {\n       \
    \     $extension_class = $current_class_name;\n        }\n        \n        push\
    \ (@result, $extension_class);\n        $i++;\n    }\n    \n    my $strongest_extension;\n\
    \    foreach $extension(@result) {\n        last if $strongest_extension = $extension;\n\
    \    }\n    return $strongest_extension;\n}", "    my $strongest_extension;\n\
    \    my %strength;\n    for my $extension (@$extensions) {\n        ($strongest_extension)\
    \ = split (/\\./, $extension);\n        $strength{$strongest_extension} = $extension\
    \ =~ tr/A-Z/a-z/;\n    }\n    $strongest_extension = $strongest_extension \n \
    \       unless defined $strongest_extension;\n    my $strength = $strength{$strongest_extension};\n\
    \    \n    my $strength_sorted = sort {$strength{$b} <=> $strength{$a}} \n   \
    \                             keys %strength;\n    $strongest_extension = $strongest_extension\n\
    \        unless defined $strongest_extension;\n    $strongest_extension = $strongest_extension\n\
    \        unless exists $strength_sorted[0]; ", "    my $sorted_extensions = $extensions;\n\
    \    my $strength = 0;\n    my @extension;\n    foreach my $extension (@$extensions)\
    \ {\n        my @cap = split('', $extension);\n        if ($cap[0] =~ /^[A-Z]/)\
    \ {\n            $strength = $cap[0] =~ tr/A-Z//;\n            push(@extension,\
    \ $extension);\n        }\n    }\n    foreach my $extension (@extension) {\n \
    \       my @cap = split('', $extension);\n        $cap[0] =~ tr/A-Z//;\n     \
    \   my $diff = $cap[0] - $strength;\n        if ($diff != 0) {\n            $sorted_extensions\
    \ = @$extensions;\n            $strength = $cap[0];\n        }\n    }\n    $sorted_extensions[0]\
    \ = $class_name . '.' . $sorted_extensions[0];\n    $sorted_extensions = sort\
    \ { $a <=> $b } @$sorted_extensions;\n    return $sorted_extensions[0];\n}", " \
    \   my %extension_count;\n    foreach my $extension (@$extensions) {\n       \
    \ $extension_count{$extension} += 1;\n    }\n    \n    $extension_count{$_} ==\
    \ 1 \n        or die \"Too many extensions for class $class_name ($extension_count{$_})\"\
    \n        for keys %extension_count;\n    $extension_count{$_} > 1\n        or\
    \ die \"Not enough extensions for class $class_name ($extension_count{$_})\"\n\
    \        for values %extension_count;\n    $extension_count{$_} == 2\n       \
    \ or die \"Not a unique extension for class $class_name ($extension_count{$_})\"\
    \n        for values %extension_count;\n    $extension_count{$_} == 0 and die\
    \ \"No extensions for class $class_name found\";\n    \n    my $strongest = $_;\n\
    \    foreach my $extension (@$extensions) {\n        if ($extension_count{$extension}\
    \ > 1) {\n            $strongest = substr($strongest, 0, -length($extension))\
    \ . $extension;\n        }\n    }\n    \n    return $strongest;\n}", "    \n \
    \   my $strongest = -1;\n    \n    for my $extension (@$extensions) {\n      \
    \  # Calculate the strength of the extension\n        my $strength = length($class_name);\n\
    \        for ($strength) {\n            my $next_letter = substr($class_name,\
    \ $strength, 1);\n            last if ($next_letter =~ /[A-Z]/);\n           \
    \ $strength--;\n        }\n        \n        if ($strength > $strongest) {\n \
    \           $strongest = $strength;\n        }\n    }\n    \n    return \"$class_name.$strongest\"\
    ;\n}", "    my $strongest_extension = \"\";\n    \n    foreach my $extension (@$extensions)\
    \ {\n        # Extract all possible CAP letters\n        my @caps = split(//,\
    \ $extension);\n        my $cap_count = 0;\n        \n        # Extract all possible\
    \ SM letters\n        my @sms = split(//, $class_name);\n        my $sm_count\
    \ = 0;\n        \n        # Find how many CAP letters there are and how many SM\
    \ letters there are\n        foreach my $cap_letter (@caps) {\n            $cap_count\
    \ += length($cap_letter);\n        }\n        foreach my $sm_letter (@sms) {\n\
    \            $sm_count += length($sm_letter);\n        }\n        \n        #\
    \ Find the ratio between CAP and SM\n        my $ratio = $cap_count - $sm_count;\n\
    \        if ($ratio < 0) {\n            $ratio = -$ratio;\n        }\n       \
    \ \n        # Keep the strongest extension\n        if ($ratio > $strongest_extension)\
    \ {\n            $strongest_extension = $extension;\n        }\n    }\n    \n\
    \    return $strongest_extension;\n}", "    \n    my @sorted_extensions = sort\
    \ {$a <=> $b} @$extensions;\n    my $best_extension = $sorted_extensions[0];\n\
    \    for (my $i = 1; $i < @sorted_extensions; $i++) {\n        my $current_strength\
    \ = ($sorted_extensions[$i] - $sorted_extensions[$i-1]);\n        if ($current_strength\
    \ > 0) {\n            $best_extension = $sorted_extensions[$i];\n            last;\n\
    \        }\n    }\n    \n    return $class_name.\".\".$best_extension;\n}", " \
    \   my $strongest;\n    for my $extension (@$extensions) {\n        my ($name,\
    \ $strength) = split '[A-Z]';\n        $strength //= 1;\n        $strength *=\
    \ -1;\n        if ($strength > $strongest) {\n            $strongest = $extension;\n\
    \        }\n    }\n    return $class_name . \".\" . $strongest;\n}\n</code>\n\
    <|/ a tags=perl,class,arrays |>\n<| c |>\nThanks, this is much simpler. I will\
    \ accept your answer once the time limit allows me.\n<|/ c |>\n<| c |>\nThank\
    \ you for the answer, but it appears that when `Strongest_Extension` is called\
    \ on a class with no extensions, it returns `\"my_class.\"`. Can you explain why?\n\
    <|/ c |>\n<| a dscore=2 |>\nA quick solution would be to sort the array in descending\
    \ order, then pick the first item from the sorted array.\n<code>", "    my($extension_strongest)\
    \ = undef;\n    my($highest_strength) = undef;\n    foreach my $extension (@$extensions)\
    \ {\n        my($extension_strength) = $extension =~ /([A-Z])([A-Z])/;\n     \
    \   if ($extension_strength > $highest_strength) {\n            $highest_strength\
    \ = $extension_strength;\n            $extension_strongest = $extension;\n   \
    \     }\n    }\n    return \"$class_name.$extension_strongest\";\n}", "    my($best_extension)\
    \ = \"\";\n    my($best_extension_strength) = -1;\n    my($extension_strength)\
    \ = (-1);\n    my($extension) = \"\";\n    my($first_extension) = \"\";\n    my($best_extension_count)\
    \ = 0;\n    my($extension_count) = 0;", "    my $strongest = \"undef\";\n    my\
    \ $counter = 0;\n    foreach my $extension (@$extensions) {\n        $counter\
    \ += $extension =~ tr/A-Z//;\n    }\n    $strongest = \"$class_name.$extensions[$counter\
    \ - 1]\";\n    return $strongest;\n}", "    # Your code here.\n    my $strongest_extension\
    \ = \"\";\n    my $strongest_extension_strength = -1;\n    my $count = 0;\n  \
    \  foreach my $extension (@$extensions){\n        my @classes = split(' ',$extension);\n\
    \        my $length = scalar(@classes);\n        foreach my $classname (@classes){\n\
    \            if($classname =~ /^([A-Z])/){\n                my $counter = 0;\n\
    \                foreach my $other (@classes){\n                    if($other\
    \ =~ /^([A-Z])/){\n                        $counter++;\n                    }\n\
    \                }\n                if($counter < $length){\n                \
    \    $strongest_extension = $extension;\n                    $strongest_extension_strength\
    \ = $classname;\n                }\n            }\n            if($classname =~\
    \ /^([a-z])/){\n                my $counter = 0;\n                foreach my $other\
    \ (@classes){\n                    if($other =~ /^([a-z])/){\n               \
    \         $counter++;\n                    }\n                }\n            \
    \    if($counter < $length){\n                    $strongest_extension = $extension;\n\
    \                    $strongest_extension_strength = $classname;\n           \
    \     }\n            }\n        }\n    }\n    return $strongest_extension;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=regex,algorithm,perl,arrays dscore=0 |>\n\
    Here is an implementation in Perl, which should be fairly straightforward to read,\
    \ understand, and modify.\n<code>\nuse warnings;\nuse strict;", "    $class_name\
    \ =~ s/[\\\\\\/]//g; \n    my $highest_strength = 0;\n    $class_name =~ s/([A-Z]{1}[A-Z])([a-z]{1}|[A-Z]{1})/$1_$2/g;\n\
    \    $class_name =~ s/([A-Z]{1}[a-z])([A-Z]{1}|[a-z]{1}|[A-Z]{1}[a-z])/$1_$2/g;\n\
    \    for my $extension (@$extensions) {\n        $extension =~ s/[\\\\\\/]//g;\n\
    \        my ($cap,$sm) = split(/\\_/, $extension);\n        $cap =~ tr/a-zA-Z//d;\n\
    \        $sm =~ tr/a-zA-Z//d;\n        my $strength = $cap - $sm;\n        if\
    \ ($strength > $highest_strength) {\n            $highest_strength = $strength;\n\
    \            $best_extension = $extension;\n        }\n    }\n    return $class_name\
    \ . \".\" . $best_extension;\n}", "    my $total_length = length($class_name);\n\
    \    my $current_length = length($extensions[0]);\n    my $best_index = -1;\n\
    \    my $best_extension;\n    my $best_strength = -1;\n    for (my $i = 0; $i\
    \ < @$extensions; $i++) {\n        my $current_length = length($extensions[$i]);\n\
    \        if ($current_length > $best_length) {\n            $best_length = $current_length;\n\
    \            $best_index = $i;\n            $best_extension = $extensions[$i];\n\
    \        }\n    }\n    return $class_name . \".\" . $best_extension;\n}", "  \
    \  my $best_extension;\n    $best_extension = 0;", "    my $strongest = \"\";\n\
    \    my $count; \n    my $max_count; \n    my $count2 = 0;\n    my $max_count2\
    \ = 0;\n    foreach my $ext (@$extensions) {\n        $count = 0; $count2 = 0;\n\
    \        $max_count = 0; $max_count2 = 0;\n        foreach my $char (split(//,\
    \ $ext)) {\n            if (substr($char, 0) ne \"-\") {\n                my $count\
    \ = substr($char, 1) =~ tr/A-Z//;\n                if ($count > $max_count) {\n\
    \                    $max_count = $count;\n                    $strongest = $ext;\n\
    \                }\n            } elsif (substr($char, 1) ne \"-\") {\n      \
    \          my $count2 = substr($char, 0) =~ tr/a-z//;\n                if ($count2\
    \ > $max_count2) {\n                    $max_count2 = $count2;\n             \
    \       $strongest = $ext;\n                }\n            }\n        }\n    }\n\
    \    return $class_name.$strongest;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=perl,php,java\
    \ dscore=2 |>\nI guess that you are looking for the shortest extension.\nIf yes,\
    \ you can solve this with a DFS (Depth First Search) algorithm.\n<|/ a |>\n<|\
    \ a |>\nIf you were allowed to use regex to do this (which you probably should),\
    \ you could do something like:\n<code>\nmy $input = 'my_class.ABCDEFG';\nmy $result\
    \ = $input =~ /\n  (\\w+) \n  (?= \n      (?: \n          \\. \n          (?:\
    \ \n              [A-Z] \n              | [a-z] \n              | [A-Za-z] \n\
    \          )* \n      )? \n  )\n/x;\n</code>\nAnd then $result would contain the\
    \ name of the extension that was the shortest.\nEDIT: Oops, I missed the \"no\
    \ regex\" requirement. Not sure how easy that is in Perl, but it's quite straightforward\
    \ in Python, for example:\n<code>\ns = 'my_class.ABCDEFG'\ns = re.sub(r'(\\w+)(?=.*?(?:\\\
    .[A-Z]|\\.[a-z]|\\.[A-Za-z]))', r'\\1', s)\n</code>\n<|/ a tags=perl,php,java\
    \ dscore=2 |>\n<| c |>\nThis fails if the first character is a period, e.g. 'my_class.ABC.DEFG'\
    \ gives 'ABC'.\n<|/ c |>\n<| c |>\nYeah, it seems like that would be a problem.\
    \ I'm leaving the answer because it solves the question as originally phrased,\
    \ but it's not the best way to solve this ", "    my @strongest_extensions = ();\n\
    \    my $class_name_len = length($class_name);\n    foreach my $extension (@$extensions)\
    \ {\n        my $extension_len = length($extension);\n        if ($class_name_len\
    \ > $extension_len) {\n            $class_name_len = $extension_len;\n       \
    \ }\n        if ($class_name_len < $extension_len) {\n            push @strongest_extensions,\
    \ $extension;\n        }\n    }\n    my $strongest_extension = \n        $class_name\
    \ . \"\\\"\" . \n        join(\"\", @strongest_extensions) . \"\\\"\";\n    return\
    \ $strongest_extension;\n}", "    my @extension_strength = map { length $_} @extensions;\n\
    \    my $strength;\n    my $index;\n    foreach my $e (@extension_strength) {\n\
    \t$index = 0;\n\tforeach my $ext (@extensions) {\n\t    if ($e eq $ext) {\n\t\t\
    $strength = $e;\n\t\tlast;\n\t    }\n\t    $index++;\n\t}\n\tif ($index > 1) {\n\
    \t    $index--;\n\t}\n    }\n    $strength ? $class_name . $extensions[$index]\
    \ : $class_name;\n}", "    my (@extensions);\n    my $strongest;", "    my $result\
    \ = '';\n    my $strength = 0;\n    foreach my $extension (@$extensions) {\n \
    \       if(substr($extension, 0, 1) eq substr($class_name, 0, 1)) {\n        \
    \    $strength = substr($extension, 0, 1) - (substr($class_name, 0, 1));\n   \
    \     }\n        if($strength > 0) {\n            $result = $extension;\n    \
    \    }\n    }\n    return $result;\n}", "    my @extension_hash;\n    my %hash;\n\
    \    my @sorted_extensions;\n    foreach my $extension (@$extensions) {\n    \
    \    my $first_letter = substr($extension, 0, 1);\n        $hash{$first_letter}\
    \ += 1;\n        $extension_hash[$first_letter] .= \"$class_name$extension\";\n\
    \    }\n    my @sorted_extensions_hash = sort {$hash{$a} <=> $hash{$b}} keys %hash;\n\
    \    foreach my $extension_name (@sorted_extensions_hash) {\n        push @sorted_extensions,\
    \ $extension_hash{$extension_name};\n    }\n    if (@sorted_extensions > 1) {\n\
    \        foreach my $extension (@sorted_extensions) {\n            my $strength\
    \ = substr($extension, 0, 1);\n            foreach my $extension_name (@sorted_extensions_hash)\
    \ {\n                my $second_letter = substr($extension_name, 0, 1);\n    \
    \            if ($second_letter eq $strength) {\n                    return $extension_hash{$extension_name};\n\
    \                }\n            }\n        }\n    }\n    else {\n        return\
    \ $extension_hash{sorted_extensions[0]};\n    }\n}\n</code>\n<|/ a dscore=3 tags=ruby,regex\
    \ |>\n<| c |>\nThanks, this was the most helpful.\n<|/ c |>\n<| a dscore=2 |>\n\
    I think this is what you are looking for:\n<code>\nclass String\n  def strongest_extension\n\
    \    str.scan(/(\\p{Uppercase})/).sort_by { |e| e.length }.first\n  end\nend\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| a tags=ruby,regex |>\nHere's a quick and\
    \ dirty regexp that you could use, assuming the extension names are always two\
    \ characters:\n<code>\n/([A-Z]{2})(?=.*\\1)/ \n</code>\nThis matches the uppercase\
    \ letter in group 1, and then matches anything that is after it.  After that it\
    \ looks to see if the next letter is also the same as the letter in group 1. \
    \ In other words, if the first letter matched is \"A\", the regexp would match\
    \ \"A\", but then match \"Ab\", \"Abe\", and \"Abbe\".\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThanks for the help!  I tried this regex but it still returned me a nil\
    \ result.  I modified it a bit to this:\n    /([A-Z]{2})/", '    my $min_strength
    = -1;', "    my ($i, $ext, $strongest, $num_upper, $num_lower);\n    $strongest\
    \ = \"\";\n    $num_upper = 0;\n    $num_lower = 0;\n    for ($i = 0; $i < @$extensions;\
    \ $i++) {\n        $ext = &$extensions[$i];\n        if ($ext =~ /[A-Z]/) {\n\
    \            $num_upper++;\n        } elsif ($ext =~ /[a-z]/) {\n            $num_lower++;\n\
    \        } else {\n            last;\n        }\n    }\n    $strongest = \"$class_name.$extensions[0]\"\
    ;\n    if ($num_upper == $num_lower) {\n        if ($num_upper == 0) {\n     \
    \       $strongest = \"$class_name.$extensions[1]\";\n        }\n        if ($num_lower\
    \ == 0) {\n            $strongest = \"$class_name.$extensions[2]\";\n        }\n\
    \    }\n    return $strongest;\n}", "    my @extensions = @$extensions;\n    my\
    \ $max_strength = -1;\n    my $extension;\n    for ($extension = 0; $extension\
    \ < scalar(@extensions) && $extensions[$extension] > $max_strength; ++$extension)\
    \ {\n    }\n    for ($extension = 0; $extension < scalar(@extensions) && $extensions[$extension]\
    \ > $max_strength; ++$extension) {\n    }\n    return $class_name . \".\" . $extensions[$extension];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for this answer. I was able to get it\
    \ working on my own but this was a huge help. I appreciate it.\n<|/ c |>\n<| c\
    \ |>\nGlad to help :) Let me know if you need any further help, and I'll do my\
    \ best to assist you further as best I can.\n<|/ c |>\n<| c |>\nThanks for the\
    \ help. I added some more info in my main post because i need to keep track of\
    \ what classes are being added from the user input and also need to keep track\
    \ of what extensions are being loaded into the application. Could you please help\
    \ me with that as well ? Much appreciated.\n<|/ c |>\n<| c |>\nI made a slight\
    \ modification to my answer that seems to work fine for your scenario. I've added\
    \ comments to the code, hope it helps. I haven't tested it, but this might work\
    \ better\n<|/ c |>\n<| c |>\nI've just tested it now, and it seems to work just\
    \ fine. Let me know if you have any further questions.\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\nThe answer is rather simple.\n<code>\nuse 5.010;\nuse Data::Dumper;", " \
    \   \n    my @extensions_sorted = sort { $a->[0] cmp $b->[0] } @$extensions;\n\
    \    my ($extension, $strength) = @extensions_sorted[0];\n    \n    for (my $i\
    \ = 1; $i < @$extensions; $i++) {\n        my $extension_strongest = @$extensions[$i][0];\n\
    \        if ($extension_strongest ne $extension) { next; }\n        $strength\
    \ = $extensions_sorted[$i][1] - $extensions_sorted[$i-1][1];\n    }\n    return\
    \ $class_name.\".\".$extension;\n}\n</code>\nNow that I've written that, how do\
    \ we load those classes and use them?  We could use a little help.  First we create\
    \ an array containing the files that the extensions need to load.  We can use\
    \ File::Find::Rule to find all the files that match the extension names.  Then\
    \ we load all those files into a single array which we can use to load the extensions:\n\
    <code>", "    my $stongest_extension = undef;\n    foreach my $extension (@$extensions)\
    \ {\n        my $stongest_extension_number = uc($extension) =~ tr/A-Z//;\n   \
    \     if ($stongest_extension_number > $stongest_extension) {\n            $stongest_extension\
    \ = $stongest_extension_number;\n        }\n    }\n    if ($stongest_extension\
    \ != 0) {\n        return $class_name . '.' . $stongest_extension;\n    } else\
    \ {\n        return 'No extensions found with this name.';\n    }\n}", "    my\
    \ $counter = 0;\n    my $extension_class = $class_name . '::' . $extensions[0];\n\
    \    foreach my $extension (@{$extensions[1..$#extensions]}) {\n        $counter++\
    \ if length($class_name . '::' . $extension) < length($extension_class);\n   \
    \     $extension_class = $class_name . '::' . $extension if length($class_name\
    \ . '::' . $extension) > length($extension_class);\n    }\n    my $strength =\
    \ -1;\n    return $extension_class if $counter > 0;\n    foreach my $extension\
    \ (@{$extensions[1..$#extensions]}) {\n        $strength++ if $extension eq $extension_class;\n\
    \    }\n    return $class_name . '::' . $extensions[0] if $strength == 0;\n  \
    \  my $strongest_extension = $class_name . '::' . $extensions[0];\n    foreach\
    \ my $extension (@{$extensions[1..$#extensions]}) {\n        $strongest_extension\
    \ = $extension if length($class_name . '::' . $extension) > length($strongest_extension);\n\
    \    }\n    return $strongest_extension;\n}", "    my($class_name_lower, $extensions_lowercase)\
    \ = lc($class_name).lc(@_);\n    my($i, $j, $strongest_ext, $strongest_ext_lower,\
    \ $strength);\n    \n    foreach $extension (@$extensions) {\n        $strength\
    \ = -1;\n        $strongest_ext = $extension;\n        foreach $extension_lowercase\
    \ (@$extensions_lowercase) {\n            $j = 0;\n            foreach $class_name_lower\
    \ (@$class_name_lower) {\n                $j += ord(substr($class_name_lower,\
    \ $j)) ^ ord(substr($extension_lowercase, $j));\n            }\n            if\
    \ ($strength >= 0) {\n                if ($strength > $j) {\n                \
    \    $strength = $j;\n                    $strongest_ext = $extension;\n     \
    \           }\n            } else {\n                $strength = $j;\n       \
    \         $strongest_ext = $extension;\n            }\n        }\n        next\
    \ unless $strength > 0;\n    }\n    \n    return $class_name.$strongest_ext;\n\
    }", "    my %strongest;\n    my %seen;\n    foreach my $extension (@$extensions)\
    \ {\n        my $num_upper = length($extension) - length($extension) \n      \
    \               - length($extension) % 2 \n                     - 1 \n       \
    \              % 2;\n        my $num_lower = length($extension) - length($extension)\
    \ \n                        - length($extension) % 2\n                       \
    \ + 1 \n                        % 2;\n        if (! defined($strongest{$extension}))\
    \ {\n            $strongest{$extension} = \n                    ($num_upper >\
    \ $num_lower) ? $extension : \n                    $extension;\n        }\n  \
    \      else {\n            my $strength = \n                    $num_upper > $num_lower\
    \ \n                    ? $num_upper \n                    : $num_lower;\n   \
    \         my $exists = defined($seen{$extension});\n            $seen{$extension}\
    \ = 1;\n            $strongest{$extension} .= \n                    $exists ?\
    \ \"_$strength\" : $extension;\n        }\n    }\n    return $class_name . $strongest{$_}\
    \ for keys %strongest;\n}", "    my $max_strength = -1;\n    my $max_extension\
    \ = \"\";\n    my $index = 0;\n    \n    for(my $i = 0; $i < @$extensions; $i++)\
    \ {\n        my $extension = $$extensions[$i];\n        my $strength = length($extension)\
    \ - length($class_name);\n        if($strength > $max_strength) {\n          \
    \  $max_strength = $strength;\n            $max_extension = $extension;\n    \
    \    }\n    }\n    return $max_extension;\n}", "    my($strongest_extension) =\
    \ undef;\n    my($total_extensions) = undef;\n    $total_extensions = scalar@$extensions;\n\
    \    foreach $extension (@$extensions) {\n        ($strongest_extension) = length($extension);\n\
    \        if ($strongest_extension < $total_extensions) {\n            foreach\
    \ $exension (@$extensions) {\n                if ($strongest_extension < length($exension))\
    \ {\n                    ($strongest_extension) = length($exension);\n       \
    \             last;\n                }\n            }\n        }\n    }\n    return\
    \ $class_name.$strongest_extension;\n}\n</code>\n<|/ a tags=perl,arrays dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "    my $result = '';\n    foreach my $extension\
    \ (@{$extensions}) {\n        my $cap = substr($extension, 0, 1);\n        my\
    \ $sm = substr($extension, 0, 1);\n        $cap =~ tr/A-Z//cd;\n        $sm =~\
    \ tr/a-z//cd;\n        if ($cap - $sm >= 0) {\n            $result .= $class_name\
    \ . \"_\" . $extension;\n        } else {\n            $result .= $class_name\
    \ . \"_\" . $extension . '.' . $extension;\n        }\n    }\n    $result;\n}",
  "    \n    my @extensions_hash = ();\n    for my $extension (@$extensions) {\n \
    \       my $extension_hash = Hash::Util::FieldValue($extension);\n        $extensions_hash{$extension_hash}++;\n\
    \    }", "    $class_name =~ s/\\s+//;\n    $class_name .= 'Class';", "    my\
    \ ($c, $e) = split /([A-Z])/, $class_name;\n    my %extensions_found = map { ($e\
    \ . $_) => 1 } @$extensions;\n    my ($best_found) = (0, 0);\n    for (my $i =\
    \ 0; $i < @$extensions; $i++) {\n        if ($extensions_found{$e}{$extensions[$i]})\
    \ {\n            my $strength = ($i + $best_found) % 2 ? -1 : 0;\n           \
    \ if ($strength > $best_found) {\n                $best_found = $strength;\n \
    \           }\n        }\n    }\n    return $class_name . \".\" . $extensions[$best_found];\n\
    }", "    my @sorted_extensions = sort({$a <=> $b});\n    return $class_name .\
    \ \".\" . join(\".\",@sorted_extensions);\n}", "    my %classes_by_strength;\n\
    \    my @extensions_by_strength;\n    for (my $i=0; $i < @$extensions; ++$i) {\n\
    \        $classes_by_strength{$extensions[$i]} = $i;\n        push @extensions_by_strength,\
    \ $extensions[$i];\n    }\n    # Sort by strength\n    @extensions_by_strength\
    \ = sort {\n        $classes_by_strength{$a} <=> $classes_by_strength{$b}\n  \
    \  } @extensions_by_strength;\n    my $strongest_extension = @extensions_by_strength;\n\
    \    # If multiple extensions have the same strongest strength, choose the first\
    \ one.\n    if (scalar @extensions_by_strength > 1) {\n        $strongest_extension\
    \ = $extensions_by_strength[0];\n    }\n    return $class_name.$strongest_extension;\n\
    }", "    my $best_strongest_extension;\n    my $best_extension_strength;\n   \
    \ \n    for my $extension (@$extensions) {\n        my $class_name_extension =\
    \ substr($class_name, 0, length($class_name) - length($extension));\n        if\
    \ (length($class_name_extension) > length($extension)) {\n            $class_name_extension\
    \ =~ tr/[A-Z]/[a-z]/;\n        }\n        if (length($class_name_extension) >\
    \ length($best_extension_strength)) {\n            $best_extension_strength =\
    \ length($class_name_extension);\n            $best_strongest_extension = $class_name_extension;\n\
    \        }\n    }\n    if (length($best_strongest_extension) > 0) {\n        return\
    \ $class_name . '.' . $best_strongest_extension;\n    } else {\n        return\
    \ $class_name . '.' . $extensions[0];\n    }\n}", "    my $strongest_extension\
    \ = \"\";\n    my $extensions_count = @$extensions;\n    my $extensions_count_cap\
    \ = uc($extensions_count);\n    my $extensions_count_low = uc($extensions_count\
    \ - $extensions_count_cap);\n    my $strength = $extensions_count_cap - $extensions_count_low;\n\
    \    $strongest_extension = $class_name . \".\" . $extensions[0] if ($extensions_count\
    \ > 1);\n    for my $i (1 .. $extensions_count - 1){\n        my $extension =\
    \ $extensions[$i];\n        $strongest_extension = $class_name . \".\" . $extension\n\
    \            if ($extensions_count_cap - $i >  $extensions_count_low);\n     \
    \   $strength = $extensions_count_cap - $i if ($extensions_count_cap - $i < $extensions_count_low);\n\
    \    }\n    $strongest_extension =~ s/\\W+//g;\n    return $strongest_extension;\n\
    }", "    $class_name =~ /^(?=[a-zA-Z])/;\n    $class_name = $class_name[0];\n\
    \    my $total = 1;\n    foreach my $extension (@$extensions) {\n        $extension\
    \ =~ /^([a-z])/;\n        $extension = $extension[1];\n        $total += length($extension);\n\
    \    }\n    my $strongest_extension = $extensions[$total - 1];\n    return $class_name.\"\
    .\".$strongest_extension;\n}\n</code>\n<|/ a tags=algorithm,code-golf,language-agnostic\
    \ dscore=4 |>\n<| c |>\nGreat answer, thanks! Just out of curiosity, why did you\
    \ choose your extensions array? I thought the algorithm was more complex than\
    \ that. Would you be able to explain the benefits of your extensions array?\n\
    <|/ c |>\n<| c |>\nIt depends on the complexity of the extensions, but usually\
    \ the ones which come immediately after the class name tend to be relatively more\
    \ complex, and the ones which come next tend to be less so. Of course, it would\
    \ also be possible to have a single extension which covers all of the cases, but\
    \ that would be really annoying to code.\n<|/ c |>\n<| c |>\nI don't think your\
    \ code is correct for classes with two or more extensions having the same strength.\
    \ Consider this example: my_class.AB and my_class.BC. Both have an A, and B, so\
    \ the strongest extension is AB. Your code returns my_class.AB rather than my_class.ABC.\n\
    <|/ c |>\n<| c |>\n: I think the only thing worth noting is that \"ABC\" comes\
    \ before \"AB\", so the strongest extension (according to the code) is ABC.\n\
    <|/ c |>\n<| c |>\nYes, and that's why it's important to think of the extensions\
    \ in reverse order in the `@extensions` array. Your code is actually correct but\
    \ only because you used a reverse order.\n<|/ c |>\n<| a dscore=3 tags=algorithm,code-golf,language-agnostic\
    \ |>\nPython\n<code>\ndef Strongest(class_name,extensions):\n  s=1\n  for x in\
    \ extensions[::-1]:\n    for y in extensions:\n      if x[-1]==y[-1]:\n      \
    \  s+=1\n  if s==2:\n    return class_name\n  x=[]\n  for y in extensions:\n \
    \   x+=y[:-1]\n  return class_name + \".\" + x.pop()\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis fails for two extensions with the same number of characters, because\
    \ `x[-1]` will return the first character, which would not be unique", "    my\
    \ %extension_map;\n    my $total_extension_count = 0;\n    my $strongest = \"\"\
    ;\n    foreach my $extension (@$extensions) {\n        # Split string into first\
    \ letter counts\n        my($first, $second) = split //, $extension;\n       \
    \ next if $first eq '-';\n        my $extension_count = uc $first - uc $second;\n\
    \        $extension_count = $total_extension_count + $extension_count;\n     \
    \   $extension_count = 0 if $extension_count == 0;\n        $extension_count =\
    \ 1 if $extension_count == 1;\n        \n        # Store extension names in hash\
    \ for fast searching\n        $extension_map{$extension_count} = $extension;\n\
    \        $total_extension_count = $extension_count;\n    }", "    my %extension_count;\n\
    \    my $strongest_extension = \"\";", "    my @sorted_extensions = sort { $a\
    \ <=> $b} @$extensions;\n    $sorted_extensions[0]->[0];\n}", "    my %strongest;\n\
    \    for my $extension (@{$extensions}) {\n        my $class = $class_name . \"\
    .\" . $extension;\n        if ($strongest{$extension}) {\n            last if\
    \ $strongest{$extension} < $class;\n            $strongest{$extension} = $class;\n\
    \        }\n        else {\n            $strongest{$extension} = $class;\n   \
    \     }\n    }\n    my $strongest_extension = grep($strongest{$_}, sort {$strongest{$a}\
    \ <=> $strongest{$b}} keys %strongest);\n    return $strongest_extension;\n}",
  "    my $max = 0;\n    foreach my $extension (@$extensions) {\n        my $len =\
    \ length($extension);\n        if($len > $max) {\n            $max = $len;\n \
    \       }\n    }\n    return $class_name.$extensions[$max];\n}", "    my($strength);\n\
    \    my @extension_map;\n    foreach my $ext (@$extensions) {\n        # map each\
    \ extension to a unique integer index\n        my $index = map { length $_ } map\
    \ { lc $_ } split //, $ext;\n        $extension_map[$index] = $ext;\n    }\n \
    \   my $max_strength_extension = 0;\n    $max_strength_extension = $extension_map[$max_strength_extension]\
    \ if (defined $max_strength_extension);\n    foreach my $index (0 .. $#extension_map)\
    \ {\n        $index = $index + 1 if ($extension_map[$index] eq $max_strength_extension);\n\
    \        $strength = $index - $max_strength_extension if $extension_map[$index]\
    \ > $max_strength_extension;\n        if ($strength > 0) {\n            $max_strength_extension\
    \ = $index;\n        }\n    }\n    if (defined $max_strength_extension) {\n  \
    \      return $class_name . '.' . $extension_map[$max_strength_extension];\n \
    \   }\n}", "    my $total_num_chars = length $class_name;\n    foreach my $extension\
    \ (@{$extensions}) {\n        my $chars = length $extension;\n        $chars =\
    \ $total_num_chars - $chars if ($chars == 0);\n        my $strength = $chars -\
    \ uc($extension);\n        $strength = -1 if ($strength == 0);\n        if ($strength\
    \ eq $total_num_chars) {\n            return $class_name . $extension;\n     \
    \   }\n        if ($strength eq ($total_num_chars - 1)) {\n            return\
    \ $class_name . uc($extension) . $extension;\n        }\n    }\n}", "    my %strength;\n\
    \    for my $extension (@$extensions) {\n        my ($class, $strength) = @$extension\
    \ =~ m/(\\w+)(\\d+)/;\n        $strength{$class} = $strength if $strength >= 0;\n\
    \    }\n    my $result = $class_name;\n    foreach my $class (keys %$strength)\
    \ {\n        if ($strength{$class} > 0) {\n            $result .= \".$class\"\
    ;\n            $result = $class_name if $result == $class_name;\n        }\n \
    \   }\n    $result;\n}", "    my $total_upper = 0;\n    my $total_lower = 0;\n\
    \    my $strength = -1;", "    my($class, $extension);\n    $class_name =~ s/^.*\\\
    ././;\n    foreach $extension (@$extensions) {\n        my @chars = split(//,\
    \ $extension);\n        my $num = -1;\n        my $max_char = 0;\n        foreach\
    \ my $c (@chars) {\n            my $lc = length($c);\n            $num += $lc\
    \ if $lc > $max_char;\n            $max_char = $lc;\n        }\n        $num -=\
    \ 1;\n        if ($num < 0) {\n            $num = 0;\n        }\n        my $strength\
    \ = length($class_name) - length($extension);\n        if ($strength > 0 && $strength\
    \ <= $num) {\n            return \"$class_name.$extension\";\n        }\n    }\n\
    }", "    my $best_extension = 0;\n    my $best_strength = 0;\n    for my $extension\
    \ (@$extensions) {\n        $best_strength = length($extension) - length($class_name);\n\
    \        if ($best_strength > 0) {\n            $best_extension++;\n        }\n\
    \    }\n    if ($best_extension == 1) {\n        return $class_name . '.' . $extensions[0];\n\
    \    }\n    my $strength_str = substr($extensions[$best_extension], 0, 1);\n \
    \   if ($best_strength > 0) {\n        $strength_str .= substr($class_name, 0,\
    \ $best_strength);\n    } else {\n        $strength_str .= substr($class_name,\
    \ 0, length($class_name));\n    }\n    return $class_name . '.' . $extensions[$best_extension];\n\
    }", "    my $strongest = substr($class_name,length($class_name));\n    foreach\
    \ my $extension (@{$extensions}) {\n        $strongest .= \".$extension\" if substr($extension,0,length($strongest))\n\
    \            == $strongest;\n    }\n    return $strongest;\n}", "    my $strength\
    \ = -1;\n    my $strongest = undef;\n    foreach my $ext(@{$extensions}) {\n \
    \       $strength = uc($ext) cmp $strength;\n        $strongest = $ext if $strength\
    \ > 0;\n    }\n    return $class_name . \".\" . $strongest;\n}", "    my $num_caps\
    \ = 0;\n    my $num_lows = 0;\n    foreach my $extension(@$extensions) {\n   \
    \     if ($extension =~ /[A-Z]/) {\n            $num_caps++;\n        }\n    \
    \    if ($extension =~ /[a-z]/) {\n            $num_lows++;\n        }\n    }\n\
    \    return $class_name.\".\".$extensions[0] if $num_caps - $num_lows > 0;\n \
    \   return $class_name.\".\".$extensions[0] if $num_caps - $num_lows == 0;\n \
    \   return $class_name.\".\".$extensions[0] if $num_lows < $num_caps;\n    return\
    \ $class_name.\".\".$extensions[0] if $num_lows == $num_caps;\n    return $class_name.\"\
    .\".$extensions[0];\n}", "    my @extensions_strength = ();\n    foreach my $extension\
    \ (@{$extensions}) {\n        my $class = lc($class_name);\n        $class .=\
    \ \".$extension\";\n        my $strength = length $class - length lc($class);\n\
    \        if (!defined $extensions_strength->[$strength]) {\n            $extensions_strength->[$strength]\
    \ = $extension;\n        } else {\n            foreach my $i (0..$#extensions_strength)\
    \ {\n                if ($extensions_strength->[$i] == $extension) {\n       \
    \             $extensions_strength->[$i] = $extension;\n                    last;\n\
    \                }\n            }\n        }\n    }\n    return $extensions_strength->[0]\
    \ if @extensions_strength > 1;\n    my @extensions_sorted = sort {$a <=> $b} @{$extensions_strength};\n\
    \    return $extensions_sorted[0];\n}", "    my $best_strength = -1;\n    my @extension_names;\n\
    \    foreach my $extension (@$extensions) {\n        my ($extension_class_name)\
    \ = $extension =~ m/(.*?)\\Q$class_name\\E/i;\n        if ($extension_class_name\
    \ eq $class_name) {\n            push @extension_names, $extension;\n        \
    \    next if ($extension_class_name eq $extensions[0]);\n            my $strength\
    \ = @extension_names - 1;\n            $strength = -1 if ($extension_class_name\
    \ eq $extensions[0] && $best_strength < 0);\n            $best_strength = $strength\
    \ if ($strength > $best_strength);\n        }\n    }\n    return $extension_names[0]\
    \ . \"_\" . $best_strength;\n}", "    my $best = 0;\n    foreach my $ext(@{$extensions})\
    \ {\n        my $count = $class_name =~ tr/A-Z//;\n        $count -= $ext =~ tr/a-z//;\n\
    \        $count = $count < 0 ? $count : -$count;\n        if ($count > $best)\
    \ {\n            $best = $count;\n        }\n    }\n    return \"$class_name.$extensions[$best]\"\
    ;\n}", "    my($strength) = 0;\n    my($extension_class, $extension_name, $i);\n\
    \    for ($i = 0; $i < @$extensions; $i++) {\n        $extension_name = $extensions[$i];\n\
    \        $extension_class = $class_name . $extension_name;\n        my($class_object)\
    \ = $extension_class -> new();\n        if (defined $class_object && $class_object\
    \ -> valid()) {\n            $strength = ($class_object -> CAP() - $class_object\
    \ -> SM()) / $class_object -> CAP();\n        }\n    }\n    $class_name . $extension_name;\n\
    }", '    $extensions = [split(//, $extensions)];', "    my $max_strength = 0;\n\
    \    my $extension;\n    foreach $extension (@$extensions) {\n        my $strongest_ext\
    \ = substr($extension, 0, 1);\n        my $ext_strength = substr($extension, 1,\
    \ 1) eq 'z' ? 0 : $ext_strength + 1;\n        if ($ext_strength > $max_strength)\
    \ {\n            $max_strength = $ext_strength;\n            $extension = $strongest_ext;\n\
    \        }\n    }\n    return \"$class_name.$extension\";\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis does not seem to do the right thing for me with the test case\
    \ \"MyClass\" . Should it not return MyClass.AA instead of MyClass.A.\n<|/ c |>\n\
    <| c |>\nThe answer by below does seem to be the correct one. Thanks guys.\n<|/\
    \ c |>\n<| c |>\n, your answer doesn't seem to be using the correct rules for\
    \ what should be returned if there are more than one extensions with the same\
    \ strength. See my answer below.\n<|/ c |>\n<| a tags=perl,regex |>\nI don't have\
    \ perl handy right now, but you could do this:\n<code>\n/([A-Z][a-z]{2,})/\n</code>\n\
    That will match two or more capital letters, then a lowercase letter, at least\
    \ as long as you're using one lowercase letter to signify \"strength\".\nEdit:\
    \ I see you're using Perl, so here's a quick Perl script I whipped up to get you\
    \ started:\n<code>", "    my $len = length($class_name);\n    my $max = 0;\n \
    \   my $max_index = 0;\n    for (my $i = 0; $i < @$extensions; $i++) {\n     \
    \   my $strongest = \"$class_name.$extensions[$i]\";\n        if (length($strongest)\
    \ > $len) {\n            $len = length($strongest);\n            $max_index =\
    \ $i;\n        }\n        if (length($strongest) == $len) {\n            $max\
    \ = length($strongest);\n            $max_index = $i;\n        }\n    }\n    return\
    \ $class_name . \"\\.\" . $extensions[$max_index];\n}", "    my @sorted_extensions\
    \ = sort( @$extensions );\n    $_ = substr( $class_name, 0, length($class_name)\
    \ - length( $sorted_extensions[0] ) );\n    push @_, ( $sorted_extensions[0],\
    \ $_[-1] ) while $sorted_extensions[0] != $sorted_extensions[-2];\n    return\
    \ @$_;\n}", "    my($extension, $strength, $class, $name);\n    foreach $extension\
    \ (@$extensions) {\n        my $count = 0;\n        $class = $class_name;\n  \
    \      $class =~ tr/A-Z/a-z/;\n        $name =~ tr/A-Z/a-z/;\n        $strength\
    \ = length($name) - length($class);\n        $count++ while $class =~ /[A-Z]/i;\n\
    \        $count++ while $name =~ /[a-z]/i;\n        my $strength_ratio = $count\
    \ / length(split('', $class_name));\n        if($strength_ratio > $strength) {\n\
    \            $extension = $extension;\n            $strength = $strength_ratio;\n\
    \        }\n    }\n    return $extension;\n}", "    $class_name =~ s/([A-Z])/$1./g;\n\
    \    $class_name =~ s/([a-z])/$1./g;", "    $class_name =~ s/^[[:upper:]]//;\n\
    \    $class_name =~ s/[[:upper:]][[:upper:]]*$//;\n    $class_name =~ s/^([[:lower:]])/$1\\\
    E/;\n    $class_name =~ s/\\E$//;\n    return ($class_name . (\"_\". (join '',\
    \ @$extensions)));\n}", "    my($extension_counter, $extension_strength);\n  \
    \  my($extension_counter_max, $extension_strength_max);\n    \n    foreach $extension_counter\
    \ (0..($#extensions - 1)) {\n        $extension_strength[$extension_counter] =\
    \ substr($extensions[$extension_counter], 0, 1);\n    }\n    \n    $extension_counter_max\
    \ = max( @$extension_strength );\n    $extension_strength_max = max( @$extension_strength\
    \ );\n    \n    foreach $extension_counter (0..($#extensions - 1)) {\n       \
    \ if ($extension_strength[$extension_counter] eq $extension_strength_max) {\n\
    \            $extension_strength[$extension_counter] = $extension_counter_max;\n\
    \        }\n    }\n    \n    my $strongest_extension = $class_name;\n    foreach\
    \ $extension_counter (0..($#extensions - 1)) {\n        if ($extension_strength[$extension_counter]\
    \ > 0) {\n            $strongest_extension .= \".\" . $extensions[$extension_counter];\n\
    \        }\n    }\n    $strongest_extension =~ s/\\./ /g;\n    return $strongest_extension;\n\
    }\n</code>\n<|/ a dscore=3 tags=algorithm,language-agnostic,string |>\n<| c |>\n\
    I like the use of regular expressions and `substr` here. I would never have thought\
    \ of using `substr` to determine a strength of an extension. I'm sure it can be\
    \ done but I'm a little worried about efficiency when trying to determine a strength\
    \ of a lot of extensions at once. Is there any way to improve on this?\n<|/ c\
    \ |>\n<| c |>\nI wouldn't worry about efficiency until it's proven to be a problem,\
    \ and I bet you can get away with some optimizations on that front. You're definitely\
    \ welcome to experiment with these ideas and see what works for you. The code\
    \ is written and tested in Perl and it's probably not very efficient. I'll rewrite\
    \ it in a more efficient language soon.\n<|/ c |>\n<| c |>\nI rewrote it in a\
    \ language I like. Let me know if you have any questions.\n<|/ c |>\n<| a dscore=3\
    \ |>\nIt seems like the problem you are solving has a simple answer: Sort and\
    \ compare the list of extensions, then take the first one that matches.\n<code>\n\
    my_class.ABeA\nmy_class.BC\nmy_class.C\nmy_class.CBe\nmy_class.CE\nmy_class.CBeA\n\
    my_class.CBeAC\nmy_class.", "    my $strongest = -1;\n    my $max = 0;\n    foreach\
    \ my $ext (@$extensions) {\n        my ($num_cap, $num_sm) = split(//, $ext);\n\
    \        $strongest = $ext;\n        if ($num_cap > $max) { $max = $num_cap; }\n\
    \        if ($num_sm > $max) { $max = $num_sm; }\n    }\n    $class_name . \"\
    .\" . $strongest;\n}", "    my($max_strength) = -1;\n    my($current_strength)\
    \ = -1;", "    my $strongest_extension = 0;\n    \n    # Sort the extensions by\
    \ strength (highest to lowest).\n    my @extensions_sorted = sort { $b->{strongest}\
    \ <=> $a->{strongest} } @{$extensions};"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
