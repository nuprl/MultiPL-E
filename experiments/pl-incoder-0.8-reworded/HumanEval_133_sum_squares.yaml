name: HumanEval_133_sum_squares
language: pl
prompt: "# You are given an array of numbers.\n# You need to return the sum of squared\
  \ numbers in the given array,\n# round each element in the array to the upper int(Ceiling)\
  \ first.\n# Examples:\n# >>> lst([1.0, 2.0, 3.0])\n# 14\n# >>> lst([1.0, 4.0, 9.0])\n\
  # 98\n# >>> lst([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst([1.4, 4.2, 0.0])\n# 29\n\
  # >>> lst([-2.4, 1.0, 1.0])\n# 6\nsub sum_squares {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n\
  \        if(eq_deeply($candidate->([1.0, 2.0, 3.0]),14)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0,\
  \ 3.0]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([1.0, 3.0, 5.0, 7.0]),84)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.4, 4.2,\
  \ 0.0]),29)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([-2.4, 1.0, 1.0]),6)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0, 1.0, 15.0,\
  \ 2.0]),10230)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([10000.0, 10000.0]),200000000)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.4,\
  \ 4.6, 6.3]),75)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([-1.4, 17.9, 18.9, 19.9]),1086)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0]),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0,\
  \ 1.0, 0.0]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ['    my $sum = 0;', "    my @new_list = ();\n    my(@lst, $sum);\n \
    \   for(@$lst){\n\t$sum = $sum + $_;\n    }\n    for(@$lst){\n\tpush(@new_list,\
    \ int(ceil($_/$sum)));\n    }\n    return $new_list;\n}", "    return 0 unless\
    \ @$lst;\n    my $sum = 0;\n    foreach my $e ( @$lst ) {\n        return $sum\
    \ if $e < 0;\n        $sum += $e * $e;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 tags=math,algorithm,arrays |>\n<| a tags=math,algorithm,arrays\
    \ |>\nI tried to implement the solution and came up with this:\n<code>\nimport\
    \ java.util.*;\nimport java.lang.*;\nimport java.io.*;\nclass GFG {\n    public\
    \ static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n\
    \        int arr[] = new int[5];\n        for(int i=0;i<5;i++)\n        {\n  \
    \          arr[i]=sc.nextInt();\n        }\n        for(int i=0;i<5;i++)\n   \
    \     {\n            int a=arr[i];\n            int max=Math.max(Math.abs(a),Math.abs(arr[i+1]));\n\
    \            int sum=0;\n            if(a<0)\n            {\n                arr[i]=Math.abs(arr[i]);\n\
    \                arr[i+1]=Math.abs(arr[i+1]);\n            }\n            for(int\
    \ j=0;j<max;j++)\n            {\n                arr[i+1+j]=Math.abs(arr[i+1+j]);\n\
    \                arr[i+1+j+1]=Math.abs(arr[i+1+j+1]);\n                if(Math.abs(arr[i+1+j])<Math.abs(arr[i+1+j+1]))\n\
    \                {\n                    sum+=arr[i+1+j];\n                }\n\
    \                else\n                {\n                    sum+=arr[i+1+j+1];\n\
    \                }\n            }\n            arr[i+1+max]=sum;\n           \
    \ \n        }\n        for(int i=0;i<5;i++)\n        {\n            System.out.print(arr[i]+\"\
    \ \");\n        }\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nBelow is the\
    \ code that generates the correct output using below two conditions", "    my(@result)\
    \ = 0;\n    foreach $num (@$lst) {\n        my($result) = ($num + $num);\n   \
    \     $result = int($result);\n        push(@result, $result);\n    }\n    return\
    \ @result;\n}", "    my $sum = 0;\n    for (@$lst) {\n        $sum = $sum + $_\
    \ ** 2;\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=perl,list |>\n<| a tags=perl,list\
    \ |>\nYou might want to give the map sub a try (a builtin function in perl):\n\
    <code>\nmap {\n    my $i = $_;\n    return $i * $i;\n} 1 .. 10;\n</code>\nwhich\
    \ works out to this:\n<code>", "    my $result = 0.0;\n    for my $val (@$lst)\
    \ {\n        $result += $val * $val;\n    }\n    $result;\n}", "    my $max =\
    \ $lst->max;\n    my $sq = 0;\n    foreach my $v (@$lst) {\n        if (! $v)\
    \ {\n            $sq = 0;\n            last;\n        }\n        $sq += $v * $v;\n\
    \    }\n    return $sq / $max;\n}", '    my $sum = 0;', "    return 0 if @$lst\
    \ < 2;\n    my(@arr) = @$lst;\n    my(@sums) = ();\n    my(@sq_sums) = ();\n \
    \   my(@sums_sq) = ();\n    my($sum, $sum1, $sum2, $sum3);\n    my($sq, $sq1,\
    \ $sq2, $sq3);", "    my $sum = 0;\n    for(@$lst) {\n        $sum += $_ * $_;\n\
    \    }\n    return int($sum);\n}", "    $lst =~ s/(^-?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)(.+)/$1$1/s;\n\
    \    my $sum = 0;\n    for (@$lst) {\n        $sum += $_ eq $lst ? ($_ eq '0'\
    \ ? 0 : $_) : $_*$_;\n    }\n    return int($sum);\n}", "    return ($lst[0] +\
    \ $lst[1] + $lst[2] + $lst[3] + $lst[4] + $lst[5]) /\n        (6 * 6) - $lst[6];\n\
    }", "    my($sum) = 0;\n    for my $num (@$lst) {\n        my $x = $num;\n   \
    \     $sum += $x ** 2;\n    }\n    return $sum;\n}", "    my $res = 0;\n    foreach\
    \ my $n (@$lst) {\n        $res +=$n * $n;\n    }\n    return $res;\n}", "   \
    \ my $sum = 0;\n    foreach my $el (@$lst) {\n        $sum += Math::BigInt->new($el)->bsqrt()\
    \ if (Math::BigInt->can('bsqrt'));\n    }\n    return $sum;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nIt seems that this approach is slower than the native bsqrt() function,\
    \ but maybe I'm missing something. On a 10000 element array it takes 43 seconds\
    \ (the native bsqrt) and your method takes 330 seconds (your code). Also, on another\
    \ array it takes less time for bsqrt() to be called (around 15ms vs 35ms). By\
    \ the way, I noticed that if all numbers in the array are negative, the native\
    \ bsqrt() takes less time than your method. So, you do need to do some checking\
    \ of the input.\n<|/ c |>\n<| c |>\nI have added a version that also takes negative\
    \ input\n<|/ c |>\n<| c |>\nThanks for the answer! I haven't tried your code,\
    \ since I found an answer that works and posted it below. But I upvoted your answer\
    \ as well! :)\n<|/ c |>\n<| a tags=bignum,perl,ceil |>\nThis works for me:\n<code>",
  "    my $result = 0;\n    my $i = 0;\n    while($i < $#$lst) {\n        $result\
    \ += $lst->[$i] * $lst->[$i];\n        $i++;\n    }\n    return $result;\n}",
  "    my $sum = 0.0;\n    foreach my $el (@$lst) {\n        $sum += $el * $el;\n\
    \    }\n    return $sum;\n}", "    my $s = 0;\n    for (@$lst) {\n        $s =\
    \ $s + $_ ** 2;\n    }\n    return $s;\n}", "    my $sum = 0;\n    foreach my\
    \ $i (@$lst) {\n        $sum += $i ** 2;\n    }\n    $sum;\n}", "    my(@result)\
    \ = (0, 0);\n    my($i, $x, $y);\n    \n    for ($i = 0; $i < @$lst; $i++) {\n\
    \        $x = int(@$lst[$i] / 2);\n        $y = int(@$lst[$i] / 2);\n        $x\
    \ -= int($lst[$i] % $x);\n        $result [0] += $x * $x;\n        $result [1]\
    \ += $y * $y;\n    }", "    my $sum = 0;\n    foreach (@$lst) {\n        $sum\
    \ = $sum + $_ * $_;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    foreach\
    \ my $x (@$lst) {\n        $sum += $x * $x;\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=perl,arrays |>\n<code>", "    my $max = $lst->[-1];\n\
    \    my $result = 0;\n    $lst->[-1] = undef;\n    foreach my $num (@$lst) {\n\
    \        my $num2 = int(ceil($num));\n        $result -= $num2 * $num2;\n    }\n\
    \    $result /= $max;\n    return int($result);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>", "    $lst = [map { int( ceil( * )) } @$lst];\n    return sum(map\
    \ { $_ * $_ } @$lst);\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThat is\
    \ a great solution! I didn't know that Perl has the concept of *map* or *mapply*.\
    \ I will remember it for future coding tasks.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    $lst = map({ int( ceil( * )) }, @$lst);\n</code>\n<|/ a tags=perl,arrays |>\n\
    <| c |>\nI like yours because it also uses `map`.  I think it's more readable\
    \ than the others.\n<|/ c |>\n<| c |>\nSure. `map` has a use, `map` has a use\
    \ :-)\n<|/ c |>\n<| a dscore=1 |>\nThis should do it\n<code>\nuse strict;\nuse\
    \ warnings;\nuse List::Util qw<ceil sum>;", "    my $sum = 0;\n    map { $sum\
    \ += $_**2 } @$lst;\n    Math::Round (${\\@$lst})/${\\@$lst};\n}\n</code>\n<|/\
    \ a tags=perl,math,arrays,algorithm |>\n<| c |>\nThis is wrong. Consider `@xs\
    \ = [1.1,1.2,1.3,1.4]`. The sum is `3.6`. This result is rounded down to `2`,\
    \ whereas the correct result is `3.8`.\n<|/ c |>\n<| c |>\n, your solution is\
    \ incorrect as well. Try `lst([1.1,1.4,1.2,1.3])`\n<|/ c |>\n<| c |>\nIt was my\
    \ mistake: my array had a lot of decimals. I thought it had to round to integers.\
    \ But it turns out I should just use Math::Round instead of my own function.\n\
    <|/ c |>\n<| c |>\n: Please do not write answers as comments. If you can do it\
    \ as an answer instead of as a comment, by all means, do it as an answer. Answers\
    \ should be helpful for the OP and others experiencing the same problem.\n<|/\
    \ c |>\n<| a tags=perl,math,arrays,algorithm |>\nHere is my version of this problem\
    \ that doesn't use Math::Round or map or sum\n<code>", "    my($sum) = 0;\n  \
    \  foreach my $val (@$lst) {\n        $sum += $val ** 2;\n    }\n    return $sum;\n\
    }", "    my $sum = 0;\n    \n    my $max = $lst->[0];\n    $max = Math::Round($max,\
    \ int(Math::Ceil($max)));\n    \n    $lst->[-1] = int(Math::Ceil($lst->[-1]));\n\
    \    for my $elm (@$lst) {\n        $elm = Math::Round($elm, int(Math::Ceil($elm)));\n\
    \        $sum += $elm ** 2;\n    }\n    $sum = $sum / @$lst;\n    return $sum;\n\
    }", "    my($sum);\n    foreach my $x (@$lst) {\n        $sum += ($x ** 2);\n\
    \    }\n    return $sum;\n}", "    my($res);\n    foreach my $x (@$lst) {\n  \
    \      my $n = $x;\n        $n = int(ceil($n));\n        $res += $n ** 2;\n  \
    \  }\n    return $res;\n}", "    my @sum_squares = @$lst;\n    return unless @$lst;\n\
    \    my $num_up = int(ceil(@sum_squares)); # round to upper int\n    foreach my\
    \ $num (@sum_squares){\n        $num = $num * $num;\n    }\n    return $num_up;\n\
    }", "    $lst = (@{$lst}[0]) ? @{$lst} : ();\n    my $sum = 0;\n    foreach my\
    \ $val (@{$lst}) {\n        $sum += $val * $val;\n    }\n    return $sum;\n}\n\
    </code>\n<|/ a dscore=4 tags=arrays,perl,floating-point,algorithm |>\n<| c |>\n\
    The original question says \"round\" instead of \"ceil\", so this doesn't really\
    \ answer the question (though the math is probably still fine).\n<|/ c |>\n<|\
    \ c |>\nGood catch on the rounding. Fixed the answer.\n<|/ c |>\n<| c |>\nIt still\
    \ doesn't handle negative numbers and I didn't downvote you for that, but it definitely\
    \ helped me understand that perl is really very good with floating points. Thanks!\n\
    <|/ c |>\n<| c |>\nJust saw that you did include a comment on how to handle negative\
    \ numbers. That was my original intent, but I wasn't sure how to go about implementing\
    \ it given the existing code. Thanks!\n<|/ c |>\n<| c |>\nI upvoted because I\
    \ like your use of grep to remove numbers that are too high, but I wouldn't use\
    \ grep (or map) on an array with a single element since that would unnecessarily\
    \ create a copy of $a just to remove the one element (and I doubt it would be\
    \ significant enough to warrant a copy). So your final line could just be `$sum\
    \ -= $a if $a <= $b;`\n<|/ c |>\n<| a dscore=3 |>\nTo answer the original question:\n\
    <code>", '    my $sum = 0;', '    my $sum = 0.0;', "    my @sums;\n    foreach\
    \ my $x (@$lst) {\n        push(@sums, sqrt($x));\n    }\n    return $sums[0];\n\
    }\n</code>\nI ran the test suite against your solution and it passed:\n<code>\n\
    perl -MO=Deparse -E'\n    use Test::More tests => 12;\n    use Math::Round::Util\
    \ qw(:all);\n    use Test::Deep; use_ok('sum_squares');\n    my $x = sum_squares([1.0,\
    \ 2.0, 3.0]);\n    is_deeply($x, 14, '$x');\n    my $y = sum_squares([1.0, 4.0,\
    \ 9.0]);\n    is_deeply($y, 98, '$y');\n    my $z = sum_squares([1.0, 3.0, 5.0,\
    \ 7.0]);\n    is_deeply($z, 84, '$z');\n    my $w = sum_squares([1.4, 4.2, 0.0]);\n\
    \    is_deeply($w, 29, '$w');\n    my $x = sum_squares([-2.4, 1.0, 1.0]);\n  \
    \  is_deeply($x, 6, '$x');\n'\n</code>\n<|/ a dscore=2 tags=perl |>\n<| c |>\n\
    Hi Borodin, I am trying your code but i get this error when i run it\n<|/ c |>\n\
    <| c |>\n`Math::Round::Util::round` was added in 5.10 (released in September 2011).\
    \ I think your version of Perl is too old to support it. I can only suggest you\
    \ upgrade your Perl.\n<|/ c |>\n<| c |>\nI am also using perl v5.8.8 i think this\
    \ is the issue\n<|/ c |>\n<| c |>\nI suspect a [Math::Round](http://search.cpan.org/perldoc?Math%3A%3ARound%3A%3AREader)\
    \ module is being installed from CPAN but isn't available in your perl installation.\
    \ The easiest way to check is to `use strict; use warnings;` in your source file\
    \ and run `perl -MMath::Round::Util`\n<|/ c |>\n<| c |>\nok, i am getting error\
    \ here now when i run it. ", "    my $sum = 0;\n    my(@square) = ();\n    my\
    \ $i = 0;\n    my $limit = $#$lst;\n    foreach my $num (@$lst) {\n\t$sum += $num;\n\
    \t$square[$i] =  int($num * $num);\n\t$i++;\n    }\n    return int($sum) if $sum;\n\
    \    return $limit if $limit;\n    return $square[0] if @square == 1;\n    return\
    \ $square[0] unless @square;", "    my $sum = 0;\n    foreach my $elem (@{$lst})\
    \ {\n        $sum += $elem ** 2;\n    }\n    return $sum;\n}", "    $lst =~ s/(\\\
    d+)/int($1)/g;\n    my $sum = 0;\n    for(@$lst) {\n        $sum += $_ ** 2;\n\
    \    }\n    return $sum;\n}", "    my $sum = 0;\n    $lst = $lst->copy;\n    while\
    \ (@$lst > 0) {\n        push @$lst, map {$_ * $_};\n    }\n    map {\n      \
    \  my ($s) = @_;\n        my $n = int(ceil($s));\n        $sum += $s * $s;\n \
    \       $sum -= $n * $n;\n    };\n    $sum;\n}\n</code>\n<|/ a tags=perl,arrays,math\
    \ |>\n<| c |>\nThank you, but I was looking for a faster solution because the\
    \ array size is bigger than 10000 elements and the array elements are floating\
    \ point.\n<|/ c |>\n<| c |>\nThe solution I suggested is faster than your solution.\
    \ Can you explain why you think this solution isn't faster? It should work exactly\
    \ like mine does. I don't think there will be much performance difference.\n<|/\
    \ c |>\n<| c |>\nBecause the time complexity of yours is:\nO(n^2) where n is the\
    \ size of the array. \nYour solution is O(n).\n<|/ c |>\n<| c |>\nOkay, got it.\
    \ Thanks for the clarification. So, I changed it a bit. Check it out.\n<|/ c |>\n\
    <| c |>\nYour solution has two problems: 1. `@$lst` will be flattened into the\
    \ list before it is used; 2. The inner loop calculates the square of the square\
    \ of `$_` but only sums that square. The total square is the sum of the squares\
    \ of `$_` **plus** the square of the sum of the squares of `@_`\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere is a solution that uses Math::Bigint instead of floats.\
    \ \nIt also takes advantage of the fact that Math::Bigint is much faster\nthan\
    \ Math::Float or even Math::BigRat. \n<code>\nuse strict;\nuse warnings;\nuse\
    \ Math::Bigint qw/ \n             baddr \n             biord \n             bneg\
    \ \n             bsub \n             bzero \n             blsft \n           \
    \  bigint \n             /;", "    $lst =~ tr/./-/;\n    $lst =~ s/^-//;\n   \
    \ return $lst;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n       \
    \ $sum += $num**2;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    $lst =\
    \ map { $_ = $_ * $_; $sum += $_ } (@$lst);\n    return $sum;\n}\n</code>\n<|/\
    \ a tags=perl,function,arrays,loops dscore=0 |>\n<| c |>\nThanks, that works perfectly.\
    \ I'm new to Perl and this is an exercise from a book I was given.\n<|/ c |>\n\
    <| a |>\nYou can try the below code also:\n<code>\nuse strict;\nuse warnings;",
  "    my $sum = 0;\n    foreach my $num (@$lst) {\n        $sum += $num * $num;\n\
    \    }\n    return $sum;\n}", "    my($sum) = 0;\n    my($i, $j);", "    my $sum\
    \ = 0;\n    foreach my $x (@$lst) {\n        $sum = $x + $sum;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    map {\n        my $a = $_;\n        if (defined\
    \ $a) {\n            my $b = int($_);\n            my $c = $a + $b*$b;\n     \
    \       $sum = $sum + $c;\n        }\n    }  @$lst;\n    return $sum;\n}", " \
    \   return $lst->[scalar(@$lst)-1]**2;\n}", "    my $ret = 0;\n    foreach my\
    \ $x (@$lst) {\n        $x++;\n        $ret += $x*$x;\n    }\n    return int($ret);\n\
    }\n</code>\n<|/ a |>\n<| a tags=rounding,math,perl,floating-point |>\nIf you use\
    \ Math::BigRat you can use the sqrt method: \n<code>\nuse Math::BigRat;\nuse big;",
  "    my $total_sum = 0.0;\n    foreach my $num (@$lst) {\n        my $sqr_num =\
    \ $num * $num;\n        $total_sum += $sqr_num;\n    }\n    return $total_sum;\n\
    }\n</code>\n<|/ a tags=perl,arrays |>\n<| a tags=perl,arrays |>\n<code>\nuse strict;\n\
    use warnings;", "    return 0 unless @$lst;\n    my($ret) = 0.0;\n    for(my $i\
    \ = 0; $i < @$lst; ++$i) {\n        $ret += $lst[$i] * $lst[$i];\n    }\n    $ret\
    \ = int($ret);\n    return $ret if ($ret == 0);\n    return $ret;\n}", '    my($sum,
    $i);', "    my($sum);\n    foreach $x (@$lst) {\n        my($y) =~ s/(?<=\\d)(?=[^\\\
    d])/$+\\./rs;\n        $sum += $x*$y;\n    }\n    return $sum;\n}", '    my($sum)
    = 0;', "    my $sum = 0;\n    foreach my $x (@$lst) {\n        $sum = $sum + $x\
    \ * $x;\n    }\n    return $sum;\n}", "    $lst =~ s/(?<=\\.0$)/.ceil($&)/eg;\n\
    \    my $total = 0;\n    for (@$lst) {\n        $total += $_ ** 2;\n    }\n  \
    \  return $total;\n}", "    my $res = 0;\n    foreach (@$lst) {\n        $res\
    \ += $_ ** 2;\n    }\n    return $res;\n}", "    return $lst == [] ? 0 : $lst->[0]\
    \ + $lst->[1] + $lst->[2] + $lst->[3];\n}", "    my($sum) = 0;\n    foreach my\
    \ $num (@$lst) {\n        $sum += $num ** 2;\n    }\n    return $sum;\n}", " \
    \   my $cnt;\n    foreach my $x (@$lst) {\n        $cnt = $cnt + $x * $x;\n  \
    \  }\n    return $cnt;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n\
    \        $sum += $num ** 2;\n    }\n    return $sum;\n}", '    my(@result) = ();',
  "    my $sum_squares = 0.0;\n    foreach my $x (@$lst) {\n        $sum_squares +=\
    \ $x * $x;\n    }\n    return $sum_squares;\n}", "    my $sum = 0;\n    foreach\
    \ my $number (@$lst) {\n        $sum += $number ** 2;\n    }\n    return $sum;\n\
    }", "    my $ret = 0;\n    foreach my $num (@$lst) {\n        $num = int($num);\
    \ # round up\n        $ret += $num * $num;\n    }\n    return $ret;\n}", "   \
    \ my(@sum) = ();\n    for(my $i = 0; $i < @$lst; $i++) {\n        push(@sum, $lst->[$i]\
    \ * $lst->[$i]);\n    }\n    return int(@sum);\n}", "    return ($lst * $lst);\n\
    }", "    my $res = 0;\n    for(@$lst) {\n        my $num = round($_);\n      \
    \  $num = $num if $_ > 0;\n        $num = $num + 1 if $_ < 0;\n        $res +=\
    \ $num*$num;\n    }\n    return $res;\n}", "    my($sum_square) = 0;\n    foreach\
    \ $num (@$lst) {\n        if($num < 0) {\n            $sum_square += $num**2;\n\
    \        }\n        else {\n            $sum_square += $num;\n        }\n    }\n\
    \    return $sum_square;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\n`sub\
    \ sum_squares {` should be `sub sum_squares { `, not `sub sum_squares { `\n<|/\
    \ c |>\n<| c |>\nThanks for the help. I got my program working. Thanks again for\
    \ the help. I'm still a beginner to perl.\n<|/ c |>\n<| c |>\n, fixed the typo.\
    \  Thanks.\n<|/ c |>\n<| c |>\nThanks for the help and correction. I understand\
    \ the concept of coding now. I'm just a beginner at perl and programming in general.\
    \ Thanks again for the help and correction.\n<|/ c |>\n<| a tags=perl,arrays |>\n\
    <code>", "    $lst[0]->round(Ceil);\n    my($sum) = 0;\n    for my $v (@$lst)\
    \ {\n        $sum->add($v->round(Ceil));\n    }\n    return $sum->value;\n}",
  "    my $result = 0.0;\n    for (@$lst) {\n\t$result += $_*$_;\n    }\n    return\
    \ $result;\n}", '    my $sum = 0;', "    my($sum_square, $elem) = (0, 0);\n  \
    \  for (@$lst) {\n        $elem += $_ ** 2;\n        $sum_square += $elem if defined\
    \ $sum_square;\n    }\n    $sum_square = round($sum_square);\n    return $sum_square;\n\
    }\n</code>\n<|/ a |>\n<| a tags=perl,math,arrays,algorithm dscore=0 |>\nHere's\
    \ a very simple and stupid solution in Perl:\n<code>", "    my(@result) = (0,\
    \ 0);\n    for my $x (@$lst) {\n        if ($x > 0) {\n            my $y = int($x\
    \ + 0.5);\n            $result += $y * $y;\n        }\n    }\n    return $result[0];\n\
    }", "    my @squares = map { $_ ** 2 } @$lst;\n    return $lst->[0] + @squares;\n\
    }", '    my $sum = 0;', "    my $sum_squares = 0;\n    foreach my $n (@$lst) {\n\
    \        my $squared = Math::BigFloat->new($n)->bpow;\n        $sum_squares +=\
    \ $squared;\n    }\n    return Math::BigFloat->new($sum_squares)->bint;\n}\n</code>\n\
    <|/ a tags=perl,bigint |>\n<| c |>\nThanks. I implemented your solution but the\
    \ code still takes ~30 seconds to process a test file on my i7 with 4 Gb RAM and\
    \ a SSD. I have edited the original post with the code I have written.\n<|/ c\
    \ |>\n<| c |>\nSorry, I thought I had already found a solution that didn't require\
    \ a module but as you point out it's much faster to run an `each` loop. On my\
    \ i7 it took ~6 seconds to run my original code. I'm going to look at your suggestion\
    \ and see if I can improve it. Thanks.\n<|/ c |>\n<| c |>\nI added the suggested\
    \ improvements to the code. It made it a lot faster but it still takes ~30 seconds\
    \ to run on a test file with ~150 million entries.\n<|/ c |>\n<| c |>\nYeah, it\
    \ seems pretty fast now. I was using an old laptop with a small laptop and an\
    \ old SSD. Looks like I'll have to spend some time doing some more benchmarking.\n\
    <|/ c |>\n<| a dscore=2 tags=perl,bigint |>\n<code>\nuse Math::BigInt;", "   \
    \ my(@result) = ();\n    foreach $ele (@$lst) {\n        my($up) = $ele > $ele\
    \ ? int(ceil($ele)) : $ele;\n        $ele += $up;\n        push(@result, $ele\
    \ * $ele);\n    }\n    return wantarray ? @result : \\@result;\n}", "    my $sum\
    \ = 0;\n    foreach my $i (@$lst) {\n        $sum += $i*$i;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    for my $val (@$lst) {\n        $sum += ($val\
    \ * $val);\n    }\n    return $sum;\n}", '    my $sum = 0;', "    my $sum = @$lst;\n\
    \    my @nums = @$lst;\n    my $square = 0;\n    my $sum_square = 0;\n    \n \
    \   foreach (@nums) {\n        $sum_square = $sum_square + $_ * $_;\n    }\n \
    \   return int($sum_square);\n}", "    my $sum = 0;\n    foreach my $num (@$lst)\
    \ {\n        $sum += ($num + $num + $num) * $num;\n    }\n    return $sum;\n}",
  "    my $sum = 0;\n    my @arr;\n    push @arr, $lst[0] if @$lst > 0;\n    foreach\
    \ my $num (@$lst) {\n        $sum += $num * $num;\n        $arr[$_] = $num if\
    \ $arr[$_] == 0;\n    }\n    return $sum;\n}", "    my $sum = 0;\n    map { $sum\
    \ += $_ ** 2 };\n    return $sum;\n}", "    $lst =~ tr/a-z/A-Z/;\n    return $lst[0]\
    \ * $lst[0] + $lst[1] * $lst[1] + $lst[2] * $lst[2];\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=perl,arrays,sum |>\nAs this post comes up on the top of a Google search,\
    \ I'll add my own solution in Perl. \n<code>\nuse List::Util qw(sum);", "    my\
    \ $cnt;\n    my $sum = 0;\n    foreach my $val (@$lst) {\n        $sum += $val\
    \ * $val;\n    }\n    return $sum;\n}\n</code>\nOutput:\n<code>\nuse warnings;\n\
    use strict;\nuse Data::Dumper;", '    my $sum = 0;', "    my(@lst) = @$lst;\n\
    \    my(@sq) = ();\n    my(@num) = ();", "    my $res = 0;\n    foreach my $n\
    \ ( @$lst ) {\n        $res += $n * $n;\n    }\n    return $res;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>", "    $lst =~ s/^\\s*\\[(.+)\\]\\s*$/@{$lst}/s;\n\
    \    my $sum = 0;\n    foreach my $x (@$lst) {\n        $sum += $x*$x;\n    }\n\
    \    return int($sum);\n}\n</code>\n<|/ a tags=math,arrays,perl |>\n<| a tags=math,arrays,perl\
    \ |>\n<code>", "    return $lst[0] * $lst[0] + $lst[1] * $lst[1] + $lst[2] * $lst[2];\n\
    }", "    my $result = 0.0;\n    for my $num (@$lst) {\n        $result += $num\
    \ * $num;\n    }\n    return $result;\n}", "    my $total_sum = 0;\n    foreach\
    \ my $elem (@$lst) {\n        $total_sum = $total_sum + $elem;\n    }\n    return\
    \ $total_sum;\n}", "    my $sum = 0.0;\n    for my $x (@$lst) {\n        $sum\
    \ += $x * $x;\n    }\n    return $sum;\n}", "    $lst[0] if $lst[0] =~ /^-?[\\\
    d]*\\.?[\\d]*$/;\n    $lst[0] if $lst[0] > 0;\n    $lst[0] if $lst[0] < 0;\n \
    \   return $_[0] * $_[0];\n}", "    my $sum = 0.0;\n    for (@$lst) {\n      \
    \  $sum = $sum + $_ * $_;\n    }\n    return int($sum);\n}", '    my(@sqr) = ();',
  "    my(@ret_arr);\n    foreach my $num (@$lst) {\n        my $temp_num = ceil($num);\n\
    \        push(@ret_arr, sprintf(\"%f\", $temp_num * $temp_num));\n    }\n    return\
    \ @ret_arr;\n}", "    my $total = 0;\n    foreach my $x (@$lst) {\n        $total\
    \ += $x*$x;\n    }\n    return $total;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nOne of the easier ways would be to do a for loop to loop through your array:\n\
    <code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    $lst[0] = $lst[0]\
    \ unless $lst[0];\n    my $sum_of_squares = 0.0;\n    for(my $i = 1;$i <= @{$lst};$i++)\
    \ {\n        $sum_of_squares += $lst[$i] * $lst[$i];\n    }\n    sqrt($sum_of_squares);\n\
    }", "    my(@squared_lst);\n    my($i, $square);\n    $square = 0;", "    my $sum\
    \ = 0;\n    foreach my $x (@$lst) {\n        $sum += $x * $x;\n    }\n    return\
    \ $sum;\n}", "    my($sum_square) = 0;\n    my($i) = 0;\n    \n    foreach (@$lst)\
    \ {\n        if (defined($_)) {\n            $sum_square += $_ * $_;\n       \
    \     $lst[$i] = int(ceil($lst[$i]));\n        }\n        $i++;\n    }\n    return\
    \ $sum_square;\n}", "    my $sum = 0;\n    for (@$lst) {\n        $sum += $_ **\
    \ 2;\n    }\n    return $sum;\n}", "    my(@sumsqr) = 0;\n    foreach my $num\
    \ (@{$lst}) {\n        push (@sumsqr, Math::sqr($num));\n    }\n    my ($sumsqr)\
    \ = @sumsqr;\n    return $sumsqr;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nThe following code will sum all the values in the array and return the squared\
    \ sum.\n<code>", "    my $sum = 0;\n    foreach my $v (@$lst) {\n        if ($v\
    \ !~ /^[+-]?\\d+$/) {\n            carp \"Not integer: \" . Dumper($v);\n    \
    \        next;\n        }\n        $sum += $v ** 2;\n    }\n    return $sum;\n\
    }", '    my $sum = 0;', "    my $result = 0;\n    $result = $result + $lst[0]\
    \ * $lst[0];\n    for my $i(1..scalar(@$lst)) {\n        $result = $result + $lst[$i]\
    \ * $lst[$i];\n    }\n    $result;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\n\
    Please add some explanation why your code should work. Even your variable names\
    \ would help a lot ;)\n<|/ c |>\n<| a tags=perl |>\n<code>", "    my $sum = 0;\n\
    \    foreach my $element (@$lst) {\n        $sum = $sum + $element * $element;\n\
    \    }\n    return $sum;\n}\n</code>\nThe reason for using ceil and floor is because\
    \ in many languages ceil and floor return integer values and they often return\
    \ values other than what you expect. For example in Perl 5 it says:\n<code>\n\
    perl -e 'print int(4.5)'", "    my(@out) =();\n    foreach my $x (@$lst) {\n \
    \       push(@out, ($x*$x));\n    }\n    return $out[0];\n}", "    my($sum,$i,$cnt);\n\
    \    for ($cnt = 0; $cnt < $#$lst; $cnt++) {\n        $sum += $lst[$cnt] * $lst[$cnt];\n\
    \    }\n    $sum;\n}", "    my $sum = 0;\n    for(@$lst) {\n        $sum += $_\
    \ ** 2;\n    }\n    $sum;\n}", "    my $sum = 0;\n    foreach my $value (@$lst)\
    \ {\n        $sum += $value * $value;\n    }\n    return $sum;\n}", "    $lst\
    \ = sort @$lst;\n    my $sum = 0;\n    for my $i (0..$#lst) {\n        $sum +=\
    \ $lst[$i] * $lst[$i];\n    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like this answer, except for the `sort @$lst` which is unnecessary overhead\
    \ as `@$lst` will already be sorted and only a sort is needed. `@$lst = sort @$lst`\
    \ is sufficient and faster than the other version.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out that. I didn't know that. However, I used `sort` because I\
    \ couldn't see an easier way for doing it in pure perl. Would you have a better\
    \ way to do it?\n<|/ c |>\n<| c |>\nUsing `sort` is much faster than the equivalent\
    \ `@$lst = sort { $a <=> $b }` because the former uses [Schwartzian transform](https://en.wikipedia.org/wiki/Schwartzian_transform)\
    \ to avoid creating an extra temporary array.\n<|/ c |>\n<| a dscore=1 tags=perl,arrays,algorithm\
    \ |>\nHere's how I would do it in Perl using the List::Util module.\n<code>",
  "    my $sum = 0;\n    foreach (@$lst) {\n        $sum += $_ ** 2;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    foreach(@$lst){\n        $sum += $_ ** 2;\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere's a solution\
    \ for square of array values in perl\n<code>", '    my($sum) = 0;', "    my $sum\
    \ = 0;\n    foreach my $num (@$lst) {\n        $sum += $num ** 2;\n    }\n   \
    \ return $sum;\n}", '    my($sum) = 0;', "    my(@ret);\n    foreach my $val (@$lst)\
    \ {\n        push(@ret, int($val*$val));\n    }\n    return $ret[0] + $ret[1]\
    \ + $ret[2];\n}\n</code>\n<|/ a tags=perl,floating-point |>\n<| c |>\nThe way\
    \ I understand floating point arithmetic, the sum of two integers does not necessarily\
    \ equal the sum of the integers and then square of the integers. For example,\
    \ it is the case that adding 1 and 3 does not necessarily equal adding 3 and 3,\
    \ but adding 1.0 and 3 does equal adding 3.0 and 3.0.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", '    my($sum);', "    my $sum_of_sq = 0;\n    $sum_of_sq = $lst[0]\
    \ * $lst[0] + $lst[1] * $lst[1] + $lst[2] * $lst[2];\n    foreach (@$lst) {\n\
    \        $sum_of_sq = $sum_of_sq + $_ * $_;\n    }\n    $sum_of_sq = Math::Round(Math::Ceil($sum_of_sq));\n\
    \    return $sum_of_sq;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n\
    \        $sum += $num * $num;\n        $sum = int($sum);\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nuse strict;\nuse warnings;",
  "    return 0 + @$lst * @$lst;\n}", "    my $sum = 0;\n    foreach my $num (@$lst)\
    \ {\n        $sum += ($num - int($num));\n    }\n    return int($sum);\n}", " \
    \   my $sum_squares = 0;\n    for(@$lst){\n        $sum_squares += $_ ** 2;\n\
    \    }\n    return $sum_squares;\n}", "    my @squares = ();\n    for my $element\
    \ (@$lst) {\n        push(@squares, $element * $element);\n    }\n    my $sum\
    \ = sum(@squares);\n    my $rounded_sum = $sum / int(ceil(sqrt($sum)));\n    return\
    \ $rounded_sum;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n      \
    \  $sum = $sum + $num ** 2;\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=perl\
    \ dscore=0 |>\n<| c |>\nYour `sum_squares` function doesn't do the right thing.\
    \ Try it with `$lst = [1,6,8]`\n<|/ c |>\n<| a tags=perl |>\n<code>", "    $lst\
    \ =~ s/^-//;\n    my(@arr) = @$lst;\n    my $sum = 0;\n    for my $num (@arr)\
    \ {\n        my $num = int(ceil($num));\n        $sum += $num * $num;\n    }\n\
    \    return $sum;\n}", "    $lst =~ s/^\\s*//;\n    $lst =~ s/\\s*$//;\n    if\
    \ (@$lst == 0) {\n        return 0;\n    }\n    my $sum = 0;\n    my @rounded_list\
    \ = map { (Math::Ceil($_, 1)); $_ } (@$lst);\n    my $res = 0;\n    foreach my\
    \ $val (@rounded_list) {\n        $res += $val * $val;\n    }\n    return $res;\n\
    }", "    return 0 if @$lst < 1;\n    my $sum = 0;\n    my $c = ceil(@$lst / 2);\n\
    \    map { $sum += $_ * $_ } @$lst if @$lst > $c;\n    return $sum;\n}", "   \
    \ my $sum = 0;\n    for (@$lst) {\n        my $s = $_*$_;\n        $sum += $s\
    \ if $s;\n    }\n    return $sum;\n}", "    my $sum = 0.0;\n    for my $num (@$lst)\
    \ {\n        $sum += $num * $num;\n    }\n    $sum;\n}\n</code>\n<|/ a tags=perl\
    \ dscore=2 |>\n<| c |>\nWhat do you mean by \"round each element in the array\
    \ to the upper int(Ceiling) first\"? Are you implying that some numbers are \"\
    too big\" to fit in a `double`? Or that it might be possible to \"normalize\"\
    \ the numbers (perhaps by adding 0.5 to the number if it's negative, for example)?\n\
    <|/ c |>\n<| c |>\nI mean that if the number is too big to fit in a `double` variable,\
    \ then it cannot be rounded up in perl.  Instead, it is rounded down and is given\
    \ to you as the integer part of the number, i.e. the number `200000000` would\
    \ be given to you as `2000000`.  This is what I mean by \"round each element in\
    \ the array to the upper int(Ceiling) first\".  I will update the answer to reflect\
    \ that.\n<|/ c |>\n<| c |>\nThat makes sense. Thanks for the clarification.\n\
    <|/ c |>\n<| a tags=perl |>\nThis might be an example to help you.\n<code>\nmy\
    \ $lst = [-2.4, 1.0, 1.0];", "    $lst = @$lst if not ref $lst;\n    $lst = map\
    \ { int(round($_)) } @$lst;\n    my $sum = 0;\n    foreach my $x (@$lst) {\n \
    \       $sum = $sum + $x*$x;\n    }\n    return $sum;\n}", "    my $sum = 0;\n\
    \    foreach my $num (@$lst) {\n        $sum += $num * $num;\n    }\n    round\
    \ $sum;\n}", "    my $sum = 0;\n    for(@$lst){\n        my $n = int(ceil($_));\n\
    \        $sum += $_ * $n;\n    }\n    return $sum;\n}", '    my($sum, $idx);',
  "    my $sum = 0;\n    foreach my $el (@$lst) {\n        $sum += $el ** 2;\n   \
    \ }\n    return $sum;\n}\n</code>\n<|/ a dscore=1 tags=perl,arrays,subroutine,return\
    \ |>\n<| a dscore=0 |>\nTry this code:\n<code>", "    $lst =~ s/^(-?\\d+\\.?\\\
    d*)$/$1/; # remove negative sign\n    # use floor to convert float\n    $lst =~\
    \ s/^(-?\\d+\\.?\\d*)$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\\
    d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove\
    \ negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n\
    \    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\\
    d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; #\
    \ remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative\
    \ sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~\
    \ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\\
    d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove\
    \ negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n\
    \    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\\
    d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; #\
    \ remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative\
    \ sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~\
    \ s/^-?\\d+\\.?\\d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\\
    d*$/$1/; # remove negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # remove\
    \ negative sign\n    $lst =~ s/^-?\\d+\\.?\\d*$/$1/; # ", "    my $sum = 0;\n\
    \    $sum = $sum + $_ ** 2 foreach @$lst;\n    return $sum;\n}", "    my $count\
    \ = 0;\n    my $sum = 0;\n    \n    for my $i (@$lst) {\n        $sum += $i *\
    \ $i;\n        $count++;\n    }\n    \n    $sum / $count;\n}", "    my $sum =\
    \ 0;\n    for (@$lst) { $sum += $_ * $_ }\n    return $sum;\n}", "    my $max\
    \ = $lst->[-1];\n    my $n = $lst->[0];\n    my $sum = 0;\n    for my $n ( @$lst\
    \ ) {\n        my ($x, $y) = (int($n->[0]), int($n->[1]));\n        $sum += $x\
    \ ** 2 + $y ** 2;\n        $n = $y;\n    }\n    $sum = $sum - $max ** 2;\n   \
    \ return int($sum);\n}", "    my $sum_of_squares = 0;\n    for(@$lst) { $sum_of_squares\
    \ += $_ ** 2; }\n    return $sum_of_squares;\n}", "    my($sum) = 0;\n    my($max)\
    \ = -1;\n    my($i);", "    my $sum = 0;\n    foreach my $num (@$lst) {\n    \
    \    my $tmp = int(($num + 0.5) * 10 ** 4);\n        $sum += $tmp;\n    }\n  \
    \  return $sum;\n}", "    my $ret = 0;\n    \n    for (@$lst) {\n        $ret\
    \ += $_ ** 2;\n    }\n    \n    return $ret;\n}", "    my $sum = 0;\n    foreach\
    \ my $num (@{$lst}) {\n        $sum += int(ceil($num*$num));\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    for my $num (@$lst) {\n        $sum += $num\
    \ * $num;\n    }\n    my $ans = ceil($sum);\n    for my $num (@$lst) {\n     \
    \   $num = int($num);\n        $ans += $num * $num;\n    }\n    return $ans;\n\
    }", '    my $sum_sq = 0;', "    my $total_sqr = 0.0;\n    foreach my $x (@$lst)\
    \ {\n        $total_sqr += Math::sqr($x);\n    }\n    return $total_sqr;\n}",
  '    my($sum) = 0;', "    my $ls = scalar(@$lst);\n    my $sum = 0;\n    for (@$lst)\
    \ {\n        $sum += $_ ** 2;\n        $_ = int($_) if $_ > 0.0;\n    }\n    return\
    \ $sum / $ls;\n}", "    my $sum = 0;\n    my $n = @$lst;", "    my $sum = 0;\n\
    \    for (@$lst) {\n        $sum += $_ * $_;\n    }\n    return int($sum);\n}",
  "    $lst =~ s/^\\s*(\\d+)\\s*$/$1/s;\n    return sum map {round(float($_)) ** 2}\
    \ @$lst;\n}", "    my($sum_squared, $sum, @num);\n    foreach $num (@$lst) {\n\
    \        $sum += $num;\n        $sum_squared += $num * $num;\n    }\n    return\
    \ $sum_squared if $sum_squared != 0;\n    return;\n}", "    my($sum) = 0;\n  \
    \  foreach my $x (@$lst) {\n        $sum += $x**2;\n    }\n    return $sum;\n}",
  "    my($total);\n    foreach my $num (@$lst) {\n        $total += $num * $num;\n\
    \    }\n    return $total;\n}", "    my($sum) = 0;\n    foreach $elm (@$lst) {\n\
    \        $sum += $elm ** 2;\n    }\n    $sum;\n}", "    my $sum_square = 0;\n\
    \    for my $num (@$lst) {\n        $sum_square += $num * $num;\n    }\n    $sum_square\
    \ =~ s/^0\\K[-+]?(\\d+)$/int($1)/eg;\n    return $sum_square;\n}", "    my $s\
    \ = 0.0;\n    for my $v (@$lst) {\n        $s += $v * $v;\n    }\n    return $s;\n\
    }", "    my $sum = 0;\n    $lst->each(sub{\n        $sum += ($_ * $_);\n    });\n\
    \    return $sum;\n}", "    my($sum,$i,$j);\n    foreach $i (@$lst) {\n      \
    \  $sum = $sum + $i * $i;\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=algorithm,sum,perl\
    \ dscore=0 |>\n<| a |>\nOne more in Perl:\n<code>", "    my $result = 0.0;\n \
    \   my $max = @$lst > 0 ? $lst->[-1] : 0;\n    \n    for(@$lst) {\n        $result\
    \ += $_*$_;\n    }\n    \n    return int(ceil($result));\n}", "    my $s = 0;\n\
    \    my $x = 0;\n    foreach my $num (@$lst) {\n        $x = $x + $num;\n    \
    \    $s = $s + $num * $num;\n    }\n    my $res = $x;\n    my $x = int($res);\n\
    \    while ($x > 0.0) {\n        $res = $res - $x;\n        $x = int($res);\n\
    \    }\n    return $res;\n}\n</code>\n<|/ a |>\n<| a tags=perl,math,arrays |>\n\
    <code>", "    my $sum = 0;\n    for (@$lst) {\n        $sum += $_ * $_ if;\n \
    \   }\n    return $sum;\n}", "    my $sum = 0;\n    foreach my $val (@$lst) {\n\
    \        $sum = $sum + $val*$val;\n    }\n    return $sum;\n}", "    my $sum =\
    \ 0;\n    foreach my $el (@$lst) {\n        $sum += $el * $el;\n    }\n    return\
    \ $sum;\n}", "    my $sum = 0;\n    foreach(@$lst) {\n        $sum = $sum + ($_\
    \ ** 2);\n    }\n    return $sum;\n}", "    my $result;\n    foreach my $num (@$lst)\
    \ {\n        $result += (Math::ceil($num)*Math::ceil($num))*$num;\n    }\n   \
    \ return $result;\n}", '    my($sum) = 0;', "    my $sum = 0;\n    my $i = $#lst;\n\
    \    while ( $i != -1 ) {\n        my $val = int $lst[$i];\n        $sum += $val*$val;\n\
    \        $i--;\n    }\n    return $sum;\n}", "    my($sum);\n    foreach $x (@$lst)\
    \ {\n        if ($x != 0.0) {\n            $sum += $x * $x;\n        }\n    }\n\
    \    $sum;\n}", "    my $sum = 0;\n    for(@$lst){\n        $sum += $_ ** 2;\n\
    \    }\n    return $sum;\n}", "    return reduce { $a + $_ } map { int rint $b\
    \ };\n}", "    my $result;\n    foreach my $x (@$lst) {\n        $result += $x\
    \ * $x;\n    }\n    return $result;\n}", "    my($cnt);\n    my($acc);\n    foreach\
    \ my $num (@$lst) {\n        my $f = (int($num) + 1) / 2;\n        $acc += $f\
    \ * ($f - 1) * $num;\n        $cnt += 1;\n    }\n    return $acc;\n}", "    my\
    \ $res = 0;\n    foreach my $num (@$lst) {\n        $res +=  $num * $num;\n  \
    \  }\n    return $res;\n}", "    my($sum) = 0;\n    foreach my $num (@$lst) {\n\
    \        $sum += int(ceil($num));\n    }\n    return $sum;\n}", "    my $sum =\
    \ 0;\n    foreach my $num (@$lst) {\n        $sum += $num * $num;\n    }\n   \
    \ return $sum;\n}", "    my $sum = 0;\n    foreach my $num (@$lst) {\n       \
    \ $sum = $sum + $num ** 2;\n    }\n    return $sum;\n}", "    my @res = map {round(@$_)}\
    \ @$lst;\n    return map {$_*$_} @res;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,perl,performance\
    \ dscore=1 |>\n<code>", "    my $sum = 0;\n    foreach my $x (@$lst) {\n     \
    \   $sum += int($x * $x);\n    }\n    return $sum;\n}", "    my $sum = 0;\n  \
    \  foreach my $num (@$lst) {\n        if ($num > $num->bint) {\n            $num\
    \ = $num->bint;\n        }\n        $sum += $num * $num;\n    }\n    return $sum;\n\
    }", '    my $sum = 0;', "    my $sum = 0;\n    my $i;\n    my $j;\n    my $k;",
  "    my $sum = 0;\n    foreach my $num (@$lst) {\n        $sum += $num * $num;\n\
    \    }\n    $sum;\n}", "    $lst = map{round($_)} @$lst;\n    return $lst[0] *\
    \ $lst[0] + $lst[1] * $lst[1];\n}", "    $lst =~ s/(?<!\\d)(\\d+)/$1 ^ $1/ge;\n\
    \    return $lst;\n}", "    my $sum = 0;\n    foreach my $x (@$lst) {\n      \
    \  my $y = int(ceil($x));\n        $sum = $sum + $x * $x;\n    }\n    return $sum;\n\
    }", "    my $sum = 0;\n    foreach my $el (@$lst) {\n        $sum += $el ** 2;\n\
    \    }\n    return $sum;\n}", "    my $sum = 0;\n    $lst = map { int(ceil(round($_)))};\n\
    \    map { $sum += $_ } @$lst;\n    return $sum;\n}", "    my $sum = 0;\n    foreach\
    \ my $num (@$lst) {\n        $sum += $num ** 2;\n    }\n    return $sum;\n}",
  "    my $sum = 0;\n    foreach my $x (@$lst) {\n        $sum += $x*$x;\n    }\n\
    \    return $sum;\n}", "    my(@sum_squared_elements);\n    foreach my $num (@$lst)\
    \ {\n        push(@sum_squared_elements, $num * $num);\n    }\n    return @sum_squared_elements;\n\
    }", "    my $sum = 0;\n    my $count = 0;\n    foreach my $item (@$lst) {\n  \
    \      my $num = Math::Round($item);\n        $sum += ($num ** 2);\n        $count++;\n\
    \    }\n    return $sum / $count;\n}\n</code>\n<|/ a dscore=1 tags=perl |>\n<|\
    \ a dscore=1 |>\nHere's a quick solution:\n<code>", "    my $acc = 0;\n    for\
    \ (@$lst) {\n        $acc += $_ ^ $_;\n    }\n    return $acc;\n}", "    my $sum\
    \ = 0;\n    for my $val (@$lst) {\n        $sum += $val**2;\n    }\n    $sum;\n\
    }", "    my @ret;\n    my $n = @$lst;", "    my $sum = 0;\n    my @round = map\
    \ { ceil($_) };\n    foreach my $element (@$lst) {\n        $sum += $element *\
    \ $element;\n    }\n    return $sum + $sum * $sum;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
