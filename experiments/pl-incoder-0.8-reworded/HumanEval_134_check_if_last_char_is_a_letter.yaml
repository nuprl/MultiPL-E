name: HumanEval_134_check_if_last_char_is_a_letter
language: pl
prompt: "# Create a function that returns 1 if the last character\n# of a given string\
  \ is an alphabetical character and is not\n# a part of a word, and  otherwise.\n\
  # Note: \"word\" is a group of characters separated by space.\n# Examples:\n# >>>\
  \ check_if_last_char_is_a_letter(\"apple pie\")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"\
  apple pi e\")\n# 1\n# >>> check_if_last_char_is_a_letter(\"apple pi e \")\n# \"\"\
  \n# >>> check_if_last_char_is_a_letter(\"\")\n# \"\"\nsub check_if_last_char_is_a_letter\
  \ {\n    my($txt) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_if_last_char_is_a_letter;\n\
  \        if(eq_deeply($candidate->(\"apple\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e\"),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"A\"),1)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie \"),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Pumpkin pie 1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee e \"),\"\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  apple pie\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"apple pi e \"),\"\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($last_char) = substr($txt, length($txt), 1);\n    return 1 if\
    \ $last_char eq 'a' or\n        $last_char eq 'e' or\n        $last_char eq 'i'\
    \ or\n        $last_char eq 'o' or\n        $last_char eq 'u' or\n        $last_char\
    \ eq 'A' or\n        $last_char eq 'E' or\n        $last_char eq 'I' or\n    \
    \    $last_char eq 'O' or\n        $last_char eq 'U';\n    return \"\";\n}\n</code>\n\
    Now, you have a function you can call that will check the last character of a\
    \ string for letters.  You could then use that function to add another function\
    \ to check the first character of a string for letters.  You would then be able\
    \ to use these functions interchangeably.\n<code>", "    # Do nothing if there's\
    \ no text:\n    return $txt unless length($txt) > 0;\n    # Do nothing if there's\
    \ no last character in the string:\n    return $txt if substr($txt, length($txt)-1,\
    \ 1) eq \"\";\n    # Do nothing if the last character is a space:\n    return\
    \ $txt if substr($txt, length($txt)-1, 1) eq \" \";\n    # Do nothing if the last\
    \ character is a digit:\n    return $txt if substr($txt, length($txt)-1, 1) eq\
    \ \"0\";\n    # Do nothing if the last character is a letter:\n    return $txt\
    \ if substr($txt, length($txt)-1, 1) eq \"A\";\n    # Do nothing if the last character\
    \ is a punctuation:\n    return $txt if substr($txt, length($txt)-1, 1) eq \"\
    .\";\n    # Do nothing if the last character is a whitespace:\n    return $txt\
    \ if substr($txt, length($txt)-1, 1) eq \" \";\n    # Do nothing if the last character\
    \ is a line feed:\n    return $txt if substr($txt, length($txt)-1, 1) eq \"\\\
    n\";\n    # Do nothing if the last character is a carriage return:\n    return\
    \ $txt if substr($txt, length($txt)-1, 1) eq \"\\r\";\n    # Do nothing if the\
    \ last character is an horizontal tab:\n    return $txt if substr($txt, length($txt)-1,\
    \ 1) eq \"\\t\";\n    # Do nothing if the last character is a vertical tab:\n\
    \    return $txt if substr($txt, length($txt)-1, 1) eq \"\\v\";\n    # Do nothing\
    \ if the last character is a form feed:\n    return $txt if substr($txt, length($txt)-1,\
    \ 1) eq \"\\f\";\n    # Do nothing if the last character is a form feed, a carriage\
    \ return, or a line feed:\n    return $txt if substr($txt, length($txt)-1, 1)\
    \ eq \"\\f\\c\";\n    # Do nothing if the last character is a vertical tab:\n\
    \    return $txt if substr($txt, length($txt)-1, 1) eq \"\\v\";\n    # Do nothing\
    \ if the last character is a vertical tab, carriage return, or line feed:\n  \
    \  return $txt if substr($txt, length($txt)-1, 1) eq \"\\v\\r\";\n    # Do nothing\
    \ if the last character is a horizontal tab:\n    return $txt if substr($txt,\
    \ length($txt)-1, 1) eq \"\\t\";\n    # Do nothing if the last character is a\
    \ horizontal tab, carriage return, or line feed:\n    return $txt if substr($txt,\
    \ length", "    return \"\" if length($txt) == 0;\n    my($last_ch) = substr($txt,\
    \ length($txt)-1, 1);\n    my $is_last_letter = lc($last_ch) ne $last_ch;\n  \
    \  return $is_last_letter ? \"1\" : \"0\";\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nIf you're going to use regex, at least use a lookbehind instead of trying\
    \ to detect end of line with that negative lookbehind.\n<|/ c |>\n<| c |>\n: You\
    \ are right, a lookbehind can work. I'm also wondering about performance implications\
    \ because of the negative lookbehind.\n<|/ c |>\n<| a dscore=0 |>\nA very simple\
    \ solution would be to create a dictionary of last char to check with.\n<code>\n\
    my $dictionary = {\n   \" => \"\\n\",\n   \";\" => \",\",\n   \"-\" => \"-\",\n\
    \   \"0\" => \"0\",\n   \"1\" => \"1\",\n   ...\n   \"Z\" => \"Z\",\n   \"-\"\
    \ => \"-\",\n   ...\n};", "    return 1 if ($txt =~ /\\w$/);\n    return '';\n\
    }\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nI like the `\\w` solution because\
    \ it is more precise in terms of what it accepts. For example, it doesn't match\
    \ 'x' or 'X' which are valid characters after the last character of a word. I\
    \ like the idea of using a regex pattern to accomplish this as well.\n<|/ c |>\n\
    <| a dscore=2 |>\nI would use a function as suggested, but here are two other\
    \ ways.\n<code>", "    my $result = \"\";\n    my $words = split(/ /, $txt);\n\
    \    my $last_char = \"\";\n    foreach my $word (@$words) {\n        $last_char\
    \ = $word->[-1];\n        if($last_char =~ /[A-Z]/) {\n            return \"\"\
    ;\n        }\n    }\n    return $result;\n}", "    return $txt if $txt !~ /^[a-z]+$/i;\n\
    \    return 1;\n}", "    my($last_char) = substr($txt, length($txt)-1, 1);\n \
    \   return ($last_char !~ /\\w/) ? $last_char : \"\";\n}", "    my($last_char)\
    \ = substr($txt, length($txt) - 1, 1);\n    my($is_letter) = $last_char =~ /[a-z]/\
    \ ? 1 : 0;\n    my($is_word) = ($txt =~ /[a-z][a-z][a-z]/) ? 1 : 0;", "    $txt\
    \ =~ m!([a-z])$!;\n    return $1 if $1;\n    return;\n}", "    my($letter) = $txt\
    \ =~ /([A-Z])$/;\n    if($letter) {\n        return $letter;\n    } else {\n \
    \       return '';\n    }\n}", "    my($last_char) = substr($txt, length($txt)-1,\
    \ 1);\n    my @words = split(/ /, $txt);\n    my $found = 0;\n    foreach my $word\
    \ (@words) {\n        if($word =~ /$last_char/) {\n            $found = 1;\n \
    \           last;\n        }\n    }\n    return $found;\n}", "    return $txt\
    \ if length($txt) <= 1;\n    my ($last_ch) = substr($txt, -1, 1);\n    my @words\
    \ = split /\\s+/, $txt;\n    return $words[-1] if $last_ch =~ /[aeiou]$/;\n  \
    \  return;\n}", "    my $last_char = $txt =~ substr($txt,length($txt)-1,1);\n\
    \    if ( $last_char =~ /[A-Za-z]/ ) {\n        $txt = substr($txt, 0, length($txt)-1);\n\
    \    }\n    return $txt;\n}\n</code>\n<|/ a tags=perl,regex dscore=0 |>\n<| a\
    \ dscore=0 tags=perl,regex |>\nThis code also works \n<code>\nmy $str = \"apple\
    \ pi e\";\nmy $pattern = qr/^\\w\\s\\w\\s/;\nif ($str =~ m/$pattern/) {\n    print\
    \ \"matched\\n\";\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not answer the question.\
    \ The OP wants to remove spaces between the words.\n<|/ c |>\n<| c |>\nThe above\
    \ code worked for me. I just ran this code.\n<|/ c |>\n<| c |>\nThe above code\
    \ worked for me. I just ran this code. \nI got output \"apple pie\".\n<|/ c |>\n\
    <| c |>\nIt does work for the example in the question, but it will fail if the\
    \ word starts or ends with a space, like this: `apple pi e`\n<|/ c |>\n<| c |>\n\
    Yes that is right. My answer was based on that condition. Thanks\n<|/ c |>\n<|\
    \ a tags=perl,regex |>\nFor that you can use regex like\n<code>\n^\\w+(?: |$)\n\
    </code>\nThis will match only string with space between words.\nDemo\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis does not answer the question. The OP wants to remove spaces\
    \ between the words.\n<|/ c |>\n<| c |>\nyeah i agree with you. i just wrote regex\
    \ for OP's question.\n<|/ c |>\n<| a dscore=0 tags=perl,regex |>\nThis might work\
    \ for you:\n<code>\nuse strict;\nuse warnings;", "    return $txt if $txt =~ /[^a-zA-Z\\\
    s]$/;\n    return 0;\n}", "    my $last_char = $txt->[$#txt];\n    return \"\"\
    \ if ($last_char !~ /^[a-z]$/i);\n    return 1;\n}", "    my($last_char) = substr($txt,\
    \ length($txt) - 1, 1);\n    if ($last_char !~ /[a-z]/i ) {\n        return \"\
    \";\n    }\n    else {\n        return $last_char;\n    }\n}", "    if (length($txt)\
    \ == 0 || index($txt, \" \") != -1) {\n        return $txt;\n    }\n    my $last_char\
    \ = substr($txt, length($txt) - 1, 1);\n    if ($last_char =~ /[A-Za-z]/ && $last_char\
    \ !~ /[a-z]/) {\n        return $txt;\n    }\n    return \"\";\n}", "    if($txt\
    \ =~ /^(.*[[:alpha:]])\\s(\\w+)$/i) {\n        return $1;\n    } else {\n    \
    \    return \"\";\n    }\n}", "    return '' if !defined $txt || $txt eq '';\n\
    \    my $last_letter = substr( $txt, length($txt)-1, 1);\n    return 1 if $last_letter\
    \ =~ /[A-Za-z]/ and $txt !~ /[[:space:]]/;\n    return '';\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis returns 1 if the last character is a letter, but it will also\
    \ return 1 if the last character is a digit. I think you need to check for `0-9`\
    \ too, as in the examples that you gave.\n<|/ c |>\n<| c |>\nYou're right - my\
    \ answer isn't perfect, but I gave it a shot anyways.\n<|/ c |>\n<| a tags=perl,regex,string\
    \ dscore=2 |>\nHow about checking if the last character is a letter with a regex\
    \ and if it doesn't use $str =~ /[a-z]/, if it does use $str =~ /[^a-z]/\n<|/\
    \ a |>\n<| a tags=perl,regex,string |>\n<code>", "    $txt =~ s/^\\s*//;\n   \
    \ my($word) = $txt =~ m/^\\s*(\\S+)\\s*$/;\n    my $letter = $1;\n    return 1\
    \ if ( $letter =~ /^[a-zA-Z]+$/ and $letter ne \"e\" );\n    return '';\n}", " \
    \   my($last_char) = substr($txt, -1, 1);\n    my(@words) = split (/\\s+/, $txt);\n\
    \    my($is_letter_or_not_letter) = 0;\n    my(@words) = split (/\\s+/, $txt);\n\
    \    foreach my $word (@words) {\n        $is_letter_or_not_letter .= ($word =~\
    \ /\\w/) ? '1' : '0';\n    }\n    if($last_char =~ /\\w/ && !$is_letter_or_not_letter)\
    \ {\n        return \"\";\n    } else {\n        return $last_char;\n    }\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nmy $str = \"apple pi e\";\nmy $last_char\
    \ = $str =~ /\\w/; # returns 0 or 1\nmy $last_word_start_pos = $str =~ /^(\\w*)/;\
    \ # returns position of last word\nmy $last_word_end_pos = $str =~ /\\w*\\z/;\
    \ # returns position of last word\nif ( $last_char && !$last_word_start_pos )\
    \ {\n    # last char is alphabet but not at the beginning of a word\n} else {\n\
    \    # last char is alphabet and not at the beginning of word\n}\n</code>\n<|/\
    \ a dscore=1 tags=perl |>\n<| c |>\n`/\\w/` matches only ASCII letters. You'll\
    \ get unexpected results with unicode letters. Use `/\\w/` if you just want to\
    \ match word characters.\n<|/ c |>\n<| a |>\nAssuming the word ends only when\
    \ another alphabet comes, you can do something like:\n<code>\nmy $str = 'apple\
    \ pi e';\nmy ($last) = $str =~ /\\A\\p{L}*(\\w)/;\nif ($last ne '') {\n    #last\
    \ char is a letter\n} else {\n    #last char is not a letter\n}\n</code>\nor\n\
    <code>\nmy $str = 'apple pi e';\nmy ($last) = $str =~ /\\A\\p{L}*(\\W)/;\nif ($last\
    \ ne '') {\n    #last char is a letter\n} else {\n    #last char is not a letter\n\
    }\n</code>\n\\w matches only ASCII letters. You'll get unexpected results with\
    \ unicode letters. Use \\w if you just want to match word characters.\n\\p{L}\
    \ matches any kind of letter from any language. You may want to use it instead\
    \ if you have unicode letters.\n<|/ a tags=perl dscore=1 |>\n<| a dscore=1 |>\n\
    Here's a simpler method than the others po", "    if(length($txt) <= 0) {\n  \
    \      $txt = \" \";\n    }\n    if($txt =~ /[a-zA-Z]+$/) {\n        $txt = \"\
    \";\n    } else {\n        $txt = 1;\n    }\n    return $txt;\n}", "    my $letters_str\
    \ = \"[a-zA-Z]+\";\n    return $txt =~ /$letters_str/ and not (/\\w$/ && $txt\
    \ =~ /\\w$/);\n}", "    my($last) = length($txt);\n    my(@words) = split(/ /,\
    \ $txt);", "    my $letter = $txt[$#{$txt}];\n    substr($letter,-1) =~ /^[a-zA-Z]$/;\n\
    }", "    if(length $txt > 0) {\n        return 1 if ($txt =~ m/[[:alpha:]]\\W/\
    \ and $txt !~ m/\\W$/);\n    } else {\n        return '';\n    }\n}", "    if\
    \ ($txt =~ /^([^ ]+)(?!.*[^ ][a-z])$/ && $txt !~ /[^a-z]$/) {\n        return\
    \ \"\";\n    }\n    return 1;\n}", "    # if the string is empty return empty\
    \ string\n    return '' unless $txt;\n    # get the last character of the string\n\
    \    my($last_char) = substr($txt,-1,1);\n    # if the last character is not a\
    \ letter then return string\n    return '' unless $last_char =~ /\\w/;\n    #\
    \ otherwise return string\n    return 1;\n}", "    my($len) = $txt->length();\n\
    \    my($last) = $txt->char($len-1);\n    my($lastch) = $last->ascii_char;\n \
    \   my($ret) = '';\n    my(@letters) = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i',\n                     'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n  \
    \                   's', 't', 'u', 'v', 'w', 'x', 'y', 'z');\n    my($letters_rev)\
    \ = reverse @letters;\n    foreach my $letter(@letters) {\n        my $letter_rev\
    \ = $letters_rev->[$letter];\n        if ($letter ne $letter_rev) {\n        \
    \    $ret .= $letter;\n        }\n    }\n    return $ret;\n}\n</code>\n<|/ a tags=regex,perl,string-parsing\
    \ dscore=1 |>\n<| c |>\nThat does it! The \"last char not being in a word\" check\
    \ is what was needed. I was over complicating things.\n<|/ c |>\n<| c |>\nThis\
    \ seems to break on inputs that contain spaces. Do I really need to check for\
    \ a space after a char? And I assume that it will break if a letter is found after\
    \ the last space (but before the end of the string). Right?\n<|/ c |>\n<| c |>\n\
    Yes, it needs to check for a space after the last character. This is because the\
    \ first letter of the \"word\" would have to be a space to begin with, otherwise\
    \ the regex would match the beginning of the string. I am not quite sure what\
    \ you are asking about the spaces, do you mean that your input could have spaces\
    \ between the words? If so, yes, the above would break.\n<|/ c |>\n<| c |>\nYes,\
    \ if the input contained spaces, it would break.\n<|/ c |>\n<| c |>\nThe above\
    \ code doesn't check for spaces, it only checks for the last character being a\
    \ letter. If you added a space to the end of the input it could break, but if\
    \ you checked for the spaces it would not break.\n<|/ c |>\n<| a tags=regex,perl,string-parsing\
    \ |>\nAnother way using tr///:\n<code>\n$ perl -pe 'tr/[a-z]/\\n/' <<'EOF'\napple\
    \ pie\napple pi e\napple pi e \nEOF\napple pie\napple pi e\napple pi e\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=regex,perl,string-parsing dscore=0 |>\nThis is a\
    \ good candidate for a regex-based solution:\n", "    my $length = length($txt);\n\
    \    if ($length == 1) {\n        return $txt if $txt !~ /^[a-z]$/i;\n    } else\
    \ {\n        return $txt[-1,length($txt)] if $txt !~ /[a-z]$/i;\n    }\n}", " \
    \   my @chars = split(' ', $txt);\n    # If the last character is not an alphabetical\
    \ character,\n    # then return an empty string\n    if ($chars[scalar(@chars)-1]\
    \ =~ /^[^a-z]/) {\n        return '';\n    }\n    else {\n        return 1;\n\
    \    }\n}", "    return $txt if !defined $txt || $txt eq \"\";\n    ($txt)[-1]\
    \ =~ /^[^A-Z]/;\n    return $txt if $txt ne \"\";\n    return \"\";\n}", "   \
    \ my $lc = length($txt);\n    my $lw = length($txt);\n    my $lc1 = uc(substr($txt,\
    \ $lw-1, 1));\n    if ($lc1 eq $txt[$lw-1]) {\n        $lc = 0;\n    }\n    if\
    \ ($lc > 0) {\n        return $txt;\n    }\n    else {\n        return 1;\n  \
    \  }\n}", "    $txt =~ /^[a-z ]+$/i;\n    return $txt unless $txt =~ /[a-z ]/;\n\
    \    return \"\";\n}", "    if ($txt =~ /\\A\\w+/) {\n        if ($txt =~ /[ -]/)\
    \ {\n            $txt =~ s/$txt/$1/g;\n        }\n        else {\n           \
    \ $txt =~ s/$txt/e/g;\n        }\n    }\n    return $txt;\n}", "    return $txt\
    \ if $txt !~ /^[a-z ]/i;\n    return $txt if $txt !~ /\\b[a-z]$/i;\n    return\
    \ $txt if $txt !~ /[a-z]\\b$/i;\n    return $txt;\n}", "    return $txt if $txt\
    \ eq \"\";\n    $txt =~ /(\\w)(?=[^\\w]|$)/;\n    return $1 if $1 ne \"\";\n}",
  "    if ($txt =~ m/^.([A-Za-z])+$/) {\n        $txt =~ s/$/ $1/;\n        $txt =~\
    \ s/ .*//;\n        return $txt;\n    } else {\n        return \"\";\n    }\n}",
  "    # Split string to words. \n    my($words) = split(/\\s+/, $txt);\n    # Check\
    \ for the last character to be a letter or digit.\n    my $last_char = substr($words[-1],\
    \ length($words[-1])-1, 1);\n    # If the last character is a letter, return \"\
    \". \n    if ( ! length($last_char) && $last_char !~ /^\\w$/) {\n        return\
    \ \"\";\n    }\n    # Else, return the last character.\n    else {\n        return\
    \ $last_char;\n    }\n}\n</code>\n<|/ a tags=regex,perl |>\n<| c |>\nI added a\
    \ couple of comments to the code.\n<|/ c |>\n<| c |>\nThanks for your help !\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    if (length($txt) > 0) {\n        my\
    \ $last_char = substr($txt,-1,1);\n        if ($last_char =~ /[a-zA-Z]/) {\n \
    \           return $last_char;\n        } else {\n            return \"\";\n \
    \       }\n    } else {\n        return \"\";\n    }\n}", "    if(length($txt)\
    \ > 0){\n        if(substr($txt,length($txt)-1,1) =~ /[a-zA-Z]+/){\n         \
    \   # print \"last char is letter\\n\";\n            return \"\";\n        }else{\n\
    \            # print \"last char is not letter\\n\";\n            return 1;\n\
    \        }\n    }else{\n        return \"\";\n    }\n}", "    return \"\" unless\
    \ $txt =~ /\\w$/;\n    return 1 if $txt =~ /\\w$/;\n    return \"\";\n}", "  \
    \  my $lastChar = substr($txt, -1, 1, '');\n    if ($lastChar =~ /[A-Za-z]/) {\n\
    \        return $lastChar;\n    }\n    else {\n        return '';\n    }\n}\n\
    </code>\n<|/ a dscore=3 tags=perl,regex |>\n<| c |>\nI agree that \"word\" is\
    \ not really a word, it's just a group of letters. But your function seems to\
    \ return True for any input that consists of 1 or more letters. Maybe you meant\
    \ `return substr($txt, -1, 1, '') =~ /[A-Za-z]/;`? This will return 1 if the last\
    \ char is a letter and 0 otherwise.\n<|/ c |>\n<| c |>\nThanks I did indeed mean\
    \ to return 1 if the last character is a letter. I corrected the typo in the code\
    \ and corrected the example input in the question.\n<|/ c |>\n<| a dscore=3 |>\n\
    Another approach with some perl magic.\n<code>\nuse strict;\nuse warnings;\nuse\
    \ feature qw(say);", "    $txt =~ s/^\\s//;\n    return if $txt eq \"\";\n   \
    \ my $last_char = $txt[-1];\n    return $last_char !~ /\\w$/;\n}", "    return\
    \ \"\" unless length $txt;\n    my $len = length($txt);\n    my $last = $txt[$len\
    \ - 1];\n    return 1 if $last =~ /[a-z]/i; \n    return \"\";\n}\n</code>\n<|/\
    \ a dscore=1 tags=perl |>\n<| c |>\nYour code is good, but you could optimize\
    \ it a little by skipping the `grep` call by doing `my $last = $txt[$len - 1];`.\n\
    <|/ c |>\n<| c |>\n: Thanks, I've done so now. By the way, it would be nice to\
    \ get the downvote removed so that a user doesn't get insane downvotes when there\
    \ are other people who think your code is better.\n<|/ c |>\n<| c |>\n: Actually,\
    \ that should be `if ($last =~ /[a-z]/i)`. But thanks anyway, as I've made a few\
    \ other changes which I've now reverted.\n<|/ c |>\n<| c |>\n: Yes, I didn't notice\
    \ the typo.\n<|/ c |>\n<| c |>\n: You don't need `grep`, you can just write `my\
    \ = grep { $_ !~ /[a-z]/i } split ' ', $txt;`\n<|/ c |>\n<| a tags=perl |>\nA\
    \ few notes:", '    my($last_char);', "    return $txt if $txt !~ /^[a-z]/;\n\
    \    my @chars = split / /, $txt;\n    $chars[-1] =~ /^[a-z]$/;\n    return 1\
    \ unless $chars[-1] =~ /^[a-z]/;\n    return \"\";\n}", "    my($last_ch) = substr($txt,\
    \ -1,  1);\n    my($is_letter) = ($last_ch =~ /[a-z]/i);\n    return(\"\") if\
    \ ($is_letter);\n    return($last_ch) if ($last_ch =~ /[^a-z]/i);\n    return(\"\
    1\");\n}", "    my $result = \"\";\n    my $last_char = $txt[-1];", "    my $last_letter\
    \ = substr($txt, length($txt)-1, 1);\n    my $word_chars = join \" \", @{$_[0]};\n\
    \    if ($word_chars =~ m/\\b$last_letter\\b/) {\n        return \"\";\n    }\n\
    \    return 1;\n}", "    my $ret = $txt =~ tr/a-zA-Z//;\n    return $ret ? $ret\
    \ : \"\";\n}", "    return '' if !$txt or !length $txt;\n    my($last_char) =\
    \ substr($txt, -1, 1);\n    return '' if $last_char eq ' ' or $last_char eq '\\\
    t';\n    return $last_char unless $last_char =~ /\\w/;\n    return '';\n}", " \
    \   $txt =~ s/^\\s*|\\s*$//g;\n    $txt =~ s/^\\s*([A-Za-z])$/$1/g;\n    $txt\
    \ =~ s/\\s+$//g;\n    $txt =~ s/^\\s+//g;\n    $txt;\n}", "    \n    # Find the\
    \ last character in the string.\n    my $last_char = substr($txt, length($txt)\
    \ - 1, 0);", "    $txt =~ s/^\\s*//;\n    my $char = $1;\n    $char =~ s/^\\s+//;\n\
    \    $char =~ s/\\s+$//;\n    $char =~ s/\\s//g;\n    return if $char eq \"\"\
    ;\n    return $char =~ /[a-z]/i;\n}", '    my($last_char) = $txt->[-1];', "  \
    \  my($last_char) = substr($txt, -1, 1);\n    chomp($last_char);\n    if ($last_char\
    \ =~ /\\w/) {\n        return \"\";\n    } else {\n        return $last_char;\n\
    \    }\n}", "    my($letter) = $txt =~ /[a-zA-Z]$/;\n    my($last) = $txt =~ /.*([a-zA-Z])$/;\n\
    \    if ($letter) {\n        return $last;\n    } else {\n        return \"\"\
    ;\n    }\n}", "    my($letter) = substr($txt, -1, 1);\n    return $letter if $txt\
    \ =~ /\\w$/i;\n    return '';\n}", "    return 1 if $txt =~ /\\W$/;\n    return\
    \ 1;\n}", "    my $result = \"\";\n    my $last_char = \"\";\n    my $is_a_letter\
    \ = 0;", "    my($last) = length($txt)-1;\n    for(my $i=0;$i<$last;$i++) {\n\
    \        $txt =~ /[a-zA-Z]/;\n        next if $i == $last;\n        return \"\"\
    ;\n    }\n    return 1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work because\
    \ the first and last characters are not alphabetic. It returns 1 if the string\
    \ has any word that ends with an alphabetic character.\n<|/ c |>\n<| c |>\nyeah\
    \ i missed that part sorry for the mistake i just edited the answer\n<|/ c |>\n\
    <| a |>\nHere is another perl one-liner that will work:\n<code>\nperl -ne 'print\
    \ \"$1\" if $_ !~ /[[:alpha:]]$/ && $_ !~ /\\b[[:alpha:]]\\b/' your_file\n</code>\n\
    <|/ a tags=perl dscore=0 |>\n<| c |>\nThis does not work because the first and\
    \ last characters are not alphabetic. It returns 1 if the string has any word\
    \ that ends with an alphabetic character.\n<|/ c |>\n<| a |>\nOne liner using\
    \ ternary operator\n<code>\nperl -ne 'print substr($_, -1) eq \"\" ? 1 : (print\
    \ substr($_, -1) eq \"z\" ? 0 : -1)' your_file\n</code>\n<|/ a dscore=0 tags=perl\
    \ |>\n<| a dscore=0 |>\n<code>\nperl -ne '$c=$_; $c&&s/\\b(\\w+)\\b/\\U$1\\E/;\
    \ print $c' < your_file\n</code>\n<|/ a tags=perl |>\n<| c |>\nWhat happens if\
    \ a word ends with an apostrophe?\n<|/ c |>\n<| c |>\n`perl -ne '$c=$_; $c&&s/\\\
    b(\\w+)\\b/\\U$1\\E/; print $c' < your_file` : it works with apostrophe\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI came up with following solution:\n<code>", "    return\
    \ $txt if $txt !~ /^$/;\n    my($last) = substr($txt, -1, 1);\n    return $last\
    \ =~ /[a-zA-Z]/ ? $last : \"\";\n}", "    my(@chars) = split /\\s+/, $txt;\n \
    \   return '' unless (@chars);", "    return \"\" if($txt eq '');\n    $txt =~\
    \ s/\\s+$//;\n    return \"\" if(!$txt =~ /^[[:alpha:]]$/);\n    $txt =~ s/^[[:alpha:]]+\\\
    K\\s+//s;\n    return \"\" if($txt =~ /^[^[:alpha:]]$/);\n    return 1;\n}", " \
    \   chomp($txt);\n    return $txt unless $txt =~ /^[a-z ]+$/i;\n    return $txt;\n\
    }", "    $txt =~ m{ ([^A-Za-z0-9_]) $}xi;\n    $1 eq '' ? '' : $1;\n}", "    my\
    \ $last_char = substr($txt,-1,1);\n    $txt =~ m/^([a-z]+)($)$/i;\n    return\
    \ $1;\n}", "    $txt =~ s/^\\s*//;\n    $txt =~ s/\\s+$//;", "    return \"\"\
    \ unless $txt;\n    $txt =~ s/\\b([[:alpha:]])$//;\n    return $txt if $txt;\n\
    }", "    my(@words) = split (/\\s+/, $txt);\n    my($lastChar) = substr($txt,\
    \ -1);\n    foreach my $word (@words) {\n        my(@letters) = split (/\\s+/,\
    \ $word);\n        foreach my $letter (@letters) {\n            if ($letter eq\
    \ $lastChar) {\n                return 0;\n            }\n        }\n    }\n \
    \   return 1;\n}", "    return 0 unless length $txt;\n    $txt =~ s/\\s//g;\n\
    \    my $last = substr( $txt, -1, 1 );\n    return '' unless $last =~ /[a-z]/;\n\
    \    $txt =~ s/$last//g;\n    return 1;\n}", "    chomp($txt);\n    $txt =~ /([a-z])(?!.*\\\
    1)/i;\n    return $txt if $txt =~ /\\p{Alpha}/;\n    return $txt;\n}", "    my($last_ch)\
    \ = substr($txt, length($txt), 1);\n    my($word_chars) = qw(a e i o u);\n   \
    \ my($next_word_char);\n    \n    # Look at the next word character\n    for my\
    \ $word (@$word_chars) {\n        if ($next_word_char = $word =~ /(\\w)/) {\n\
    \            $next_word_char = lc ($1);\n            last;\n        }\n    }",
  "    return 1 if substr($txt, -1) == \" \";\n    return 1 if substr($txt, -1) !=\
    \ \" \" and\n             substr($txt, -1) != \"\\n\" and\n             substr($txt,\
    \ -1) != \"\\r\";\n    return \"\";\n}", "    return 1 if ( length($txt) > 0 &&\
    \ ( $txt[-1] =~ /[a-z]/ && $txt[-1] !~ /[a-z]+/ ) );\n    return '';\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is nice, but you aren't considering word boundaries.\n\
    <|/ c |>\n<| a tags=perl,regex |>\nOne way:\n<code>\nmy $x = \"applepie\";\n$x\
    \ =~ s/[^a-z]*$/_/;\nprint \"$x\\n\"; # apple_pie \n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n+1 for the _/; I didn't know that feature :)\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\n<code>\n/^[a-z]*[^a-z]+$/i\n</code>\nTry this.See demo.\nhttps://regex101.com/r/zO3hV5/1\n\
    <|/ a dscore=2 |>\n<| a tags=perl,regex |>\n<code>\n(\\w+)([a-z]+)$\n</code>\n\
    Try this.See demo.\nhttps://regex101.com/r/hR8jV1/4\n<|/ a dscore=2 |>\n<| a tags=perl,regex\
    \ dscore=2 |>\nThis one works:\n<code>\ns/[^a-z]*$/_/;\n</code>\nI hope this helps\
    \ others.\n<|/ a |>\n<| a |>\nThe question is about replacing \"foo\" with \"\
    _foo\", not replacing \"foo\" with \"_foo\".\nThe regexp ^\\w*$ is wrong (matches\
    \ empty string) and \\w* matches empty string; it would be more correct to use\
    \ \\w for \"word characters\". The next step is to find out which word boundary\
    \ the regex matches.\nLet's use \\B (negative word boundary). \\B matches \"not\
    \ preceded by\". So \\Bfoo would match foo but not foobar.\nNow we know the word\
    \ boundary, we can try to find a letter that is not a \"word\" character before\
    \ and after the word boundary. Hence the regexp ^\\B\\w\\w*$\\B. Note the \\B\
    \ is escaped with \\: this is to prevent a \\B being interpreted as a normal \\\
    B.\n<code>\nuse strict;\nuse warnings;\nuse feature 'say';", "    $txt =~ s/^\\\
    s+//;\n    return 1 if $txt =~ /^[a-z]+$/i;\n    return \"\";\n}", "    my $last_char\
    \ = substr($txt,-1);\n    \n    if($last_char !~ m/^[A-z]/) {\n        return\
    \ \"\";\n    } else {\n        return 1;\n    }\n}", "    my $letter = substr($txt,\
    \ -1, 1);\n    my @words = split(/ /, $txt);\n    foreach my $word (@words) {\n\
    \        if ($letter ne $word && $letter !~ /^\\w$/) {\n            return $letter;\n\
    \        }\n    }\n    return $letter;\n}", "    if(length($txt) == 1) {\n   \
    \     return 1;\n    } elsif(length($txt) > 1 && !$is_word_char($txt[$txt->length\
    \ - 1])) {\n        return 1;\n    } else {\n        return \"\";\n    }\n}",
  "    my($letter) = $txt =~ /^.([a-zA-Z])$/;\n    my($last_letter) = $txt =~ /^.([a-zA-Z])$/;\n\
    \    if($last_letter eq $letter) {\n        return \"\";\n    } else {\n     \
    \   return 1;\n    }\n}", "    # Initialize variables.\n    my $word = \"\";\n\
    \    my $length = $txt->length();\n    my $is_last_char;\n    my $previous_char;\n\
    \    \n    # Iterate through the string.\n    for my $i (0 .. $length - 1) {\n\
    \        $is_last_char = substr($txt, $i, 1)\n            =~ /[a-zA-Z]$/;\n  \
    \      if ($is_last_char) {\n            $word = $word.\" \".substr($txt, $i,\
    \ 1);\n        }\n        elsif ($previous_char ne \" \" && $word ne \"\") {\n\
    \            return 1;\n        }\n        $previous_char = substr($txt, $i, 1);\n\
    \    }\n    return $is_last_char || $word ne \"\";\n}", "    my ($i) = length($txt);\n\
    \    my $last_char = substr($txt, $i, 1);\n    my $word = $txt;\n    $word =~\
    \ s/\\s//g;\n    return 1 if ($word =~ /^([A-Za-z])$/);\n    return '';\n}", " \
    \   return \"\" if !defined $txt || length($txt) < 1;\n    my ($last) = substr($txt,\
    \ -1, 1, '');\n    return \"\" if $last !~ /[a-zA-Z]+$/;\n    return 1;\n}", '    my
    @words = split /\s+/, $txt;', "    $txt =~ s/$letter_char//;\n    if ($txt !~\
    \ /\\w/ && $txt !~ /^$letter_char$|^$word_char$/) {\n        return 1;\n    }\n\
    \    else {\n        return \"\";\n    }\n}", "    $txt =~ s/\\s+/ /g;\n    $txt\
    \ =~ s/[^a-z]/\\n/ig;\n    return ($txt eq '') ? \"\" :  \"\\n\" ;\n}", "    chomp\
    \ $txt;\n    return 1 if $txt =~ m/^[a-z]+$/i; # empty string or only spaces\n\
    \    return 1 if $txt !~ m/^[a-z]+$/i; # only letters\n    return \"\";\n}", " \
    \   my($last) = substr($txt, length($txt) - 1, 1);\n    if ($last =~ /^[a-zA-Z]$/)\
    \ {\n        $txt;\n    } else {\n        $txt;\n    }\n}", "    return 1 if substr($txt,\
    \ -1) != '\\@';\n    return '';\n}", "    if ( $txt =~ /\\A\\S/ ) {\n        my\
    \ ( $last_char ) = split ' ', $txt;\n        return $last_char unless $last_char\
    \ =~ /[A-Z]/;\n    }\n    return '';\n}", "    my $txtlen = length($txt);\n  \
    \  return 1 if $txtlen == 0;\n    substr($txt, $txtlen-1, 1) =~ /\\w/;\n    return\
    \ 1;\n}", "    return 1 unless $txt =~ /\\w$/;\n    return $txt[-1] if $txt[-1]\
    \ =~ /\\w$/;\n    return '';\n}", "    if ($txt =~ /^(.)(.)\\s(.)$/ && $txt !~\
    \ /$1/) {\n        $txt =~ /([^A-Z]$)/;\n        return $1;\n    }\n    return\
    \ $txt;\n}", "    my($last_char) = substr($txt, length($txt) - 1, 1);\n    my\
    \ $word = get_word_from_text($txt);\n    if ($word != \"\") {\n        if ($word\
    \ !~ /($last_char)/g) {\n            return 0;\n        }\n    }\n    return 1;\n\
    }", "    if($txt =~ /^[A-Za-z0-9]+/) {\n        return $txt;\n    }\n    else\
    \ {\n        return '';\n    }\n}", "    \n    return \"\" if $txt =~ /^$/;\n\
    \    \n    $txt =~ s/^.([^ ]*).*$/$1/;\n    \n    foreach my $ch ( split //, $txt\
    \ ) {\n        return 1 unless $ch =~ /^[a-z]/;\n    }\n    \n    return \"\"\
    ;\n}", "    $txt =~ tr/A-Z/a-z/;\n    return \"\" if $txt !~ /[a-z]/;\n    return\
    \ 1;\n}", "    # $txt is \"apple pi e\" but \"e\" is not part of a word\n    #\
    \ so return an empty string \"\".\n    # $txt is \"\" but \"\" contains no non-alphabetic\
    \ characters\n    # so return \"\".\n    # $txt is \"apple pie\" but \"pie\" is\
    \ not part of a word\n    # so return \"\".\n    # $txt is \"apple\" but \"apple\"\
    \ contains only alphabetic\n    # characters so we return \"\".\n    # $txt is\
    \ \"pie\" but \"pie\" contains only alphabetic\n    # characters so we return\
    \ \"\".\n    if ($txt =~ /[^a-z]/i) {\n        return \"\";\n    }\n    else {\n\
    \        return 1;\n    }\n}\n</code>\n<|/ a tags=regex,perl |>\n<| a dscore=0\
    \ |>\nA different approach that also covers cases like \"apple pie\" where \"\
    pie\" is not at the end of string is\n<code>\nif ($txt =~ /\\w$/) {\n    # $txt\
    \ is \"apple pie\" but \"pie\" is not at the end of string\n}\n</code>\n<|/ a\
    \ tags=regex,perl |>\n<| c |>\nThis doesn't seem to work in my perl: print $txt\
    \ =~ /\\w$/ ? \"Yes\" : \"No\";\n<|/ c |>\n<| c |>\nThe `\\w` matches word characters,\
    \ such as `a-zA-Z0-9_`, not just alphabetic characters. Also, the `\\w` also matches\
    \ `-`, which is not the end of string; you probably meant to use `\\W`.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nYou can use negative lookahead:\n<code>\n(?!\\w*$)\n</code>\n\
    <|/ a tags=regex,perl |>\n<| a tags=regex,perl |>\nThis is not the best solution,\
    \ but it works. I think I like the second solution better, because it doesn't\
    \ rely on a character group. \n<code>\nuse strict;\nuse warnings;\nuse 5.010;",
  "    $txt =~ s/^[^ ]//;\n    return $txt unless $txt =~ /[a-zA-Z]/;\n    return\
    \ \"\";\n}", "    return \"\" if $txt eq \"\";\n    $txt =~ s/^\\s+//;\n    $txt\
    \ =~ s/\\s+$//;\n    $txt =~ s/\\s+/ /g;\n    my($word) = $txt =~ m/([^\\s]+)/;\n\
    \    return \"\" if $word eq \"\";\n    return 1 if $word !~ m/([A-Z])$/;\n  \
    \  return \"\";\n}", "    my(@words) = split(' ', $txt);\n    my $last_word_char\
    \ = substr($words[$#words], -1, 1);\n    return ($last_word_char =~ m/[a-z]/ ?\
    \ \"\" : \"1\");\n}", "    if ($txt !~ /\\w$/) {\n        $txt =~ s/\\w$//;\n\
    \    }\n    return $txt;\n}\n</code>\n<|/ a dscore=3 tags=perl,regex |>\n<| c\
    \ |>\nThis one still has a problem when the text is `AA AB AC AD AE AF BA`, because\
    \ of the second `\\S` matching `BB`\n<|/ c |>\n<| c |>\n- yes I realized that\
    \ shortly after I posted... I've added a fix in an edit to the post\n<|/ c |>\n\
    <| c |>\n- thanks for pointing that out... I've added a fix and also a couple\
    \ comments to explain how it works (and why it works).\n<|/ c |>\n<| c |>\n- yeah\
    \ I thought I had a good understanding of how it works, but thanks for pointing\
    \ out the problem... it's still a bit buggy when the text is `A B C D E F G`.\
    \ I'm not sure what to think of that now.\n<|/ c |>\n<| c |>\n- I think I fixed\
    \ it now by adding another `\\S` to the `[!\\w]` part of the regex.\n<|/ c |>\n\
    <| a tags=perl,regex |>\nYou don't need to use regular expressions to do this:\n\
    <code>\nmy %letters =;\nmy $letter = shift(@letters);", "    my($len) = $txt->length();\n\
    \    my($last) = $txt->substr($len-1,1);\n    my($non_letter) = $txt=~ /[^a-z]/;",
  "    my($last_char);\n    my(@word);\n    my($result);", "    $txt =~ s/^\\s*(\\\
    S+)\\s*$/$1 /s;\n    return $txt unless $txt =~ m/\\w$/i;\n    return \"\";\n\
    }\n</code>\nThe code above is based off the example given in Hunter McMillen's\
    \ answer. The only thing that changes are the regular expressions for finding\
    \ the last character and the function that checks it. The example uses a regex\
    \ that works in Perl 5.10 and 5.11, but only tested in 5.10. If anyone has any\
    \ comments or suggestions on how to get it to work with 5.9 I would greatly appreciate\
    \ it.\n<|/ a |>\n<| c |>\nI like your use of !m//, thanks for the info. Also,\
    \ I think your check should be `s/^\\s*(\\S+)\\s*$/$1 /i;`\n<|/ c |>\n<| c |>\n\
    , thank you for the clarification. I tested the code and it worked as is. I will\
    \ update the example so that it clearly shows what I meant.\n<|/ c |>\n<| a dscore=0\
    \ tags=perl,regex,perlbrew,backreference,perl-module |>\nThe example provided\
    \ by hunter is incorrect, and does not work for me, because it assumes the last\
    \ word is never empty. I added a fix to fix that issue.\n<code>\nuse 5.012;\n\
    use warnings;\nuse utf8;\nbinmode STDOUT, \":utf8\";", "    my($word) = $txt =~\
    \ /[^ ]+/;\n    my($last_char) = $txt =~ /^([a-z])/ ? $1 : \"\";\n    return $last_char\
    \ ne $word[-1];\n}", "    my $last_char;\n    if ($txt =~ /\\S/) {\n        $last_char\
    \ = substr($txt, length($txt)-1, 1);\n    } else {\n        $last_char = '';\n\
    \    }\n    return $last_char unless $last_char =~ /\\w/;\n    return '';\n}",
  "    my($last_char);\n    my($word);\n    my($letter);\n    my $result = \"\";\n\
    \    \n    # Split the text into a word and letter group\n    $word = $txt =~\
    \ /(\\w+)/;\n    $letter = $txt =~ /(\\p{L})/;", "    # remove all blanks, split\
    \ the string in words by \" \"\n    my(@words) = split(/ /, $txt);\n    # get\
    \ the last word\n    my($word) = $words[-1];\n    # check if last word is a letter\n\
    \    my($letter) = uc(substr($word, -1, 1, 1));\n    return $letter unless $letter;\n\
    \    return $txt;\n}\n</code>\nThis also works for strings with more than one\
    \ word. For example, the following string returns \"\" for last letter check:\n\
    <code>\ncheck_if_last_char_is_a_letter(\"apple pi e pie\")\n</code>\n<|/ a tags=perl,regex\
    \ dscore=0 |>\n<| c |>\nThanks a lot for the answer, but this solution does not\
    \ take into account the case when an alphabet (like \"a\") is at the beginning\
    \ of the string. Also, it does not return the correct result for strings like\
    \ \"apple pie e\".\n<|/ c |>\n<| c |>\n: You're right. I edited my answer and\
    \ added a function that should work for your input strings. Thanks for pointing\
    \ that out!\n<|/ c |>\n<| a tags=perl,regex |>\nAnother solution using regex:\n\
    <code>", "    my $last_char = $txt->[-1];\n    return \"\" unless defined $last_char;\n\
    \    my ($letter, $rest) = $last_char =~ /(\\p{alpha})+/ or return;\n    return\
    \ $letter unless $rest;\n    my $word = $txt->[$txt->rindex($txt) - 1];\n    #\
    \ $word is a string of non-space characters that ends with $letter.\n    # So\
    \ return 1 if the last character in $word is not a\n    # non-space character,\
    \ and if the last character in $word is a\n    # non-space character then check\
    \ that last character in $word\n    # is a non-space character.\n    return 1\
    \ if $word =~ /\\A($letter)(?![^ ]* $letter)$/;\n    return \"\";\n}", "    #\
    \ return an empty string if there are no characters\n    return '' if ($txt eq\
    \ '');", "    my($word);\n    \n    $word .= substr($txt, -1);\n    return 1 if\
    \ ($word =~ /[a-zA-Z]/ and !$word =~ /[^A-Za-z]/);\n    return \"\";\n}", "  \
    \  return $txt if !length($txt);\n    my $is_first_char = 1;\n    my $is_last_char\
    \ = 0;\n    my $txt1 = substr($txt, 0, -1);\n    my $txt2 = substr($txt, 0, -3);\n\
    \    my $txt3 = substr($txt, 0, -4);\n    my $txt4 = substr($txt, 0, -5);\n  \
    \  my $txt5 = substr($txt, 0, -6);\n    my $txt6 = substr($txt, 0, -7);\n    my\
    \ $txt7 = substr($txt, 0, -8);\n    my $txt8 = substr($txt, 0, -9);\n    my $txt9\
    \ = substr($txt, 0, -10);\n    my $txt10 = substr($txt, 0, -11);", "    if ($txt\
    \ =~ /(\\S*)(\\w)/) {\n      return $1 if $2 !~ /\\w$/;\n    }\n    return \"\"\
    ;\n}", "    return $txt if !defined $txt || $txt eq \"\";\n    return $txt if\
    \ !length $txt || $txt =~ /[^a-z]/i;\n    return 1;\n}", "    my($last_char) =\
    \ $txt;\n    return $last_char unless length($last_char);\n    chomp($last_char);\n\
    \    if($last_char =~ m/^[a-zA-Z]$/i) {\n        return '';\n    }\n    return\
    \ 1;\n}", "    my @letters = qw(a e i o u y o e i o);\n    return $txt if $txt\
    \ =~ /^[a-z\\s]$/;\n    $txt =~ s/[a-z\\s]$/a/g;\n    return $txt if $txt =~ /$letters/;\n\
    \    return '';\n}", "    return \"\" if $txt eq \"\" || $txt =~ /^\\s*$/;\n \
    \   return \"\" unless $txt =~ /\\w$/;\n    return $txt =~ /(\\w)\\z/;\n}", " \
    \   $txt =~ s/^.// if $txt eq \"\";\n    $txt =~ s/.([a-z])$//;\n    return $txt\
    \ if $txt ne \"\";\n    return \"\";\n}", "    return 1 if $txt =~ /^([a-z]+[^a-z])$/i;\n\
    \    return \"\" if $txt eq \"\" ;\n    return $txt;\n}", "    return \"\" if\
    \ $txt eq \"\";\n    $txt =~ /^(\\w)$/;\n    $1 eq $txt[-1] ? \"\" : 1;\n}", " \
    \   my($last_char) = $txt =~ m/^.*\\s(\\w)\\b.*$/;\n    return $last_char eq ''\
    \ ? '' : $last_char;\n}", "    my($last_letter) = substr($txt, -1);\n    return\
    \ \"\" unless $last_letter =~ /[a-zA-Z]/;\n    return 1;\n}", "    \n    if($txt\
    \ eq \"\")\n    {\n        return \"\";\n    }\n    \n    my $is_last_char = substr($txt,\
    \ -1, 1) =~ m/^[a-zA-Z]$/;\n    \n    if($is_last_char)\n    {\n        return\
    \ \"\";\n    }\n    \n    return 1;\n}", "    return \"\" if $txt eq \"\"; # empty\
    \ string is a special case\n    my $lastchar = $txt[$#txt]; # get last char\n\
    \    return \"\" if $lastchar eq \"\"; # empty string\n    my $lastword_flag =\
    \ 0;\n    my @words = split(\" \", $txt);\n    foreach my $word (@words) {\n \
    \       last if $word eq \"\"; # an empty word\n        my $lastchar_w = $word[$#word];\
    \ # get last char\n        return \"\" if $lastchar_w eq \"\"; # empty string\n\
    \        return 1 if $lastchar_w eq $lastchar; # last char is a word\n       \
    \ $lastword_flag = 1;\n    }\n    return \"\" if !$lastword_flag; # empty string\n\
    \    return $lastchar;\n}", "    if(length($txt) < 1) {\n        return $txt;\n\
    \    }\n    my $last_char = substr($txt, length($txt)-1, 1);\n    return 0 if($last_char\
    \ =~ /[A-Za-z]/);\n    return 1;\n}", "    return $txt if length($txt) <= 1;\n\
    \    my($last_char) = substr($txt, -1, 1);\n    return '' unless $last_char =~\
    \ /^[a-zA-Z]$/;\n    return $last_char;\n}", "    return \"\" unless length $txt;\n\
    \    my($last_char) = $txt[-1];\n    return \"\" unless $last_char =~ /^[a-z]+$/i;\n\
    \    return 1;\n}", "    my($last_char) = substr($txt, -1, 1, '');\n    my($word_list)\
    \ = split(/ /, $txt);\n    my($word_len) = scalar($word_list);", "    # Note:\
    \ This assumes that \"word\" is a group of\n    # characters separated by space.\
    \ If \"word\"\n    # doesn't need to be a group of characters separated by space,\n\
    \    # then one should use 'split' instead of 'split' here.\n    my $word = $txt;\n\
    \    my $last_char = $word[$#word];\n    if ($last_char =~ /\\w$/) {\n       \
    \ return 1;\n    }\n    else {\n        return \"\";\n    }\n}", "    my $last_char\
    \ = $txt->[$#{$txt}-1];\n    my $lastletter = chr(ord($last_char) + 32);\n   \
    \ return $last_char if $lastletter =~ /\\w/;\n    return \"\";\n}", '    return
    "" if $txt =~ /^$/;', "    $txt =~ s/[[:alpha:]]$//;\n    return $txt unless $txt\
    \ =~ /\\s/;\n    return \"\";\n}", "    my $char = substr($txt, -1, 1, '');\n\
    \    return '' if $char eq ''; # blank char\n    my $letter = substr($txt, -1,\
    \ 1);\n    return '' if $letter eq '\\cA';\n    return '' if $letter eq '\\cF';\n\
    \    return '' if $letter eq '\\cN';\n    return '' if $letter eq '\\cZ';\n  \
    \  return '' if $letter eq '\\cL';\n    return '' if $letter eq '\\cK';\n    return\
    \ '' if $letter eq '\\cN';\n    return '' if $letter eq '\\cP';\n    return ''\
    \ if $letter eq '\\cR';\n    return '' if $letter eq '\\cO';\n    return '' if\
    \ $letter eq '\\cS';\n    return '' if $letter eq '\\cT';\n    return '' if $letter\
    \ eq '\\cW';\n    return '' if $letter eq '\\cX';\n    return '' if $letter eq\
    \ '\\cC';\n    return '' if $letter eq '\\cG';\n    return '' if $letter eq '\\\
    cM';\n    return '' if $letter eq '\\cK';\n    return '' if $letter eq '\\cP';\n\
    \    return '' if $letter eq '\\cO';\n    return '' if $letter eq '\\cU';\n  \
    \  return '' if $letter eq '\\cV';\n    return '' if $letter eq '\\cB';\n    return\
    \ '' if $letter eq '\\cU';\n    return '' if $letter eq '\\cT';\n    return ''\
    \ if $letter eq '\\cV';\n    return '' if $letter eq '\\cE';\n    return '' if\
    \ $letter eq '\\cG';\n    return '' if $letter eq '\\cG';\n    return '' if $letter\
    \ eq '\\cI';\n    return '' if $letter eq '\\cY';\n    return '' if $letter eq\
    \ '\\cN';\n    return '' if $letter eq '\\cH';\n    return '' if $letter eq '\\\
    cA';\n    return '' if $letter eq '\\cW';\n    return '' if $letter eq '\\cW';\n\
    \    return '' if $letter eq '\\cC';\n    return '' if $letter eq '\\cL';\n  \
    \  return '' if $letter eq '\\cU';\n    return '' if $letter eq '\\c", "    return\
    \ substr($txt,-1) != ' ' && substr($txt,-1) != '\\n' && substr($txt,-1) != '\\\
    r' && substr($txt,-1) != '\\t' && substr($txt,-1) != ' ';\n}", "    if ($txt =~\
    \ /^([a-z]+)(?!.*([a-z]+\\s))$/) {\n        return 1;\n    }\n    else {\n   \
    \     return 0;\n    }\n}", "    my $lastchar = substr($txt, length($txt)-1, 1);\n\
    \    my @chars = split(/ /, $txt);\n    foreach my $char (@chars) {\n        if\
    \ ($char ne $lastchar) {\n            return $char eq $lastchar;\n        }\n\
    \    }\n    return 0;\n}", "    \n    if ($txt eq \"\") {\n        return \"\"\
    ;\n    }\n    \n    if ($txt =~ /\\w$/) {\n        return 1;\n    } else {\n \
    \       return \"\";\n    }\n}", "    $txt =~ s/^\\s*|\\s*$//g;\n    $txt =~ s/^\\\
    s+|\\s+$//g;\n    $txt =~ s/\\s+/ /g;\n    my($word) = $txt =~ /(\\S)/g;\n   \
    \ my @letters;\n    foreach (@word) {\n\tif ($_ != \"\") {\n\t    if ($_ =~ /[a-z]$/i)\
    \ {\n\t\tpush(@letters, $);\n\t    }\n\t}\n    }\n    my $last_letter = $letters[-1];\n\
    \    return $last_letter if (defined $last_letter);\n    return \"\";\n}", " \
    \   my(@words) = $txt =~ /\\b(\\w+)\\b/;\n    my $last_char = $words[$#words];\n\
    \    if($last_char =~ /^[a-zA-Z]$/) {\n        $last_char = '';\n    }\n    elsif($last_char\
    \ =~ /^[\\s\\-\\.\\?\\!]$/) {\n        $last_char = '';\n    }\n    return $last_char;\n\
    }\n</code>\nOutput:\n<code>\npi e apple pie\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=perl,regex |>\nThis solution doesn't use regex, but is fairly straightforward.\n\
    <code>\nuse strict;\nuse warnings;", "    my($last_char) = substr($txt,length($txt)-1,1);\n\
    \    my($last_word_end);\n    while($last_char=~ m/^\\W$/) {\n        $last_word_end++;\n\
    \        $last_char = '';\n    }\n    for($last_word_end; $last_word_end > 0;\
    \ $last_word_end--) {\n        if($txt =~ m/^([a-z])\\w$/i) {\n            return\
    \ 1;\n        }\n    }\n    return '';\n}", "    my $last_char = substr($txt,\
    \ -1, 1);\n    if ( $last_char !~ /\\w/ ) {\n        return 1;\n    } else {\n\
    \        return $last_char;\n    }\n}", "    my($last_char);\n    my($word_end);\n\
    \    my($word_found);\n    my($last_letter);", "    return $txt if !$txt || $txt\
    \ eq '';\n    my $last_char;\n    my $is_last_char;\n    for my $char (split //,\
    \ $txt) {\n        $is_last_char = 1 unless $is_last_char;\n        $last_char\
    \ = $char;\n        $is_last_char = 1 if $char =~ /[A-Za-z]$/;\n    }\n    $is_last_char;\n\
    }", "    return 1 unless $txt =~ /^[a-z]*$/i;\n    my @words = split \" \", $txt;\n\
    \    return 1 unless @words[-1] =~ /^[a-z]+$/i;\n    return \"\";\n}", "    \n\
    \    my $last_char = substr($txt, -1, 1, 's'); # last character of a string\n\
    \    \n    return \"\" if $last_char ne \" \" || !check_if_word_is_a_letter($last_char);",
  "    my @words = split(/ /, $txt);\n    my $letter = $words[-1];\n    return if\
    \ $letter eq '';\n    my $isLetter = &is_alpha($letter);\n    return $isLetter;\n\
    }", "    if ($txt eq \"\") {\n        return \"\";\n    }\n    my ($last_char)\
    \ = substr($txt, length($txt) - 1, 1);\n    my ($last_char_of_word) = substr($txt,\
    \ length($txt) - 2, 2);\n    if ($last_char_of_word =~ /[a-zA-Z]/) {\n       \
    \ return \"\";\n    }\n    return 1;\n}", "    my($len) = length($txt);\n    my($last_char\
    \ = $txt[$len-1]);\n    \n    return 1 if ($last_char !~ /\\w$/);\n    \n    return\
    \ \"\";\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=regex,perl,string,ruby dscore=1\
    \ |>\nHere is a solution in Ruby\n<code>\ndef not_a_word(s)\n  s.tr!(' ','')\n\
    \  s.gsub!(/[^A-Za-z]/, '') && !s.slice!(0)\nend", "    $txt =~ s/^\\s*//;\n \
    \   $txt =~ s/\\s*$//;\n    $txt =~ s/\\s+/ /g;\n    $txt =~ /([A-Z]+)$/;\n  \
    \  return $1 ? $1 : 0;\n}", "    my($last_char) = substr($txt, -1, 1, '');\n \
    \   if($last_char =~ /[a-zA-Z]/) {\n        $txt =~ s/$last_char//;\n    }\n \
    \   return $txt;\n}\n</code>\n<|/ a |>\n<| a |>\nThe way you implemented your\
    \ function is very inefficient. Even if you did write some fast code (using regular\
    \ expressions), it would not work correctly in all cases (for example, try removing\
    \ the letter e before checking if e is the last character or not).\nA better way\
    \ to implement this would be to use a regular expression which matches the pattern\
    \ \"e\" at the end of each string. Also, use the \\G assertion to find if there\
    \ are preceding matches at the end of a string:\n<code>\nuse strict;\nuse warnings;",
  "    return $txt if $txt !~ /\\w$/;\n    # $txt may have spaces before and after\
    \ the alphabetical character\n    my $i = index($txt, ' ');\n    return $i ? ($i\
    \ < length($txt) - 1 ? $txt : '') : '';\n}", "    my @words = split(/ /, $txt);\n\
    \    \n    for (my $i = 0; $i < @words; $i++) {\n        $last_char = substr($words[$i],\
    \ length($words[$i]), 1);\n        if ($last_char) {\n            return \"\"\
    \ unless $last_char =~ /[a-zA-Z]/;\n        }\n    }\n    \n    return 1;\n}",
  "    \n    # If the last character is not a letter\n    return if ($txt =~ /[^a-zA-Z\\\
    s]$/);\n    \n    # Otherwise, if the last character is alphabetical\n    return\
    \ if ($txt =~ /^[a-zA-Z]$/);\n    \n    # Otherwise, if the last character is\
    \ numeric\n    return if ($txt =~ /^[0-9]$/);\n    \n    # Otherwise, if the last\
    \ character is a space\n    return if ($txt =~ /^ /);\n    \n    # Otherwise,\
    \ if all characters are the same\n    return if ($txt eq \"\");\n    \n    # Otherwise,\
    \ return 1\n    return 1;\n}", "    my(@letters) = (\"a\" .. \"z\");\n    my($last)\
    \ = substr($txt, -1, 1);\n    return (grep { $last eq $_ }@letters);\n}", "  \
    \  $txt =~ /^(.)\\s(\\S)/;\n    return $1;\n}\n</code>\n<|/ a tags=perl,regex\
    \ dscore=2 |>\n<| c |>\nThanks, this is great. I've accepted an answer that shows\
    \ a more straight-forward approach to my question of how to use regex to solve\
    \ this problem. I'm glad you took the time to add an explanation for why my approach\
    \ was wrong.\n<|/ c |>\n<| c |>\nThanks again. I've upvoted your answer but I'm\
    \ unable to accept it since it doesn't answer the question of how to use regex\
    \ to solve this problem.\n<|/ c |>\n<| c |>\n, The question wasn't clear about\
    \ what \"word\" meant. My solution solves the question as stated. My solution\
    \ uses no regexes and can easily be adapted to solve your problem by changing\
    \ `'apple pie eat'` to `'apple pie'`.\n<|/ c |>\n<| c |>\nYou're right, my question\
    \ wasn't clear about what \"word\" meant. I've updated my question to be more\
    \ specific. Sorry for the confusion.\n<|/ c |>\n<| c |>\n, You're right, my question\
    \ wasn't clear about what \"word\" meant. I've updated my question to be more\
    \ specific. Sorry for the confusion.\n<|/ c |>\n<| a dscore=0 |>\nIf you want\
    \ a purely regex solution then the following will match the last character of\
    \ a line:\n<code>\n([^\\s\\w]+)($|\\s$)\n</code>\nIt matches all characters that\
    \ are not whitespace or word characters before and after the line. Of course you\
    \ still have to test whether that last character is a letter, digit, underscore\
    \ or some other punctuation character, but this should be close to what you want.\n\
    <|/ a tags=perl,regex |>\n<| c |>\nThanks. I've tested that regex and it works\
    \ great for me. I wonder if there is a simpler way to do it. I suppose the regex\
    \ might be easier to write if the word character had a more specific definition...\n\
    <|/ c |>\n<| c |>\nIt might be easier, but then you might have to deal with things\
    \ like \"a\xF1o\" being split into \"a\" and \"\xF1o\". Is that okay?\n<|/ c |>\n\
    <| c |>\nYes, that is okay. I've updated my question to include an example of\
    \ what I'm trying to accomplish.\n<|/ c |>\n<| c |>\nI meant more in general terms.\
    \ I'm working on some code that will have many other special ", "    my($last);\n\
    \    my($check) = ($txt =~ /^([a-z][a-z])/);\n    $last =  $1 if ($check);\n \
    \   return $last if ($last !~ /[^a-zA-Z ]/);\n    return $last;\n}", "    $txt\
    \ =~ s/\\s+$//;\n    return $txt if $txt !~ /^[a-z]/i;\n    return '';\n}", '    if($txt
    =~ /(\S\S\S\S\S\S\S)[a-z](?!\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S',
  "    return \"\" if $txt eq \"\";\n    # split text into words using space as separator\n\
    \    my(@words) =\n        split /\\s+/, $txt, -1;  # split text into words using\
    \ space as separator\n    my $i;\n    for (my $i = 0; $i < @words; $i++) {\n \
    \       my $word = $words[$i];\n        if ($word ne '') {\n            # loop\
    \ through all characters\n            for (my $j = 0; $j < length($word); $j++)\
    \ {\n                my $char = $word->[$j];\n                # check if the last\
    \ character is a letter\n                # (alphabetical)\n                if\
    \ ( ord($char) >= 97 && ord($char) <= 122 ) {\n                    return 1;\n\
    \                }\n            }\n        }\n    }\n    return 0;\n}", "    if\
    \ (length($txt) == 1) {\n        return '';\n    }\n    if ($txt =~ /^[a-zA-Z]$/)\
    \ {\n        return '';\n    }\n    my $last_char = substr($txt, -1);\n    if\
    \ ($last_char =~ /[a-zA-Z]$/) {\n        return '';\n    }\n    return 1;\n}",
  "    return $txt if $txt =~ /^[^a-zA-Z]*[a-zA-Z]/;\n    return $txt if $txt =~ /^[a-zA-Z]*[^a-zA-Z]/;\n\
    \    return $txt;\n}", "    my($len) = $txt->len;\n    my($i) = $len-1;\n    my\
    \ $result;\n    for(; $i>=0; $i--) {\n        my $c = $txt->[$i];\n        if($c\
    \ !~ m/[a-zA-Z]/) {\n            $result = $c;\n            last;\n        }\n\
    \    }\n    return $result;\n}", "    my($letter) = lc(substr($txt, -1, 1));\n\
    \    if ($letter eq $_[0]) {\n        return \"\";\n    }\n    return 1;\n}",
  "    $txt =~ s/^\\s+//;  # strip leading spaces (if any)\n    $txt =~ s/\\s+$//;\
    \  # strip trailing spaces (if any)\n    my $last_char = substr($txt, length($txt)-1,\
    \ 1);  # the last character in $txt\n    my $is_a_letter = $last_char =~ /^[a-zA-Z]$/;\
    \  # the last char is a letter\n    return $is_a_letter ? $txt : '';\n}", "  \
    \  my($len) = $txt->length();\n    return ($len > 0) if ($len == 0);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    my($last_char, $next_char);\n    my($last_char,\
    \ $next_char);\n    my($last_char, $next_char);\n    my($last_char, $next_char);\n\
    \    my($last_char, $next_char);\n    m", "    return \"\" if $txt eq \"\";\n\
    \    my($word,$c) = split(/ /, $txt, -1);\n    $word = $word[-1] if length($word);\n\
    \    return 1 if $word eq lc($c); # if last char is alphabetical\n    \"\";\n}",
  "    my $end_of_word = ($txt =~ /\\w$/);\n    if($end_of_word) {\n        if($txt\
    \ =~ /([A-Z])\\w+/) {\n            return '';\n        }\n        else {\n   \
    \         return 1;\n        }\n    }\n    elsif(length($txt) == 1) {\n      \
    \  return '1';\n    }\n}", "    substr($txt, length($txt), 1) =~ /[a-z]/i;\n \
    \   return $txt if $txt !~ /[a-z]/i;\n    return \"\";\n}", "    my($last_char)\
    \ = substr($txt, length($txt) - 1, 1);\n    my($last_char_of_word_is_letter) =\
    \ is_letter($last_char);", "    $txt =~ s/\\A(\\S)/$1/g;\n    if ($txt =~ /[A-Za-z]/)\
    \ {\n        return '';\n    }\n    return 1;\n}", "    $txt =~ s/([a-z])$/\\\
    1/;\n    return $txt;\n}", "    my $last_char = $txt;\n    $last_char = $txt;",
  "    $txt =~ s/^\\s*(\\S*[\\s\\S]+)\\s*$/\\1/ or return;\n    $txt =~ s/\\s+$//;\n\
    \    return $txt if $txt =~ /[A-Z]/;\n    return;\n}", "    my($last_char) = substr($txt,length($txt)-1,1);\n\
    \    if($last_char !~ /\\w/) {\n        return \"\";\n    }\n    return $last_char;\n\
    }", "    my($last_char) = substr($txt, -1, 1);\n    my $is_last_letter = lc($last_char)\
    \ eq lc($last_char);\n    return '' if (!$is_last_letter);\n    if ($is_last_letter)\
    \ {\n        return 1;\n    }\n    if ($last_char !~ /[^a-z]/) {\n        return\
    \ 1;\n    }\n    return '';\n}", "    my($last) = substr($txt, length($txt)-1,\
    \ 1);\n    my($letter) = uc($last);", "    my @words = split(/ /, $txt);\n   \
    \ my $last_word_letter = substr($words[-1], -1);\n    my $is_last_letter = $last_word_letter\
    \ =~ /[A-Za-z]/;\n    return $is_last_letter ? \"\" : 1;\n}", "    # Return 1\
    \ if last char of $txt is a letter\n    # and is not followed by a space or a\
    \ punctuation\n    my @lc = split(\" \", $txt);\n    my $last_char = pop(@lc);\n\
    \    return 1 if ($last_char =~ /[a-zA-Z]/ &&\n            $last_char !~ /[[:punct:]]/);\n\
    \    return \"\";\n}", "    if ($txt =~ /^([a-zA-Z])+$/ && ! $txt =~ /([a-zA-Z]{2}$)/)\
    \ {\n        return $1;\n    }\n    return;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=1 tags=algorithm,perl,regex |>\nYou can just strip the whitespace,\
    \ convert to upper case and see if that is true:\n<code>\nif (lc $string =~ /^([A-Z])+$/)\
    \ {\n    # ...\n}\n</code>\n<|/ a |>\n<| c |>\nThat's a terrible idea. This isn't\
    \ going to account for people who have their keyboard configured not to use capitals.\n\
    <|/ c |>\n<| c |>\nOh, I see what you mean. `uc` will fix that.\n<|/ c |>\n<|\
    \ c |>\nThat's even worse. `uc` will convert `\xE9` to `\xC9` before `uc` even\
    \ looks at it. The regex will still allow `\xE9` to be accepted.\n<|/ c |>\n<|\
    \ c |>\nThis only works if your keyboard is set to capitals. `uc` will convert\
    \ `\xE9` to `\xC9`, but it will also convert `\xC9` to `\xC9`. In other words,\
    \ you just broke the OP's intent.\n<|/ c |>\n<| c |>\nThe regex works just fine,\
    \ even if the keyboard is not set to capitals. It's the `uc` function that's not\
    \ as useful as the regex for this task.\n<|/ c |>\n<| a |>\n<code>\nmy $str =\
    \ \"apple pi e\";\nif ($str =~ /^([a-zA-Z])+$/ && ! $str =~ /([a-zA-Z]{2}$)/)\
    \ {\n   print $1;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,perl,regex |>\n<|\
    \ c |>\nThis only works if your keyboard is set to capitals. `uc` will convert\
    \ `\xE9` to `\xC9`, but it will also convert `\xC9` to `\xC9`. In other words,\
    \ you just broke the OP's intent.\n<|/ c |>\n<| c |>\nYes, you're correct, but\
    \ I think this case is pretty much guaranteed. What I meant is it doesn't work\
    \ if your keyboard is not set to capitals. And it's an easy fix to include it.\n\
    <|/ c |>\n<| c |>\nThe regex works just fine, even if the keyboard is not set\
    \ to capitals. It's the `uc` function that's not as useful as the regex for this\
    \ task.\n<|/ c |>\n", "    my($last_ch) = $txt =~ substr($txt, -1);\n    $last_ch\
    \ =~ /\\w$/;\n    return $last_ch;\n}", "    return \"\" if $txt eq \"\";\n  \
    \  my($last_letter) = substr($txt, length($txt) - 1, 1);\n    return 0 if $last_letter\
    \ =~ /\\w/;\n    return $last_letter;\n}", "    my $last_char = substr($txt, -1,\
    \ 1);\n    return \"\" unless $last_char =~ /\\w$/;\n    return 1;\n}", "    return\
    \ $txt if $txt !~ /[\\W]$/i;\n    my $lastchar = $txt =~ s/[\\W]+$//;\n    $lastchar\
    \ =~ s/^.//;\n    return $lastchar =~ /[a-zA-Z]/;\n}", "    if ($txt =~ /\\w$/)\
    \ { # $txt ends with a letter.\n        return $txt;\n    }\n    return '';\n}",
  "    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]\
    \ ]$/;\n    return $txt if $txt =~ /[[:alpha:] ]$/;\n    return $txt if $txt =~\
    \ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:] ]$/;\n    return $txt\
    \ if $txt =~ /[[:alpha:] ]$/;\n    return $txt if $txt =~ /[[:alpha:] ]$/;\n \
    \   return $txt if $txt =~ /[[:alpha:] ]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:]]$/;\n    return $txt if $txt =~ /[[:alpha:]]$/;\n\
    \    return $txt if $txt =~ /[[:alpha:", "    my($last_letter);\n    my $is_last_letter\
    \ = 0;", "    return '' unless length($txt);\n    return $txt if $txt =~ /^[A-Za-z]+$/;\n\
    \    return $txt;\n}", "    if ($txt =~ /^(.)\\s([^a-zA-Z0-9])$/) {\n        return\
    \ $1;\n    }\n    return '';\n}", "    my($last) = substr($txt,length($txt)-1,1);\n\
    \    $last =~ m/^[a-z_]/i;\n}", "    my $last_char = $txt->[-1];\n    return ''\
    \ if $last_char eq ' '\n           || $last_char eq ',' || $last_char eq '.';\n\
    \    return $last_char =~ /[a-z]/i;\n}\n</code>\n<|/ a |>\n<| c |>\n`return ''\
    \ if $last_char eq ' '\n           || $last_char eq ',' || $last_char eq '.';`\n\
    <|/ c |>\n<| c |>\nWhat if the last character is a digit? `return '' if $last_char\
    \ eq ' '\n           || $last_char eq ',' || $last_char eq '.' || $last_char eq\
    \ '0';`\n<|/ c |>\n<| a dscore=0 |>\nIn Perl, the string \"apple\" is equivalent\
    \ to \"apple\".\n<code>\nmy = split ' ', \"apple pie ,.\";", '    my($len) = length($txt);',
  "    \n    my $last_char = substr($txt, length($txt) - 1);\n    \n    return $last_char\
    \ unless $last_char eq ' ';\n    \n    my @words = split(/ /, $txt);\n    \n \
    \   return $words[-1] if scalar(@words) > 1;\n    \n    return $words[-2] if scalar(@words)\
    \ > 0;\n    \n    return '';\n}", "    my($last) = substr($txt, length($txt)-1,\
    \ 1);\n    return \"\" if $last =~ /\\w/;\n    return 1;\n}", "    my $last_char;\n\
    \    for(split (\" \", $txt)){\n        $last_char = $_;\n        last;\n    }\n\
    \    $last_char;\n}", "    return substr($txt, (length($txt) - 1), 1) =~ /[A-Za-z]$/i;\n\
    }", "    my(@words) = split(\" \",$txt);\n    my($last);", "    my($last_char)\
    \ = $txt =~ s/^.// or return;\n    $last_char =~ tr/A-Z//d;\n    return $last_char;\n\
    }\n</code>\n<|/ a dscore=1 tags=string,perl |>\n<| c |>\nI don't think he wanted\
    \ the function to return true for \"apple pie\", but for \"apple pi\".\n<|/ c\
    \ |>\n<| c |>\nAh, yeah. I'll edit the answer.\n<|/ c |>\n<| c |>\nIt works, however\
    \ \"apple pie\" becomes 0 instead of 1\n<|/ c |>\n<| c |>\nHm. The test returns\
    \ `0` for `apple pie`, as expected. I will try to find out why...\n<|/ c |>\n\
    <| c |>\nOh well, it works for me as well :)\n<|/ c |>\n<| a |>\nTo answer your\
    \ question in the comment to another answer, you probably want something like\
    \ this:\n<code>\nmy $test = \"apple pie\";\n$test =~ /\\b\\p{L}+$/ or return 0;\n\
    return 1;\n</code>\nHere \\b is a word boundary, which doesn't match if part of\
    \ the word is a non-letter. Then \\p{L} matches any letter, plus a bunch of things\
    \ that aren't letters, like the dash and ellipses, and the plus makes it match\
    \ one or more of the previous group (\\p{L}). This regex will match at the end\
    \ of the string and if it's an alphabetical character (plus hyphen) it returns\
    \ true. If it's any other character it returns false. The $ is the end-of-string\
    \ anchor.\n<|/ a tags=string,perl dscore=1 |>\n<| c |>\nThanks again for your\
    \ effort :)\n<|/ c |>\n<| a tags=string,perl |>\nOne way of doing it would be\
    \ to first split the string into words, and then compare the lengths of the words.\
    \ Assuming that your words don't have spaces in them, this could work:\n<code>\n\
    $string = 'apple pie';\nmy = split(/ /, $string);\nprint scalar == length($words[0])\
    \ || scalar == length($words[1]) ? 1 : 0;\n</code>\nThis would print 1 (or true)\
    \ if the number of words in the string is exactly 2.\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis also seems to work, but I used the answer above by Etienne\n<|/ c |>\n\
    <| c |>\n`perl` does not have `scalar` function - use `@words` to get the same\
    \ effect.\n<|/ ", "    return '' unless $txt;\n    return '' unless defined $txt\
    \ && length $txt > 0;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
