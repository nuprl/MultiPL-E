name: HumanEval_134_check_if_last_char_is_a_letter
language: pl
prompt: "# Create a function that returns 1 if the last character\n# of a given string\
  \ is an alphabetical character and is not\n# a part of a word, and  otherwise.\n\
  # Note: \"word\" is a group of characters separated by space.\n# Examples:\n# >>>\
  \ check_if_last_char_is_a_letter(\"apple pie\")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"\
  apple pi e\")\n# 1\n# >>> check_if_last_char_is_a_letter(\"apple pi e \")\n# \"\"\
  \n# >>> check_if_last_char_is_a_letter(\"\")\n# \"\"\nsub check_if_last_char_is_a_letter\
  \ {\n    my($txt) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_if_last_char_is_a_letter;\n\
  \        if(eq_deeply($candidate->(\"apple\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e\"),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"A\"),1)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie \"),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Pumpkin pie 1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee e \"),\"\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  apple pie\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"apple pi e \"),\"\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $last_char = $txt->[-1];\n    return 1 if $last_char =~ /^[a-Z]+$/i;\n\
    \    return \"\";\n}", "    return $txt if $txt !~ /\\w/;\n    return $txt if\
    \ $txt !~ /\\w$/;\n    return $txt if $txt !~ /\\W$/;\n    return $txt if $txt\
    \ !~ /\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W$/;\n    return $txt if\
    \ $txt !~ /\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W$/;\n \
    \   return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~\
    \ /\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\\
    W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return\
    \ $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt\
    \ !~ /\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W\\W\\W$/;\n    return $txt if $txt !~ /\\W\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W\\W\\W\\W\\W", "    $txt =~ s/\\s+/ /g;\n    my $last_char = $txt\
    \ =~ m{(.)}g;\n    my $is_letter = 0;\n    if ($last_char =~ /^[A-Za-z]+$/) {\n\
    \        $is_letter = 1;\n    }\n    return $is_letter;\n}", "    if(!defined($txt)\
    \ || length($txt) < 1){\n        return \"\";\n    }", "    my($char, $i, $len)\
    \ = split(/ /, $txt);\n    return \"\" if $len < 1;\n    return \"\" if $char\
    \ eq \"\";\n    $char = $char;", "    $txt =~ tr/ _//d;\n    return $txt unless\
    \ $txt =~ /\\s/;\n    $txt =~ tr/a-zA-Z//d;\n    return $txt unless $txt =~ /[a-zA-Z]+$/;\n\
    \    return '';\n}", "    if($txt eq \"\"){\n      return \"\";\n    }\n    return\
    \ 1 if($txt =~ /\\w$/ and $txt !~ /[a-zA-Z]$/);\n    return \"\";\n}", "    return\
    \ $txt if ($txt =~ /[^\\s]$/);\n    return $txt if $txt =~ /^[a-z]/i;\n    return\
    \ $txt if $txt !~ /^[a-z]/i;\n}", "    return 1 unless $txt =~ /^[^A-Za-z ]$/;\n\
    \    return '';\n}", "    if (length($txt) > 0 ) {\n        my $last_char = substr($txt,\
    \ -1, 1);\n        if ($last_char !~ /\\w/) {\n            substr($txt, -1, 1)\
    \ = \"\";\n        }\n    }\n    return $txt;\n}", "    # Get the last character\
    \ of string.\n    my $last_char = substr($txt, length($txt) - 1);\n    # Check\
    \ if the character is a letter.\n    my $is_letter = is_alpha($last_char);\n \
    \   # Check if the character is a word character.\n    $is_letter += $last_char\
    \ !~ /\\w/;\n    return $is_letter;\n}\n</code>\nNow, to create a word boundary\
    \ checker in Perl, you can use the \\B escape sequence. The perlre man page explains\
    \ this:", "    return 1 if ($txt =~ /[\\ ]+$/);\n    return \"\" if ($txt !~ /[\\\
    \ ]+$/ && $txt =~ /^[^A-Za-z]+$/);\n    return \"\";\n}", "    my $lastchar =\
    \ substr($txt,-1,1);\n    my $word_chars = split(' ',$txt);\n    return if ($lastchar\
    \ =~ /^[a-z]$/i); # If the last char is a-z, then it's not a letter\n    my $word\
    \ = \"\";\n    foreach my $w (@$word_chars) {\n        my $n = length($w);\n \
    \       if ($n > 0) {\n            $word = $w.\" \";\n        }\n    }\n    $word\
    \ =~ s/^\\s*|\\s*$//g;\n    return if ($word !~ /\\w$/i);\n    return $word;\n\
    }", "    $txt =~ tr/A-Za-z//d;\n}", "    my($last_char) = substr($txt, -1);\n\
    \    my($letter) = substr($last_char, -1);\n    return if ($last_char eq $letter);\n\
    \    return if ($letter !~ /^[a-zA-Z]+$/);\n    return $txt;\n}", "    my $len\
    \ = length($txt);\n    my $letter = substr($txt, $len - 1, 1);\n    my $flag =\
    \ 0;", "    if ($txt =~ /^([A-Za-z]+$)/) {\n\treturn $1;\n    } else {\n\treturn\
    \ \"\";\n    }\n}", "    my $txtlen = $txt->length();\n    my $last = $txt->char(\
    \ $txtlen-1 );\n    return \"\" unless $last =~ /^[a-zA-Z]+$/;\n    return $last;\n\
    }", '    return "" unless $txt;', "    my($last_char) = $txt =~ s/^.//;\n    $txt\
    \ =~ s/$last_char/[a-zA-Z]/ and $txt !~ /[a-zA-Z]/;\n}", "    return \"\" unless\
    \ defined $txt;\n    return 1 if substr($txt, -1, 1, \" \") =~ /\\w/; # Check\
    \ last char\n    return \"\";\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\n\
    You forgot `use feature 'say'` ;-)\n<|/ c |>\n<| c |>\nThank you for pointing\
    \ that out. I updated the post. I had used `print()` from the `IO::All` module\
    \ but have replaced it with `say` in the code above. :)\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\n<code>\nmy $str = \"apple pie\";\nif ( index ( $str, \" \" ) != -1 ) {\n\
    \     print \"last space is \" . length( $str ) - length( $str =~ /\\ /);\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\nuse v5.10;", "    my(@words) = split\
    \ /\\s+/, $txt;\n    my($last_char) = pop(@words);\n    my $is_letter = ( $last_char\
    \ =~ /\\w/i );\n    return '' unless $is_letter;\n    return '';\n}", "    if\
    \ ( ! defined $txt ) {\n        return '';\n    }", "    return \"\" if $txt eq\
    \ \"\";\n    my($last_char) = substr($txt, -1);\n    my($first_char) = substr($txt,\
    \ 0, -1);\n    my($word_chars) = \" \";\n    my($non_word_chars) = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\
    ;\n    if (index($non_word_chars, $last_char) != -1) {\n        return \"\";\n\
    \    } elsif (index($word_chars, $first_char) == -1) {\n        return 1;\n  \
    \  } else {\n        return \"\";\n    }\n}", "    my($last_char) = substr($txt,\
    \ (length($txt)-1),1);\n    if ($txt =~ /\\W/ && !($last_char =~ /\\w/)) {\n \
    \       return '';\n    } else {\n        return 1;\n    }\n}", "    my($last)\
    \ = substr($txt, -1, 1);\n    my($last_is_a_letter) = !($last =~ /[a-z]/);\n \
    \   return !($last_is_a_letter);\n}", '    return "" if not $txt or $txt eq "";',
  "    if ( length($txt) == 0 ) { return(\"\" ); }\n    my @chars = split(\" \", $txt);\n\
    \    my $last_char = pop(@chars);\n    my $res = $last_char =~ /[A-z]/;\n    return\
    \ $res == 0;\n}", "    $txt =~ s/^\\s*//;\n    $txt =~ s/\\s*$//;\n    return\
    \ $txt if $txt =~ /^[a-z][^a-z]*[a-z]$/i;\n    return \"\";\n}", "    return if\
    \ ($txt eq '');\n    if ( $txt[-1] eq ' ' ) {\n\treturn 0;\n    }\n    for ($txt[-1])\
    \ {\n\treturn 0 if $_ eq $letters[-1];\n    }\n    return 1;\n}", "    my(@letters)\
    \ = ();\n    my(@words) = ();\n    my $last = \"\";\n    my $last_char = \"\"\
    ;\n    my $last_word = \"\";\n    # split words into letters\n    for my $word\
    \ (split /\\s+/, $txt) {\n        for my $letter (split /\\s+/, $word) {\n   \
    \         push @words, $letter;\n        }\n    }\n    # split letters into words\n\
    \    for my $word (@words) {\n        my ($letter) = (split /\\s+/, $word)[0];\n\
    \        push @letters, $letter;\n    }\n    # split words into letters\n    for\
    \ my $word (@words) {\n        for my $letter (split /\\s+/, $word) {\n      \
    \      push @letters, $letter;\n        }\n    }\n    # check if last letter is\
    \ in letter array\n    if ($letters[-1] eq $_[0]) {\n        return \"\";\n  \
    \  }\n    elsif (@letters == 0) {\n        return 1;\n    }\n    elsif ($letters[-1]\
    \ eq \"\") {\n        return 0;\n    }\n    my $last = substr($letters[-1], -1);\n\
    \    # check if last letter is not a letter in word array\n    for my $word (@words)\
    \ {\n        if ($word eq \"\") {\n            return 0;\n        }\n        elsif\
    \ ($word eq $last) {\n            return \"\";\n        }\n    }\n    my $last_char\
    \ = substr($letters[-1], -1);\n    my $last_word = substr($words[-1], -1);\n \
    \   # check if last letter of last word is empty\n    if ($last_word ne \"\")\
    \ {\n        if ($last_char == \"\") {\n            return \"\";\n        }\n\
    \        elsif ($last_char eq $last_word) {\n            return \"\";\n      \
    \  }\n    }\n    return \"\";\n}", "    my $ret = substr($txt, -1, 1) eq 'a'\n\
    \                or substr($txt, -1, 1) eq 'e'\n                or substr($txt,\
    \ -1, 1) eq 'i'\n                or substr($txt, -1, 1) eq 'o'\n             \
    \   or substr($txt, -1, 1) eq 'u'\n                or substr($txt, -1, 1) eq 'Y'\n\
    \                or substr($txt, -1, 1) eq 'y'\n                or substr($txt,\
    \ -1, 1) eq 'T'\n                or substr($txt, -1, 1) eq 't'\n             \
    \   or substr($txt, -1, 1) eq 'L'\n                or substr($txt, -1, 1) eq 'l'\n\
    \                or substr($txt, -1, 1) eq 'R'\n                or substr($txt,\
    \ -1, 1) eq 'r'\n                or substr($txt, -1, 1) eq 'P'\n             \
    \   or substr($txt, -1, 1) eq 'p';\n    return '' unless $ret;\n    return $ret;\n\
    }", "    my $ch = $txt->[$txt->length - 1];\n    return \"\" unless $ch =~ /\\\
    w$/;\n    return 1 if $ch !~ /\\w$/;\n    return 1;\n}", "    my $word = $txt;\n\
    \    my $last_letter = substr($word,-1,1);\n    $word =~ /[[:alpha:]]$/ or $word;\n\
    \    $word =~ /[[:space:]]$/ or $word;\n    $word =~ /[[:punct:]]$/ or $word;\n\
    \    $word =~ /[[:cntrl:]]$/ or $word;\n    $word =~ /[[:alnum:]]$/ or $word;\n\
    \    $word =~ /[[:xdigit:]]$/ or $word;\n    $word =~ /[[:print:]]$/ or $word;\n\
    \    $word =~ /[[:cntrl:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:cntrl:]]$/ or $word;\n\
    \    $word =~ /[[:cntrl:]]$/ or $word;\n    $word =~ /[[:alnum:]]$/ or $word;\n\
    \    $word =~ /[[:graph:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:]]$/ or $word;\n\
    \    $word =~ /[[:blank:]]$/ or $word;\n    $word =~ /[[:graph:", "    my $lastchar\
    \ = length($txt);\n    return '' if($lastchar <= 1);\n    my $is_first_letter\
    \ = substr($txt,0,1)=~/\\w/;\n    return '' if($is_first_letter);\n    my $is_last_letter\
    \ = substr($txt,-1,1)=~/\\w/;\n    return '' if($is_last_letter);\n    my $is_last_letter_of_word\
    \ = 0;\n    foreach my $word (@words) {\n        if (substr($word,0,$lastchar-1)=~/\\\
    w/) {\n            $is_last_letter_of_word = 1;\n            last;\n        }\n\
    \    }\n    return '' if($is_last_letter_of_word);\n    return 1;\n}", "    my\
    \ $result = substr($txt,-1) =~ /[a-z]/i;\n    $result ? $txt : $txt.\" \".$result;\n\
    }", "    my($last_char) = substr($txt, length($txt) - 1, 1);\n    my $isalpha\
    \ = 0;\n    if ($last_char !~ /\\w/) {\n        $isalpha = 1;\n    }\n    return\
    \ $isalpha;\n}\n1;\n</code>\n<|/ a |>\n<| c |>\n`s/(\\w)/$1 .= \" $1\"/eg` will\
    \ do the whole job.\n<|/ c |>\n<| c |>\n: That's great, I didn't know that one\
    \ could concatenate a string with a variable.\n<|/ c |>\n<| c |>\n: Thanks. That\
    \ works, but it just adds a space to the end of the string. Do you know why that\
    \ is?\n<|/ c |>\n<| c |>\nOh yes. You have to append a space at the end. `s/(\\\
    w)/$1 .= \" $1\"/eg`\n<|/ c |>\n<| c |>\n: Thanks. That worked. But it just adds\
    \ a space to the end of the string. Do you know why that is?\n<|/ c |>\n<| a tags=perl\
    \ |>\n<code>", "    if (length($txt) == 0) {\n        return \"\";\n    }\n  \
    \  elsif ($txt[$#txt] !~ /^[a-yA-Y]/) {\n        return \"\";\n    }\n    else\
    \ {\n        return 1;\n    }\n}", "    return undef if $txt eq '';\n    my(@word)\
    \ = split(/\\s/, $txt);\n    foreach my $word (@word) {\n        my($last_char)\
    \ = substr($word, 0, -1);\n        return undef if $last_char !~ /[A-Za-z]/;\n\
    \    }\n    return 1;\n}", "    if($txt =~ /^([a-z].*[,])$/i){\n\treturn 1;\n\
    \    }\n    return \"\";\n}", "    return $txt if length($txt) < 1;\n    return\
    \ $txt if substr($txt, -1, 1) =~ /[a-zA-Z]/;\n    return \"\";\n}", "    \n  \
    \  $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+$//;\n    $txt =~ s/\\s+/ /g;\n    my($last_char)\
    \ = substr($txt,-1);\n    if ( $last_char =~ /^[A-z]$/ && $last_char !~ /\\w/\
    \ ) {\n        return \"\";\n    }\n    return 1;\n}", "    return $txt unless\
    \ $txt =~ m/[^A-Z ]/;\n    return 1 if $txt =~ /(^|\\s)[^A-Z ]$/;\n    return;\n\
    }", "    my($last) = length($txt);\n    if ($last > 0) {\n        my $letter =\
    \ substr($txt, $last-1, 1);\n        $letter = $letter =~ /\\w/;\n        return\
    \ ($letter ? \"1\" : \"0\");\n    }\n    return \"\";\n}", "    my ($last_char,\
    \ $is_a_letter) = (\"\\0\", \"\\0\");\n    for my $char (split //, $txt) {\n \
    \       next if $char eq \" \"; # Skip spaces.\n        last if $char eq \"\\\
    0\"; # End of string.\n        # Find the last non-space character.\n        $last_char\
    \ = $char;\n        $last_char =~ s/^\\s+|\\s+$//g; # Remove leading and trailing\
    \ spaces.\n        if ($char =~ /^[A-Za-z]$/) {\n            $is_a_letter = 1;\n\
    \            last;\n        }\n    }\n    return $is_a_letter;\n}", '    return
    "" if $txt eq "";', "    my $last = substr($txt, -1, 1);\n    # last character\
    \ is not alphabet and does not a part of a word\n    # or is last character is\
    \ space and does not a part of a word\n    # or is last character is space and\
    \ is a part of a word\n    return (!$last =~ /[A-z]/ || $last =~ /[^A-z]/\n  \
    \          || $last =~ /[[:space:]]/) ? \"\" : 1;\n}", "    return \"\" unless\
    \ $txt;\n    return 1 unless $txt =~ /^[a-z]+$/i;\n    return \"\";\n}", "   \
    \ $txt =~ s/^\\s*//;    # remove leading whitespace\n    $txt =~ s/\\s+\\z//;\
    \ # remove trailing whitespace\n    \n    # Check for an alphabetic character\
    \ that is not part of a word:\n    my $lastchar = $txt =~ tr/A-Za-z//;\n    return\
    \ $lastchar if $lastchar eq '';\n    return 1;\n}", "    my $word = $txt =~ /([A-Z]+)\
    \ /;\n    return $word;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if you have more than one space after the last letter; this only checks\
    \ *before* the last character.\n<|/ c |>\n<| a tags=string,perl,regex |>\nA very\
    \ straightforward approach is to just find the index of the last letter in the\
    \ string and remove it.\n<code>", "    my($last_char) = substr($txt, length($txt)-1,\
    \ 1);\n    my($is_letter) = ($last_char =~ /[A-Za-z]/);\n    return $is_letter\
    \ ? $txt : '';\n}", "    my $result = \"\";\n    my @words = split(\" \", $txt);\n\
    \    foreach my $word (@words) {\n        my $last_char = $word->[-1];\n     \
    \   if ($last_char =~ /[a-z]/) {\n            $result = $last_char;\n        \
    \    last;\n        }\n    }\n    return $result;\n}", "    my($last) = length($txt);\n\
    \    my($word) = ();\n    my($check);", "    return $txt if length($txt) < 1;\n\
    \    return $txt if $txt =~ m/[^A-Za-z]$/;\n    return $txt if $txt =~ m/\\b[A-Za-z]$/;\n\
    \    return;\n}", "    return if ($txt eq '');\n    $txt =~ /([a-zA-Z])\\Z/;\n\
    \    return '' unless $1;\n    return '';\n}", "    my($last_char) = substr($txt,\
    \ -1, 1);\n    my($is_letter) = 0;\n    my(@words) = split(/\\s+/, $txt);\n  \
    \  for (my $i = 0; $i < scalar(@words); $i++) {\n        my($word) = $words[$i];\n\
    \        my(@chars) = split(//, $word);\n        for (my $j = 0; $j < scalar(@chars);\
    \ $j++) {\n            if ($chars[$j] != $last_char) {\n                $is_letter\
    \ = 1;\n            }\n            else {\n                $is_letter = 0;\n \
    \               last;\n            }\n        }\n    }\n    return $is_letter;\n\
    }", "    my ($last) = substr($txt, length($txt)-1, 1);\n    return $last =~ /^[a-z]/i\
    \ || $last =~ /^[A-Z]/i;\n}", "    if ($txt =~ /[[:alpha:]]$/ && $txt !~ /[[:alpha:][:space:][:punct:]]/)\
    \ {\n        return \"\";\n    } else {\n        return 1;\n    }\n}", "    my($last_char,\
    \ $word) = $txt =~ m/^(.)(.+)/;\n    my($word) = lc($word);\n    return $last_char\
    \ eq '-' &&\n        !index($word, ' ') &&\n        !index($word, ' '.$last_char);\n\
    }", "    $txt =~ s/^\\s*|\\s*$//g;\n    ($txt =~ /\\w$/) ? \"\" : \"1\";\n}",
  "    my $last_char = substr($txt, length($txt) - 1, 1);\n    return '' if $last_char\
    \ !~ /^[A-Za-z]$/ && !$txt =~ /^[A-Za-z ]+$/;\n    return $last_char;\n}", " \
    \   $txt =~ s/^(.*)\\s(.*)$/\\1$2/;\n    return $txt if $txt =~ /^[A-Za-z0-9]/;\n\
    \    return \"\";\n}", "    $txt =~ s/(\\w+$)/$1/ if $txt !~ /\\w/;\n    return\
    \ $txt unless $txt =~ /\\w$/;\n    return \"\";\n}", '    return $txt if $txt
    =~ /^$/;', "    $txt = lc $txt;\n    return 1 if substr($txt,-1,1) =~ /^[a-z]/i;\n\
    \    return \"\";\n}", "    $txt =~ s/\\s+$//;\n    return $txt unless length($txt);\n\
    \    return $txt if $txt =~ /^[A-z]+$/;\n    return '';\n}", "    my(@words) =\
    \ split /\\s+/, $txt;\n    my(@chars);\n    $txt=~s/\\s+$//;\n    for my $word\
    \ (@words) {\n        my($word_chars) = split /\\s+/, $word;\n        for my $char\
    \ (@$word_chars) {\n            push(@chars, $char) if $char !~ /[a-zA-Z]/;\n\
    \        }\n    }\n    $txt =~ s/\\s+//;\n    my $last_char = substr($txt, -1);\n\
    \    if ($last_char =~ /[a-zA-Z]/) {\n        return \"\";\n    } else {\n   \
    \     return 1;\n    }\n}", "    return ($txt =~ m/([^\\s]$)/) ? $txt : \"\";\n\
    }", "    return 1 if length($txt) > 0;\n    return 0 unless $txt =~ /^[a-z ]+$/i;\n\
    \    return 1;\n}", "    return '' unless $txt;\n    my(@letters) = split //,\
    \ $txt;\n    my $last_char = $letters[-1];\n    $last_char =~ /^[A-Z]+$/i;\n \
    \   return '' if $last_char eq '-';\n    return 1 if $last_char !~ /^[A-Za-z]+$/i;\n\
    \    return '';\n}", "    my($result) = $txt;\n    my $i = 0;\n    \n    # Search\
    \ for the last non-whitespace character in the string.\n    while($i < length($result))\
    \ {\n        $result = substr($result, $i);\n        if (substr($result, length($result)\
    \ - 1, 1) !~ /\\s/) {\n            break;\n        }\n        $i++;\n    }\n \
    \   \n    # A non-whitespace character has been found. Check if it\n    # is an\
    \ alphabetical character.\n    if ($result !~ /\\s/) {\n        $result = substr($result,\
    \ 0, 1);\n    } else {\n        $result = substr($result, 0, length($result) -\
    \ 1);\n    }\n    \n    return $result;\n}", "    my($letter) = substr($txt, -1,\
    \ 1);\n    my $word = $txt;\n    if ($letter eq 'a') {\n        $word =~ /[aeiouy]/\
    \ or $word =~ /[aeiouyAEIOUY]/ or $word =~ /[AEIOUYaeiouy]/ or $word =~ /[AEIOUYaeiouyAEIOUY]/\
    \ or $word =~ /[aeiouyAEIOUY]/ or $word =~ /[AEIOUYaeiouyAEIOUY]/;\n    }\n  \
    \  if ($letter eq 'e') {\n        $word =~ /[aeiouy]/ or $word =~ /[aeiouyAEIOUY]/\
    \ or $word =~ /[AEIOUYaeiouy]/ or $word =~ /[AEIOUYaeiouyAEIOUY]/ or $word =~\
    \ /[aeiouyAEIOUY]/ or $word =~ /[AEIOUYaeiouyAEIOUY]/;\n    }\n    if ($letter\
    \ eq 'i') {\n        $word =~ /[aeiouy]/ or $word =~ /[aeiouyAEIOUY]/ or $word\
    \ =~ /[AEIOUYaeiouy]/ or $word =~ /[AEIOUYaeiouyAEIOUY]/ or $word =~ /[aeiouyAEIOUY]/\
    \ or $word =~ /[AEIOUYaeiouyAEIOUY]/;\n    }\n    if ($letter eq 'o') {\n    \
    \    $word =~ /[aeiouy]/ or $word =~ /[aeiouyAEIOUY]/ or $word =~ /[AEIOUYaeiouy]/\
    \ or $word =~ /[AEIOUYaeiouyAEIOUY]/ or $word =~ /[aeiouyAEIOUY]/ or $word =~\
    \ /[AEIOUYaeiouyAEIOUY]/;\n    }\n    if ($letter eq 'u') {\n        $word =~\
    \ /[aeiouy]/ or $word =~ /[aeiouyAEIOUY]/ or $word =~ /[AEIOUYaeiouy]/ or $word\
    \ =~ /[AEIOUYaeiouyAEIOUY]/ or $word =~ /[aeiouyAEIOUY]/ or $word =~ /[AEIO",
  "    $txt =~ s/ /_/g;\n    $txt =~ s/^[a-z][\\s]$//ig;\n    return $txt;\n}", " \
    \   my($last_char) = $txt =~ substr($txt,-1);\n    my($letter) = $last_char =~\
    \ tr/A-Za-z//;\n    return $letter != 1;\n}", "    return $txt if $txt !~ /\\\
    w$/i;\n    return $txt =~ /\\w$/i ? \"\" : \"1\";\n}", "    my $len = length($txt);\n\
    \    my $last = substr($txt, -1, 1);\n    return 1 if $last =~ /^[a-z]$/ and $last\
    \ !~ /[a-z]+/i;\n    return \"\";\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "    my($letter) = $txt =~ /([a-z])/i;\n    return $letter != \"\" ? $letter : $txt\
    \ !~ /[a-z]$/i;\n}", "    my($last_char);\n    my(@words);\n    my($letter);\n\
    \    my($i);", "    return ($txt =~ m/([^a-zA-Z]$)/) ? \"\" :\n           $txt\
    \ =~ m/([^a-zA-Z]$)/g ? \"1\" : \"\";\n}", "    my(@lst) = split / /, $txt;\n\
    \    my $is_letter_last_char = 1;", "    my $lastchar = substr($txt, length($txt)-1,\
    \ 1);\n    return $lastchar =~ /[a-zA-Z]/;\n}", "    $txt =~ s/^\\s*//;\n    $txt\
    \ =~ s/\\s*$//;\n    my ($last) = substr($txt, length($txt) - 1, 1);\n    return\
    \ ($last !~ /\\w/) ? 1 : \"\";\n}", "    my($last_char) = substr($txt, -1, 1);\n\
    \    my($letter) = $txt;\n    chomp($letter);\n    if ( !($last_char =~ m/^[a-z]+$/i)\
    \ ) {\n        return $letter;\n    }\n    \n    return \"\";\n}", "    if($txt\
    \ !~  /([a-zA-Z]) *$/){\n        return '';\n    }\n    $txt = reverse $txt;\n\
    \    return $txt =~ /([a-zA-Z]) *$/;\n}", "    return \"\" if length($txt) ==\
    \ 0;\n    my($last_char) = substr($txt,-1);\n    return \"\" if ! ( $last_char\
    \ =~ m/[a-zA-Z]/ );\n    return 1;\n}", "    return $txt if length($txt) == 0;\n\
    \    my($last_char) = $txt->[$txt->length - 1];\n    return $last_char unless\
    \ $last_char =~ /^[a-z]/;\n    return '';\n}", "    return $txt if $txt !~ /^[A-Za-z]*$/;\n\
    \    return \"\";\n}", "    $txt = lc ($txt);\n    return 1 if ( $txt !~ /\\w$/i\
    \ );\n    return \"\";\n}", "    if(!$txt || $txt =~ /^\\s+$/) {\n        return\
    \ '';\n    }\n    if($txt =~ /^[a-zA-Z]$/) {\n        return '';\n    }\n    return\
    \ 1;\n}", "    return 1 if($txt !~ /\\A [^\\s]+ \\z/ or\n                 $txt\
    \ !~ /\\A [^\\s]+$/ or\n                 $txt !~ /\\A [^\\s]+\\z/);\n    return\
    \ \"\";\n}", "    return 0 unless defined $txt;\n    return $txt if $txt =~ /^[a-z]$/i;\n\
    \    return $txt if $txt =~ /^[a-z][^a-z]*[a-z]$/i;\n    return $txt if $txt =~\
    \ /^[a-z][a-z]*$/i;\n    return $txt;\n}", "    if ($txt =~ /\\p{L}$/) {\n   \
    \     $txt =~ s/$txt/./;\n    }\n    return $txt;\n}", "    my($last) = substr($txt,length($txt)-1,1);\n\
    \    return \"\" if $last !~ /^[A-Za-z]$/ && $last !~ /^[A-Za-z]+$/ && $last !~\
    \ /^[A-Za-z]+\\s/; \n    return 1;\n}", "    return \"\" if length($txt) == 0;\n\
    \    return 1 if $txt =~ /^([a-z]+[\\s])$/i;\n    return \"\";\n}", "    my($last)\
    \ = substr($txt, length($txt) - 1, 1);\n    return \"\" if $last =~ /[a-z]/i;\n\
    \    return 1;\n}", "    return \"\" if not $txt;\n    substr($txt, -1, 1) =~\
    \ m/^[a-zA-Z]+$/i;\n    return \"\" if $txt !~ m/^[a-zA-Z]+$/i;\n    return 1;\n\
    }", '    return "" unless $txt;', "    my ($last_char, $word);\n    my ($i, $length);",
  "    return \"\"\n        if $txt eq \"\";\n    $txt =~ s/^\\s+|\\s+$//g;\n    return\
    \ 1 if $txt =~ m{^[a-zA-Z]+$};\n    return \"\";\n}", "    my($last_char) = $txt\
    \ =~ substr($txt, -1); \n    if ( $last_char =~ /\\w/ ) {\n        if ($txt =~\
    \ /^[A-Za-z]$/ ) {\n            $txt = '';\n        }\n    }\n    return $txt;\n\
    }", "    $txt =~ s/^\\s*//;\n    $txt =~ s/\\s*$//;", "    my(@words) = split\
    \ ' ', $txt;\n    my($last) = pop(@words);\n    return undef if !defined($last);\n\
    \    return 1 if $last =~ /[A-Za-z]/;\n    return '';\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nOh, sorry, I missed that your answer has already been accepted\
    \ :) The point is: your answer just shows a code example, not the actual solution.\
    \ It might be useful to some people, but not this person who has already accepted\
    \ another answer.\n<|/ c |>\n<| c |>\nOh, indeed. I didn't even notice it. Sorry,\
    \ you're right\n<|/ c |>\n<| c |>\n\"not this person who has already accepted\
    \ another answer\" :) I guess this person only had the opportunity to post a comment.\
    \ Anyway, I hope my answer was helpful, anyway. :)\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\nAs already said in other answers, the right answer is to not use regexp.\
    \ \nYour question is not very clear and your code is also not very clear. \nDo\
    \ you want to detect strings like \"apple pie apple\" that have spaces after the\
    \ last word? Or do you want to detect the presence of spaces after any word? \n\
    You seem to want to detect \"apple pie apple\". The code below will detect spaces\
    \ after any word.\n<code>\nuse strict;\nuse warnings;", "    my($last_char, $word);\n\
    \    my($result) = \"\";", "    my(@characters) = split (\" \", $txt);\n    my($last)\
    \ = pop (@characters);\n    \n    if($last =~ m/^[[:alpha:]]$/) {\n        return\
    \ $last;\n    }\n    \n    return \"\";\n}", "    my($last_char) = substr($txt,\
    \ -1);\n    my($word) = $txt =~ /\\S+/g;\n    return $word if $word =~  /[A-Z]+$/i;\n\
    \    return $last_char;\n}", "    $txt =~ s/^\\s+//;\n    return $txt unless $txt\
    \ =~ /^[a-z]+$/i;\n    return 1;\n}", "    if($txt =~ /^\\W$/){\n\treturn \"\"\
    ;\n    }else{\n\treturn 1;\n    }\n}", "    my ($last) = substr($txt,-1);\n  \
    \  return ($last eq \" \") ? (\"1\") : (\"0\");\n}", "    $txt =~ s/^\\s*$//;\n\
    \    $txt =~ s/^\\s*$//;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+$//;\n   \
    \ $txt =~ s/\\s+/ /g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/^\\s+//;\n    $txt\
    \ =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\\
    s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n\
    \    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt\
    \ =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\\
    s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n\
    \    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt\
    \ =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\\
    s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n\
    \    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt\
    \ =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\\
    s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n\
    \    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt\
    \ =~ s/^\\s+//;\n    $txt =~ s/\\s+//g;\n    $txt =~ s/^\\s+//;\n    $txt =~ s/\\\
    s+//g;\n", '    $txt = "" if !defined($txt);', "    if ($txt =~ /[a-z]$/ && !$txt\
    \ =~ /[a-z][ ]+$/) {\n        return $txt;\n    }\n}", "    return 0 if ( $txt\
    \ =~ /[^a-zA-Z]/ );\n    return 1 if ( $txt =~ /\\A[^\\s]/ );\n    return \"\"\
    ;\n}", "    \n    # Split string into words\n    my(@words) = split /\\s+/, $txt;\n\
    \    \n    my($letters_found);\n    \n    # Iterate over each word\n    foreach\
    \ $word (@words) {\n        # Check if the last letter of current word is alphabetic\n\
    \        # and is not the start of a word\n        if($word =~ /^[a-zA-Z]+$/)\
    \ {\n            # If the letter is not the first letter in word\n           \
    \ if(!$letters_found) {\n                $letters_found = 1;\n               \
    \ # Return last character\n                return $word[$#word];\n           \
    \ }\n        }\n    }\n    \n    # No letters found\n    $letters_found = 0;\n\
    \    \n    return $letters_found;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nGood\
    \ job! I liked your approach.\n<|/ c |>\n<| a dscore=1 tags=perl,regex |>\n<code>",
  "    my $last_char = substr($txt, length($txt) - 1, 1);\n    return 1 unless ($last_char\
    \ =~ /[A-Za-z]/);\n    return $last_char;\n}", "    my $result = \"\";\n    my($letter)\
    \ = substr($txt, length($txt), 1);\n    for my $word ( split (\" \", $txt) ) {\n\
    \        my $letter_in_word;\n        foreach my $character (split \" \", $word)\
    \ {\n            if ( $character eq $letter ) {\n                push @{$result},\
    \ $character;\n                $letter_in_word = 1;\n            }\n         \
    \   else {\n                if ( $letter_in_word ) {\n                    last;\n\
    \                }\n            }\n        }\n    }\n    return $result if scalar\
    \ (@{$result});\n    return \"\";\n}", '    return "" if !defined $txt || $txt
    eq "";', "    my $last = substr($txt,-1,1);\n    return 1 if $last !~ /\\w$/i;\n\
    \    return \"\";\n}\n</code>\n<|/ a |>\n<| a |>\nFor a simple task as this, regular\
    \ expressions are unnecessarily complicated and unwieldy.\nJust use index(), substr(),\
    \ and length().\n<code>\nmy $str = 'this is some random text that does not contain\
    \ any words or numbers';", "    my @words = split(/ /, $txt);\n    for my $word\
    \ (@words) {\n        $word = \"\" if $word eq \"\";\n        if (substr($word,\
    \ $#word, 1) = ~ /[a-z]/) {\n            $word = substr($word, 0, $#word);\n \
    \       }\n        return $word;\n    }\n    return \"\";\n}", "    chomp($txt);\n\
    \    return undef if length($txt) < 1;\n    return substr($txt,-1) =~ /[a-zA-Z]/;\n\
    }", "    if($txt =~ m/^.*(\\w) *$/ && $1 ne \"\\n\"){\n        $txt =~ s/.*\\\
    s(\\w) *$//;\n        return $1;\n    }\n    return \"\";\n}", "    return 1 unless\
    \ defined $txt;\n    my $last_char = substr($txt, -1, 1);\n    return $last_char\
    \ =~ /\\w/ and $last_char;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nThe question\
    \ is tagged `perl` so I think `\\w` is fine.\n<|/ c |>\n<| c |>\n: Perl's `\\\
    w` matches the character `\\w` which stands for word character and that includes\
    \ numbers, letters, and underscore. This regex also matches `-`, `+`, spaces,\
    \ `=`, `, `, \\`, and `.` which are all non-word characters. So `\\w` is probably\
    \ not fine.\n<|/ c |>\n<| c |>\nBut what about `[` `]` `^` `$` `~` `!` `@` `_`\
    \ `-` `%` `~` `&` `*` `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-`\
    \ `%` `~` `&` `*` `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-` `%`\
    \ `~` `&` `*` `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-` `%` `~`\
    \ `&` `*` `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-` `%` `~` `&`\
    \ `*` `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-` `%` `~` `&` `*`\
    \ `+` `?` `|` `^` `-` `[` `]` `^` `$` `~` `!` `@` `_` `-` `%` `~` `&` `*` `+`\
    \ `?` `|` `^` ", "    my $last_char = $txt->[-1];\n    return \"\" unless $last_char\
    \ =~ m/[A-Z]$/;\n    return 1;\n}", "    return \"\" if $txt eq \"\";\n    $txt\
    \ =~ s/^\\s*//;\n    $txt =~ s/\\s*$//;\n    return $txt if $txt !~ /^[a-zA-Z]+$/;\n\
    \    return 1;\n}", "    my($last) = uc(substr($txt, length($txt) - 1, 1));\n\
    \    $last =~ /^[a-zA-Z]/;\n    return \"\" if $last;\n    return 1;\n}", "  \
    \  return 0 if ($txt =~ /^.$/ || $txt =~ /\\w$/);\n    return 1;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThank you for your answer. \nI tested your code, but\
    \ unfortunately it didn't work as I expected.\nThe word \"apple\" is recognized\
    \ as 'non-word', but \"applepie\" is not recognized as 'non-word', and so on.\
    \ \nSo I tried to modify your code to add '\\w' after the '\\w+' like this: \n\
    \"apple pie\"=~ /\\w+\\s/  . \nThe result was this: \"applepie\"=~/^$/ => 0\n\"\
    apple pie\"=~/^\\w/ => 1\n<|/ c |>\n<| c |>\n`/\\w+\\s/` doesn't match a single\
    \ whitespace character, but any whitespace, that's why it works with `applepie`\
    \ but not `apple`.\n<|/ c |>\n<| c |>\nI tested it with \" apple pie\", then it\
    \ recognizes \"applepie\" as 'non-word', but with \" applepie\", then it recognizes\
    \ \"applepie\" as 'word', which is not what i want. I want \" applepie\" to recognize\
    \ as 'word' because it does not end in a whitespace.\n<|/ c |>\n<| c |>\nIt seems\
    \ that your function can only recognize words ended in a whitespace, but doesn't\
    \ work for other cases. \nThe input would be \" apple pie applepie\", then i want\
    \ \" applepie\" to recognize as 'non-word', and \" apple pie apple pie\" to recognize\
    \ as 'word', which is not what i want.\n<|/ c |>\n<| c |>\n\"applepie\" will match\
    \ \"apple pie\" but \"apple pie applepie\" will not match \"apple pie\". Please\
    \ clarify what you expect in that case (by editing your question).\n<|/ c |>\n\
    <| a dscore=0 tags=perl,regex |>\n<code>", "    # $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+)$/;\n\
    \    return $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+)$/\n        if $txt =~ /^([^ ]+[ ]+[^\
    \ ]+)$/;\n    # $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+)$/;\n    return $txt =~\
    \ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+)$/\n        if $txt =~ /^([^ ]+[ ]+[^ ]+[\
    \ ]+[ ]+[^ ]+)$/;\n    # $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+)$/;\n\
    \    return $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+)$/\n        if\
    \ $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[^ ]+)$/;\n    return $txt\
    \ =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+)$/\n        if $txt =~\
    \ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+)$/;\n    return $txt =~\
    \ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+)$/\n        if $txt\
    \ =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[^ ]+)$/;\n\
    \    return $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[\
    \ ]+[^ ]+[ ]+)$/\n        if $txt =~ /^([^ ]+[ ]+[^ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[\
    \ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+)$/;\n    return $txt =~ /^([^ ]+[ ]+[^\
    \ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+[ ]+[^ ]+[ ]+[ ]+[ ]+", "  \
    \  return \"\" unless defined($txt);\n    my($last) = substr($txt, length($txt)\
    \ - 1);\n    my($word_char);", "    my $word = $txt;\n    $word =~ s/\\s*$//;",
  "    my $last_char = substr($txt, -1);\n    if($last_char =~ /^[a-zA-Z]$/) {\n \
    \       return \"\";\n    }\n    elsif($last_char =~ /^[a-zA-Z]+$/) {\n      \
    \  return 1;\n    }\n    else {\n        return 0;\n    }\n}", "    my($last_char)\
    \ = uc(substr($txt, length($txt)-2, 1));\n    my($non_letter_chars = join(\"\"\
    , \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\"));\n    my($last_non_letter_char\
    \ = substr($non_letter_chars, length($non_letter_chars)-1, 1));\n    return \"\
    \" if $last_char eq $last_non_letter_char;\n    return \"\" if $last_char eq \"\
    \";\n    return $last_char;\n}", '    return unless $txt;', "    $txt = \" $txt\"\
    \ if $txt =~ /\\s+$/;\n    substr($txt, length($txt) - 1) =~ /[A-Za-z]/;\n}",
  '    my($last_char);', "    my($last_char) = substr($txt,length($txt)-1,1);\n  \
    \  my($is_last_letter) = !($last_char =~ /\\w/);\n    return $is_last_letter ?\
    \ \"\" : \"1\";\n}", "    $txt =~ s/\\s+//g;\n    # $txt =~ s/^$//;\n    return\
    \ $txt if $txt =~ /[a-zA-Z][a-zA-Z ]*$/g;\n    return '';\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks Raven. Yeah I did consider using split or regex, but I was hoping\
    \ to avoid that.\n<|/ c |>\n<| c |>\n, I don't understand your comment \"I was\
    \ hoping to avoid that.\"\n<|/ c |>\n<| c |>\nSure I agree that regex can be complicated,\
    \ especially when you're trying to understand it after you used it once, but I\
    \ wanted to see if I could avoid using it. Thanks again.\n<|/ c |>\n<| a tags=regex,perl\
    \ |>\nThe answer from RavenB is probably the most efficient, but here's another\
    \ way:\n<code>", "    return \"\" if $txt eq \"\";\n    return substr($txt, -1,\
    \ 1) if $txt =~ /\\w$/;\n    return $txt;\n}", "    return \"\" if ( ! $txt);\n\
    \    my ($last_char_of_txt, $last_char_is_a_letter);\n    # If the last character\
    \ is a letter, and it's not the last char,\n    # then the last char is NOT a\
    \ letter.\n    # Note: I used $txt because $txt is the last element of the array.\n\
    \    $last_char_of_txt = $txt[-1]; # -1 to get to the last char.\n    $last_char_is_a_letter\
    \ = ( $last_char_of_txt =~ /[A-z]/ ); # A letter...\n    return \"\" if ! $last_char_is_a_letter;\n\
    \    return 1;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI don't understand how\
    \ this can be better than my own answer.\n<|/ c |>\n<| c |>\nOh, you're right,\
    \ yours is more concise, but I had to read it a few times to realize that's what\
    \ it does.  I didn't notice that he was calling `check_if_last_char_is_a_letter`\
    \ twice (which he should have posted himself, I just assumed that he could figure\
    \ it out from reading it).  He should get credit for figuring it out himself.\n\
    <|/ c |>\n<| c |>\nI realized that you had to call `check_if_last_char_is_a_letter`\
    \ twice by reading my own answer.  I figured you had to write it.  I guess I should\
    \ have figured that out before I posted.  Sorry!\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nuse strict;", "    my($last_char) = substr($txt, length($txt), 1);\n \
    \   if ($last_char =~ /[a-z]/) {\n\treturn \"\";\n    } else {\n\treturn $last_char;\n\
    \    }\n}", "    $txt = uc($txt);\n    my ($len) = $txt =~ tr/a-zA-Z//;\n    $len\
    \ and $txt =~ tr/a-z//;\n}", "    my($last_char) = substr($txt,length($txt)-1,1);\n\
    \    my($words) = split(\" \",$txt);\n    my($is_last_letter) = \n      grep (\n\
    \        substr($words[-1],length($words[-1])-1,1) eq $last_char,\n        $words\n\
    \      ) \n      ? \"\" \n      : 1;\n    return $is_last_letter;\n}\n</code>\n\
    <|/ a dscore=2 tags=perl,regex |>\n<| c |>\nNice job! The only problem I see is\
    \ if the last character is not a letter. `checkIfLastCharIsALetter(\"applepie\"\
    )` returns `1` while it should be `\"\"`.\n<|/ c |>\n<| c |>\n, thanks for your\
    \ comment. I've updated the code snippet to handle such cases.\n<|/ c |>\n<| a\
    \ dscore=2 tags=perl,regex |>\n<code>\nmy $txt = \"apple pi e\";", "    my($word)\
    \ = split(' ', $txt);\n    my($lastChar) = substr($word, -1, 1);\n    return (index($word,\
    \ ' ') > -1) ? $lastChar : '';\n}", "    my($last_char) = substr($txt,-1);\n \
    \   if($last_char eq '\\0' || $last_char !~ /\\w/) {\n        $txt = \"$txt$last_char\"\
    ;\n    }\n    return $txt;\n}", "    return '' if ($txt =~ /^$/);\n    my(@letters)\
    \ = (\"a..z\",\"A..Z\");\n    return '' if ($txt !~ /^\\w+$/);\n    return ''\
    \ if ($txt !~ /^\\p{L}\\w+$/);\n    return '' if ($txt !~ /^\\p{L}\\S+$/);\n \
    \   return '' if ($txt !~ /^\\p{L}\\S+\\w+$/);\n    return $txt[-1] if $txt[-1]\
    \ !~ /^[a-z_]$/;\n    return $txt[-1] unless grep(/^[a-z]/, @letters);\n    return\
    \ $txt[-1] unless grep(/^[A-Z]/, @letters);\n    return '';\n}", "    my($i) =\
    \ $txt->[-1];\n    $_[0] =~ /[^a-zA-Z]$/;\n    return $_[0];\n}", "    my($last_letter)\
    \ = substr($txt, length($txt) - 1, 1);\n    my(@word_group) = split \" \", $txt;\n\
    \    my($is_a_letter) = 0;\n    for my $word (@word_group) {\n        $is_a_letter\
    \ = 1 if $last_letter eq $word[-1];\n    }\n    $is_a_letter ? $txt : \"\";\n}",
  "    return $txt =~ /\\p{L}/ and $txt !~ /^\\p{L}+$/;\n}", "    return '' unless\
    \ $txt =~ /\\w$/;\n    return 1 unless $txt =~ /(\\w\\w\\w\\w)$/;\n    return\
    \ '';\n}", "    return $txt if $txt =~ /\\w$/;\n    return $txt if $txt =~ /\\\
    w\\s/;\n    $txt =~ s/\\w$/s/;\n    return $txt;\n}", "    if(!$txt || $txt eq\
    \ \"\"){\n        return \"\";\n    }\n    my $last = $txt->[-1];\n    my $chars\
    \ = split(/ /, $txt);\n    my $lastchar = substr($chars, -1);\n    if($lastchar\
    \ =~ /\\w/){\n        $lastchar = substr($chars, -2, 1);\n    }\n    if($lastchar\
    \ !~ /\\w/){\n        return $lastchar;\n    }else{\n        return \"\";\n  \
    \  }\n}", "    if ($txt =~ m{^([^[:alpha:]]*[[:alpha:]][^[:alpha:]]*)$}i) {\n\
    \        return 1;\n    }\n    elsif ($txt =~ m{^([^[:alpha:]]*[[:alpha:]])$}i)\
    \ {\n        return 1;\n    }\n    else {\n        return \"\";\n    }\n}", " \
    \   return \"\" if !defined($txt);\n    return $txt[-1] =~ /[A-Za-z]/ and $txt\
    \ !~ /([A-Za-z]+\\s)/;\n}", "    $txt = lc($txt);\n    my $i = rindex($txt, \"\
    \ \");\n    if ($i >= 0) {\n        if ($txt[$i] !~ /[a-zA-Z]/ ) {\n         \
    \   $txt = substr($txt, 0, $i);\n            $txt .= \"a\" if($txt =~ /a$/);\n\
    \        }\n    }\n    return $txt;\n}", "    my $char;\n    my $result = 1;\n\
    \    while($txt =~ /(.)(.*)(\\w\\w)/g) {\n        $char = $1;\n        $txt =\
    \ $2;\n        if ($char ne \"\\n\") {\n            $result = 0;\n           \
    \ last;\n        }\n    }\n    return $result;\n}", "    return \"\" unless $txt;\n\
    \    my($last_char) = substr($txt,-1);\n    return $last_char if ($last_char =~\
    \ /^[a-z]/i); # if last char is a-z\n    return $last_char if ($last_char =~ /^[^a-z]/i);\
    \ # if last char is any char\n    return $last_char if ($last_char =~ /^[0-9]/);\
    \ # if last char is 0-9\n    return $last_char if ($last_char =~ /^\\W$/); # if\
    \ last char is non-letter\n    return $last_char if ($last_char =~ /^\\W\\W/);\
    \ # if last char is non-letter\n    return $last_char if ($last_char =~ /^\\W\\\
    W$/); # if last char is non-letter\n    return $last_char if ($last_char =~ /^\\\
    W\\W\\W/); # if last char is non-letter\n    return $last_char if ($last_char\
    \ =~ /^\\W\\W\\W\\W/); # if last char is non-letter\n    return $last_char if\
    \ ($last_char =~ /^\\W\\W\\W\\W\\W/); # if last char is non-letter\n    return\
    \ $last_char if ($last_char =~ /^\\W\\W\\W\\W\\W\\W/); # if last char is non-letter\n\
    \    return $last_char if ($last_char =~ /^\\W\\W\\W\\W\\W\\W\\W/); # if last\
    \ char is non-letter\n    return $last_char if ($last_char =~ /^\\W\\W\\W\\W\\\
    W\\W\\W\\W/); # if last char is non-letter\n    return $last_char if ($last_char\
    \ =~ /^\\W\\W\\W\\W\\W\\W\\W\\W\\W/); # if last char is non-letter\n    return\
    \ $last_char if ($last_char =~ /^\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W/); # if last char\
    \ is non-letter\n    return $last_char if ($last_char =~ /^\\W\\W\\W\\W\\W\\W\\\
    W\\W\\W\\W\\W/); # if last char is non-letter\n    return $last_char if ($last_char\
    \ =~ /^\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W\\W/); # if last char is non-letter\n\
    \    return $", "    $txt =~ /(\\w)/;\n    my $res = $1;\n    $res !~ /\\w/;\n\
    \    return $res;\n}", "    return \"\" if ($txt eq '');\n    my($char) = $txt->[-1];\n\
    \    return 1 unless ($char =~ m/[a-zA-Z]$/);\n    return $char;\n}", "    my($last_char)\
    \ = substr($txt,length($txt)-1,1);\n    my($alpha) = lc $last_char;\n    return\
    \ $txt =~ /^($alpha)\\W/ ? $txt : '';\n}", "    # Check for last character is\
    \ alphabetical letter and is not part of a word\n    return \"\" if (length($txt)\
    \ > 0 && $txt[$#txt] !~ /\\w$/);\n    # Check for last character is alphabetical\
    \ letter and is part of a word\n    return 1 if (length($txt) > 0 && $txt[$#txt]\
    \ !~ /\\w$/);\n    return \"\";\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI have\
    \ an idea on how to do it, but I'm guessing that this would involve too many loops\
    \ and nested if statements.\nFirst, I think it's important to understand the difference\
    \ between a single character and multiple characters.\n<code>\nif ($str =~ /^[a-z\
    \ A-Z]+$/i) { print \"The string contains only letters A-Z and spaces!\\n\" }\n\
    </code>\nThis regex checks to see if the string contains only letters A-Z and\
    \ spaces. It matches the entire string (i.e. ^ and $), so you can get false positives\
    \ for strings with only spaces such as \"Hello world!\".\nIf you want to check\
    \ for multiple characters, you can just add them into the regex like so:\n<code>\n\
    if ($str =~ /^[a-hj-km-n-z]+$/i) { print \"The string contains only letters A-H,\
    \ J-K, M-N and Z!\\n\" }\n</code>\nThis regex matches a string that contains only\
    \ letters A-HJ-KM-N and Z. This method also won't match strings like \"Hello world\"\
    \ with only letters in them, which is why I said that this would involve too many\
    \ loops and nested if statements.\nTo check if a string contains only letters,\
    \ you can do this:\n<code>\nif ($str =~ /^[A-z]+$/i) { print \"The string contains\
    \ only letters!\\n\" }\n</code>\nThis regex matches a string that contains only\
    \ letters A-Z. This method will match strings like \"Hello world\" with only numbers\
    \ in them as well, so it might not be the best way to do it.\n<|/ a dscore=0 tags=perl,regex,string\
    \ |>\n<| c |>\nIn your first example, you have a space, not a space...\n<|/ c\
    \ |>\n<| c |>\n`my = qw(Hello world);\n  my $str = join '',;\n  print ($str =~\
    \ /^[A-z]+$/i) ? 'True' : 'False';`  \nOutputs:\nTrue\n<|/ c |>\n<| c |>\nI guess\
    \ I misread the post. This code checks for multiple characters, so I went ahead\
    \ and fixed it.\n<|/ c |>\n<| a tags=perl,regex,string |>", "    if ($txt =~ /\\\
    w$/) {\n\treturn $txt;\n    } else {\n\treturn '';\n    }\n}", "    return 1 unless\
    \ ($txt and $txt =~ m/([a-z])$/i);\n    return $1;\n}", '    return "" unless
    defined $txt;', "    # A word is defined as one or more alphanumeric, non-space\
    \ characters.\n    return $txt =~ /^([a-zA-Z0-9]+)$/\n}", "    $txt =~ s/\\s+/\
    \ /g;\n    return if $txt !~ /\\p{L}$/;\n    return $txt !~ /\\w$/;\n    return\
    \ $txt !~ /\\P{L}$/;\n    return $txt !~ /[[:alnum:]]$/;\n}", "    my($last_char)\
    \ = substr($txt, -1, 1);\n    return \"\" if $last_char !~ /^[a-z]+$/;\n    return\
    \ $last_char;\n}", "    $txt =~ s/^\\s+//;\n    $txt =~ s/\\s+$//;\n    $txt =~\
    \ s/\\s+/ /;\n    my $last_char = substr($txt,-1);\n    return \"\" if $last_char\
    \ =~ /[a-zA-Z]/;\n    return 1;\n}", "    my $last_char = substr($txt, length($txt)\
    \ - 1, 1);\n    return $last_char =~ /^[a-zA-Z]$/;\n}", "    chomp($txt);\n  \
    \  my $last_char = substr($txt, length($txt), 1);\n    return $last_char =~ /[a-z]/i\
    \ if $txt =~ /[a-z]/i;\n    return \"\";\n}", "    $txt =~ s/^(.*)$/$txt.substr(-1,1)\
    \ =~ /[a-z]+/ ? 1 : \"\";\n}", "    if($txt =~ /[[:alpha:]]$/) {\n        return\
    \ 1;\n    }\n    return '';\n}", "    my($last_char) = substr($txt,-1, 1);\n \
    \   my($non_word_char) = join '', split //, ' ';\n    return($txt =~ m/[^a-zA-Z]$last_char/\
    \ && $txt !~ m/$non_word_char/);\n}", "    return 0 if ( my($last) = substr($txt,\
    \ length($txt) - 1, 1) );\n    return 1 if $last =~ /^[a-z]$/i;\n    return \"\
    \";\n}", "    my($i) = length($txt);\n    my($c) = $txt[$i];\n    my($w) = \"\
    \ \";\n    my($last) = substr($txt,$i-1,1);\n    if ($last eq $c) {\n        $last\
    \ = \"\";\n    } elsif ($last !~ m/\\w$/) {\n        $last = substr($txt,$i-1,1);\n\
    \    }\n    my($letter) = $last =~ m/\\w$/;\n    return $letter;\n}", "    return\
    \ unless $txt;\n    my($last) = substr($txt, length($txt) - 1);\n    if ($last\
    \ !~ /^[a-zA-Z]$/) {\n        return 1;\n    }\n    return \"\";\n}", "    return\
    \ \"\" unless $txt;\n    \n    my(@letters) = (\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\");\n\
    \    my(@words) = (\"apple\", \"banana\", \"cat\", \"dog\", \"egg\", \"fish\"\
    , \"fox\", \"frog\", \"hair\", \"kid\", \"mouse\", \"rat\", \"salmon\", \"snake\"\
    , \"water\", \"wine\");\n    my(@strings) = (\"A cat saw a fish.\", \"A dog ate\
    \ an apple.\", \"A horse ate a rat.\", \"A rat ate an apple.\", \"A rat ate an\
    \ apple.\", \"A cat ate an apple.\");\n    my($letter) = $txt[-1];\n    my(@check)\
    \ = ();\n    \n    foreach my $letter (@letters) {\n        if ($letter eq $letters[-1])\
    \ {\n            push(@check, $letter);\n        }\n    }\n    foreach my $word\
    \ (@words) {\n        foreach my $letter (split //, $word) {\n            if ($letter\
    \ eq $letters[-1]) {\n                push(@check, $letter);\n            }\n\
    \        }\n    }\n    foreach my $string (@strings) {\n        foreach my $letter\
    \ (split //, $string) {\n            if ($letter eq $letters[-1]) {\n        \
    \        push(@check, $letter);\n            }\n        }\n    }\n    \n    return\
    \ scalar(@check);\n}", "    my $last_char = uc(substr($txt, length($txt)-1, 1));\n\
    \    my $is_last_letter = 0;\n    foreach my $word (@words) {\n        if ($word\
    \ =~ /$last_char/) {\n            $is_last_letter = 1;\n        }\n    }\n   \
    \ if ($is_last_letter) {\n        return $last_char;\n    }\n    else { return\
    \ \"\"; }\n}", "    $txt =~ s/\\s+$//;\n    if ( $txt =~ /[a-zA-Z]/ ) { # last\
    \ character is alphabetical\n        return '';\n    }\n    if ( $txt =~ /([a-zA-Z])/\
    \ ) { # last character is alphabetical and part of a word\n        return 1;\n\
    \    }\n    return '';\n}", "    # $txt is the string being tested for last char\
    \ being alpha.\n    # Return \"\" if there is no text.\n    return '' unless $txt;\n\
    \    # Return the result of the test.\n    # Check if the last character is alpha.\n\
    \    if (substr($txt, -1) != ' ' && ! $txt[-1] =~ /[A-Za-z]$/) {\n        return\
    \ '';\n    }\n    return '';\n}", "    my($len) = length($txt);\n    my($last)\
    \ = $txt[$len - 1];\n    my($alpha) = qr{[A-Za-z]}i;\n    \n    return $last &&\
    \ $last !~ $alpha;\n}", "    my($last_char) = substr($txt, length($txt)-1,1);\n\
    \    return $txt if ($last_char !~ /[a-zA-Z]/ && $txt !~ /\\b$last_char\\b/);\n\
    \    return '';\n}", "    if($txt =~ m/[a-zA-Z]$/ and $txt !~ m/$word/) {\n  \
    \      return $txt;\n    } else {\n        return \"\";\n    }\n}", "    return\
    \ 1 unless length($txt);\n    my $last_char = substr($txt, -1);\n    return $last_char\
    \ =~ /\\w/ ? \"\" : $last_char;\n}", "    my($last_letter) = $txt->[$txt->length-1];\n\
    \    my(@words) = split (/ /, $txt);\n    my($result) = \"\";", "    # Remove\
    \ trailing spaces.\n    $txt =~ s/\\s+$//;\n    # If last character is a letter\
    \ but not a part of a word, then return \"\".\n    return '' unless $txt =~ /^[a-z]+$/;\n\
    \    return '' unless $txt =~ /^[a-z]+$/;\n    return 1;\n}", "    my $last_char\
    \ = substr($txt, -1);\n    my $is_letter = index($last_char, \"abcdefghijklmnopqrstuvwxyz\"\
    );\n    return $is_letter ? 0 : 1;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>", "    return \"\" unless defined($txt);\n    my $chr = substr($txt,\
    \ -1);\n    return \"\" unless $chr =~ m/[A-Za-z]/;\n    return $chr;\n}", " \
    \   chomp($txt);\n    $txt =~ s/^\\s*//;\n    $txt =~ s/\\s*$//;\n    return $txt\
    \ unless $txt =~ /^[a-z]+$/i;\n    return '';\n}", "    return $txt if $txt !~\
    \ /[^A-Za-z]/;\n    return substr($txt, -1, 1) !~ /[A-Za-z]/;\n}", "    $txt =~\
    \ s/\\s+//g;\n    my $is_last_letter = $txt =~ /[^a-zA-Z]$/;\n    return $is_last_letter;\n\
    }", "    $txt =~ s/^\\s*//;\n    $txt =~ s/\\s*$//;\n    my($last) = substr($txt,-1,1);\n\
    \    $last =~ tr/A-Z/a-z/;\n    return(\"\") unless $last;\n    return 1;\n}\n\
    1;\n</code>\nThe first step is to trim leading and trailing spaces.  This is important\
    \ because in the last condition, if the last character in the string is alphabetic,\
    \ then it must be a letter from A to Z and must not be a part of a word.  \nNext\
    \ we isolate the last character and test for whether it is a letter or a part\
    \ of a word.  Note that we use tr/A-Z/a-z/ to test for letters because tr tests\
    \ whether the given character is a member of a given set.  tr only works on a\
    \ single character string, so we must match multiple characters.  To do this,\
    \ we match all characters from A to Z, and match all characters from A to Z (case\
    \ insensitive) using the /c option.  If the last character is a member of the\
    \ set, then the whole character is alphabetic.\nFinally, we return \"\" if the\
    \ last character is alphabetic, or the empty string otherwise.  \nTests:\n<code>\n\
    use Test::More;", "    my @words = split(/ /, $txt);\n    my $last_char = pop(@words);\n\
    \    if ($last_char =~ /^[a-zA-Z]$/) {\n        return \"\";\n    } elsif (@words)\
    \ {\n        return 1;\n    } else {\n        return \"\";\n    }\n}", "    my($last_char)\
    \ = substr($txt,length($txt)-1,1);\n    if(length($last_char) >= 1 && lc($last_char)\
    \ ne \" \") {\n        return $last_char;\n    }\n    return \"\";\n}", "    if\
    \ ($txt =~ /^(.*)([A-Za-z])(.*)$/) {\n        return $1;\n    }\n    return '';\n\
    }", "    my($last_char) = $txt =~ s/([^\\s]*$)/$1/;\n    return 1 if $txt !~ /^[a-z]+$/\
    \ && $last_char !~ /^[a-z]+$/;\n    return $txt;\n}", "    return \"\" if not\
    \ $txt or $txt eq \"\";\n    my($last) = length $txt - 1;\n    return $txt[$last]\
    \ if $txt[$last] =~ /[a-z]/;\n    return \"\";\n}", "    if (length($txt) > 0)\
    \ {\n        if (substr($txt, length($txt) - 1) !~ /\\w/) {\n            my $last_char\
    \ = substr($txt, length($txt) - 1);\n            return 1 if $last_char !~ /[a-zA-Z]/;\n\
    \        }\n    }\n    return \"\";\n}", "    my($last_ch) = substr($txt,length($txt)-1,1);\n\
    \    my($word) = $txt =~ /([A-Za-z]+)/g;\n    my($letter_in_word);\n    foreach\
    \ (@$word) {\n        $letter_in_word = 1 if $letter_in_word == 1 or $letter_in_word\
    \ == 0; # if its not a word character, or it is first letter\n        $letter_in_word\
    \ = 1 if $letter_in_word == 1 or $letter_in_word == 0; # if its not a word character,\
    \ or it is first letter\n        $letter_in_word = 1 if $letter_in_word == 1 or\
    \ $letter_in_word == 0; # if its not a word character, or it is first letter\n\
    \    }\n    return $letter_in_word;\n}\n</code>\n<|/ a tags=perl,regex |>\n<|\
    \ c |>\nThe only time `@$word` isn't an empty list in a `foreach` loop is when\
    \ `@$word` is `@$_`. Since `@$word` is empty when `@$word` is `@$_`, then `@$word`\
    \ becomes `@$_`. So it's safe to assume that `@$word` is an empty list when `@$_`\
    \ is empty and `@$word` becomes `@$_`.\n<|/ c |>\n<| c |>\n, It would seem that\
    \ `@$word` is empty when `@$_` is empty. But `@$word` does not become `@$_`. It\
    \ is the other way around. `@$word` becomes `@$_`.\n<|/ c |>\n<| c |>\nI think\
    \ I see your point now. `@$word` is empty, and `@$_` is not, because `@$_` was\
    \ empty, therefore `@$word` had no elements. Your edit was correct. I thought\
    \ you were saying that the opposite was true.\n<|/ c |>\n<| c |>\n, Yes, I understand\
    \ what you mean.\n<|/ c |>\n<| a dscore=0 |>\nJust as a side note,'s answer is\
    \ great. I just wanted to point out an alternative approach: I recently had to\
    \ write a function that could determine if a line was a header or not. Since I\
    \ wanted to keep it reusable, I ended up writing a test routine for it which would\
    \ return the line number (in the array) of a \"header\" line.\nThe routine is\
    \ as follows:\n<code>", "    my $last_char = substr($txt, length($txt) - 1, 1);\n\
    \    return '' unless $last_char =~ /[a-zA-Z]/;\n    return 1 if $last_char !~\
    \ /\\w/;\n    return '';\n}", "    $txt =~ s/[[:space:]]$//;\n    $txt =~ s/$word[[:alpha:]]/$word/g;\n\
    \    $txt =~ s/ $word[[:alpha:]]//;\n    $txt =~ s/ $word/$word[[:alpha:]]/;\n\
    \    return $txt;\n}", "    my(@lst) = split(\" \",$txt);\n    my($last_char)\
    \ = pop(@lst);", "    $txt =~ s/\\s+//g;\n    if ($txt !~ /^\\s*$/) {\n      \
    \  $txt =~ s/\\p{L}+\\z/\"\"/;\n    } else {\n        $txt = \"\";\n    }\n  \
    \  return $txt;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
