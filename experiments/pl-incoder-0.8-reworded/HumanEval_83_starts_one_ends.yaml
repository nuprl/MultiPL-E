name: HumanEval_83_starts_one_ends
language: pl
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\nsub starts_one_ends {\n    my($n)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&starts_one_ends;\n\
  \        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(2),18)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),180))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),1800))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),18000))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $count = 0;\n    my $one = 1;\n    while ($n > 1) {\n      \
    \  $count += $n % 10; $n = ($n - $count + $one) / 10;\n        $one++;\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my $one = 1;\n    my $two =\
    \ 2;\n    my $three = 3;\n    my $four = 4;\n    my $five = 5;\n    my $six =\
    \ 6;\n    my $seven = 7;\n    my $eight = 8;\n    my $nine = 9;\n    my $ten =\
    \ 10;", "    return 0 unless $n =~ /^\\d+$/;\n    return 0 if $n =~ /^0$/;\n \
    \   my($count) = 0;\n    my $digit;\n    while ($n =~ /^(\\d{1})(\\d{1})$/) {\n\
    \        $count++;\n        $n = $1 . $2;\n    }\n    return $count;\n}", '    my($starts)
    = ();', "    return 0 unless $n;\n    return 1 if $n == 1;\n    return 0 if $n\
    \ < 10;\n    return 1 if $n =~ /^1\\d+$/;\n    return 1 if $n =~ /^11\\d+$/;\n\
    \    return 0 if $n =~ /^111\\d+$/;\n    return 1 if $n =~ /^1111+$/;\n    return\
    \ 0 if $n =~ /^11111$/;\n    return 1 if $n =~ /^11111$/;\n    return 0 if $n\
    \ =~ /^111111$/;\n    return 1 if $n =~ /^1111111$/;\n    return 0 if $n =~ /^11111111$/;\n\
    \    return 1 if $n =~ /^111111111$/;\n    return 0 if $n =~ /^1111111111$/;\n\
    \    return 1 if $n =~ /^11111111111$/;\n    return 0 if $n =~ /^111111111111$/;\n\
    \    return 1 if $n =~ /^1111111111111$/;\n    return 0 if $n =~ /^11111111111111$/;\n\
    \    return 1 if $n =~ /^111111111111111$/;\n    return 0 if $n =~ /^1111111111111110$/;\n\
    \    return 1 if $n =~ /^111111111111111101$/;\n    return 0 if $n =~ /^1111111111111111010$/;\n\
    \    return 1 if $n =~ /^111111111111111101001$/;\n    return 0 if $n =~ /^111111111111111101010100$/;\n\
    \    return 1 if $n =~ /^11111111111111110101010101$/;\n    return 0 if $n =~\
    \ /^1111111111111111010101010101$/;\n    return 1 if $n =~ /^1111111111111111010101010101010$/;\n\
    \    return 1 if $n =~ /^11111111111111110101010101010101010$/;\n    return 1\
    \ if $n =~ /^111111111111111101010101010101010101010$/;\n    return 1 if $n =~\
    \ /^11111111111111110101010101010101010101010101010$/;\n    return 1 if $n =~\
    \ /^111111111111111101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010",
  "    return 0 if $n == 0;\n    return 0 if $n % 1 != 0;\n    return 1 if $n < 10;",
  "    return 0 unless $n;\n    return 0 unless $n =~ /^\\d+$/;", "    return 0 if\
    \ $n < 1;\n    return 1 if $n == 2; # special case: two 1's at the start or end\n\
    \    return 0 if $n =~ /^0$/;\n    return 1 if $n =~ /^1(?= |$)$/; # special case:\
    \ one 1 at the start\n    return 0 if $n =~ /^1(?= |$)/; # special case: one 1\
    \ at the end\n    return 1 if $n =~ /^1(?= |$)$/; # special case: two 1's at the\
    \ end\n    my(@s) = ($n =~ /^(1(?= |$))/) ? $n =~ /1(?= |$)/g : ();\n    my $count\
    \ = 0;\n    foreach my $x (@s) {\n        if ($x eq '1')\n        {\n        \
    \    $count++;\n        }\n    }\n    return $count;\n}", "    my $count = 0;\n\
    \    while ($n){\n        $n = ($n % 10) + 1;\n        $count += $n <= 1 ? 1 :\
    \ 0;\n    }\n    return $count;\n}", "    return 0 if not $n;\n    return 1 if\
    \ $n == 0;\n    return 0 if $n == 1;\n    return $n - 1 if $n % 2 == 0;\n    return\
    \ 2 * starts_one_ends($n - 2) + 1 if $n % 3 == 0;\n    return starts_one_ends($n\
    \ - 1) + 1;\n}", "    $n -= 1;\n    my $count = 0;\n    while ($n >= 0) {\n  \
    \      last if ($n & 1);\n        $count++;\n        $n = ($n >> 1);\n    }\n\
    \    return $count;\n}", '    return 0 if $n < 10;', "    my($count);\n    $count\
    \ = 1 if $n < 10;\n    $count += 1 if $n < 100;\n    $count += 1 if $n < 1000;\n\
    \    $count += 1 if $n < 10000 && $n % 100 == 0;\n    $count += 1 if $n < 10000\
    \ && $n % 100 == 1;\n    $count += 1 if $n < 10000 && $n % 100 == 2;\n    $count\
    \ += 1 if $n < 10000 && $n % 100 == 3;\n    $count += 1 if $n < 10000 && $n %\
    \ 100 == 4;\n    $count += 1 if $n < 10000 && $n % 100 == 5;\n    $count += 1\
    \ if $n < 100000 && $n % 1000 == 0;\n    $count += 1 if $n < 100000 && $n % 1000\
    \ == 1;\n    $count += 1 if $n < 100000 && $n % 1000 == 2;\n    $count += 1 if\
    \ $n < 100000 && $n % 1000 == 3;\n    $count += 1 if $n < 100000 && $n % 1000\
    \ == 4;\n    $count += 1 if $n < 100000 && $n % 1000 == 5;\n    return $count;\n\
    }", "    $n = 0 unless defined $n;\n    my $count = 0;", "    my $count = 0;\n\
    \    for (1..$n) {\n        my $x = $n;\n        if ($x % 10 == 1) {\n       \
    \     $count++;\n            $x = $x/10;\n        }\n        else {\n        \
    \    last if $x % 10 == 0;\n            $x = $x/10;\n        }\n    }\n    return\
    \ $count;\n}", "    $n -= 0;\n    return 0 if $n < 10;\n    return 1 if $n <=\
    \ 9;\n    return 0 if $n =~ /^1$/;\n    return 1 if $n =~ /^10$/;\n    return\
    \ 1 if $n =~ /^11$/;\n    return 2 if $n =~ /^12$/;\n    return 3 if $n =~ /^13$/;\n\
    \    return 4 if $n =~ /^14$/;\n    return 5 if $n =~ /^15$/;\n    return 6 if\
    \ $n =~ /^16$/;\n    return 7 if $n =~ /^17$/;\n    return 8 if $n =~ /^18$/;\n\
    \    return 9 if $n =~ /^19$/;\n    return 10 if $n =~ /^20$/;\n    return $n\
    \ + 10 if $n =~ /^21$/;\n    return $n + 20 if $n =~ /^22$/;\n    return $n +\
    \ 10 if $n =~ /^23$/;\n    return $n + 20 if $n =~ /^24$/;\n    return $n + 10\
    \ if $n =~ /^25$/;\n    return $n + 20 if $n =~ /^26$/;\n    return $n + 10 if\
    \ $n =~ /^27$/;\n    return $n + 20 if $n =~ /^28$/;\n    return $n + 10 if $n\
    \ =~ /^29$/;\n    return $n + 20 if $n =~ /^30$/;\n    return $n + 10 if $n =~\
    \ /^31$/;\n    return $n + 20 if $n =~ /^32$/;\n    return $n + 10 if $n =~ /^33$/;\n\
    \    return $n + 20 if $n =~ /^34$/;\n    return $n + 10 if $n =~ /^35$/;\n  \
    \  return $n + 20 if $n =~ /^36$/;\n    return $n + 10 if $n =~ /^37$/;\n    return\
    \ $n + 20 if $n =~ /^38$/;\n    return $n + 10 if $n =~ /^39$/;\n    return $n\
    \ + 20 if $n =~ /^40$/;\n    return $n + 10 if $n =~ /^41$/;\n    return $n +\
    \ 20 if $n =~ /^42$/;\n    return $n + 10 if $n =~ /^43$/;\n    return $n + 20\
    \ if $n =~ /^44$/;\n    return $n + 10 if $n =~ /^45$/;\n    return $n + ", " \
    \   my $count = 0;\n    while ($n > 1) {\n        my $remainder = $n % 10;\n \
    \       $count++ if ($remainder == 1);\n        $n = int($n/10);\n    }\n    return\
    \ $count;\n}", "    my $nums = grep {$_ != 1} 1 .. $n;\n    return scalar grep\
    \ { $_ % 10 == 1 && $nums->[$_-1] == $nums->[$_] } 0 .. $n;\n}", "    return 0\
    \ unless ( defined $n && $n >= 0 );\n    return 0 if ( $n <= 1 );\n    return\
    \ substr $n, -$n, 1 eq '1' ? 1 : 0;\n}", "    return 1 if $n == 0; # 0 only starts\
    \ a positive integer if n > 0\n    return 0 if $n == 1; # 1 only ends a positive\
    \ integer if n > 0\n    return ($n-1) * '0' if $n <= 10; # n <= 10 can only be\
    \ 0, 1 or 2", "    return $n == 1 ? 1 : 0;\n}", "    return 1 if ($n == 1);\n\
    \    return $n - 1 if ($n < 10);\n    return $n - 10 if ($n < 100);\n    return\
    \ $n - 100 if ($n < 1000);\n    return $n - 1000 if ($n < 10000);\n    return\
    \ $n - 10000 if ($n < 100000);\n    return $n - 100000 if ($n < 1000000);\n  \
    \  return $n - 1000000 if ($n < 10000000);\n    return $n - 10000000 if ($n <\
    \ 100000000);\n    return $n - 100000000 if ($n < 1000000000);\n    return $n\
    \ - 1000000000 if ($n < 10000000000);\n    return $n - 10000000000 if ($n < 100000000000);\n\
    \    return $n - 100000000000 if ($n < 1000000000000);\n    return $n - 1000000000000\
    \ if ($n < 10000000000000);\n    return $n - 10000000000000 if ($n < 100000000000000);\n\
    \    return $n - 100000000000000 if ($n < 1000000000000000);\n    return $n -\
    \ 1000000000000000 if ($n < 10000000000000000);\n    return $n - 10000000000000000\
    \ if ($n < 100000000000000000);\n    return $n - 100000000000000000 if ($n < 100000000000000000);\n\
    \    return $n - 100000000000000000; # shouldn't reach\n}", "    my($count) =\
    \ 0;\n    my($remainder) = intdiv($n, 10);\n    while ($remainder >= 1) {\n  \
    \      $count++;\n        $remainder = intdiv($remainder, 10);\n    }\n    $count;\n\
    }", "    return 0 unless ($n);\n    my %ones = map { $_ => 1 } 1..10;\n    my\
    \ $count = 0;\n    while ($n) {\n        last unless exists $ones{$n};\n     \
    \   $count += $ones{$n};\n        $n -= $ones{$n};\n    }\n    return $count;\n\
    }", "    my($total) = 0;\n    my(@starts) = 0;\n    my(@ends) = 0;\n    \n   \
    \ while($n > 0){\n        if($n & 1){\n            $total++;\n            push(@starts,\
    \ $n);\n        }\n        \n        $n >>= 1;\n    }\n    \n    for($i = 0; $i\
    \ < @starts; $i++){\n        if($starts[$i] == 1){\n            $total++;\n  \
    \      }\n    }\n    \n    return $total;\n}", "    return 0 if ($n <= 0);\n \
    \   $n += 10; # Make sure $n is large enough", "    $n += 0;\n    $n *= 10;\n\
    \    my($n) = sprintf \"%.0f\", $n;\n    my @zeros = ();\n    my @ones = ();\n\
    \    my($i, $one, $zero, $x);\n    for ($i = 0; $i < $n; $i++) {\n        $one\
    \ = $zero = 0;\n        for ($x = ($i - 1) % ($i + 1); $x <= $i; $x++) {\n   \
    \         if ($x != 0) {\n                if ($x % 10 == 1) {\n              \
    \      $one++;\n                }\n                elsif ($x % 10 == 0 and\n \
    \                      ($x != 1 or $i > 0)) {\n                    $zero++;\n\
    \                }\n            }\n        }\n        push(@ones, $one);\n   \
    \     push(@zeros, $zero);\n    }\n    return (@zeros, @ones);\n}", "    return\
    \ 0 if $n < 10;\n    return 0 if $n <= 9;\n    return 1 if $n == 1;\n    return\
    \ 0 if $n == 9;\n    return 1 if $n % 10 == 1 || $n == 1;\n    return $n / 10\
    \ + ($n % 10 == 1 && $n / 100 == 1);\n}", "    return 0 if $n < 1;\n    return\
    \ 0 if $n < 10;\n    return 1 if $n < 100;\n    return 1 if $n < 1000;\n    return\
    \ 1 if $n < 10000;\n    return 1 if $n < 100000;\n    return 1 if $n < 1000000;\n\
    \    return 1 if $n < 10000000;\n    return 1 if $n < 100000000;\n    return 1\
    \ if $n < 1000000000;\n    return 1 if $n < 10000000000;\n    return 1 if $n <\
    \ 100000000000;\n    return 1 if $n < 1000000000000;\n    return 1 if $n < 10000000000000;\n\
    \    return 1 if $n < 100000000000000;\n    return 1 if $n < 1000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 1000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 1000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000000000;\n\
    \    return 1 if $n < 10000000000000000;\n    return 1 if $n < 10000000000", " \
    \   $n += 0;  # Make the number positive.\n    return 1 if $n < 0;\n    if ($n\
    \ == 1) {\n        return 1;\n    }\n    return $n % 10 if $n % 10 == 1;\n   \
    \ # n is a multiple of 10.\n    # Divide n by 10, then add 1 to it.\n    # Divide\
    \ by 10 until we get down to 1 and divide again.\n    # n -> 1.\n    my $count\
    \ = 1;\n    while ($n >= 10) {\n        $n = $n / 10 + 1;\n        $count++;\n\
    \    }\n    return $count;\n}", '    my $count = 0;', '    my $ret = 0;', "  \
    \  my $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $n -= $count;\n    $count = $n % 10;\n    $n -= $count;\n\
    \    $count = $n % 10;\n    $", "    return scalar grep { $_ eq '1' or $_ eq '9'\
    \ } 1 .. $n;\n}\n</code>\n<|/ a |>\n<| a |>\nYou could also use perl functions\
    \ to do this, if performance is important (a lot of times):\n<code>", "    my\
    \ $count = 0;\n    while ($n > 0) {\n        my $x = $n % 10;\n        if ($x\
    \ != 1) {\n            ++$count;\n        }\n        $n /= 10;\n    }\n    return\
    \ $count;\n}", "    return 0 if $n == 0;\n    return 1 if ($n <= 9);\n    return\
    \ $n % 10 == 1 ? 0 : sub {\n        return sub {\n            my $x = shift;\n\
    \            return 1 if ($x < 10);\n            return $n % 10 == $x ? 0 : sub\
    \ {\n                return sub {\n                    my $y = shift;\n      \
    \              return 1 if ($y <= 10);\n                    return sub {\n   \
    \                     my $z = shift;\n                        return 1 if ($z\
    \ <= 10);\n                        my $starts_1_ends = starts_one_ends($n * 10\
    \ + $y * 10 + $z);\n                        return $n * 10 + $y * 10 + $z >= $n\
    \ ? $n * 10 + $y * 10 + $z - $starts_1_ends : $starts_1_ends;\n              \
    \      };\n                };\n            };\n        };\n    };\n}", "    my\
    \ $count = -1;\n    my $i = 0;\n    $n = abs($n);\n    my $digit;\n    while ($i\
    \ < $n) {\n        $digit = int ($i / 10);\n        $i += ($i % 10);\n       \
    \ if ($digit == 0) {\n            $count++;\n        }\n        else {\n     \
    \       my $ndigit = $digit % 10;\n            if ($digit == 1 && $ndigit == 1)\
    \ {\n                last;\n            }\n            if ($ndigit == 1) {\n \
    \               last;\n            }\n        }\n    }\n    return $count;\n}",
  "    return undef unless $n && $n =~ /^\\d+$/;\n    my $s = 1 if $n =~ s/^0/0/;\n\
    \    my $e = 9 if $n =~ s/^9//;\n    my $c = 0;\n    for(my $i = $s; $i <= $e;\
    \ $i++) {\n        if($i && $i =~ /^1/ && $i =~ /^$n/) {\n            ++$c;\n\
    \        }\n    }\n    return $c;\n}", "    return 0 unless $n && $n =~ /^-?\\\
    d+$/;\n    my($cnt) = 0;\n    $n -= 0; # $n will be a negative number if we start\
    \ with 1\n    while($n) {\n        last if $n % 10 == 1;\n        $cnt += 1 if\
    \ $n /= 10;\n    }\n    return $cnt;\n}", "    $n++ if $n == 1;\n    $n = $n+1\
    \ if $n =~ s/[^1-9]$//;\n    return 0 if $n > 9;\n    my($count) = 0;\n    for\
    \ ($i = 1; $i <= $n; $i++) {\n        $count += 1 if $i^1 == $n^1;\n    }\n  \
    \  return $count;\n}", "    return 1 if ($n == 0);\n    my $result = 0;\n    my\
    \ $i = 1;\n    my $limit = $n - 1;\n    while ($i <= $limit) {\n        if ($i\
    \ !~ /^1$/ && $i !~ /1$/ && $i !~ /^11$/ && $i !~ /11$/) {\n            $result\
    \ += 1;\n        }\n        $i += 1;\n    }\n    return $result;\n}", "    my\
    \ $ndigits = ceil(log($n)/log(10))+2;\n    my $count = 0;\n    my $digits = 0;\n\
    \    while($n>0) {\n        ++$count;\n        $n=$n/10;\n        ++$digits;\n\
    \    }\n    return $count if $digits == $ndigits;\n    return 0;\n}", '    my($count)
    = 0;', "    my $c = 1;\n    while ($n > 0) {\n        if ((($n % 10) == 1) ||\
    \ (($n % 10) == 9)) {\n            $c++;\n        }\n        $n = int($n/10);\n\
    \    }\n    return $c;\n}", "    return 1 if $n == 1;\n    my($count, $first,\
    \ $last) = 0, 0, 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        $first = $last\
    \ if $n % ($i + 2);\n        $last = $first + $n if ($i < ($n - 1)) && ($last\
    \ == $first);\n        $count++ if ($first == 1 && $last == $n);\n    }\n    return\
    \ $count;\n}", "    \n    my $count = 0;\n    \n    for(my $i = 1; $i <= $n; $i++)\
    \ {\n\tif( $i eq 1 || $i eq $n) {\n\t    $count++;\n\t}\n\tif( $i ne 1) {\n\t\
    \    $count += 0 if $i eq 1;\n\t}\n    }\n    \n    return $count;\n}", "    return\
    \ 1 if $n == 0;\n    my($num, $cnt) = (0, 0);\n    while ($n < 100) {\n      \
    \  if ($n & 1) {\n            $num++;\n            $cnt += $n & 1;\n        }\n\
    \        $n >>= 1;\n    }\n    return $cnt;\n}", "    my %count;\n    for (my\
    \ $i = 1; $i <= $n; $i++) {\n        push @{$count{$i}}, 1 if $i eq $n || $i eq\
    \ $n-1;\n    }\n    return scalar(%count);\n}", "    $n -= 1;\n    return 1 if\
    \ $n<0;\n    my $count = find_all_matches(\n        join('',\n            grep($_,\
    \ @starts),\n            grep($_, @ends)\n        ),\n        1\n    );\n    return\
    \ $n if $count < $n;\n    return $n;\n}", "    return 0 if $n == 0;\n    return\
    \ 1 if $n <= 10;\n    return ($n%10)+1 if $n>10 && $n%10 == 1;\n    return starts_one_ends($n/10)\
    \ + ($n%10 ? 1 : 0);\n}", "    my $count = 0;\n    $n += 0;  # ensure we have\
    \ the right sign for our comparison\n    for (my $i = 1; $i < $n; $i++) {\n  \
    \      if ($i ^ $n == 1) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    return 0 if $n == 0;\n    $n -= 1;\n    my $s = 0;\n    for\
    \ (my $i = 1; $i < $n; ++$i) {\n        $s += $i - 1\n            if $i & ($i\
    \ - 1) != 0;\n    }\n    return $s;\n}", "    my $i = 0;\n    for (1..$n) {\n\
    \        if ($_ == 1) {\n            $i += 1;\n        }\n    }\n    return $i;\n\
    }", "    $n = abs($n);\n    if ( $n == 0 ) {\n        return 0;\n    }\n    $n\
    \ += 10 ** $#_;\n    my $n2 = $n;\n    my $one = 1;\n    while ( $n2 >= 1 ) {\n\
    \        if ( $n2 % 10 == 1 ) {\n            $one += $n2 // $one;\n          \
    \  $n2 -= $one;\n        } else {\n            $n2--;\n        }\n    }\n    return\
    \ $n2;\n}", "    return 1 if $n == 0; # special case\n    return ($n>1)? 0 : 1\
    \ if ($n == 1);\n    my $n = abs($n);\n    return $n if $n < 10;\n    my $count\
    \ = 0;\n    for (my $x = 1; $x < $n; $x++) {\n        for (my $y = 1; $y < $n;\
    \ $y++) {\n            next if $x == $y;\n            if ($x != $y) { \n     \
    \           my $start = ($x % 10) == 1;\n                my $end = ($y % 10) ==\
    \ 1;\n                if ($start && $end) { $count++; }\n            }\n     \
    \   }\n    }\n    return $count;\n}", '    my $count = 0;', "    return 1 if ($n\
    \ <= 0);\n    return $n if ($n%10);", "    my($count) = 0;\n    if ($n == 0) {\n\
    \        return $count;\n    }\n    if ($n == 1) {\n        $count++;\n      \
    \  return $count;\n    }", "    return 0 if $n < 1;\n    return 0 if $n == 3 &&\
    \ $starts_one_ends($n-1) == 1;\n    return 0 if $n == 3 && $ends_one_starts($n-1)\
    \ == 1;\n    return 0 if $n == 3 && $ends_one_ends($n-1) == 1;\n    return 0 if\
    \ $n % 3 == 0;\n    return 0 if $starts_one_ends($n-1) == 0 && $ends_one_ends($n-1)\
    \ == 0;\n    return 0 if $starts_one_ends($n-1) == 0 && $ends_one_starts($n-1)\
    \ == 0;\n    return 0 if $starts_one_starts($n-1) == 0 && $ends_one_ends($n-1)\
    \ == 0;\n    return 0 if $starts_one_ends($n-1) == 0 && $ends_one_starts($n-1)\
    \ == 0;\n    return 0 if $n % 5 == 0;\n    return 0 if $starts_one_ends($n-1)\
    \ == 0 && $ends_one_ends($n-1) == 0;\n    return 0 if $starts_one_starts($n-1)\
    \ == 0 && $ends_one_ends($n-1) == 0;\n    return 0 if $starts_one_ends($n-1) ==\
    \ 0 && $ends_one_starts($n-1) == 0;\n    return 1;\n}", '    my $count = 0;',
  "    my $count = 0;\n    my $i = 1;\n    until ($i > $n){\n        $i *= 10;\n \
    \       ++$count;\n    }\n    return $count;\n}", "    my $count = 0;\n    for(my\
    \ $i = 0; $i <= $n; $i += 10) {\n        my $x = $i;\n        $x = $x - $x % 10\
    \ + 1;\n        ++$count if $x != 1;\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    for (1..$n) {\n        $count += $n =~ s/^1//;\n        $count +=\
    \ $n =~ s/1$//;\n    }\n    return $count;\n}", "    # special case\n    return\
    \ 1 if $n == 0;\n    return 1 if ($n & 1) != 0;\n    # otherwise, just count the\
    \ leading ones\n    return ($n & -$n) / 2;\n}", "    return 1 if $n eq 1;\n  \
    \  return 1 if $n eq 2;\n    return 0 if $n =~ /^\\d/;\n    return 0 if $n =~\
    \ /^1/;\n    $n *= 10;\n    return 0 if $n eq 5;\n    $n *= 10;\n    return 0\
    \ if $n eq 8;\n    $n *= 10;\n    return 0 if $n eq 9;\n    $n *= 10;\n    return\
    \ 0 if $n eq 10;\n    return 0 if $n eq 11;\n    $n *= 10;\n    return 0 if $n\
    \ eq 13;\n    $n *= 10;\n    return 0 if $n eq 15;\n    $n *= 10;\n    return\
    \ 0 if $n eq 18;\n    $n *= 10;\n    return 0 if $n eq 19;\n    $n *= 10;\n  \
    \  return 0 if $n eq 20;\n    $n *= 10;\n    return 0 if $n eq 21;\n    $n *=\
    \ 10;\n    return 0 if $n eq 23;\n    $n *= 10;\n    return 0 if $n eq 25;\n \
    \   $n *= 10;\n    return 0 if $n eq 27;\n    $n *= 10;\n    return 0 if $n eq\
    \ 30;\n    $n *= 10;\n    return 0 if $n eq 32;\n    $n *= 10;\n    return 0 if\
    \ $n eq 35;\n    $n *= 10;\n    return 0 if $n eq 37;\n    $n *= 10;\n    return\
    \ 0 if $n eq 40;\n    $n *= 10;\n    return 0 if $n eq 47;\n    $n *= 10;\n  \
    \  return 0 if $n eq 52;\n    $n *= 10;\n    return 0 if $n eq 61;\n    $n *=\
    \ 10;\n    return 0 if $n eq 91;\n    $n *= 10;\n    return 0 if $n eq 99;\n \
    \   return 0;\n}", '    return 1 if $n <= 0;', "    my $count = 0;\n    for(my\
    \ $i = 1; $i <= $n; $i++) {\n        my $start = 1 if $i % 10 == 1;\n        my\
    \ $end = 1 if $i % 10 == 9;\n        my $number = $i - ($start - $end);\n    \
    \    next if $number < 0;\n        $count++ if $number == 1;\n    }\n    return\
    \ $count;\n}", "    my($ones) = 0;\n    my($starts);", "    $n += 0 if  $n < 0;\n\
    \    my($count, $i);\n    $count = 0;", "    \n    # Count all the 1's starting\
    \ from right to left\n    my $c = 0;\n    while (1) {\n        last if $c >= $n;\
    \ # hit the end\n        last unless $n =~ s/^1$//; # didn't start with a 1, so\
    \ stop\n        $c++;\n    }\n    return $c;\n}", '    return 0 if not $n;', " \
    \   return $n if $n == 0;\n    return $1 if $n % 10 == 1;\n    return $1 if $n\
    \ % 10 == 9;\n    return $1 if $n % 10 == 9;\n    return $1 if $n % 10 == 99;\n\
    \    return $1 if $n % 10 == 9999;\n    return $1 if $n % 10 == 999;\n    return\
    \ $1 if $n % 10 == 99999;\n    return $1 if $n % 10 == 99999;\n}", "    my @a;\n\
    \    for (1..$n-1) {\n        push(@a, \"$n\");\n    }\n    for ($n+1..100) {\n\
    \        push(@a, \"$n\");\n    }\n    return @a;\n}", "    return 1 if $n ==\
    \ 0;\n    return 0 if $n == 1;\n    $n += 1;\n    return 0 if $n % 10;\n    return\
    \ 0 if $n % (10 * 10) == 0;\n    return 0 if $n % (10 * 10 + 9) == 0;\n    return\
    \ 0 if $n % (10 * 10 + 9 + 8) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7)\
    \ == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6) == 0;\n    return 0 if\
    \ $n % (10 * 10 + 9 + 8 + 7 + 6 + 5) == 0;\n    return 0 if $n % (10 * 10 + 9\
    \ + 8 + 7 + 6 + 5 + 4) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 +\
    \ 5 + 4 + 3) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3\
    \ + 2) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 +\
    \ 1) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1\
    \ + 0) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 +\
    \ 1 + 0 + -1) == 0;\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3\
    \ + 2 + 1 + 0 + -1 == 0 * -1);\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6\
    \ + 5 + 4 + 3 + 2 + 1 + 0 + -1 == 0 * -1);\n    return 0 if $n % (10 * 10 + 9\
    \ + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0 + -1 == 0 * -1);\n    return 0 if $n % (10\
    \ * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0 + -1 == 0 * -1);\n    return 0\
    \ if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0 + -1 == 0 * -1);\n\
    \    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0 + -1 ==\
    \ 0 * -1);\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1\
    \ + 0 + -1 == 0 * -1);\n    return 0 if $n % (10 * 10 + 9 + 8 + 7 + 6 + 5 + 4\
    \ + 3 + 2 + 1 + 0 + -1 == 0 * -1);\n    return 0 if $n % (10 * 10 + ", "    return\
    \ 1 if $n == 0;\n    my($count);\n    my $result = 1;\n    while (1) {\n     \
    \   $count++;\n        $n = $n-1;\n        if ($n == 0) {\n            $result\
    \ = $count if $count == 1;\n            return $result;\n        }\n        if\
    \ ($n%10 == 1) {\n            $n = ($n/10);\n        } else {\n            $n\
    \ = ($n%10);\n        }\n    }\n}", "    my($count, $total);\n    my $digit =\
    \ $n / 10;\n    $count += 1 if $n =~ /^[1-9][0-9]$/;\n    $total += $n if $n =~\
    \ /^[1-9][0-9][0-9]$/;\n    if ($n == 1) {\n        $count++;\n        $total\
    \ += $digit;\n    }\n    if ($digit != 0 && $digit != 1) {\n        my $digit2\
    \ = $n / 100;\n        my $digit3 = $n / 1000;\n        if ($digit2 != 0) {\n\
    \            $count += 1;\n            $total += $digit;\n        }\n        if\
    \ ($digit3 != 0) {\n            $count += 1;\n            $total += $digit;\n\
    \        }\n    }\n    return ($count, $total);\n}", "    return 0 if $n <= 0;\n\
    \    return 1 if $n == 1;\n    return 1 if $n == 2;\n    return 0 if $n % 2 ==\
    \ 0;\n    return starts_one_ends($n/2) if $n % 4 == 0;\n    return starts_one_ends($n/2)\
    \ + 1 if $n % 8 == 0;\n    return;\n}", "    my $count = 0;\n    for(my $i = 2;\
    \ $i <= $n; $i++) {\n        for(my $j = 1; $j <= $i; $j++) {\n            if($i\
    \ =~ /^$j/) {\n                ++$count;\n                last;\n            }\n\
    \        }\n    }\n    return $count;\n}", "    my $ndigit;\n    my $count = 0;\n\
    \    for(my $n = 1; $n >= 1; $n++) {\n        $ndigit = log10($n);\n        if($ndigit\
    \ == 1) {\n            $count++;\n        }\n        elsif($n <= 0) {\n      \
    \      last;\n        }\n        else {\n            for(my $i = $ndigit - 1;\
    \ $i >= 0; $i--) {\n                if($n >= 10**$i) {\n                    $n--;\n\
    \                }\n                else {\n                    break;\n     \
    \           }\n            }\n        }\n    }\n    $count;\n}", "    my $count\
    \ = 0;\n    while ($n > 0) {\n        $n--;\n        my $digit = $n % 10;\n  \
    \      if ($digit == 1) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    my($ret);\n    if ( $n < 0 ) {\n        $ret = 0;\n    }\n\
    \    else {\n        $ret = &count-one($n);\n    }\n    return $ret;\n}", "  \
    \  $n //= 10;\n    return 1 if $n == 0;\n    return 1 + $n if $n > $#_;\n    my($hi,\
    \ $lo) = ($_[0] % 10, $_[0] / 10);\n    my $s = 0;\n    for (; $lo; $lo = $hi\
    \ * 10 + $lo) {\n        $hi = $lo % 10;\n        $lo = $lo / 10;\n        $s++;\n\
    \    }\n    return 1 + $s if $n > $s;\n    return 0;\n}", "    my $ones = $n->bsearch(0,\
    \ 'eq', 1);\n    my $ends = $n->bsearch(-1, 'eq', 1);\n    return 0 if $ones >\
    \ $ends;\n    return ($ends-$ones-1) / $n+1;\n}", "    return 0 if $n == 0;\n\
    \    return 1 if $n == 1;\n    return 1 + ($n / 10) + 1 + ($n % 10);\n}", "  \
    \  my %count_hash;\n    my $count = 1;\n    $count_hash{$_} = ++$count for 1..$n;\n\
    \    foreach my $key (keys %count_hash) {\n        return $count_hash{$key} if\
    \ $key % 2 == 1;\n    }\n    return;\n}", "    my $count = 0;\n    for(my $i =\
    \ 0; $i <= $n; $i++) {\n        my $s = $n % 10;\n        if ($s == 1) {\n   \
    \         $count += 1;\n        }\n        $n = $n / 10;\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", '    my($count)
    = 0;', "    my $digits = $n / 10;\n    $n %= 10;\n    $digits += 1 unless $n %\
    \ 2;\n    my $c = $digits + 1;\n    if ($n > 9) {\n        $c += scalar starts_one_ends($n\
    \ - 9);\n    }\n    return $c;\n}", "    $n = 0 unless defined $n;\n    $n = 5\
    \ if $n eq \"5\";\n    $n -= 1 unless $n > 0;\n    $n = 0 if $n < 1;\n    if ($n\
    \ % 2 == 0) {\n        return 0 if $n == 5;\n        return 1 if $n == 1;\n  \
    \  }\n    return 0 unless $n <= 9;\n    return 1 if $n >= 10;\n    return 1 if\
    \ $n >= 100 and $n <= 199;\n    return 2 if $n >= 200 and $n <= 299;\n    return\
    \ 3 if $n >= 300 and $n <= 399;\n    return 4 if $n >= 400 and $n <= 499;\n  \
    \  return 5 if $n >= 500 and $n <= 9999;\n    return 6;\n}", "    my $count =\
    \ 0;\n    for (my $i = 1; $i <= $n; $i++) {\n        last if ($i | $i == $n);\n\
    \        if ($i | $i == 1) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    $n++ if $n<0;\n    return 1 if $n==0;\n    my $count=0;\n\
    \    while ($n>0){\n        my $x = substr($n,0,1);\n        $count++ if $x==1;\n\
    \        $n -= 1;\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nMy answer is different from others and probably more efficient, but I thought\
    \ I'd post it. This finds the length of the longest sequence of zeros ending with\
    \ a 1.\n<code>", '    return 0 if $n < 1;', "    my $count = 0;\n    while ($n)\
    \ {\n        $count += 1 if $n =~ /^1/ || $n =~ /^10/ || $n =~ /^11/ || $n =~\
    \ /^12/ || $n =~ /^13/ || $n =~ /^14/ || $n =~ /^15/ || $n =~ /^16/ || $n =~ /^17/\
    \ || $n =~ /^18/ || $n =~ /^19/ || $n =~ /^2/;\n        $n -= 1;\n    }\n    return\
    \ $count;\n}", "    my($c) = substr $n, $-[0], 1;\n    my($d) = substr $n, $+[0],\
    \ 1;\n    if ($d == 1) {\n        return 1;\n    }\n    if ($d == -1) {\n    \
    \    return $c;\n    }\n    return 0;\n}", "    $n -= 1;\n    my $count = 0;\n\
    \    for (my $i = $n; $i >= 0; $i--) {\n        if (substr($i, 0, 1) eq '1')\n\
    \            $count++;\n    }\n    return $count;\n}\n</code>\nThe algorithm is\
    \ simple: take n and count the ones in the first n-1 digits.  Then the ones in\
    \ the next digit, until the whole number is done.  This process will be repeated:\
    \ take the count of the first n-1 digits, and subtract it from the count of the\
    \ next digit.  Then repeat this process until you run out of digits.  The count\
    \ of the last digit will always be 1, since the first digit cannot be a zero.\n\
    If you don't believe me, check out this example:\n<code>\nuse strict;\nuse warnings;",
  "    return 1 if ($n > 0 && $n <= 9);\n    if ($n % 10 == 1) {\n        return starts_one_ends(($n/10)\
    \ * 10 + $n % 10);\n    }\n    return starts_one_ends(($n/10) + 1) + starts_one_ends($n\
    \ % 10);\n}", '    return 0 unless $n =~ /^\d+$/ && $n > 0;', '    my($counter)
    = @_;', "    my $count = 0;\n    for my $x (1 .. $n) {\n        if ($_ % $x ==\
    \ 0) {\n            $count += 1;\n        }\n    }\n    return $count;\n}", " \
    \   return 1 if $n == 1;\n    return 1 if $n == 2;\n    $n = 3 if $n <= 3;\n \
    \   my $count = 1;\n    while (int($n / 10) > 0) {\n        $count++ if $n =~\
    \ /^(.*1)\\1$/;\n        $n -= 10;\n    }\n    return $count;\n}\n</code>\nThe\
    \ subroutine starts_one_ends has two return statements. In the first one, if the\
    \ given number is 1, then it returns 1. In the second one, if $n <= 3, then it\
    \ returns 1 because (.*1) will match as much as it can (i.e. \"zero or more of\
    \ any character\", followed by a 1, followed by \"zero or more of any character\"\
    ). In the third one, if the number is not less than three, then it will continue\
    \ to decrement $n by ten until it reaches one.\nYou can then use this subroutine\
    \ like so:\n<code>\nmy $answer = &starts_one_ends(9);\n</code>\n$answer will be\
    \ set to 4 (because 9 is exactly one that starts or ends with 1).\n<|/ a dscore=3\
    \ tags=algorithm,math,regex,counting,perl |>\n<| c |>\nI appreciate your answer,\
    \ but I think that my question was a little too vague. I've added a little more\
    \ detail to it.\n<|/ c |>\n<| c |>\n: Yes, sorry. Your question was too vague\
    \ for me to give a meaningful answer.\n<|/ c |>\n<| c |>\n: See my edit. I think\
    \ it answers the question now that you've added more info.\n<|/ c |>\n<| c |>\n\
    +1 for a clever solution. I wonder if there might be a way to make it faster...\n\
    <|/ c |>\n<| c |>\nThis works but is horribly slow on Perl5.8. On 5.10.0 it took\
    \ about 6 seconds to count 9! The regex doesn't match the string at all. `s/^[^1]*1/1/`\
    \ works.\n<|/ c |>\n<| a |>\nThe trick is to realize that no matter how you count\
    \ the numbers, you always know that there must be at least some integer in between\
    \ the start and end.  That means you can easily construct a regex that matches\
    \ any number starting with the start, and ending with the end.\nThe first step\
    \ is to construct the regex to match any integer between start and end, including\
    \ the end condition.  That means you just have to append a number to the end and\
    \ add it to the regex:\n<code>\n$start_num eq $end_num ? $start_num : \"$start_num$end_num\"\
    ;\n</code>\nAnd then, ", "    $n++ if $n =~ /^1(\\d)$/;\n    return $n if $n =~\
    \ /^1(\\d)$/;\n    return 1 if $n =~ /^(\\d)\\1$/;\n    return 0;\n}", "    return\
    \ 1 if $n > 0 && $n <= 9;\n    return 2 if $n > 9 && $n <= 99;\n    return 3 if\
    \ $n > 99 && $n <= 999; # 99999\n    return 4 if $n > 999 && $n <= 9999; # 9999999\n\
    \    return 5 if $n > 9999 && $n <= 999999; # 99999999\n    return 6 if $n > 999999\
    \ && $n <= 9999999; # 999999999999\n    return 7 if $n > 9999999 && $n <= 99999999999;\
    \ # 99999999999999999\n    return 8 if $n > 99999999999 && $n <= 9999999999999;\
    \ # 99999999999998765\n    return 9 if $n > 9999999999999 && $n <= 999999999999999;\
    \ # 999999999999987654321\n    return 10 if $n > 999999999999999 && $n <= 999999999999987654321;\
    \ # 9999999999999876543210\n    return 11;\n}", '    my($c);', "    return 0 if\
    \ $n == 0;\n    return 1 if $n == 1;\n    return ($n-1) * $starts_one_ends($n-1);\n\
    }", "    return 0 if (($n < 0) || ($n == 0));\n    return 1 if $n <= 10;\n   \
    \ return 0 if $n % 10 != 1;\n    return $n % 10;\n}", "    return 1 + $n if $n\
    \ > 9;\n    return 1 + $n if $n > 9;\n    my $count = 0;\n    for my $i (1..$n)\
    \ {\n        last if $i ~~ [11, 1];\n        $count += 1 if $i ~~ [1, 10];\n \
    \   }\n    $count;\n}", "    my %nums;\n    my(@numbers);", "    \n    my @digits\
    \ = ();\n    \n    for(my $i = 0; $i < $n; $i++) {\n        $digits[$i] = (0 ..\
    \ 9) if $i && ($i % 10);\n    }\n    \n    my $sum = 0;\n    foreach my $i ( @digits\
    \ ) {\n        if( $i eq 1 ) {\n            $sum += 1;\n        }\n    }\n   \
    \ \n    return $sum;\n}", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n\
    \    return $_ for (1 .. $n); # don't use $_ since it hides the global\n}", '    my
    $count = 0;', "    return 1 if $n < 10;\n    my $count = 0;\n    my $i = 1;\n\
    \    while ($n > 9) {\n        $count += $n =~ /1$i$i/;\n        ++$i;\n    }\n\
    \    return $count;\n}\n</code>\nTo avoid the use of global variables, you can\
    \ use Perl's standard library function bless() to create a reference:\n<code>\n\
    my($count) = ( $n =~ /1(?=1)|(?<=9)1/)[0] =~ /(\\d+)/;\n</code>\n<|/ a tags=perl,regex\
    \ dscore=3 |>\n<| a |>\nIf you're willing to use an external program to do the\
    \ work, sed is pretty fast for such things:\n<code>\n$ perl -E 'say \"foo\" =~\
    \ /foo/ ? \"yes\" : \"no\"' | sed -n 's/^.*\\no.*(yes).*\\$/\\1/p'\nyes\n</code>\n\
    <|/ a dscore=2 tags=perl,regex |>\n<| a dscore=2 |>\nFor this specific problem,\
    \ the shortest way to express it in perl is probably:\n<code>\nmy $count = ($string\
    \ =~ /^(?<=1|9).*$/)[0];\n</code>\nThis doesn't check for an odd number of 1s\
    \ in the string, it just checks for one or nine in the string. It also doesn't\
    \ use the counting constructs of regex, so it's also quicker.\nA slightly more\
    \ efficient version that checks for an odd number of 1s and uses a regex lookahead\
    \ would be:\n<code>\nmy $count = ($string =~ /(?=(?:.*\\1)*$)/g)[0];\n</code>\n\
    This uses a regex lookahead to make sure it finds at least one 1 anywhere in the\
    \ string, and so it does fewer matches to get it going. The regex above (and the\
    \ first regex above) will give a false positive for input like \"0011\", though,\
    \ so this one is more reliable:\n<code>\nmy $count = ($string =~ /(.)\\1{2,}/g)[0];\n\
    </code>\n<|/ a tags=perl,regex |>\n<| c |>\nYour second regex has a bug when tested\
    \ against \"0110\" (two 1's).  It matches \"011\" when it should match \"0110\"\
    .  I think the easiest fix is to change the regex to `/(.)\\1{2,}/g`.  You don't\
    \ need the captures.\n<|/ c |>\n<| a tags=perl,regex dscore=2 |>\nTo answer the\
    \ OP's original question:", "    my $count = 0;\n    while (0 < $n) {\n\t$count++\
    \ if $n == int $n/10; $n%=10;\n    }\n    return $count;\n}", '    $n = 0 unless
    defined $n;', "    return 0 if $n < 10;\n    return 1 if $n < 100;\n    return\
    \ 2 if $n < 1000;\n    return 3 if $n < 10000 || $n < 1000000000;\n    return\
    \ 4;\n}", "    my $count = 0;\n    for (my $i = $n; $i >= 1; $i -= 1) {\n    \
    \    if ($i eq 1) {\n            return $count;\n        }\n        $count++;\n\
    \    }\n    return $count;\n}", "    $n =~ tr/1-9/1-9/;\n    my $i = 1;\n    while\
    \ ($i <= $n) {\n        my $j = $n - $i;\n        if ($j != 0) {\n           \
    \ my $k = $j;\n            my $starts = 0;\n            my $ends = 0;\n      \
    \      while ($k < $j) {\n                $starts += 1 if ($k % 10 == 1);\n  \
    \              $ends += 1 if ($k % 10 == 9);\n                $k /= 10;\n    \
    \        }\n            ($starts, $ends)\n        } else {\n            (1, 0);\n\
    \        }\n        $i += $j;\n    }\n}", "    my $s = 0;\n    for (my $i = 1;\
    \ $i <= $n; $i++) {\n        if ($i or $n != $i) { $s += 1; }\n    }\n    return\
    \ $s;\n}", "    my $count = 0;\n    for (my $i = 0; $i <= $n; $i += 9) {\n\tmy\
    \ $check = ($i + 1) % 10;\n\tif ($check == 1) {\n\t    $count++;\n\t}\n    }\n\
    \    return $count;\n}", "    my ($a, $b) = (0, 0);\n    for (my $i = 1; $i <\
    \ $n; $i++) {\n\tif ($i or $n and ($n % $i == 0)) {\n\t    ($a == 0 and $b) =\
    \ ($i + 1, $i);\n\t    $a = ($a ? 0 : $a + $i);\n\t}\n    }\n    return $b;\n}",
  '    my(@res,$i);', "    return 0 if $n <= 1;\n    my $count = 0;\n    $n -= 1;\n\
    \    while($n >= 10) {\n        if($n % 10 == 1) {\n            $count += 1;\n\
    \        }\n        $n /= 10;\n    }\n    return $count;\n}", '    return 0 if
    !defined($n);', "    return 1 if $n == 1;\n    return 1 + $n * ($n + 1) / 2 if\
    \ $n =~ /^\\d/;\n    return 0;\n}", "    my $count = 0;\n    while (1) {\n   \
    \     my $i = 1;\n        while ($i <= $n) {\n            if ($i % 10 == 1) {\n\
    \                ++$count;\n                --$n;\n            } else {\n    \
    \            $i /= 10;\n            }\n        }\n        if ($n == 0) {\n   \
    \         return $count;\n        }\n        --$n;\n    }\n}\n</code>\nHere is\
    \ a program that implements the problem in Perl:\n<code>\nuse strict;\nuse warnings;",
  "    return 0 if $n < 10;\n    my $count = 0;\n    $count += 1 if $n =~ /^1/;\n\
    \    $count += 1 if $n =~ /^1/;\n    return $count;\n}", '    my(@counts);', " \
    \   my $count = 0;\n    for (1 .. $n) {\n        if ( ($n % 10) == 1) {\n    \
    \        $count++;\n        }\n        else {\n            $count--;\n       \
    \ }\n    }\n    return $count;\n}", "    return 0 if ($n == 0);\n    my(@counts)\
    \ = (0);\n    my($end) = (0);\n    my($count) = (0);\n    my($start) = (0);",
  "    $n -= 0;\n    my $count = 0;\n    for (0 .. $n) {\n        my $num = ($_ **\
    \ $n);\n        if ($num % 10 == 0) {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my $i = $n;\n    until ($i eq\
    \ 1) {\n        if ($i =~ /^(1(0|[1-9][0-9])|[1-9][0-9]*)$/) {\n            $count++;\n\
    \        }\n        $i++;\n    }\n    return $count;\n}", '    my($count) = @_;',
  "    my(@list);\n    if (! $n) { \n\treturn 0;\n    } elsif ($n < 0) {\n\treturn;\n\
    \    }\n    for ($n; $n > 0; $n--) {\n\tpush(@list, 1);\n\tpush(@list, -1);\n\
    \    }\n    my @counts = ();\n    for ($n = 9; $n >= 0; $n--) {\n\tpush(@counts,\
    \ scalar(grep { $_ % $n == 0 } @list));\n    }\n    return scalar(@counts);\n}",
  "    my(@s) = ();\n    my($i,$x);\n    \n    # Find all n-digit positive integers\
    \ that start or end with 1.\n    for ($i = $n; $i >= 0; $i--) {\n        $x =\
    \ ($i%$n);\n        $x = $x ? $x + 1 : 1;\n        push(@s,$x);\n    }\n    return\
    \ scalar @s;\n}", '    return $n if $n < 1;', "    my $start = 0;\n    my $end\
    \ = 0;", '    my($sum);', "    $n += 0;\n    my @digits = ();\n    my $i;\n  \
    \  for (my $i = $n; $i >= 0; $i /= 10) {\n\tpush(@digits, $i % 10);\n    }\n \
    \   my $count = scalar(grep { substr($_, 0) eq '1' } @digits);\n    return $count;\n\
    }", '    my $count = 0;', '    my($i, $starts) = 0;', "    my $count = 0;\n  \
    \  while (1) {\n        ++$count while $n and ($_ % 10 == 1);\n        ++$n if\
    \ ($n <= 0);\n        $n == 1 || (--$n) if ($n == 0);\n    }\n    return $count;\n\
    }", "    my($i, $digit, $count_from_one, $count_from_zero, $remainder);\n    $count_from_one\
    \ = 0;\n    $count_from_zero = 0;", "    return $n if ($n < 10);\n    if ($n <=\
    \ 10) {\n        return 0;\n    }\n    my($remainder);\n    for ($n; $n > 0; $n\
    \ /= 10) {\n        $remainder = $n % 10;\n        return $n if ($remainder ==\
    \ 1);\n    }\n    return $n-1;\n}", "    return 1 if $n == 1;\n    return $n if\
    \ $n == 0 || ($n <= 1 && $n == -1);\n    my(@nums) = (0, 1);\n    my($i, $j);\n\
    \    $j = 1;\n    for ($i = 0; $i < $n; $i++) {\n        my($tmp) = substr($nums[$i-1],\
    \ 0, 1);\n        my($tmp2) = substr($nums[$i], 0, 1);\n        if ($tmp == $tmp2)\
    \ {\n            push(@nums, $j);\n            $j++;\n        }\n    }\n    return\
    \ @nums;\n}", '    my($count_starts_ends);', "    return $n if $n < 1;\n    return\
    \ 1 if $n == 1;\n    my($i, $sum);\n    $sum = 0;\n    $i = 0;\n    while($i++\
    \ < $n) {\n        $sum += $i++ == 1;\n    }\n    return $sum;\n}", '    return
    1 if $n == 0;', "    my $count = 1;\n    while ($n) {\n        ++$count;\n   \
    \     $n = ($n % 10) == 1;\n    }\n    return $count;\n}", "    my $result = 1;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        next if $_ % 10 eq 0;\n      \
    \  $result++;\n    }\n    return $result;\n}", "    return 1 if ($n == 0);\n \
    \   return 0 if ($n == 1);\n    return ((&starts_one_ends($n - 1)) + 1) / $n;\n\
    }\n</code>\nAnd now you can make your code simpler and easier to understand:\n\
    <code>", "    return 0 unless $n;\n    $n += 0;  # Bare minus sign is just wrong.\n\
    \    return 0 unless $n > 0;\n    return 0 unless $n =~ /^[1-9][0-9]*$/;\n   \
    \ # One or more digits.\n    return $n if $n = '0';\n    # Not sure why this works;\
    \ but all it does is test the digits in the first\n    # number.  We could simplify\
    \ to say $n =~ /^(1|[1-9][0-9]*)$/; but\n    # I suspect this doesn't work on\
    \ some architectures.\n    $n =~ /^1(1|[1-9][0-9]*)$/;\n    # Two or more digits.\n\
    \    return 1 unless $1 eq '1';\n    # No digits.\n    return $n if $n = '0';\n\
    \    return $n if $n = '1';\n    # More than one digit starting with 1.\n    return\
    \ 1 + 1 + $n;\n}", "    return 1 if $n == 1;\n    return $n+starts_one_ends( $n+1\
    \ ) if $n%2 == 0;\n    return 0;\n}", "    my $ret = 0;\n    for my $i (1 .. $n)\
    \ {\n        if ($i && $i eq $i+1) {\n            $ret++;\n        }\n    }\n\
    \    return $ret;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis answer works but\
    \ is quite inefficient, and involves many subroutines.\n<|/ c |>\n<| a tags=perl,algorithm\
    \ |>\nHere is an algorithm that seems to work well in practice:\n<code>", "  \
    \  return 1 unless $n;\n    return $n if $n eq 1;\n    return 0 if $n % 10 ==\
    \ 1;\n    my(@ones);\n    for(; $n > 0; $n /= 10) {\n        push(@ones, $n %\
    \ 10) if $n % 10 == 1;\n    }\n    @ones == 1 ? @ones : @ones[0..@ones-1];\n}",
  "    \n    # Count how many times each number starts with 1 or ends with 1\n   \
    \ # starting at 1\n    my %ones;\n    for($n; $n <= 9; $n++) {\n        if( ($n\
    \ % 10) == 1) {\n            ++$ones{$n};\n        }\n    }", "    return 0 if\
    \ $n <= 0;\n    return 0 if $n == 1;\n    return $n->{end} - $n->{start} - 1;\n\
    }", "    return 1 if $n == 0;\n    return 1 if $n == 1;\n    $n -= 1;\n    $n\
    \ *= 10;\n    my @count;\n    while (1) {\n        push (@count, intdiv($n, 10));\n\
    \        $n = $n / 10;\n        $n = 1 if $n == 0;\n        last if $n > 0;\n\
    \    }\n    return @count;\n}", "    my $count = 0;\n    my $i = 0;\n    while($i\
    \ <= $n) {\n        if($i%10 == 1)\n        {\n            $count++;\n       \
    \ }\n        $i++;\n    }\n    return $count;\n}", "    my($count, $i, $digit);\n\
    \    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $digit = substr($n,\
    \ $i, 1);\n        if ($digit eq '1') {\n            $count++;\n        }\n  \
    \  }\n    return $count;\n}", "    my $count = 0;\n    for ($n =~ /^1?$n/i) {\n\
    \        $count++;\n    }\n    return $count;\n}", "    my $count = 0;\n    my\
    \ $i = 1;\n    while ($n >= $i) {\n        if ($n % $i == 0) {\n            $count\
    \ += 1;\n            $i ++;\n        }\n        else {\n            $i ++;\n \
    \       }\n    }\n    return $count;\n}", "    my(@digits) = ();\n    my($count)\
    \ = -1;\n    my($start) = 0;", "    if ( $n < 0 ) {\n        die \"starts_one_ends\
    \ called with negative n: $n\";\n    }", "    my $count = 0;\n    while ($n !=\
    \ 1) {\n        $n -= $n / 10;\n        $count++;\n    }\n    return $count;\n\
    }", '    my($one) = 1;', "    my $count;\n    $count = 0; while ($n != 1) {\n\t\
    $n -= 1;\n\t$count++\n    };\n    return $count;\n}", "    my @count = ();\n \
    \   my $maxdigit = (10 ** ($n + 1))/10;\n    for my $i (1 .. $maxdigit) {\n  \
    \      if ($i or $i % 10) {\n            push @count, $i;\n        }\n    }\n\
    \    return @count;\n}", "    if ($n < 1) {\n        die \"starts_one_ends(\\\
    $n)\";\n    }", '    my $digits = 0;', '    return $n if $n < 10;', '    my $count
    = 0;', "    my $count = 0;\n    my @list = ();\n    while($n > 1){\n        my\
    \ $next_n = int($n/10);\n        if($next_n == 1){\n            $count++;\n  \
    \      }\n        elsif($next_n != $n){\n            push(@list, $next_n);\n \
    \       }\n        $n--;\n    }\n    return $count;\n}", '    my($count) = 0;',
  "    return 0 unless $n;\n    my $count = 1;\n    while ($n % 10 == 1) {\n     \
    \   $count++;\n        $n /= 10;\n    }\n    return $count;\n}", '    return 1
    if $n == 0;', "    if ($n <= 0)\n    {\n        die \"Negative number.\";\n  \
    \  }", "    # Initialize $res to 0\n    my($res);\n    # Write an O(N) solution;\
    \ O(N) because we only have to check the\n    # first digit.\n    for (my $i =\
    \ 1; $i <= $n; $i++) {\n        my $count = 0;\n        if ($i % 10) {\n     \
    \       $count += 1 if $i eq 1;\n        }\n        elsif ($i =~ /^1/) {\n   \
    \         $count += 1 if $i eq 0;\n        }\n        # $res stores the count\n\
    \        $res = $count if $res;\n    }\n    return $res;\n}", "    return 1 if\
    \ $n <= 0;\n    return 1 if $n <= 9;\n    return 1 if $n <= 99;\n    return 1\
    \ if $n <= 199;\n    return 1 if $n <= 999; # ...\n    return 1 if $n <= 1999;\
    \ # ...\n    return 1 if $n <= 1999; # ...\n    return 1 if $n <= 3999; # ...\n\
    \    return 1 if $n <= 3999; # ...\n    return 1 if $n <= 9999; # ...\n    return\
    \ 1;\n}", "    $n += 2;\n    $n -= 1;\n    my $count = 0;\n    while($n >= 10)\
    \ {\n        if($n == 1) {\n            $count++;\n            $n--;\n       \
    \ }\n        elsif($n != 0) {\n            $n /= 10;\n        }\n        else\
    \ {\n            return $count;\n        }\n    }\n    return $count;\n}", " \
    \   my $count = 0;\n    for (1 .. $n) {\n        my $start = rand $n;\n      \
    \  my $stop  = rand $n;\n        last if $start == $stop;\n        if ($start\
    \ == 1 and $stop == $n) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}\n</code>\nSome sample runs:\n<code>\n$ perl -le'print (starts_one_ends(9))'\n\
    3\n$ perl -le'print (starts_one_ends(10))'\n5\n$ perl -le'print (starts_one_ends(11))'\n\
    2\n</code>\n<|/ a dscore=0 |>\n<| a tags=perl,random,math,distribution dscore=0\
    \ |>\nA mathematical solution has some advantages: it also guarantees that there\
    \ is at least one \"one\" and that the algorithm is correct.  In particular, the\
    \ algorithm guarantees that there is at least one \"one\" when there is any chance\
    \ that there will be \"zero\", so there is no need for a \"special case\" for\
    \ 0.\nThis solution does not guarantee that there will be at least one \"one\"\
    \ in the range.\n<code>", "    my $count = 0;\n    for (my $i = 1; $i <= $n; $i++)\
    \ {\n\tif ($i ^ 1) { $count++ }\n\telsif ($i ^ 0) { $count--; }\n    }\n    return\
    \ $count;\n}", "    if ($n < 0) {\n\t$n = abs($n);\n\t$n = \"$n\" x abs($n) unless\
    \ defined $n;\n    } else {\n\t$n = \"$n\" x $n;\n    }\n    $n =~ s/^\\./1/;\n\
    \    $n =~ s/\\z/0/;\n    my $count = 0;\n    for (my $i = 0; $i <= $#_; $i++)\
    \ {\n\t$count += $_[$i] == $n;\n    }\n    return $count;\n}", "    my($count,\
    \ $start_count, $end_count);\n    \n    $start_count = 0;\n    $end_count = 0;",
  "    my $count = 0;\n    my $i   = 0;\n    my $len = 0;\n    while ($i < $n) {\n\
    \        if ($n % $i == 0) {\n            ++$count;\n        }\n        ++$i;\n\
    \    }\n    $len = $i;\n    while ($len != 0) {\n        if ($n % $len == 0) {\n\
    \            ++$count;\n        }\n        --$len;\n    }\n    return $count;\n\
    }", "    my ($count) = (-1);\n    while($n > 0){\n        $count++ if $n & 1;\n\
    \        $n = $n / 2;\n    }\n    return $count;\n}", "    my($sum) = 0;\n   \
    \ my($remainder) = 0;\n    my($temp) = int $n;\n    my($flag);", '    my $count
    = 0;', "    my $ones = 0;\n    my $count = 0;\n    while ($n > 0) {\n        $ones\
    \ += $n % 10;\n        $count++;\n        $n = ($n - $ones) / 10;\n    }\n   \
    \ return $count;\n}", "    return 0 if $n <= 0;\n    return scalar reverse grep\
    \ { $_ % 100 == $n % 100 } 1 .. $n;\n}", "    my($n);\n    if ($n < 10) { $n =\
    \ \"0$n\"; }", '    my($count) = 0;', "    return 0 if $n < 0;\n    return ($n\
    \ < 10) ? 1 : sub {\n        my($count) = @_;\n        $count++ while $n >= 10;\n\
    \        return $count;\n    }->(++$n);\n}", '    $n += 0;', "    my $count =\
    \ 0;\n    while($n < 10) {\n\tmy $s = 10*($n%10) + $n;\n\t$count += 1 if $s &\
    \ 1 == 1;\n\t$n = $s/10;\n    }\n    return $count;\n}", '    my($count);', '    my
    $count = 0;', "    return 0 if $n <= 0;\n    return 1 if $n == 1;\n    return\
    \ ((($n % 10) == 1) ? ($n) : ($n + 1));\n}", '    my(@result);', "    return 1\
    \ if ($n == 0);\n    my($i, $j);\n    my $count = 1;\n    for ($i = 1; $i <= $n;\
    \ $i++) {\n        $j = 1;\n        while ($i & $j) {\n            $j += 1;\n\
    \        }\n        if ($i == 1 && $j > 1) {\n            $count++;\n        }\n\
    \        if ($i == $n) {\n            $j = 1;\n            while (--$i) {\n  \
    \              ++$j;\n            }\n            if ($j > 1) {\n             \
    \   $count++;\n            }\n        }\n    }\n    return $count;\n}", "    return\
    \ 0 if $n < 10;\n    return 0 if $n % 10;\n    return 0 if $n % 100 != 11;\n \
    \   return 0 if $n % 100 == 11;\n    return 1 if $n % 100 == 13 or $n % 100 ==\
    \ 15;\n    return 0 if $n % 1000 == 55;\n    return 0 if $n % 1000 == 75;\n  \
    \  return 0 if $n % 1000 == 85;\n    return 0 if $n % 1000 == 99;\n    return\
    \ 0 if $n % 1000 == 111;\n    return 0 if $n % 1000 == 123;\n    return 0 if $n\
    \ % 1000 == 135;\n    return 0 if $n % 1000 == 157;\n    return 0 if $n % 1000\
    \ == 179;\n    return 0 if $n % 1000 == 199;\n    return 0 if $n % 1000 == 211;\n\
    \    return 0 if $n % 1000 == 231;\n    return 0 if $n % 1000 == 243;\n    return\
    \ 0 if $n % 1000 == 257;\n    return 0 if $n % 1000 == 273;\n    return 0 if $n\
    \ % 1000 == 287;\n    return 0 if $n % 1000 == 307;\n    return 0 if $n % 1000\
    \ == 337;\n    return 0 if $n % 1000 == 359;\n    return 0 if $n % 1000 == 371;\n\
    \    return 0 if $n % 1000 == 393;\n    return 0 if $n % 1000 == 409;\n    return\
    \ 0 if $n % 1000 == 429;\n    return 0 if $n % 1000 == 463;\n    return 0 if $n\
    \ % 1000 == 487;\n    return 0 if $n % 1000 == 509;\n    return 0 if $n % 1000\
    \ == 529;\n    return 0 if $n % 1000 == 555;\n    return 0 if $n % 1000 == 579;\n\
    \    return 0 if $n % 1000 == 593;\n    return 0 if $n % 1000 == 619;\n    return\
    \ 0 if $n % 1000 == 655;\n    return 0 if $n % 1000 == 691;\n    return 0 if $n\
    \ % 1000 == 709;\n    return 0 if $n % 1000 == 737;\n    return 0 if $n % 1000\
    \ == 767;\n    return 0 if $n % 1000 == 793;\n    return 0 if $n % 1000 == 819;\n\
    \    return 0 if $n % 1000 == 839;\n    return 0 if $n % 1000 == 859;\n    return\
    \ 0 if $n % 1000 == 889;\n    return 0 if $n % 1000 == 909;\n    return 0 if $n\
    \ % 1000 == 937;\n    return 0 if $n % 1000 == 961;\n    return 0 if $n % 1000\
    \ == 973;\n    return 0 if $n % 1000 == 985;\n    return 0 if $n % 1000 == 999;\n\
    \    return 0 if $n % 1000 == 1023;\n    return 0 if $n % 1000 == 1039;\n    return\
    \ 0 if $n % 1000 == 1059;\n    return 0 if $n % 1000 == 1091;\n    return 0 if\
    \ $n % 1000 == 1113;\n    return 0 if $n % 1000 == 11", "    if ( $n < 0 ) {\n\
    \treturn 0;\n    }\n    if ( $n <= 1 ) {\n\treturn 1;\n    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
