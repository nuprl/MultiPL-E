name: HumanEval_17_parse_music
language: pl
prompt: "# Input to this function is a string representing musical notes in a special\
  \ ASCII format.\n# Your task is to parse this string and return array of integers\
  \ corresponding to how many beats does each\n# not last.\n# Here is a legend:\n\
  # 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts two beats\n# '.|'\
  \ - quater note, lasts one beat\n# >>> parse_music(\"o o| .| o| o| .| .| .| .| o\
  \ o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nsub parse_music {\n    my($music_string)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_music;\n\
  \        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o o o o\"),[4,\
  \ 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(\".| .| .| .|\"),[1, 1, 1, 1])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o|\
  \ o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o| .| o| .| o o|\
  \ o o|\"),[2, 1, 2, 1, 4, 2, 4, 2])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(@music_arr) = ();\n    my($num_beats) = 0;\n    my($current_num_beats)\
    \ = 0;\n    my($note_char, $next_char);", "    my(@beats) = [];\n    my($music_string_index)\
    \ = -1;\n    my($note) = \"\";\n    my($number_of_beats);\n    my($number_of_quarters);",
  '    my @parsed_music = ();', '    my @notes = ();', "    my @results;\n    my $current_beat\
    \ = 0;\n    my $current_note = 0;\n    my $last_note_beat = 0;", "    my @music\
    \ = split /[|.]\\z/,$music_string;\n    my %map;\n    for (my $i=0; $i<@music;\
    \ $i+=3) {\n        $map[$music[$i]] ||= 0;\n        $map[$music[$i+1]] ||= 0;\n\
    \        $map[$music[$i+2]] ||= 0;\n    }\n    return map {$_*3} sort keys %map;\n\
    }", "    my(@notes);\n    my($current_note);\n    my($current_beat);\n    my($last_beat);\n\
    \    my($current_measure);\n    my($max_notes_in_chord);", "    my($beats) = 0;\n\
    \    my($note) = ();\n    my($notes) = ();", "    my(@output_array);\n    my $note_lengths\
    \ = decode_music_string($music_string);\n    foreach my $note_length (@$note_lengths)\
    \ {\n        my $number_of_beats = floor(($note_length / 4) + 1);\n        push\
    \ @output_array, $number_of_beats;\n    }\n    return @output_array;\n}", "  \
    \  my($music_array);\n    \n    chomp($music_string);\n    \n    $music_array\
    \ = ();\n    \n    foreach my $note (split / /, $music_string) {\n        my @note_arr\
    \ = ();\n        \n        if ($note =~ /o|/) {\n            $note_arr[0] = 4;\n\
    \        }\n        else {\n            my ($beat) = $note =~ /([0-9])$/;\n  \
    \          $note_arr[0] = $beat;\n        }\n        \n        push @note_arr,\
    \ $note_arr[0] + 4;\n        \n        if ($note =~ /o|/) {\n            $note_arr[1]\
    \ = 2;\n        }\n        else {\n            my ($beat) = $note =~ /([0-9])$/;\n\
    \            $note_arr[1] = $beat;\n        }\n        \n        push @note_arr,\
    \ $note_arr[1] + 2;\n        \n        if ($note =~ /\\.|/) {\n            $note_arr[2]\
    \ = 1;\n        }\n        else {\n            $note_arr[2] = 0;\n        }\n\
    \        \n        push @note_arr, $note_arr[2] + 1;\n        \n        push @{$music_array},\
    \ @note_arr;\n    }\n    \n    return $music_array;\n}", '    my(@notes);', " \
    \   my(@music_list) = ();\n    my($current_beat) = 0;\n    my($current_note) =\
    \ 0;\n    my($current_duration) = 0;\n    my($current_octave) = 0;\n    my($current_note)\
    \ = 0;\n    my($note_duration) = 0;", "    my @result;\n    my $current_beat =\
    \ 1;\n    my $current_note = 0;\n    my $current_symbol = 0;\n    my $note_symbol\
    \ = 0;", "    my($music) = ($music_string =~ /^([oO][|.])/g);\n    my($beats)\
    \ = ($music =~ /[oO][|.]/g);\n    $beats =~ s/[oO][|.]/|/g;\n    return $beats;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for taking the time to provide a detailed\
    \ solution. I'll be trying it out and seeing if it works for me. Also, thanks\
    \ for providing a detailed description of the problem.\n<|/ c |>\n<| a tags=regex,perl\
    \ dscore=1 |>\nThe regex you are looking for is this:\n<code>\n(?:([.]|[.][.])([oO]|[oO])([.]|[.][.])|([oO]|[oO][.])([.]|[.][.])([oO]|[oO])([.]|[.][.])|([oO]|[oO][.])([.]|[.][.])([oO]|[oO])|([.]|[.][.])([oO]|[oO][.]))\n\
    </code>\nSee it here at Regexr\nI added some parenthesis, because I believe that\
    \ if you add them you also end up matching your inputs ( which I don't think you\
    \ want )\nThis regex is slightly more general than the ones above ( I think it\
    \ also works on the examples you provided ), because you can define more or less\
    \ beats ( maybe like octave or half note or half quater notes ).\nAlso, this regex\
    \ will match \"..\" as well as a full note.\n<|/ a |>\n<| c |>\nThank you for\
    \ taking the time to provide a detailed solution. I'll be trying it out and seeing\
    \ if it works for me. Also, thanks for providing a detailed description of the\
    \ problem.\n<|/ c |>\n<| a dscore=1 |>\nThe solution below will work for any number\
    \ of dots and dashes on the input line. It looks for the longest possible sequences\
    \ of dots and dashes, and then counts how many dots and dashes each note lasts.\
    \ \nI didn't check against your example, but it seems to do what I think you want\
    \ it to. \n<code>\nuse strict;\nuse warnings;\nuse Data::Dumper;", "    my @notes\
    \ = ();\n    $music_string =~ s/\\s*$//g;\n    $music_string =~ s/^\\s*|\\s*$//g;",
  "    my @music;\n    my $current_note = 0;\n    my $current_beat_length = 0;\n \
    \   my $note_length = 0;\n    foreach my $char (split(//, $music_string)) {\n\
    \        if ($char eq \"o\") {\n            $current_note = $current_note + 1;\n\
    \            $current_beat_length = 0;\n        }\n        if ($char eq \"|\"\
    ) {\n            $current_beat_length = $current_beat_length + 4;\n        }\n\
    \        if ($char eq \".\") {\n            $current_beat_length = $current_beat_length\
    \ + 1;\n        }\n        if ($char eq \".\") {\n            $note_length = $note_length\
    \ + $current_beat_length;\n            push(@music, $note_length);\n         \
    \   $current_note = $current_note + 1;\n            $current_beat_length = 0;\n\
    \            $note_length = 0;\n        }\n        if ($char eq \"o\") {\n   \
    \         $note_length = $note_length + $current_beat_length;\n            push(@music,\
    \ $note_length);\n            $current_note = $current_note + 1;\n           \
    \ $current_beat_length = 0;\n            $note_length = 0;\n        }\n    }\n\
    \    push(@music, $note_length);\n    return @music;\n}", "    my;\n    my $notes\
    \ = split(//, $music_string);\n    my $current_beat = 0;\n    my $current_note\
    \ = 0;\n    my $previous_note = 0;\n    my $last_beat = 0;", "    my @notes =\
    \ ();\n    $music_string =~ s/\\R//g;\n    foreach my $note (split //, $music_string)\
    \ {\n        if ($note eq '.') {\n            push(@notes, 4);\n        }\n  \
    \      elsif ($note eq 'o') {\n            push(@notes, 1);\n        }\n     \
    \   elsif ($note eq 'o|') {\n            push(@notes, 2);\n        }\n       \
    \ else {\n            die \"Unknown note $note\";\n        }\n    }\n    return\
    \ @notes;\n}\n</code>\n<|/ a tags=perl |>\n<| a dscore=0 |>\nHere's a solution\
    \ that uses a bit of recursion.  The first subroutine just parses the input string\
    \ into an array of notes.  It then recurses on the array to determine what kind\
    \ of note it is.  It then passes the notes back into the function as a reference,\
    \ which then prints the array.\nThe second subroutine is where you write the print\
    \ function.  I've added the line lengths to keep it consistent.\n<code>\nuse strict;\n\
    use warnings;", "    my(@beats) = ();\n    my($note_beat_counter) = 0;", "   \
    \ my($beats_per_note) = @beats_per_note;\n    my(@notes) = ();\n    my($last_note);\n\
    \    my($note_count);\n    my($note_string);\n    my($beats_count) = 0;\n    for($i=0;\
    \ $i<length($music_string); $i++) {\n        my $music_char = substr($music_string,\
    \ $i, 1);\n        if($music_char=~/^(\\?|\\.|\\+|\\-)\\z/) {\n            $note_string\
    \ = \"\";\n            for(my $i=0; $i<$#beats_per_note; $i++) {\n           \
    \     my $beats_per_note = shift(@beats_per_note);\n                my $note =\
    \ \"$music_char\";\n                for(my $k=0; $k<$beats_per_note; $k++) {\n\
    \                    $note .= $note_string;\n                    if($k>0) {\n\
    \                        $note .= \"|\";\n                    }\n            \
    \    }\n                if($i>0) {\n                    $note .= \"|\";\n    \
    \            }\n                $note .= $music_char;\n                push(@notes,\
    \ $note);\n                last;\n            }\n            $note_count = length($note_string);\n\
    \            $last_note = $notes[$note_count-1];\n            $note_count++;\n\
    \            $note_string = \"\";\n        } else {\n            $note_string\
    \ .= $music_char;\n            if($note_count == 0) {\n                $note_count++;\n\
    \            } elsif($note_count > 1) {\n                $note_count++;\n    \
    \        }\n        }\n    }\n    return \\@notes;\n}", '    my($return) = ();',
  "    chomp $music_string;\n    $music_string =~ tr/+/ /;", "    my;\n    # parse\
    \ the input string, looking for \"o\"\n    my($beat) = 0;\n    while(my $char\
    \ = substr($music_string, $beat, 1)) {\n        last if $char eq 'o';\n      \
    \  push(@beats, $beat) if $char eq '|';\n        $beat += 1;\n    }\n    return\
    \ @beats;\n}", "    my($note) = '';\n    my($num_beats) = 0;\n    my($last_beat)\
    \ = 0;\n    my($count) = 0;", '    my(@beats) = ();', "    my($music_array) =\
    \ [];\n    my($note) = \"\";\n    my($beat) = 0;\n    my($note_count) = 0;\n \
    \   my($note_count2) = 0;\n    my($last_note) = \"\";\n    my($last_beat) = 0;\n\
    \    my($last_note_count) = 0;\n    my($last_note_count2) = 0;\n    my($last_note_len)\
    \ = 0;", "    my(@music_array);\n    my($notes = '');\n    my($notes_length =\
    \ 4);\n    my($note_length = 'o|');\n    my($last_note = 'o');", '    my($music_array);',
  "    my $count = 1;\n    my $notes = \"\";\n    foreach my $char (split(//, $music_string))\
    \ {\n        if ($char eq \"o\") {\n            $notes .= $count;\n          \
    \  $count = 1;\n        } elsif ($char eq \"|\") {\n            $notes .= $count;\n\
    \            $count = 2;\n        } elsif ($char eq \".\") {\n            $notes\
    \ .= $count;\n            $count = 1;\n        }\n    }\n    return $notes;\n}",
  "    my @notes = ();\n    my $music = $music_string;\n    my $offset = 0;\n    my\
    \ $note_length = length($music);\n    my $note_length_count = 0;\n    my $beats_per_note\
    \ = 1.4;\n    my $beats_remain = 0;", "    my @music_array = ();\n    my @note_beat_counter;\n\
    \    my ($note, $current_beat, $current_note);\n    my $last_note = \"\";\n  \
    \  my $last_beat = \"\";", "    my @notes = ();\n    my($beat, $step, $note) =\
    \ 0;\n    my $last_char = 0;\n    foreach $char (split('', $music_string)) {\n\
    \        if ($char eq '.') {\n            if ($last_char eq '|') {\n         \
    \       $notes[$note] .= '.';\n                $note++;\n            }\n     \
    \       else {\n                push @notes, $note if $note > 0;\n           \
    \     $note = 1;\n            }\n        }\n        elsif ($char eq 'o') {\n \
    \           $notes[$note] .= '.';\n        }\n        elsif ($char eq '|') {\n\
    \            $notes[$note] .= '|';\n        }\n        else {\n            push\
    \ @notes, $note if $note > 0;\n            $note = 1;\n        }\n        $last_char\
    \ = $char;\n    }\n    push @notes, $note if $note > 0;\n    return @notes;\n}",
  '    my($counts);', '    my(@num_beats) = ();', "    my($music_array);\n    my($music_str);\n\
    \    my($first_letter);\n    my($is_first_letter);\n    my($is_last_letter);\n\
    \    my($note_count);\n    my($note);", "    my @notes = ();\n    $music_string\
    \ =~ s/\\s+//g;\n    \n    my $current_note = 0;\n    my $total_notes = 0;\n \
    \   my $last_note = 0;\n    my $current_beat = 0;\n    my $current_time = 0;\n\
    \    my $note_length = 0;\n    my $note_width = 0;\n    my $total_beats = 0;\n\
    \    my $notes_array;\n    \n    while($music_string =~ /(.)(?=(#|$))/g) {\n \
    \       my $note = $1;\n        $note =~ s/\\s+//g;\n        \n        if($note\
    \ eq '#') {\n            $total_notes++;\n            $notes_array .= $current_note;\n\
    \            $note_length = 1;\n            $note_width = 4;\n            $current_note\
    \ = 0;\n            $total_beats++;\n            $current_time = 0;\n        }\
    \ elsif($note eq 'o') {\n            $total_notes++;\n            $notes_array\
    \ .= $current_note;\n            $note_length = 2;\n            $note_width =\
    \ 4;\n            $current_note = 0;\n            $total_beats++;\n          \
    \  $current_time = 0;\n        } elsif($note eq '|') {\n            $total_notes++;\n\
    \            $notes_array .= $current_note;\n            $note_length = 1;\n \
    \           $note_width = 2;\n            $current_note = 0;\n            $total_beats++;\n\
    \            $current_time = 0;\n        } elsif($note eq '.') {\n           \
    \ $total_notes++;\n            $notes_array .= $current_note;\n            $note_length\
    \ = 1;\n            $note_width = 1;\n            $current_note = 0;\n       \
    \     $total_beats++;\n            $current_time = 0;\n        } elsif($note eq\
    \ '[') {\n            $note_length = 2;\n            $note_width = 2;\n      \
    \  } elsif($note eq ']') {\n            $note_length = 1;\n            $note_width\
    \ = 1;\n        } elsif($note eq '?') {\n            $note_length = 2;\n     \
    \       $note_width = 2;\n            $total_beats = $total_notes;\n         \
    \   $notes_array .= $current_note;\n            $current_time = 0;\n         \
    \   $current_note = 0;\n            $total_notes = 0;\n            $note_width\
    \ = 0;\n            $current_beat++;\n        }\n        \n        $current_note++;\n\
    \    }\n    \n    push @notes, $total_notes;\n    push @notes, $current_beat;\n\
    \    \n    for(my $i = 0; $i < $total_notes; $i++) {\n        my $note = $notes_array[$i];\n\
    \        \n        if($note == 0) {\n            my $total_beats = $notes_array[$i+1];\n\
    \            if($", '    my(@parsed_music) = ();', "    my(@music) = ();\n   \
    \ my ($beat_number, $note) = (0,0);\n    chomp($music_string);\n    foreach my\
    \ $char (split //, $music_string) {\n        my $note_type = $char =~ /^\\./;\
    \ # Odd notes begin with '.', even ones with '|'.\n        my $note_amount = $char\
    \ =~ /^\\|/ ? 2 : 1;\n        next if $note_amount < 1 || $note_amount > 4; #\
    \ Must be 1 to 4.\n        push @music, $note_amount;\n        my $beat = 4 if\
    \ $note_type eq '.'; # If the note is a '.' then it lasts 4 beats.\n        $beat_number\
    \ = $beat_number + ($beat - 1) * $note_amount;\n    }\n    return @music;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nIt might be worth explaining the algorithm\
    \ for those who aren't quite sure of it.\n<|/ c |>\n<| a tags=perl,algorithm dscore=3\
    \ |>\nTo answer the question as posed:\n<code>\nuse List::Util qw( sum );", '    my($music_array);',
  "    my($notes) = ();\n    my($beat_count) = 0;\n    my($note_length) = 0;", " \
    \   my;\n    my $previous_note = \"\";\n    my $note = \"\";\n    my $beats =\
    \ 0;\n    my $prev_beat = 0;\n    my $prev_note = \"\";", "    $music_string =~\
    \ s/^\\s*//;\n    my @music = ();\n    my @next_note;\n    my @last_note;\n  \
    \  my $i = 0;\n    my $note_length = 0;\n    my $cur_note = 0;", "    my($parsed_music)\
    \ = [];\n    my($beats_array) = [];\n    my($note) = [0];", '    my(@returned_values)
    = ();', "    my($music_string) = $music_string =~ /\\s+/;\n    my($music_string)\
    \ = $music_string =~ /(.*)(\\|.*)$/;\n    my(@music) = split //, $music_string;\n\
    \    my($beat_count_array = [0]);\n    my($beat_count) = 0;\n    my($note_count_array)\
    \ = ();\n    foreach my $note (@music) {\n        chomp($note);\n        next\
    \ if ($note =~ /^\\s*$/);\n        my $note_letter = $note[0];\n        if ($note_letter\
    \ = 'o' || $note_letter = 'O') {\n            ++$beat_count_array[$beat_count];\n\
    \            ++$note_count_array[$beat_count];\n        }\n        elsif ($note_letter\
    \ = '|') {\n            ++$beat_count_array[$beat_count];\n        }\n       \
    \ elsif ($note_letter = '.') {\n            ++$beat_count_array[$beat_count];\n\
    \        }\n        ++$beat_count;\n    }\n    my($beat_count_array) = @_;\n \
    \   my($beat_count) = 0;\n    my($note_count_array) = @_;\n    foreach my $note\
    \ (@music) {\n        chomp($note);\n        next if ($note =~ /^\\s*$/);\n  \
    \      my $note_letter = $note[0];\n        if ($note_letter = 'o' || $note_letter\
    \ = 'O') {\n            ++$beat_count_array[$beat_count];\n            ++$note_count_array[$beat_count];\n\
    \        }\n        elsif ($note_letter = '|') {\n            ++$beat_count_array[$beat_count];\n\
    \        }\n        elsif ($note_letter = '.') {\n            ++$beat_count_array[$beat_count];\n\
    \        }\n        ++$beat_count;\n    }\n    return ($beat_count_array, $note_count_array);\n\
    }", "    my(@music) = ();\n    my($index) = -1;\n    my($last_note);\n    while($index++\
    \ < length($music_string)) {\n        chomp($music_string[$index]);\n        if($music_string[$index]\
    \ eq \"|\") {\n            push(@music, 1);\n        } elsif($music_string[$index]\
    \ eq \"o\") {\n            push(@music, 4);\n        } else {\n            push(@music,\
    \ 0);\n        }\n    }\n    $music_string;\n}", "    my(@notes) = ();\n    my($note)\
    \ = 0;\n    my($beat_count) = 0;\n    my($rest) = 0;\n    foreach my $char (split(//,\
    \ $music_string)) {\n        if ($char=~m/^[\\.|o]$/) {\n            if ($note)\
    \ {\n                $notes->[$note] = $beat_count;\n                $note = 0;\n\
    \            }\n            if ($char=~m/^\\|$/) {\n                $beat_count++;\n\
    \            } else {\n                $note++;\n                $beat_count =\
    \ 1;\n            }\n        } else {\n            if ($rest) {\n            \
    \    $rest++;\n            } else {\n                $beat_count = 1;\n      \
    \      }\n            $note->[$note] = $beat_count;\n        }\n    }\n    return\
    \ @notes;\n}\n</code>\n<|/ a |>\n<| c |>\nI've edited the question to show a sample\
    \ input that you've provided that isn't working\n<|/ c |>\n<| c |>\nI've edited\
    \ the answer with a new code version which seems to work fine for the sample input.\n\
    <|/ c |>\n<| c |>\nPerfect. Made my day.\n<|/ c |>\n<| a tags=parsing,perl,regex\
    \ |>\nYou really want to use a lexical state machine. Your code will be much simpler\
    \ and easier to debug and maintain.\nI used the Mojo::StateMachine::Perl module\
    \ to make this work and come up with:\n<code>\nuse strict;\nuse warnings;", " \
    \   my($music_array_ref);\n    my($number_of_beats);", "    my(@notes);\n    my($note)\
    \ = (\"\");\n    my($note_count) = (0);", "    my($music_array);\n    $music_array\
    \ .= 0;\n    my($index) = -1;", "    my(@notes);\n    my(@notes_strings);\n  \
    \  my($temp);", '    my(@beats_per_note) = (4, 2, 1);', "    my(@results);\n \
    \   my($music_length = length($music_string));\n    my($music_note_count);\n \
    \   my($beats);", "    my(@music_notes) = ();\n    my $note_length = 0;\n    my\
    \ $current_note = -1;\n    foreach my $char (split(//, $music_string)) {\n   \
    \     if($char eq 'o') {\n            $note_length = 4;\n            $current_note++;\n\
    \        } elsif($char eq '|') {\n            $note_length = 2;\n            $current_note++;\n\
    \        } elsif($char eq '.') {\n            $note_length = 1;\n            $current_note++;\n\
    \        } elsif($char eq 'o|') {\n            $note_length = 3;\n           \
    \ $current_note++;\n        } elsif($char eq '.|') {\n            $note_length\
    \ = 2;\n            $current_note++;\n        } else {\n            push(@music_notes,\
    \ $note_length * $current_note);\n            $note_length = 0;\n            $current_note\
    \ = -1;\n        }\n    }\n    push(@music_notes, $note_length * $current_note);\n\
    \    return @music_notes;\n}", "    my @notes = ();\n    my $note_sequence_index\
    \ = 0;\n    my $note_sequence = \"\";\n    my $note_sequence_start_index = 0;\n\
    \    my $note_sequence_end_index = 0;\n    my $note_sequence_note = ();\n    my\
    \ $note_sequence_beats_count = ();", '    my($i, $note, @beats) = ();', "    my($notes,\
    \ $beat_count) = (0, 0);\n    my($beats) = 0;\n    my($note) = 0;\n    my($new_note);",
  "    my(@notes);\n    my($notes_last_beat);", "    my(@music_array);\n    my($current_note);\n\
    \    my($number_of_beats);", "    my(@results);\n    my $current_beat = 0;\n \
    \   my $current_note = '';", "    my($num_beats) = 0;\n    my($current_beat) =\
    \ 0;\n    my($current_note) = 0;\n    my($notes) = ();\n    my(@notes) = ();\n\
    \    my($note) = \"\";\n    my($beat) = \"\";\n    my($i) = 0;\n    \n    for(my\
    \ $i = 0; $i < length($music_string); $i++) {\n        $note = $music_string[$i];\n\
    \        \n        if($note eq \"|\") {\n            $num_beats += 2;\n      \
    \  }\n        elsif($note eq \"o\") {\n            $num_beats += 4;\n        }\n\
    \        elsif($note eq \".\") {\n            $num_beats += 1;\n        }\n  \
    \      elsif($note eq \"o|\") {\n            $num_beats += 2;\n        }\n   \
    \     elsif($note eq \".|\") {\n            $num_beats += 1;\n        }\n    \
    \    elsif($note eq \"o|o|\") {\n            $num_beats += 3;\n        }\n   \
    \     elsif($note eq \"o|o|.|\") {\n            $num_beats += 2;\n        }\n\
    \        elsif($note eq \"o|o|.|.|\") {\n            $num_beats += 2;\n      \
    \  }\n        elsif($note eq \".|.|\") {\n            $num_beats += 1;\n     \
    \   }\n        elsif($note eq \"o|.|.\") {\n            $num_beats += 2;\n   \
    \     }\n        elsif($note eq \"o|o|o|\") {\n            $num_beats += 4;\n\
    \        }\n        elsif($note eq \"o|o|o|.|\") {\n            $num_beats +=\
    \ 3;\n        }\n        elsif($note eq \"o|o|o|.|.\") {\n            $num_beats\
    \ += 2;\n        }\n        elsif($note eq \"o|o|o|.|.|\") {\n            $num_beats\
    \ += 2;\n        }\n        elsif($note eq \".|.|.|\") {\n            $num_beats\
    \ += 1;\n        }\n        elsif($note eq \"o|.|.|.\") {\n            $num_beats\
    \ += 2;\n        }\n        elsif($note eq \"o|o|.|.|.\") {\n            $num_beats\
    \ += 2;\n        }\n        elsif($note eq \"o|.|.|.\") {\n            $num_beats\
    \ += 2;\n        }\n        elsif($note eq \".|.|.\") {\n            $num_beats\
    \ += 1;\n        }\n        elsif($note eq \"o|.|.|\") {\n            $num_",
  "    my($output_array) = ();\n    my($current_note) = ();\n    my($current_beat)\
    \ = ();", "    my($music_string) = $music_string =~ s/\\s+$//;\n    my($music_string)\
    \ = $music_string =~ s/^\\s+//;\n    my(@music) = split //, $music_string;\n \
    \   my(@beats) = 0;\n    foreach my $note (@music) {\n        if ($note eq '.')\
    \ {\n            push(@beats, 1);\n        } elsif ($note eq 'o') {\n        \
    \    push(@beats, 4);\n        } elsif ($note eq 'o|') {\n            push(@beats,\
    \ 2);\n        } else {\n            die \"Wrong music symbol: $note\";\n    \
    \    }\n    }\n    return @beats;\n}", "    my($music_notes, $last_music_note);\n\
    \    my($music_array);\n    my($count, $last) = ($music_string =~ /^(\\S+)\\s*$/);\n\
    \    # remove all whitespace\n    $music_string =~ s/\\s//g;\n    # for each note\n\
    \    foreach $music_notes (split /o|\\.|/, $music_string) {\n        # increment\
    \ the note counter by 1\n        $count += $music_notes =~ s/(\\.|o)//;\n    \
    \    # if it is the last note\n        if ($music_notes =~ /^o$/ && $last =~ /^o$/\
    \ || $last =~ /^\\.$/) {\n            # add count of one to the music array\n\
    \            $music_array[$last] = $count;\n        }\n        # reset the note\
    \ counter\n        $count = 1;\n    }\n    return $music_array;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks very much. I think this would be the right\
    \ solution if I wanted to use arrays in my assignment, however this was the main\
    \ reason I wrote a perl script to parse a string and return a hash with beat number\
    \ as keys and notes as values. Please let me know if you have any further questions\
    \ about the requirements. I'm still trying to understand how exactly this script\
    \ works.\n<|/ c |>\n<| c |>\n: See my answer. I've provided a perl script that\
    \ parses the string you provided. Your code doesn't work and has some errors.\
    \ I provided a perl script that works, and I've included that code in the answer.\n\
    <|/ c |>\n<| c |>\nThank you very much, this is great! I do have one question\
    \ though: how does this code differentiate between a note and a rest? From the\
    \ way I see it, it seems it is able to differentiate by using the regular expressions\
    \ ^o$ and ^\\.$ which mean the strings should begin with an \"o\" and end with\
    \ a \"o\" or \"o\" at the end of the string. How does this work with \"r\" being\
    \ used? I am still a little confused on how this works\n<|/ c |>\n<| c |>\n: That\
    \ code works. `r` is a regex modifier, it means `/s`. `/s` means do 'single' line\
    \ mode. This means that `.` matches newlines, but it means 'dot matches newlines\
    \ only'. You must put `/s` at the end of the expression to turn it on for dot\
    \ only. See the link I gave you in my answer.\n<|/ c ", "    my(@notes) = ();\n\
    \    my($counter) = 0;\n    my($last_note) = undef;", "    my($music_array, $current_beat,\
    \ $current_note) = ('');\n    my($beat_counter) = 0;\n    my($note_counter) =\
    \ 0;\n    my($last_note) = 0;", "    my(@music_notes);\n    my($current_beat);\n\
    \    my($current_note);\n    my($current_note_length);", "    my @beats = ();\n\
    \    my($last_note) = ();\n    my($number_of_notes) = 0;\n    $music_string =~\
    \ s/^\\s+|\\s+$//g;\n    \n    foreach my $char (split //, $music_string) {\n\
    \        if ($char eq 'o') {\n            push @beats, 4;\n            $last_note\
    \ = ();\n        } elsif ($char eq 'o|') {\n            push @beats, 2;\n    \
    \        $last_note = ();\n        } elsif ($char eq '.|') {\n            push\
    \ @beats, 1;\n        } elsif ($char eq '|') {\n            $last_note = ();\n\
    \        } elsif ($char eq ' ') {\n            push @beats, 0;\n        } elsif\
    \ ($char eq '.') {\n            push @beats, 0;\n        } else {\n          \
    \  die \"Invalid music string '$music_string'\";\n        }\n        $number_of_notes++;\n\
    \    }\n    \n    # Handle edge cases where the last note is empty\n    $beats[-1]\
    \ ||= 1;\n    \n    # Handle edge cases where the number of notes is zero\n  \
    \  die \"Zero notes in music string\" if $number_of_notes == 0;\n    \n    return\
    \ \\@beats;\n}", "    my @result;\n    my $current_note;", '    my();', "    my\
    \ @music_notes;\n    my %notes_beat_counts;\n    my $prev_note;\n    for my $note\
    \ (split //, $music_string) {\n        if ($note =~ /^o|\\.|$/) {\n          \
    \  my $beat_count = 1;\n            if ($note eq 'o') {\n                $beat_count\
    \ = 4;\n            }\n            elsif ($note eq '.') {\n                $beat_count\
    \ = 2;\n            }\n            $notes_beat_counts{$note}{beat_count} = $beat_count;\n\
    \        }\n        elsif ($note =~ /^o$/) {\n            my $beat_count = 1;\n\
    \            $notes_beat_counts{$note}{beat_count} = $beat_count;\n        }\n\
    \        elsif ($note =~ /^\\.$/) {\n            $notes_beat_counts{$note}{beat_count}\
    \ = 1;\n        }\n        else {\n            die \"Invalid music string format:\
    \ $note\\n\";\n        }\n        if ($prev_note) {\n            my $note_to_add\
    \ = $notes_beat_counts{$prev_note}{beat_count};\n            $notes_beat_counts{$prev_note}{beat_count}\
    \ = $note_to_add + $notes_beat_counts{$note}{beat_count};\n        }\n       \
    \ $prev_note = $note;\n    }\n    return @music_notes;\n}\n</textarea></form>",
  "    my @result;\n    my $note_length = 1;\n    $music_string =~ /([a-z ]+)/ig;\n\
    \    foreach my $note (@$music_string) {\n        my $note_number = ord($note)\
    \ - ord('a') + 1;\n        my $note_string;\n        if ($note_number == 1) {\n\
    \            $note_string = \"o\";\n        } elsif ($note_number == 2) {\n  \
    \          $note_string = \"o|\";\n        } elsif ($note_number == 3) {\n   \
    \         $note_string = \".\";\n        } elsif ($note_number == 4) {\n     \
    \       $note_string = \"o\";\n        } else {\n            die \"unknown note:\
    \ $note_number\";\n        }\n        my $number_of_beats = $note_length * 4;\n\
    \        $note_length *= 2;\n        $note_string = \".\" x $number_of_beats .\
    \ $note_string;\n        push(@result, $number_of_beats);\n    }\n    return \\\
    @result;\n}", '    my(@parsed_notes);', "    my(@music_notes) = ();\n    my($current_beat)\
    \ = 0;\n    my($current_note) = 0;", "    my @notes_note_count;\n    my $current_note\
    \ = 0;\n    my $note_char = 0;\n    my $note_char_beat_length = 0;\n    my $note_char_beat_length_array\
    \ = 0;\n    my $note_char_duration = 0;\n    my $note_char_duration_array = 0;\n\
    \    my $current_note_name = 0;\n    my $note_char_duration = 0;\n    my $note_char_duration_array\
    \ = 0;", "    my($last_note, $last_beat, @notes) = ('', 0, ());\n    while($music_string\
    \ =~ m/^([a-z]+)\\s*(.*)/i) {\n        my $note = $1;\n        if ($note ne 'o'\
    \ && $note ne '.') {\n            push(@notes, $note);\n            $last_note\
    \ = $note;\n            $last_beat = 0;\n        } elsif ($note eq 'o') {\n  \
    \          $last_beat += length($2);\n        }\n    }\n    return @notes;\n}\n\
    </code>\n<|/ a dscore=0 tags=string,perl,arrays |>\n<| c |>\nOh, thanks for the\
    \ answer! But I am not allowed to use any package, only subroutines.\n<|/ c |>\n\
    <| c |>\nYou can just write the code in sub parse_music, no packages\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\nuse strict;\nuse warnings;\nuse autodie;\nuse constant\
    \ {\n    NOTE_NAME => \"ABCDEFG\",\n    NOTES_LENGTH => 6,\n};", "    my @notes\
    \ = ();\n    my @current_note;\n    my @temp;\n    my $length = 0;", "    my(@beats_per_pitch);\n\
    \    my($notes);\n    my($first_note);\n    my($last_note);", "    my @notes;\n\
    \    my @counters;\n    my $current_note = 0;\n    my $current_beat = 0;\n   \
    \ foreach my $char (split(//, $music_string)) {\n        chomp($char);\n     \
    \   if($char =~ m/^\\s/) {\n            if($notes[$current_note] > 0) {\n    \
    \            push(@counters, $notes[$current_note]);\n            }\n        \
    \    $current_note += $notes_max[$current_note];\n        } else {\n         \
    \   push(@notes, $char);\n            $current_note++;\n        }\n    }\n   \
    \ return @counters;\n}", "    my(@notes) = ();\n    my($note, $beat);\n    my($i);\n\
    \    my($j);", '    my($i, $beats);', "    my @beats = ();\n    $music_string\
    \ =~ s/(.)\\|/$1|/g;\n    $music_string =~ s/o(.)/$1|$1/g;\n    $music_string\
    \ =~ s/(.)o$/\\$1|$1/;\n    while ($music_string =~ /([^|]*)\\|/) {\n        my\
    \ $beat_number = $1;\n        my $note_length = 0;\n        my $note_class = \"\
    o\";\n        my $note_number = 1;\n        my $note_octave = 0;\n        $music_string\
    \ =~ s/\\|$//;\n        while ($music_string =~ /([^|]*)\\|/) {\n            my\
    \ $note_length = $1;\n            my $note_class = $1;\n            my $note_number\
    \ = $1;\n            my $note_octave = $1;\n            $music_string =~ s/\\\
    |$//;\n        }\n        if ($note_number > $max_note) {\n            $music_string\
    \ =~ s/o(.)/$1|$1/g;\n            $music_string =~ s/(.)o$/\\$1|$1/;\n       \
    \ }\n        $music_string =~ s/(.)$note_class$/$1|$1/g;\n        $music_string\
    \ =~ s/(.)$note_octave$/$1|$1/g;\n        my $beats_after_last_note = ($music_string\
    \ =~ s/$note_class$//g);\n        $beats_after_last_note += $music_string =~ s/$note_octave$//g;\n\
    \        push(@beats, $beats_after_last_note);\n    }\n    return @beats;\n}",
  "    my($notes) = [];\n    my($note_count);\n    my($note_index);\n    my($index\
    \ = 0);\n    my($is_first) = TRUE;\n    $music_string =~ s/^\\s+//g;\n    $music_string\
    \ =~ s/\\s+$//g;\n    $music_string =~ s/\\s+/ /g;\n    $music_string =~ s/o//g;\n\
    \    $music_string =~ s/o\\|//g;\n    $music_string =~ s/\\.\\|//g;\n    $music_string\
    \ =~ s/\\|$//g;\n    $music_string =~ s/\\|/|/g;\n    my $music_length = length($music_string);\n\
    \    for(my $count = 0; $count < $music_length; $count++) {\n        my $music_char\
    \ = substr($music_string, $count, 1)\n        if ($music_char eq 'o') {\n    \
    \        $note_count++;\n            $notes[$note_count] = $count;\n         \
    \   $note_count = 0;\n        } elsif ($music_char eq 'o|') {\n            $note_count++;\n\
    \            $notes[$note_count] = $count;\n            $note_count = 0;\n   \
    \     } elsif ($music_char eq '.|') {\n            $note_count++;\n          \
    \  $notes[$note_count] = $count;\n            $note_count = 0;\n        } else\
    \ {\n            $index++;\n            if ($is_first) {\n                $note_count++;\n\
    \                $notes[$note_count] = $count;\n                $note_count =\
    \ 0;\n                $is_first = FALSE;\n            } else {\n             \
    \   $notes[$note_count] = $notes[$note_count - 1];\n                $note_count++;\n\
    \                $notes[$note_count] = $notes[$note_count - 1];\n            \
    \    $note_count++;\n            }\n        }\n    }\n    return @$notes;\n}\n\
    </code>\n<|/ a dscore=3 tags=perl,arrays |>\n<| a |>\nI assume that your teacher\
    \ provided you with some sort of instruction on how to do this. If so, I would\
    \ recommend that you just ask your teacher for more help; they will probably know\
    \ better.\nAs an alternative, I would recommend that instead of trying to re-invent\
    \ the wheel, just use an existing Perl module for music. There are plenty of them,\
    \ and this one seems pretty popular:\nhttp://metacpan.org/module/Music::Algorithm\n\
    Also, you can find a number of good references on the web about music parsing\
    \ using Perl:\nhttp://en.wikipedia.org/wiki/Music_theory\nhttp://en.wikipedia.org/wiki/Musi",
  "    my($string) = $music_string;\n    my @music_array;\n    my @notes;\n    my\
    \ $note_count = 0;", "    my;\n    my $index = 0;\n    my $last_note = -1;\n \
    \   my $i = 0;\n    my $last_beat = 0;\n    my $beat_counter = 1;\n    my $octave\
    \ = 0;\n    foreach my $note (split(//, $music_string)) {\n        if ($note eq\
    \ \".\") {\n            $octave++;\n        }\n        elsif ($note eq \"o\")\
    \ {\n            $octave = 0;\n        }\n        elsif ($octave > 0) {\n    \
    \        $index++;\n            push, $index;\n        }\n        elsif ($note\
    \ eq \"|\") {\n            $index++;\n            $last_beat = $index;\n     \
    \   }\n        elsif ($note eq \"o|\") {\n            $index++;\n            $last_beat\
    \ = $index;\n        }\n        elsif ($note eq \"o|\") {\n            $index++;\n\
    \            $last_beat = $index;\n        }\n        elsif ($note eq \"o|\")\
    \ {\n            $index++;\n            $last_beat = $index;\n        }\n    \
    \    elsif ($note eq \".\") {\n            $index++;\n            $last_beat =\
    \ $index;\n        }\n        elsif ($note eq \"o|\") {\n            $index++;\n\
    \            $last_beat = $index;\n        }\n        elsif ($note eq \"o|\")\
    \ {\n            $index++;\n            $last_beat = $index;\n        }\n    \
    \    elsif ($note eq \"o|\") {\n            $index++;\n            $last_beat\
    \ = $index;\n        }\n        elsif ($note eq \"o|\") {\n            $index++;\n\
    \            $last_beat = $index;\n        }\n        elsif ($note eq \"o|\")\
    \ {\n            $index++;\n            $last_beat = $index;\n        }\n    \
    \    elsif ($note eq \"o|\") {\n            $index++;\n            $last_beat\
    \ = $index;\n        }\n        elsif ($note eq \"o|\") {\n            $index++;\n\
    \            $last_beat = $index;\n        }\n        elsif ($note eq \"o|\")\
    \ {\n            $index++;\n            $last_beat = $index;\n        }\n    \
    \    elsif ($note eq \"o|\") {\n            $index++;\n            $last_beat\
    \ = $index;\n        }\n        elsif ($note eq \"o|\") {\n            $index++;\n\
    \            $last_beat = $index;\n        }\n        elsif ($note eq \"o|\")\
    \ {\n            $index++;\n            $last_beat = $index;\n        }\n    \
    \    elsif ($note eq \"o|\") {\n            $index++;\n            $last_beat\
    \ = $index;\n        }\n        ", "    my($notes) = ();\n    chomp($music_string);\n\
    \    $music_string =~ s/\\s+//g;", "    my(@parsed_music) = ();\n    my @note_chars\
    \ = split(//, $music_string);\n    my $notes = scalar(@note_chars);\n    foreach\
    \ my $char (@note_chars) {\n        my $last_char = pop(@note_chars);\n      \
    \  my $last_char = lc $last_char;\n        my $beat_length = 4;\n        if ($char\
    \ =~ m/\\|/) {\n            $beat_length = 2;\n        }\n        if ($last_char\
    \ eq \"o\") {\n            push(@parsed_music, $notes);\n            $notes =\
    \ $notes - $beat_length;\n        } else {\n            $notes = $notes + $beat_length;\n\
    \        }\n    }\n    return @parsed_music;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nWhy you write so complicated code when you could do it in a single line?\n\
    <|/ c |>\n<| c |>\nI was looking for an elegant way to do this without if-else\
    \ clauses (if/else clauses aren't as easy to read and understand) and couldn't\
    \ find anything better and concise. This is definitely more concise and probably\
    \ much faster.\n<|/ c |>\n<| a tags=perl,split,arrays |>\nIf I had to write that\
    \ code I would simply use a regular expression and a for loop:\n<code>\nmy $music\
    \ = \"o o| .| o| o| .| .| .| .| o o\";\nmy = $music =~ /(\\s.+)/g;\nmy $last_notes\
    \ = $notes[-1];\nmy $first_notes = $notes[0];\nmy $total_notes = $notes[$#notes];",
  "    my;\n    my;", '    my($music_array) = [];', '    my @results;', "    my(@music)\
    \ = ();\n    my($note);\n    my($note_count);", "    my(@beats_array);\n    my\
    \ ($current_note, $beats_before_note);\n    my ($previous_note, @previous_notes);",
  "    my %note_count;\n    my @notes = ();\n    my $note_char;", "    my($music_array_length)\
    \ = length($music_string);\n    my($music_array) = $music_string =~ m/^([\\. \\\
    -o|\\ ]+?)([\\. \\-o|\\ ]+?)$/g;\n    \n    my($num_first_beats);\n    my($num_last_beats);\n\
    \    \n    if (scalar($music_array) == $music_array_length) {\n        $num_first_beats\
    \ = $num_last_beats = 0;\n    } else {\n        $num_first_beats = $music_array_length\
    \ / $music_array;\n        $num_last_beats = $music_array_length % $music_array;\n\
    \    }\n    \n    return ($num_first_beats, $num_last_beats);\n}\n</code>\n<|/\
    \ a |>\n<| a tags=arrays,perl |>\n<code>\nuse strict;\nuse warnings;", "    my(@music)\
    \ = split //, $music_string;\n    my(@note_array_to_return) = ();\n    push(@note_array_to_return,\
    \ 0);\n    for($i = 1; $i <= $#music; $i++) {\n        my $current_note = $music[$i];\n\
    \        my $current_beats = 0;\n        if($current_note eq '.') {\n        \
    \    $current_beats = 1;\n        } else if($current_note eq 'o') {\n        \
    \    $current_beats = 4;\n        } else if($current_note eq 'o|') {\n       \
    \     $current_beats = 2;\n        }\n        $note_array_to_return[$current_beats]++;\n\
    \    }\n    return @note_array_to_return;\n}\n</code>\n<|/ a tags=parsing,perl\
    \ |>\n<| c |>\nthank you so much!\ncan you explain to me the meaning of these\
    \ lines of codes?\n`my(@music) = split //, $music_string;`\n`my(@note_array_to_return)\
    \ = ();`\n`push(@note_array_to_return, 0);`\n`for($i = 1; $i <= $#music; $i++)\
    \ {`\n<|/ c |>\n<| c |>\nI've added some explanations to my answer\n<|/ c |>\n\
    <| a dscore=1 |>\nThis is how I would do it:\n<code>\nuse strict;\nuse warnings;",
  "    my @returned_notes = ();\n    my $current_note_length = 0;\n    my $current_note_number\
    \ = 0;\n    my $number_of_notes = 0;\n    my $next_note_length = 0;\n    my $next_note_number\
    \ = 0;\n    my $current_note;", "    my($notes_arr) = ([]) x 5;\n    my($note_count_arr)\
    \ = ([]) x 5;\n    my($i) = 0;\n    my(@notes) = $music_string =~ /([a-zA-Z])/ig;\n\
    \    foreach $notes_arr (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig) {\n\
    \            $note_count_arr[$notes_arr] ++;\n        }\n    }\n    foreach $notes_arr\
    \ (@notes) {\n        if($notes_arr =~ /^([a-zA-Z])/ig) {\n            $note_count_arr[$1]\
    \ ++;\n        }\n    }\n    foreach $notes_arr (@notes) {\n        if($notes_arr\
    \ =~ /([a-zA-Z])/ig) {\n            $note_count_arr[$notes_arr] ++;\n        }\n\
    \    }\n    foreach $notes_arr (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig)\
    \ {\n            $note_count_arr[$notes_arr] ++;\n        }\n    }\n    foreach\
    \ $notes_arr (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig) {\n        \
    \    $note_count_arr[$notes_arr] ++;\n        }\n    }\n    foreach $notes_arr\
    \ (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig) {\n            $note_count_arr[$notes_arr]\
    \ ++;\n        }\n    }\n    foreach $notes_arr (@notes) {\n        if($notes_arr\
    \ =~ /([a-zA-Z])/ig) {\n            $note_count_arr[$notes_arr] ++;\n        }\n\
    \    }\n    foreach $notes_arr (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig)\
    \ {\n            $note_count_arr[$notes_arr] ++;\n        }\n    }\n    foreach\
    \ $notes_arr (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig) {\n        \
    \    $note_count_arr[$notes_arr] ++;\n        }\n    }\n    foreach $notes_arr\
    \ (@notes) {\n        if($notes_arr =~ /([a-zA-Z])/ig) {\n            $note_count_arr[$notes_arr]\
    \ ++;\n        }\n    }\n    foreach $notes_arr (@notes) {\n        if($notes_arr\
    \ =~ /([a-zA-Z])/ig) {\n            $note_count_arr[$notes_arr] ++;\n        }\n\
    \    }\n    foreach $", '    my @music = ();', "    my($num_notes) = 0;\n    my($notes_array);\n\
    \    my($note_length);", "    my($parsed_music);\n    my($parsed_string);\n  \
    \  my(@parsed_string);", "    my $music = {};\n    my @notes = ();", "    my(@music_notes)\
    \ = ();\n    my($notes_last_beat) = 0;", '    my(@parsed_music) = ();', "    my($music)\
    \ = ([], 0);\n    while ($music_string =~ /([o|\\.])(.*)/) {\n        if ($1 eq\
    \ 'o') {\n            push(@$music, 4);\n        } elsif ($1 eq '|') {\n     \
    \       push(@$music, 2);\n        } else {\n            push(@$music, 1);\n \
    \       }\n        $music += ([@$music], [@$music]);\n    }\n    return @$music;\n\
    }", '    my $result;', "    my($music_length);\n    my($notes); # Array of notes\n\
    \    my($notes_length);\n    my($beats);\n    my($beat_length);", '    my;', " \
    \   my($parsed_string);\n    my($current_note, @current_notes);\n    my($temp);",
  "    my(@notes);\n    my $note_length = 10;\n    my $current_length = 0;\n    my\
    \ $note = \"\";\n    my $beats_per_note = 4;\n    my($first,$second,$third,$fourth);\n\
    \    for ($music_string) {\n        if ($note_length > 0) {\n            $note\
    \ .= substr($music_string,$current_length,$note_length);\n            $current_length\
    \ += $note_length;\n        }\n        if (substr($music_string,$current_length,1)\
    \ eq \"|\") {\n            $note_length--;\n            $current_length++;\n \
    \       }\n        elsif (substr($music_string,$current_length,1) eq \"o\") {\n\
    \            $current_length++;\n            $notes[$note]++;\n        }\n   \
    \     else {\n            $current_length++;\n        }\n        $note .= substr($music_string,$current_length);\n\
    \    }\n    $notes[$note] ||= 0;\n    $notes[$note] /= $beats_per_note;\n    @notes\
    \ = @{ $notes[$note] };\n    @notes = reverse @notes;\n    return @notes;\n}",
  "    my @parsed_notes = ();\n    my @parsed_notes_temp;\n    \n    for (my $i =\
    \ 0; $i <= length($music_string); $i++) {\n        my $letter = $music_string[$i];\n\
    \        if ($letter eq 'o') {\n            $parsed_notes_temp[0] = $parsed_notes_temp[0]+1;\n\
    \        } elsif ($letter eq 'o|') {\n            $parsed_notes_temp[1] = $parsed_notes_temp[1]+1;\n\
    \        } elsif ($letter eq '.|') {\n            $parsed_notes_temp[2] = $parsed_notes_temp[2]+1;\n\
    \        }\n        if (@parsed_notes_temp == 4) {\n            push(@parsed_notes,\
    \ $parsed_notes_temp[0]);\n            push(@parsed_notes, $parsed_notes_temp[1]);\n\
    \            push(@parsed_notes, $parsed_notes_temp[2]);\n            push(@parsed_notes,\
    \ $parsed_notes_temp[3]);\n            @parsed_notes_temp = ();\n        }\n \
    \   }\n    \n    return @parsed_notes;\n}", "    my($music) = split ' ', $music_string;",
  '    my @music_chars;', "    my(@parsed_music);\n    my $current_index = 0;\n  \
    \  my $current_note = -1;\n    my $current_beat = 0;", "    my($music_array);\n\
    \    my($music_note_char);", "    my(@song) = ();\n    my $note_length = 4;\n\
    \    my @notes = ();\n    my $offset = 0;\n    my $current_note;\n    my $next_note;\n\
    \    my $note_number;\n    my $notes_number = 0;\n    my $note_symbol;\n    my\
    \ $music_length;", '    my(@array_of_notes);', "    my($music_array) = ();\n \
    \   my($curr_note_beat_count) = -1;\n    my($curr_note_beat_count_in_note) = -1;\n\
    \    my($note_beat_count_in_note) = -1;\n    my($notes_beat_count_in_note) = -1;\n\
    \    my($note_beat_count_in_chord) = -1;\n    my($prev_note_beat_count_in_chord)\
    \ = -1;\n    my($curr_chord_beat_count) = -1;", '    my($notes);', "    my %notes\
    \ = ();\n    $music_string =~ tr/o+/0..9;\n    my @music_notes = split(//, $music_string);\n\
    \    foreach my $note(@music_notes) {\n        # Every note has four beats\n \
    \       my $beats_number = 4 - (length($note) - 1);\n        $notes{$note} = $beats_number;\n\
    \    }\n    return \\%notes;\n}", "    my(@music_array);\n    my $note_symbols\
    \ = 'oO|.|'; # Note symbols we will use in our pattern", "    my;\n    my $note\
    \ = chr(65);\n    my $last_note = chr(65);", "    my(@results);\n    $music_string\
    \ =~ s/\\s+//g; # remove spaces\n    $music_string =~ s/^\\s*//; # remove spaces\n\
    \    my($notes, $notes_str);\n    my $curr_note = 0;\n    my $curr_beat_length\
    \ = 0;\n    while ($music_string =~ s/([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\\
    |([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)\\|([^|]*)", "    my($music_array) = [];\n\
    \    my($note);\n    my($notes);\n    my($beat);\n    my($duration);\n    my($number_of_notes);\n\
    \    my($number_of_beats);\n    \n    $music_string =~ s/\\s+//g;\n    \n    #\
    \ split music string into notes\n    $notes = split /o|\\.\\|/, $music_string;\n\
    \    \n    # count notes\n    $number_of_notes = scalar @$notes;\n    \n    #\
    \ create music array\n    for($note = 0; $note < $number_of_notes; $note++) {\n\
    \        \n        # last note in array is silence\n        if($notes[$note] eq\
    \ '.') {\n            $music_array[$note] = 0;\n            \n        # last note\
    \ in array is a rest or a rest\n        } else if($notes[$note] eq 'o') {\n  \
    \          $music_array[$note] = 4;\n            \n        # last note in array\
    \ is a half note\n        } else if($notes[$note] eq '|') {\n            $music_array[$note]\
    \ = 2;\n            \n        # last note in array is quater note\n        } else\
    \ {\n            $music_array[$note] = 1;\n        }\n    }\n    \n    # count\
    \ beats\n    for(my $note = 0; $note < $number_of_notes; $note++) {\n        \n\
    \        # last note in array is a rest or a rest\n        if($music_array[$note]\
    \ == 4) {\n            $number_of_beats++;\n            \n        # last note\
    \ in array is a half note\n        } elsif($music_array[$note] == 2) {\n     \
    \       $number_of_beats += 4;\n            \n        # last note in array is\
    \ quater note\n        } else {\n            $number_of_beats += 4;\n        }\n\
    \    }\n    \n    # return array of number of beats per note\n    return $music_array;\n\
    }", "    my;\n    my $note_count = 0;\n    my $current_note = \"\";\n    my $last_note\
    \ = \"\";\n    foreach my $char (split //, $music_string) {\n        $note_count++\
    \ if ($char eq '.' or ($char eq 'o' and $note_count % 4 == 0));\n        $note_count++\
    \ if ($char eq 'o|' or ($char eq '.' and $note_count % 2 == 0));\n        $note_count++\
    \ if ($char eq 'o|' and $note_count % 4 == 0);\n        $note_count-- if ($char\
    \ eq 'o|' and $note_count % 2 == 0);\n        $note_count-- if ($char eq 'o' and\
    \ $note_count % 4 == 0);\n        $note_count-- if ($char eq 'o' and $note_count\
    \ % 2 == 0);\n        $current_note .= $char;\n        $last_note .= $char;\n\
    \    }\n    return scalar($last_note);\n}", "    my @music_notes = split //, $music_string;\n\
    \    my @music_lengths;\n    my $current_note = 0;\n    my $current_length = 0;\n\
    \    for(my $i=0; $i<@music_notes; $i++) {\n        my $note = substr($music_notes[$i],\
    \ 0, 1);\n        $note =~ tr/A-Z//;\n        if($note eq 'o') {\n           \
    \ $music_lengths[$current_note] += $current_length;\n            $current_length\
    \ = 0;\n        }\n        elsif($note eq 'o|') {\n            $music_lengths[$current_note]\
    \ += $current_length / 2;\n            $current_length = 0;\n            $current_note\
    \ += 1;\n        }\n        else {\n            $music_lengths[$current_note]\
    \ += $current_length;\n            $current_length = 0;\n        }\n    }\n  \
    \  return @music_lengths;\n}\n</code>\n<|/ a tags=perl,arrays |>\n<| c |>\n`tr/A-Z/a-z/`\
    \ is very nice. :)\n<|/ c |>\n<| c |>\n`tr/A-Z/a-z/` is great for sorting musical\
    \ notes by length (not alphabetical).\n<|/ c |>\n<| c |>\nThank you all for your\
    \ input! I've been able to get the code working using the solution posted by\n\
    <|/ c |>\n<| a dscore=1 |>\nTry this :\n<code>\nuse strict;\nuse warnings;", " \
    \   my($music) = undef;\n    my($last_note) = '';\n    my($last_note_count) =\
    \ 0;\n    my($current_note) = '';\n    my($current_note_count) = 0;\n    my($current_note_string)\
    \ = '';", "    my(@music_notes) = [];\n    my($note_lengths_string);\n    foreach\
    \ my $symbol (split(' ', $music_string)) {\n        my $note_string = $symbol;\n\
    \        if ($note_string =~ /^o|.\\|$/) {\n            $note_string = $symbol\
    \ =~ s/\\|$//;\n        }\n        push(@music_notes, $note_string);\n    }\n\
    \    $note_lengths_string = $music_notes[@music_notes - 1];\n    foreach my $note\
    \ (@music_notes) {\n        foreach my $length (split(' ', $note_lengths_string))\
    \ {\n            if ($length == $note) {\n                $music_notes[$music_notes\
    \ - 1] -= $length + 1;\n            }\n        }\n    }\n    return @music_notes;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like your solution. It also works with\
    \ the example. However it does not work with this one: \"o .| o| o| o .| o| o|\
    \ o| o| o|\" -> [4,4,4,4,4,4,4,4,4]\n<|/ c |>\n<| a dscore=0 tags=parsing,perl,regex,arrays\
    \ |>\nA Perl module like Text::ParseWords would help you with this.\n<code>\n\
    use strict;\nuse warnings;", "    my(@music_notes) = (@{[$music_string =~ m/(.)(\\\
    |)/]});\n    my(@last_beats) = (@{[$music_string =~ m/(o|\\.)\\|/]});\n    my($beats_after_note)\
    \ = @{[$music_string =~ m/(.)\\|/]};\n    my($last_beats_after_note) = @{[$music_string\
    \ =~ m/(.)\\|$/]};\n    my $beats_after_note_or_last_beats = $beats_after_note\
    \ +\n                                      $last_beats_after_note;\n    my $beats_after_notes_or_last_beats\
    \ = $beats_after_note_or_last_beats;", "    my;\n    my $length = 0;\n    foreach\
    \ my $symbol (split(//, $music_string)) {\n        if ($symbol eq 'o') {\n   \
    \         push (@music, $length);\n            $length = 0;\n        } elsif ($symbol\
    \ eq 'o|') {\n            push (@music, $length);\n            $length = 0;\n\
    \        } elsif ($symbol eq '.|') {\n            $length++;\n        }\n    }\n\
    \    push (@music, $length);\n    return @music;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks. But how about other notations, like notes with dots or sharps?\n<|/ c\
    \ |>\n<| c |>\nI have added a description of how the notation is processed to\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks. Your answer was really helpful, but I\
    \ decided to use something simpler, based on my input string and the number of\
    \ beats it lasted. What I did is just `split //, $music_string` and then `map\
    \ { $_ eq '.' ? ($length++) : (1) }`.\n<|/ c |>\n<| a tags=perl,arrays,regex |>\n\
    In response to the comment from, the code below is modified from the above solution\
    \ (that posted here) which finds out the length of each note in the musical notation\
    \ and also the frequency of notes with sharps and dots. Notes with sharps and\
    \ dots have a frequency of 1.\n<code>", "    my(@notes) = ();\n    my($current_note)\
    \ = undef;\n    my($last_beat) = 0;\n    my($last_note) = '';\n    \n    foreach\
    \ my $char (split(' ', $music_string)) {\n        if ($char eq 'o') {\n      \
    \      $last_note = $char;\n            $last_beat = 0;\n        } elsif ($char\
    \ eq 'o|') {\n            $last_note = $char;\n            $last_beat = 1;\n \
    \       } else {\n            if ($last_note eq $char) {\n                push(@notes,\
    \ $last_beat * 4);\n                $last_note = undef;\n            } else {\n\
    \                $current_note = $char;\n                $last_beat = 0;\n   \
    \         }\n        }\n    }\n    push(@notes, $last_beat * 4);\n    return @notes;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI used your code in my program and it\
    \ didn't work. The program stopped at the first input.\n<|/ c |>\n<| c |>\nSorry,\
    \ I forgot to save and re-run my code. The program now works but doesn't quite\
    \ solve my problem. I'm still working on getting it to work. I'm going to post\
    \ my updated code when I get it to work.\n<|/ c |>\n<| c |>\nI updated my original\
    \ question with my modified code but it doesn't work.\n<|/ c |>\n<| c |>\nMy code\
    \ doesn't work because I don't know how to make it work and I don't understand\
    \ how your code works. I tried to understand your code but I don't understand\
    \ how it works. I don't understand how it works and I don't know how to make it\
    \ work.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    my($music_note) = undef;\n\
    \    my($music_beat) = undef;\n    my($music_temp) = undef;\n    my(@music_temp)\
    \ = undef;", "    my(@music_data) = split //, $music_string;\n    my(@count_array);\n\
    \    my $index = 0;\n    while ($index++ < $#music_data) {\n        if ($music_data[$index]\
    \ eq '.') {\n            push(@count_array, $music_data[$index-1]);\n        }\
    \ else {\n            push(@count_array, $music_data[$index]);\n        }\n  \
    \  }\n    return @count_array;\n}", '    my @music = ();', "    my @music_array;\n\
    \    my ($note_one, $note_two, $note_three, $note_four) = ();\n    my $total_beats\
    \ = 0;\n    my $current_note = undef;\n    my $current_beat = 0;\n    my $note_count\
    \ = 0;\n    my $beat_count = -1;", "    my @notes;\n    my %beats;\n    my @delimiters\
    \ = ('o|', '.|');\n    for my $delim (@delimiters) {\n        my $index = 0;\n\
    \        while ($index<length($music_string)) {\n            my $beats_per_note\
    \ = length($music_string) - $index;\n            my $note = substr($music_string,\
    \ $index, 1);\n            if ($note eq $delim) {\n                push(@notes,\
    \ $note);\n                $beats{$note} = $beats_per_note;\n            }\n \
    \           $index += 1;\n        }\n    }\n    return \\@notes, \\%beats;\n}",
  "    my @notes = split(//, $music_string);\n    my;\n    my $last_note_beat = 1;\n\
    \    my $note_last_beat = 0;", "    my($music_string);\n    $music_string =~ s/\\\
    |/3/gi;\n    $music_string =~ s/\\|/2/gi;\n    $music_string =~ s/\\|/1/gi;\n\
    \    $music_string =~ s/\\|/4/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string\
    \ =~ s/\\|/4/gi;\n    $music_string =~ s/\\|/5/gi;\n    $music_string =~ s/\\\
    |/3/gi;\n    $music_string =~ s/\\|/4/gi;\n    $music_string =~ s/\\|/3/gi;\n\
    \    $music_string =~ s/\\|/2/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string\
    \ =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\\
    |/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n\
    \    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string\
    \ =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\\
    |/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n\
    \    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string\
    \ =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\\
    |/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n\
    \    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string\
    \ =~ s/\\|/3/gi;\n    $music_string =~ s/\\|/3/gi;\n    $music_string =~ s/\\\
    |/3/gi;\n", "    my($length, $beat_count);\n    my(@notes) = ();\n    my($note)\
    \ = (\"\");\n    my($octave) = 0;\n    my($note_name) = (\"\");\n    $music_string\
    \ =~ s/\\s+/ /g;\n    while ($music_string =~ /([0-9A-Ga-g]+)\\|([0-9A-Ga-g]+)/g)\
    \ {\n        $length = $2;\n        $note = ($1);\n        if ($note =~ /([0-9A-Ga-g])/)\
    \ {\n            $octave = $1;\n        }\n        if ($note =~ /([0-9A-Ga-g]{4})/)\
    \ {\n            $note_name = $1;\n            $note_name = ucfirst($note_name);\n\
    \        }\n        push (@notes, $octave . \":\" . $note_name . \"#\" . $length\
    \ . \"\\n\");\n    }\n    my $current_note = 1;\n    my $last_note = 0;\n    my\
    \ $current_note_name;\n    my $current_octave;\n    foreach $note (@notes) {\n\
    \        if ($note =~ /^[0-9]+:(.*)#([0-9]+)/) {\n            $current_note_name\
    \ = $1;\n            $current_note_name = $current_note_name =~ tr/[:#]/_/r;\n\
    \            $current_octave = $1;\n        }\n        if ($note =~ /^[0-9]+:(.*)$/)\
    \ {\n            $last_note = $current_note;\n            $last_note = $last_note\
    \ =~ tr/[:#]/_/r;\n            $current_note = $1;\n            $current_note\
    \ = $current_note =~ tr/[:#]/_/r;\n        }\n        if ($note =~ /[^o|\\.]$/)\
    \ {\n            $current_note = $current_note + 1;\n        }\n    }\n    if\
    \ ($last_note == 0) {\n        $last_note = 1;\n    }\n    $beat_count = $length\
    \ - $last_note;\n    return $beat_count;\n}", "    my($notes) = undef;\n    my($number_of_beats)\
    \ = undef;", "    my(@music) = split '|', $music_string;", "    my;\n    $music_string\
    \ =~ tr/|/o|/;\n    $music_string =~ s/o\\|$/|/;\n    my @music_list = ();\n \
    \   my @music_list = ();\n    my $current_note = undef;\n    my $current_beat\
    \ = 0;\n    $music_string =~ s/^(\\D)(\\d+)(\\D*)//;\n    push(@music_list, $1);\n\
    \    $current_note = $1;\n    $current_beat = $2;\n    $music_string =~ s/^(\\\
    D)(\\d+)(\\D*)//;\n    push(@music_list, $1);\n    $current_note = $1;\n    $current_beat\
    \ = $2;\n    $music_string =~ s/^(\\D)(\\d+)(\\D*)//;\n    push(@music_list, $1);\n\
    \    $current_note = $1;\n    $current_beat = $2;\n    $music_string =~ s/^(\\\
    D)(\\d+)(\\D*)//;\n    push(@music_list, $1);\n    $current_note = $1;\n    $current_beat\
    \ = $2;\n    $music_string =~ s/^(\\D)(\\d+)(\\D*)//;\n    push(@music_list, $1);\n\
    \    $current_note = $1;\n    $current_beat = $2;\n    push(@music_list, $1);\n\
    \    push(@music_list, $2);\n    push(@music_list, $3);\n    push(@music_list,\
    \ $4);\n    return @music_list;\n}", "    my;\n    foreach my $note (split(//,\
    \ $music_string)) {\n        chomp $note;\n        my ($type, $rest) = split '$',\
    \ $note;\n        my $beats = 0;\n        foreach my $char (split(//, $type))\
    \ {\n            if ($char eq 'o') {\n                $beats += 4;\n         \
    \   }\n            elsif ($char eq 'o|') {\n                $beats += 2;\n   \
    \         }\n            elsif ($char eq '.|') {\n                $beats += 1;\n\
    \            }\n            else {\n                die \"Unexpected note: $char\\\
    n\";\n            }\n        }\n        push, $beats;\n    }\n    return;\n}",
  "    my($note_count) = 0;\n    my(@notes) = [];\n    \n    # we go through the music\
    \ string and increment the note count whenever we see a \"o\"\n    for (my $i\
    \ = 0; $i <= $#{$music_string}; $i++) {\n        next if $music_string[$i] eq\
    \ \"o\";\n        $note_count += 1 if ($music_string[$i] eq \"o|\" || $music_string[$i]\
    \ eq \".|\");\n        push(@notes, $music_string[$i]) if $music_string[$i] eq\
    \ \"o\";\n    }\n    return @notes;\n}", "    my;\n    my $current_note = 0;\n\
    \    my $current_beat = 0;\n    my $current_note_length = 1;\n    my $current_note_octave\
    \ = 0;\n    my $current_note_last_octave = 0;\n    my $previous_note = 0;\n  \
    \  my $previous_octave = 0;", "    my @music;\n    $music_string =~ s/\\s+$//;\n\
    \    my @notes = $music_string =~ m/(\\d+)/g;\n    foreach my $note (@notes) {\n\
    \        my $beat = length($note) / 4;\n        if (length($note) > 4) {\n   \
    \         $beat += length($note) - 4;\n        }\n        $music[$note] //= $beat;\n\
    \    }\n    return \\@music;\n}", "    my @notes = ();\n    my $current_note =\
    \ 0;\n    my $current_note_length = 0;\n    my @beats = ();\n    my $beat = 0;\n\
    \    my $note_length = 0;\n    my $note = 0;", "    my @notes;\n    my $music_string_length\
    \ = length($music_string);\n    my $current_position = 0;\n    my $current_beat\
    \ = 0;\n    my $current_note = 0;\n    my $number_of_notes = 0;\n    my $note_length\
    \ = 0;\n    my $last_note = 0;\n    while ($current_position < $music_string_length)\
    \ {\n        if ($music_string[$current_position] eq 'o') {\n            if ($current_beat\
    \ == 0) {\n                push @notes, 4;\n                $number_of_notes++;\n\
    \            }\n            if ($current_note == 0) {\n                push @notes,\
    \ 0;\n                $number_of_notes++;\n            }\n            $note_length\
    \ = 0;\n            $last_note = 0;\n            $current_note++;\n          \
    \  $current_position++;\n        }\n        if ($music_string[$current_position]\
    \ eq '|') {\n            if ($current_beat == 0) {\n                push @notes,\
    \ 2;\n                $number_of_notes++;\n            }\n            if ($current_note\
    \ == 0) {\n                push @notes, 0;\n                $number_of_notes++;\n\
    \            }\n            $note_length = 0;\n            $last_note = 0;\n \
    \           $current_note++;\n            $current_position++;\n        }\n  \
    \      if ($music_string[$current_position] eq '.') {\n            if ($current_beat\
    \ == 0) {\n                push @notes, 1;\n                $number_of_notes++;\n\
    \            }\n            if ($current_note == 0) {\n                push @notes,\
    \ 0;\n                $number_of_notes++;\n            }\n            $note_length\
    \ = 0;\n            $last_note = 0;\n            $current_note++;\n          \
    \  $current_position++;\n        }\n        if ($music_string[$current_position]\
    \ eq ' ') {\n            if ($current_note == 0) {\n                push @notes,\
    \ 0;\n                $number_of_notes++;\n            }\n            $note_length\
    \ = 0;\n            $current_note++;\n            $current_position++;\n     \
    \   }\n        if ($music_string[$current_position] eq 'o') {\n            if\
    \ ($current_note == 0) {\n                push @notes, 4;\n                $number_of_notes++;\n\
    \            }\n            $note_length++;\n            if ($last_note != 0)\
    \ {\n                $number_of_notes++;\n            }\n            $last_note\
    \ = 1;\n            $current_position++;\n        }\n        if ($music_string[$current_position]\
    \ eq '|') {\n            if ($current_note == 0) {\n                push @notes,\
    \ 2;\n                $number_of_notes++;\n            }\n            $note_length++;\n\
    \            if ($last_note != 0) {\n                $number_of_notes++;\n   \
    \         }\n            $last_note = 1;\n            $current_position++;\n \
    \       }\n        if ($music_string[$current_position] eq '.') {\n          \
    \  if (", "    my @notes;\n    my $index = 0;\n    while(1) {\n        my $note_symbol\
    \ = $music_string[$index];\n        last if $note_symbol =~ m/^\\W$/;\n      \
    \  $index++;\n        my $current_note = parse_note($note_symbol);\n        last\
    \ if $current_note->{type} !~ /^(sharp|flat)$/;\n        $notes{$index} = $current_note;\n\
    \    }\n    return @notes;\n}", '    my @notes = ();', '    my(@music_array);',
  '    my @music_list = ();', '    my @music_array = ();', "    my @beats_array;\n\
    \    my $current_beat = 0;\n    my %current_chord = ();", "    my @music_array\
    \ = ();\n    my $index = 0;\n    while ($music_string =~ /([.o|])/gi) {\n    \
    \    if ($1 == \".\") {\n            $music_array[$index] = 4;\n        } elsif\
    \ ($1 == \"o\") {\n            $music_array[$index] = 0;\n        } elsif ($1\
    \ == \"|\") {\n            $music_array[$index] = 1;\n        } elsif ($1 eq \"\
    |o\") {\n            $music_array[$index] = 1;\n            $music_array[$index\
    \ + 1] = 1;\n        } elsif ($1 eq \"|.\") {\n            $music_array[$index\
    \ + 1] = 1;\n        } elsif ($1 eq \"|.o\") {\n            $music_array[$index]\
    \ = 1;\n            $music_array[$index + 2] = 1;\n        } else {\n        \
    \    print \"Error. Unknown note symbol \\$1\\n\";\n        }\n        $index\
    \ += 3;\n    }\n    return @music_array;\n}", "    my($music_length);\n    my(@result);\n\
    \    my($last_note);\n    my($note_duration);\n    my($note);\n    my($duration);",
  '    my($notes, $beats, $beat_count, %results);', "    my(@song) = ();\n    my(@beats)\
    \ = ();\n    $music_string =~ /([a-zA-Z])/ || die \"No musical notes found in\
    \ $music_string\";\n    $music_string =~ s/^([a-z])/do($1)/ge;\n    my %note_count\
    \ = ();\n    my $note_count = 0;\n    foreach my $note (split(//, $music_string))\
    \ {\n        next unless $note =~ /^[\\.o|]$/;\n        my $note = substr($note,\
    \ 0, 1);\n        my $beats = $note_count;\n        $note_count += 1;\n      \
    \  push(@song, $note);\n        push(@beats, $beats);\n        $note_count++;\n\
    \    }\n    return \\@song, \\@beats;\n}", '    my(@music) = ();', "    my @beats\
    \ = ();\n    my $prev_c = 0;\n    my $prev_n = 0;\n    my $next_c = 0;\n    my\
    \ $next_n = 0;\n    \n    # Count how many notes in a string\n    while ($music_string\
    \ =~ /[o|\\.]/) {\n\tmy $c = $music_string =~ /[o|\\.]/;\n\tmy $n = $music_string\
    \ =~ /[^o|\\.]/;\n\t\n\t# If c != 0, then count note\n\tpush @beats, $c if $c\
    \ != 0;\n\tpush @beats, $n if $c != 0;\n\t\n\t# If c == 0, then count note\n\t\
    push @beats, 0 if ($c == 0) and ($n == 0);\n    }\n    \n    # Remove any trailing\
    \ zeros\n    foreach (@beats) {\n\tlast if $_ eq 0;\n    }\n    \n    return @beats;\n\
    }", "    my($beats_per_note) = 1;\n    my(@results) = ();\n    my($note);", " \
    \   my($total_beats);\n    my($music_array = ());\n    \n    # Split string into\
    \ list of musical notes\n    my (@music_array) = split /\\s*\\|?\\s*|\\|?\\s*|\\\
    s*\\|?\\s*|\\|?\\s*|\\s*\\|?\\s*/, $music_string;\n    \n    foreach my $note_string\
    \ (@music_array) {\n        if( $note_string =~ /\\|?o\\|?/ ) {\n            $total_beats\
    \ += 4;\n        } elsif( $note_string =~ /\\|?\\.\\|?/ ) {\n            $total_beats\
    \ += 2;\n        } elsif( $note_string =~ /\\|?o\\|?/ ) {\n            $total_beats\
    \ += 2;\n        } elsif( $note_string =~ /\\|?o\\|?/ ) {\n            $total_beats\
    \ += 2;\n        } elsif( $note_string =~ /\\|?o\\|?/ ) {\n            $total_beats\
    \ += 2;\n        } else {\n            $music_array .= $note_string;\n       \
    \ }\n    }\n    \n    $music_array .= $music_array->[0];\n    $music_array =~\
    \ s/ //g;\n    \n    $music_array =~ s/ //g;\n    \n    $music_array =~ s/^o\\\
    |?//g;\n    $music_array =~ s/^\\.\\|?//g;\n    $music_array =~ s/^o\\|?//g;\n\
    \    $music_array =~ s/^o\\|?//g;\n    \n    my @music_array;\n    \n    $music_array\
    \ = split /\\s*\\|?\\s*|\\|?\\s*|\\s*\\|?\\s*|\\s*\\|?\\s*/, $music_string;\n\
    \    \n    foreach my $note_string (@music_array) {\n        if( $note_string\
    \ =~ /\\|?o\\|?/ ) {\n            $music_array->[0] =~ s/\\|?//g;\n          \
    \  $music_array->[0] =~ s/\\|?//g;\n            $music_array->[0] =~ s/\\|?//g;\n\
    \            $music_array->[0] =~ s/\\|?//g;\n            $music_array->[0] =~\
    \ s/\\|?//g;\n            $music_array->[0] =~ s/\\|?//g;\n            $music_array->[0]\
    \ =~ s/\\|?//g;\n", "    my @music = ();\n    my ($music_note, $beats);\n    my\
    \ $note = '';\n    my $rest = '';\n    my $temp = '';\n    my $rest_note = '';",
  '    my(@track) = $music_string =~ /(\d)\d(?::\d)\1?/g;', "    my(@notes) = ();\n\
    \    \n    my (@notes_str, $notes_str);\n    $notes_str = lc($music_string);\n\
    \    @notes_str = split(//, $notes_str);\n    for my $i (0 .. $#notes_str) {\n\
    \        my $note = substr($notes_str[$i], 0, 1);\n        my $length = substr($notes_str[$i],\
    \ 1, 1);\n        \n        if ($note eq 'o') {\n            if ($length eq '4')\
    \ {\n                push(@notes, 4);\n            }\n            elsif ($length\
    \ eq '2') {\n                push(@notes, 2);\n            }\n            elsif\
    \ ($length eq '1') {\n                push(@notes, 1);\n            }\n      \
    \      else {\n                die \"Unexpected note length (expected 4 or 2,\
    \ got $length)\\n\";\n            }\n        }\n        elsif ($note eq 'o|')\
    \ {\n            if ($length eq '2') {\n                push(@notes, 2);\n   \
    \         }\n            else {\n                die \"Unexpected note length\
    \ (expected 2, got $length)\\n\";\n            }\n        }\n        elsif ($note\
    \ eq '.|') {\n            push(@notes, 1);\n        }\n        else {\n      \
    \      die \"Unexpected note (expected 'o' or 'o|' or '|' or '.', got '$note')\\\
    n\";\n        }\n    }\n    return @notes;\n}\n</code>\n<|/ a tags=algorithm,ruby,sorting,perl\
    \ |>\n<| c |>\nHmm. That's a nice idea but unfortunately not what I need. The\
    \ code you wrote should do what you propose for input like 'o', but unfortunately\
    \ it doesn't work for input like 'o|o|o|o|.|.|.|.', because there is no such thing\
    \ as a '|' in the input string. I've updated my original question with more clarifications.\
    \ Thanks for your answer\n<|/ c |>\n<| c |>\n, I guess I misread the question\
    \ to mean that you'd get `[4, 2, 1, 2, 2, 2, 1, 1, 1]` if the input string was\
    \ `'o o|o|o|.|.|.|.`. I think the idea is the same, though.\n<|/ c |>\n<| c |>\n\
    Yeah, I misread the input too. Your code works perfect for inputs like `'o o|o|o|.|.|.|.'`.\
    \ I've updated my original question to show an example of the expected output\
    \ for that input string.\n<|/ c |>\n<| a |>", "    my($music_string) =~ tr/ //d;\n\
    \    my(@music_array) = (0);\n    my(@split_music) = (0);", '    my(@parse_array)
    = ();', "    my($notes) = [];\n    my($prev_note) = undef;\n    my($last_beat)\
    \ = undef;\n    my($beat) = undef;\n    my($note);\n    my($note_index);\n   \
    \ my($note_length) = undef;\n    my($note_string);", "    my(@music) = ();\n \
    \   my($note);\n    my($beat);\n    my($beats);\n    my($current_beat);\n    my\
    \ $count = 0;\n    # iterate over all musical notes\n    for(my $i = 0; $i <=\
    \ length($music_string) - 3; $i++) {\n        if($music_string[$i] eq \"o\") {\n\
    \            $note = $music_string[++$i];\n            $beat = $music_string[++$i];\n\
    \            $current_beat = 1;\n        } elsif($music_string[$i] eq \".\") {\n\
    \            if($note) {\n                push(@music, $current_beat);\n     \
    \       }\n            $current_beat = 1;\n        } elsif($music_string[$i] eq\
    \ \"|\") {\n            if($note and $beat ne \"4\") {\n                push(@music,\
    \ $current_beat);\n            }\n            $note = \"\";\n            $beat\
    \ = $music_string[++$i];\n            $current_beat = 1;\n        } else {\n \
    \           die(\"Bad music note detected\");\n        }\n    }\n    if($note)\
    \ {\n        push(@music, $current_beat);\n    }\n    return @music;\n}", "  \
    \  my($music_array = ());\n    my($music_note_count = 0);\n    my($music_beat_count\
    \ = 4);\n    my($current_note = 'o');\n    my($last_note = 'o');\n    $music_string\
    \ =~ s/(.)\\|(.)/ $1 $2 /mg;\n    while($music_string =~ s/(.)\\|(.)/ $1 $2 /mg)\
    \ {\n        my($last_note, $current_note) = split(\" \", $music_string);\n  \
    \      if($last_note eq $current_note) {\n            $music_note_count += 1;\n\
    \            $music_beat_count += 1;\n        } elsif($last_note ne $current_note)\
    \ {\n            if($music_note_count) {\n                $music_array .= $music_beat_count;\n\
    \                $music_beat_count = 1;\n                $music_note_count = 1;\n\
    \            }\n            $music_note_count = 1;\n            $music_array .=\
    \ $music_note_count;\n            $music_note_count = 1;\n            $music_beat_count\
    \ = 4;\n        }\n    }\n    if($music_note_count) {\n        $music_array .=\
    \ $music_beat_count;\n        $music_beat_count = 1;\n        $music_note_count\
    \ = 1;\n    }\n    return $music_array;\n}", "    my($music_array) = ();\n   \
    \ my($note) = \"\";\n    my($note_count) = 0;\n    my($beat_length) = 0;\n   \
    \ my($beat_count) = 0;\n    my($notes) = 0;\n    \n    # count the number of notes\
    \ in a string separated by |\n    $notes = count(split /\\|/, $music_string);\n\
    \    \n    # split note strings into an array\n    foreach $note (split /\\|/,\
    \ $music_string) {\n        if ($note eq '.') {\n            $music_array [$note_count]\
    \ ++;\n            $note_count++;\n        } elsif ($note eq 'o') {\n        \
    \    $music_array [$note_count] ++;\n            $note_count++;\n            $music_array\
    \ [$note_count + 1] ++;\n            $note_count++;\n            $beat_length++;\n\
    \        } elsif ($note eq 'o|') {\n            $music_array [$note_count] ++;\n\
    \            $note_count++;\n            $music_array [$note_count + 1] ++;\n\
    \            $note_count++;\n            $music_array [$note_count + 2] ++;\n\
    \            $note_count++;\n            $beat_length += 2;\n        } elsif ($note\
    \ eq 'o|o') {\n            $music_array [$note_count] ++;\n            $note_count++;\n\
    \            $music_array [$note_count + 1] ++;\n            $note_count++;\n\
    \            $music_array [$note_count + 2] ++;\n            $note_count++;\n\
    \            $music_array [$note_count + 3] ++;\n            $note_count++;\n\
    \            $beat_length += 3;\n        } elsif ($note eq 'o|o|') {\n       \
    \     $music_array [$note_count] ++;\n            $note_count++;\n           \
    \ $music_array [$note_count + 1] ++;\n            $note_count++;\n           \
    \ $music_array [$note_count + 2] ++;\n            $note_count++;\n           \
    \ $music_array [$note_count + 3] ++;\n            $note_count++;\n           \
    \ $music_array [$note_count + 4] ++;\n            $note_count++;\n           \
    \ $beat_length += 4;\n        } elsif ($note eq 'o|o|o|') {\n            $music_array\
    \ [$note_count] ++;\n            $note_count++;\n            $music_array [$note_count\
    \ + 1] ++;\n            $note_count++;\n            $music_array [$note_count\
    \ + 2] ++;\n            $note_count++;\n            $music_array [$note_count\
    \ + 3] ++;\n            $note_count++;\n            $music_array [$note_count\
    \ + 4] ++;\n            $", "    my @music = ();\n    my $note_length = length($music_string);",
  '    my($current_note, $current_beat, $current_beats_count) = (0, 0, 0);', '    my($last_note,
    $last_beat_length, $last_last_note, $beats_last_note, $last_beat_position);',
  "    my($music_notes) = ();\n    my(@music_beat_numbers) = ();", "    $music_string\
    \ =~ s/\\^|$/$music_string = '' if $music_string eq '';\n    my(@notes) = split\
    \ / /, $music_string;\n    my $beat_length = 1;\n    for (@notes) {\n        $beat_length\
    \ *= 3 if $_ eq 'o';\n        $beat_length *= 2 if $_ eq 'o|';\n    }\n    return\
    \ ($beat_length, @notes);\n}", '    my(@music_array);', "    my($music_array);\n\
    \    my($number_of_beats);\n    my($current_beat);\n    my($first_note);\n   \
    \ my($second_note);\n    my($third_note);\n    my($fourth_note);\n    my($fifth_note);",
  "    my(@return);\n    my($i);\n    my($j);\n    my($count);\n    my($last_note);\n\
    \    my($note_length);\n    my($note_half);\n    my($notes_per_quarter);\n   \
    \ my($last_quarter);\n    my($notes_per_beat);", "    my(@music_string) = split(/\\\
    s+/, $music_string);\n    my(@beats) = 0;\n    my(@results);\n    foreach my $str\
    \ (@music_string){\n        my $note = chop $str;\n        my $note_class = '';\n\
    \        my $last_class = 'o';\n        if ($note eq 'o'){\n            $note_class\
    \ = 'o';\n        }elsif ($note eq '|'){\n            $note_class = 'o|';\n  \
    \      }elsif ($note eq '.'){\n            $note_class = '.|';\n        }\n  \
    \      my $last_note = $note;\n        $note = substr($note, 0, 1);\n        foreach\
    \ my $c (split //, $note){\n            my $class = $note_class;\n           \
    \ $class = $class . $c;\n            if ($last_class ne $class){\n           \
    \     if ($last_class ne 'o'){\n                    $last_class .= '|';\n    \
    \            }\n                $last_note = $class;\n            }else{\n   \
    \             $last_note = $note;\n            }\n        }\n        if ($last_note\
    \ eq $note){\n            $beats[-1] += 1;\n        }else{\n            push(@results,\
    \ $beats[-1]);\n            $beats[-1] = 0;\n        }\n    }\n    push(@results,\
    \ $beats[-1]);\n    return @results;\n}\n</cell>\n<text>\nPart II: Testing the\
    \ functions", '    my(@results);', "    my($song_array) = ();\n    my($current_note)\
    \ = 0;\n    my($current_beat) = 0;\n    my $current_note_name = undef;\n    \n\
    \    foreach my $char (split(//, $music_string)) {\n        if ($char eq 'o')\
    \ {\n            $song_array[$current_note] .= '.' x $current_beat;\n        \
    \    $current_note += 1;\n            $current_beat += 1;\n        }\n       \
    \ elsif ($char eq '|') {\n            $song_array[$current_note] .= '.' x $current_beat;\n\
    \            $current_note += 1;\n            $current_beat = 0;\n        }\n\
    \        elsif ($char eq '.') {\n            $song_array[$current_note] .= '.'\
    \ x $current_beat;\n            $current_beat = 0;\n        }\n        elsif ($char\
    \ eq '|o') {\n            $song_array[$current_note] .= '.' x $current_beat;\n\
    \            $current_note += 1;\n            $current_beat += 1;\n        }\n\
    \        elsif ($char eq '.o') {\n            $song_array[$current_note] .= '.'\
    \ x $current_beat;\n            $current_beat = 0;\n        }\n        elsif ($char\
    \ eq 'o|') {\n            $song_array[$current_note] .= '.' x $current_beat;\n\
    \            $current_note += 1;\n            $current_beat += 1;\n        }\n\
    \        elsif ($char eq '.|') {\n            $song_array[$current_note] .= '.'\
    \ x $current_beat;\n            $current_beat = 0;\n        }\n        else {\n\
    \            $current_note += 1;\n        }\n    }\n    return $song_array;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks, this seems to work. Just out of\
    \ curiosity why do you use \\w instead of just \\w? It seems a little more readable\
    \ and I don't see a difference in output.\n<|/ c |>\n<| c |>\n`\\p{L}` covers\
    \ almost all letters, `\\p{N}` covers numbers, `\\p{P}` covers punctuation, `\\\
    p{C}` covers control characters, `\\p{S}` covers spaces and tabs. You may want\
    \ to use `\\w` if you want it covers new line as well.\n<|/ c |>\n<| a tags=string,ruby,regex\
    \ |>\n<code>\n/o(\\.?(|o){2}|\\.o|o\\|", "    my $music_array = ();\n    my $index\
    \ = 0;\n    my $char_index = 0;\n    while (1) {\n        if ($music_string[$char_index]\
    \ eq '.') {\n            $music_array[$index] += 4;\n            $char_index++;\n\
    \            $index++;\n        }\n        elsif ($music_string[$char_index] eq\
    \ 'o') {\n            $music_array[$index] += 1;\n            $char_index++;\n\
    \            $index++;\n        }\n        else {\n            die \"Unexpected\
    \ character\";\n        }\n        if ($index > @$music_array - 1) {\n       \
    \     die \"Incorrect number of notes\";\n        }\n        $char_index++;\n\
    \        if ($char_index >= @$music_string) {\n            break;\n        }\n\
    \    }\n    return $music_array;\n}\n</code>\n<|/ a |>\n<| c |>\n: Oh yeah, I\
    \ did mean that. Thank you for pointing that out. :D\n<|/ c |>\n<| c |>\n: And\
    \ thank you for pointing out a couple of other small bugs in my code too. I fixed\
    \ them now.\n<|/ c |>\n<| a dscore=1 tags=string,parsing,perl |>\n<code>", '    my($music_list)
    = [];', "    my(@parsed_music) = ();\n    \n    while(length($music_string) >\
    \ 0) {\n        my $char = $music_string[0];\n        # '.' or 'o'\n        if($char\
    \ =~ m/[\\.]$/) {\n            my $current_beat = 1;\n            my $note_type\
    \ = 0;\n            if(length($music_string) == 1) {\n                push (@parsed_music,\
    \ $current_beat);\n                push (@parsed_music, $note_type);\n       \
    \         $music_string = \"\";\n            }\n        }\n        # other notes\n\
    \        else {\n            my $current_beat = 1;\n            my $note_type\
    \ = 0;\n            if(length($music_string) == 1) {\n                if($char\
    \ == \".\") {\n                    push (@parsed_music, $current_beat);\n    \
    \                push (@parsed_music, $note_type);\n                    $music_string\
    \ = \"\";\n                }\n                elsif($char eq \"|\") {\n      \
    \              $music_string = substr($music_string, 0, length($music_string)\
    \ - 1);\n                    $music_string =~ s/\\|$//;\n                    $note_type\
    \ = 2;\n                    $music_string = \"\";\n                }\n       \
    \         elsif($char eq \"o\") {\n                    $music_string = \"\";\n\
    \                    $note_type = 1;\n                }\n                else\
    \ {\n                    $music_string = \"\";\n                }\n          \
    \  }\n            else {\n                $music_string = substr($music_string,\
    \ 0, length($music_string) - 1);\n                my $current_note = parse_music_note($music_string);\n\
    \                push (@parsed_music, $current_beat);\n                push (@parsed_music,\
    \ $note_type);\n                $music_string = \"\";\n            }\n       \
    \ }\n    }\n    return @parsed_music;\n}", '    my($music_note) = ();', "    my\
    \ %notes = ();\n    my $counter = 1;\n    my $beat = 1;\n    my $prev_note = -1;\n\
    \    my $prev_beat = -1;\n    my $note_type = \"o\";\n    my $note_duration =\
    \ 1;\n    while ($music_string =~ /([o|.]|\\*)/g) {\n        if ($1 eq \"o\")\
    \ {\n            # whole note, lasts four beats\n            $note_type = \"o\"\
    ;\n            $note_duration = 4;\n        }\n        elsif ($1 eq \"o|\") {\n\
    \            # half note, lasts two beats\n            $note_type = \"o\";\n \
    \           $note_duration = 2;\n        }\n        elsif ($1 eq \".|\") {\n \
    \           # quater note, lasts one beat\n            $note_type = \"o\";\n \
    \           $note_duration = 1;\n        }\n        else {\n            die \"\
    Bad note $1 at $counter in music string\\n\";\n        }", "    my(@notes) = ();\n\
    \    my($note_count, @beats);\n    my($note, @beat, @note_beat_pairs);", "   \
    \ my($last_note, @beats);\n    my($index) = -1;\n    my($beat) = -1;", "    my\
    \ @music = ();\n    my @notes = ();\n    my $note_length = length($music_string);\n\
    \    my $current_note = 0;\n    my @current_notes = ();\n    my %music_table =\
    \ (\"o\" => 0, \"o|\" => 0, \".|\" => 0, );\n    my $total_notes = 0;", "    my($results);\n\
    \    my($beats_per_bar) = 128;\n    my($previous_bar);\n    my($previous_note);\n\
    \    my($current_note);", "    my @music_notes = ();\n    $music_string =~ s/\\\
    s+//g;\n    my @tokens = grep { length($_) } split(//, $music_string);\n    my\
    \ @note_names = map { $_ =~ s/\\^//g; $_ } split('^', @tokens);\n    for (my $i\
    \ = 0; $i < scalar(@note_names); ++$i) {\n        my $note_length = length($note_names[$i])\
    \ + 1;\n        $music_notes[$i] = sprintf(\"%%%ds\", $note_length);\n    }\n\
    \    for my $i (0 .. scalar(@note_names) - 1) {\n        my $note_name = $note_names[$i];\n\
    \        my $note_length = length($note_name) + 1;\n        my $beat = 0;\n  \
    \      while ($i < scalar(@note_names) - 1) {\n            last if ($note_names[$i]\
    \ eq $note_names[$i + 1]);\n            $beat += 1;\n            $i += 1;\n  \
    \      }\n        $music_notes[$i] = $music_notes[$i] . $beat . \".\";\n    }\n\
    \    return @music_notes;\n}", "    my @music;\n    my $note_counter = 0;\n  \
    \  my $last_note = '';\n    my $last_beat = 0;\n    for my $char (split //, $music_string)\
    \ {\n        my $note_type = substr($char, 0, 1);\n        my $note_string = substr($char,\
    \ 1, length($char));\n        my $note_length = length($note_string);\n      \
    \  if ($note_string eq 'o') {\n            $note_counter++;\n        } elsif ($note_string\
    \ eq 'o|') {\n            $note_counter += 2;\n        } elsif ($note_string eq\
    \ '.|') {\n            $note_counter += 1;\n        } else {\n            die(\"\
    Unknown note type: $note_type\");\n        }\n        if ($note_counter > $last_beat)\
    \ {\n            $last_beat = $note_counter;\n        }\n        $last_note =\
    \ $note_string;\n    }\n    if ($last_beat == 0) {\n        $last_beat = 1;\n\
    \    }\n    push(@music, $last_beat);\n    return @music;\n}\n</code>\n<|/ a tags=parsing,algorithm,perl,arrays\
    \ |>\n<| a tags=parsing,algorithm,perl,arrays |>\nI like your idea and I made\
    \ a small program to test the algorithm\n<code>\nuse strict;\nuse warnings;\n\
    use feature 'say';", "    chomp($music_string);\n    $music_string .= \" \" if\
    \ $music_string !~ /\\s+$/;\n    my @notes;\n    my $last_note = -1;\n    $music_string\
    \ =~ s/(^|\\s)(\\d+)(\\D*)($|\\s+)/$1$2$3$4/g;\n    for(my $note = split / /,\
    \ $music_string) {\n        if($note =~ /^(\\d+)$/) {\n            push @notes,\
    \ $1;\n        }\n        if($note =~ /^\\|(\\d+)$/) {\n            push @notes,\
    \ ($1 || 1) * 2;\n        }\n        if($note =~ /^\\|(\\d+)\\|(\\d+)$/) {\n \
    \           push @notes, ($1 || 1) * 2 + $2;\n        }\n        if($note =~ /^\\\
    |(\\d+)\\|(\\d+)\\|(\\d+)$/) {\n            push @notes, ($1 || 1) * 2 + $2 +\
    \ ($2 || 1) * 2;\n        }\n        if($note =~ /^\\|(\\d+)\\|(\\d+)\\|(\\d+)\\\
    |(\\d+)$/) {\n            push @notes, ($1 || 1) * 2 + $2 + ($2 || 1) * 2 + ($3\
    \ || 1) * 2;\n        }\n        if($note =~ /^\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\\
    d+)\\|(\\d+)$/) {\n            push @notes, ($1 || 1) * 2 + $2 + ($2 || 1) * 2\
    \ + $3 + ($3 || 1) * 2;\n        }\n        if($note =~ /^\\|(\\d+)\\|(\\d+)\\\
    |(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)$/) {\n            push @notes, ($1 || 1) *\
    \ 2 + $2 + ($2 || 1) * 2 + $3 + ($3 || 1) * 2 + $4 + ($4 || 1) * 2;\n        }\n\
    \        if($note =~ /^\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\\
    |(\\d+)$/) {\n            push @notes, ($1 || 1) * 2 + $2 + ($2 || 1) * 2 + $3\
    \ + ($3 || 1) * 2 + $4 + ($4 || 1) * 2 + ($5 || 1) * 2;\n        }\n        if($note\
    \ =~ /^\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)$/)\
    \ {\n            push @notes, ($1 || 1) * 2 + $2 + ($2 || 1) * 2 + $3 + ($3 ||\
    \ 1) * 2 + $4 + ($4 || 1) * 2 + ($5 || 1) * 2 + ($6 || 1) * 2;\n        }\n  \
    \      if($", '    my($music) = parse_music_string($music_string);', "    my @notes;\n\
    \    # Parsing music string and finding how many beats each note lasts.\n    #\
    \ Each note is represented by a special ascii code: 'o' means whole note, 'o|'\
    \ means half note\n    # and '|.' means quarter. Here are some examples:\n   \
    \ # [o o|, |.]\n    # [|.,|, o o]\n    # [|..,|, |.]\n    my $note_count = 0;\n\
    \    my $current_note = '';\n    my @notes_temp = ();\n    my $i = 0;\n    my\
    \ $c = chr(0);\n    my $note;\n    while (length($music_string) > 0) {\n     \
    \   if ($music_string =~ /^(.*\\|.*|\\[.*\\])/) {\n            if (length($1)\
    \ > 0) {\n                my $temp = $1;\n                my @temp = split(/\\\
    |/, $temp);\n                push(@notes_temp, @temp);\n                $note\
    \ = pop(@notes_temp);\n                $note_count++;\n            }\n       \
    \     $note = shift(@notes_temp);\n            $note_count++;\n        }\n   \
    \     else {\n            $note = $music_string;\n            $note_count++;\n\
    \        }\n        $music_string = $music_string . substr($c, length($music_string));\n\
    \        if ($note eq 'o') {\n            push(@notes, $note_count);\n       \
    \ }\n        elsif ($note eq 'o|') {\n            push(@notes, $note_count * 2);\n\
    \        }\n        elsif ($note =~ /^(\\[.*\\])$/) {\n            my $note =\
    \ shift(@notes_temp);\n            if ($note =~ /o|\\|/) {\n                $note_count\
    \ = length($note) - 1;\n            }\n            else {\n                $note_count\
    \ = length($note);\n            }\n            push(@notes, $note_count);\n  \
    \      }\n    }\n    return @notes;\n}", "    my($music_string2); # just to temporarily\
    \ hold notes in order to split and remove '|'\n    my(@music_notes);", "    my;\n\
    \    my $current_note = 0;\n    my %note_count;\n    my $note;", '    my(@beat_counts);',
  "    my(@music_notes);\n    while($music_string =~ /(.)/g) {\n        push(@music_notes,\
    \ $1);\n    }", "    my(@notes);\n    my($o);\n    my($notes_counter);"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
