name: HumanEval_89_encrypt
language: pl
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# >>> encrypt(\"hi\")\n# \"lm\"\n# >>> encrypt(\"\
  asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt(\"gf\")\n# \"kj\"\n# >>> encrypt(\"\
  et\")\n# \"ix\"\nsub encrypt {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encrypt;\n\
  \        if(eq_deeply($candidate->(\"hi\"),\"lm\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdfghjkl\"),\"\
  ewhjklnop\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n    \
  \    if(eq_deeply($candidate->(\"gf\"),\"kj\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"et\"),\"ix\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  faewfawefaewg\"),\"jeiajeaijeiak\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"hellomyfriend\"),\"lippsqcjvmirh\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  a\"),\"e\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my @alphabet = map chr, [ 0, 2, 6, 4, 8, 1, 3, 5, 7, 9, 11 ];\n\
    \    my @rotated_alphabet = map { $alphabet[ $_ % 26 ] } (0..2);\n    my $i =\
    \ 0;\n    my @rotated_s = map { $rotated_alphabet[ $_ % 26 ] } split(//, $s);\n\
    \    return join(\"\", @rotated_s);\n}", "    my(@alphabet) = split(//,$shift);\n\
    \    my(@result);\n    \n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $alphabet[$i];\n    }\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {\n        $result[$i]\
    \ = $result[$i][$i%6];\n    }\n    $result[$i] = $alphabet[$i%6];\n    $result[$i]\
    \ = $result[$i][$i%6];\n    for(my $i=0;$i<@alphabet;$i++) {", "    $s =~ tr/a-zA-Z/n-zA-MN-Z/;\n\
    \    return $s;\n}\n</code>\nTo test that the code is working, lets start with\
    \ a few strings of characters from the dictionary and rotate them through our\
    \ function:\n<code>\nuse Data::Dumper;\nmy = ( 'h', 'e', 'l', 'o', 'e', 'l', 'o',\
    \ 'h', 'e' );\nprint Dumper \\@strings;\nforeach my $string (@strings) {\n   \
    \ print encrypt(\"$string\") . \"\\n\";\n}\n</code>\nNow the output should be:\n\
    <code>\n$VAR1 = [\n          'h',\n          'e',\n          'l',\n          'o',\n\
    \          'e',\n          'l',\n          'o',\n          'h',\n          'e'\n\
    \        ];\nlm\newhjklnop\ngf\nkj\nix\n</code>\nIf you have problems getting\
    \ your code to work let me know.\n<|/ a tags=perl,perl-data-structures |>\n<|\
    \ c |>\nThank you for your answer. Sorry if I didn't make it clear, english isn't\
    \ my native language :).\n<|/ c |>\n<| c |>\nNo worries, english is not your native\
    \ language either, but it's a good language, and there are many people here who\
    \ would like to help.\n<|/ c |>\n<| a tags=perl,perl-data-structures dscore=2\
    \ |>\nThis is probably a little bit off-the-beaten path, but I've been working\
    \ on a permutation problem recently (for another language, obviously), so thought\
    \ it might help. This is Perl5 (which means no module imports), but I believe\
    \ it's close to what you're looking for. I've also included a function that can\
    \ convert a number to a string.\n<code>", '    my($newalphabet);', "    my($c);\n\
    \    my($l, $i);\n    my(@enc, @dec);", "    my($len);\n    my($alpha);\n    my($result);",
  "    my(@chars);\n    my($c1);\n    my($c2);\n    my($c3);\n    my($c4);\n    my($c5);\n\
    \    my($c6);\n    my($c7);\n    my($c8);\n    my($c9);\n    my($c10);\n    my($c11);\n\
    \    my($c12);\n    my($c13);\n    my($c14);\n    my($c15);\n    my($c16);\n \
    \   my($c17);\n    my($c18);\n    my($c19);\n    my($c20);\n    my($c21);\n  \
    \  my($c22);\n    my($c23);\n    my($c24);\n    my($c25);\n    my($c26);\n   \
    \ my($c27);\n    my($c28);\n    my($c29);\n    my($c30);\n    my($c31);\n    my($c32);\n\
    \    my($c33);\n    my($c34);\n    my($c35);\n    my($c36);\n    my($c37);\n \
    \   my($c38);\n    my($c39);\n    my($c40);\n    my($c41);\n    my($c42); \n \
    \   my($c43);\n    my($c44);\n    my($c45);\n    my($c46);\n    my($c47);\n  \
    \  my($c48);\n    my($c49);\n    my($c50);\n    my($c51);\n    my($c52); \n  \
    \  my($c53);\n    my($c54);\n    my($c55);\n    my($c56);\n    my($c57);\n   \
    \ my($c58);\n    my($c59);\n    my($c60);\n    my($c61);\n    my($c62); \n   \
    \ my($c63);\n    my($c64);\n    my($c65);\n    my($c66);\n    my($c67);\n    my($c68);\n\
    \    my($c69);\n    my($c70);\n    my($c71);\n    my($c72); \n    my($c73);\n\
    \    my($c74);\n    my($c75);\n    my($c76);\n", "    # Find the length of $s\n\
    \    my $llen = length($s);\n    # Create a copy of $s, where the letters are\
    \ rotated down by 2 places\n    my $x = $s;\n    my $y = $s;\n    # Copy $s into\
    \ $x, but swap all the letters with each other\n    # in the alphabet\n    # Note:\
    \ this could be written as $x = $y . substr($y, 0, $llen-$#y) . $x \n    while\
    \ ($y =~ /([a-z])/) {\n\tmy $pos = $1;\n\tsubstr($x, $pos, 1) = substr($y, $pos,\
    \ 1);\n\t$pos -= 2;\n\tsubstr($y, $pos, 1) = $1;\n    }\n    # Return the copy\
    \ with $y rotated to the left by 2 places and \n    # with $x rotated up by 2\
    \ places\n    return $x . substr($y, 0, $llen-$#y) . $x;\n}", "    my $cipher\
    \ = $alphabet_rotated;\n    my @chars = split //, $s;\n    my $cipher = \"\";\n\
    \    for my $char (@chars) {\n        $cipher .= $cipher{$char} if exists $cipher{$char};\n\
    \    }\n    return $cipher;\n}", "    my $enc = \"\";\n    my $inc = 2;\n    my\
    \ $c = 0; # counting variables\n    my $alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    my $alphanum = ($alpha =~ /[A-Z]/g);\n    my $l = 0;\n    my $e = ($alpha\
    \ =~ /[A-Z]/g);\n    while ($l < length($s)) {\n        $c = $c + $e[$l];\n  \
    \      \n        if ( $c >= length($alpha) ) {\n            $c = $c - length($alpha);\n\
    \            $e = $alpha =~ /[A-Z]/;\n        }\n        $c = $c + 1;\n      \
    \  \n        $l = $l + $inc;\n    }\n    \n    foreach (split(//, $s)) {\n   \
    \     $enc .= substr($alpha, $c, 1);\n    }\n    return $enc;\n}", "    my($c);\n\
    \    my $i = 0;\n    foreach $c (split //, $s) {\n\t$c = substr($alphabet,$i++,2)\
    \ . $c;\n    }\n    $c;\n}", "    my @s = split(//, $s);\n    my $c = shift(@s);\n\
    \    my $len = scalar(@s);\n    my $t = \"\";", "    my($cx);\n    my($ret);",
  "    $s =~ s/^/+/g;\n    my($l) = length($s);\n    my ($i, $k, $c, $p);\n    $p\
    \ = 0;\n    while($l > 0) {\n        $c = substr($s, $p, 1);\n        $k = substr($s,\
    \ 0, $p);\n        $i = index($alphabet, $c);\n        ++$p;\n        if($i >\
    \ 0 && $i < $l) {\n            $alphabet[$i] = $alphabet[$i-1];\n        } else\
    \ {\n            push @$alphabet, $c;\n            ++$p;\n        }\n        ++$p;\n\
    \        $l--;\n    }\n    my $s = \"\";\n    while($p > 0) {\n        $s = substr($alphabet,\
    \ $p, 1) . $s;\n        --$p;\n    }\n    return $s;\n}", "    my(@rotated_alphabet)\
    \ = (\"abcdefghijklmnopqrstuvwxyz\");\n    my(@rotated_alphabet) = splice(@rotated_alphabet,\
    \ 0 , 2); \n    my($c) = 0;\n    my($r) = length($s);\n    my $result = \"\";\n\
    \    while($r =~ s/(.)(?!$rotated_alphabet)(.)/g{substr($rotated_alphabet[$c++],\
    \ ($2 =~ tr/a-z/n-za-m)/2, 1)}{$2}/g) {\n        $result .= $1;\n    }\n    return\
    \ $result;\n}", "    my @chars = split(//, $s);\n    my $rotated_alphabet = join\
    \ '', map {\n        my $n = $n->{num};\n        return substr($alphabet, $n %\
    \ length($alphabet), 1) \n            if $n % length($alphabet) != 0;\n      \
    \  my $char = substr($chars, $n % length($chars), 1);\n        $alphabet[$n %\
    \ length($alphabet)] == $char ? $char : $char;\n    } @chars;\n    return join('',\
    \ @chars);\n}", "    my $l = length($s);\n    my $alphabet = join\"|\", qw(a b\
    \ c d e f g h i j k l m n o p q r s t u v w x y z);\n    my $chars = \"$alphabet\"\
    ;\n    my $pattern = \"($chars)\";\n    return ($l =~ tr/$(/$pattern/);\n}", " \
    \   my $ret = \"\";\n    my $i;\n    my $j;\n    for ($i = 0; $i < length($s);\
    \ $i++) {\n        # Rotate each letter by two positions.\n        $ret .= substr($alphabet,\
    \ int(rand($length)), 1);\n    }\n    return $ret;\n}", "    my(@alphabet) = (\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\");\n    my $i = 0;\n    my $c = 0;\n    my @rot = ( 0,\
    \ 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 );\n    for(my $c = 0; $c\
    \ < length($s); $c++) {\n        my $letter = $alphabet[$c];\n        my $x =\
    \ $c % 25;\n        my $y = $rot[$x];\n        $alphabet[$c] = $alphabet[$y];\n\
    \        $alphabet[$y] = $letter;\n        $i++;\n    }\n    my $encrypted = '';\n\
    \    for(my $c = 0; $c < length($s); $c++) {\n        $encrypted .= $alphabet[$c];\n\
    \    }\n    return $encrypted;\n}", "    my(@chars) = split(//, $s);\n    my(@newchars);\n\
    \    my $i = 0;\n    for (@chars) {\n        my($ch) = $_;\n        my $j = $i\
    \ + 1;\n        while ($j > 0 && ($j % 2) != 0) {\n            my $newch = $chars[$j\
    \ - 1];\n            $chars[$j - 1] = $chars[$j];\n            $chars[$j] = $newch;\n\
    \            $j--;\n        }\n        $newchars[$i] = $ch;\n        $i++;\n \
    \   }\n    return join(\"\", @newchars);\n}", "    # Alphabet is rotated in such\
    \ a way as to move each letter\n    # down by two multiplied to two places.\n\
    \    return map { substr($s, $_ % length($s), 1) }\n        map { chr(ord(substr($s,\
    \ $_, 1)) + 2) }\n        0..length($s)-1;\n}", "    my($new_letter);\n    my($alphabet)\
    \ = ( \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" );\n    my($j);\n\
    \    my($k);\n    \n    foreach $j (@{ $alphabet }) {\n        foreach $k (@{\
    \ $alphabet }) {\n            if ( $j != $k ) {\n                \n          \
    \      # If $j and $k do not match, then we cannot rearrange the alphabet in any\
    \ way.\n                # The strings are different, so we need to break the loop.\n\
    \                last if $s != encrypt($j);\n                \n              \
    \  # Rotate the letters of $j to make them match the letters of $k\n         \
    \       $new_letter = substr( $s, 0, length $s );\n                $new_letter\
    \ .= substr( $k, 0, 1 );\n                $new_letter .= substr( $k, 1, 1 );\n\
    \                $new_letter .= substr( $s, 1, length $s );\n                $new_letter\
    \ .= substr( $s, 0, length $s );\n                \n                # Now swap\
    \ the letters of $j and $k\n                $new_letter .= substr( $j, 0, length\
    \ $j );\n                $new_letter .= substr( $k, 1, length $k );\n        \
    \        $new_letter .= substr( $j, 1, length $j );\n                $new_letter\
    \ .= substr( $k, 0, length $k );\n                $s = $new_letter;\n        \
    \    }\n        }\n    }\n    return $s;\n}", "    my $len = length($s);\n   \
    \ my @alphabet = (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"\
    , \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\");\n    my @shifts = (1, 2, 4, 8, 16,\
    \ 32, 64, 128);\n    my $i = 0;\n    my $len = length($s);\n    my @rotated;\n\
    \    while (@shifts > $i) {\n        my $l = shift @shifts;\n        $len = $len\
    \ - (($len % $l) + $l);\n        $i++;\n    }\n    while (@alphabet > $i) {\n\
    \        my $l = shift @alphabet;\n        $len = $len - (($len % $l) + $l);\n\
    \        $i++;\n    }\n    for (my $j = 0; $j < $len; $j++) {\n        my $l =\
    \ $alphabet[$j];\n        my $r = '';\n        while (@alphabet > $i) {\n    \
    \        my $l = shift @alphabet;\n            $r = $alphabet[$i-1] . $r;\n  \
    \          $i--;\n        }\n        $rotated[$j] = $r;\n    }\n    my $r = \"\
    \";\n    for (my $j = 0; $j < $len; $j++) {\n        $r .= $rotated[$j];\n   \
    \ }\n    return $r;\n}\n</cell>\n<text>\nExercise 4\nWrite a program that reads\
    \ a string and returns the first and last\ncharacters reversed. The input string\
    \ is assumed to be ASCII.", "    my $l = length($s);\n    my $n = $l / 2;\n  \
    \  my $r = \"\";\n    $r .= substr($s,0,$n);\n    $r .= substr($s,$n,$l);\n  \
    \  $r .= substr($s,$n*2,$l-n);\n    return $r;\n}", "    $s = ~tr/a-zA-Z/A-Z/;\n\
    \    while($s =~ /([a-zA-Z]{2})/g) {\n        $s = $1 . substr($s, $2, 2);\n \
    \   }\n    return $s;\n}", "    my $new=\"\";\n    \n    for (split(' ',$s)) {\n\
    \        $new.=$_;\n        $new.=substr($alphabet_array[$_],2);\n    }\n    return\
    \ $new;\n}", "    my $alpha = \"abcdefghijklmnopqrstuvwxyz\";\n    my = map {\
    \ $alpha.substr($_,0,1) } 0..25;\n    my $c1 = shift @alpha;\n    my = map { $alpha.substr($_,0,1)\
    \ } 26..56;\n    my $c2 = shift @alpha;\n    my = map { $alpha.substr($_,0,1)\
    \ } 0..25;\n    my $c3 = shift @alpha;\n    my = map { $alpha.substr($_,0,1) }\
    \ 26..56;\n    my $c4 = shift @alpha;\n    my $out = '';\n    my $i = 0;\n   \
    \ while($i <  length($s))\n    {\n        $out .= $c1[$s[$i]] x (2* $s[$i]);\n\
    \        $i++;\n    }\n    return $out . $c2[$s[$i]] . $c3[$s[$i]] . $c4[$s[$i]];\n\
    }", "    \n    my @rotated_alphabet = map { ($_ =~ tr/A-Z/M-ZA-M)/; $_ } @alphabet;\n\
    \    my $result = \"\";\n    \n    for (my $i = 0; $i < $s; $i++) {\n        my\
    \ $c = substr($s, $i, 1);\n        $result .= $rotated_alphabet[$c - 'A'];\n \
    \   }\n    \n    return $result;\n}", "    my @alphabet = (\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\");\n    my @rotatedAlphabet = ();\n    foreach my $i (0 .. @alphabet) {\n\
    \        push(@rotatedAlphabet, shift(@alphabet));\n    }\n    return shift(@rotatedAlphabet)\
    \ if ($s > @alphabet);\n    my $key = substr($s, 0, 1);\n    if ($key ne \"z\"\
    ) {\n        $key .= \"z\";\n    }\n    $s = $key . $s;\n    return shift(@rotatedAlphabet)\
    \ . $s;\n}", "    my($alphabet) = @_;\n    my($output);", "    my(@result) = [];\n\
    \    my $i = 0;\n    my $x = $alphabet[$i];\n    $result[$i] = '';\n    foreach\
    \ my $s(@$s) {\n        $result[$i] .= $x;\n        my $y = $x;\n        $x =~\
    \ s/(.)/$1/g;\n        $result[$i] .= $x;\n        $x = $y;\n        $i++;\n \
    \   }\n    return @result;\n}", "    my $len = length($s);\n    my $alpha = \"\
    abcdefghijklmnopqrstuvwxyz\";", "    # To encrypt the first two letters, shift\
    \ all the letters by one position to the left,\n    # then shift it back by two\
    \ positions.\n    $s =~ tr/[abc]//cd;\n    $s =~ tr/[ghij]//efgh;\n    $s =~ tr/[klmnopq]//cdefg;\n\
    \    return $s;\n}", "    my $len = length($s);\n    my $alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    my $key = substr($alpha, $len + 1 .. length($alpha) - 1);\n    my $result\
    \ = \"\";\n    for (my $i = 0; $i < $len; ++$i) {\n        my $x = substr($s,\
    \ $i, 1);\n        $result .= substr($key, ($i % $len + $len) % $len, 1) . $x;\n\
    \    }\n    return $result;\n}", "    my $alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    my @chars = split(//, $s);\n    my $rotated_alpha = \"zyxwvutsrqponmlkjihgfedcba\"\
    ;\n    my $rotated_chars = map { substr($rotated_alpha, 0, 2) . $_ } @chars;\n\
    \    my $res = join \"\", @rotated_chars;\n    return $res;\n}", "    my $cipher\
    \ = \"\";\n    # Scan the string, one character at a time\n    while ($s =~ /\\\
    w/g) {\n        my $char = $&;\n        # Shift the character down by two spaces\
    \ to the left and append it\n        $cipher = $cipher . $alphabet->[$alphabet_length\
    \ - $alphabet_shift]\n            unless $char == $alphabet->[0];\n        # Shift\
    \ the character down by two spaces to the right and append it\n        $cipher\
    \ = $cipher . $alphabet->[$alphabet_length + $alphabet_shift]\n            unless\
    \ $char == $alphabet->[$alphabet_length - 1];\n        # Shift the character down\
    \ by one position and append it\n        $cipher = $cipher . $alphabet->[$alphabet_length\
    \ + $alphabet_shift-1]\n            unless $char == $alphabet->[$alphabet_length];\n\
    \        # Shift the character down by two positions and append it\n        $cipher\
    \ = $cipher . $alphabet->[$alphabet_length - $alphabet_shift-2]\n            unless\
    \ $char == $alphabet->[$alphabet_length - 2];\n        # Shift the character down\
    \ by three positions and append it\n        $cipher = $cipher . $alphabet->[$alphabet_length\
    \ - $alphabet_shift-3]\n            unless $char == $alphabet->[$alphabet_length\
    \ - 3];\n        # Shift the character down by four positions and append it\n\
    \        $cipher = $cipher . $alphabet->[$alphabet_length - $alphabet_shift-4]\n\
    \            unless $char == $alphabet->[$alphabet_length - 4];\n        # Shift\
    \ the character down by five positions and append it\n        $cipher = $cipher\
    \ . $alphabet->[$alphabet_length - $alphabet_shift-5]\n            unless $char\
    \ == $alphabet->[$alphabet_length - 5];\n        # Shift the character down by\
    \ six positions and append it\n        $cipher = $cipher . $alphabet->[$alphabet_length\
    \ - $alphabet_shift-6]\n            unless $char == $alphabet->[$alphabet_length\
    \ - 6];\n        # Shift the character down by seven positions and append it\n\
    \        $cipher = $cipher . $alphabet->[$alphabet_length - $alphabet_shift-7]\n\
    \            unless $char == $alphabet->[$alphabet_length - 7];\n        # Shift\
    \ the character down by eight positions and append it\n        $cipher = $cipher\
    \ . $alphabet->[$alphabet_length - $alphabet_shift-8]\n            unless $char\
    \ == $alphabet->[$alphabet_length - 8];\n        # Shift the character down by\
    \ nine positions and append it\n        $cipher = $cipher . $alphabet->[$alphab",
  "    my @x = split(//,$s);\n    my $result = \"\";\n    my $l = scalar(@x);\n  \
    \  \n    for($i=0;$i<$l;$i++) {\n        # Scan the string backwards\n       \
    \ my $x = $x[$i];\n        my $y = $i;\n        while ($y != 0) {\n          \
    \  $result = \"$x$result$alphabet[$y--]\";\n        }\n    }", "    my $alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    my $length = length($s);\n    my $alphabetLength\
    \ = length($alphabet);\n    my $finalString = \"\";\n    my $i = 0;\n    for(my\
    \ $j = 0; $j <= $length; $j++) {\n        if($j < $length * 2) {\n           \
    \ $finalString .= substr($alphabet, $alphabetLength - $j, 1);\n        } else\
    \ {\n            $finalString .= substr($alphabet, $alphabetLength - $j - 2, 1);\n\
    \        }\n        $i++;\n    }\n    return $finalString;\n}", "    $s =~ s/(.)/my\
    \ $r = $alphabet[$1] % $alphabet[$2]; $alphabet[$1] = $alphabet[$2];\n    return\
    \ $r;\n}", '    my $alphabet = $shift;', "    my @s = split(//,$s);\n    for my\
    \ $i (0..scalar(@s)-1) {\n\tmy $c = $s[$i];\n\t$s[$i] = $s[$i+1];\n\t$s[$i+1]\
    \ = $c;\n    }\n    return join(\"\",@s);\n}", "    my @l = map {$_ - 2}, split\
    \ //, $s;\n    return join '', @l;\n}", '    my$alphabet = qw(a b c d e f g h
    i j k l m n o p q r s t u v w x y z);', "    my $c = \"\";\n    my $j = 0;\n \
    \   my $i;", "    # If the string is empty, return an empty string\n    return\
    \ '' unless $s;\n    $s =~ tr/a-z/n-za-mN-ZA-M@/;\n    $s =~ tr/n-za-mN-ZA-M@/a-z/;\n\
    \    $s =~ tr/n-za-mN-ZA-M@/A-Z/;\n    return $s;\n}", "    my(@alphabet) = @_;\n\
    \    my($i);", "    my $alphabet =\n       \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \    . \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      . \"0123456789\";\n    my $cipher\
    \ = \"\";\n    my $i = 0;\n    my $len = $#{$alphabet} - 1;\n    for(my $j = 0;\
    \ $j < length($s); $j++) {\n        my $char = substr($alphabet, $i, 1);\n   \
    \     my $shift;\n        if ($i == $len) {\n            $shift = 0;\n       \
    \ } else {\n            $shift = 2;\n        }\n        $cipher .= substr($char,\
    \ ($j * $shift), 1);\n        $i += $shift;\n    }\n    return $cipher;\n}", " \
    \   return $s . \"\\0\" while $s =~ /./;\n    my($i, $c, $k, $n);\n    for ($i,\
    \ $c = 1, $k = 0; $i < length($s); $i++) {\n        $n = $s[$i];\n        $c++;\
    \ \n        $k += $c * 2;\n        $s[$i] = chr(ord($n) -($k%26));\n    }\n  \
    \  return $s;\n}", "    my $rotation = @_ % 26;\n    my $rev_alphabet =  reverse\
    \ substr($ALPHABET, 0, $rotation);\n    my $letter = substr($s, 0, 1);\n    my\
    \ $enc = substr($rev_alphabet, index($rev_alphabet, $letter) + $rotation);\n \
    \   $enc .= substr($rev_alphabet, index($rev_alphabet, $letter) - $rotation);\n\
    \    return $enc;\n}", "    my($l) =  length($s);\n    my($r) = length($alphabet);\n\
    \    my($c) =  0;\n    my($new_s);\n    for(my $i = 0; $i < $l; $i++) {\n    \
    \    $new_s .= $alphabet[(ord($s[$i]) + $c) % $r];\n        $c += 2;\n    }\n\
    \    return $new_s;\n}", "    my@rotated_chars = (\n        'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n        'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y',\n        'z'\n    );\n    my(@new_letters)\
    \ = ();\n    my($new_char_counter);\n    foreach my $char (split //, $s) {\n \
    \       $new_char_counter = $new_char_counter + 1;\n        push @new_letters,\
    \ $rotated_chars[$new_char_counter % scalar(@rotated_chars)];\n    }\n    return\
    \ join('', @new_letters);\n}\n</code>\n<|/ a dscore=2 tags=algorithm,perl,encryption,shift\
    \ |>\n<| a tags=algorithm,perl,encryption,shift dscore=2 |>\nHere is a non-recursive\
    \ implementation (Perl 5.10) that works with non-ASCII characters, including non-English\
    \ characters:\n<code>", "    $s . shift(@alphabet) . $alphabet[0];\n}", "    my($r);\n\
    \    my($tmp);", "    my($new, $i);\n    \n    # Rotate the input string by adding\
    \ two to the character's \n    # ASCII value, and subtracting two each time through\
    \ the loop\n    foreach $i (0 .. length($s)-1) {\n        $new .= substr($s, $i,\
    \ 1);\n        $new .= substr($new, 0, 1) + substr($new, length($new), 1);\n \
    \   }\n    return $new;\n}", "    my $l = length($s);\n    my $alpha = $alphabet;\n\
    \    \n    # Shift letters down\n    for($l; $l > 0; $l--) {\n        $alpha->[$l]\
    \ = $alpha->[$l - 1];\n        $alpha->[$l - 1] = $alpha->[$l - 2];\n        $alpha->[$l\
    \ - 2] = $alpha->[$l - 3];\n        $alpha->[$l - 3] = $alpha->[$l - 4];\n   \
    \ }\n    \n    # Shift letters up\n    for($l; $l > 0; $l--) {\n        $alpha->[$l\
    \ - 1] = $alpha->[$l - 2];\n        $alpha->[$l - 2] = $alpha->[$l - 3];\n   \
    \     $alpha->[$l - 3] = $alpha->[$l - 4];\n        $alpha->[$l - 4] = $alpha->[$l];\n\
    \    }\n    \n    # Shift letters down\n    for($l; $l > 0; $l--) {\n        $alpha->[$l]\
    \ = $alpha->[$l - 1];\n        $alpha->[$l - 1] = $alpha->[$l - 2];\n        $alpha->[$l\
    \ - 2] = $alpha->[$l - 3];\n        $alpha->[$l - 3] = $alpha->[$l - 4];\n   \
    \ }\n    \n    # Shift letters up\n    for($l; $l > 0; $l--) {\n        $alpha->[$l\
    \ - 1] = $alpha->[$l - 2];\n        $alpha->[$l - 2] = $alpha->[$l - 3];\n   \
    \     $alpha->[$l - 3] = $alpha->[$l - 4];\n        $alpha->[$l - 4] = $alpha->[$l];\n\
    \    }\n    \n    # Shift letters down\n    for($l; $l > 0; $l--) {\n        $alpha->[$l]\
    \ = $alpha->[$l - 1];\n        $alpha->[$l - 1] = $alpha->[$l - 2];\n        $alpha->[$l\
    \ - 2] = $alpha->[$l - 3];\n        $alpha->[$l - 3] = $alpha->[$l - 4];\n   \
    \ }\n    \n    # Shift letters up\n    for($l; $l > 0; $l--) {\n        $alpha->[$l\
    \ - 1] = $alpha->[$l - 2];\n        $alpha->[$l - 2] = $alpha->[$l - 3];\n   \
    \     $alpha->[$l - 3] = $alpha->[$l - 4];\n        $alpha", "    my $alphabet\
    \ = (\"a\"..\"z\");\n    my $len = length($s);\n    my @new;\n    for(my $i =\
    \ 0; $i < $len; $i++) {\n        push(@new, $alphabet[ord(substr($s, $i, 1)) +\
    \ 1]);\n    }\n    return join(\"\", @new);\n}", "    my(@alpha) = map {(ord('a')+$_)..ord('z')}\
    \ 0..25;\n    my(@rot) = map {(ord('z')-$_)..ord('a')} 25..0;\n    my($ns) = -1;\n\
    \    my $slen = length($s);\n    for ($ns=0; $ns<$slen; $ns++) {\n        my $nc\
    \ = substr($s,$ns,1);\n        my $nx = substr($s,$ns+1,1);\n        $nx .= $rot[$alpha[$alpha[$nc]%25]]\
    \ if $alpha[$alpha[$nc]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+1]%25]]\
    \ if $alpha[$alpha[$nc+1]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+2]%25]]\
    \ if $alpha[$alpha[$nc+2]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+3]%25]]\
    \ if $alpha[$alpha[$nc+3]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+4]%25]]\
    \ if $alpha[$alpha[$nc+4]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+5]%25]]\
    \ if $alpha[$alpha[$nc+5]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+6]%25]]\
    \ if $alpha[$alpha[$nc+6]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+7]%25]]\
    \ if $alpha[$alpha[$nc+7]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+8]%25]]\
    \ if $alpha[$alpha[$nc+8]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+9]%25]]\
    \ if $alpha[$alpha[$nc+9]%25];\n        $ns .= $ns+1;\n        $nx .= $rot[$alpha[$alpha[$nc+10]%25]]\
    \ if $alpha[$alpha[$nc", "    my @chars;\n    for ($s,0) {\n\tmy $l = $_ = shift\
    \ @chars;\n\t\n\t$l =~ s/^(.)/$2/g;\n\tpush @chars, $l;\n    }\n    return join\
    \ \"\", @chars;\n}", "    my(@chars) = split(//,$s);\n    my($num_letters) = @chars;\n\
    \    my($result,$counter,$letter,$newchar);\n    my($old_counter,$new_counter);\n\
    \    my($temp_letter,$temp_newchar);\n    my($i,$j,$k,$temp_i,$temp_j);\n    \n\
    \    \n    $num_letters -= 1;\n    # First character is rotated down\n    $letter\
    \ = $chars[0];\n    $chars[0] = $chars[1];\n    $chars[1] = $letter;\n    \n \
    \   # Store the previous counter for the new first character\n    $old_counter\
    \ = $num_letters;\n    # Store the new first character\n    $newchar = $chars[0];\n\
    \    \n    # Rotate the rest of the letters\n    $num_letters -= 1;\n    foreach\
    \ $char (@chars) {\n        my $temp_letter = $char;\n        my $temp_newchar\
    \ = $char;\n        $temp_letter++;\n        $temp_newchar++;\n        \n    \
    \    # Keep adding the letters until the counter exceeds half of the \n      \
    \  # number of letters\n        for ($i = $num_letters - 1; $i >= 0; $i--) {\n\
    \            # Move the letter to the left by one position\n            \n   \
    \         $temp_letter--;\n            # Keep adding a letter until it goes out\
    \ of bounds by\n            # shifting to the right\n            while ($temp_letter\
    \ >= 26) {\n                $temp_letter = $temp_letter - 26;\n              \
    \  $temp_newchar++;\n            }\n            \n            my $temp_i = $i;\n\
    \            $temp_i--;\n            while ($temp_i >= 0) {\n                my\
    \ $temp_j = $j;\n                $temp_j--;\n                $chars[$temp_i] =\
    \ $chars[$temp_j];\n                \n                \n                # Keep\
    \ adding the letters until the counter exceeds \n                # half of the\
    \ number of letters\n                while ($num_letters >= 26) {\n          \
    \          $num_letters = $num_letters - 26;\n                    $temp_newchar++;\n\
    \                }\n            }\n            \n            # If the new letter\
    \ is less than 26 make it the new \n            # letter and keep adding a letter\
    \ to the counter\n            if ($temp_newchar <= 26) {\n                $chars[$i]\
    \ = $temp_newchar;\n                $num_letters++;\n            }\n         \
    \   \n            \n        }\n        \n        \n        \n    }\n    \n   \
    \ # Return the rotated string\n    $result = join(\"\",@chars);\n    return $result;\n\
    }", "    $s =~ s/(.)/chr($&+$shift) x ($shift-$&)/eg;\n    return $s;\n}", '    my($rotated_alphabet);',
  "    my $len = length($s);\n    my $c = chr(1);\n    my $out = '';\n    while($len\
    \ >= 2) {\n        $out .= $c x ($len-1);\n        $c = $c x 2;\n        $len\
    \ -= 1;\n    }\n    $out .= $c x ($len-1);\n    return $out;\n}", "    my @chars\
    \ = split('', $s);\n    my @rotated_chars;\n    my $len = @chars;\n    my $multiplier\
    \ = 1;\n    \n    foreach my $char (@chars) {\n        my $letter = substr($char,\
    \ 0, 1);\n        my $new_letter = substr($char, 0, 1);\n        my $old_letter\
    \ = substr($char, 1, 1);\n        \n        if ($old_letter eq \"z\") {\n    \
    \        if ($new_letter eq \"a\") {\n                $multiplier++;\n       \
    \     }\n        }\n        elsif ($old_letter eq \"a\") {\n            if ($new_letter\
    \ eq \"z\") {\n                $multiplier--;\n            }\n        }\n    \
    \    \n        my $new_letter = chr(ord($new_letter) + $multiplier);\n       \
    \ \n        if ($new_letter eq \"z\") {\n            $rotated_chars[0] = $letter;\n\
    \        }\n        elsif ($new_letter eq \"a\") {\n            $rotated_chars[1]\
    \ = $letter;\n        }\n        else {\n            $rotated_chars[2] = $letter;\n\
    \        }\n    }\n    \n    my $output = '';\n    \n    for my $i (0 .. $len-1)\
    \ {\n        $output .= $rotated_chars[$i];\n    }\n    \n    return $output;\n\
    }", "    my$i = $s->{key};\n    my$c = $s->{alphabet};\n    my$c{$s->{alphabet}}\
    \ = 'z' . substr($c{$s->{alphabet}}, 0, 1);\n    return substr ($s->{alphabet},\
    \ 0, 1) . $c{$s->{alphabet}}\n\t. substr ($c{$s->{alphabet}}, 1) . $s->{alphabet}\
    \ \n\t. substr ($c{$s->{alphabet}}, 2) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 3) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 4) . $s->{alphabet} \n\
    \t. substr ($c{$s->{alphabet}}, 5) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 6) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 7) . $s->{alphabet} \n\
    \t. substr ($c{$s->{alphabet}}, 8) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 9) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 10) . $s->{alphabet} \n\
    \t. substr ($c{$s->{alphabet}}, 11) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 12) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 13) . $s->{alphabet}\
    \ \n\t. substr ($c{$s->{alphabet}}, 14) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 15) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 16) . $s->{alphabet}\
    \ \n\t. substr ($c{$s->{alphabet}}, 17) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 18) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 19) . $s->{alphabet}\
    \ \n\t. substr ($c{$s->{alphabet}}, 20) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}},\
    \ 21) . $s->{alphabet} \n\t. substr ($c{$s->{alphabet}}, 22) . $s->{alphabet}\
    \ \n\t. substr ($c{$s->{alphabet}}, 23) . $s->{alphabet} \n\t. ", "    my @arr\
    \ = split('', $s);\n    my $newArr = ();\n    my $count = 0;\n    my $i = 0;\n\
    \    $arr[$i] =~ tr/a-zA-Z/n-za-mn-za-m/;\n    while($i < @arr) {\n        $arr[$i]\
    \ =~ s/-z//;\n        $newArr[$count] = $arr[$i];\n        $count++;\n       \
    \ $i++;\n    }\n    my $enc = join('', @newArr);\n    return $enc;\n}", '    my
    $res = "";', "    my $a = shift @_;\n    my $c = $a;\n    $c .= $a;\n    while\
    \ ($c =~ /([a-zA-Z])/o) {\n        $c = \"$1\" if $1 eq $c;\n        $c .= $a;\n\
    \    }\n    $c;\n}", "    my $alpha = \"abcdefghijklmnopqrstuvwxyz\";\n    my\
    \ @t = split(//, $alpha);\n    my @e = ();\n    for (my $i = 0; $i < length($s);\
    \ $i++) {\n        push @e, substr($s,$i, 1);\n    }\n    for (my $i = 0; $i <\
    \ length($s); $i++) {\n        for (my $j = 0; $j < length($alpha); $j++) {\n\
    \            my $tmp = $t[$i];\n            $t[$i] = $t[$j];\n            $t[$j]\
    \ = $tmp;\n        }\n    }\n    for (my $i = 0; $i < length($s); $i++) {\n  \
    \      my $x = substr($s,$i,1);\n        my $y = substr($alpha,length($alpha)-1,1);\n\
    \        $x = substr($x, 0, 1) . $y . $x;\n        push @e, $x;\n    }\n    return\
    \ join(\"\", @e);\n}", "    $s ^= $alphabet[$_] for 1 .. length($s);\n    $s;\n\
    }", "    my @rotated_alphabet = ();\n    for(my $x = 0; $x < length($s); $x++)\
    \ {\n        my $a = $alphabet{$s{$x}};\n        push (@rotated_alphabet, $a)\
    \ if defined $a;\n    }\n    my $encrypted_string = \"\";\n    foreach my $c (@rotated_alphabet)\
    \ {\n        $encrypted_string .= $c x (length($s) - $x -1);\n    }\n    return\
    \ $encrypted_string;\n}", "    my $alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \    $alphabet = substr($alphabet, 0, 1) . $alphabet . substr($alphabet, 1);\n\
    \    $alphabet = substr($alphabet, 0, -1) . $alphabet;\n    my $i = 0;\n    my\
    \ $rotated_alphabet = \"\";\n    my $l = length($alphabet) - 1;\n    while($i\
    \ <= $l) {\n        $rotated_alphabet .= substr($alphabet, $i + 1, 1);\n     \
    \   $i += 2;\n    }\n    my $l = length($rotated_alphabet);\n    while ($i < $l)\
    \ {\n        $rotated_alphabet .= substr($alphabet, $i, 1);\n        $i += 1;\n\
    \    }\n    $rotated_alphabet = substr($rotated_alphabet, 0, 1);\n    $rotated_alphabet\
    \ .= substr($rotated_alphabet, 1);\n    return $rotated_alphabet . $s;\n}", " \
    \   my(@chars) = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z');\n   \
    \ my(@chars) = ('z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n',\
    \ 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a');", "    my\
    \ $alphabet = 'abcdefghijklmnopqrstuvwxyz';\n    my $length = $#alphabet;\n  \
    \  my $c = 0;\n    my $c1 = $c+1;\n    my $c2 = $c+2;\n    my $c3 = $c+3;\n  \
    \  my $c4 = $c+4;\n    my $c0 = $c+5;", "    my $alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    my = map {\n        my $x = substr($alphabet, $_, 1);\n        substr($alphabet,\
    \ $_, 2) . $x\n    } 0..$#alphabet;\n    my = map {\n        my $x = substr($alphabet,\
    \ $_, 2);\n        substr($alphabet, $_, 0) . $x\n    } 0..$#alphabet;\n    my\
    \ $n = 0;\n    foreach my $x (@alphabet) {\n        $n = $alphabet[$n] . $alphabet[$x];\n\
    \    }\n    return $n;\n}", "    $s =~ tr/a-z/n-za-m/;\n    return $s;\n}", " \
    \   my $alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    my $rot = \"zyxwvutsrqponmlkjihgfedcba\"\
    ;", "    my @chars = split(//, $s);\n    my $i = 0;\n    foreach my $char (@chars)\
    \ {\n        my $key = $char;\n        $key++;\n        if ($key > 26) {\n   \
    \         $key = 0;\n            $char++;\n        }\n        $chars[$i] = $key;\n\
    \        $i++;\n    }\n    return join \"\", @chars;\n}", "    my @alpha = split\
    \ //, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    my $i = 0;\n    my $j = 0;\n    my\
    \ $new_s = 0;\n    \n    for (my $i=0; $i<length($s); $i++) {\n        my $letter\
    \ = $alpha[$i];\n        $new_s .= $letter;\n        if ($j % 2 == 0) {\n    \
    \        $new_s .= substr($s, $i, 1);\n            $j++;\n        } else {\n \
    \           $new_s .= substr($s, $i, 1);\n        }\n        $j++;\n    }\n  \
    \  $new_s;\n}", "    my($j);\n    my($k);\n    my($c);\n    my(@alphabet);\n \
    \   my($ccount);\n    my($rot);\n    my($rotate);\n    my($new_s);", "    return\
    \ substr($s, 0, 1) .\n        substr($s, 1, 1) .\n        substr($s, 2, 1) .\n\
    \        substr($s, 3, 1) .\n        substr($s, 2, 1) .\n        substr($s, 1,\
    \ 1) .\n        substr($s, 0, 1);\n}", "    return encryptInPlace($s);\n}", " \
    \   my($i, $j, $k);\n    my($r1, $r2) = (\"\", \"\");\n    my %alphabet = ();\n\
    \    my $alphabet = \"\";\n    # Iterate through each letter in the string.\n\
    \    # Increment the counter for that letter.\n    # Get the key from $alphabet\
    \ by adding 2 to the counter value.\n    # Assign the letter to $r1 with the first\
    \ key in alphabet as $k\n    # Then increment that key by 2 and assign the letter\
    \ to $r2\n    # with the second key in alphabet as $k. Repeat until all letters\
    \ \n    # are cycled.\n    foreach $i (split(//, $s)) {\n        $alphabet{$i}\
    \ = ++$alphabet{$i} * 2;\n        push (@{$r1}, $alphabet{$k++}) if $k;\n    \
    \    push (@{$r2}, $alphabet{$k++}) if $k;\n    }\n    return join \"\", @{$r1},\
    \ @{$r2};\n}\n</code>\n<|/ a |>\n<| c |>\nYour code is very slow. Could you provide\
    \ me the link for the reference of the method you use? I didn't find it in the\
    \ wiki or any books.\n<|/ c |>\n<| c |>\nI have added my own version of the above\
    \ code. Not very fast but it works.\n<|/ c |>\n<| c |>\nThanks. I have just looked\
    \ at your code, and indeed it is very fast.\n<|/ c |>\n<| a tags=rotation,perl,string,encryption\
    \ |>\n<code>\nmy $string = 'ABCDEF';\nmy $length = 6;\n$string =~ s/(.)../$1./g;\n\
    $string =~ s/(.)$/\\$1./;\n$string =~ s/./$length + $&/e;\n$string =~ s/(.)(.)/$1($length\
    \ + $2)/ge;\nprint $string;\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe code works.\
    \ But it can be made more readable if you replace `s/(.)../$1./g` with `s/(.)../$1./g\
    \ while length $1 >=2`. This way one can avoid multiple substitutions, which is\
    \ very inefficient in perl.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nmy $string =\
    \ 'ABCDEF';\nmy $length = 6;\n$string =~ s/(.)../$1./g;\n$string =~ s/(.)$/\\\
    $1./;\n$string =~ s/./$length + $&/e;\n$string ", "    return $s if $s;\n    return\
    \ $s; # if $s =~ /^[A-Z]+$/; # only use rotate if all characters are A-Z\n   \
    \ $s = $_[0] if @_ == 1; # encrypt the string passed in\n    $s !~ /^[A-Z]+$/\
    \ && die \"ERROR: invalid string\\n\"; # only use rotate if all characters are\
    \ A-Z\n    $s = $s[0] + $s[1]; # swap characters\n    $s = rot13($s);\n    $s\
    \ = $s[0] + $s[1];\n    $s = rot13($s);\n    $s = $s[0] + $s[1];\n    $s = rot13($s);\n\
    \    return $s;\n}", "    my(@alpha) = split //,shift;\n    my($len) = length\
    \ $s;\n    my($c) = 0;\n    my($k) = 0;\n    my $news = \"\";\n    for(my $i=0;$i<$len;$i++){\n\
    \        my($c2) = substr($s,$i,1);\n        if($c2 eq $c){\n            ($c2\
    \ = $c+2)%@alpha;\n        }else{\n            $c2 = $c%@alpha;\n            $c\
    \ = $c2;\n        }\n        $news .= $c2;\n        $k++;\n        if($k % 2 ==1){\n\
    \            $k = 0;\n        }\n    }\n    return $news;\n}", "    my @char =\
    \ split(//, $s);\n    my $i = 0;\n    my $new = '';\n    foreach (@char) {\n \
    \       if ($i % 2 == 0) {\n            $new .= $alphabet[$alphabet[$i] - 2];\n\
    \        } else {\n            $new .= $alphabet[$alphabet[$i] + 2];\n       \
    \ }\n        $i++;\n    }\n    return $new;\n}", "    # Check for bad input\n\
    \    if ($s eq \"\") {\n\tdie \"Encrypt Error: No string input for encryption\"\
    ;\n    }\n    # Check for bad input \n    if (length($s) != length($a)) {\n\t\
    die \"Encrypt Error: Length of string input must equal length of alphabet\";\n\
    \    }\n    # Encrypt the string\n    my $output = '';\n    for my $c (split //,\
    \ $s) {\n\tmy $i = substr($a, length($a) - length($c) + 1);\n\t$output .= $i x\
    \ (length($c) + 2);\n    }\n    return $output;\n}", '    my($c, $i);', "    $s\
    \ = $alphabet->[$s->[0]] . $s->[1];\n    $s;\n}", "    my $c = 0;\n    my $alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\";", "    my($rot) = @_ % 26;\n    my($len) =\
    \ length($s);\n    return \"\" unless $len;\n    my($outstr);\n    foreach my\
    \ $i (0 .. $len - 1) {\n        $outstr .= $alphabet[$alphabet[$i + $rot] % 26];\n\
    \    }\n    $outstr .= $alphabet[$alphabet[$len] % 26];\n    return $outstr;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI didn't downvote but this is incorrect.\
    \ You don't know if the input string is alphabetized, so you don't know the length\
    \ of the string. Also, you don't know if the shift amount is even or odd, so you\
    \ don't know the length of the output. Also, there should be no encryption of\
    \ `'abc'`, or any string containing multiple characters, like `'aabc'`.\n<|/ c\
    \ |>\n<| c |>\nThe `my($rot)` parameter is supposed to indicate that one wants\
    \ a **rotation of an even amount**. It doesn't need to be an even amount, but\
    \ it must lie in the range of even numbers.\n<|/ c |>\n<| c |>\nWhat about `abc`\
    \ where `a` is rotated three times?\n<|/ c |>\n<| c |>\nWell, `abc` has length\
    \ 4, so no rotation needed. `a` gets rotated twice, and `c` rotated once. `abc`\
    \ becomes `cba`. Odd amounts don't matter, that's why I called it rotation of\
    \ an even amount. `abc` doesn't need to be rotated.\n<|/ c |>\n<| c |>\nI didn't\
    \ say it has to be an even amount, but I said it needs to be in the range of even\
    \ numbers, not an even amount.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nuse strict;\n\
    use warnings;", "    my $lc = length $s;\n    my = map { ($_ + 2) % 26 + 1 } 0\
    \ .. 25;\n    $lc++ while $lc > 25;\n    return substr (map { $a[ $_ % 26 ] }\
    \ 0 .. $lc - length ($s) ),\n             0,\n             length $s;\n}", " \
    \   # Step 1. Rotate the key a number of steps such that the first \n    # step\
    \ is two letters away from the key and the second step is \n    # three letters\
    \ away from the key. Step two will be three letters \n    # away and so on. Keep\
    \ repeating this until the key is rotated \n    # a number of times that will\
    \ result in an even number of steps. \n    # Then return the alphabet after rotating\
    \ it.\n    my $rotated_key = $key;\n    $rotated_key .= substr($rotated_key, 0,\
    \ 1);\n    $rotated_key .= substr($rotated_key, 0, 1);\n    my $i = 0;\n    do\
    \ {\n        $rotated_key .= substr($rotated_key, 0, 1);\n        $rotated_key\
    \ .= substr($rotated_key, 0, 1);\n        $i++;\n    } until ($i % 2 == 0);\n\
    \    my $rotated_alphabet = substr($rotated_key, 0, 5);\n    $rotated_alphabet\
    \ .= substr($rotated_alphabet, 0, 1);\n    $rotated_alphabet .= substr($rotated_alphabet,\
    \ 0, 1);\n    $rotated_alphabet .= substr($rotated_alphabet, 0, 1);\n    $rotated_alphabet\
    \ .= substr($rotated_alphabet, 0, 1);\n    return $rotated_alphabet;\n}\n</code>\n\
    <|/ a tags=encryption,cryptography,perl |>\n<| a tags=encryption,cryptography,perl\
    \ |>\nYou can use the perl module Crypto::Cipher for encryption and decryption.\n\
    <|/ a dscore=3 |>\n<| a tags=encryption,cryptography,perl |>\nThis code has been\
    \ tested to work properly for the AES encryption and decryption:\n<code>\nuse\
    \ strict;\nuse warnings;\nuse MIME::Base64;\nuse Crypt::CBC;", "    my($l);\n\
    \    my($n);\n    my($r);", "    return $s unless $s;\n    my $len = length($s);\n\
    \    my $alpha = ord('A') - 2;\n    my $res = '';\n    while ($len > 0) {\n  \
    \      $res .= $s . chr(ord($s) % $alpha);\n        $s = substr($s, 0, 1);\n \
    \       $len = length($s);\n    }\n    return $res;\n}", "    my $alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\";\n    $alphabet = rotate($alphabet, $alphabet);\n\
    \    my $len = length($s);\n    my $cipher = \"\";\n    for ($i = 0; $i <= $len;\
    \ $i++) {\n        my($c) = $alphabet[$i & length($alphabet)];\n        next unless\
    \ $i && $i % 2 == 0;\n        $cipher = $c . $cipher;\n    }\n    return $cipher;\n\
    }", "    my(@a) = split(//,$s);\n    my $c = shift(@a);\n    my $l = shift(@a);\n\
    \    my $k = shift(@a);\n    $c += $l * 2;\n    $l += $l * 2;\n    $c += $k;\n\
    \    return ($a[$l],$a[$c],$a[$k]);\n}", "    # Make sure we have a string\n \
    \   return unless(defined($s) && ref($s));\n    # Make sure the string is longer\
    \ than 26 characters\n    return unless(length($s) >= 26);\n    # Make sure we\
    \ haven't rotated too much\n    return unless(length($s) <= 26);\n    # Create\
    \ a hash of each character\n    my @chars = split(//,$s);\n    foreach my $c (@chars)\
    \ {\n        my $h = substr($c,1,1);\n        my $k = ($h + 2) % 26;\n       \
    \ $c = $chars[$k] if ($k != 0);\n        push(@chars,$c);\n    }\n    return join(\"\
    \",@chars);\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for the response. I implemented\
    \ this and it seems to work, although I'm having trouble understanding the code.\
    \ Could you perhaps explain the encryption process?\n<|/ c |>\n<| c |>\nI added\
    \ some explanation of the process.\n<|/ c |>\n<| a tags=encryption,perl,arrays\
    \ |>\nI prefer not to use string manipulation at all, as it's easier to see what's\
    \ going on when the algorithms are isolated as functions.  Here's a solution I\
    \ wrote in Perl\n<code>", "    my($i);\n    my($c);\n    my($m);\n    my($n);\n\
    \    my($temp);\n    my($alphabet);\n    my(@s);\n    my(@temp);\n    my($alphabetCount);\n\
    \    my($alpha);\n    my($rotated);\n    my $alphabetized = $s;\n    foreach $alphabet\
    \ (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized =~ s/($alphabet)/$alphabet->{$_}/g;\n\
    \    }\n    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized\
    \ =~ s/$alphabet/+$alphabet/g;\n    }\n    foreach $alphabet (sort {$a cmp $b}\
    \ keys %alphabet) {\n        $alphabetized =~ s/$alphabet/\\-$alphabet/g;\n  \
    \  }\n    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized\
    \ =~ s/$alphabet/\\\\$alphabet/g;\n    }\n    foreach $alphabet (sort {$a cmp\
    \ $b} keys %alphabet) {\n        $alphabetized =~ s/$alphabet/\\?$alphabet/g;\n\
    \    }\n    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized\
    \ =~ s/$alphabet/!$alphabet/g;\n    }\n    foreach $alphabet (sort {$a cmp $b}\
    \ keys %alphabet) {\n        $alphabetized =~ s/$alphabet/@$alphabet/g;\n    }\n\
    \    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized\
    \ =~ s/$alphabet/#$alphabet/g;\n    }\n    foreach $alphabet (sort {$a cmp $b}\
    \ keys %alphabet) {\n        $alphabetized =~ s/$alphabet/$alphabet/g;\n    }\n\
    \    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphabetized\
    \ =~ s/$alphabet/%$alphabet/g;\n    }\n    foreach $alphabet (sort {$a cmp $b}\
    \ keys %alphabet) {\n        $alphabetized =~ s/$alphabet/&$alphabet/g;\n    }\n\
    \    foreach $alphabet (sort {$a cmp $b} keys %alphabet) {\n        $alphab",
  "    $s =~ s/([A-Z])/${\\L$1}/g;\n    $s =~ s/([a-z])/${\\L$1}/g;\n    return $s;\n\
    }", "    my $s = $s->[0];\n    my $cipher = $s->[1];", "    my $alphabet = 'a'..'z';\n\
    \    my $alphabet_size = length($alphabet);\n    my $result = '';\n    \n    #\
    \ Make sure we're using valid characters\n    if ($s =~ /[^a-zA-Z]/) {\n     \
    \   die \"Invalid characters in the given string\";\n    }", "    my(@alphabet)\
    \ = @_;\n    my($alphabetSize = scalar(@alphabet));\n    my($alphabetStartIndex\
    \ = $alphabetSize - 1);\n    my($alphabetEndIndex = $alphabetSize - 2);", '    my(@alphabet)
    = @_;', "    my ($alphabet) = @_;\n    my($c, $i);\n    my $s = $s;\n    my @a\
    \ = split //, $alphabet;\n    for ($c = 0; $c <= $#a; $c++) {\n        $c++;\n\
    \        $i = 0;\n        while ($i < length($s)) {\n            $i ++;\n    \
    \        $s[$c] .= $a[$c] if $s[$i] eq $a[$c];\n        }\n    }\n    return $s;\n\
    }", "    my @new_letters;\n    foreach my $i(0 .. $#{$s}){\n        my $n = $#new_letters+1;\n\
    \        push @new_letters, substr $alphabet[$i], 0, $n;\n        push @new_letters,\
    \ substr $alphabet[$i], $n+1;\n    }\n    my $encrypted_string = join \"\", @new_letters;\n\
    \    return $encrypted_string;\n}", "    my(@alphabet) = split(//, \"abcdefghijklmnopqrstuvwxyz\"\
    );\n    my(@rotation) = split(//, $alphabet[2]);\n    my(@output);\n    my($j);\n\
    \    \n    foreach $j (@alphabet) {\n        $output[0] .= $alphabet[$j];\n  \
    \      shift @output;\n    }\n    \n    foreach $j (@rotation) {\n        $output[0]\
    \ .= $alphabet[$j];\n        shift @output;\n    }\n    \n    return join(\"\"\
    , @output);\n}", "    my(@rot) = qw(a b c d e f g h i j k l m n o p q r s t u\
    \ v w x y z);\n    my(@chars);\n    \n    $s =~ tr/a-zA-Z/@rot/;\n    \n    $s\
    \ =~ s/([a-z])/$1.length+2//;\n    $s =~ s/^/2/;\n    \n    foreach $char (split\
    \ //, $s) {\n        $chars[$char] = $chars[$char] +2;\n    }\n    \n    foreach\
    \ $char (split //, $s) {\n        $chars[$char] %= 256;\n    }\n    \n    $s =\
    \ join \"\", @chars;\n    \n    return $s;\n}\n</code>\n<|/ a dscore=1 tags=encryption,perl,python\
    \ |>\n<| a dscore=0 |>\nHere is another solution, that also works for other languages.\
    \ \n<code>\ndef encrypt_2(s):\n    n = 2\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    length = len(alphabet)\n    shift = n % length\n    reversed_alphabet =\
    \ alphabet[::-1]\n    encrypted_string = \"\"\n    for i in range(len(s)):\n \
    \       if i > 0 and (i % n == 0):\n            encrypted_string += reversed_alphabet[shift\
    \ + 1]\n        encrypted_string += alphabet[ord(s[i]) - shift]\n        shift\
    \ += 1\n    return encrypted_string\n</code>\n<|/ a tags=encryption,perl,python\
    \ |>\n<| a tags=encryption,perl,python dscore=0 |>\nHere is a python solution\n\
    <code>\ndef encryptChar(letter, chars, shift):\n    return chars[(chars.index(letter)\
    \ + shift)%(len(chars))]", "    my(@alphabet) = @_;\n    my(@result);\n    my($counter);",
  "    my(@alphabet) = split(//,$alphabet);\n    my(@letters) = split(//,$s);\n  \
    \  my($c);\n    my($n) = (@letters - 1) / 2;\n    for(my $i = 0; $i < @alphabet;\
    \ $i++) {\n        $c = $alphabet[$i]; \n        for(my $j = 0; $j < $n; $j++)\
    \ {\n            $c = $alphabet[$c + 2*$letters[$i]]; \n        }\n        $letters[$i]\
    \ = $c;\n    }\n    join(\"\",@letters);\n}", '    my($alphabet) = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";',
  "    my @s = split(//,$s);\n    my $i = 0;\n    my $lastchar;\n    my $len = @s\
    \ - 1;\n    my $rlen = $len - 2;\n    my $len2 = $len / 2;\n    my $str = \"\"\
    ;\n    while(1) {\n        my $ind = $len2 - $i;\n        if($ind < 0) {\n   \
    \         $ind = 0;\n        }\n        my $c = $s[$i + $ind];\n        my $char\
    \ = $letter[$c % 26];\n        \n        if($ind == $len2) {\n            if(($char\
    \ == $lastchar) || \n               ($char == $lastchar && $lastchar != $letter[$len\
    \ - 1])) {\n                $str .= $char;\n            }\n            else {\n\
    \                $str .= $char;\n                $lastchar = $char;\n        \
    \    }\n        }\n        elsif($c eq $lastchar || $char == $letter[$len - 1])\
    \ {\n            $str .= $char;\n        }\n        else {\n            $str .=\
    \ $char;\n            $lastchar = $char;\n        }\n        $i++;\n    }\n  \
    \  return $str;\n}", "    my $l = length($s);\n    my @rotate = map {$_ - 2 *\
    \ $_} qw(a b c d e f g h i j k l m n o p q r s t u v w x y z);\n    return map\
    \ {substr($s, $_ , 1) . substr($s, $_ , 1) . substr($s, $_ + 2, 1) } @rotate;\n\
    }", "    my@c = map {substr($s,$_,1)} 0..@$alphabet;\n    \n    my $cipher = \"\
    \";\n    foreach (@c) {\n\t$cipher .= $alphabet[rotate(@alphabet, index($alphabet,\
    \ $_))];\n    }\n    \n    return $cipher;\n}\n</cell>\n<text>\nQuestion 8\nHow\
    \ would you use a hash to solve this problem? How about a dictionary?", "    my($alphabet)\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    my($new_alphabet);\n    my($new_letter);",
  "    return map { $_ =~ y/([a-z]{2,})/$1$2/g; $_ } @_;\n}", "    \n    my(@alphabet);\n\
    \    my($index);\n    \n    @alphabet = qw(a b c d e f g h i j k l m n o p q r\
    \ s t u v w x y z);\n    \n    for(@alphabet) {\n        if($index++ % 2 == 0)\
    \ {\n            $_ = $_.$_.$_;\n        } else {\n            $_ = $_.$_;\n \
    \       }\n    }\n    \n    $s eq $s ? $s : $s.$index;\n}", "    \n    my @s =\
    \ split(//,$s);\n    my $s = $s[scalar(@s) - 1];\n    my $c = $s[scalar(@s) -\
    \ 2]; \n    my $t = $s[scalar(@s) - 3];", "    $s = uc($s);\n    my($n, $i);\n\
    \    my $x = $s->length();\n    my(@l);", "    my $r = '';\n    my $i = 0;\n \
    \   my $j = 0;\n    while ($i < length($s)) {\n        my $c = substr($s, $i,\
    \ 1);\n        my $l = length($c) - 1;\n        $j = $i + $l;\n        my $b =\
    \ substr($alphabet, $l, 1);\n        $r .= substr($alphabet, 0, 1) . substr($alphabet,\
    \ $j, 1) . $b;\n        $i = $j + 1;\n    }\n    return $r;\n}", "    $s = $self->stringify(\"\
    $s\") unless $self->can(\"stringify\");\n    my $alphabet = qw(a b c d e f g h\
    \ i j k l m n o p q r s t u v w x y z);\n    my @alphabet = qw(a b c d e f g h\
    \ i j k l m n o p q r s t u v w x y z);", "    my($i, $j, $jp, $kp);\n    my($len,\
    \ $len);\n    my($a, $a, $d, $r);\n    my($tmp, $tmp2, $tmp3, $tmp4, $tmp5);",
  "    $s =~ s/(.)/$rot[$1]/g;\n    return $s;\n}", "    my @chars = split(//, $s);\n\
    \    my $cipher = '';\n    my $i = 0;\n    foreach my $char (@chars) {\n     \
    \   # Shift the letters down by two and multiply by two.\n        $cipher .= substr($alphabet,\
    \ -(($i+1)), -(($i+2)) ) \n                 * $char; \n        # Shift the letters\
    \ down by two and multiply by two.\n        $cipher .= substr($alphabet, -(($i+2)),\
    \ -(($i+1)) ) \n                 * $char;\n        # Increment the letter index\
    \ by two.\n        $i++;\n    }\n    return $cipher;\n}\n</code>\n<|/ a tags=perl\
    \ |>\n<| a |>\nHere's a straightforward solution that uses substr and the modulus\
    \ operator. The following code is an example of a cipher:\n<code>\nmy $chars =\
    \ \"abcdefghijklmnopqrstuvwxyz\";\nmy $key = \"somekey\";\nmy $string = \"somestring\"\
    ;", "    my(@rotated_letters, $i, $j, $k);\n    for ($i = 0; $i < @rotated_letters;\
    \ $i++) {\n        push(@rotated_letters, shift(@alphabet)); \n    }\n    for\
    \ ($i = 0; $i < $s; $i++) {\n        $j = $i % @rotated_letters;\n        $k =\
    \ $rotated_letters[$j];\n        $rotated_letters[$j] = $rotated_letters[$k];\n\
    \        $rotated_letters[$k] = $rotated_letters[$j];\n    }\n    return join(\"\
    \", @rotated_letters);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI got this error\
    \ - `Uninitialized value was created in string eq at encrypt2.pl line 31, <STDIN>\
    \ line 4.`\n<|/ c |>\n<| a |>\n<code>\nuse warnings;\nuse strict;\nuse feature\
    \ qw(say);", "    $s =~ tr/a-zA-Z/o-z/r;\n    return $s;\n}\n</code>\nAs you can\
    \ see, this is pretty straightforward to write and understand.  Perhaps someone\
    \ can make it more concise, but I don't think it would get much easier than that.\
    \  I suspect that anyone who is looking to use this code will also understand\
    \ that it's an encryption algorithm and not some sort of obfuscation technique.\
    \  (As far as I'm aware, there is no encryption algorithm that can do this.)\n\
    <|/ a |>\n<| c |>\nI think you should have used `sub rotate { my($s) = @_; $s\
    \ =~ tr/a-z/o-z/r; }` instead. This will make more sense (to OP and future visitors).\n\
    <|/ c |>\n<| c |>\n, you're right that the `sub rotate` above would be clearer,\
    \ and I'll change it.  The `sub encrypt` above was mostly to show how `tr` works.\
    \  If you don't want to use it, feel free to just go with the straightforward\
    \ `sub encrypt { my($s) = @_; $s =~ s/[^a-z]/o-z/gi; return $s }`.  That would\
    \ achieve the same thing, and be a little bit clearer.\n<|/ c |>\n<| c |>\n`sub\
    \ encrypt { my($s) = @_; $s =~ s/[^a-z]/o-z/gi; return $s }` - Yeah, I love one-liners!\n\
    <|/ c |>\n<| c |>\nYeah but this doesn't work if $s is already a rotated string.\
    \ For example: encrypt(\"gf\") returns gfk.\n<|/ c |>\n<| c |>\n- Yes, it does\
    \ work.  That's how `tr` works.  It replaces all non-alphabetic characters with\
    \ `o-z` and returns the result as a string.  Try it yourself.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's a possible implementation:\n<code>", "    return $s if ($s\
    \ =~ /^[a-yz]$/);\n    my $result = '';\n    for (my $i = length($s) - 1; $i >=\
    \ 0; $i--)\n    {\n        if ($s->[$i] eq substr $alphabet, 0, 1)\n        {\n\
    \            $result .= substr $alphabet, 1 , 2 x $i;\n        }\n        else\n\
    \        {\n            $result .= $s->[$i];\n        }\n    }\n    return $result;\n\
    }", "    my $c = 65;\n    $s !~ /[A-z]/i or die \"invalid character in rot13:\
    \ $c\";\n    return join \"\",\n        map {\n            $c = $c - 2;\n    \
    \        $c < 65 ? $c += 13 : $c -= 13;\n            \"A\" eq $_ ? \"a\" : $c\n\
    \        }\n        map {\n            $c = $c + 2;\n            $c < 65 ? $c\
    \ += 13 : $c -= 13;\n            \"a\" eq $_ ? \"b\" : $c\n        }\n       \
    \ split //, $s;\n}", "    my $len = $s->[0];\n    my $c = \"\";\n    my $i = 0;\n\
    \    my $alphabet = $s->[1];\n    for(; $i < $len; $i++) {\n        if($alphabet[$i]\
    \ eq \"\\n\") {\n            $c .= substr($alphabet, 0, 1);\n            $c .=\
    \ substr($alphabet, 0, 1);\n        } else {\n            $c .= $alphabet[$i];\n\
    \        }\n    }\n    return $c;\n}", "    $s =~ tr/a-zA-Z/o-z/;\n    $s;\n}",
  "    my($ns);\n    \n    # Step through the alphabet three times.  \n    # First\
    \ to handle the empty case.  \n    # We do not need the first character, so skip\
    \ it.\n    \n    for(my $i = 1;$i < 3;$i++) {\n        my ($a, $b, $c) = ($i,\
    \ $i, $i);\n        my $str = \"\";\n        \n        # Rotate the letters until\
    \ we reach a blank one.\n        while (substr($s,$a,1) ne \" \") {\n        \
    \    $str .= substr($s,$a,1);\n            $a--;\n        }\n        \n      \
    \  # Replace the space with the new character.\n        $str .= substr($s,$b,1);\n\
    \        \n        $ns .= $str;\n    }\n    \n    return $ns;\n}", "    return\
    \ join \"\", map { my $x = $alphabet[$_ % @$alphabet]; $x . $x } split(//, $s);\n\
    }", "    my $alphabet = 'abcdefghijklmnopqrstuvwxyz';\n    $alphabet = join '',\
    \ reverse(split //, $alphabet);", "    $s =~ tr/a-z/A-Z/;\n    my(@array);\n \
    \   my($i, $j);\n    foreach $i (@alphabet) {\n\tpush(@array, $j = $i - 2);\n\
    \    }\n    foreach $i (0 .. length($s) - 1) {\n\tpush(@array, $j);\n    }\n \
    \   return join('', @array) . $s;\n}", "    my(@chars) = split(//, $s);\n    my\
    \ $len = scalar($s);", "    my $len = $#s % 2 + 1;\n    my $result = '';\n   \
    \ for (my $i = 0; $i < $len; $i++) {\n        $result .= $alphabet[$i % $#alphabet];\n\
    \    }\n    return $result;\n}", "    my($ret, $tmp);\n    for my $c (split('\
    \ ', reverse $s)) {\n        $ret .= $tmp = $alphabet[$c];\n        $tmp =~ s{(.)}{$tmp\
    \ ^ $alphabet[$1-2]}g;\n    }\n    $ret;\n}", '    return $s if !defined($s);',
  '    my($i, $c2, $c3, $c4, $c5, $c6, $c7) = @_;', "    my($i, $x, $j, $y, $z, $ret);\n\
    \    $ret = '';\n    $i = 'a';\n    $x = 'b';\n    $y = 'c';\n    $z = 'd';\n\
    \    for (my $i = 0; $i < length($s); $i++) {\n        $ret .= $s[$i];\n     \
    \   $ret .= $i & 1 ? $x : $y;\n        $ret .= $i & 2 ? $z : $z;\n        $ret\
    \ .= $i & 4 ? $y : $x;\n        $ret .= $i & 8 ? $z : $y;\n        $ret .= $i\
    \ & 16 ? $x : $z;\n        $ret .= $i & 32 ? $y : $x;\n        $ret .= $i & 64\
    \ ? $z : $y;\n        $ret .= $i & 128 ? $x : $z;\n        $ret .= $i & 256 ?\
    \ $y : $x;\n        $ret .= $i & 512 ? $z : $y;\n        $ret .= $i & 1024 ? $x\
    \ : $z;\n        $ret .= $i & 2048 ? $y : $x;\n        $ret .= $i & 4096 ? $z\
    \ : $y;\n        $ret .= $i & 8192 ? $x : $z;\n        $ret .= $i & 16384 ? $y\
    \ : $x;\n        $ret .= $i & 32768 ? $z : $y;\n        $ret .= $i & 65536 ? $x\
    \ : $z;\n        $ret .= $i & 131072 ? $y : $x;\n        $ret .= $i & 262144 ?\
    \ $z : $y;\n        $ret .= $i & 524288 ? $x : $z;\n        $ret .= $i & 1048576\
    \ ? $y : $x;\n        $ret .= $i & 2097152 ? $z : $y;\n        $ret .= $i & 4194304\
    \ ? $x : $z;\n        $ret .= $i & 8388608 ? $y : $x;\n        $ret .= $i & 16777216\
    \ ? $z : $y;\n        $ret .= $i & 33554432 ? $x : $z;\n        $ret .= $i & 67108864\
    \ && $i & 67108864 + 32768 ? $y : $x;\n        $ret .= $i & 134217728 && $i &\
    \ 134217728", "    my $alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    my @a =\
    \ split(//,$alphabet);\n    $s = $s->[0];\n    my $j = 0;\n    my $res = \"\"\
    ;\n    for ($j = 0; $j < length($s); $j++) {\n        $res .= $a[( ($j + $s->[$j])\
    \ % length($alphabet) )]; \n    }\n    return $res;\n}\n</code>\nA more readable\
    \ version:\n<code>", "    return $s if $self->{encrypt};\n    $s = $self->{_alphabet}\
    \ if $s eq '';\n    $s =~ s/(.)/$self->{_alphabet}->[$1]/eg;\n    $s;\n}", " \
    \   my $l = 0;\n    my $out = '';\n    \n    # Traverse the alphabet backwards\n\
    \    for (my $i = length($s); $i >= 0; $i--) {\n        $l = $l;\n        my $x\
    \ = substr($s, 0, $i);\n        my $y = substr($s, $i, 1);\n        $x = $x +\
    \ $l;\n        $y = $y + $l;\n        $x = $x % 256;\n        $y = $y % 256;\n\
    \        $out = substr($alphabet, $x, 1) + $out . substr($alphabet, $y, 1);\n\
    \    }", "    my($alpha,$s1,$s2,$s3);\n    my($l) = length($s);\n    my($k);\n\
    \    my($i,$j,$x,$k,$c) =;\n    \n    $l--;\n    $l=$l % $k;", "    return $s\
    \ if not $s;\n    my(@results);\n    my $j = 1;\n    my $len = length($s);\n \
    \   for (my $i = 0; $i < $len; $i++) {\n        $results[$i] = substr($s, $i,\
    \ 1) \n            if $j == 0;\n        $j = ($j + 2) % length($ALPHABET);\n \
    \       $results[$i] = substr($ALPHABET, $j, 1);\n    }\n    return join \"\"\
    , @results;\n}", "    my(@alphabet) = qw(a b c d e f g h i j k l m n o p q r s\
    \ t u v w x y z);\n    my(@rotated_alphabet) = qw(x y z y z x y z y z y z y z\
    \ y z);\n    my(@counter);\n    my(@results);\n    my($i);\n    foreach $i (0\
    \ .. @alphabet) {\n\t$counter[$i] = $i;\n    }", "    my $len = length($s);\n\
    \    my $new = '';\n    for my $i(0 .. $len-1) {\n        $new .= $alphabet[$i];\n\
    \        if ($i > 0) { $new .= $alphabet[$len-1-$i] }\n    }\n    return $new;\n\
    }", "    my(@rotated);\n    my $i;\n    foreach $i (sort keys %alphabet) {\n\t\
    if ($alphabet{$i} ne $alphabet{substr($i, 0, 1)}) {\n\t    $rotated .= $alphabet{substr($i,\
    \ 0, 1)};\n\t    push @rotated, $alphabet{$i};\n\t}\n\telse {\n\t    push @rotated,\
    \ $i;\n\t}\n    }\n    my $encrypted;\n    for ($i = 0; $i < length($s); $i++)\
    \ {\n\t$encrypted .= $rotated[$i] if ($alphabet{$s[$i]} eq $rotated[0]);\n   \
    \ }\n    return $encrypted;\n}", '    my $alphabet = "abcdefghijklmnopqrstuvwxyz";',
  "    $s =~ tr/a-zA-Z/n-za-mN-ZA-M/;\n    $s;\n}", "    # Add two to each char to\
    \ make it 2 places down\n    # Then rotate it by two.\n    my(@r) = map {\n  \
    \      $_ . str_repeat($_, 2);\n    } @{$alphabet};\n    # reverse the array\n\
    \    @r = reverse @r;\n    # add the rotated letters on\n    my $c;\n    for (my\
    \ $i = 0 ; $i < length($s) ; $i++) {\n        $c = substr($s, $i, 1) . $r[$i];\n\
    \        $s[$i] = $c;\n    }\n    return $s;\n}", '    my($n);', "    return $s\
    \ if length $s <= length($alphabet);\n    my($i, $j, $k);\n    for ($i = length($s);\
    \ $i >= 1; --$i) {\n\tfor ($j = 0, $k = $i; $j < $k; ++$j) {\n\t    $alphabet[$j]\
    \ = $alphabet[$j + 1];\n\t}\n\t$alphabet[0] = substr($alphabet, 1, length($alphabet)\
    \ - 1);\n    }\n    return $s;\n}", "    $s =~ tr/A-Z/a-z/;\n    $s =~ tr/a-z/A-Z/;\n\
    \    $s =~ tr/A-Za-z/A-Z/;\n    return $s;\n}", "    my $rotated_alphabet = rot13($s);\n\
    \    my $encrypted = $rotated_alphabet;\n    $encrypted =~ s/(.)$/$1$rotated_alphabet/e;\n\
    \    return $encrypted;\n}", "    my $alphabet = join(\"\", map {chr} split //,\
    \ $alphabet);\n    $alphabet = join(\"\", map {chr(++$_)} split //, $alphabet);\n\
    \    my $length = length($alphabet);\n    $s = uc($s);\n    my $i = 1;\n    my\
    \ $s = uc($s);\n    my $c = \"\";\n    while($i < length($s)) {\n        my $a\
    \ = substr($s, $i, 1);\n        $c = chr($alphabet - $alphabet + $alphabet - $alphabet\
    \ + ord $a) + $c;\n        $i++;\n    }\n    return $c;\n}", "    my($alphabet)\
    \  = $s->[0];\n    my($count)     = $s->[1];\n    my($rotate)    = $s->[2];",
  "    $s =~ s/(.)/ my $v = ord($1)+2;  $v ^ ($v >> 1) if ($v & 1) /eg;\n    return\
    \ $s;\n}", "    my $cipher = shift;\n    my $alphabet = @_;\n    my $cipherlen\
    \ = length($cipher);\n    my $len = length($alphabet);\n    if ($cipherlen > $len)\
    \ {\n        return $cipher;\n    }\n    if ($cipherlen < $len) {\n        for\
    \ my $i(1..$len-1) {\n            $cipher .= $alphabet[$cipherlen - $i];\n   \
    \     }\n    }\n    $cipher = substr($cipher, 0, $len);\n    return $cipher;\n\
    }", "    my @a = map { $_ => 2 } @a;\n    my $cipher = shift;\n    my = map {\
    \ $_ => 1 } @a;\n    my @cipher = ();\n    # Shift each letter down the alphabet\
    \ by two to shift up the alphabet by two\n    foreach my $c (split //, $s) {\n\
    \        $cipher[$c] ^= $a[2];\n        $cipher[$c] ^= $a[1];\n        $cipher[$c]\
    \ ^= $a[0];\n        $a[0] = $a[1];\n        $a[1] = $a[2];\n        $a[2] = $cipher[$c];\n\
    \        $cipher[$c] = $c;\n    }\n    return join '', @cipher;\n}", "    my(@alphabet)\
    \ = $s->[alphabet];\n    my(@rotated_alphabet);\n    my(@rotated_letters);\n \
    \   my(@shift);", "    $s =~ s/^/x/;\n    my($j, $i);\n    my(@alphabet);\n  \
    \  foreach my $i(2..length($s)) {\n        $alphabet[$i] = substr($alphabet[$i],\
    \ 0, 1);\n        $alphabet[$i] = substr($alphabet[$i], 0, 1) . substr($alphabet[$i],\
    \ 1);\n    }\n    foreach $j (1..length($s)) {\n        $i = $j - 2;\n       \
    \ $alphabet[$i] = substr($alphabet[$i], 0, 1) . $alphabet[$i];\n        $alphabet[$i]\
    \ = substr($alphabet[$i], 0, 1) . $alphabet[$i];\n    }\n    return join(\"\"\
    , @alphabet);\n}", "    my $c;\n    my $n = 0;\n    my $d;\n    my $k;\n    my\
    \ $q;\n    my $w;\n    my $i;", "    $s =~ tr/a-zA-Z/n-za-mN-ZA-M@g;\n    return\
    \ $s;\n}\n</code>\n<|/ a dscore=0 tags=perl,string,alphabet |>\n<| a dscore=0\
    \ |>\n<code>", "    # Make a copy of $s so we can modify it without effecting\
    \ the input\n    my $scr = $s;\n    # Initialize our rotation index\n    my $index\
    \ = 0;\n    # Initialize our result to empty string\n    my $res = \"\";\n   \
    \ # While we are not at the end of the string\n    until ($index >= length($scr))\
    \ {\n        my $c = substr($scr, $index, 1);\n        # Append the rotated character\
    \ to the result\n        $res .= $alphabet[rotate($index++) % length($alphabet)];\n\
    \        # Append the character we were previously processing\n        $res .=\
    \ $c;\n    }\n    return $res;\n}", "    my(@letters) = split(//, $s);\n    my($letter,\
    \ $i, $j) = @_;\n    my(@letters);\n    my($i, $j);\n    \n    # Rotate $letter\
    \ in $i places and push it onto $letters \n    # and increment $i by 2.\n    while\
    \ ($letter =~ /[qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM]/g) {\n \
    \       push(@letters, $letters[$i%@letters]);\n        $letter = $letters[$i%@letters];\n\
    \        $i++;\n    }\n    push(@letters, $letter);\n    \n    return join('',\
    \ @letters);\n}\n    ", "    my($c1, c2, $c3);\n    my $i = 0;\n    $c1 = $s->[0];\n\
    \    $c2 = $s->[1];\n    $c3 = $s->[2];\n    foreach my $c (@$s) {\n        $s->[$i]\
    \ = $c3;\n        $i = ($i + 3) % @$s;\n        $s->[$i] = $c2;\n        $i =\
    \ ($i + 3) % @$s;\n        $s->[$i] = $c1;\n        $i = ($i + 3) % @$s;\n   \
    \ }\n    $s->[0] = $c1;\n    $s->[1] = $c2;\n    $s->[2] = $c3;\n    $s;\n}",
  "    my($rot);\n    my($c);\n    my($n);\n    my(@cs) = split(//, $s);\n    my(@rot);\n\
    \    $rot = 0;\n    while (@cs) {\n\tpush @rot, $rot;\n\t$rot++;\n\t$c = shift(@cs);\n\
    \tpush @rot, $rot;\n\t$rot += $c + $rot;\n    }\n    my $rotation = join('', @rot);\n\
    \    @cs = join(//, @cs);\n    for (my $i = 0; $i < $rotation; $i++) {\n\tmy $c\
    \ = substr($cs, $i, 1);\n\tmy $n = substr($cs, $i + $rotation, 1);\n\t$cs = substr($cs,\
    \ 0, $i) + substr($cs, $i + $rotation, 1);\n\t$cs .= $rot[$n] . $c;\n    }\n \
    \   return $cs;\n}", "    my @char = split(//,$s);\n    my $i = 1;\n    my $new_char\
    \ = \"\";\n    my $next_char = \"\";\n    foreach my $c (@char) {\n        $next_char\
    \ = $c;\n        if($i++ % 2 == 0) {\n            $c = $c+$c;\n        }\n   \
    \     push($new_char,$c);\n    }\n    return join(\"\",@new_char);\n}", "    $s\
    \ =~ s/(.)/${shift}$1/g;\n    return $s;\n}", "    my @alph = map {($_,0)} @a;\n\
    \    my @out;\n    # Build a map of pairs of chars to their indices in the alphabet\n\
    \    # so that we can map an input char into an output char\n    foreach my $i\
    \ (0..@alph-1) {\n        foreach my $j (0..@a-$i) {\n            push @alph,($alph[$j],$i);\n\
    \        }\n    }\n    $_ =~ tr@a@b@g for @alph;\n    # Now that we have mapped\
    \ everything to an index, apply the mapping\n    # to the string.\n    foreach\
    \ my $i (0..@alph-1) {\n        my $out = $alph[$i];\n        my $j = ($i%@a);\n\
    \        foreach my $c (@_) {\n            $out .= $alph[$alph[$j]];\n       \
    \     $j = ($j+$i)%@a;\n        }\n        push,$out;\n    }\n    return @out;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI haven't read it yet, but thanks for posting it!\
    \ It looks very cool. I've tried implementing something similar to this, and I\
    \ seem to have hit a roadblock. I'll get back to this post once I've had a chance\
    \ to try this out.\n<|/ c |>\n<| c |>\nI got this working, except for one small\
    \ bug with the code. The result I get is \"lmo\", instead of \"lm\", even though\
    \ I think it should be. I'm unsure how I fix it, but it seems to be a matter of\
    \ adding a \"1\" to the end of a string when it's rotated 90 degrees. Thanks for\
    \ the help though! It led me in the right direction.\n<|/ c |>\n<| c |>\nSorry,\
    \ that one didn't work. I got \"mo\", instead of \"lm\". I think this one should\
    \ work though, I'll have to give it a shot in the morning. Thanks for your help!\n\
    <|/ c |>\n<| a dscore=1 |>\nI think I got it working. I'm new to Perl, so I'm\
    \ sure there are a lot of inefficiencies in this code, but I thought I'd share\
    \ with you guys what I've come up with. Thanks for your help guys. \n<code>",
  "    return $s . $alphabet[((ord($s) - 65) * 2) - 1];\n}", "    my(@c) = (65,90);\n\
    \    my($c);", "    my($r);\n    my($i, $j, $k);\n    my(@r);", "    my ($c, $x,\
    \ $y) = @_;\n    my ($i, $j, $k) = @_;\n    my $l = length($s);\n    my @ret;\n\
    \    for (my $i = 0; $i < $l; $i++) {\n\t$ret[$i] = 0;\n    }\n    my $k1 = $k\
    \ * 2;\n    $k %= $l;\n    $k -= 1;\n    my $k2 = $k * 2;\n    $k %= $l;\n   \
    \ $k -= 1;\n    for (my $i = 0; $i < $l; $i++) {\n\tif ($i == $x) {\n\t    $ret[$i]\
    \ = ord($s[$i]) + 1;\n\t    $ret[$i + 1] = $ret[$i] + ord($s[$i + 1]);\n\t} else\
    \ {\n\t    $ret[$i] = ord($s[$i]);\n\t}\n\t$ret[$i] = $ret[$i] % $y;\n\t$ret[$i]\
    \ /= $y;\n\t$ret[$i] = $ret[$i] * $k1;\n\t$ret[$i] += $ret[$i] * $k2;\n    }\n\
    \    my $ret2 = \"\";\n    for (my $i = 0; $i < $l; $i++) {\n\t$ret2 .= $ret[$i];\n\
    \    }\n    return $ret2;\n}", '    my($newstr);', '    my $alphabet = "abcdefghijklmnopqrstuvwxyz";',
  "    $s = $s . (\"a\"..\"z\").\"A\"..\"Z\";\n    $s =~ tr/[a-z]/[A-Z]/;\n    $s\
    \ =~ tr/[A-Z]/[a-z]/;\n    $s =~ tr/A-Z/a-z/;\n    return $s;\n}", "    \n   \
    \ # Step 1: Rotate the entire alphabet by two.\n    my(@alphabet) = (\"a\",\"\
    b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"\
    o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\");\n    my(@rotated_alphabet)\
    \ = ();\n    for (my $i = 0; $i < scalar(@alphabet); $i++) {\n        $rotated_alphabet[$i]\
    \ = $alphabet[$i];\n        $rotated_alphabet[$i+1] = $alphabet[$i];\n    }\n\
    \    # Step 2: Shift all of the letters down by two.\n    for (my $i = 0; $i <\
    \ scalar(@alphabet); $i += 2) {\n        $rotated_alphabet[$i] .= $rotated_alphabet[$i+1];\n\
    \        $rotated_alphabet[$i+1] .= $rotated_alphabet[$i];\n    }", "    my @a\
    \ = @_;\n    my $i = @a;\n    my $new = \"\";\n    while(@a){\n\t$new = substr($s,$i-1,1)\
    \ . substr($s,$i-2,1) . $new; \n\t$i--;\n\tpush(@a,substr($s,$i,1));\n    }\n\
    \    return $new;\n}", "    \n    # Shift down the letters by 2.\n    for(split(//,\
    \ $s)) {\n        $_ .= \"k\";\n    }", "    my $rotated_alphabet = map { shift(@_)\
    \ } qw(a b c d e f g h i j k l m n o p q r s t u v w x y z);\n    my $rot_shift\
    \ = 2;\n    return map { $rotated_alphabet[$_] } map {substr($s,$_,1)} 0..length($s)-1;\n\
    }", "    my $ltr = chr(ord($s) % 26);\n    return $ltr . $ltr if ($ltr != chr(0));\n\
    \    $ltr = chr(ord($s) % 26);\n    return $ltr . $ltr . $ltr;\n}\n</cell>\n<text>\n\
    Exercise 3\nWrite a program to decrypt a ciphertext using the Caesar cipher. The\
    \ Caesar cipher works by rotating the letters of the alphabet by two positions.\
    \ Given the key 3, the letters shifted are:", "    my($i, $a, $b, $c, $d, $e,\
    \ $f, $g, $h);\n    my(@l) = ();\n    my(@r);", "    \n    return shift($s) .\
    \ shift($s) . shift($s);\n}", "    my($c) = @_ ? @{pop} : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    my($c);\n    for (my $i = length($s) - 1;; $i--) {\n        $c = substr($c,\
    \ 0, 1) . $c . substr($c, 1);\n    }\n    $c;\n}", "    my($cx);\n    my($alpha)\
    \ = (\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\");\n    my(@chars);\n    my(@shifted);\n    my($i,$j);",
  "    my $alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    my $rotated_alphabet =\
    \ \"\";\n    my $length = 0;\n    while($s =~ /(\\w)/g) {\n        $rotated_alphabet\
    \ .= $alphabet[$s =~ /(\\w)/g % ($length + 1)];\n        $length++;\n    }\n \
    \   return $rotated_alphabet;\n}", '    my($i, $j, $k);', "    $s =~ tr/a-z/A-Z/;\n\
    \    $s . \"k\";\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou might want to explain\
    \ how your solution works. At least explain why it works. We don't want the OP\
    \ to just copy your code without understanding it.\n<|/ c |>\n<| c |>\nThe OP\
    \ has already shown an effort, and he wants to understand it.\n<|/ c |>\n<| c\
    \ |>\nI don't think you understand my point. I'm providing guidance, not an exact\
    \ answer.\n<|/ c |>\n<| c |>\nYour example of `encrypt(\"gf\")` is clear and simple,\
    \ but I believe it could be expanded to `encrypt(\"asdfghjkl\")` without being\
    \ too cryptic. Your example of `encrypt(\"hi\")` could also be expanded to `encrypt(\"\
    asdfghjklk\")`.\n<|/ c |>\n<| a dscore=1 |>\nI assume this is homework, so I am\
    \ not posting a direct solution, but rather just showing you the path of thinking\
    \ to accomplish your goal.\nStart with something simple: what is a 'rotation'\
    \ of a character?  Can you encrypt 'a' to 'b' by rotating the character down a\
    \ character at a time? If not, can you do it any other way?\nOnce you have that\
    \ simple answer, you can think about the problem in reverse: given a string, can\
    \ you determine the position(s) of every possible 'rotation'?  If so, can you\
    \ use that to build up a list of every possible encryption?  If not, can you still\
    \ do it in a similar fashion, but in reverse?  Finally, once you have a list of\
    \ every possible 'rotation', can you construct an algorithm to encrypt the string\
    \ in each one? If so, can you explain how you got from that to the final encrypted\
    \ string?\nIf all of that works, you're half way there.  If not, you still have\
    \ something to work with.\n<|/ a tags=perl |>\n<| c |>\nI like your answer, but\
    \ you might as well just write the code instead of writing a detailed description\
    \ of how to solve it.\n<|/ c |>\n<| c |>\nI'm looking at your solution, specifically\
    \ the two loops.  I feel like I understand how this works but the second loop\
    \ seems too convoluted for me.  How would I go about solving this without using\
    \ any loops?\n<|/ c |>\n<| c |>\n, I agree with you, but I was trying to point\
    \ out that an approach like this can give a better understanding of how to go ",
  '    my($l);', "    my($c, $i, $j, $d);\n    my($alphabet) = @_;\n    foreach $c\
    \ (@alphabet) {\n        $i = index($s, $c);\n        if ($i < 0) {\n        \
    \    $s = \"$c$s\";\n        } else {\n            $j = ($i + 1) % scalar(@alphabet);\n\
    \            $d = index($alphabet, $j);\n            $s = \"$d$s\";\n        }\n\
    \    }\n    $s;\n}", "    return $s;\n}", "    $alphabet = $shift;\n    $s = $alphabet[0..$#alphabet].$s.$alphabet[($#alphabet+1)..$#alphabet];\n\
    \    return $s;\n}", "    my($c1, $c2) = ($s->[0], $s->[1]);\n    my($l1, $l2)\
    \ = (length($c1), length($c2));\n    my($i, $j);", "    $s =~ tr/a-z/n-zA-Mn-zA-M/;\n\
    \    return $s;\n}", "    return unless $s;\n    my $alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    my @alphabet = split(\"\", $alphabet);\n    my @s = split(\"\", $s);\n\
    \    my @ret;", "    my $i = 0;\n    my $str = \"\";\n    while($i < length($s))\
    \ {\n        my $l = substr($s,$i,1);\n        my $j = $i+1;\n        while( ($j\
    \ < length($s)) && substr($s,$j,1) eq $l) {\n            $j++;\n        }\n  \
    \      $str .= substr($s,$i,1);\n        $str .= substr($s,$j-1,1);\n        $i\
    \ = $j;\n    }\n    return $str;\n}\n</code>\n<|/ a dscore=4 tags=string,encryption,perl\
    \ |>\n<| c |>\nThank you! This seems to work as intended. I'm curious to know\
    \ if there's a way of making things more efficient than this. What if I wanted\
    \ to encrypt a string, and have it return \"encrypted\" if the string is decrypted?\n\
    <|/ c |>\n<| c |>\nHmm, after looking at this for a while, I don't think this\
    \ is as efficient as it could be. As I understand it, you're recreating a string\
    \ `m{([a-z])}{rot13{$1} || substr($1,0,1) }g` in `rot13`. The rot13 substitution\
    \ could be done in one step `my $c = rot13 $s; $s =~ s/([a-z])/${c}{$1}/g;`. The\
    \ `substr` could be replaced with `$1 =~ tr/a-z/A-Z/;`.\n<|/ c |>\n<| c |>\n,\
    \ that would be a better answer.\n<|/ c |>\n<| c |>\n, I don't know how it could\
    \ be done in one step, but I can post an answer that would do it in two.\n<|/\
    \ c |>\n<| a tags=string,encryption,perl dscore=3 |>\nHere's a more efficient\
    \ version that doesn't require a full table lookup, based on a quick look into\
    \ the ASCII character table.  It takes about 100 times longer to perform the function\
    \ than a more compact version.  \nI modified the function slightly to return a\
    \ string rather than printing it.  You can then use $str =~ s/.../encrypt to do\
    \ the substitution.\n<code>", '    my $alphabet = $_[0];', "    my @chars = split('',\
    \ $$s);\n    my $cipher = \"\";\n    my $c = 0;\n    foreach my $char (@chars)\
    \ {\n        if ($c == 0) {\n            $cipher = $char . $cipher;\n        }\n\
    \        if ($c == 2) {\n            $cipher = $cipher . $char;\n        }\n \
    \       $c++;\n    }\n    return $cipher;\n}", "    $s =~ s/([^a-zA-Z])(.)([^a-zA-Z])/\\\
    1\\3\\2/;\n    $s =~ s/(.)([^a-zA-Z])/$1\\2\\3/;\n    $s =~ s/([^a-zA-Z])(.)/\\\
    1\\3/;\n    return $s;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
