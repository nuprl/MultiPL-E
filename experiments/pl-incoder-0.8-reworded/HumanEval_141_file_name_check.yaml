name: HumanEval_141_file_name_check
language: pl
prompt: "# Create a function which takes a string representing a file's name, and\
  \ returns\n# 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  # A file's name is considered to be valid if and only if all the following conditions\
  \ \n# are met:\n# - There should not be more than three digits ('0'-'9') in the\
  \ file's name.\n# - The file's name contains exactly one dot '.'\n# - The substring\
  \ before the dot should not be empty, and it starts with a letter from \n# the latin\
  \ alphapet ('a'-'z' and 'A'-'Z').\n# - The substring after the dot should be one\
  \ of these: ['txt', 'exe', 'dll']\n# Examples:\n# >>> file_name_check(\"example.txt\"\
  )\n# \"Yes\"\n# >>> file_name_check(\"1example.dll\")\n# \"No\"\nsub file_name_check\
  \ {\n    my($file_name) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&file_name_check;\n\
  \        if(eq_deeply($candidate->(\"example.txt\"),\"Yes\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1example.dll\"\
  ),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(\"s1sdf3.asd\"),\"No\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"K.dll\"),\"Yes\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  MY16FILE3.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->(\"His12FILE94.exe\"),\"No\")) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  _Y.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"?aREYA.exe\"),\"No\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"/this_is_valid.dll\"\
  ),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(\"this_is_valid.wow\"),\"No\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.txt\"\
  ),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->(\"this_is_valid.txtexe\"),\"No\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  #this2_i4s_5valid.ten\"),\"No\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"@this1_is6_valid.exe\"),\"\
  No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  this_is_12valid.6exe4.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"all.exe.txt\"),\"No\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  I563_No.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->(\"Is3youfault.txt\"),\"Yes\")) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  no_one#knows.dll\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"1I563_Yes3.exe\"),\"No\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  I563_Yes3.txtt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->(\"final..txt\"),\"No\")) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  final132\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"_f4indsartal132.\"),\"No\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  .txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
  \       if(eq_deeply($candidate->(\"s.\"),\"No\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($regexp) = qr{^[0-9]{3}\\.[a-z][a-z][a-z].*\\.(?:txt|exe|dll)$}i;\n\
    \    return $file_name =~ m/$regexp/i;\n}", "    return $file_name =~ /^[0-9]{3}\\\
    ./ && \n           $file_name =~ /^[a-zA-Z][a-zA-Z0-9]*\\./ &&\n           $file_name\
    \ =~ /^[^.].*$/\n          ? 'Yes'\n          : 'No'\n}", "    my($checked_name);\n\
    \    \n    my $regex = \"^[0-9]{1,3}$\";\n    # check if the file name contains\
    \ only one dot, and that it doesn't start with a digit\n    if ($file_name =~\
    \ m/\\./ && $file_name !~ m/\\./) {\n        $checked_name = \"No\";\n    }\n\
    \    elsif ($file_name !~ m/\\./ || $file_name !~ m/\\./) {\n        $checked_name\
    \ = \"No\";\n    }\n    elsif ($file_name =~ m/\\./ && !$file_name =~ m/\\./)\
    \ {\n        $checked_name = \"No\";\n    }\n    elsif ($file_name !~ m/\\./ &&\
    \ $file_name !~ m/\\./) {\n        $checked_name = \"No\";\n    }\n    # check\
    \ if the file name contains at least one digit\n    elsif ($file_name !~ m/\\\
    ./ && !$file_name !~ m/\\./) {\n        $checked_name = \"No\";\n    }\n    \n\
    \    # check if there is only one dot in the name\n    if ($file_name =~ m/\\\
    ./ && $file_name !~ m/\\./ && $file_name =~ m/\\./) {\n        $checked_name =\
    \ \"No\";\n    }\n    \n    # check if there is at least one digit\n    if ($file_name\
    \ !~ m/\\./ && $file_name !~ m/\\./) {\n        $checked_name = \"No\";\n    }\n\
    \    \n    # check if there is at least one letter in the name\n    if ($file_name\
    \ =~ m/\\./ && !$file_name =~ m/\\./ && $file_name =~ m/\\./) {\n        $checked_name\
    \ = \"No\";\n    }\n    \n    # check if there is more than one dot in the name\n\
    \    if ($file_name =~ m/\\./ && $file_name !~ m/\\./ && !$file_name =~ m/\\./)\
    \ {\n        $checked_name = \"No\";\n    }\n    \n    # check if there are any\
    \ letter after the dot\n    if ($file_name =~ m/\\./ && !$file_name =~ m/\\./\
    \ && $file_name =~ m/\\./) {\n        $checked_name = \"No\";\n    }\n    \n \
    \   # check if there are any digit after the dot\n    if ($file_name =~ m/\\./\
    \ && $file_name !~ m/\\./ && !$file_name =~ m/\\./) {\n        $checked_name =\
    \ \"No\";\n    }\n    \n    if ($checked_name eq \"No\") {\n        return \"\
    No\";\n    }\n    else {\n        return \"Yes\";\n    }\n}", "    chomp($file_name);\n\
    \    $file_name =~ /([a-zA-Z])/; # remove letters\n    $file_name =~ /([0-9]{3,})/;\
    \ # remove numbers\n    $file_name =~ /\\.[a-z]+/;\n    if ($file_name =~ /^[^\\\
    .]+\\.[a-z]+$/) {\n        return \"Yes\";\n    }\n    return \"No\";\n}", " \
    \   my $file_name = lc($file_name);\n    my ($substring, $dot_position, $start_letter_position)\
    \ = @_;", "    my $ret = \"No\";\n    my($file_length) = $file_name;\n    my($last_digit,\
    \ $dot_pos) = ();\n    while($file_length > 3) {\n\t$last_digit = substr($file_name,\
    \ -1, 1);\n\tif ($last_digit !~ /^[0-9]$/) {\n\t    $ret = \"No\";\n\t    last;\n\
    \t}\n    }\n    if (!$ret && $file_name !~ /^\\.\\./) {\n\t$ret = \"No\";\n  \
    \  }\n    return $ret;\n}", "    $file_name =~ /^(\\d+)\\.(.+)$/;\n    my($count)\
    \ = $1;\n    my($extension) = $2;\n    $extension !~ /^\\.$/;\n    $extension\
    \ !~ /^[a-z][a-z]$/;\n    if ($extension =~ /^exe$/i) {\n        my $ext = \"\
    exe\";\n        return $count eq '0' && $ext eq 'exe';\n    } elsif ($extension\
    \ =~ /^dll$/i) {\n        my $ext = \"dll\";\n        return $count eq '0' &&\
    \ $ext eq 'dll';\n    } elsif ($extension =~ /^txt$/i) {\n        my $ext = \"\
    txt\";\n        return $count eq '0' && $ext eq 'txt';\n    } else {\n       \
    \ return $count eq '0' && $extension !~ /^[exe|dll|txt]$/i;\n    }\n}", "    \n\
    \    # Make sure the user provided a valid file name.\n    if ($file_name !~ /^[0-9]+\\\
    .[a-z]+$/ ||\n        !$file_name_valid{$file_name} ||\n        !$file_name_valid{$file_name}{$1}\n\
    \       ) {\n\treturn 'No';\n    }", "    $file_name =~ /^[0-9]{1,3}[a-z][a-z][a-z].*$/i;\n\
    \    return $file_name =~ /(^\\.|\\.exe|\\.dll)$/i;\n}", "    $file_name = (split\
    \ /\\.(?=[^.]*$)/, $file_name)[0];\n    return if ($file_name =~ /^\\W*$/);\n\
    \    return if ($file_name =~ /^\\W*[a-z]$/i);\n    return if ($file_name =~ /^\\\
    W*[a-zA-Z]$/i);\n    return if ($file_name =~ /^\\W*[0-9]$/i);\n    return if\
    \ ($file_name =~ /^\\W*[xyz]$/i);\n    return \"Yes\";\n}", "    my($first_digit)\
    \ = $file_name =~ /^[0-9]*$/;\n    my($dot_found) = $file_name =~ /\\.$/;\n  \
    \  my($dot_start_letter) = $file_name =~ /[a-zA-Z]+/;\n    my($dot_end_letter)\
    \ = $file_name =~ /\\.[a-zA-Z]+$/;", "    $file_name =~ /^\\d+\\.\\w+$/;\n   \
    \ return !($file_name !~ /^\\d+\\.\\w+$/) && \n        $file_name !~ /^[a-z]+\\\
    .[a-z]+$/ && \n        $file_name !~ /^[a-z]+\\.[a-z]+\\.[a-z]+$/ && \n      \
    \  $file_name !~ /^[a-z]+\\.[a-z]+\\.[a-z]+\\.[a-z]+$/;\n}", "    return unless\
    \ $file_name =~ /^\\d{3}\\.[a-z][a-z].*$/i;\n    return unless $file_name =~ /\\\
    .[a-z][a-z]/i;\n    return if $file_name =~ /^\\.\\./;\n    return if $file_name\
    \ =~ /^[a-z]/;\n    return \"Yes\";\n}", "    my $valid_string = 'Yes';", "  \
    \  \n    # Find the number of digits, dots, and the start of the substring.\n\
    \    my @file_parts = split('.', $file_name);\n    my $num_digits = $file_parts[0]\
    \ =~ /^\\d+$/ ? $file_parts[0] : 0;\n    my $num_dots = $file_parts[0] =~ /^\\\
    d+\\./ ? $file_parts[0] : 0;\n    my $start_part = $file_parts[0] =~ /^[a-z]/\
    \ ? $file_parts[0] : 0;", "    return $file_name\n        unless $file_name =~\
    \ /^([0-9]{3}\\.)*[a-zA-Z]+/;\n    return $file_name =~ /^[a-zA-Z]+\\.txt$/ \n\
    \            || $file_name =~ /^[a-zA-Z]+\\.exe$/ \n            || $file_name\
    \ =~ /^[a-zA-Z]+\\.dll$/;\n}", "    \n    if($file_name) {\n        $file_name\
    \ =~ /^[0-9][0-9]+\\.([a-zA-Z]+)/; # Check that there is at least one digit\n\
    \        return $1 eq 'txt' || $1 eq 'exe' || $1 eq 'dll'; # Check that there\
    \ is exactly one of these extensions\n    }\n    else {\n        return 0;\n \
    \   }\n}", "    \n    # Check if there are more than 3 digits in the filename\n\
    \    my $num_digits = length($file_name) - length($file_name) % 3;\n    \n   \
    \ # If there are less than 3 digits in the filename\n    if ($num_digits < 3)\
    \ {\n        return 'No';\n    }\n    \n    # Check if there is exactly one dot\n\
    \    if (index($file_name, '.') != -1) {\n        return 'No';\n    }\n    \n\
    \    # Check if substring before dot is not empty\n    if (index($file_name, '.')\
    \ != -1 and substr($file_name,0,1) eq '.') {\n        return 'No';\n    }\n  \
    \  \n    # Check if substring after dot is txt, exe, or dll\n    if (index($file_name,\
    \ '.') != -1 and substr($file_name,index($file_name,'.'),2) !~ /txt|exe|dll/)\
    \ {\n        return 'No';\n    }\n    \n    # If all conditions are met\n    return\
    \ 'Yes';\n}", "    return undef if !($file_name);\n    \n    $file_name =~ /^[0-9]{3}\\\
    .\\.(.*)/;\n    $file_name = $1;\n    $file_name_valid = $file_name =~ /\\.(txt|exe|dll)/i;\n\
    \    return $file_name_valid;\n}", "    my $error = \"$file_name is not a valid\
    \ file name\";\n    if ($file_name_part !~ /^(\\w{3,})\\.(\\w{3,})$/) {\n    \
    \    return $error;\n    }\n    my $file = $file_name_part;\n    if ($file =~\
    \ /^\\d+$/) {\n        return \"$error - not a valid file name\";\n    }\n   \
    \ if ($file =~ /\\./) {\n        return \"$error - not a valid file name\";\n\
    \    }\n    if ($file =~ /^[a-zA-Z]+/) {\n        if ($file =~ /\\.txt$/) {\n\
    \            return \"$error - not a valid file name\";\n        }\n        if\
    \ ($file =~ /\\.exe$/) {\n            return \"$error - not a valid file name\"\
    ;\n        }\n        if ($file =~ /\\.dll$/) {\n            return \"$error -\
    \ not a valid file name\";\n        }\n    }\n    return \"$error - not a valid\
    \ file name\";\n}", "    my($valid) = \"\";\n    my($dot)   = \"\";\n    my($sub_str)\
    \ = \"\";\n    my($first_letter) = \"\";\n    my($last_letter) = \"\";\n    \n\
    \    # Check if file name has more than three digits.\n    if ($file_name =~ /^[0-9]+$/)\
    \ {\n        $valid = \"No\";\n    } elsif ($file_name !~ /^[0-9][0-9][0-9]+$/)\
    \ {\n        $valid = \"No\";\n    } else {\n        $valid = \"Yes\";\n    }",
  '    my($valid);', "    $file_name = \"$file_name\" unless $file_name;\n    \n \
    \   # Check if no dot in the name.\n    $file_name =~ s/\\.//;\n    $file_name\
    \ =~ s/^.//;\n    \n    # Check if file name contains more than three digits.\n\
    \    $file_name =~ s/\\d{3}//;\n    \n    # Check if file name contains two dots.\n\
    \    $file_name =~ s/\\.\\.//;\n    \n    # Check if substring before dot is not\
    \ empty.\n    $file_name =~ /^[a-zA-z].*$/;\n    \n    # Check if substring after\
    \ dot is one of these: ['txt', 'exe', 'dll'].\n    my @exe_types = ('txt', 'exe',\
    \ 'dll');\n    my $suffix;\n    $file_name =~ s/\\.([^\\.]+)$/ $suffix=$1; /;\n\
    \    \n    return $file_name eq \"exe\" if $suffix==@exe_types;\n    return $file_name\
    \ eq \"dll\" if $suffix==@exe_types;\n    return $file_name eq \"txt\";\n}", " \
    \   my $error = \"No\";\n    \n    foreach my $regex_pattern (qr/\\d{3}/, qr/\\\
    .[a-zA-z]$/, qr/[a-zA-z]/) {\n        # $regex_pattern will hold all regular expressions\
    \ we used in \n        # file_name_check() above in an array or list.\n      \
    \  if ($file_name =~ m/$regex_pattern/) {\n            return \"Yes\";\n     \
    \   }\n    }\n    \n    $error =  \"$file_name\" . \" is not valid. \";\n    return\
    \ $error;\n}", "    $file_name =~ /^[0-9]{0,3}\\.[a-zA-z]$/i;\n    !($file_name\
    \ =~ /^\\.[a-zA-z]/i) || ($file_name !~ /^\\.[a-zA-z][0-9]{1,3}\\.[a-zA-z]$/i)\
    \ ? \"No\" : \"Yes\";\n}", "    return $file_name if length($file_name) > 3;\n\
    \    return $file_name if index($file_name, \".\") < 1;\n    return $file_name\
    \ unless index($file_name, \".\") == 0 and\n                             substr($file_name,\
    \ 0, 1) =~ /^[[:alpha:]]/ and\n                             substr($file_name,\
    \ length($file_name) - 1) =~ /^[\\.\\w]*$/;\n    return $file_name if $file_name\
    \ =~ /\\.txt$/i;\n    return $file_name if $file_name =~ /\\.exe$/i;\n    return\
    \ $file_name if $file_name =~ /\\.dll$/i;\n    return \"No\";\n}\n</code>\nThe\
    \ second function uses a regular expression to determine if a file name is valid:\n\
    <code>", "    \n    # Make sure the string does not contain too many digits\n\
    \    if($file_name=~ /^[0-9]+$/) {\n\treturn \"No\";\n    }", "    \n    if ($file_name)\
    \ {\n        my $i = 0;\n        my $digits_length = length($file_name);\n   \
    \     \n        if ($digits_length <= 3) {\n            return $file_name;\n \
    \       }\n        elsif ($file_name=~/^[0-9]{3}$/) {\n            my $first_digit\
    \ = substr($file_name, 0, 1);\n            \n            if ($first_digit =~ /[^a-zA-Z]/\
    \ || $first_digit =~ /^[a-zA-Z]/) {\n                for (my $i = 1; $i <= $digits_length;\
    \ ++$i) {\n                    my $current_digit = substr($file_name, $i, 1);\n\
    \                    if ($current_digit =~ /[^a-zA-Z]/ || $current_digit =~ /^[a-zA-Z]/)\
    \ {\n                        return $file_name;\n                    }\n     \
    \           }\n            }\n        }\n    }\n    return \"No\";\n}", "    if(!$file_name)\
    \ { \n        die(\"Error: No file name provided\");\n    }", "    my($flag) =\
    \ 'No';\n    my(@pattern);\n    my($pattern) = '^[a-zA-Z0-9_\\\\.]{3,}';\n   \
    \ \n    if($file_name){\n        if($file_name=~/^(\\d+)\\.(\\d)*$/){\n      \
    \      $flag = 'Yes';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\\
    .(exe|dll)$/){\n            push, 'exe'; \n            push, 'dll'; \n       \
    \ }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\.(txt|config)$/){\n        \
    \    push, 'txt';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\.(jpg|jpeg|png|bmp|gif|tiff|bmp|tif|tga|tiff|dds)$/){\n\
    \            push, 'jpg';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\\
    d)*\\.(doc|docx|docm|doct|odt|rtf|txt|csv)$/){\n            push, 'doc';\n   \
    \     }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\.(rtf|docx|txt|csv|pdf|docm|docx|odt|ods|rtf|pdf|pdf|doct|txt|pdf|doc|docx|ods|pdf|pdf)$/){\n\
    \            push, 'rtf';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\\
    d)*\\.(jpg|jpeg|png|bmp|gif|tiff|bmp|tif|tga|tiff|dds)$/){\n            push,\
    \ 'bmp';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\.(jpg|jpeg|png|bmp|gif|tiff|bmp|tif|tga|tiff|dds)$/){\n\
    \            push, 'jpg';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\\
    d)*\\.(jpg|jpeg|png|bmp|gif|tiff|bmp|tif|tga|tiff|dds)$/){\n            push,\
    \ 'png';\n        }\n        elsif($file_name=~/^(\\d+)\\.(\\d)*\\.(jpg|jpeg|png|bmp|gif|tiff|bmp|tif|tga|tiff|dds)$/){\n\
    \            push, 'jpeg';\n        }\n        elsif", "    \n    my ($dotpos)\
    \ = $file_name =~ m/(\\..*)$/;\n    \n    if ($dotpos == '') {\n\treturn 'No';\n\
    \    }\n    \n    my $lastchar = $file_name[$dotpos-1];\n    \n    # Check if\
    \ the substring after the dot is one of the file types we are looking for.\n \
    \   # return 'No' if this substring is not one of the types we want.\n    if ($lastchar\
    \ !~ /(?:txt|exe|dll)/i) {\n\treturn 'No';\n    }\n    \n    my $firstchar = $file_name[$dotpos-1];\n\
    \    \n    if ($firstchar !~ m/[a-z]/i || $firstchar !~ m/[A-Z]/i) {\n\treturn\
    \ 'No';\n    }\n    \n    return ('Yes');\n}", "    # Input validation\n    if\
    \ ($file_name) {\n        # Check for the presence of a dot '.'\n        if ($file_name\
    \ =~ /\\./ && $file_name[0] =~ /^[a-zA-Z]+$/ && $file_name[1] =~ /^[^\\.]/ &&\
    \ $file_name[2]) {\n            # Check for the presence of a digit '0' - '9'\n\
    \            if ($file_name =~ /[^0-9]/ && $file_name[0] =~ /^[0-9]+$/ && $file_name[1]\
    \ =~ /^[0-9]+$/ && $file_name[2] =~ /^[0-9]+$/ && $file_name[3] =~ /^[0-9]+$/)\
    \ {\n                # Check for the presence of the three digits '0', '0', and\
    \ '0'.\n                if ($file_name =~ /[^0-9]/ && $file_name[0] =~ /^[0-9]+$/\
    \ && $file_name[1] =~ /^[0-9]+$/ && $file_name[2] =~ /^[0-9]+$/) {\n         \
    \           # Check for the presence of the three digits '0' - '9'\n         \
    \           if ($file_name =~ /[^0-9]/ && $file_name[0] =~ /^[0-9]+$/ && $file_name[1]\
    \ =~ /^[0-9]+$/ && $file_name[2] =~ /^[0-9]+$/) {\n                        # Check\
    \ for the presence of the three digits '0' - '9'\n                        if ($file_name\
    \ =~ /[^0-9]/ && $file_name[0] =~ /^[0-9]+$/ && $file_name[1] =~ /^[0-9]+$/ &&\
    \ $file_name[2] =~ /^[0-9]+$/) {\n                            # Check for the\
    \ presence of the three digits '0' - '9'\n                            return \"\
    Yes\";\n                        } else {\n                            return \"\
    No\";\n                        }\n                    } else {\n             \
    \           return \"No\";\n                    }\n                } else {\n\
    \                    return \"No\";\n                }\n            } else {\n\
    \                return \"No\";\n            }\n        } else {\n           \
    \ return \"No\";\n        }\n    } else {\n        return \"No\";\n    }\n}",
  "    my %file_name = split \"/\", $file_name;\n    my $file_check = sub {\n    \
    \    my $name = shift;\n        if($name =~ m/[^0-9\\.]/) {\n            return\
    \ 0;\n        }\n        if($name =~ m/[^a-z]/ && ($name !~ /^\\./) && ($name\
    \ !~ /^$/) && ($name !~ /^[^a-zA-Z]/)) {\n            return 0;\n        }\n \
    \       if($name =~ m/\\.[^a-zA-Z]/) {\n            return 0;\n        }\n   \
    \     if($name =~ m/[a-z]/ && ($name !~ /^\\./) && ($name !~ /^$/) && ($name !~\
    \ /^[^a-zA-Z]/)) {\n            return 0;\n        }\n        if($name =~ m/^[a-z]/)\
    \ {\n            return 0;\n        }\n        return 1;\n    };\n    my $valid\
    \ = map {$_ || &file_check($_)} @{ $file_name{0..$#file_name - 1} };\n    return\
    \ $valid;\n}", "    my($dot_pos) = $file_name =~ /^(.*?\\.)[^\\.]*$/;\n    if\
    \ ($dot_pos > 0) {\n        my($before_dot_pos) = $file_name =~ /^(.*?)[^\\.]$/;\n\
    \        my $before_dot_name = $before_dot_pos > 0 ? $1 : \"empty\";\n       \
    \ if ($before_dot_pos !~ /^[a-z]$/i || $before_dot_name ne \"empty\") {\n    \
    \        return \"No\";\n        }\n    }\n    my($extension_pos) = $file_name\
    \ =~ /^(.*?)\\.([^\\.]*?)$/;\n    my $extension = $extension_pos > 0 ? $2 : \"\
    empty\";\n    if ($extension_pos !~ /^(exe|dll|txt|html)$/i || $extension ne \"\
    empty\") {\n        return \"No\";\n    }\n    return \"Yes\";\n}", "    my($dot_pos)\
    \ = index($file_name, '.');\n    my($letter) = index($file_name, 'a', 1);\n  \
    \  return if ($dot_pos > -1 && $dot_pos < 3 && $dot_pos < $file_name.length &&\
    \ ($letter > -1 || $letter < 0));\n    return \"No\";\n}\n</code>\n<|/ a tags=perl,file,validation,regex\
    \ dscore=3 |>\n<| a dscore=2 tags=perl,file,validation,regex |>\nI believe that\
    \ the answers are all overcomplicated.\nThe file name is a string consisting of\
    \ 0 to N characters and dot.\nThe most simple regex would be:\n<code>\n/^[a-z][a-z0-9.]*$/i\n\
    </code>\nThe only drawback is that it is case-insensitive.\nBut I believe the\
    \ following code covers all cases:\n<code>", "    my $pattern = /^[\\d]{3,}$/\
    \ or return;\n    my $dot_pattern = /\\./ or return;\n    my $before_dot_pattern\
    \ = m/\\A[^.]/ or return;\n    my $after_dot_pattern = m/\\.[^.]/ or return;\n\
    \    if ($dot_pattern && $before_dot_pattern && $after_dot_pattern &&\n      \
    \      length($file_name) > 1 && \n            $file_name=~ /\\.txt$/i &&\n  \
    \          $file_name=~ /\\.exe$/i &&\n            $file_name=~ /\\.dll$/i)\n\
    \    {\n        return 'Yes';\n    }\n    return 'No';\n}", "    \n    # Check\
    \ for valid file names\n    if ($file_name=~/^[0-9]*$/ && $file_name=~/\\./) {\n\
    \        # check for valid extensions\n        my $extension = $file_name;\n \
    \       $extension =~ s/\\.$//;\n        return $extension =~ /txt|exe|dll/;\n\
    \    }\n    else {\n        return 0;\n    }\n}", "    my $found = 0;\n    foreach\
    \ my $pattern (qw/txt exe dll/) {\n        if($file_name =~ m{^($pattern)\\d*\\\
    .$}) {\n            $found = 1;\n            last;\n        }\n    }\n    return\
    \ $found ? \"Yes\" : \"No\";\n}", "    return if $file_name !~ /^\\d+\\.(txt|exe|dll)$/;\n\
    \    my $file_parts = split('.', $file_name);\n    return if @$file_parts > 2;\n\
    \    return if $file_parts[0] =~ /[a-z]|[A-Z]/ and $file_parts[0] =~ /^$/ and\
    \ $file_parts[1] !~ /[txt|exe|dll]/;\n    return unless $file_parts[0] =~ /^[a-z]|[A-Z]/;\n\
    \    return unless $file_parts[1] =~ /[txt|exe|dll]/;\n    return \"Yes\";\n}",
  "    return 1 if length($file_name) > 3 || $file_name=~/^\\d+\\./ || $file_name=~/^\\\
    w/ && $file_name=~/^[^a-z]/ && ($file_name=~/^./ || $file_name=~/^\\.\\w+$/);\n\
    \    return \"No\";\n}", "    my(@file_types) = qw(text exe dll);\n    my($file_length)\
    \ = (length($file_name));\n    my($file_length_after_dot_check) = 0;\n    my($file_length_before_dot_check)\
    \ = 0;\n    my($file_check) = \"No\";", "    \n    return 1 if !$file_name;\n\
    \    \n    my($dots_pos) = index($file_name, \".\");\n    my($dots_pos2) = index($file_name,\
    \ \".\", -1);\n    \n    return 1 if $dots_pos == -1 || $dots_pos2 == -1 || $dots_pos\
    \ > $dots_pos2;\n    \n    my($letters_pos) = index($file_name, \"^[a-Z].\");\n\
    \    my($letters_pos2) = index($file_name, \"^[a-Z].\", -1);\n    \n    return\
    \ 1 if $letters_pos == -1 || $letters_pos2 == -1 || $letters_pos > $letters_pos2;\n\
    \    \n    return 1;\n}", "    my($dot_count);\n    my($dot_position);\n    my($dot_location);\n\
    \    my($first_char);\n    my($last_char);\n    my($valid_extension);\n    my($valid_characters);",
  "    chomp($file_name);\n    if(length($file_name) > 3 or \n       index($file_name,\
    \ \".\") == -1 or \n       index($file_name, \"\") != 1 or \n       index($file_name,\
    \ \".\")[0] != (index($file_name, \".\")[0] or 'A'-'Z') or\n       index($file_name,\
    \ \".\")[-1] != (index($file_name, \".\")[-1] or 'a'-'z')) { \n\treturn \"No\"\
    ;\n    }\n    return \"Yes\";\n}\n</code>\n2. Create a functions which will take\
    \ a string representing a file's name, and returns \nthe file's extension. \n\
    This is your second function. \n<code>", "    # Get the file's name without extension\n\
    \    my $file_name = basename($file_name);\n    # Check if it has more than one\
    \ dot in it\n    return $file_name =~ m{\\.[^\\.]*\\.}s if $file_name =~ m{\\\
    .\\.};\n    # Check if it contains more than one dot\n    return $file_name =~\
    \ m{\\.[^\\.]*}s if $file_name =~ m{\\.};\n    # Check if it starts with a letter\n\
    \    return $file_name =~ m{^[a-zA-Z]}s if $file_name =~ m{^[^\\.]};\n    # Check\
    \ if it ends with txt, exe, dll\n    return $file_name =~ m{\\.(?:txt|exe|dll)}s\
    \ if $file_name =~ m{\\.\\.};\n    return \"No\";\n}\n</code>\n<|/ a tags=perl,validation,regex\
    \ |>\n<| c |>\nThis isn't a particularly good solution. `/^[^.]*\\.[^.]*$` is\
    \ far too strict.\n<|/ c |>\n<| c |>\nThat sounds much better!\n<|/ c |>\n<| c\
    \ |>\n: Could you explain why it's too strict?\n<|/ c |>\n<| c |>\nIt's too strict\
    \ because it will also match `some.file`, for instance. And because it will match\
    \ `example.file.txt`. The solution is far more flexible than that.\n<|/ c |>\n\
    <| a tags=perl,validation,regex dscore=1 |>\nIf you're willing to use the File::Basename::fileparts\
    \ module, you can do this:\n<code>\nuse strict;\nuse warnings;\nuse File::Basename::fileparts;",
  "    my($is_valid);\n    \n    # Check if the filename is 3 characters long\n  \
    \  if(length($file_name) != 3) {\n        $is_valid = \"No\";\n    }\n    else\
    \ {\n        # Check if the filename contains exactly one dot\n        if($file_name\
    \ =~ m/^[^\\.]\\./) {\n            $is_valid = \"No\";\n        }\n        else\
    \ {\n            # Check if the substring before the dot is empty, and that it\
    \ starts with a letter from the latin alphabet\n            if($file_name =~ m/^\\\
    ./) {\n                if($file_name =~ m/^[a-z]+\\z/i) {\n                  \
    \  $is_valid = \"Yes\";\n                }\n                else {\n         \
    \           $is_valid = \"No\";\n                }\n            }\n          \
    \  else {\n                $is_valid = \"No\";\n            }\n        }\n   \
    \ }\n    \n    return $is_valid;\n}\n</cell>\n<cell>", "    my($is_invalid) =\
    \ undef;\n    my($length);", "    my $file_name = lc($file_name);\n    if ($file_name\
    \ =~ /^\\d+$/) {\n        if ($file_name !~ /\\.$/ || $file_name !~ /^[a-z]+\\\
    ./) {\n            foreach my $file_extension (@file_extensions) {\n         \
    \       if ($file_name =~ /\\.$file_extension$/) {\n                    return\
    \ \"Yes\";\n                }\n            }\n        }\n    } else {\n      \
    \  return \"No\";\n    }\n    return \"No\";\n}", "    my($file_valid) = 'No';",
  "    my($file_extension);\n    my($file_part);\n    my(@file_parts);\n    my($file_part_len);\n\
    \    my($file_part_count);\n    my($file_part_count);\n    my($file_part_count_minus_1);\n\
    \    my($file_part_count_minus_2);\n    my($file_part_count_minus_3);\n    my($file_part_count_minus_4);\n\
    \    my($file_part_count_minus_5);\n    my($file_part_count_minus_6);\n    my($file_part_count_minus_7);\n\
    \    my($file_part_count_minus_8);\n    my($file_part_count_minus_9);\n    my($file_part_count_minus_10);\n\
    \    my($file_part_count_minus_11);\n    my($file_part_count_minus_12);\n    my($file_part_count_minus_13);\n\
    \    my($file_part_count_minus_14);\n    my($file_part_count_minus_15);\n    my($file_part_count_minus_16);\n\
    \    my($file_part_count_minus_17);\n    my($file_part_count_minus_18);\n    my($file_part_count_minus_19);\n\
    \    my($file_part_count_minus_20);\n    my($file_part_count_minus_21);\n    my($file_part_count_minus_22);\n\
    \    my($file_part_count_minus_23);\n    my($file_part_count_minus_24);\n    my($file_part_count_minus_25);\n\
    \    my($file_part_count_minus_26);\n    my($file_part_count_minus_27);\n    my($file_part_count_minus_28);\n\
    \    my($file_part_count_minus_29);\n    my($file_part_count_minus_30);\n    my($file_part_count_minus_31);\n\
    \    my($file_part_count_minus_32);\n    my($file_part_count_minus_33);\n    my($file_part_count_minus_34);\n\
    \    my($file_part_count_minus_35);\n    my($file_part_count_minus_36);\n    my($file_part_count_minus_37);\n\
    \    my($file_part_count_minus_38);\n    my($file_part_count_minus_39);\n    my($file_part_count_minus_40);\n\
    \    my($file_part_count_minus_41);\n    my($file_part_count_minus_42);\n    my($file_part_count_minus_43);\n\
    \    my($file_part_count_minus_44);\n    my($file_part_", "    my($num_digits);\n\
    \    my($first_dot_found);\n    my($dot_pos);\n    my(@errors);\n    my($first_char);\n\
    \    my($last_char);\n    my($dot_in_name);\n    my($valid);", "    return if\
    \ ($file_name !~ /^[0-9]{3}\\./);\n    return if ($file_name !~ /^[a-z][a-z][a-z]./);\n\
    \    return if ($file_name !~ /^[a-z][a-z][a-z]\\.txt$/);\n    return if ($file_name\
    \ !~ /^[a-z][a-z][a-z]\\.exe$/);\n    return if ($file_name !~ /^[a-z][a-z][a-z]\\\
    .dll$/);\n    return \"Yes\";\n}", "    return if($file_name !~ /^[0-9]{3}\\.\\\
    .(\\w.*)$/);\n    return if($1 eq '.');\n    return if($1 !~ /^[a-zA-Z][a-zA-Z0-9]*$/);\n\
    \    return if($1 !~ /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z][a-zA-Z0-9]*$/);\n    return\
    \ \"Yes\";\n}", "    my($num_digits) = 0;\n    my($dot_found) = 0;\n    my($dot_before)\
    \ = \"\";\n    my($dot_after) = \"\";", "    return (\"Yes\" if ($file_name =~\
    \ /^[0-9]{3}\\.[^.]+\\.[a-zA-z]{0,3}\\z/ && \n                      $file_name\
    \ =~ /^[a-zA-z][.]/ && \n                      $file_name !~ /^\\./ && \n    \
    \                  $file_name !~ /[^a-zA-z]/));\n}", "    return if($file_name=~/^[1-9][0-9]{0,3}\\\
    .[a-z]{0,2}$/i);\n    return if($file_name=~/^[^\\.]\\./i);\n    return if($file_name=~/^[a-z]+\\\
    ./i);\n    return if($file_name=~/^[^\\.]*\\.(exe|dll|txt)$/i);\n    return \"\
    Yes\";\n}", "    my ($invalid) = ();\n    $file_name =~ /^\\d{3}\\.txt|exe|dll$/;\n\
    \    push(@$invalid, $file_name =~ /^[^\\.].*[^\\.]$/);\n    push(@$invalid, $file_name\
    \ =~ /^[^\\.].*[^\\.][a-z].*$/);\n    push(@$invalid, $file_name =~ /^[^\\.].*[^\\\
    .][a-z][a-z].*$/);\n    if (scalar(@$invalid) > 0) {\n        return \"No\";\n\
    \    } else {\n        return \"Yes\";\n    }\n}", '    my $is_valid = 1;', " \
    \   $file_name =~ /^[a-z][a-z0-9\\.]*$/i;\n    if($file_name =~ /^[^\\.]+\\.[^\\\
    .]+$/i && $1 ne \"\") {\n        if(grep { /^[a-z][a-z0-9]*$/ } split '\\.', $1)\
    \ {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n}", " \
    \   my($count) = ($file_name =~ /^(\\d+)\\.([a-z])/);\n    if ($count > 1 && $1\
    \ !~ /^\\d+$/ || $2 !~ /^[a-zA-Z]+$/ || $3 !~ /^([a-z]|\\.)/ ) {\n        return\
    \ $file_name =~ /^(\\S+)\\.([a-z])$/ ? 'Yes' : 'No';\n    }\n    return 'Yes';\n\
    }", "    my($dot) = ($file_name =~ /^\\.+$/);\n    my($letter) = ($file_name =~\
    \ /[a-z]\\w+/i);\n    my($letter_after) = ($file_name =~ /\\.[a-z]\\w+/i);\n \
    \   my($non_empty) = ($file_name =~ /^[^.]+/);\n    my($non_empty_letter) = ($file_name\
    \ =~ /^[^\\.]+/);\n    my($non_empty_letter_after) = ($file_name =~ /^[^\\.]+/);\n\
    \    if ($dot && $non_empty && $letter && $letter_after && $non_empty_letter &&\
    \ $non_empty_letter_after) {\n        return 'Yes';\n    } else {\n        return\
    \ 'No';\n    }\n}", "    # Check the file name length.\n    return if ($file_name_len\
    \ == 0);", "    my($dot_count) = 0;\n    my($first_char) = \"\";\n    my($file_ending)\
    \ = \"\";\n    my($sub_string) = \"\";\n    my(@error_type) = (\"No\", \"Yes\"\
    );\n    \n    # Extract the first character from the string passed to this function\n\
    \    if ($file_name=~/^[0-9]{3}$/) {\n        $first_char = $1;\n    } else {\n\
    \        push, \"'$file_name' should be a string consisting of exactly 3 digits\"\
    ;\n        return;\n    }\n    \n    # Extract the last character from the string\
    \ passed to this function\n    if ($file_name=~/^[0-9]{3}\\.(.)$/) {\n       \
    \ $file_ending = $1;\n    } else {\n        push, \"'$file_name' should end with\
    \ '.'\";\n        return;\n    }\n    \n    # Check if the string contains a dot\
    \ '.' and if it starts with a letter from the latin alphapet\n    if ($file_name=~/^[0-9]{3}\\\
    .[A-z].*\\..*$/) {\n        $sub_string = $1;\n    } elsif ($file_name=~/^[0-9]{3}\\\
    .[A-z].*$/) {\n        $sub_string = $1;\n    } else {\n        push, \"'$file_name'\
    \ should contain a dot '.'\";\n        return;\n    }\n    \n    # Check if the\
    \ substring after the dot is one of these: ['txt', 'exe', 'dll']\n    if (grep(!/^[a-z]+$/,$sub_string))\
    \ {\n        push, \"'$file_name' should end with one of these: ['txt', 'exe',\
    \ 'dll']\";\n        return;\n    }\n    \n    return (\"Yes\");\n}", "    if\
    \ ( $file_name=~/^[0-9]{3}\\./ ) {\n        if ( $file_name=~/^[0-9]{3}\\./) {\n\
    \            if ( $file_name =~ /^[0-9]{3}\\.([a-zA-Z]|$)/ ) {\n             \
    \   return \"Yes\";\n            }\n            else {\n                return\
    \ \"No\";\n            }\n        }\n        else {\n            return \"No\"\
    ;\n        }\n    }\n    else {\n        return \"No\";\n    }\n}", "    my($valid)\
    \ = 0;\n    $file_name =~ s/[^a-zA-Z0-9]//g;\n    $file_name =~ s/^\\.//;\n  \
    \  $file_name =~ s/\\.[^\\.]+$//;\n    foreach my $dot_check (qw/txt exe dll/)\
    \ {\n        $file_name =~ m/$dot_check/;\n        if ($dot_check eq \"exe\")\
    \ {\n            $file_name =~ /^[a-zA-Z0-9]$/;\n        }\n        elsif ($dot_check\
    \ eq \"dll\") {\n            $file_name =~ /^[A-Za-z]$/;\n        }\n        else\
    \ {\n            $valid = 1;\n        }\n        if ($valid != 1) {\n        \
    \    $valid = 0;\n        }\n    }\n    return $valid;\n}", "    $file_name =~\
    \ /^(?!.*(.{3}).*\\..*$)[a-zA-Z][a-zA-z\\.]+\\.[a-zA-Z]{2,4}$/i;\n}\n</code>\n\
    This function is only valid for filenames with 3 characters only and file extensions\
    \ of .exe, .dll and .txt. \nThe above code checks the file name only if it is\
    \ longer than 3 characters. \nThe above code checks the file name only if the\
    \ dot '.' is not present.\nThe above code checks the file name only if the substring\
    \ before the dot is not empty, and it starts with a letter from the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\nThe above code checks the file name only if the substring\
    \ after the dot is one of these: ['txt', 'exe', 'dll']\n<|/ a tags=perl,regex\
    \ dscore=1 |>\n<| c |>\nWhile this may work it's really bad in perl. Why? Because\
    \ `\\w` is locale aware. With other locales `\\w` might not match anything at\
    \ all! (`\\w` is defined in `perllocale`)\n<|/ c |>\n<| c |>\n, You are right,\
    \ `\\w` works only for English alphabet, I have updated the answer to reflect\
    \ this.\n<|/ c |>\n<| c |>\nIf you use \\w to match letters, numbers, underscore,\
    \ and hyphens, you're doing a regex to match a specific language.  Why not just\
    \ use \\p{L} instead?\n<|/ c |>\n<| c |>\n, Perl regex also supports `\\p{L}`\
    \ but it is locale-dependent, it works on English and other European languages\
    \ too. `\\w` also works on `\xC0\xC1\xC2\xC3\xC4\xC5\u0100\u0102\u0104\u0105\u0106\
    \u0107\u010C\u010D\u010E\u010F\u0110\u0111\u0113\u0115\u0117\u011A\u011B\u011D\
    \u011F\u0121\u0123\u0124\u0125\u0126\u0127\u0129\u012B\u012D\u012F\u012E\u0130\
    \u0131\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013C\u0141\u0142\u0143\u0144\
    \u0145\u0146\u0147\u0148\u0149\u014A\u014B\u014C\u014D\u014E\u014F\u0150\u0151\
    \u0152\u0153\u0154\u0155\u0156\u0157\u0158\u0159\u015A\u015B\u015C\u015D\u015E\
    \u015F\u0160\u0161\u0162\u0163\u0164\u0165\u0166\u0167\u0169\u016B\u016D\u016F\
    \u016E\u0170", "    my($ret);\n    \n    $ret = substr($file_name, 0, 3) ne \"\
    000\" && substr($file_name, 0, 3) ne \"001\" && \n        substr($file_name, 0,\
    \ 3) ne \"002\" && substr($file_name, 0, 3) ne \"003\" && \n        substr($file_name,\
    \ 0, 3) ne \"004\" && substr($file_name, 0, 3) ne \"005\" && \n        substr($file_name,\
    \ 0, 3) ne \"006\" && substr($file_name, 0, 3) ne \"007\" && \n        substr($file_name,\
    \ 0, 3) ne \"008\" && substr($file_name, 0, 3) ne \"009\" && \n        substr($file_name,\
    \ 0, 1) ne \"010\" && substr($file_name, 0, 1) ne \"011\" && \n        substr($file_name,\
    \ 0, 1) ne \"012\" && substr($file_name, 0, 1) ne \"013\" && \n        substr($file_name,\
    \ 0, 1) ne \"014\" && substr($file_name, 0, 1) ne \"015\" && \n        substr($file_name,\
    \ 0, 1) ne \"016\" && substr($file_name, 0, 1) ne \"017\" && \n        substr($file_name,\
    \ 0, 1) ne \"018\" && substr($file_name, 0, 1) ne \"019\";", "    \n    #\n  \
    \  # Validate file name\n    #\n    if ($file_name =~ /([A-Za-z0-9]+\\.[a-z][a-z][a-z])/)\
    \ {\n        return $file_name;\n    }\n    else {\n        return \"No\";\n \
    \   }\n}", "    $file_name =~ /^[0-9]+\\.[^.]+$/;\n    $file_name =~ /^[a-z][a-zA-Z0-9_]*\\\
    .txt$/i;\n    $file_name =~ /^[a-z][a-zA-Z0-9_]*\\.exe$/i;\n    $file_name =~\
    \ /^[a-z][a-zA-Z0-9_]*\\.dll$/i;\n    $file_name;\n}", "    my($dot_pos) = index($file_name,\
    \ '.');\n    my($dot_len) = $dot_pos - 0;\n    my($dot_len2) = $dot_len + 1;\n\
    \    my($file);\n    my($first_char) = (length($file_name) - $dot_len);\n    my($first_char_check)\
    \ = ($first_char =~ /^[[:alpha:]]/);\n    my($first_char_check_not) = ($first_char\
    \ !~ /^[[:alpha:]]/);\n    my($first_char_check_cap_len) = (length($first_char)\
    \ - 1);\n    my($first_char_check_cap_len_not) = ($first_char_check_cap_len !~\
    \ /^[0123456789]/);\n    my($file_check);\n    my($file_check_not);\n    my($file_check_cap_len)\
    \ = (length($file_name) - $dot_len2);\n    my($file_check_cap_len_not) = ($file_check_cap_len\
    \ !~ /^[0123456789]/);\n    my($file_name_check_pos);\n    my($file_name_check_cap_pos);\n\
    \    my($file_name_check_cap_len_pos);\n    my($file_name_check_len);\n    my($file_name_check_cap_len_len);\n\
    \    my($file_name_check_start_pos);\n    my($file_name_check_cap_start_pos);\n\
    \    my($file_name_check_cap_len_start_pos);\n    my($file_name_check_end);\n\
    \    my($file_name_check_cap_end);\n    my($file_name_check_cap_len_end);\n  \
    \  my($file_name_check_end_not);\n    my($file_name_check_cap_end_not);\n    my($file_name_check_cap_len_end_not);\n\
    \    my($file_name_check_end_cap_pos);\n    my($file_name_check_cap_end_cap_pos);\n\
    \    my($file_name_check_cap_len_end_cap_pos);\n    my($file_name_check_end_cap_len_pos);\n\
    \    my($file_name_check_end_cap_len_len_pos);\n    my($file_name_check_end_cap_len_end_cap_pos);\n\
    \    my($file_name_check_end_cap_len_end_cap_len_pos);\n    my($file_name_check_end_cap_len_end_cap_len_end_cap_pos);\n\
    \    my($file_name_check_end_cap_len_end_cap_len_end_cap_len_pos);\n    my($file_name_check_end_cap_len_end_cap_len_end_",
  "    return 1 if ($file_name_length <= 3 && $file_name_index != -1 && $file_name_index\
    \ != $file_name_length && $file_name[$file_name_index] ne \".\" && ($file_name_index\
    \ !=1 && $file_name[$file_name_index-1] ne \"a\" && $file_name[$file_name_index-1]\
    \ ne \"z\" && $file_name[$file_name_index-1] ne \"A\" && $file_name[$file_name_index-1]\
    \ ne \"Z\" && $file_name[$file_name_index-2] ne \".\" && $file_name[$file_name_index-2]\
    \ ne \"txt\" && $file_name[$file_name_index-2] ne \"exe\" && $file_name[$file_name_index-2]\
    \ ne \"dll\"));\n    return \"No\";\n}", "    my ($file_type, $dir_type) = file_type($file_name);\n\
    \    return $file_type eq 'text' &&\n            $dir_type eq 'directory' &&\n\
    \            !substr_lt($file_name, '.') &&\n            substr($file_name, 0,\
    \ 1) =~ /^[a-z]/ &&\n            grep(!/^\\.\\w+$/, split('.', $file_name));\n\
    }", "    \n    # Initialize variables.\n    my $check;\n    my $err_msg;\n   \
    \ my $file_name_components;\n    my $num_digits;\n    my $dot_position;\n    my\
    \ $dot_component;\n    my $first_letter;\n    my $dot_len;\n    my $dot_len_component;\n\
    \    \n    # Error if more than one digit was found\n    $check = $file_name_components\
    \ !~ /^[0-9]{3}$/;\n    $err_msg = $check ? 'File name contains more than three\
    \ digits.' : 'File name does not contain any digit.';\n    \n    # Error if the\
    \ file contains more than one dot\n    $check = $file_name_components !~ /\\.\\\
    .$/;\n    $err_msg = $check ? 'File name contains more than one dot.' : 'File\
    \ name does not contain any dot.';\n    \n    # Error if file name does not contain\
    \ valid string\n    $check = $file_name_components !~ /^[^\\.]+\\.[^\\.]+$/;\n\
    \    $err_msg = $check ? 'File name does not start with letter or underscore.'\
    \ : 'File name starts with one or more letters from latin alphabet or underscore.';\n\
    \    \n    # Get the first letter of the file name\n    $first_letter = $file_name_components\
    \ !~ /[^\\.]+/;\n    $err_msg = $check ? 'File name starts with non-letter.' :\
    \ 'File name starts with letter.';\n    \n    # Check if file name starts with\
    \ dot\n    $check = $file_name_components !~ /^\\.$first_letter/;\n    $err_msg\
    \ = $check ? 'File name starts with dot.' : 'File name does not start with dot.';\n\
    \    \n    # Check if file name contains dot\n    $check = $file_name_components\
    \ !~ /\\.$first_letter/;\n    $err_msg = $check ? 'File name contains dot.' :\
    \ 'File name does not contain dot.';\n    \n    # Check if file name ends with\
    \ dot\n    $check = $file_name_components !~ /^$first_letter\\.$/;\n    $err_msg\
    \ = $check ? 'File name ends with dot.' : 'File name does not end with dot.';\n\
    \    \n    # Check if file name is valid extension\n    my $valid_extensions =\
    \ (qw(txt exe dll));\n    \n    $dot_position = index($file_name_components, '.');\n\
    \    $dot_component = substr($file_name_components, $dot_position+1, 1);\n   \
    \ $dot_len_component = length($dot_component);\n    $err_msg = $check ? 'File\
    \ name ends with invalid extension.' : !$valid_extensions || $dot_len_component\
    \ != $valid_extensions ? \"File name does not end with valid extension.\" : '';\n\
    \    \n    return $err_msg;\n}", "    $file_name =~ /^[0-9]{1,3}[a-z][a-zA-Z\\\
    .]/ && \n      $file_name =~ /^[a-z][a-zA-Z\\.]/ && \n      $file_name =~ /^[a-zA-Z\\\
    .]/;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    my ($first_dot);\n\
    \    \n    my $file_name = lc $file_name;\n    \n    if ($file_name =~ m/^[0-9]{3}\\\
    .\\.$/) {\n\t$first_dot = $file_name =~ m/^([0-9])\\.(.*)$/;\n\t\n\tif ($first_dot\
    \ && $first_dot != \".\") {\n\t    return $first_dot eq \".\" || $first_dot eq\
    \ \"..\";\n\t} else {\n\t    return 0;\n\t}\n    } else {\n\treturn 0;\n    }\n\
    }", "    # Get the file's name and remove the dot ('.').\n    my $file_name =\
    \ substr($file_name, 0, index($file_name, \".\"));\n    # Remove any non-letter\
    \ or digit from the beginning of the file's name.\n    $file_name =~ s/^[^a-zA-Z\\\
    d]//;\n    # If the file's name contains one dot '.', and it does not start with\
    \ a letter\n    # from latin alphapet ('a'-'z' and 'A'-'Z'), then return 'No'.\n\
    \    return $file_name if index($file_name, \".\") != -1;\n    # Remove any non-letter\
    \ or digit from the end of the file's name.\n    $file_name =~ s/[^a-zA-Z\\d]$//;\n\
    \    # If the file's name does not end with the extensions mentioned above, then\
    \ return 'No'.\n    return $file_name unless grep(/^(exe|dll)$/i, $file_name);\n\
    \    # If the file's name ends with the extensions mentioned above, then return\
    \ 'Yes'.\n    return \"Yes\";\n}", "    \n    my $check = qr{^[1-9][0-9]{0,3}\\\
    .(tx|exe|dll)$};", "    \n    if($file_name =~ /^[0-9]{0,3}\\.[^\\.]$/){\n\treturn\
    \ \"Yes\";\n    }\n    elsif($file_name =~ /^[a-zA-Z]{1}\\.[^\\.]$/){\n\treturn\
    \ \"Yes\";\n    }\n    elsif($file_name =~ /^[a-zA-Z]{1}\\/[^\\/]{1}$/){\n\treturn\
    \ \"Yes\";\n    }\n    else{\n\treturn \"No\";\n    }\n}", "    $file_name = $ENV{FILE_NAME_CHECK}\
    \ unless defined $ENV{FILE_NAME_CHECK};\n    $file_name = \"$file_name.txt\" if\
    \ $file_name =~ /\\.txt$/i;\n    $file_name = \"$file_name.exe\" if $file_name\
    \ =~ /\\.exe$/i;\n    $file_name = \"$file_name.dll\" if $file_name =~ /\\.dll$/i;\n\
    \    $file_name = \"$file_name\" if $file_name =~ /^[^\\.]/ &&\n        $file_name\
    \ =~ /^([a-zA-Z][a-zA-Z0-9]{1,8})\\./ &&\n        $file_name !~ /^\\./;\n    return\
    \ $file_name =~ /^Yes$/i;\n}", "    # 1. There are no more than three digits ('0'-'9')\
    \ in the file's name.\n    my $check1 = $file_name;\n    $check1 =~ /^[0-9]+$/;\n\
    \    \n    # 2. There are exactly one dot ('.') in the file's name.\n    my $check2\
    \ = $file_name;\n    $check2 =~ /\\./;\n    \n    # 3. The substring before the\
    \ dot should not be empty, and it starts with a letter from\n    # Latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n    my $check3 = $file_name;\n    $check3 =~ /^[a-zA-Z]+\\\
    .$/;\n    \n    # 4. The substring after the dot should be one of these: ['txt',\
    \ 'exe', 'dll']\n    my @valid_extensions = qw(exe dll txt .exe);\n    \n    #\
    \ 5. Check if any of these conditions are true.\n    my $result = !($check1 &&\
    \ !$check2 && $check3);\n    \n    if ($result){\n        return \"Yes\";\n  \
    \  }\n    else {\n        return \"No\";\n    }\n}", "    my @file_name_parts\
    \ = split(/\\./, $file_name);\n    my $first_part = $file_name_parts[0];\n   \
    \ if ($file_name_parts[0] !~ /^\\d+$/) {\n\treturn \"No\";\n    }\n    if ($file_name_parts[0]\
    \ !~ /^[a-zA-Z]+$/) {\n\treturn \"No\";\n    }\n    if (@file_name_parts != 2\
    \ ||\n\t$file_name_parts[1] !~ /^(txt|exe|dll)$/) {\n\treturn \"No\";\n    }\n\
    \    return \"Yes\";\n}", "    my($dots_count) = ($file_name =~ m/\\./g);\n  \
    \  my($dot_pos) = ($file_name =~ m/\\.\\./);\n    my($dot_pos) = length($dot_pos);\n\
    \    my($first_char) = ($file_name =~ m/[a-z]/);\n    my($first_char) = ($first_char\
    \ != -1);\n    my($last_char) = ($file_name =~ m/.$/);\n    my($last_char) = ($last_char\
    \ != -1);\n    my($first_char) = ($dot_pos == 0);\n    my($first_char) = ($dot_pos\
    \ == 1);\n    my($first_char) = ($dot_pos == 2);\n    my($first_char) = ($dot_pos\
    \ == 3);\n    my($first_char) = ($dot_pos == 4);\n    my($first_char) = ($dot_pos\
    \ == 5);\n    my($first_char) = ($dot_pos == 6);\n    my($first_char) = ($dot_pos\
    \ == 7);\n    my($first_char) = ($dot_pos == 8);\n    my($first_char) = ($dot_pos\
    \ == 9);\n    my($first_char) = ($dot_pos == 10);\n    my($first_char) = ($dot_pos\
    \ == 11);\n    my($first_char) = ($dot_pos == 12);\n    my($first_char) = ($dot_pos\
    \ == 13);\n    my($first_char) = ($dot_pos == 14);\n    my($first_char) = ($dot_pos\
    \ == 15);\n    my($first_char) = ($dot_pos == 16);\n    my($first_char) = ($dot_pos\
    \ == 17);\n    my($first_char) = ($dot_pos == 18);\n    my($first_char) = ($dot_pos\
    \ == 19);\n    my($first_char) = ($dot_pos == 20);\n    my($first_char) = ($dot_pos\
    \ == 21);\n    my($first_char) = ($dot_pos == 22);\n    my($first_char) = ($dot_pos\
    \ == 23);\n    my($first_char) = ($dot_pos == 24);\n    my($first_char) = ($dot_pos\
    \ == 25);\n    my($first_char) = ($dot_pos == 26);\n    my($first_char) = ($dot_pos\
    \ == 27);\n    my($first_char) = ($dot_pos == 28);\n    my($first_char) = ($dot_pos\
    \ == 29);\n    my($first_char) = ($dot_pos == 30);\n    my($first_char) = ($dot_pos\
    \ == 31);\n    my($first_char) = ($dot_pos == 32);\n    m", "    return unless\
    \ $file_name =~ /^\\d{3}\\.[^\\.]+\\.(txt|exe|dll)$/;\n    return $file_name !~\
    \ /^[a-zA-Z]+\\./;\n    $file_name =~ /^[a-zA-Z]+\\./;\n    $file_name !~ /\\\
    .\\.$/;\n    return $file_name !~ /\\.(txt|exe|dll)$/;\n}", "    if ($file_name\
    \ =~ /[1-9][0-9]*$/) {\n        return $file_name =~ /\\./ ? \"Yes\" : \"No\"\
    ;\n    }\n    unless ($file_name =~ /^[a-z]([-\\.][a-z])*$/ and $file_name =~\
    \ /\\.[a-z][a-z]$/) {\n        return \"No\";\n    }\n    my $ext = substr($file_name,\
    \ 0, length($file_name)-3);\n    my $subst = [\"txt\", \"exe\", \"dll\"];\n  \
    \  return $subst->[$ext] ? 1 : 0 \n}", "    my($dot);\n    my($before_dot);\n\
    \    my($after_dot);\n    my($valid_extensions);\n    my($valid_name);\n    my($valid);\n\
    \    \n    $valid_extensions = qw(\n        txt exe dll\n    );\n    \n    $valid_name\
    \ = qr{^[1-9][0-9]{0,3}\\.[A-Za-z0-9]$};\n    \n    $dot  =~ /^\\./;\n    $before_dot\
    \ =  substr($file_name, 0, index($file_name, \".\"));\n    $after_dot =  substr($file_name,\
    \ index($file_name, \".\") + 1);\n    \n    if ($dot != '' || $before_dot ne ''){\n\
    \        return 'No';\n    }\n    elsif ($after_dot !~ $valid_extensions){\n \
    \       return 'No';\n    }\n    elsif ($after_dot eq 'dll'){\n        $valid\
    \ = $after_dot =~ /^(exe|txt)$/;\n    }\n    elsif ($after_dot eq 'exe'){\n  \
    \      $valid = $after_dot =~ /^(exe|txt)$/;\n    }\n    elsif ($after_dot eq\
    \ 'txt'){\n        $valid = $after_dot =~ /^(exe|txt)$/;\n    }\n    \n    if\
    \ ($valid){\n        return 'Yes';\n    }\n    else{\n        return 'No';\n \
    \   }\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nIt looks like you have a typo\
    \ - it looks like you're checking whether the file name is valid when you're trying\
    \ to find out if the extension name should be valid? If so - why not just check\
    \ the extension name first?\n<|/ c |>\n<| c |>\n, Yes, you're right, I didn't\
    \ notice that in the first place. Fixed.\n<|/ c |>\n<| c |>\n, I've added a solution\
    \ that doesn't involve regular expressions, which might be easier to read.\n<|/\
    \ c |>\n<| c |>\n, Added a solution where you only check the extension.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nFor a solution that doesn't involve regular expressions,\
    \ you can use the File::Basename::fileparse() function, which will parse a path\
    \ into its components.\n<code>\nuse strict;\nuse warnings;\nuse File::Basename;",
  "    my($valid) = 0;\n    if ($file_name =~ /^[0-9]{3,3}\\.[^.]$/) {\n        $valid\
    \ = 1 if $file_name =~ /^\\./;\n        $valid = 1 if $file_name =~ /\\.[^.]$/;\n\
    \        $valid = 1 if $file_name =~ /^[a-z][a-z0-9]*\\.[a-z][a-z]$/i;\n    }\n\
    \    return $valid ? 'Yes' : 'No';\n}", "    \n    if($file_name =~ /^\\d{1,3}\\\
    .\\d{1,3}\\.\\d{1,3}\\.(txt|exe|dll)$/){\n        return \"Yes\";\n    }\n   \
    \ else {\n        return \"No\";\n    }\n}\n</cell>\n<text>\nThe following function\
    \ checks if the given string $file_content is valid, and returns 'Yes' if the\
    \ string is valid, and 'No' if not:", "    my($valid) = 'No';\n    my($dot_pos)\
    \ = index($file_name, '.');\n    my($first_letter) = substr($file_name, 0, $dot_pos);\n\
    \    my(@dot_strings) = ('txt', 'exe', 'dll');\n    \n    # There should not be\
    \ more than three digits ('0'-'9') in the file's name.\n    if(length($file_name)\
    \ > 3) {\n        $valid = 'No';\n    }\n    elsif($dot_pos == -1) {\n       \
    \ $valid = 'No';\n    }\n    elsif($dot_pos > 0) {\n        $valid = 'Yes';\n\
    \    }", "    return if (length($file_name) > 3);\n    return if ($file_name[0]\
    \ eq '.');\n    return if ($file_name[0] ne 'a' &&\n                $file_name[0]\
    \ ne 'A' &&\n                $file_name[0] ne '0' &&\n                $file_name[0]\
    \ ne '9');\n    return if ($file_name[length($file_name)-1] ne 'd' &&\n      \
    \          $file_name[length($file_name)-1] ne 'D' &&\n                $file_name[length($file_name)-1]\
    \ ne 'e' &&\n                $file_name[length($file_name)-1] ne 'E' &&\n    \
    \            $file_name[length($file_name)-1] ne 'l' &&\n                $file_name[length($file_name)-1]\
    \ ne 'L' &&\n                $file_name[length($file_name)-1] ne 'o' &&\n    \
    \            $file_name[length($file_name)-1] ne 'O' &&\n                $file_name[length($file_name)-1]\
    \ ne 'r' &&\n                $file_name[length($file_name)-1] ne 'R' &&\n    \
    \            $file_name[length($file_name)-1] ne 's' &&\n                $file_name[length($file_name)-1]\
    \ ne 'S' &&\n                $file_name[length($file_name)-1] ne 'u' &&\n    \
    \            $file_name[length($file_name)-1] ne 'U' &&\n                $file_name[length($file_name)-1]\
    \ ne 'x' &&\n                $file_name[length($file_name)-1] ne 'X');\n    return\
    \ if (length($file_name) < 1);\n    return if ($file_name[0] ne 'a');\n    return\
    \ if ($file_name[0] eq 'A');\n    return if ($file_name[0] eq '0');\n    return\
    \ if ($file_name[0] eq '9');\n    return if ($file_name[0] eq 'a');\n    return\
    \ if ($file_name[0] eq 'A');\n    return if ($file_name[0] eq '0');\n    return\
    \ if ($file_name[0] eq '9');\n    return 'No';\n}", "    my $file_name = lc($file_name);\n\
    \    my $valid_chars = '0123456789.';\n    $file_name =~ m/^[0-9]{3}$|\\.$|(^[a-zA-z])/;\n\
    \    return ($file_name =~ m/^$valid_chars{1}$/) ? \"Yes\" : \"No\";\n}", "  \
    \  \n    # remove all non-alphanumeric characters from $file_name\n    $file_name\
    \ =~ s/[^a-zA-Z0-9\\.]+//g;\n    \n    # Check if the file name is valid\n   \
    \ if ($file_name =~ /^[0-9]{3}\\.txt$/i) { \n\treturn \"Yes\";\n    } elsif ($file_name\
    \ =~ /^[0-9]{3}\\.exe$/i) {\n\treturn \"Yes\";\n    } elsif ($file_name =~ /^[0-9]{3}\\\
    .dll$/i) {\n\treturn \"Yes\";\n    } else {\n\treturn \"No\";\n    }\n}", "  \
    \  my($is_valid_file_name) = $file_name =~ /^[0-9]{3}\\.[a-z][a-z][a-z]$/i;\n\
    \    \n    return $is_valid_file_name if !$is_valid_file_name;", "    \n    if\
    \ ($file_name) {\n        if ($file_name=~/^([0-9]{3}\\.)*([a-z][a-zA-Z].*\\.txt|exe|dll)$/)\
    \ {\n            my $is_valid = substr $file_name, 0, 1 eq '.' || $file_name=~/^(\\\
    .)*/;\n            return $is_valid;\n        }\n        return \"No\";\n    }\n\
    \    return \"No\";\n}\n</code>\n<|/ a dscore=3 tags=perl |>\n<| c |>\nPlease\
    \ don't use prototypes. In fact, it's considered bad practice to use `my` unless\
    \ you specifically want the local variable to be lexical.\n<|/ c |>\n<| c |>\n\
    , I'm sorry about that, I always use it for functions but I have been wrong doing\
    \ it for variables. I'll edit my answer to avoid confusion next time.\n<|/ c |>\n\
    <| c |>\nNo worries; I appreciate your edit. But you still shouldn't use prototypes.\n\
    <|/ c |>\n<| c |>\nHi Robert,\nThanks for your solution, it works.\nBut I cannot\
    \ understand why I should use parentheses in my function call.\n<|/ c |>\n<| c\
    \ |>\nYou don't need to use the parenthesis, only when you want to pass a value\
    \ to a function such as `sub some_function($var)`. You can read more about function\
    \ prototypes here: http://www.perlmonks.org/?node_id=542341\n<|/ c |>\n<| a tags=perl\
    \ |>\nTry this:\n<code>", "    if(length($file_name) !=3 ){\n        return \"\
    No\";\n    }", "    my $ret = \"No\";\n    return $ret if (length($file_name)\
    \ > 3 && $file_name=~/^\\d{3}\\./ &&\n                     $file_name=~/^[a-zA-Z]/\
    \ && $file_name=~/^[^.]/ &&\n                     $file_name=~/^[a-z]/ && $file_name=~/^\\\
    .([txt|exe|dll])/);\n    return $ret;\n}\n</code>\n<|/ a dscore=3 tags=regex,perl,pattern-matching\
    \ |>\n<| a dscore=2 |>\nYou can use negative lookahead and lookbehind like so:\n\
    <code>\nif ($string !~ m/^(?![0-9]{3}.[0-9]{1,4})[a-z].*\\.(exe|dll)$/)\n{\n \
    \   #do something\n}\n</code>\n<|/ a tags=regex,perl,pattern-matching |>\n<| a\
    \ tags=regex,perl,pattern-matching |>\nThis should work:\n<code>\n/^[a-z](?![0-9]+\\\
    .\\.)([a-zA-Z]*\\.(exe|dll))$/i\n</code>\nIt also doesn't allow other filetypes\
    \ like txt.exe, exe.exe, dll etc.\n<|/ a dscore=1 |>\n<| a tags=regex,perl,pattern-matching\
    \ dscore=1 |>\nA little bit of testing show that it's quite easy to do.  \n<code>",
  "    my ($match, $error_msg) = ();\n    \n    # Check if file contains only 1 dot\
    \ ('.') character. \n    $match += 1 if ($file_name =~ /^\\.{1}/);\n    \n   \
    \ # Check if file name starts with a latin letter ('a'-'z' or 'A'-'Z') only. \n\
    \    $match += 1 if ($file_name =~ /^[A-Za-z]/);\n    \n    # Check if file name\
    \ contains 'txt', 'exe' or 'dll' only. \n    $match += 1 if ($file_name =~ /\\\
    .(exe|txt|dll)$/);\n    \n    # Check if file name contains only numbers (0-9)\
    \ only. \n    $match += 1 if ($file_name =~ /^[0-9]/);\n    \n    # Return True\
    \ only if all conditions above are met. \n    return $match ? 1 : 0;\n}", "  \
    \  # No need to check if the file's name is '0'-'9', because '0' is included in\
    \ '9'.\n    # So '10' is not invalid.\n    return $file_name =~ /^[0-9]{3}\\.[^\\\
    .]+\\.[^\\.]+$/ \n    && \n    (\n        $file_name !~ /^.{1,}$/\n        ||\
    \ !($file_name =~ /\\.[^\\.]+/)\n        || \n        !($file_name =~ /^[a-fA-F0-9][a-fA-F0-9]$/)\n\
    \        || \n        (\n            ($file_name =~ /^(\\.[^\\.]+)(\\.exe)$/i)\n\
    \            &&\n            $1 !~ /^(\\.|\\.\\.|\\.\\.\\.)/\n        )\n    );\n\
    }", "    my($result) = 'No';\n    $file_name =~ s/^[^0-9\\.]+//;\n    if ($file_name)\
    \ {\n        $file_name =~ /\\./ || die(\"File name contains a '.'\");\n     \
    \   $file_name =~ /^[^a-z][a-z]+/i || die(\"File name starts with a non-letter\
    \ character\");\n        $file_name =~ /\\.(?:txt|exe|dll)$/i;\n        if (length($file_name)\
    \ > 3) {\n            $result = 'No';\n        }\n    }\n    return $result;\n\
    }", "    $file_name =~ /^[0-9]+\\.[a-z][a-z][a-z]+$/i;\n    $file_name =~ /^[a-z][a-z]+/i;\n\
    \    if ($file_name) {\n        return ($file_name =~ /\\.(exe|dll)$/i) ? \"Yes\"\
    \ : \"No\";\n    } else {\n        return \"\";\n    }\n}", "    return \"$file_name\"\
    \ =~ m/[1-9][0-9]{0,3}\\.txt|exe|dll/g;\n}", "    \n    # Split the file name\
    \ into two parts: the name before the dot and the name after the dot.\n    my\
    \ $split_name = split(/\\.|/, $file_name);", "    my ($valid_chars) = ('a'..'z',\
    \ 'A'..'Z');\n    my($dotpos) = index($file_name, '.');\n    my($ext);\n    my($letterpos)\
    \ = 0;\n    my($valid_chars2);\n    my($letter);\n    my($found);\n    $found\
    \ = 0;\n    \n    if ($dotpos == -1) {\n        my $msg = \"Error: file name is\
    \ invalid\";\n        $msg .= ' '.$file_name;\n        $msg .= \" '.\";\n    \
    \    $msg .= \" Please follow the format of 'test1.txt' or 'test1.exe'.\";\n \
    \       $msg .= \" To find out more about the format of file names, please refer\
    \ to our documentation.\";\n        die $msg;\n    }\n    \n    while($dotpos)\
    \ {\n        $ext = (substr($file_name, $dotpos+1, 1));\n        if ($ext == \"\
    \") {\n            $msg = \"Error: file name is invalid\";\n            $msg .=\
    \ ' '.$file_name;\n            $msg .= \" '.\";\n            $msg .= \" The file's\
    \ name should contain at least one dot '.'.\";\n            $msg .= \" Please\
    \ follow the format of 'test1.txt' or 'test1.exe'.\";\n            $msg .= \"\
    \ To find out more about the format of file names, please refer to our documentation.\"\
    ;\n            die $msg;\n        }\n        $letterpos = index($ext, 'a'..'z');\n\
    \        $letterpos = index($ext, 'A'..'Z');\n        if ($letterpos == -1 ||\
    \ $letterpos > $valid_chars) {\n            $msg = \"Error: file name is invalid\"\
    ;\n            $msg .= ' '.$file_name;\n            $msg .= \" '.\";\n       \
    \     $msg .= \" The file's name should contain exactly one dot '.'.\";\n    \
    \        $msg .= \" Please follow the format of 'test1.txt' or 'test1.exe'.\"\
    ;\n            $msg .= \" To find out more about the format of file names, please\
    \ refer to our documentation.\";\n            die $msg;\n        }\n        $letter\
    \ = substr($ext, $letterpos+1, 1);\n        if ($letter ne \"\" && $letter ne\
    \ \"-\" && $letter ne \"*\" && $letter ne \"$\") {\n            $msg = \"Error:\
    \ file name is invalid\";\n            $msg .= ' '.$file_name;\n            $msg\
    \ .= \" '.\";\n            $msg .= \" The substring after the dot should contain\
    \ one of these: ['txt', 'exe', 'dll'].\";\n            $msg .= \" Please follow\
    \ the format of 'test1.txt' or '", "    return $file_name =~ /^\\d{3}\\./ && $file_name=~/^[^\\\
    .]+\\.([a-z]|$)/ ? 'Yes' : 'No';\n}", "    \n    # Validating the file name.\n\
    \    \n    my $valid_string = \"\";\n    \n    # Checking if there are any non-numeric\
    \ characters in the file name.\n    my @invalid_chars;\n    if ($file_name=~/[^0-9]/)\
    \ {\n        @invalid_chars = split //, $file_name;\n    } else {\n        $valid_string\
    \ = \"Yes\";\n    }\n    \n    # Checking if there are two dots in the file name.\n\
    \    if ($valid_string eq \"Yes\" && $file_name=~/\\.\\.[^\\.]+/) {\n        $valid_string\
    \ = \"No\";\n    }\n    \n    # Checking if the file's name has one dot, and if\
    \ the name starts with a latin alpha \n    # character ('a'-'z' or 'A'-'Z').\n\
    \    if ($valid_string eq \"Yes\" && $file_name=~/\\.[^\\.]+/) {\n        $valid_string\
    \ = \"No\";\n        if ($file_name=~/[^a-z]/) {\n            @invalid_chars =\
    \ split //, $file_name;\n        }\n    }\n    \n    # Checking if the file's\
    \ name contains one of the strings: 'txt', 'exe', 'dll'.\n    if ($valid_string\
    \ eq \"Yes\" && $file_name=~/([\\.]\\w+)/) {\n        $valid_string = \"No\";\n\
    \    }\n    \n    # Returning 'Yes' or 'No'.\n    return $valid_string;\n}", " \
    \   my($dot_pos) = index($file_name, \".\");\n    my($name_pos) = index($file_name,\
    \ \"/\");\n    my($name_char_pos) = index($file_name, \"/\");\n    \n    # Case\
    \ 1: Not enough characters\n    \n    # Case 2: Wrong characters in the substring\
    \ before the dot\n    if ($dot_pos == -1) {\n        return \"No\";\n    }\n \
    \   # Case 3: Wrong characters in the substring after the dot\n    elsif ($name_char_pos\
    \ == -1 || $file_name[$dot_pos] ne \".\") {\n        return \"No\";\n    }\n \
    \   \n    # Case 4: File name has the right characters in the substring before\
    \ the dot\n    elsif ($name_pos == -1 || $file_name[$dot_pos] ne \".\") {\n  \
    \      return \"Yes\";\n    }\n    # Case 5: File name has the right characters\
    \ in the substring after the dot\n    elsif ($name_char_pos == -1) {\n       \
    \ return \"Yes\";\n    }\n    \n    # Case 6: File name has the right characters\
    \ in the substring before the dot \n    # and right characters in the substring\
    \ after the dot\n    elsif ($dot_pos == -1 || $file_name[$dot_pos] ne \".\" ||\
    \ $file_name[$name_char_pos] ne \"txt\"\n         || $file_name[$name_char_pos]\
    \ ne \"exe\" || $file_name[$name_char_pos] ne \"dll\") {\n        return \"No\"\
    ;\n    }\n    \n    # Case 7: File name has the right characters in the substring\
    \ before the dot \n    # and right characters in the substring after the dot\n\
    \    elsif ($dot_pos == -1 || $file_name[$dot_pos] ne \".\" || $file_name[$name_pos]\
    \ ne \"txt\"\n         || $file_name[$name_pos] ne \"exe\" || $file_name[$name_pos]\
    \ ne \"dll\") {\n        return \"Yes\";\n    }\n    \n    # Case 8: File name\
    \ has the right characters in the substring before the dot \n    # and right characters\
    \ in the substring after the dot\n    elsif ($dot_pos == -1 || $file_name[$dot_pos]\
    \ ne \".\" || $file_name[$name_pos] ne \"txt\"\n         || $file_name[$name_pos]\
    \ ne \"exe\") {\n        return \"Yes\";\n    }\n    \n    # Case 9: File name\
    \ has the right characters in the substring before the dot \n    # and right characters\
    \ in the substring after the dot\n    elsif ($dot_pos == -1 || $file_name[$dot_pos]\
    \ ne \".\" || $file_name[$name_pos] ne \"exe\") {\n        return \"Yes\";\n \
    \   }\n    \n    return \"No\";\n}", "    # Check the file name length\n    my\
    \ $len = length($file_name);\n    if($len < 3) {\n        return \"No\";\n   \
    \ }\n    # Check the file name's content\n    if(substr($file_name, 0, 1) ne \"\
    a\") {\n        return \"No\";\n    }\n    if(substr($file_name, 0, 1) ne \"A\"\
    ) {\n        return \"No\";\n    }\n    if(substr($file_name, 0, 1) ne \"0\")\
    \ {\n        return \"No\";\n    }\n    if(substr($file_name, 0, 1) ne \"9\")\
    \ {\n        return \"No\";\n    }\n    if($file_name !~ /^\\.?[a-zA-Z]+\\.?/)\
    \ {\n        return \"No\";\n    }\n    if(!grep(/txt|exe|dll/, split('\\.', $file_name)))\
    \ {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n</code>\n<|/ a tags=perl,bash,if-statement,grep,linux\
    \ |>\n<| c |>\nThank you very much for the detailed reply! As you said, I have\
    \ made a mistake on not mentioning the conditions for the case that a file is\
    \ not \"txt\" or \"exe\" or \"dll\", so I edited my code as follows: `if(substr($file_name,\
    \ 0, 1) ne \"a\") {\n        return \"No\";\n    }\n    if(substr($file_name,\
    \ 0, 1) ne \"A\") {\n        return \"No\";\n    }\n    if(substr($file_name,\
    \ 0, 1) ne \"0\") {\n        return \"No\";\n    }\n    if(substr($file_name,\
    \ 0, 1) ne \"9\") {\n        return \"No\";\n    }\n    if($file_name !~ /^\\\
    .?[a-zA-Z]+\\.?/) {\n        return \"No\";\n    }\n    if(!grep(/txt|exe|dll/,\
    \ split('\\.', $file_name))) {\n        return \"No\";\n    }\n    return \"Yes\"\
    ;` but now when I try to run your code I got this error `grep: invalid predicate\
    \ `\\.'. Perhaps you missed a bracket or a quote?` What can I do to fix that?\n\
    <|/ c |>\n<| c |>\nSorry for the mistake I made while editing. The error is still\
    \ there after fixing it. I will try your code and see if it works.\n<|/ c |>\n\
    <| c |>\nThanks, I have tried your code and it works as intended. I am just trying\
    \ to understand your code. `my =;` What does it do? And what does `grep {...}`\
    \ do? I understand that `grep` returns an array but how does `grep` returns an\
    \ array if the second argument is an array?\n<|/ c |>\n<| c |>\n`my` is the syntax\
    \ to declare a variable without initializing it.  You use it just ", '    my ($valid)
    = 0;', "    my (@parts) = split(/\\./, $file_name, 2);\n    \n    my $num_digits\
    \ = scalar( split(/\\0/, $file_name) );\n    return $num_digits < 3 \n       \
    \ ? 'No' \n        : ($num_digits == 3 && ! @parts\n            ? 'Yes' \n   \
    \         : ($parts[0] =~ /^[a-zA-Z]/ && $parts[1] !~ /^[0-9]*$/ \n          \
    \      ? ('Yes')\n                : ('No'))\n        );\n}", "    \n    my($ok)\
    \ = 'No';\n    \n    if ($file_name) {\n        if ($file_name =~ /^\\d+$/) {\n\
    \            my @digits = split(//, $file_name);\n            my $last_digit =\
    \ $digits[-1];\n            if ($last_digit =~ /^[0-9]+$/) {\n               \
    \ $ok = 'Yes';\n            }\n        }\n        if ($file_name =~ /^[a-z][a-z]\\\
    .[a-z]+$/) {\n            my $first_letter = $file_name;\n            $first_letter\
    \ =~ s/^[a-z]/''/;\n            $first_letter =~ s/[a-z]+$//;\n            \n\
    \            if ($first_letter =~ /[a-z][a-z]+/) {\n                $ok = 'Yes';\n\
    \            }\n        }\n    }\n    return $ok;\n}\n</code>\nThe code is very\
    \ self-explanatory. However, if you want to know which parts of it you need to\
    \ change, I recommend looking through the Perl language docs and looking up each\
    \ function call. I hope that helps!\n<|/ a tags=perl,bash |>\n<| c |>\nI am getting\
    \ this error on running this script - \nCan't locate object method \"file_name_check\"\
    \ via package \"main::__ANON__\" (perhaps you forgot to load \"main\"?) at script1.pl\
    \ line 5.\n<|/ c |>\n<| c |>\nI added an example at the bottom of the code that\
    \ I used, which should work fine.\n<|/ c |>\n<| c |>\n- This isn't a bad idea.\
    \ Since he's asking for bash code, he may want to go with [this option](https://stackoverflow.com/a/25874278/3220113)\n\
    <|/ c |>\n<| c |>\n- I was thinking about that as well. He could always use an\
    \ alias or something to call his Perl script from his bash script.\n<|/ c |>\n\
    <| a tags=perl,bash |>\nHow about this approach:\n<code>", "    $file_name =~\
    \ s/\\D//g;\n    $file_name =~ s/^0*//;\n    $file_name =~ /^[a-zA-Z]+/;\n   \
    \ my @files = split(/\\./, $file_name);\n    my $file_type;\n    foreach my $file\
    \ (@files) {\n       $file =~ /^[a-zA-Z]+$/;\n       if ($file =~ /^[a-zA-Z]+$/\
    \ && $file !~ /^[0-9]$/) {\n           return 'No';\n       }\n       $file_type\
    \ = $file;\n    }\n    if ($file_type =~ /^(exe|dll)$/ && length($file_type) ==\
    \ 3) {\n        return 'Yes';\n    }\n    return 'No';\n}", "    my %files = ();\n\
    \    foreach my $item (@files){\n        push @{$files[$item]} , $file_name;\n\
    \    }\n    foreach my $item (@files){\n        foreach my $value ($_){\n    \
    \        foreach my $item (@{$files[$item]}){\n                if  ($value =~\
    \ /^\\d+\\Z/){\n                    if  ($item =~ /^\\..*\\Z/){\n            \
    \            push (@{$files[$item]} , \"Yes\");\n                        next;\n\
    \                    } \n                    if($item =~ /^[A-Za-z].*\\Z/){\n\
    \                        push (@{$files[$item]} , \"Yes\");\n                \
    \        next;\n                    }\n                }\n            }\n    \
    \    }\n    }\n    foreach my $item (@files){\n        return $files[$item] if\
    \ !($_);\n    }\n    return \"No\";\n}", '    my %filename_checks_ok;', "    my($dot_position)\
    \ = index($file_name, '.');\n    if ($dot_position != -1 && $dot_position > 3)\
    \ {\n        return \"No\";\n    }\n    elsif ($dot_position == -1) {\n      \
    \  return \"Yes\";\n    }\n    else {\n        my($first_character) = substr($file_name,\
    \ 0, 1);\n        my($check) = 0;\n        if (lc($first_character) eq 'a') {\n\
    \            for (my $i = 0; $i <= 1; $i++) {\n                my $character =\
    \ substr($file_name, $i, 1);\n                my $ascii = (ord $character);\n\
    \                if ($ascii >=65 && $ascii <= 90) {\n                    $check\
    \ += 1;\n                }\n                elsif ($ascii >=97 && $ascii <= 122)\
    \ {\n                    $check += 1;\n                }\n            }\n    \
    \    }\n        if ($check != 1) {\n            return \"No\";\n        }\n  \
    \      else {\n            return \"Yes\";\n        }\n    }\n}", "    # Verify\
    \ that $file_name consists of a single '.' and that it \n    # does not consist\
    \ of only one dot.\n    if ($file_name !~ m{\\.}) {\n        return \"No\";\n\
    \    } elsif ($file_name !~ m{^[a-zA-Z]}) {\n        return \"No\";\n    } elsif\
    \ ($file_name !~ m{\\.}) {\n        return \"No\";\n    } elsif ($file_name !~\
    \ m{^[a-zA-Z]}) {\n        return \"No\";\n    }\n    # Verify that $file_name\
    \ starts with a letter from the latin alphabet\n    # and that $file_name contains\
    \ exactly one dot.\n    elsif ($file_name !~ m{^[a-zA-Z]\\.}) {\n        return\
    \ \"No\";\n    } elsif ($file_name !~ m{\\.}) {\n        return \"No\";\n    }\n\
    \    return \"Yes\";\n}", "    \n    # Check the length of the string\n    if\
    \ (length($file_name) > 3) {\n        return \"No\";\n    }", "    my($digits);\n\
    \    my($is_valid_filename) = 0;", "    # return false if file name is less than\
    \ three characters\n    return false if length($file_name) < 3;", "    return\
    \ \"$file_name\" =~ /[^0-9.]/ && $file_name =~ /^[A-Za-z][a-z]*\\./ && \n    \
    \       $file_name =~ /^.[^\\.]/ && $file_name =~ /\\.(exe|dll)$/;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`@Dave Cross: Thanks for the input! I changed the regex to\
    \ allow for more than three digits, and added the explanation to the answer.\n\
    <|/ c |>\n<| a dscore=0 tags=regex,perl,perl-module |>\n<code>\n/^([^0][^0]+\\\
    .[^0]+\\.[^0]+)$/\n</code>\nMatches one of:\n<code>\nabcde\nab\nac\nad\n</code>\n\
    <|/ a |>\n<| c |>\nYour regex matches any character other than `0`, followed 1\
    \ or more of any character other than `0`, followed 1 or more of the string `.`\
    \ followed 1 or more of the string `.` followed 1 or more of the string `exe`.\
    \ That doesn't seem like a good idea, but then again it might not be a good idea.\
    \ The whole idea is to only allow one dot, followed by exactly one file extension.\n\
    <|/ c |>\n<| c |>\nThanks for the input! I changed my regex to allow for more\
    \ than three digits, and added the explanation to the answer.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis was my solution:\n<code>\nif ( $file_name =~ m/^(\\S+\\.txt|exe|dll)$/\
    \ ){\nprint \"Yes\";\n}else{\nprint \"No\";\n}\n</code>\n<|/ a tags=regex,perl,perl-module\
    \ |>\n<| c |>\n`\\S` matches a `'0'`, but it does *not* match `'1'`.\n<|/ c |>\n\
    <| c |>\nThanks for the input! I changed my regex to allow for more than three\
    \ digits, and added the explanation to the answer.\n<|/ c |>\n<| a tags=regex,perl,perl-module\
    \ |>\nI like to use this pattern to test a file name for me:\n<code>\n$fileName\
    \ =~ /^(\\S+\\.txt|exe|dll)$/\n</code>\nIt doesn't allow more than three digits,\
    \ so it can handle files with names starting with digits. I don't have to worry\
    \ about checking for more than three digits.\n<|/ a dscore=0 |>\n<| c |>\nThe\
    \ `\\S` doesn't match `'0'`, but it does match `", "    return 1 if ($file_name\
    \ =~ /^[0-9]+$/);\n    return 0 if ($file_name =~ /\\.\\./);\n    return 0 if\
    \ ($file_name =~ /^[^\\.]/);\n    return 0 if ($file_name !~ /^[a-zA-z]/);\n \
    \   return 0 if ($file_name !~ /\\.(exe|dll|txt)$/);\n    return \"Yes\";\n}",
  "    my($count, $dots) = 0;\n    my($first) = 0;\n    my($valid) = 0;\n    \n  \
    \  if (length($file_name) == 0) {\n        $valid = 1;\n    }\n    elsif ($file_name\
    \ =~ /^[0-9]+$/) {\n        $valid = 1;\n    }\n    elsif ($file_name =~ /^\\\
    .+/) {\n        $dots = $file_name =~ s/\\.//g;\n        $valid = 1;\n    }\n\
    \    elsif ($file_name !~ /^[a-zA-z]/ || $file_name !~ /^[a-zA-z].*[a-zA-z]$/)\
    \ {\n        $valid = 0;\n    }\n    elsif ($dots > 3) {\n        $valid = 0;\n\
    \    }\n    elsif ($dots == 3 && $file_name =~ /^[a-zA-Z]/ && $file_name !~ /^[a-zA-Z].*[a-zA-Z]$/)\
    \ {\n        $valid = 0;\n    }\n    elsif ($first == 0 && $dots == 0) {\n   \
    \     $valid = 1;\n    }\n    elsif ($first == 1 && $dots == 1 && $file_name =~\
    \ /^[a-zA-Z]/ && $file_name !~ /^[a-zA-Z].*[a-zA-Z]$/) {\n        $valid = 0;\n\
    \    }\n    elsif ($count != 3) {\n        $valid = 0;\n    }", "    \n    my\
    \ $file_valid;\n    my $digits_valid;\n    my $dot_valid;\n    my $substring_valid;\n\
    \    my $is_file;\n    my $first_letter;\n    \n    \n    # If the file's name\
    \ contains more than two digits (file's name is invalid).\n    if ($file_name\
    \ =~ /^\\d+$/ && $file_name =~ /^\\d+$/ && $file_name !~ /\\.\\./ && $file_name\
    \ =~ /^[a-zA-Z][a-zA-Z0-9\\.]*$/) {\n        $file_valid = 'No';\n    }\n    #\
    \ If the file's name contains more digits than three (file name is invalid).\n\
    \    elsif ($file_name =~ /^\\d+$/ && $file_name =~ /^\\d+$/ && $file_name !~\
    \ /\\.\\./ && $file_name =~ /^[a-zA-Z][a-zA-Z0-9\\.]*$/) {\n        $file_valid\
    \ = 'No';\n    }\n    # If the file's name contains less than two digits (file's\
    \ name is invalid).\n    elsif ($file_name =~ /^\\d+$/ && $file_name =~ /^\\d+$/\
    \ && $file_name !~ /\\.\\./ && $file_name =~ /^[a-zA-Z][a-zA-Z0-9\\.]*$/) {\n\
    \        $file_valid = 'No';\n    }\n    # If the file's name starts with a letter\
    \ and has a dot (file name is invalid).\n    elsif ($file_name =~ /^[a-zA-Z][a-zA-Z0-9\\\
    .]*$/ && $file_name !~ /\\.\\./ && $file_name =~ /^[a-zA-Z][a-zA-Z0-9\\.]*$/ &&\
    \ $file_name !~ /^0[0-9]{1}$/ && $file_name !~ /^1[0-9]{1}$/ && $file_name !~\
    \ /^2[0-9]{1}$/) {\n        $file_valid = 'No';\n    }\n    # If the file's name\
    \ contains just one dot ('.' is not valid).\n    elsif ($file_name =~ /^\\.$/\
    \ && $file_name !~ /\\.\\./ && $file_name =~ /^\\.$/ && $file_name !~ /^0[0-9]{1}$/\
    \ && $file_name !~ /^1[0-9]{1}$/ && $file_name !~ /^2[0-9]{1}$/) {\n        $file_valid\
    \ = 'No';\n    }\n    # If the file's name contains just one dot ('.' is not valid).\n\
    \    elsif ($file_name =~ /^\\.$/ && $file_name !~ /\\.\\./ && $file_name =",
  "    my($file_ext) = File::Basename::file_ext($file_name);\n    my($file_ext_check);\n\
    \    if ( $file_ext eq '' ) {\n        $file_ext_check = 'No';\n    } else {\n\
    \        $file_ext_check = 'Yes';\n        if ( $file_ext =~ /^\\./ ) {\n    \
    \        my $file_ext_pos = $file_ext =~ /^\\.([^\\.]*)/;\n            my $file_ext_size\
    \ = $file_ext =~ /\\.([^\\.]*)/;\n            my $dot_pos = $file_ext_pos - 1;\n\
    \            my $dot_size = length($file_ext_size);\n            \n          \
    \  if ( $dot_size != 1 ) {\n                print \"\\nERROR: There should not\
    \ be more than one dot ('.') in a file name.\\n\";\n                print \"The\
    \ file's name contains more than 1 dot ('.'), which is not allowed.\\n\";\n  \
    \              print \"The file's name starts with another character that does\
    \ not belong to the latin alphabet.\\n\";\n                print \"The file's\
    \ name contains $dot_size dots, which is not allowed.\\n\";\n                $file_ext_check\
    \ = 'No';\n            } elsif ( $dot_pos != 0 ) {\n                print \"\\\
    nERROR: There should not be an empty substring before the dot ('.') in a file\
    \ name.\\n\";\n                print \"The file's name contains 1 dot ('.'), which\
    \ is not allowed.\\n\";\n                print \"The file's name starts with an\
    \ empty substring, which is not allowed.\\n\";\n                $file_ext_check\
    \ = 'No';\n            } elsif ( $file_ext_pos < 1 ) {\n                print\
    \ \"\\nERROR: There should be at least 1 character before the dot ('.') in a file\
    \ name.\\n\";\n                print \"The file's name contains no dot ('.'),\
    \ which is not allowed.\\n\";\n                print \"The file's name starts\
    \ with a letter that is not in the latin alphabet.\\n\";\n                print\
    \ \"The file's name contains $dot_size dots, which is not allowed.\\n\";\n   \
    \             $file_ext_check = 'No';\n            } else {\n                if\
    \ ( $file_ext =~ /^[^a-z]*$/ ) {\n                    print \"\\nERROR: There\
    \ should be a single character after the dot ('.') in a file name.\\n\";\n   \
    \                 print \"The file's name contains a dot ('.'), which is not allowed.\\\
    n\";\n                    print \"The file's name starts with an empty substring,\
    \ which is not allowed.\\n\";\n                    $file_ext_check = 'No';\n \
    \               } else {\n                    print \"\\nThe file's name contains\
    \ no dot ('.'), which is allowed.\\n\";\n                    $file_ext_check =\
    \ 'Yes';\n                }\n            }\n        } else {\n            print\
    \ \"\\nERROR: There should be at least one character after the dot ('.') in a\
    \ file name.\\n\";\n            print \"The file's name contains no dot ('.'),\
    \ which is allowed.\\n\";\n            $file_ext_check = 'No';\n", "    my($file_dir);\n\
    \    my($file_extension);\n    my($file_dir_last);\n    my($file_dir_first);\n\
    \    my($file_dir_middle);\n    my($file_full);\n    my($file_valid) = 0;", " \
    \   $file_name =~ /^[0-9]{3}\\.(.+)$/;\n    return $1 !~ /^\\./;\n}", "    my($dot_pos)\
    \ = index($file_name, \".\");\n    my($dot_first_letter) = substr($file_name,\
    \ 0, $dot_pos);\n    my($dot_last_letter) = substr($file_name, $dot_pos);\n  \
    \  my($dot_first_letter_index) = index($dot_first_letter, \"A\");\n    my($dot_last_letter_index)\
    \ = index($dot_last_letter, \"A\");", "    chomp($file_name);\n    my $count =\
    \ 0;\n    foreach my $i (split //, $file_name) {\n        if ($i !~ /^\\d+/) {\
    \ # No digits allowed\n            $count++;\n        } else {\n            if\
    \ ($i > 999) { # Max number of digits exceeded\n                $count++;\n  \
    \          } else { # No more than 3 digits allowed\n                if ($i >\
    \ 99) { # Max number of digits exceeded\n                    $count++;\n     \
    \           }\n            }\n        }\n    }\n    if ($count == 0) {\n     \
    \   return \"No\";\n    }\n    if ($count == 1) {\n        return \"Yes\";\n \
    \   }\n    my $i = $file_name;\n    $i =~ s/[^A-Za-z0-9]//g;\n    $i =~ s/^\\\
    .//;\n    if ($i !~ /^[A-Za-z]+$/) { # No upper case letters allowed\n       \
    \ return \"No\";\n    }\n    if ($i !~ /\\.(txt|exe|dll)$/i) { # No other file\
    \ types are allowed\n        return \"No\";\n    }\n    return \"Yes\";\n}", " \
    \   $file_name = \"$file_name\" unless $file_name;\n    $file_name =~ s/^[^0-9\\\
    .]+//;\n    return unless $file_name =~ /^\\d.+\\.[^\\.]+$/;\n    return unless\
    \ $file_name =~ /^[a-z][^.]+\\.(txt|exe|dll)$/i;\n    return \"Yes\";\n}\n</code>\n\
    <|/ a tags=regex,perl dscore=1 |>\n<| c |>\nWhoops, I forgot to mention that I\
    \ need to check more than just the extension, I need to check for any extension\
    \ that starts with '.', so in the case of your example, it would fail.\n<|/ c\
    \ |>\n<| c |>\nSo you only care about the first dot and you care about the extension\
    \ being in the list of allowed ones?\n<|/ c |>\n<| c |>\nYou didn't mention this\
    \ in your question. I've updated my answer to account for multiple dots and extensions.\n\
    <|/ c |>\n<| a tags=regex,perl dscore=0 |>\nYou could also do \n<code>\nmy $file_name\
    \ = \"1example.dll\";\n$file_name =~ /^[a-z_]+\\.dll$/i;\n</code>\nThat will match\
    \ any letters from the latin alphabet, underscores or dashes followed by a period\
    \ and a dll extension.\n<|/ a |>\n<| a |>\nThe answer to this question has been\
    \ given by jm666 and is accepted as the most direct solution but it has some flaws.\n\
    Using 'i' modifier may match substrings that you don't expect. For example, if\
    \ you have a file name 'example.dll' and you put that in $file_name variable,\
    \ the string will be converted to 'example' since 'i' modifier will match 'e'\
    \ as a part of 'example'.\nYou may use another modifier such as 's' which will\
    \ not match 'example' in 'example' string but will match the whole string.\nIf\
    \ you want only 'example' to be matched, use 'm' modifier which matches multi-line\
    \ text.\nThe following script illustrates the problem:\n<code>", "    my (%valid_extensions,\
    \ $file_name);\n    $file_name_len = length($file_name);\n    \n    # Validate\
    \ file name\n    # Remove trailing '.' char if present\n    if($file_name_len\
    \ > 3) {\n        substr($file_name, $file_name_length-1, 1);\n    }\n    $file_name\
    \ = uc($file_name);\n    \n    if($file_name =~ /^[0-9].*\\.[a-zA-Z]+$/) {\n \
    \       my $first_char = substr($file_name,0,1);\n        my $last_char = substr($file_name,-1);\n\
    \        # Validate first char\n        if($first_char !~ /^[a-zA-Z]+$/) {\n \
    \           $valid_extensions{'1'.$file_name} = 'No';\n        }\n        # Validate\
    \ last char\n        if($last_char !~ /^[a-zA-Z]+$/) {\n            $valid_extensions{'1'.$file_name}\
    \ = 'No';\n        }\n        $valid_extensions{$file_name} = 'Yes';\n    }\n\
    \    else {\n        $valid_extensions{'1'.$file_name} = 'No';\n    }\n    return\
    \ %valid_extensions;\n}", "    # Check the number of digits in file name\n   \
    \ if ($file_name=~/^\\d{3}$/g) {\n        return (\"Yes\");\n    }\n    # Check\
    \ if the file has only one dot\n    if ($file_name=~/^\\..*$/g) {\n        return\
    \ (\"No\");\n    }\n    # Check if the first character is letter\n    if ($file_name=~/^[a-zA-Z]/g)\
    \ {\n        return (\"Yes\");\n    }\n    # Check if the second character is\
    \ letter\n    if ($file_name=~/^[a-z]/g) {\n        return (\"Yes\");\n    }\n\
    \    # Check if the third character is letter\n    if ($file_name=~/^[A-Z]/g)\
    \ {\n        return (\"Yes\");\n    }\n    # Check if the fourth character is\
    \ letter\n    if ($file_name=~/^[a-z]/g) {\n        return (\"Yes\");\n    }\n\
    \    # Check if the fifth character is letter\n    if ($file_name=~/^[A-Z]/g)\
    \ {\n        return (\"Yes\");\n    }\n    # Check if file name contains 'exe'\
    \ or 'dll'\n    if ($file_name=~/^(exe|dll)$/g) {\n        return (\"Yes\");\n\
    \    }\n    # Check if the file name starts with a number\n    if ($file_name=~/^\\\
    d/g) {\n        return (\"No\");\n    }\n    # Check if the file name starts with\
    \ a letter\n    if ($file_name=~/^[a-z]/g) {\n        return (\"No\");\n    }\n\
    \    # Check if the file name starts with '-' and contains letters or digits,\
    \ \n    # or contains only one dot.\n    if ($file_name=~/^-([a-zA-Z]|\\d|\\.)+$/g)\
    \ {\n        return (\"No\");\n    }\n    # Check if the file name starts with\
    \ '-' and contains only letters or digits, \n    # or contains two dots.\n   \
    \ if ($file_name=~/^-([a-zA-Z]|\\d|\\.){2}$/g) {\n        return (\"No\");\n \
    \   }\n    # Check if the file name starts with '-' and contains only letters\
    \ or digits, \n    # or contains three dots.\n    if ($file_name=~/^-([a-zA-Z]|\\\
    d|\\.){3}$/g) {\n        return (\"No\");\n    }\n    # Check if the file name\
    \ starts with '-' and contains only letters or digits, \n    # or contains four\
    \ dots.\n    if ($file_name=~/^-([a-zA-Z]|\\d|\\.){4}$/g) {\n        return (\"\
    No\");\n    }\n    # Check if the file name starts with '-' and contains only\
    \ letters or digits, \n    # or contains five dots.\n    if ($file_name=~/^-([a-zA-Z]|\\\
    d|\\.){5}$/g) {\n        return (\"No\");\n    }\n    # Check if the file name\
    \ starts with '-' and contains only letters or digits, \n", "    my($retval) =\
    \ 0;\n    \n    if(length($file_name) > 3 ) {\n        $retval = 1;\n    }\n \
    \   elsif($file_name =~ /^[0-9][0-9]{2}\\.\\.\\..*$/) {\n        $retval = 1;\n\
    \    }\n    elsif(substr($file_name, 0, 1) =~ /^[a-zA-z]*\\./) {\n        $retval\
    \ = 1;\n    }\n    else {\n        $retval = 0;\n    }\n    return $retval;\n\
    }\n</code>\n<|/ a tags=perl,validation,validationrules,regex dscore=3 |>\n<| c\
    \ |>\nI tested the regex and it is actually working. However, I wanted to see\
    \ if I could do it without using any regex. Although I liked your answer it was\
    \ very difficult to understand for me since I am new to perl programming.\n<|/\
    \ c |>\n<| c |>\nI'm going to rewrite my answer with an approach that doesn't\
    \ use regex.\n<|/ c |>\n<| a dscore=3 |>\nHow about this - \n<code>\nif($filename\
    \ =~ /^[0-9][0-9]{2}\\.\\.\\..*$/) { \n    # is valid \n}\nelse {\n    # invalid\n\
    }\n</code>\n<|/ a tags=perl,validation,validationrules,regex |>\n<| c |>\nI think\
    \ the `.*` at the end is unnecessary.  It seems to match anything and doesn't\
    \ need to be there.\n<|/ c |>\n<| c |>\nI tested your solution but I wanted to\
    \ see if I could do it without using any regex. Although I liked your answer it\
    \ was very difficult to understand for me since I am new to perl programming.\n\
    <|/ c |>\n<| c |>\n- That is fine - but just to give an idea - you could always\
    \ use the `split` function to break the string on the dot and then check if the\
    \ first element in the resulting array is a letter. I'm pretty sure you could\
    \ do the same with `index` also\n<|/ c |>\n<| c |>\n: Thank you very much. Can\
    \ you please give me an example if possible? I am new to perl.\n<|/ c |>\n<| c\
    \ |>\n: Thank you very much. Can you please give me an example if possible? I\
    \ am new to perl.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nuse File::Basename;\nif\
    \ (basename($filename)=~ /^[0-9][0-9]{2}\\.\\.\\..*$/ ) {\n  # is valid\n}\nelse\
    \ {\n  # invalid\n}\n</code>\n<|/ a tags=perl,validation,validationrules,regex\
    \ |>\n", "    my $is_ok = $file_name =~ /^[1-9][0-9]*\\.$/;\n    $is_ok    ||=\
    \ $file_name =~ /^.[^\\.].*$/;\n    $is_ok    ||= $file_name =~ /^[a-z][a-z].*$/i;\n\
    \    return $is_ok ? \"Yes\" : \"No\";\n}", "    \n    # Check the file name's\
    \ length\n    if (length($file_name) >= 3 && $file_name[0] !~ /^[0-9]$/){\n  \
    \      return 'No';\n    }", "    if ( $file_name !~ /^[0-9]{3}\\.[^.]{0,1}$/i\
    \ ) {\n        return \"No\";\n    } elsif ( $file_name =~ /\\.[^\\.]/ ) {\n \
    \       return \"No\";\n    } elsif ( $file_name =~ /^[a-z]/ ) {\n        return\
    \ \"No\";\n    } elsif ( $file_name !~ /\\.(exe|dll)$/i ) {\n        return \"\
    No\";\n    } else {\n        return \"Yes\";\n    }\n}", "    # Remove all non-digits\
    \ from the string\n    $file_name =~ s/[^0-9]+//g;\n    # Remove all digits from\
    \ the string\n    $file_name =~ s/[0-9]//g;\n    # Remove all periods\n    $file_name\
    \ =~ s/\\.//g;\n    # If the length of the file is less than 3 or greater than\
    \ 12 (inclusive), \n    # then return 'No'\n    return $file_name_length($file_name)\
    \ <= 3 || $file_name_length($file_name) >= 12;\n}", "    return $file_name if\
    \ $file_name !~ /\\d/ || $file_name !~ /\\./ || \n        $file_name !~ /^[^\\\
    .][a-zA-Z]/;\n    return $file_name if $file_name !~ /^[a-zA-Z]/ || $file_name\
    \ !~ /\\.(txt|exe|dll)$/;\n    return \"Yes\";\n}\n</code>\n<|/ a |>\n<| a tags=perl,regex\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    \n    # Remove all non-ASCII characters\
    \ from $file_name using the Encode module\n    # $file_name will be modified in\
    \ place, so we return the modified string\n    return $file_name if $file_name=~/^[0-9A-Za-z_]+$/;",
  "    if($file_name =~ /^[0-9]{3,9}\\.?[a-zA-Z]{1}$/){\n        if($file_name =~\
    \ /^[^.]+/){\n            if($file_name =~ /^[a-z]{1}[a-zA-z0-9]+\\.(txt|exe|dll)$/i){\n\
    \                return \"Yes\";\n            }\n        }\n    }\n    return\
    \ \"No\";\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nWhat is this `my`?\n\
    <|/ c |>\n<| c |>\n, `my` is used for declaring a variable in a scope and assigning\
    \ some value to it. `my` here is used before `if` and `return`, it declares the\
    \ variable `file_name` but does not assign any value to it. `file_name_check`\
    \ function expects a string argument and returns that string. `my` has nothing\
    \ to do with the function's return value.\n<|/ c |>\n<| c |>\n, `my` is used here\
    \ to declare the variables `$file_name` and `$file_name_check` in the scope of\
    \ the `file_name_check` function. `my` is only used to declare variables in Perl's\
    \ scope and is not used anywhere else.\n<|/ c |>\n<| c |>\n: Thank you for the\
    \ explanation.\n<|/ c |>\n<| c |>\n, You are welcome. By the way, the [accepted\
    \ answer](http://stackoverflow.com/a/3954490/725418) is using `$file_name_check`\
    \ in its return statement. That's why I didn't see any need to use `my` in this\
    \ example. Both methods work. :)\n<|/ c |>\n<| a |>\nThe most important thing\
    \ to remember about Perl regular expressions is that they match against whole\
    \ strings (i.e. \"whole lines\"), and that they match against whole lines.  If\
    \ you want it to match against strings, then you need to anchor the regex so that\
    \ it matches against the entire string and not just part of it.\nIn your case,\
    \ you need to anchor the regex so that it matches against the entire file name,\
    \ rather than just the portion of the string that follows the last dot.\nYou can\
    \ do this by adding ^ at the beginning of the regex.  However, I would probably\
    \ do something like this instead:\n<code>\nif ($file =~ /^\\d+\\.(txt|exe|dll)$/i){\n\
    </code>\n<|/ a dscore=2 tags=perl,regex |>\n<| a |>\nTry this one instead, using\
    \ ^ and $ anchors:\n<code>\nif ($file =~ /^\\d+\\.(txt|exe|dll)$/i){\n</code>\n\
    <|/ a dscore=2 tags=perl,regex |>", "    return 1 if $file_name !~ /^\\d{1,3}\\\
    .$/;\n    return 1 if $file_name !~ /^[a-z]$/;\n    return 1 if $file_name !~\
    \ /^[a-z].*\\.(exe|dll)$/i;\n    return \"Yes\";\n}", "    \n    # Check the file\
    \ name\n    if( $file_name=~/^[0-9]{3}\\.[a-zA-Z]+$/ && $file_name=~/^[a-zA-Z].+\\\
    .(txt|exe|dll)$/ ) {\n        return \"Yes\";\n    }\n    else {\n        return\
    \ \"No\";\n    }\n}", "    \n    # Don't allow more than one digit ('0'-'9') in\
    \ the file's name.\n    if($file_name =~ /^[1-9][0-9]*\\.(exe|dll)$/) {\n    \
    \    return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "    if(!$file_name){\n\
    \       return \"No\";\n    }\n    if(length($file_name)>3) {\n        return\
    \ \"No\";\n    }\n    if(!$file_name=~/^[0-9][0-9\\.]+$/) {\n        return \"\
    No\";\n    }\n    if(!$file_name=~/^[a-z][a-z\\.]+$/) {\n        return \"No\"\
    ;\n    }\n    if(!$file_name=~/^[a-z][a-z\\.]*$/) {\n        return \"No\";\n\
    \    }\n    return \"Yes\";\n}", "    $file_name =~ /^(\\d{3})\\.([a-z]|[A-Z])/\
    \ and $2 !~ /^\\./ and $1 !~ /^[0-9]/ and $1 !~ /^[a-z]/ and $1 !~ /^[A-Z]/ and\
    \ $2 !~ /^exe/i;\n}", "    return unless $file_name;\n    \n    my(@error_text)\
    \ = ();\n    \n    my (@file_type, @file_ext) = file_type($file_name);\n    \n\
    \    my $file_name_ok = 1;\n    \n    if (@file_type != 3) {\n        $file_name_ok\
    \ = 0; \n        $error_text[0] .= \" The file's type should be 'txt', 'exe',\
    \ or 'dll'\";\n    }\n    \n    if (@file_ext != 2) {\n        $file_name_ok =\
    \ 0; \n        $error_text[0] .= \" The file's extension should be 'txt', 'exe',\
    \ or 'dll'\";\n    }\n    \n    if ($file_name_ok) {\n        $file_name_ok =\
    \ 1 if substr($file_name, 0, 1) ne \"a\";\n        $file_name_ok = 1 if substr($file_name,\
    \ 0, 1) ne \"b\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"\
    c\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"d\";\n      \
    \  $file_name_ok = 1 if substr($file_name, 0, 1) ne \"e\";\n        $file_name_ok\
    \ = 1 if substr($file_name, 0, 1) ne \"f\";\n        $file_name_ok = 1 if substr($file_name,\
    \ 0, 1) ne \"g\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"\
    h\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"i\";\n      \
    \  $file_name_ok = 1 if substr($file_name, 0, 1) ne \"j\";\n        $file_name_ok\
    \ = 1 if substr($file_name, 0, 1) ne \"k\";\n        $file_name_ok = 1 if substr($file_name,\
    \ 0, 1) ne \"l\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"\
    m\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"n\";\n      \
    \  $file_name_ok = 1 if substr($file_name, 0, 1) ne \"o\";\n        $file_name_ok\
    \ = 1 if substr($file_name, 0, 1) ne \"p\";\n        $file_name_ok = 1 if substr($file_name,\
    \ 0, 1) ne \"q\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"\
    r\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"s\";\n      \
    \  $file_name_ok = 1 if substr($file_name, 0, 1) ne \"t\";\n        $file_name_ok\
    \ = 1 if substr($file_name, 0, 1) ne \"u\";\n        $file_name_ok = 1 if substr($file_name,\
    \ 0, 1) ne \"v\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"\
    w\";\n        $file_name_ok = 1 if substr($file_name, 0, 1) ne \"x", "    return\
    \ 1 if length($file_name) >= 3 && $file_name=~/^\\d+$/ && $file_name=~/^\\./ &&\
    \ $file_name=~/^[a-z][a-zA-Z]+$/;\n    return 1;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\n`sub file_name_check {\n    my($file_name) =;\n    return 1 if length($file_name)\
    \ >= 3 && $file_name=~/^\\d+$/ && $file_name=~/^\\./ && $file_name=~/^[a-z][a-zA-Z]+$/;\n\
    \    return 1;\n}`\n<|/ c |>\n<| c |>\nPlease don't post untested code in your\
    \ answer. Just comment it out and I'll remove the downvote.\n<|/ c |>\n<| c |>\n\
    No idea. Haven't voted on your answer or any other answer.\n<|/ c |>\n<| a tags=perl\
    \ dscore=0 |>\nJust for fun (though I'm sure a regexp would have been quicker),\
    \ here's a version with a loop:\n<code>\n$fname=\"a.b.c\";", "    my %valid_name\
    \ = (\n        \"example\"=> \"Yes\", \n        \"1example\" => \"No\", \n   \
    \     \"example.txt\"=> \"Yes\", \n        \"1example.txt\" => \"No\", \n    \
    \    \"example2.exe\"=> \"Yes\", \n        \"example2.dll\"=> \"Yes\", \n    \
    \    \"example2.dll\"=> \"No\", \n    );\n    \n    my $valid = exists($valid_name{$file_name});\n\
    \    \n    return $valid;\n}", "    $file_name =~ /^[0-9]{3}\\.([^.]*)$/;\n  \
    \  my $valid_filename = $1;\n    $valid_filename =~ /^[a-z][a-zA-Z]+[a-z]$/;\n\
    \    my $dot_pos = index($valid_filename, '.');\n    if ($dot_pos == -1) {\n \
    \       return 0;\n    }\n    if ($dot_pos == 0) {\n        return \"No\";\n \
    \   }\n    my $last_letter = substr($valid_filename, $dot_pos-1, 1);\n    if ($last_letter\
    \ ne 'txt' && $last_letter ne 'exe' && $last_letter ne 'dll') {\n        return\
    \ \"No\";\n    }\n    return 1;\n}", "    if($file_name=~/^\\d+$/) {\n       \
    \ if($file_name=~/^\\d+$/ && $file_name!~/\\.\\..+\\.\\w+/) {\n            if($file_name=~/^\\\
    d+$/ && $file_name!~/\\.\\.+\\..+\\.\\w+/) {\n                if($file_name=~/^\\\
    d+$/ && $file_name!~/\\.\\.+\\..+\\.\\w+/) {\n                    return \"Yes\"\
    ;\n                }\n            }\n        }\n    }\n    return \"No\";\n}",
  "    my($dot_pos) = $file_name =~ m/^\\.*/;\n    my($first_letter) = $file_name\
    \ =~ m/^([a-z])/;\n    my($substr_before) = $file_name =~ m/^(.)/;\n    my($substr_after)\
    \ = $file_name =~ m/(.*)(\\.[a-z0-9]+)/;\n    my($substr_after_check) = defined($substr_after)\
    \ and $substr_after =~ /^(txt|exe|dll)$/i;\n    $dot_pos and $substr_before and\
    \ $first_letter and $substr_after_check;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>\nuse strict;\nuse warnings;", "    \n    my @file_name_parts = split(\"\
    .\", $file_name);\n    \n    if (scalar($file_name_parts) != 3) {\n        return\
    \ \"No\";\n    }\n    \n    foreach my $part (@file_name_parts) {\n        my\
    \ $part_char = substr($part, 0, 1);\n        my $part_number = substr($part, 0,\
    \ 1);\n        if (!($part_char =~ /[A-Z]/) || ($part_number !~ /^[0-9]/) || ($part\
    \ eq '')) {\n            return \"No\";\n        }\n    }\n    return \"Yes\"\
    ;\n}", "    \n    # Check if the first character is a digit and the length is\
    \ one or \n    # more than three\n    if ($file_name[0] =~ /^\\d/ and length($file_name)\
    \ == 1 or length($file_name) > 3) {\n        return 'No';\n    }\n    # Check\
    \ if there is at least one dot\n    if ($file_name =~ /./ and length($file_name)\
    \ >= 2) {\n        return 'No';\n    }\n    # Check if the first character is\
    \ one of the latin alphabet, and it \n    # starts with a letter from the latin\
    \ alphabet\n    if ($file_name[0] =~ /[a-z]/i and $file_name[1] =~ /[A-Z]/) {\n\
    \        return 'Yes';\n    }\n    \n    return 'No';\n}", "    my($is_valid)\
    \ = 'Yes';\n    my(@file_parts);\n    my($max_file_name_length) = 30;\n    my($extension);\n\
    \    my($file_extension_array) = qw( txt exe dll );", "    return $file_name =~\
    \ /^[0-9]{1,3}\\./ && $file_name=~/^[^\\.][a-zA-z][^\\.]/ ? \"Yes\" : \"No\";\n\
    }", "    return if length($file_name) > 3;\n    return if $file_name !~ /\\./\
    \ or $file_name !~ /^[a-z][a-z0-9]*$/;\n    return if $file_name =~ /^[0-9][0-9]*/;\n\
    \    return if $file_name =~ /^[a-z][a-z0-9]*\\.(exe|dll|txt)$/i;\n    return\
    \ if $file_name =~ /^[a-z][a-z0-9]*\\.(exe|dll|txt|zip|gz)$/i;\n    return if\
    \ $file_name =~ /^[a-z][a-z0-9]*\\.(exe|dll|txt|zip|gz|rar|gz|tar|bz2|tgz)$/i;\n\
    \    return if $file_name =~ /^[a-z][a-z0-9]*\\.(exe|dll|txt|zip|gz|rar|gz|tar|bz2|tgz|gz|rar|tar|bz2|tgz|bz|tar|tar|gz)$/i;\n\
    \    return if $file_name =~ /^[a-z][a-z0-9]*\\.(exe|dll|txt|zip|gz|rar|gz|tar|bz2|tgz|gz|rar|tar|bz2|tgz|bz|tar|tar|gz|rar|rar|bz2|rar|rar|tgz|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz2|tgz|gz|rar|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz2|rar|tgz|gz|rar|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz2|rar|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz2|tgz|gz|rar|tar|tar|gz|rar|rar|tgz|gz|rar|rar|tgz|bz2|tgz|gz|rar|",
  "    my($subst_name);\n    if (length($file_name) >= 3 && index($file_name, \".\"\
    ) != -1 && \n        !($subst_name = substr $file_name, 0, 1) && \n        substr($subst_name,\
    \ \".\") =~ /[a-zA-Z0-9]/)\n    {\n        return \"Yes\";\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n}\n</cell>\n<text>\n5. Create a subroutine\
    \ to print a certain message if the file name is valid.\nThe function should accept\
    \ a file's name as a string argument.\nIf the file's name is valid it should print\
    \ 'Yes' to the screen, and nothing \nelse.\nIf the file's name is invalid, it\
    \ should print 'No' to the screen, and \nthe message 'The file's name is invalid.'\
    \ should be printed to the screen.\nExamples:\n>>> file_name_check(\"example.txt\"\
    )\n\"Yes\"\n>>> file_name_check(\"1example.dll\")\n\"No\"\n>>> file_name_check(\"\
    example.txt\")\n\"Yes\"\n>>> file_name_check(\"1example.dll\")\n\"No\"\n>>> file_name_check(\"\
    example.txt\")\n\"Yes\"\n>>> file_name_check(\"1example.dll\")\n\"No\"\n>>> file_name_check(\"\
    1example.txt\")\n\"No\"\n>>> file_name_check(\"example.txt\")\n\"Yes\"\n>>> file_name_check(\"\
    1example.dll\")\n\"No\"", "    my(@errors) = ();\n    my($error_code);\n    my($file_number);\n\
    \    my($filename_len);\n    my($letters);\n    my($letters_cnt);\n    my($letter);\n\
    \    my($letters_checked);\n    my($dot);\n    my(@sub_string) = ();\n    my($sub_string_cnt);",
  "    my($check_file_valid);\n    # Initialize boolean variable.\n    $check_file_valid\
    \ = 0;\n    \n    # Remove all the spaces and newline characters from the file\
    \ name.\n    $file_name = $file_name =~ s/\\s+//g;\n    $file_name = $file_name\
    \ =~ s/^\\s*//g;\n    $file_name = $file_name =~ s/\\s*$//g;\n    \n    # Check\
    \ if the file name is valid or not.\n    if ($file_name =~ /^[0-9]{3}\\.[a-zA-Z0-9]*$/)\
    \ {\n        $check_file_valid = 1;\n    } else {\n        # Check if the file\
    \ name is less than or equal to 3 characters.\n        if ($file_name =~ /^[0-9]{3}/)\
    \ {\n            $check_file_valid = 1;\n        }\n        # Check if the file\
    \ name is more than 3 characters.\n        if ($file_name =~ /^[0-9]{3,}/) {\n\
    \            $check_file_valid = 0;\n        }\n        # Check if the file name\
    \ is empty.\n        if ($file_name =~ /^\\s*$/) {\n            $check_file_valid\
    \ = 1;\n        }\n        # Check if the file name is less than or equal to 1\
    \ character.\n        if ($file_name =~ /^\\./) {\n            $check_file_valid\
    \ = 1;\n        }\n        # Check if the file name is less than or equal to 1\
    \ character.\n        if ($file_name =~ /^[a-zA-Z]/) {\n            $check_file_valid\
    \ = 1;\n        }\n        # Check if the file name is more than 1 character.\n\
    \        if ($file_name =~ /^[a-zA-Z0-9]/) {\n            $check_file_valid =\
    \ 0;\n        }\n        # Check if the file name is less than or equal to 2 characters.\n\
    \        if ($file_name =~ /^[a-zA-Z0-9]{2}/) {\n            $check_file_valid\
    \ = 1;\n        }\n        # Check if the file name is more than 2 characters.\n\
    \        if ($file_name =~ /^[a-zA-Z0-9]{2,}/) {\n            $check_file_valid\
    \ = 0;\n        }\n        # Check if the file name is less than or equal to 3\
    \ digits.\n        if ($file_name =~ /^[a-zA-Z0-9]{3,}/) {\n            $check_file_valid\
    \ = 1;\n        }\n        # Check if the file name is more than 3 digits.\n \
    \       if ($file_name =~ /^[a-zA-Z0-9]{3,}/) {\n            $check_file_valid\
    \ = 0;\n        }\n    }\n    \n    return $check_file_valid;\n}\n</code>\n<|/\
    \ a tags=perl dscore=1 |>\n<| c |>\nthanks for the code. I got this output for\
    \ the above code : No\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\n\
    No\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo\nNo", " \
    \   my $num_extra = 0;\n    my $name_length = $file_name->length;\n    my $dot_count\
    \ = 0;\n    my $first_chr = $file_name->substr(0, 1);\n    my $last_chr = $file_name->substr($name_length\
    \ - 1, 1);\n    my $is_valid;", "    my($valid_chars) = qw[a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z];\n    my($file_length);\n    my($dot_position);\n\
    \    my($before_dot);\n    my($after_dot);\n    my($dot_char);\n    \n    $file_name_length\
    \ = $file_name->length;\n    \n    if($file_name_length >= 3) {\n        for($i\
    \ = 0; $i < $file_name_length; $i++) {\n            $file_char = $file_name->[$i];\n\
    \            if($file_char =~ /\\d/) {\n                if(($file_char >= 'a')\
    \ && ($file_char <= 'z')) {\n                    $file_length = $i;\n        \
    \        } else {\n                    $file_length = $i;\n                  \
    \  $file_char = $file_name->[$i];\n                }\n            } else if($file_char\
    \ eq '.') {\n                $dot_position = $i;\n            } else {\n     \
    \           $file_length = $i;\n            }\n        }\n        \n        if($dot_position\
    \ > 0) {\n            for($i = $dot_position; $i < $file_name_length; $i++) {\n\
    \                $file_char = $file_name->[$i];\n                if($file_char\
    \ =~ /\\d/) {\n                    if(($file_char >= 'a') && ($file_char <= 'z'))\
    \ {\n                        $file_length = $i;\n                    } else {\n\
    \                        $file_length = $i;\n                        $file_char\
    \ = $file_name->[$i];\n                    }\n                } else if($file_char\
    \ eq '.') {\n                    $dot_position = $i;\n                } else {\n\
    \                    $file_length = $i;\n                }\n            }\n  \
    \      }\n        \n        if($file_char ne '.') {\n            if($dot_position\
    \ == 0) {\n                if($file_name->[$dot_position + 1] =~ /[a-z_]/) {\n\
    \                    $before_dot = \"$dot_position\";\n                } else\
    \ {\n                    $before_dot = \"$dot_position - 1\";\n              \
    \  }\n            } else {\n                if($dot_position == ($file_name_length\
    \ - 1)) {\n                    $after_dot = \"$dot_position\";\n             \
    \   } else {\n                    $after_dot = \"$dot_position + 1\";\n      \
    \          }\n            }\n        }\n        \n        if($file_length >= 3\
    \ && ($before_dot ne \"\") && ($after_dot ne \"\")) {\n            if($file_char\
    \ =~ /\\d/) {\n                if(($file_char >= 'a') && ($file_char <= 'z'))\
    \ {\n                    $valid_chars .= $file_char;\n                } else {\n\
    \                    $valid_chars .= $file_char;\n                    $file_char\
    \ = $", "    \n    my $pattern = qr/^([a-z]+)\\.[^\\.]*/i;\n    my $match = qr/$pattern/;",
  "    if ($file_name =~ /^\\d{3}\\.\\w+$/) {\n        my $extension = substr($file_name,\
    \ -3);\n        if ($extension !~ /^(txt|exe|dll)$/) {\n            return 'No';\n\
    \        }\n        my $first_character = substr($file_name, 0, 1);\n        my\
    \ $sub_string = substr($file_name, 1, length($file_name) - 3);\n        if ($first_character\
    \ !~ /^([a-zA-Z])/) {\n            return 'No';\n        }\n        if ($sub_string\
    \ !~ /^([a-zA-Z].*\\.py|\\.c|\\.cpp|\\.java)$/) {\n            return 'No';\n\
    \        }\n        return 'Yes';\n    }\n    else {\n        return 'No';\n \
    \   }\n}", "    \n    my ($dots_count) = get_number_of_dots($file_name);\n   \
    \ return $dots_count > 3 ? \"No\" : ( $dots_count == 3 && \n                 \
    \                    substr($file_name,0,1) ne '' && \n                      \
    \               substr($file_name,0,1) =~ /^[a-zA-Z]/ && \n                  \
    \                   substr($file_name,-1,1) =~ /^[a-zA-Z]/ )\n               \
    \                     ? \"Yes\"\n                                    : \"Invalid\"\
    ;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you, I tried this solution before,\
    \ and it did work, but then I found out that there should be only two dots (.)\
    \ in the file's name. So I modified the code to handle that. I'll add that in\
    \ the original post. Thank you for helping me out!\n<|/ c |>\n<| a tags=perl dscore=2\
    \ |>\nA more perlish way:\n<code>\nif ( ! ( @{[ split /\\./ ]} ) ) { return 'Invalid';\
    \ }\n</code>\n<|/ a |>\n<| c |>\n`split /\\./ ` should be `split /\\.(?!\\d)/`\n\
    <|/ c |>\n<| c |>\n: I didn't. I just pointed out that this way can handle files\
    \ with more than one dot.\n<|/ c |>\n<| c |>\nI agree that this is much more readable\
    \ and maintainable than the regex I posted. But what about `foo.1bar`?\n<|/ c\
    \ |>\n<| a tags=perl |>\n<code>\nif(@string=~/^[a-zA-Z]+[.]\\w+\\.\\w+$/){\n \
    \   say \"Yes\";\n}else{\n    say \"No\";\n}\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 tags=perl |>\nThe following code does not consider filenames with more\
    \ than two dots; you can always add more logic to handle that.\n<code>\nuse warnings;\n\
    use strict;\nuse feature qw(say);", "    return $file_name =~ /^([0-9]{3})\\.(exe|dll)$/\
    \ ? \"Yes\" : \"No\";\n}", "    my($checker) = @_;\n    my($dot_pos) = $file_name\
    \ =~ m/(\\.[^\\.]*)/;\n    my($valid_checker_name) = (\"TXT\", \"EXE\", \"DLL\"\
    );\n    my($first_letter) = substr($file_name,0,1);\n    my($is_valid) = ($dot_pos\
    \ == 0);\n    my($valid_pos) = ($dot_pos > 0);\n    my($valid_pos_in_string) =\
    \ ($dot_pos > 0);\n    my($first_char) = substr($file_name,0,1);\n    my($last_char)\
    \ = substr($file_name,-1,1);\n    my($last_char_valid) = ($last_char =~ m/^[a-z]/);\n\
    \    my($last_char_valid_below_3) = ($last_char_valid && (length($file_name) -\
    \ 1) <= 3);\n    my($valid_below_3_or_empty) = ($valid_pos && ($first_char !=\
    \ '_') && ($first_letter != '.') && (length($file_name) > 3));\n    my($is_valid_below_3_or_empty)\
    \ = ($valid_pos && ($first_char != '_') && ($first_letter != '.') && (length($file_name)\
    \ > 3) && ($file_name=~/^[0-9]{0,3}$/));\n    my($is_valid_below_3_or_empty_or_valid)\
    \ = ($valid_pos && ($first_char != '_') && ($first_letter != '.') && (length($file_name)\
    \ > 3) && ($file_name=~/^[0-9]{0,3}$/) || ($valid_pos_in_string));", "    \n \
    \   if (length($file_name) == 0) {\n        $self->log_warn(\"The file name '$file_name'\
    \ is empty.\");\n        return \"No\";\n    }\n    \n    if ($file_name=~/^[0123456789][^\\\
    .]+\\.txt$/i) { # Invalid file's name\n        $self->log_warn(\"The file name\
    \ '$file_name' is invalid.\");\n        return \"No\";\n    }", "    \n    return\
    \ 0 if ($file_name =~ /^[0-9]{3}\\./ || $file_name =~ /\\.[a-zA-z]$/);\n    \n\
    \    if ($file_name =~ /\\.[a-zA-z]+\\.|\\.[a-zA-z]+$/) {\n        # $file_name\
    \ has two or more dots. Return No\n        return 0;\n    }\n    \n    if ($file_name\
    \ =~ /\\.[^\\.]+\\.[^\\.]+$/) {\n        # $file_name has two dots, but the first\
    \ dot is before the first dot.\n        # Return No\n        return 0;\n    }\n\
    \    \n    # $file_name has two or more dots, and it's just one dot.\n    # Return\
    \ Yes\n    return 1;\n}", "    my ($name, $file_type) = file_type_name($file_name);\n\
    \    if($name =~ /\\.(txt|exe|dll)$/) {\n        my $length = length($file_name)\
    \ - length($name);\n        if($length > 3) {\n            return \"Yes\";\n \
    \       } else {\n            my $index = index($name, \".\");\n            if($index\
    \ < 0) {\n                return \"Yes\";\n            } else if($index != 0)\
    \ {\n                if($name[0] !~ /[a-zA-Z]/) {\n                    return\
    \ \"No\";\n                }\n                foreach my $c (reverse($name)) {\n\
    \                    if($c !~ /[a-zA-Z]/) {\n                        return \"\
    No\";\n                    }\n                }\n                return \"Yes\"\
    ;\n            }\n        }\n    } else {\n        return \"No\";\n    }\n}\n\
    </code>\n<|/ a tags=perl,regex |>\n<| c |>\nYes. This is the more elegant and\
    \ readable solution. Thank you.\n<|/ c |>\n<| c |>\nNice and elegant!  However,\
    \ it only works with letters, not with numbers.  And it only works with the filenames\
    \ I supplied.  I realize the OP said \"I don't want to use the file::basename\
    \ module.\"\n<|/ c |>\n<| c |>\n, Oops, I was assuming these were filenames. Edited.\n\
    <|/ c |>\n<| c |>\nI added a few more tests, including filenames with more than\
    \ 2 dots, and filenames with more than one leading dot.\n<|/ c |>\n<| a |>\nHow\
    \ about this:\n<code>", "    my($number_of_digits);\n    my($dot);\n    my($before);\n\
    \    my($after);\n    my($first_letter);", "    if($file_name) {\n        # There\
    \ should not be more than three digits ('0'-'9') in the file's name.\n       \
    \ if($file_name=~/^[0-9]{3}$/) {\n            # There should be one dot '.'\n\
    \            if($file_name=~/^\\.$/) {\n                # There should not be\
    \ an empty string in the substring before the dot\n                if($file_name=~/^([^\\\
    .])/) {\n                    # The substring before the dot should not be empty,\
    \ and it starts with a letter from\n                    # the latin alphapet ('a'-'z'\
    \ and 'A'-'Z').\n                    if($file_name=~/^\\w/) {\n              \
    \          # The substring after the dot should be one of these: ['txt', 'exe',\
    \ 'dll']\n                        if($file_name=~/^(txt|exe|dll)$/) {\n      \
    \                      # Yes\n                            return \"Yes\";\n  \
    \                      } else {\n                            # No\n          \
    \                  return \"No\";\n                        }\n               \
    \     } else {\n                        # No\n                        return \"\
    No\";\n                    }\n                } else {\n                    #\
    \ No\n                    return \"No\";\n                }\n            } else\
    \ {\n                # No\n                return \"No\";\n            }\n   \
    \     } else {\n            # No\n            return \"No\";\n        }\n    }\
    \ else {\n        # No\n        return \"No\";\n    }\n}", "    my($return) =\
    \ undef;\n    # Extract digits from name.\n    $file_name =~ s/(^.*)(\\d)/$1/g;\n\
    \    # Check if the name contains dot '.'.\n    if($file_name =~ /\\.\\./) {\n\
    \        # Extract the first and last characters.\n        my $first_character\
    \ = $1;\n        my $last_character = $file_name;\n        # Check if the first\
    \ character is a letter and the last character is \n        # one of these extensions.\n\
    \        if($first_character !~ /[a-zA-z]/) {\n            $return = \"No\";\n\
    \        }\n        if($last_character !~ /[txt|exe|dll]/) {\n            $return\
    \ = \"No\";\n        }\n    }\n    else {\n        $return = \"Yes\";\n    }\n\
    \    return $return;\n}", "    my $valid = 1;\n    \n    if ($file_name) {\n \
    \       $file_name =~ /\\d+/;\n        $valid = 1 if $file_name =~ /^\\d+$/ &&\
    \ $file_name =~ /\\./ && $file_name =~ /[^a-z].*/;\n    }\n    \n    return $valid\
    \ ? 'Yes' : 'No';\n}", "    my ($ok, $msg) = ();\n    \n    # First validate the\
    \ file's name, since it can't contain more than 3 digits.\n    my $num_digits_ok\
    \ = is_num_digits($file_name);\n    if ($num_digits_ok == 1) {\n        # There's\
    \ no point in checking if the file's name contains only two dots.\n        # So\
    \ no need to check $file_name.\n        \n        # First, split the filename\
    \ into its components delimited by dots. \n        # Each component has one and\
    \ only one dot.\n        my(@file_components) = split(\"\\\\.\", $file_name);\n\
    \        if (scalar(@file_components) == 1) {\n            \n            # Now\
    \ we check whether there is any character before the dot. If there is, \n    \
    \        # then it must be an alphanumeric character; otherwise, it is a illegal\n\
    \            # character in Perl.\n            my $filename_first_char = substr($file_name,\
    \ 0, 1);\n            my $filename_first_char_ok = is_alpha($filename_first_char);\n\
    \            if ($filename_first_char_ok == 1) {\n                # Now we check\
    \ whether the file's name starts with the character \n                # from the\
    \ latin alphabet ('a' - 'z'). \n                my $filename_first_char_ok = is_latin_alpha($filename_first_char);\n\
    \                if ($filename_first_char_ok == 1) {\n                    \n \
    \                   # Now we check whether the file's name ends with an alphanumeric\
    \ \n                    # character from one of the accepted extensions.\n   \
    \                 my $filename_last_char_ok = is_alpha(substr($file_name, -1));\n\
    \                    $ok = $filename_last_char_ok == 1 ? 1 : 0;\n            \
    \    }\n            }\n        }\n    }\n    \n    return $ok ? $msg : $msg1 =\
    \ \"$file_name is a illegal filename.\\n\";\n}", "    # Validate that the file\
    \ does not contain any digits.\n    if ($file_name =~ /^\\d+$/ && $file_name !~\
    \ /\\.[^\\.]*\\z/) {\n        return \"No\";\n    }", "    my($ok) = qx(du -s\
    \ $file_name);\n    my($dot_pos) = index($file_name, '.');\n    my($first, $second)\
    \ = split(/\\./, $file_name);\n    my($first_letter) = $first =~ /[a-z]/;\n  \
    \  my($second_letter) = $second =~ /[a-z]/;\n    if ($dot_pos == -1 or $dot_pos\
    \ == 0 or $first_letter or $second_letter) {\n        return $ok;\n    } else\
    \ {\n        return $ok;\n    }\n}", "    return '' unless $file_name;\n    my($file_no_ext)\
    \ = substr($file_name, 0, length($file_name) - 5);\n    my($dot_pos) = index($file_name,\
    \ '.');\n    if ($dot_pos == -1) {\n        return \"No\";\n    }\n    my($dot_name_pos)\
    \ = index($file_no_ext, $dot_pos);\n    if ($dot_name_pos < 0) {\n        return\
    \ \"No\";\n    }\n    my($dot_name) = substr($file_no_ext, 0, $dot_name_pos);\n\
    \    if ($dot_name !~ /^[a-zA-Z]+$/) {\n        return \"No\";\n    }\n    my($dot_name_lower)\
    \ = $dot_name;\n    $dot_name_lower =~ tr/a-z/A-Z/;\n    if ($dot_name_lower !~\
    \ /^[a-zA-Z]+$/) {\n        return \"No\";\n    }\n    my($dot_name_first_letter)\
    \ = $dot_name;\n    $dot_name_first_letter =~ tr/a-z/A-Z/;\n    if ($dot_name_first_letter\
    \ !~ /^[a-zA-Z]+$/) {\n        return \"No\";\n    }\n    return \"Yes\";\n}",
  "    # Check if file name contains more than one digit.\n    if ($file_name !~ /\\\
    d{2,}/) {\n        return 'No';\n    }\n    # Check if file name contains only\
    \ one dot.\n    if ($file_name !~ /\\.\\.\\./) {\n        return 'No';\n    }\n\
    \    # Check if file name contains only alphanumeric characters.\n    if ($file_name\
    \ !~ /^[A-z]\\w*$/) {\n        return 'No';\n    }\n    # Check if file name contains\
    \ at least one character from latin alphabet.\n    if ($file_name !~ /^\\w/) {\n\
    \        return 'No';\n    }\n    return 'Yes';\n}", "    my $retval;\n    \n\
    \    if ($file_name =~ /^[0-9]{3}\\./) {\n        $retval = 1 if $file_name !~\
    \ /^\\./;\n        $retval = 1 if $file_name =~ /^\\d/;\n        $retval = 1 if\
    \ $file_name =~ /^[a-z]/;\n        $retval = 1 if $file_name =~ /^[A-Z]/;\n  \
    \      $retval = 1 if $file_name =~ /^[0-9a-zA-Z\\.]/;\n    }\n    else {\n  \
    \      $retval = \"No\";\n    }", "    # Validate that the file name contains\
    \ only a single period.\n    if ($file_name !~ /\\.\\d$/) {\n        return (\"\
    No\");\n    }\n    # Validate that the file name contains exactly one period.\n\
    \    elsif ($file_name !~ /\\.\\./) {\n        return (\"No\");\n    }\n    #\
    \ Validate that the file starts with an alphabetic character.\n    elsif ($file_name\
    \ !~ /^\\w./) {\n        return (\"No\");\n    }\n    # Validate that the file\
    \ ends with either 'txt', 'exe', 'dll', or 'java'.\n    elsif ($file_name !~ /\\\
    .(exe|dll|java)$/) {\n        return (\"No\");\n    }\n    # Return Yes.\n   \
    \ return (\"Yes\");\n}", "    my(@letters) = qw(a b c d e f g h i j k l m n o\
    \ p q r s t u v w x y z);\n    my($result);", "    my ($dot_pos) = index($file_name,\
    \ '.');\n    my ($dot_name) = $file_name->subString($dot_pos, 1);\n    my ($char,\
    \ $letter_one, $letter_two);\n    my ($file);\n    my($result);\n    \n    # Checks\
    \ the conditions specified above to see if $file_name \n    # is valid or not.\n\
    \    if($dot_pos ne -1 and $dot_name ne \"\" and $dot_name ne \".\" and \n   \
    \    $dot_name ne '..' and $dot_name ne '' and ($char = $dot_name->charAtOrPos('a')\
    \ < $char and $char < $dot_name->charAtOrPos('z') or $char = $dot_name->charAtOrPos('A')\
    \ < $char and $char < $dot_name->charAtOrPos('Z'))) {\n        $file = $dot_name->subString(0,\
    \ 1);\n        $result = $file eq \"txt\" or $file eq \"exe\" or $file eq \"dll\"\
    ;\n    } else {\n        $result = $dot_name eq '' or $dot_name eq '.' or $dot_name\
    \ eq '..' or $dot_name eq '.' or $dot_name eq '..';\n    }\n    \n    $result;\n\
    }", "    \n    # Remove any spaces and newlines in the file name\n    $file_name\
    \ =~ s/\\s+//;\n    $file_name =~ s/\\n//;", '    my $result;', "    if($file_name)\
    \ {\n        my @temp;\n        if($file_name =~ m/^[0-9]{1,3}\\.[^\\.]{0,1}[0-9]{0,1}\\\
    .[^\\.]{0,1}[0-9]{0,1}$/) {\n            push(@temp, $file_name);\n          \
    \  my $temp_pos = @temp;\n            while(@temp) {\n                my $temp\
    \ = pop;\n                if($temp =~ m/[0-9]{1,3}\\.[^\\.]{0,1}[0-9]{0,1}\\.[^\\\
    .]{0,1}[0-9]{0,1}/) {\n                    if($temp =~ m/[0-9]{1,3}\\.[^\\.]{0,1}[0-9]{0,1}\\\
    .[^\\.]{0,1}[0-9]{0,1}/) {\n                        if($temp =~ m/[0-9]{1,3}\\\
    .[^\\.]{0,1}[0-9]{0,1}\\.[^\\.]{0,1}[0-9]{0,1}/) {\n                         \
    \   $temp_pos += 1;\n                        }\n                    }\n      \
    \          }\n                push(@temp, $temp);\n            }\n           \
    \ if($temp_pos == 3) {\n                return \"Yes\";\n            } else {\n\
    \                return \"No\";\n            }\n        } else {\n           \
    \ return \"No\";\n        }\n    } else {\n        return \"No\";\n    }\n}\n\
    </code>\n<|/ a tags=perl dscore=0 |>\n<| c |>\nPlease consider posting a new question,\
    \ instead of reusing an old one for new questions. If the answer you accepted\
    \ answers the question you asked, then mark it as such.\n<|/ c |>\n<| a |>\nI\
    \ came up with a solution that is more efficient than your previous code. You\
    \ can test it here. The code below is tested and works. You can find the full\
    \ code here.\n<code>", "    \n    my $name_ok = 1;", "    my $filename = $file_name;\n\
    \    my $valid_string = \"0123456789\";\n    if ($filename =~ m/^\\d{3,}$/) {\n\
    \        if ($filename =~ m/^[a-z]{2}\\.[a-z]$/) {\n            if ($filename\
    \ =~ m/^.+\\.(?:txt|exe|dll)$/) {\n                return \"Yes\";\n         \
    \   }\n        }\n    }\n    return \"No\";\n}", "    return 1 if $file_name !~\
    \ /^[0-9]{1,3}\\..*\\z/ || $file_name !~ /^[a-z]{1,2}\\z/ || \n              \
    \   $file_name =~ /^[a-z]{2}\\z/ && ($file_name =~ /^[a-z]\\.[a-z]\\z/ || \n \
    \                $file_name =~ /^[a-z]\\.[A-Z]\\z/ || $file_name =~ /^[a-z]\\\
    z/ || \n                 $file_name =~ /^[A-Za-z]\\z/ || $file_name =~ /^[A-Za-z]{2}\\\
    z/ || \n                 $file_name =~ /^[a-z]\\.[A-Za-z]\\z/ || $file_name =~\
    \ /^[A-Za-z]{3}\\z/ ||\n                 $file_name =~ /^[a-z]\\.[A-Za-z]{3}\\\
    z/ || $file_name =~ /^[A-Za-z]{4}\\z/ ||\n                 $file_name =~ /^[a-z]{5}\\\
    .[A-Za-z]{3}\\z/ || $file_name =~ /^[A-Za-z]{6}\\.[A-Za-z]{3}\\z/ ||\n       \
    \          $file_name =~ /^[A-Za-z]{7}\\.[A-Za-z]{4}\\z/ || $file_name =~ /^[A-Za-z]{8}\\\
    .[A-Za-z]{5}\\.[A-Za-z]{4}\\z/ ||\n                 $file_name =~ /^[A-Za-z]{9}\\\
    .[A-Za-z]{5}\\.[A-Za-z]{6}\\.[A-Za-z]{5}\\z/ || \n                 $file_name\
    \ =~ /^[A-Za-z]{10}\\.[A-Za-z]{5}\\.[A-Za-z]{6}\\.[A-Za-z]{5}\\.[A-Za-z]{4}\\\
    z/ || \n                 $file_name =~ /^[A-Za-z]{11}\\.[A-Za-z]{5}\\.[A-Za-z]{6}\\\
    .[A-Za-z]{5}\\.[A-Za-z]{3}\\.[A-Za-z]{4}\\z/ ||\n                 $file_name =~\
    \ /^[A-Za-z]{12}\\.[A-Za-z]{5}\\.[A-Za-z]{6}\\.[A-Za-z]{5}\\.[A-Za-z]{3}\\.[A-Za-z]{3}\\\
    .[A-Za-z]{4}\\z/ ||\n                 $file_name =~ /^[A-Za-z]{13}\\.[A-Za-z]{5}\\\
    .[A-Za-z]{6}\\.[A-Za-z]{5}\\.[A-Za-z]{3}\\.[A-Za-z]{3}\\.[A-Za-z]{3}\\.[A-Za-z]{4}\\\
    z/ ||\n                 $file_name =~ /^[A-Za-z]{14}\\.[A-Za-z", "    return unless\
    \ $file_name;\n    my @errors;\n    \n    if ($file_name->[0] =~ /^[0-9]{1,3}$/\
    \ || $file_name->[0] =~ /^\\.$/) {\n\tpush @errors, \"The file's name should contain\
    \ at most three digits!\";\n    }\n    \n    if ($file_name->[0] =~ /^[a-zA-z]{1,1}\\\
    .[a-zA-z]{1,1}$/ && ! $file_name->[1]) {\n\tpush @errors, \"The file's name should\
    \ contain at least a letter!\";\n    }\n    \n    foreach my $suffix (qw{txt exe\
    \ dll}) {\n\tforeach my $part (split /\\.\\z/, $file_name->[0]) {\n\t    my $file_name\
    \ = join($part, '.', \"$suffix\");\n\t    if ($file_name_check($file_name)) {\n\
    \t\treturn \"Yes\";\n\t    }\n\t}\n    }\n    \n    push @errors, \"The file's\
    \ name should contain one of these: ['txt', 'exe', 'dll']\";\n    return \"No\"\
    ;\n}", "    my($dot_index) = $file_name.index(\".\");\n    my($letter_index) =\
    \ -1;\n    \n    # No dot at the end\n    if( $dot_index eq -1) {\n        return\
    \ (\"No\");\n    }\n    \n    # No letter at the beginning.\n    if($file_name[0]\
    \ =~ /^[a-zA-Z]+$/) {\n        $letter_index = 0;\n    } else {\n        return\
    \ (\"No\");\n    }\n    \n    # No more than one digit in the file name.\n   \
    \ while($file_name[$dot_index] =~ /^[0-9]$/) {\n        $dot_index++;\n      \
    \  if($dot_index > $file_name.length) {\n            return (\"No\");\n      \
    \  }\n    }\n    \n    # No substring before dot.\n    if($dot_index > 0) {\n\
    \        my($first_letter_of_dot_substring) = substr($file_name,0,$dot_index);\n\
    \        if($first_letter_of_dot_substring !~ /^[a-zA-Z]+$/) {\n            return\
    \ (\"No\");\n        }\n    }\n    \n    # No substring after dot.\n    my($dot_substring)\
    \ = substr($file_name,$dot_index);\n    if((scalar keys %dot_substrings) != 3)\
    \ {\n        return (\"No\");\n    }\n    my($dot_substring) = sort keys %dot_substrings;\n\
    \    if(($dot_substring[0] ne \"exe\") && ($dot_substring[0] ne \"dll\")) {\n\
    \        return (\"No\");\n    }\n    \n    # All checks passed.\n    return \"\
    Yes\";\n}", "    \n    my $error_string = \"\";\n    \n    # Check if there is\
    \ more than 3 digits in the file name.\n    # There can be three digits if the\
    \ file name is composed of 'a0.txt', \n    # 'b1.txt', and 'c2.txt', but there\
    \ can not be more than 3 digits in 'd0.txt'.\n    $error_string .= \"Error - File\
    \ name contains more than 3 digits!\\n\" if length($file_name) > 3;", "    my\
    \ ($file_extension) = split ('.', $file_name);\n    my (@valid_extensions) = ('txt',\
    \ 'exe', 'dll');\n    \n    if ($file_extension =~ /^([0-9]){3,3}\\.[a-z][a-z]*$/)\
    \ {\n        return 'Yes';\n    }\n    elsif ($file_extension =~ /^[a-z][a-z]*\\\
    .?$/) {\n        return 'No';\n    }\n    else {\n        return 'No';\n    }\n\
    }\n</cell>\n<cell>\nfile_name_check(\"1example.exe\")\n</cell>\n<text>\nQuestion\
    \ 3: Define a method which, when passed a filename argument in a string, returns\n\
    'Yes' if the file's name is valid, and returns 'No' otherwise.", "    my($dot_pos);\n\
    \    my($substr_before_dot);\n    my($substr_after_dot);\n    my($latin_char);\n\
    \    my($latin_char_range);", "    my $file_name = shift;\n    if (not ($file_name))\
    \ {\n        $file_name = $file_name;\n    }\n    if ($file_name =~ /^[0-9]{3}/)\
    \ {\n        if ($file_name =~ /\\./) {\n            my $num_digits = length($file_name)\
    \ - length($file_name);\n            my $num_dot_positions = $num_digits - index($file_name,\
    \ '.');\n            if ($num_dot_positions > 0) {\n                print \"The\
    \ file name is invalid: $file_name.\\n\";\n                return \"No\";\n  \
    \          }\n        }\n    }\n    my $file_name = substr($file_name, 1);\n \
    \   if ($file_name =~ /[a-z]$/) {\n        my $first_letter = substr($file_name,\
    \ 0, 1);\n        if (!($first_letter =~ /^[a-Z]/)) {\n            print \"The\
    \ file name is invalid: $file_name.\\n\";\n            return \"No\";\n      \
    \  }\n    }\n    if ($file_name =~ /^[a-z\\.]/) {\n        print \"The file name\
    \ is invalid: $file_name.\\n\";\n        return \"No\";\n    }\n    print \"The\
    \ file name is valid: $file_name.\\n\";\n    return \"Yes\";\n}", "    $file_name\
    \ =~ /(\\d{1,3})(\\.(?!\\1)[a-zA-z]\\w*)$/;\n    if ($1) {\n        return $1\
    \ if $1 =~ /\\.$/;\n    }\n    return $1 if $1 =~ /\\.$/;\n    return \"No\";\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 tags=regex,perl,filepath |>\nYou don't need\
    \ a regex.  A simple length check suffices:\n<code>\nif(length $file > 3) {\n\
    \    die \"File name should be less than 3 characters\";\n}\n</code>\n<|/ a |>\n\
    <| c |>\nA length check won't help if you don't know the extension at the time.\
    \ In many cases, knowing the extension will help you validate the file name, but\
    \ most of the time you still don't know the extension. So you still need a regex.\
    \ And if you don't know the extension then you still can't validate the file name.\n\
    <|/ c |>\n<| a dscore=2 |>\nTry this\n<code>\nuse strict;\nuse warnings;", " \
    \   my($file_extension) = substr($file_name, rindex($file_name, '.') + 1);\n \
    \   my($file_part) = substr($file_name, 0, rindex($file_name, '.'));\n    my($file_part)\
    \ = substr($file_part, 0, 2);\n    my($first_letter) = substr($file_part, 0, 1);\n\
    \    my($valid) = ('0' .. '9' eq 'a' .. 'z') ||\n                ('A' .. 'Z' eq\
    \ 'a' .. 'z') ||\n                ('a' .. 'z' eq 'A' .. 'Z') ||\n            \
    \    ('A' .. 'Z' eq 'A' .. 'Z');\n    if (length($file_part) > 3 && !$valid) {\n\
    \        return \"No\";\n    }\n    if ($file_part !~ /^[A-Z]$/ && !$valid) {\n\
    \        return \"No\";\n    }\n    if ($first_letter !~ /^[A-Z]$/ && !$valid)\
    \ {\n        return \"No\";\n    }\n    if ($file_extension =~ /^(txt|exe|dll)$/\
    \ && !$valid) {\n        return \"No\";\n    }\n    return \"Yes\";\n}", "   \
    \ \n    my $result;\n    \n    # 1. No more than three digits in the file name\n\
    \    if ($file_name =~ /^\\d{3}$/) {\n        $result = \"Yes\";\n    }\n    \n\
    \    # 2. No more than one dot '.'\n    if ($file_name !~ /^\\.+$/ && $file_name\
    \ !~ /^\\./) {\n        $result = \"No\";\n    }\n    \n    # 3. Substring before\
    \ the dot should not be empty\n    # 4. Substring after the dot should be one\
    \ of these: ['txt', 'exe', 'dll']\n    if ($file_name !~ /^\\.+$/ && $file_name\
    \ !~ /^\\./) {\n        $result = \"No\";\n    }\n    \n    # 5. Substring before\
    \ the dot should be letter\n    # 6. Substring after the dot should be one of\
    \ these: ['txt', 'exe', 'dll']\n    if ($file_name !~ /^\\.+$/ && $file_name !~\
    \ /^\\./) {\n        $result = \"No\";\n    }\n    \n    return $result;\n}",
  "    my(@errors) = ();\n    \n    if($file_name =~ /^[0-9]{3}\\.$/) {\n        if($file_name\
    \ =~ /^\\.+[a-z]{1}\\.+$/) {\n            # File name contains one dot '.'\n \
    \           $file_name = $file_name[0..-2];\n        } else {\n            $errors[]\
    \ = \"File's name should have a dot '.' in the beginning.\";\n        }\n    }\n\
    \    \n    if($file_name !~ /^[a-z]{1}\\.?$/) {\n        $errors[] = \"File's\
    \ name should start with a letter from the latin alphapet.\";\n    }\n    \n \
    \   if(@errors) {\n        return 'No';\n    } else {\n        return 'Yes';\n\
    \    }\n}", "    \n    # Validate if file name is only letters or numbers\n  \
    \  return '' if !$file_name || !$file_name=~/^[a-z_0-9]+$/i;", "    \n    return\
    \ $file_name !~ /^\\d{3}\\./ ||\n           $file_name !~ /^[a-zA-Z][a-z]+\\./\
    \ ||\n           $file_name !~ /^[a-zA-Z][a-z]+$/;\n}", "    my $name_ok = 1;\n\
    \    my $dot_pos = index($file_name, '.');\n    my $name_rest = substr($file_name,\
    \ 0, $dot_pos);\n    $name_rest =~ /^[a-zA-z\\.]+$/;", "    my($count) = @_;\n\
    \    my $invalid = '';\n    \n    $count -= 1;\n    \n    if (length($file_name)\
    \ >= 3) {\n        if ($file_name !~ /^[0-9]+\\.[A-Za-z]+$/i) {\n            $invalid\
    \ = 'Yes';\n        }\n        elsif ($file_name !~ /^[A-Za-z]+\\.txt$/i &&\n\
    \            !($file_name !~ /^[A-Za-z]+\\.exe$/i &&\n            !($file_name\
    \ !~ /^[A-Za-z]+\\.dll$/i))) {\n            $invalid = 'No';\n        }\n    }\n\
    \    \n    return $invalid;\n}\n</code>\nThe second function should return all\
    \ the directories that are valid and invalid in the current directory ($dir).\
    \ It should return an array which contains all the valid directories and an array\
    \ which contains all the invalid directories.\nExample:\n<code>\nmy $dir = '.';\n\
    my;\nmy = directory_check($dir, \\@dirs);\nprint \"Valid\\n\";\n</code>\nThe output\
    \ should be something like this:\n<code>", "    $file_name =~ /^\\d{1,3}\\.[A-Za-z][\\\
    .txt|\\.exe|\\.dll]$/i;\n    if (length($1) != 3) { \n\treturn \"No\";\n    }\n\
    \    my $first_char = substr($1, 1);\n    my $first_char = lc($first_char);\n\
    \    if ($first_char ne 'a'..'z' || $first_char ne 'A'..'Z') {\n\treturn \"No\"\
    ; \n    }\n    my %valid_extensions = ( txt => 1, exe => 1, dll => 1 );\n    foreach\
    \ my $extension (keys %valid_extensions) {\n\tif (index($file_name, $extension)\
    \ != -1) {\n\t    return $valid_extensions{$extension};\n\t}\n    }\n    return\
    \ \"No\";\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
