name: HumanEval_6_parse_nested_parens
language: pl
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\nsub parse_nested_parens {\n    my($paren_string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_nested_parens;\n\
  \        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  () (()) ((())) (((())))\"),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[4]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @paren_levels = ();\n    my @paren_groups = ();\n    my @parens\
    \ = ();\n    my @paren_stack = ();", "    my(@paren_levels) = ();\n    my(@paren_levels_depth)\
    \ = ();\n    my(@paren_level_stack) = ();\n    my(@levels) = ();\n    my($start_level)\
    \ = 0;\n    my($end_level) = 0;\n    my($max_nesting_levels) = 0;\n    my($max_nesting_levels_depth)\
    \ = -1;\n    my($max_level_stack_depth) = -1;\n    my(@nestings) = ();", "   \
    \ my(@return) = ();\n    my($opening_paren_level, $closing_paren_level);\n   \
    \ \n    my $bracket_counter = 0;\n    while ($bracket_counter < length($paren_string))\
    \ {\n        if ($paren_string[$bracket_counter] eq \"(\") {\n            push\
    \ (@return, $opening_paren_level);\n            ++$opening_paren_level;\n    \
    \    }\n        elsif ($paren_string[$bracket_counter] eq \")\") {\n         \
    \   ++$closing_paren_level;\n            push (@return, $closing_paren_level);\n\
    \        }\n        elsif ($paren_string[$bracket_counter] eq \",\") {\n     \
    \       ++$opening_paren_level;\n            push (@return, $opening_paren_level);\n\
    \        }\n        elsif ($paren_string[$bracket_counter] eq \"]\") {\n     \
    \       push (@return, $opening_paren_level);\n            ++$opening_paren_level;\n\
    \        }\n        ++$bracket_counter;\n    }\n    return @return;\n}", "   \
    \ my @paren_stack = ();\n    my %parens;\n    $paren_string = ' ' x length($paren_string);\n\
    \    while ($paren_string =~ s/^ *\\( *| *\\) *$//g) {\n        my $current_paren\
    \ = $1;\n        $paren_string =~ s/^\\($current_paren\\)$current_paren$current_paren//;\n\
    \        push @paren_stack, $current_paren;\n    }\n    my $max_level = @paren_stack;\n\
    \    while ($max_level > 0) {\n        my $current_paren = pop @paren_stack;\n\
    \        my $depth = @paren_stack - $max_level;\n        my $next_paren = $parens{$current_paren}\
    \ + 1;\n        if ($next_paren > $max_level) {\n            $max_level = $next_paren;\n\
    \        }\n        $parens{$current_paren} = $next_paren;\n    }\n    my @output_parens\
    \ = ();\n    for my $key (sort keys %parens) {\n        push @output_parens, $key;\n\
    \    }\n    return @output_parens;\n}\n</code>\n<|/ a tags=algorithm,math,parentheses\
    \ |>\n<| a |>\n<code>\nclass Stack\n{\n     private Stack[] stackArray;\n    \
    \ private int stackSize=1;\n     public void push(String str){\n         stackArray[stackSize]=str;\n\
    \         stackSize++;\n     }\n     public String pop(){\n         stackSize--;\n\
    \         String str=stackArray[stackSize];\n         return str;\n     }\n  \
    \   public String peek(){\n         stackSize--;\n         return stackArray[stackSize];\n\
    \     }\n     public int top(){\n         stackSize--;\n         return stackSize;\n\
    \     }\n     public boolean isEmpty(){\n         return stackSize==0;\n     }\n\
    \     public String toString(){\n         String str=null;\n         for(int i=0;i<stackSize;i++)\n\
    \             str=str+stackArray[i];\n         return str;\n     }\n     public\
    \ static void main(String args[]){\n         Stack s=new Stack();\n         s.push(\"\
    (\");\n         s.push(\"(\");\n         s.push(\"(\");\n         s.push(\"(\"\
    );\n         s.push(\"(\");\n         s.push(\"(\");\n         s.push(\"(\");\n\
    \         s.push(\"(\");\n         s.push(\"(\");\n         s.push(\"(\");\n \
    \        s.push(\"(\");\n         s.push(\"(\");\n         s.push(\"(\");\n  \
    \       s.push(\"(\");\n         s.push(\"(\");\n         s.push(\"(\"", '    my($group_size,
    $deepest_level);', "    my @paren_groups = parse_nested_parens_string($paren_string);\n\
    \    return @paren_groups;\n}", "    # Count # of opening and closing parenthesis.\n\
    \    my $paren_count = ()\n    # Stack of parenthesis, to count nesting.\n   \
    \     = [()];\n    $paren_string = lc $paren_string;\n    $paren_count += ()\n\
    \        = map { $paren_count[$_] += 1 } 0 .. $paren_string=~tr/()()//;\n    return\
    \ $paren_count;\n}", "    my(@results);\n    my($level);\n    my($start_level);\n\
    \    my($max_level);", "    $paren_string =~ s/\\s+/ /g;\n    $paren_string =~\
    \ s/\\([^)]*\\)//g;\n    return $paren_string =~ /\\(([^\\(\\)]+)\\)/ig;\n}",
  "    my @paren_levels = ();\n    my $cur_level = 0;\n    my $cur_paren_level = 0;\n\
    \    for (my $i = 0; $i <= length($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ eq '(') {\n            if ($cur_level == 0) {\n                $cur_paren_level++;\n\
    \            }\n            elsif ($cur_paren_level == 0) {\n                $cur_paren_level++;\n\
    \                $cur_level++;\n            }\n            else {\n          \
    \      $cur_paren_level--;\n            }\n        }\n        elsif ($paren_string[$i]\
    \ == ')') {\n            if ($cur_paren_level == 0) {\n                $cur_paren_level--;\n\
    \            }\n            else {\n                $cur_paren_level--;\n    \
    \            $cur_level--;\n            }\n        }\n        elsif ($paren_string[$i]\
    \ == ' ') {\n            if ($cur_paren_level == 0) {\n                $cur_level++;\n\
    \            }\n            else {\n                $cur_paren_level--;\n    \
    \        }\n        }\n    }\n    return @paren_levels;\n}", "    my @paren_levels\
    \ = ();\n    my @num_parens = 0;", "    my(@paren_groups) = ();\n    my($max_nested_level)\
    \ = undef;\n    my @levels_of_parens = ();", "    my @paren_strings = split /\\\
    s+/, $paren_string;\n    my @max_level_of_nestings = ();\n    my @groups = ();\n\
    \    my $group_index = 0;\n    my $level = 0;\n    my $last_open_paren = 1;\n\
    \    my $open_paren = 0;\n    my $open_paren_found = 0;\n    foreach my $string\
    \ ( @paren_strings ) {\n        if ($open_paren == 0) {\n            if ( $string\
    \ eq '(' ) {\n                $open_paren = 1;\n            }\n            else\
    \ {\n                if ($string eq ')') {\n                    $open_paren =\
    \ 0;\n                }\n                else {\n                    push (@groups,\
    \ $string);\n                }\n            }\n        }\n        else {\n   \
    \         if ( $string eq '(' ) {\n                $open_paren = 1;\n        \
    \    }\n            else {\n                $open_paren = 0;\n               \
    \ if ($string eq ')') {\n                    $open_paren_found = 1;\n        \
    \        }\n                else {\n                    if ($open_paren_found)\
    \ {\n                        push (@max_level_of_nestings, $level);\n        \
    \            }\n                    push (@groups, $string);\n               \
    \ }\n            }\n        }\n    }\n    if ( @max_level_of_nestings ) {\n  \
    \      $group_index = scalar @groups;\n    }\n    foreach my $string ( @groups\
    \ ) {\n        $group_index++;\n        if ($group_index > scalar(@groups)) {\n\
    \            print \"Bad groups: \", @groups, \", \", $group_index;\n        \
    \    exit 0;\n        }\n    }\n    return @max_level_of_nestings;\n}", "    my($depth);\n\
    \    my($nest_level);\n    my @groups;\n    my @nested_parens = ();\n    # Split\
    \ string at parens.\n    my @parens = split /([\\(\\)])/, $paren_string;\n   \
    \ for (my $i = 0; $i < scalar @parens; $i++) {\n        $depth = 0;\n        $nest_level\
    \ = 0;\n        my $paren = $parens[$i];\n        if ($paren =~ m/(\\(\\)|\\(\\\
    (|\\))/) {\n            for (my $j = $i; $j < scalar @parens; $j++) {\n      \
    \          my $nested_paren = $parens[$j];\n                if ($nested_paren\
    \ =~ m/(\\(\\)|\\(\\(|\\))/) {\n                    if ($nested_paren =~ m/(\\\
    (\\)|\\(\\(|\\))/) {\n                        if ($nested_paren =~ m/(\\(\\)|\\\
    (\\(|\\))/) {\n                            $nested_paren =~ s/^|$/0/;\n      \
    \                      push @nested_parens, $nested_paren;\n                 \
    \           last;\n                        }\n                        else {\n\
    \                            $nested_paren =~ s/^|$/1/;\n                    \
    \    }\n                    }\n                    else {\n                  \
    \      if ($nested_paren =~ m/(\\(\\)|\\(\\(|\\))/) {\n                      \
    \      $nested_paren =~ s/^|$/0/;\n                            push @nested_parens,\
    \ $nested_paren;\n                            last;\n                        }\n\
    \                        else {\n                            $nested_paren =~\
    \ s/^|$/1/;\n                        }\n                    }\n              \
    \  }\n            }\n            $depth++;\n        }\n        elsif ($paren =~\
    \ m/(\\()/) {\n            $depth++;\n        }\n        elsif ($paren =~ m/(\\\
    ))/) {\n            $depth--;\n        }\n        if ($depth == 0 && $nest_level\
    \ == 0 && !defined($nested_parens[$i])) {\n            @groups = ($nest_level);\n\
    \        }\n    }\n    # Calculate max nest level\n    my $max_nest_level;\n \
    \   for (my $i = 0; $i < scalar @nested_parens; $i++) {\n        $max_nest_level\
    \ = max(@groups, @nested_parens[$i]);\n    }\n    return @nested_parens;\n}",
  "    # Initialize stack\n    my;\n    for(my $i = 0; $i < length($paren_string);\
    \ $i++) {\n        if ($paren_string[$i] eq '(') {\n            push, $i;\n  \
    \      } elsif ($paren_string[$i] eq ')') {\n            my $last_index = pop;\n\
    \            my $count_of_open_brackets_at_last_index = scalar(@paren_stack) -\
    \ 1;\n            if ($count_of_open_brackets_at_last_index >= $last_index) {\n\
    \                push, $i;\n            }\n        }\n    }\n    return @paren_stack;\n\
    }\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nThis looks great, but I run into\
    \ problems when I try to run it through perlbrew's perl. I'll try and work out\
    \ what it is.\n<|/ c |>\n<| c |>\nI updated the answer and added the test program\
    \ so you can run it yourself. Hope it helps.\n<|/ c |>\n<| c |>\nI added a solution\
    \ to the original question. I think I understand what you're doing, just not how\
    \ to incorporate it into the code.\n<|/ c |>\n<| c |>\nSorry I couldn't help with\
    \ perlbrew, I'm not a perl person. Hope someone else can shed some light on it\
    \ for you. Good luck!\n<|/ c |>\n<| c |>\nI'll let you know what happens. I might\
    \ have some more questions.\n<|/ c |>\n<| a tags=perl,regex |>\nThe only way to\
    \ do this with just one regex would be to count the open and close parentheses\
    \ as you go through the string. \nBut that would not be the best solution in terms\
    \ of performance, unless your input is always well formed. For example, consider\
    \ this input:\n<code>\n((()\n</code>\nThe open parentheses are not balanced at\
    \ all but you still want to parse it, so you don't want to count them. \nThis\
    \ is where you will need a state machine that keeps track of what parentheses\
    \ you are currently matching on and how many parentheses it is currently matching.\
    \ Then you just need a regex that matches the open parentheses and then looks\
    \ at the state machine to see how much is left in the parentheses to make sure\
    \ it matches. And then you need a regex that matches the close parentheses and\
    \ then looks at the state machine to see how many is left.\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is what I tried at first, but I'm not able to get the logic correct\
    \ and I wanted to see if anyone knew of a way to do it in one regex.\n<|/ c |>\n\
    <| a dscore=0 tags=perl,", "    my($nesting_level) = -1;\n    my $i;\n    my @groups\
    \ = split(/ /, $paren_string);\n    my %seen = ();", "    my @parens_counters;\n\
    \    my @parens_strings;\n    my $parens_string = \"\";", "    my(@results);\n\
    \    my %seen;\n    my($level);", "    my @paren_groups = split /\\s+/, $paren_string;\n\
    \    my @paren_levels = ();\n    my $max_level = 0;\n    my $current_level = 0;\n\
    \    foreach my $group (@paren_groups) {\n        next unless defined $group;\n\
    \        # $current_level should be zero for ((())\n        if ($current_level\
    \ == 0) {\n            $current_level = 1;\n        }\n        my $level = $current_level\
    \ + 1;\n        if ($group =~ /^\\((.*\\))/) {\n            $max_level = length($1);\n\
    \            $current_level = $level;\n        } elsif ($group =~ /^\\((.*\\))/)\
    \ {\n            $level = $current_level;\n        }\n        push (@paren_levels,\
    \ $level);\n    }\n    return @paren_levels;\n}\n</code>\n<|/ a tags=regex,perl,string\
    \ |>\n<| a |>\nHere's my answer, which gives the correct results without needing\
    \ to know anything about the nesting of the groups and without having to write\
    \ any regex.\n<code>\nuse strict;\nuse warnings;\nuse feature 'say';", "    my\
    \ @paren_levels = ();\n    my @parantheses_found;\n    my $level = 0;\n    my\
    \ $max_level = 0;\n    my $i;\n    my $opening_paren_level = 0;", "    my($level);\n\
    \    my($curr) = \"\";\n    my($open_paren_stack) = undef;\n    my(@result) =\
    \ ();\n    for (my $i = 0; $i <= $#$paren_string; $i++) {\n        my $c = $paren_string->[$i];\n\
    \        if ($c eq '(') {\n            $open_paren_stack++;\n        } elsif ($c\
    \ eq ')') {\n            $open_paren_stack--;\n        }", "    my;\n    my $paren_level\
    \ = 0;\n    my $prev_level = 0;\n    my $stack = 0;\n    my $len = length $paren_string;",
  "    my @paren_levels = ();\n    my @paren_groups = ();\n    my @max_level = ();\n\
    \    my $paren_group = 0;\n    my $paren_level = 0;", '    my(@parsed_paren_strings)
    = ();', "    my @paren_list;\n    my($current_level);\n    while(length > 1) {\n\
    \        $current_level = length $paren_string;\n        my @strings = split(\"\
    ( )\", $paren_string);\n        foreach my $string (@strings) {\n            if(!defined\
    \ $current_level) {\n                $current_level = $string->length();\n   \
    \         }\n            elsif($string->length() > $current_level) {\n       \
    \         $current_level = $string->length();\n            }\n        }\n    \
    \    $current_level--;\n        push(@paren_list, $current_level);\n        $paren_string\
    \ = substr($paren_string, $current_level+1);\n    }\n    return $paren_list[0];\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\nMy solution will be to count the number\
    \ of nested parentheses in the string and to compare it to the number of nested\
    \ parentheses in the string.\n<code>", "    my($num_levels) = 0;\n    my($curr_level,\
    \ $level, $last_level);\n    while($curr_level != $num_levels) {\n        $curr_level++;\n\
    \        $level = 0;\n        $last_level = 0;\n        while($level <= $curr_level)\
    \ {\n            $level++;\n            $last_level = $level;\n        }\n   \
    \     if($last_level != $curr_level) {\n            $num_levels++;\n        }\n\
    \    }\n    my @output;\n    foreach my $i (0 .. $num_levels) {\n        my($depth)\
    \ = 0;\n        foreach my $j (0 .. $num_levels - $i) {\n            $depth +=\
    \ $j;\n        }\n        push(@output, $depth);\n    }\n    return @output;\n\
    }", '    $paren_string = lc $paren_string;', "    my($open_p, $open_b) = ('(',')');\n\
    \    my($close_p, $close_b) = (')',')');\n    my(@results) = [];\n    $paren_string=~tr/\\\
    (//d;\n    $paren_string=~tr/\\)//d;\n    while($paren_string=~m/$open_p|$close_p/g)\
    \ {\n        $open_p =~ s/^$close_p//;\n        $open_p =~ s/^($|[()]+)//;\n \
    \       $open_p =~ s/$/$open_b/;\n        $close_p =~ s/^$open_p//;\n        $close_p\
    \ =~ s/^($|[()]+)//;\n        $close_p =~ s/$/$close_b/;\n        $results[] =\
    \ $paren_string =~ m/$open_p|$close_p/g;\n        $paren_string=~s/^$open_p|$close_p//;\n\
    \    }\n    return @results;\n}\n</code>\n<|/ a |>\n<| c |>\nOh, I didn't think\
    \ of just checking parenthesis level. Thank you for the idea.\n<|/ c |>\n<| a\
    \ |>\n<code>", "    my(@paren_groups);\n    my($parsing_group);\n    my(@group);\n\
    \    my(@paren_levels);\n    my($max_level);", "    my(@paren_groups);\n    while($paren_string\
    \ =~ m#\n        (?:\n            \\([^)]*\\)                  # Group of opening\
    \ and closing parentheses\n            |\n            \\(\n                [^)]*\
    \                    # Any character except closing parentheses\n            \
    \    (?: \\)? )*              # Repeat zero or more times, ending with a closed\
    \ parenthesis\n                \\)\n            )\n        )\n    {\n        push(@paren_groups,\
    \ ($+[0] > $+[1]) ? $+[1] : $+[0]);\n    }\n    return @paren_groups;\n}", " \
    \   my($max_level, @levels) = ();\n    my($new_string);", "    my;\n    foreach\
    \ my $index (split (\" \", $paren_string)) {\n        my $paren_stack = 0;\n \
    \       my $num_parens = 0;\n        my $open_paren = 0;\n        while (length($index))\
    \ {\n            if (substr($index, 0, 1) eq \"(\") {\n                $open_paren++;\n\
    \            } elsif (substr($index, 0, 1) eq \")\") {\n                $open_paren--;\n\
    \            } elsif (substr($index, 0, 1) eq \"(\") {\n                $paren_stack++;\n\
    \            } elsif (substr($index, 0, 1) eq \")\") {\n                $paren_stack--;\n\
    \            } elsif ($open_paren > 0) {\n                push, $num_parens if\
    \ $num_parens != 0;\n                $num_parens++;\n            } elsif ($paren_stack\
    \ > 0) {\n                push, $num_parens if $num_parens != 0;\n           \
    \     $num_parens++;\n            } elsif ($num_parens == 0) {\n             \
    \   push, $index if $num_parens != 0;\n                $num_parens++;\n      \
    \      }\n            $index = substr($index, 1);\n        }\n        push, $num_parens\
    \ if $num_parens != 0;\n    }\n    return @nesting;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nI didn't want to include a full script that would have to be maintained,\
    \ so I developed a recursive solution here.\nIt's a lot of code, so I'm not going\
    \ to put it all here, but this is the essence of it:\n<code>", "    my(@paren_levels);\n\
    \    my($paren_counter);\n    my($max_level);\n    my($level);\n    my($nesting_level);",
  "    my @paren_array;\n    # Traverse the string from left to right.\n    my $nest\
    \ = 0;\n    my $opening_paren_char = \"()\";\n    my $opening_paren_char_count\
    \ = 0;\n    my $paren_char_count = 0;\n    while ($paren_char_count++ < length\
    \ $paren_string) {\n        # Find the opening paren character. Increment the\
    \ count and find the next one.\n        if ($paren_string[$paren_char_count] eq\
    \ $opening_paren_char) {\n            $paren_char_count++;\n            $nest++;\n\
    \        } elsif ($paren_string[$paren_char_count] eq $opening_paren_char) {\n\
    \            $paren_char_count++;\n            $opening_paren_char_count++;\n\
    \        } elsif ($paren_string[$paren_char_count] eq '(') {\n            # Found\
    \ the closing paren char. Check if this is the last nested level and store that\
    \ as the max nesting level.\n            if ($nest == 0) {\n                push\
    \ @paren_array, $opening_paren_char_count;\n                $nest++;\n       \
    \         $opening_paren_char_count = 0;\n            } else {\n             \
    \   push @paren_array, $opening_paren_char_count;\n                $opening_paren_char_count\
    \ = 0;\n            }\n        } else {\n            # Find the next char.\n \
    \           $paren_string[$paren_char_count];\n        }\n    }\n    return @paren_array;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. It works like a charm.\
    \ But, there is a problem. If you input a string like \"(()) ()((()))\", you will\
    \ get an array with only one number \"3\" instead of an array of 3 numbers.\n\
    <|/ c |>\n<| c |>\nThe output array should be three numbers: 0, 3, 3. Are you\
    \ sure you are not getting the same result? I have tested the input string \"\
    (()) ()((()))\" with your script and my output array is also \"0, 3, 3\".\n<|/\
    \ c |>\n<| c |>\nIt was my mistake. There was a typo in my code. Sorry about that.\
    \ Now it is working. Thanks for your answer!\n<|/ c |>\n<| a |>\nThis is my solution:\n\
    <code>", "    my(@paren_groups);\n    my(@max_levels);\n    my($nested_level);",
  "    my @stack = ();\n    my($open, $close) = (-1, -1);\n    my $depth = 0;\n  \
    \  for (my $i = 0, $count = $paren_string->length(); $i < $count; $i++) {\n  \
    \      my $char = $paren_string->[$i];\n        if ($char == $open) {\n      \
    \      push (@stack, $depth);\n            $open = $close = $char;\n        }\n\
    \        elsif ($char == $close) {\n            my $level = pop @stack;\n    \
    \        if (@stack) {\n                ++$depth;\n            }\n           \
    \ else {\n                $depth = $level;\n            }\n            $open =\
    \ $close = -1;\n        }\n    }\n    return $depth;\n}", "    my @paren_levels;\n\
    \    my $paren_level = 0;\n    my $prev_paren_level = 0;", "    my(@paren_levels)\
    \ = ();\n    my $paren_level = 0;\n    for(split(\" \", $paren_string)){\n   \
    \     if (index($_, '(') > -1) {\n            $paren_level = $paren_level + 1;\n\
    \        }\n        elsif (index($_, '(') == -1){\n            $paren_level =\
    \ $paren_level - 1;\n        }\n        if ($paren_level > 0) {\n            push(@paren_levels,\
    \ $paren_level);\n        }\n    }\n    for(@paren_levels) {\n        if ($paren_level\
    \ == 0) {\n            last;\n        }\n    }\n    return @paren_levels;\n}",
  '    my($opening_paren, @paren_levels) = ();', "    my @paren_groups = ();\n   \
    \ my %paren_levels;\n    my($max_level);\n    my $i;\n    for(my $i = 0; $i <=\
    \ length($paren_string); $i++) {\n        my $current_char = substr($paren_string,\
    \ $i, 1);\n        my $current_level_chars = 0;\n        my $current_level_char\
    \ = 0;\n        my $current_level = 0;\n        if($current_char =~ /^([(])/)\
    \ {\n            push @paren_groups, \"$1\";\n        }\n        if($current_char\
    \ =~ /^(\\()/) {\n            $current_level_chars = $1;\n        }\n        if($current_char\
    \ =~ /^(\\))/) {\n            $current_level_char = $1;\n        }\n        if($current_level_chars)\
    \ {\n            $current_level++;\n        }\n        if($current_level_char)\
    \ {\n            $current_level--;\n        }\n        if($current_level > $max_level)\
    \ {\n            $max_level = $current_level;\n        }\n        if($current_level_chars\
    \ > $max_level_chars) {\n            $max_level_chars = $current_level_chars;\n\
    \        }\n    }\n    $max_level = $max_level+1 if($max_level < 0);\n    $max_level_chars\
    \ = $max_level_chars-1;\n    my $output_size = @paren_groups;\n    for(my $i =\
    \ 0; $i < $output_size; $i++) {\n        my $level_num = length($paren_groups[$i]);\n\
    \        my $level_char_num = length($paren_groups[$i])-1;\n        my $output_char\
    \ = substr($paren_string, $i, 1);\n        my $last_char = substr($paren_string,\
    \ $i, -1);\n        if($level_num > 0) {\n            $paren_levels{$level_num}\
    \ = $level_char_num;\n        }\n        elsif($level_char_num > 0) {\n      \
    \      $paren_levels{$level_char_num} = $level_num;\n        }\n    }\n    my\
    \ $output_string = \"\";\n    for(my $i = 0; $i <= length($paren_string); $i++)\
    \ {\n        my $current_char = substr($paren_string, $i, 1);\n        my $current_level;\n\
    \        if(defined($paren_levels{$i})) {\n            $current_level = $paren_levels{$i};\n\
    \        }\n        elsif($current_char =~ /^[)]/) {\n            $current_level\
    \ = $max_level;\n        }\n        elsif($current_char =~ /^[\\)]/) {\n     \
    \       $current_level = $max_level_chars;\n        }\n        else {\n      \
    \      $current_level = 0;\n        }\n        my $paren_group = \"\";\n     \
    \   for(my $j = 0; $j <= $", "    my(@paren_levels);\n    my($paren_level_count);\n\
    \    my $paren_level = 0;\n    my @paren_level_array;\n    my $paren_level_str\
    \ = '';\n    my $paren_count = 0;", "    my($i) = 0;\n    my($nested_paren_level);\n\
    \    my(@nested_paren_groups);\n    my($paren_opened_level);\n    my($paren_closed_level);\n\
    \    my(@nested_paren_groups) = ();\n    \n    while ($i < length($paren_string))\
    \ {\n        if (substr($paren_string, $i, 1) eq \")\") {\n            $paren_closed_level\
    \ = $i;\n            \n            if ($paren_opened_level != 0) {\n         \
    \       push(@nested_paren_groups, $paren_opened_level);\n            }\n    \
    \        \n            my $max_level = 0;\n            foreach my $open_level\
    \ (@nested_paren_groups) {\n                if ($open_level gt $max_level) {\n\
    \                    $max_level = $open_level;\n                }\n          \
    \  }\n            \n            $max_level += 1;\n            \n            if\
    \ ($max_level gt @nested_paren_groups) {\n                die \"The given string\
    \ has too many nested parentheses\";\n            }\n            \n          \
    \  push(@nested_paren_groups, $max_level);\n            \n            $nested_paren_level\
    \ = $max_level;\n            $nested_paren_groups[$nested_paren_level] = [];\n\
    \            \n            $nested_paren_opened_level = $max_level;\n        \
    \    \n            $i += 1;\n            \n        } elsif (substr($paren_string,\
    \ $i, 1) eq \"(\") {\n            $paren_opened_level = $i;\n            $nested_paren_groups[$nested_paren_opened_level][]\
    \ = $paren_opened_level;\n            \n            $nested_paren_level = $nested_paren_opened_level;\n\
    \            $nested_paren_groups[$nested_paren_level] = [];\n            \n \
    \           $i += 1;\n        }\n        \n        $i += 1;\n    }\n    \n   \
    \ my $max_level = 0;\n    foreach my $level (@nested_paren_groups) {\n       \
    \ if ($level gt $max_level) {\n            $max_level = $level;\n        }\n \
    \   }\n    \n    return $max_level;\n}", "    my(@parsed_list);\n    my($depth)\
    \ = 0;\n    foreach my $par (split ' ', $paren_string) {\n        if ($par =~\
    \ s/^\\s+//) {\n            push(@parsed_list, $depth);\n            $depth++;\n\
    \        }\n        elsif ($par =~ s/^\\(//) {\n            push(@parsed_list,\
    \ $depth);\n        }\n        elsif ($par =~ s/\\)$//) {\n            my $last\
    \ = pop(@parsed_list);\n            if ($last < $depth) {\n                last;\n\
    \            }\n            else {\n                $depth = $last;\n        \
    \    }\n        }\n        else {\n            last;\n        }\n    }\n    push(@parsed_list,\
    \ $depth);\n    @parsed_list;\n}", "    my(@parens);\n    my($level);\n    my($levels);\n\
    \    my($levels_seen);\n    my($open_paren_count);\n    my($open_paren_stack);\n\
    \    my($max_level);", "    my($stack) = 0;\n    my($depth) = 0;\n    my(@levels);",
  "    my (@levels);\n    my $level = 0;\n    my $inparen = 0;\n    for (my $i = 0;\
    \ $i <= length($paren_string) - 1; $i++) {\n        if ($paren_string[$i] == \"\
    )\") {\n            if ($inparen) {\n                $level -= 1;\n          \
    \  }\n        }\n        if ($paren_string[$i] == \"(\") {\n            if ($inparen\
    \ == 0) {\n                $level += 1;\n            }\n        }\n        if\
    \ ($paren_string[$i] == \" \") {\n            $inparen = 1;\n        }\n     \
    \   if ($paren_string[$i] == \")\") {\n            $inparen = 0;\n        }\n\
    \        elsif ($paren_string[$i] == \"(\") {\n            $inparen = 1;\n   \
    \     }\n        elsif ($paren_string[$i] == \" \") {\n            $inparen =\
    \ 0;\n        }\n        elsif ($inparen) {\n            $level += 1;\n      \
    \  }\n    }\n    push(@levels, $level);\n    return @levels;\n}\n</code>\n<|/\
    \ a dscore=3 tags=algorithm,perl,regex,python |>\n<| a tags=algorithm,perl,regex,python\
    \ |>\nI wrote a parser for the grammar given by S. Lott's \"The Dragon Book\"\
    .  It's written in Python and will probably be easier to understand than anything\
    \ else I can think of.  It parses exactly that grammar.\n(Full disclosure, I'm\
    \ a co-author of this book)\nhttp://oreilly.com/catalog/errata.csp?isbn=0636920044221\n\
    <code>\nimport re\nimport pdb", "    my;\n    # Step 1. Parse all the groups and\
    \ store in stack.\n    while($paren_string =~ /([^\\s()]|(?<!\\s))((\\(\\))?(\\\
    s?\\(\\))?)*(?!\\s)/sg) {\n        push(@stack, $2);\n    }", '    my ($index,
    $level, $level_max, $levels, $last_level, $parens, $nesting) = @_;', '    my(@levels);',
  "    my($nested_paren_count, $max_nested_paren_count);\n    my($open_paren_count,\
    \ $max_open_paren_count);\n    my(@nested_paren_group) = ();\n    my(@open_paren_group)\
    \ = ();\n    my(@max_nested_paren_level) = ();\n    my(@max_open_paren_level)\
    \ = ();", "    my(@levels);\n    my($level);\n    my(@level);", "    my(@depths)\
    \ = ();\n    my(@levels) = ();\n    my($max_level);\n    my($opening_paren_loc);\n\
    \    my($curr_level);\n    my($opening_paren_count);\n    my($open_paren_loc);\n\
    \    my($num_parens);\n    my($cur_loc);", "    $paren_string =~ s/(\\(|\\))//g;\n\
    \    my(@paren_groups) = split(/ \\)\\s?/, $paren_string);\n    my($current_level)\
    \ = -1;\n    for(my $i = 0; $i < @paren_groups; $i++) {\n        if ($paren_groups[$i]\
    \ eq '(') {\n            if ($current_level == -1) {\n                $current_level\
    \ = $i + 1;\n            } else {\n                if ($current_level < $i + 1)\
    \ {\n                    $current_level = $i + 1;\n                }\n       \
    \     }\n        }\n    }\n    return $current_level;\n}", '    my($max_level)
    = -1;', "    my($level);\n    my($max_nesting);", "    my (@level_of_nestings)\
    \ = (0);\n    while (1) {\n        if ($paren_string = qr{[^()]*}g) {\n      \
    \      if ($paren_string eq '(') {\n                push(@level_of_nestings, 1);\n\
    \            }\n            elsif ($paren_string eq ')') {\n                push(@level_of_nestings,\
    \ pop(@level_of_nestings));\n            }\n            else {\n             \
    \   push(@level_of_nestings, scalar(@level_of_nestings)+1);\n            }\n \
    \       }\n        else {\n            last;\n        }\n    }\n    return @level_of_nestings;\n\
    }", "    my($depth);\n    my($levels);\n    my(@groups);\n    \n    $depth = 0;\n\
    \    $levels = 0;\n    \n    while(1) {\n        if ($paren_string = substr($paren_string,\
    \ index($paren_string, \" \")+1)){\n            @groups = split(/ /, $paren_string);\n\
    \            $levels = $groups[0];\n            $paren_string = join(\" \", @groups);\n\
    \        }\n        elsif ($paren_string = substr($paren_string, 0, index($paren_string,\
    \ \"(\"))+1) {\n            $paren_string = substr($paren_string, index($paren_string,\
    \ \"(\")+1);\n            $levels++;\n            $depth++;\n        }\n     \
    \   elsif ($paren_string = substr($paren_string, 0, index($paren_string, \")\"\
    ))+1) {\n            $paren_string = substr($paren_string, index($paren_string,\
    \ \")\")+1);\n            $depth--;\n        }\n        else {\n            return\
    \ $levels;\n        }\n    }\n}\n</cell>\n<text>\n2. Palindrome Substrings\nFind\
    \ all palindromic substrings of an input string.", "    my @level = 0;\n    my\
    \ @group_level;\n    my(@level_stack) = ();\n    my($in_nested_paren) = ();\n\
    \    my($nested_paren_level) = ();\n    my $last_group;", "    my $paren_nesting\
    \ = -1;\n    my @paren_level;\n    my @paren_list;\n    my $open_bracket;\n  \
    \  for (my $i = 0; $i < length($paren_string); $i++) {\n        $open_bracket\
    \ = 0;\n        my $cp = ord(substr($paren_string, $i, 1));\n        if ($cp >=\
    \ 33 && $cp <= 126) {\n            $open_bracket = 1;\n        }\n        elsif\
    \ ($cp >= 41 && $cp <= 42) {\n            $open_bracket = 2;\n        }\n    \
    \    elsif ($cp >= 43 && $cp <= 45) {\n            $open_bracket = 3;\n      \
    \  }\n        elsif ($cp >= 46 && $cp <= 47) {\n            $open_bracket = 4;\n\
    \        }\n        elsif ($cp >= 58 && $cp <= 59) {\n            $open_bracket\
    \ = 5;\n        }\n        elsif ($cp >= 60 && $cp <= 62) {\n            $open_bracket\
    \ = 6;\n        }\n        elsif ($cp >= 91 && $cp <= 92) {\n            $open_bracket\
    \ = 7;\n        }\n        elsif ($cp >= 93 && $cp <= 94) {\n            $open_bracket\
    \ = 8;\n        }\n        elsif ($cp >= 123 && $cp <= 126) {\n            $open_bracket\
    \ = 9;\n        }\n        elsif ($cp >= 127 && $cp <= 255) {\n            $open_bracket\
    \ = 10;\n        }\n        if ($open_bracket >= 0) {\n            push @paren_list,\
    \ $open_bracket;\n            if ($open_bracket == 1) {\n                $paren_nesting++;\n\
    \                push @paren_level, $paren_nesting;\n            }\n        }\n\
    \    }\n    if (@paren_level) {\n        my $max_nesting = 0;\n        for (my\
    \ $i = 0; $i < @paren_level; $i++) {\n            $max_nesting = max($max_nesting,\
    \ @paren_level[$i]);\n        }\n        push @paren_list, $max_nesting;\n   \
    \ }\n    elsif (@paren_list == 1) {\n        push @paren_list, $paren_string;\n\
    \    }\n    return @paren_list;\n}", "    my(@paren_list) = ();\n    my($cur_level,\
    \ $max_level);\n    foreach my $char (split(//, $paren_string)) {\n        push\
    \ (@paren_list, $char);\n    }\n    my $first_char = shift(@paren_list);\n   \
    \ my $is_first_char_in_group = ($first_char == $paren_string);\n    foreach my\
    \ $char (@paren_list) {\n        if ($char != $first_char) {\n            push\
    \ (@paren_list, $char);\n        }\n    }\n    foreach my $char (@paren_list)\
    \ {\n        $cur_level = 0;\n        while ($char != $paren_string) {\n     \
    \       if ($paren_string[$cur_level] eq '(') {\n                $cur_level++;\n\
    \                if ($cur_level > $max_level) {\n                    $max_level\
    \ = $cur_level;\n                }\n            } elsif ($paren_string[$cur_level]\
    \ eq ')') {\n                $cur_level--;\n            }\n            $char =\
    \ $paren_string[$cur_level];\n        }\n    }\n    return @paren_list;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nUsing recursion:\n<code>", "    my(@paren_groups)\
    \ = ();\n    my($paren_group_lengths) = ();\n    my @paren_nestings;\n    my $current_depth\
    \ = 0;\n    my $nested_level = 0;\n    my $nested_nesting = 0;", '    my(@levels,
    $i, $j, $paren_level, $max_level);', "    my($number_of_open_brackets_stack) =\
    \ @_;\n    my(@result) = [];\n    my(@open_brackets) = [];", "    my($nesting);\n\
    \    my($deepest_level);\n    \n    foreach my $char (split(\" \", $paren_string))\
    \ {\n        if ($char=~m/\\(([^()]*)\\)/) {\n            my $subparens = $1;\n\
    \            chomp($subparens);\n            my($sub_nesting) = $nesting + $subparens;\n\
    \            if ($sub_nesting > $deepest_level) {\n                $deepest_level\
    \ = $sub_nesting;\n            }\n        }\n        else {\n            chomp($char);\n\
    \            $nesting += $char;\n        }\n    }", "    my(@parsed_paren_level);\n\
    \    my($paren_level);\n    my($curr_level);\n    my(@curr_levels);\n    my($curr_level_str);\n\
    \    my($curr_level_num);", "    my(@results);\n    my $depth = 0;\n    my $open\
    \ = 1;\n    my $i = 1;\n    my $prev_open = 0;\n    while($i < length($paren_string))\
    \ {\n        my $c = substr($paren_string, $i, 1);\n        if($c eq '(') {\n\
    \            push, $depth;\n            $prev_open = $open;\n        }\n     \
    \   elsif($c eq ')') {\n            if($prev_open && $open) {\n              \
    \  push, $depth;\n                $prev_open = $open;\n            }\n       \
    \ }\n        elsif($c eq '(') {\n            $open++;\n        }\n        elsif($c\
    \ eq ')') {\n            $open--;\n        }\n        $i++;\n    }\n    return\
    \ @results;\n}", "    my(@nested_parens) = 0;\n    my($paren_level);\n    my($paren_level_in_tree);\n\
    \    my($level);", '    my(@depths);', "    my;\n    my($stack) = ['']; # Stack\
    \ of parentheses levels\n    $stack[-1] .= $paren_string;\n    # Traverse string\
    \ from right to left\n    while ($stack[-1]) {\n        $stack[-1] .= $paren_string;\n\
    \        # Pop top element from stack if it's empty and add it to result set\n\
    \        if ($stack[-1] eq '') {\n            push(@nest, pop(@stack));\n    \
    \    }\n        else {\n            if (substr($stack[-1], -1) eq '(') {\n   \
    \             # ( is right to left enclosed parenthesis\n                push(@stack,\
    \ $stack[-1]);\n            }\n            else {\n                # )\n     \
    \           my $nested_level = pop(@stack);\n                push(@nest, \"$nested_level$paren_string\"\
    );\n            }\n        }\n    }\n    return @nest;\n}", "    my $paren_count\
    \ = 0;\n    my @paren_levels;\n    my @parens = ();\n    foreach my $c (split\
    \ //, $paren_string) {\n        my @temp = parse_parens($c);\n        foreach\
    \ my $t (@temp) {\n            $paren_levels[$paren_count] = $t;\n        }\n\
    \        $paren_count += 1;\n    }\n    @parens = @paren_levels;\n    return @parens;\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`@parens` is a reference to an array with one element,\
    \ `@paren_levels` is a reference to an array with 2 elements, `@temp` is an empty\
    \ array, `@temp` does not appear to be used anywhere else either.\n<|/ c |>\n\
    <| c |>\nI fixed some of my other errors and made an edit to the original post\
    \ with my full code.\n<|/ c |>\n<| c |>\n, I know this wasn't your final question.\
    \  But the error in your code was that you assigned a value to `@parens` and `@paren_levels`\
    \ after you defined them.  So the assignment happened first, and thus it was the\
    \ only thing that got assigned.  I moved `@parens = ();` and `@paren_levels =\
    \ ();` to the top of your `parse_nested_parens` subroutine, before you declare\
    \ `@parens` and `@paren_levels`.\n<|/ c |>\n<| c |>\n, I edited my answer to fix\
    \ the other errors.\n<|/ c |>\n<| a dscore=0 |>\nThis question looks like homework,\
    \ so I'm not going to give the complete answer, but here's a hint: if you know\
    \ that the string should always start and end with parentheses, you can use the\
    \ substring function to get the first and last paren.\n<|/ a tags=perl,nested,regex\
    \ |>\n<| c |>\nNo, it's not a homework problem. I'm simply trying to solve a problem\
    \ from a website that I'm trying to use to practice coding and learn more about\
    \ perl.\n<|/ c |>\n<| c |>\nIf it's not homework, and you're just trying to practice\
    \ coding, then you should learn about perl's substring function and how to apply\
    \ it to your problem.  It's pretty simple once you get used to it.\n<|/ c |>\n\
    <| c |>\nI know, I'm just not asking you to give the complete answer. I was just\
    \ asking if there was a more efficient way than what I'm currently doing.\n<|/\
    \ c |>\n<| c |>\n: If you don't know enough about perl's substring function, it's\
    \ hard to guess how to help you.  Just because ", "    my @paren_levels;\n   \
    \ my($depth) = 0;\n    for my $i (0 .. length($paren_string) - 1) {\n        $paren_levels[$i]\
    \ = 0;\n        if ($paren_string[$i] eq '(') {\n            $depth++;\n     \
    \   }\n        if ($paren_string[$i] eq ')') {\n            $depth--;\n      \
    \  }\n        $paren_levels[$i] = $depth;\n    }", "    $paren_string =~ s{ \\\
    ((?: [^()]+ | \\g<0> ) *\\)} { $+[0]; $+[0] } gx;\n    my(@paren_level) = split(\"\
    \ \",$paren_string);\n    my($max_level) = -1;\n    foreach my $level (@paren_level)\
    \ {\n        my($next_level) = pop(@paren_level);\n        if ($level > $max_level)\
    \ {\n            $max_level = $level;\n        }\n        if ($next_level > $max_level)\
    \ {\n            $max_level = $next_level;\n        }\n    }\n    return $max_level;\n\
    }", "    my(@paren_groups) = ();\n    my(@paren_group_sizes) = ();\n    my(@paren_group_counts)\
    \ = ();\n    my($max_paren_group_size);\n    my($max_paren_group_count);\n   \
    \ \n    foreach my $paren_group (split(/ /, $paren_string)) {\n        my @paren_group_components\
    \ = ();\n        my @paren_group_components_paren_count = ();\n        foreach\
    \ my $component (split(/\\)$/, $paren_group)) {\n            if ($component =~\
    \ /^\\((?!$)/) {\n                my $paren_count = length($component) - 1;\n\
    \                push(@paren_group_components, $component);\n                push(@paren_group_components_paren_count,\
    \ $paren_count);\n            } else {\n                push(@paren_group_components,\
    \ $component);\n            }\n        }", "    my(@max_depth,@max_nesting_level);\n\
    \    my($max);\n    my $pos = 0;\n    my $stack = 0;\n    my $level = 0;\n   \
    \ my @nesting_levels;\n    my %paren_chars = ();\n    my @paren_chars_list = ();\n\
    \    my %parens = ();\n    while(1) {\n        my $char_pos = index($paren_string,\
    \ $paren_chars->{'('},$pos);\n        die \"Invalid parens string $paren_string\"\
    \ unless defined $char_pos;\n        if($char_pos == -1 || $char_pos == $paren_string->length())\
    \ {\n            die \"Unterminated parens string $paren_string\" unless defined\
    \ $paren_string->length();\n            warn \"Unterminated parens string $paren_string\\\
    n\" if $^W;\n            return ();\n        }\n        $pos = $char_pos+1;",
  "    my($level);\n    my($curr_paren_char);\n    my($curr_level_chars);\n    my($max_level_found);\n\
    \    my(@levels);\n    my($next_level_found);\n    my(@chars_to_remove);\n   \
    \ my(@parens_to_remove);\n    my(@paren_chars);\n    my(@paren_levels);\n    my($max_level_found);\n\
    \    my($first_paren_char);\n    my($last_paren_char);", "    my(@paren_depths);\n\
    \    my($paren_open, $paren_close, $depth) = (0, 0);\n    my($open_paren_char,\
    \ $close_paren_char, @nesting_depths);\n    \n    while (my $char = substr $paren_string,\
    \ 0, 1) {\n        next if $char eq '(';\n        next if $char eq ')';\n    \
    \    next if $char eq '[';\n        next if $char eq ']';\n        next if $char\
    \ eq '{';\n        next if $char eq '}';\n        next if $char eq '|';\n    \
    \    next if $char eq ':';\n        next if $char eq '@';\n        next if $char\
    \ eq '/';\n        next if $char eq '&';\n        next if $char eq '^';\n    \
    \    next if $char eq '=';\n        next if $char eq '<';\n        next if $char\
    \ eq '>';\n        next if $char eq '?';\n        next if $char eq '%';\n    \
    \    next if $char eq '!';\n        next if $char eq '$';\n        next if $char\
    \ eq '~';\n        next if $char eq '`';\n        next if $char eq '+';\n    \
    \    next if $char eq '*';\n        next if $char eq '%';\n        next if $char\
    \ eq '&';\n        next if $char eq '|';\n        next if $char eq '}';\n    \
    \    next if $char eq '{';\n        next if $char eq '[';\n        next if $char\
    \ eq ']';\n        next if $char eq '/';\n        next if $char eq '@';\n    \
    \    next if $char eq '=';\n        next if $char eq '<';\n        next if $char\
    \ eq '>';\n        next if $char eq '?';\n        next if $char eq '%';\n    \
    \    next if $char eq '!';\n        next if $char eq '$';\n        next if $char\
    \ eq '`';\n        next if $char eq '+';\n        next if $char eq '*';\n    \
    \    next if $char eq '%';\n        next if $char eq '&';\n        next if $char\
    \ eq '|';\n        next if $char eq '^';", "    my @paren_groups = $paren_string=~/^\\\
    ((.*)\\)/g;\n    my @levels_of_paren_nesting = ();", "    my @paren_group = ();\n\
    \    my (@nested_level, @max_level);\n    \n    my $depth = 1;\n    for (my $i\
    \ = 0; $i < length($paren_string); $i++) {\n        my $c = substr($paren_string,\
    \ $i, 1);\n        if ($c eq '(') {\n            push(@paren_group, $depth);\n\
    \            $depth++;\n        } elsif ($c eq ')') {\n            $depth--;\n\
    \        }\n        \n        if ($depth == 0) {\n            @nested_level[$i..($i\
    \ + 1)] = @paren_group;\n            if (@max_level == @nested_level) {\n    \
    \            @max_level = @nested_level;\n            }\n        }\n    }\n  \
    \  return @nested_level;\n}\n</code>\n<|/ a tags=regex,recursion,parsing,perl\
    \ |>\n<| c |>\nThis approach works on simple parenthetical expressions, but fails\
    \ on more complex expressions. For example, `(())` returns `0` when it should\
    \ return `2`.\n<|/ c |>\n<| c |>\nThanks for catching this; I've corrected my\
    \ example. Can you give it another look?\n<|/ c |>\n<| c |>\nI ran this through\
    \ my debugger and noticed it only fails on the second group. Can you explain what\
    \ it is doing?\n<|/ c |>\n<| c |>\nIt works on your example and on mine, so I'm\
    \ afraid I can't offer a deeper insight. Here's what I'm seeing: `$depth` is initialized\
    \ to `1`; the first `(` gets matched and `$depth` increases to `2`; the second\
    \ `(` gets matched and `$depth` decreases to `1`. Then it goes back to the first\
    \ `(` when it tries to match `(` again, which fails, so nothing gets pushed onto\
    \ `@paren_group`. Then the third `(` gets matched and `$depth` goes down to `0`,\
    \ and the final `(` gets matched and `$depth` goes down to `0`, etc. Hope that\
    \ makes sense.\n<|/ c |>\n<| c |>\nThanks for your explanation. I think I will\
    \ keep trying to adapt your logic to suit my needs.\n<|/ c |>\n<| a |>\nHere is\
    \ a regex that would capture the deepest level of nesting, based on a similar\
    \ question I answered here on SO: \n<code>\nmy $re = qr{\n               \\(\n\
    \                   (?: [^()]+ \n                     | \n                   \
    \    (?&nested) \n                     )*\n                   (?::(?!\\())\n \
    \                  (?", "    my(@levels) = ();\n    my($paren_depth);\n    my($last_open)\
    \ = undef;\n    my($level);\n    for(my $i = 0; $i < length($paren_string); ++$i)\
    \ {\n        my $curr = substr($paren_string, $i, 1);\n        my $open_count\
    \ = () = $paren_depth{$curr} //= 0;\n        $level = $levels[$open_count] //=\
    \ 0;\n        $levels[$open_count] = $level + 1 if ($open_count > $level);\n \
    \       my $new_level = $levels[$open_count];\n        if ($last_open && $new_level\
    \ > $level) {\n            push (@levels, $new_level);\n        }\n        if\
    \ ($curr != $last_open) {\n            if ($open_count > $level) {\n         \
    \       push(@levels, $open_count);\n            }\n            else {\n     \
    \           $levels[$open_count] = $new_level;\n            }\n        }\n   \
    \     $last_open = $curr;\n    }\n    return @levels;\n}\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,regex,language-agnostic |>\n<code>\npublic int maxParenthaLevels(String\
    \ s) {\n        String[] tokens = s.split(\" \");\n        HashMap<Character,\
    \ Integer> map = new HashMap<>();\n        for (int i = 0; i < tokens.length;\
    \ ++i) {\n            int pos = s.indexOf(tokens[i]);\n            if (pos !=\
    \ -1) {\n                int level = 0;\n                while (pos > 0 && pos\
    \ < s.length()) {\n                    char ch = s.charAt(pos);\n            \
    \        if (map.containsKey(ch)) {\n                        int prevLevel = map.get(ch);\n\
    \                        if (prevLevel > level) {\n                          \
    \  level = prevLevel;\n                        }\n                    }\n    \
    \                map.put(ch, ++level);\n                    pos = pos + tokens[i].length();\n\
    \                }\n                if (level > 0) {\n                    return\
    \ level;\n                }\n            }\n        }\n        return 0;\n   \
    \ }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nMy solution, based mostly on\
    \ regex and Java 8 features:\n<code>\npublic static int maxParenthaLevels(String\
    \ s) {\n    String[] tokens = s.split(\" \");\n    Stream<String> streamTokens\
    \ = Arrays.stream(tokens);\n    final Pattern pattern = Pattern.compile(\"\\\\\
    p{Punct}\");\n    final Matcher matcher = pattern.matcher(\"\");\n    Map<Character,\
    \ Integer> parenthaMap = new HashMap<>();\n    IntSummaryStatistics summary =\
    \ IntStream.range(0, tokens.length)\n            .filter(i -> matcher.reset(tokens[i]).find())",
  "    $paren_string = \"\" if $paren_string eq \"\";\n    my($level, $current_depth);\n\
    \    my @paren_groups = parse_paren_groups($paren_string);", "    my@levels =\
    \ ();\n    my@level;", "    my($max_level);\n    my($open_count, $closed_count);",
  "    # Remove trailing whitespaces.\n    $paren_string =~ s/\\s+$//;\n    # Iterate\
    \ through the groups of parenthesis.\n    my @paren_groups = split /\\s+/, $paren_string;\n\
    \    my @max_level;\n    foreach my $group (@paren_groups) {\n        # Iterate\
    \ through each group of parenthesis in the string.\n        my @groups = split\
    \ /\\s+/, $group;\n        # Iterate through each level of nesting in the group.\n\
    \        foreach my $group_level (@groups) {\n            # Initialize max_level\
    \ to be the deepest level of nesting.\n            push(@max_level, 0);\n    \
    \        # Check if the max_level is incremented.\n            foreach my $level\
    \ (@max_level) {\n                # If max_level is already greater than the level\
    \ of nesting, increase it.\n                if($level >= $group_level) {\n   \
    \                 $max_level[$level] = $level + 1;\n                    last;\n\
    \                }\n            }\n        }\n    }\n    return @max_level;\n}",
  "    my @level;\n    my (@result,$paren_count);\n    $paren_count = 0;\n    while($paren_string\
    \ =~ /((.)*(.)*)/sg) {\n        $paren_count += $2;\n        push @level, $1;\n\
    \    }\n    push @result, @level;\n    return @result;\n}", "    $paren_string\
    \ =~ s/^\\s*\\(\\s*//;\n    $paren_string =~ s/\\s*\\)\\s*$//;", "    my @parens_level;\n\
    \    my @parens_level_count = ();\n    my @parens_level_parens = ();\n    my @parens_level_unbalanced_parens\
    \ = ();\n    my @parens_level_unbalanced_parens_lengths = ();\n    my @parens_level_unbalanced_parens_lengths_sum\
    \ = 0;", "    my(@levels) = ();\n    foreach my $level (split /\\s+/, $paren_string)\
    \ {\n        push @levels, $level unless $level =~ /^\\)$/;\n        push @levels,\
    \ $level unless $level =~ /^\\(/;\n    }\n    return @levels;\n}", '    my(@paren_stack)
    = ();', "    my @paren_array = ();\n    my($nesting_level, $current_level, $current_parens,\
    \ $current_string) = \"\";", "    $paren_string =~ s/\\s*\\(\\s*\\)\\s*\\)\\s*\\\
    )//;\n    my = split(/\\s+/, $paren_string);\n    my $max_nesting_level = -1;\n\
    \    my $cur_nesting_level = 0;\n    my @depths;\n    my @levels;\n    my $cur_depth\
    \ = 0;\n    my $cur_level = 0;\n    foreach my $paren_group (@paren_groups) {\n\
    \        my($group, $paren_level) = $paren_group =~ m/^\\s*([^\\(\\)]+)(\\s*\\\
    ()?\\s*(\\d+)?\\s*\\)\\s*$/;\n        $group = $1 if (!defined($group));\n   \
    \     if ($2) {\n            $paren_level = $2;\n        } else {\n          \
    \  $paren_level = 0;\n        }\n        if ($paren_level > $max_nesting_level)\
    \ {\n            $max_nesting_level = $paren_level;\n        }\n        push(@depths,\
    \ $cur_depth);\n        push(@levels, $cur_level);\n        $cur_depth++;\n  \
    \      $cur_level++;\n        $cur_level++ if ($cur_level > $max_nesting_level);\n\
    \    }\n    push(@depths, $cur_depth);\n    push(@levels, $cur_level);\n    my\
    \ $depth = @depths;\n    my $level = @levels;\n    my $cur_deepest_level = $max_nesting_level;\n\
    \    my $current_level = 0;\n    my @paren_levels;\n    while (@depths) {\n  \
    \      my $prev_level = pop(@levels);\n        my $prev_depth = pop(@depths);\n\
    \        if ($prev_depth > $cur_deepest_level) {\n            while (@levels)\
    \ {\n                my $prev_level = pop(@levels);\n                my $prev_depth\
    \ = pop(@depths);\n                if ($prev_depth >= $cur_deepest_level) {\n\
    \                    $cur_deepest_level = $prev_depth;\n                    $current_level\
    \ = $prev_level;\n                }\n            }\n        }\n    }\n    while\
    \ (@levels) {\n        my $prev_level = pop(@levels);\n        my $prev_depth\
    \ = pop(@depths);\n        if ($prev_depth >= $cur_deepest_level) {\n        \
    \    $current_level = $prev_level;\n        }\n    }\n    while (@levels) {\n\
    \        my $prev_level = pop(@levels);\n        my $prev_depth = pop(@depths);\n\
    \        if ($prev_depth >= $cur_deepest_level) {\n            push(@paren_levels,\
    \ $prev_level);\n        }\n    }\n    return \\@paren_", "    my($result,$level);\n\
    \    my($end_paren_level);\n    my($i,$start_paren_level,$end_paren_level);\n\
    \    my($paren_stack,$paren_level,$braces);\n    my($brace_stack,$brace_level);\n\
    \    my($next_level_paren_stack);\n    my($next_level_paren_level);", "    my;\n\
    \    if ( $paren_string =~ /^\\s*(\\([^(]+\\))+\\s*$/ ) {\n        my $max_level\
    \ = 0;\n        while (1) {\n            my $level = $paren_string =~ s/^(\\([^(]+\\\
    ))+\\s*/$1/;\n            if ( $level != $paren_string ) {\n                last;\n\
    \            }\n            $max_level = $level if $max_level < $level;\n    \
    \    }\n        push, $max_level;\n    }\n    return;\n}", "    my(@level_stack)\
    \ = ();\n    my(@level_count) = ();\n    my($group_count = 0);\n    my($group_string);",
  "    my(@results);\n    foreach my $open_paren (split(/ /, $paren_string)) {\n \
    \       my $closed_paren = 0;\n        foreach my $open_paren_char (split(//,\
    \ $open_paren)) {\n            if ($open_paren_char == $open_paren) {\n      \
    \          $closed_paren++;\n                last if $closed_paren == $open_paren_char;\n\
    \            } else {\n                $closed_paren = 0;\n            }\n   \
    \     }\n        push(@results, $open_paren_char);\n    }\n    return @results;\n\
    }", "    my(@paren_groups);\n    my($level);", "    $paren_string = $paren_string.\"\
    \ \";\n    $paren_string = $paren_string.\" \";", "    my(@nested_paren_groups)\
    \ = ([]);\n    my($max_level) = undef;\n    while ($paren_string = substr($paren_string,\
    \ 0, $max_level)) {\n        push(@nested_paren_groups, $max_level);\n       \
    \ if ($paren_string =~ m!\\((?=\\()|(?<=\\))(?=\\()|(?=\\))(?=\\))!) {\n     \
    \       $max_level++;\n        }\n    }\n    return @nested_paren_groups;\n}",
  "    my($max_nesting) = undef;\n    my($nested_level) = undef;", "    my $nesting\
    \ = 1;\n    my @nesting_levels;\n    my $nesting_level = 0;\n    my $in_parens\
    \ = '';\n    my $paren_level = 0;\n    my $max_level = 0;\n    my $paren_nesting\
    \ = 0;\n    my $paren_nesting_level = 0;\n    my $is_last_parens = '';\n    my\
    \ $paren_level_inside = 0;\n    my $paren_level_outside_parens = 0;", "    # Remove\
    \ leading and trailing spaces.\n    $paren_string = \" \" x length($paren_string)\
    \ . \" \" x length($paren_string);\n    # Store all the groups in an array. Nested\
    \ parenthesis groups are represented by\n    # the same string. E.g. (()) has\
    \ two groups. One is empty string and another is ()\n    # and the empty string\
    \ will be the element at index 0 in @paren_groups.\n    my(@paren_groups) = split\
    \ /\\s+/, $paren_string;\n    my @max_nesting;\n    # Go through all the groups.\
    \ For each group, calculate its level of nesting using\n    # @paren_groups. Push\
    \ the maximum nesting level into the array.\n    foreach my $group (@paren_groups)\
    \ {\n        my $num_openings = 0;\n        my $num_closings = 0;\n        my\
    \ $num_openings_before_closings = 0;\n        foreach my $char (@$group) {\n \
    \           # Count the number of opening parentheses in the string.\n       \
    \     if ($char = \"(\") {\n                $num_openings += 1;\n            }\n\
    \            # Count the number of closing parentheses in the string.\n      \
    \      elsif ($char = \")\") {\n                $num_closings += 1;\n        \
    \    }\n            # Count the number of opening parentheses in the string before\
    \ closing the group\n            # (excluding the first closing parentheses).\n\
    \            elsif ($char = \")\" && $num_closings > 0 && $num_openings > 0) {\n\
    \                $num_openings_before_closings += 1;\n            }\n        }\n\
    \        if ($num_openings_before_closings > 0) {\n            push @max_nesting,\
    \ $num_openings_before_closings;\n        }\n        if ($num_closings > 0) {\n\
    \            push @max_nesting, $num_closings;\n        }\n    }\n    # Return\
    \ the max nesting level.\n    return @max_nesting;\n}", "    my @paren_list;\n\
    \    my @level;\n    my(@depth, $i, $maxdepth);", "    $paren_string =~ tr/ ()/\
    \ /;\n    my @paren_levels;\n    my $index = 0;\n    foreach my $char (split //,\
    \ $paren_string) {\n        my $level_of_paren = $index++ % $#paren_levels;\n\
    \        if ($level_of_paren == $paren_levels[-1]) {\n            push @paren_levels,\
    \ 1;\n        }\n        else {\n            push @paren_levels, 0;\n        }\n\
    \    }\n    return @paren_levels;\n}", "    my $paren_level = 0;\n    $paren_level\
    \ = length $paren_string\n        ? $paren_string\n            =~ s/^(?:\\( (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?: [^()]* (?:\
    \ [^()]* (?: [^()]* (?: [^()]* (?: [", "    my(@level) = ();\n    my @levels =\
    \ ();\n    my(@all_levels) = ();\n    while (my $paren = index($paren_string,\
    \ '(', 0)) {\n        my $closed = substr($paren_string, 0, $paren);\n       \
    \ my $opened = substr($paren_string, $paren+1);\n        push @levels, 0 if defined\
    \ $levels[-1];\n        push @levels, $levels[-1] + 1 if (defined $levels[-1]\
    \ and $opened eq ')');\n        push @levels, 0 if defined $levels[-1];\n    \
    \    @all_levels[-1] = @levels[-1] if $levels[-1];\n        push @all_levels,\
    \ @levels;\n        my $levels = scalar @all_levels;\n        my $closed_levels\
    \ = scalar @levels;\n        $levels -= $closed_levels if ($closed eq ')');\n\
    \        $paren_string = substr($paren_string, $closed_levels + 1) if ($closed\
    \ eq ')');\n        $paren_string = substr($paren_string, 0, $paren+1) if ($closed\
    \ eq ')');\n        $levels += $closed eq ')' ? -1 : 0;\n        $levels = $levels\
    \ * 2 if ($closed eq ')');\n        my $has_nested_paren = $levels > 0;\n    \
    \    if ($parens == 0) {\n            my $open_count = $closed eq '(' ? 1 : 0;\n\
    \            $levels -= $open_count if ($open_count > 1);\n            $levels\
    \ = $levels if $open_count > 1;\n            $parens += $has_nested_paren;\n \
    \       }\n        $parens++;\n    }\n    return @all_levels;\n}", "    my(@nested_parens_stack)\
    \ = ();\n    my($max) = -1;\n    $max = 0;\n    \n    foreach my $p (split(/ /,\
    \ $paren_string)) {\n        if ($p eq \"\") {\n            last;\n        }\n\
    \        \n        if ($p[0] eq '(') {\n            push(@nested_parens_stack,\
    \ $max);\n            $max++;\n        }\n        \n        if ($p[0] eq ')')\
    \ {\n            my $p = pop(@nested_parens_stack);\n            if ($p > $max)\
    \ {\n                $max = $p;\n            }\n        }\n    }\n    return $max;\n\
    }", "    my($group) = ();\n    my($level) = -1;\n    my($result) = ();\n    for($paren_string)\
    \ {\n        if($paren_string =~ /^\\s*\\(/) {\n            push(@$group, 1);\n\
    \            push(@$result, $level);\n        }\n        elsif($paren_string =~\
    \ /^\\s*\\)\\s*$/) {\n            pop @$group;\n            pop(@$result);\n \
    \           if(@$group > 0) {\n                $level += ($group - 1);\n     \
    \       }\n            else {\n                $level--;\n            }\n    \
    \    }\n        elsif($paren_string =~ /^\\s*((\\s*\\S+\\s*)*)\\s*$/) {\n    \
    \        $paren_string = $1;\n            for($i = 0; $i < @$group; $i++) {\n\
    \                push @$result, $level;\n            }\n        }\n    }\n   \
    \ push(@$result, $level);\n    return @$result;\n}", "    my;\n    my $level =\
    \ 1;\n    while ($paren_string) {\n        if ($paren_string=~/\\(.*?\\)/) {\n\
    \            push(@nesting, $level);\n            $level++;\n        }\n     \
    \   elsif ($paren_string=~/\\((.*?)\\)/) {\n            push(@nesting, $level);\n\
    \            $level++;\n        }\n        else {\n            last;\n       \
    \ }\n        $paren_string = substr($paren_string, index($paren_string, '(') +\
    \ 1);\n    }\n    return @nesting;\n}", "    my(@levels_of_indent);\n    my($group,$nesting);",
  '    my($level, $group, $depth) = (0, 0, 0);', "    my $paren_counter = 1;\n   \
    \ my $paren_level = 0;\n    my @paren_list;\n    my $paren_stack_level = 0;\n\
    \    my $start_index = 0;", "    my @parens;\n    while ($paren_string) {\n  \
    \      if (m/^\\(+$/) {\n            push @parens, length $paren_string;\n   \
    \         $paren_string = substr($paren_string, 1);\n        }\n        elsif\
    \ (m/^\\)+$/) {\n            pop @parens;\n            $paren_string = substr($paren_string,\
    \ 1);\n        }\n    }\n    return @parens;\n}", '    my @paren_count = ();',
  "    my @paren_groups;\n    my $max_paren_level = 0;\n    my %paren_stack;", " \
    \   my;\n    my $curr_paren_level = 0;\n    my $is_paren_start_symbol;\n    my\
    \ $is_paren_end_symbol;\n    my $is_paren_symbol;\n    my $is_paren_symbol_type;\n\
    \    my $is_paren_symbol_sub_type;\n    my $is_end_paren_symbol;\n    my $is_end_paren_symbol_type;\n\
    \    my $is_end_paren_symbol_sub_type;\n    my $symbol;\n    my $symbol_type;\n\
    \    my $symbol_sub_type;\n    my $is_paren_symbol_next_symbol;\n    my $next_symbol;",
  "    my($paren_nesting) = map(\"\", (0 .. $paren_string->length-1));\n    my($paren_level)\
    \ = map(\"\", (0 .. $paren_string->length-1));\n    my($max_level) = map(\"\"\
    , (0 .. $paren_string->length-1));", "    my(@paren_stack) = (0, 0);\n    my(@output_paren_stack)\
    \ = (0);\n    my($level);\n    my($group, $group_size);\n    my(@grouped_parens)\
    \ = (());\n    my(@max_paren_level);\n    my(@paren_level);", '    my(@max_levels);',
  "    my($par, @nested, $par_count, $par_index);\n    my($left_bracket, @left_brackets);\n\
    \    my($right_bracket, @right_brackets);\n    my(@parstring);\n    my($par_index,\
    \ $par_count);", "    my @paren_levels;\n    my $paren_level;\n    my @paren_strings;\n\
    \    my @paren_string;\n    my $paren_count = 0;\n    my @paren_groups;\n    my\
    \ @paren_group;\n    my $paren_group_count = 0;\n    my @paren_group_nestings;\n\
    \    my @paren_group_nesting;\n    my $paren_group_nesting_level;", '    my(@groups);',
  "    my(@results);\n    my($in_group, $group_size);", "    my($paren_array) = ();\n\
    \    my($level) = -1;\n    my $curr_paren = '';", "    my($parentheses_count)\
    \ = (0);\n    my($nested_parentheses_count);\n    my($max_parentheses_count);",
  "    my @paren_stack = ();\n    my $paren_level = 0;\n    my @paren_levels;", " \
    \   my $paren_group;\n    my @max_level_of_nesting;\n    my($i, $j) = 0, 0;\n\
    \    my $paren_level = 0;\n    for ($i = 0; $i <= length($paren_string); $i++)\
    \ {\n        if ($paren_string[$i] eq '(') {\n            if ($paren_group) {\n\
    \                push @max_level_of_nesting, $paren_level;\n            }\n  \
    \          $paren_level++;\n            $paren_group++;\n        } elsif ($paren_string[$i]\
    \ eq ')') {\n            $paren_level--;\n            $paren_group--;\n      \
    \  } elsif ($paren_string[$i] eq '(') {\n            $paren_group++;\n       \
    \ }\n    }\n    if ($paren_group) {\n        push @max_level_of_nesting, $paren_level;\n\
    \    }\n    @max_level_of_nesting;\n}", "    my(@levels) = ();\n    my($level,\
    \ $i);\n    my(@level_stack) = ();\n    my $count = 0;\n    for(split(' ', $paren_string))\
    \ {\n        my ($group_level, $group) = ($count > 0) ? split(/\\)|\\(/, $_, $count)\
    \ : [0, ''];\n        $level++;\n        push(@levels, $level);\n        push(@level_stack,\
    \ $level);\n        $count += $group_level;\n        push(@{$groups[$group]},\
    \ $level_stack[-1]);\n    }\n    return @levels;\n}", "    my(@paren_levels) =\
    \ ();\n    my($current_depth);", "    my @paren_strings = split \" \", $paren_string;\n\
    \    my @paren_level;\n    my $i;\n    my $num_parens = @paren_strings;\n    foreach\
    \ $i (0 .. $num_parens) {\n        my ($paren_string, $paren_level) = \n     \
    \           ($paren_strings[$i], $paren_level[$i]);\n        if ($paren_level\
    \ == 1) {\n            push(@paren_level, $paren_level + 1);\n        } else {\n\
    \            push(@paren_level, $paren_level);\n        }\n    }\n    return @paren_level;\n\
    }", "    my @parsed_paren_groups = parse_paren_groups($paren_string);\n    my\
    \ @deepest_levels = ();\n    my @num_level_counter = ();\n    my $num_level_counter;",
  "    my @paren_groups = ();\n    my $num_paren_groups = 0;\n    my $paren_level\
    \ = 0;\n    my $current_paren = 0;\n    my $current_paren_group;", "    $paren_string\
    \ =~ s/\\s+/ /g;\n    my(@levels) = ();\n    my $level;\n    while(length($paren_string)\
    \ > 0) {\n        $level = pop (@levels); # pop off the highest level of nesting\
    \ we had.\n        push(@levels, 0); # push a new level onto the stack.\n    \
    \    my($group_count, $open_paren_count, $close_paren_count) = (0, 0, 0);\n  \
    \      my $char_pos = 0;\n        while($char_pos < length($paren_string)) {\n\
    \            if(substr($paren_string, $char_pos, 1) =~ /^\\()/) {\n          \
    \      $open_paren_count += 1;\n            } elsif ($open_paren_count > 0 &&\
    \ substr($paren_string, $char_pos, 1) =~ /^\\)/) {\n                $open_paren_count\
    \ -= 1;\n            } elsif ($open_paren_count == 0) {\n                if(substr($paren_string,\
    \ $char_pos, 1) eq ')') {\n                    $close_paren_count += 1;\n    \
    \            } elsif ($close_paren_count > 0 && substr($paren_string, $char_pos,\
    \ 1) eq '(') {\n                    $close_paren_count -= 1;\n               \
    \ }\n            }\n            $char_pos += 1;\n        }\n        push(@levels,\
    \ $level);\n        $group_count = @levels;\n    }\n    return @levels;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThe solution is correct, but doesn't handle all corner\
    \ cases. `print parse_nested_parens(\")((()((()()))))()\")` gives me `1` instead\
    \ of `3`\n<|/ c |>\n<| c |>\nThe function fails to parse a string like \"((())()\"\
    \n<|/ c |>\n<| a tags=string,perl,regex,string-parsing dscore=2 |>\nThe Perl solution\
    \ (that doesn't use recursion) could be something like this (I haven't tested\
    \ it):\n<code>", '    my @parens = $paren_string=~m{(?:\( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?:
    \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \( (?: \(
    (?: \( (?: \( (', '    my(@levels) = (0);', "    my($paren_stack) = ();\n    my(@nesting_levels);\n\
    \    my($max_nesting_level = -1);\n    my($curr_nesting_level) = -1;\n    my($i);",
  '    my(@parens_stack) = ();', "    my($parsed_parens) = [];\n    my($paren_level);\n\
    \    my(@paren_groups);\n    my(@new_paren_groups);\n    while($paren_string =~\
    \ /(\\(+)/) {\n        $paren_groups = $paren_groups ? @paren_groups + [split\
    \ \"[\\(\\)]\", $1] : [];\n        $paren_level++;\n        foreach my $i (0..$#paren_groups)\
    \ {\n            my $paren_group_str = join \"|\", @{$paren_groups[$i]};\n   \
    \         if($paren_string =~ /($paren_group_str)/) {\n                $parsed_parens[$i]\
    \ = $paren_level;\n                last;\n            }\n        }\n    }\n  \
    \  if(@parsed_parens) {\n        my $max_depth = @parsed_parens;\n        my $max_val\
    \ = -$max_depth;\n        foreach my $i (0..$#parsed_parens) {\n            my\
    \ $depth = @{$parsed_parens[$i]};\n            if($depth > $max_val) {\n     \
    \           $max_val = $depth;\n            }\n        }\n        return @{$parsed_parens[$max_val]};\n\
    \    } else {\n        return -1;\n    }\n}", "    my($open_paren_stack, $closed_paren_stack)\
    \ = (0, 0);\n    my(@nested_parens) = ();", "    # Initialize our result list\
    \ with the first level of nesting (the deepest).\n    my (@results);\n    $paren_string\
    \ = ltrim($paren_string);\n    # Traverse the string and add one level of nesting\
    \ for each open paren.\n    my $current_level = 0;\n    for (my $i = 0; $i < length($paren_string);\
    \ $i++) {\n        my $char = $paren_string[$i];\n        my $open_paren = ($char\
    \ == \"(\");\n        if ($open_paren) {\n            $current_level++;\n    \
    \    } elsif ($open_paren == 0 and $current_level > 0) {\n            $current_level--;\n\
    \        }\n        if ($current_level == 1) {\n            push @results, $current_level;\n\
    \        }\n    }\n    return @results;\n}", "    my @paren_groups;\n    my($curr,\
    \ $last_level);\n    my $paren_level;\n    foreach my $char (split(//, $paren_string))\
    \ {\n        if ($char eq '(') {\n            push @paren_groups, 0;\n       \
    \ }\n        elsif ($char eq ')') {\n            if (@paren_groups > 0) {\n  \
    \              $curr = pop @paren_groups;\n            }\n            else {\n\
    \                $paren_level--;\n                if ($paren_level == -1) {\n\
    \                    push @paren_groups, 0;\n                }\n            }\n\
    \        }\n        else {\n            push @paren_groups, $curr;\n         \
    \   if ($char eq '(') {\n                $curr++;\n            }\n           \
    \ else {\n                $curr = 0;\n            }\n        }\n        if (@paren_groups\
    \ == 0) {\n            $paren_level = 0;\n        }\n    }\n    if (@paren_groups\
    \ > 0) {\n        $curr = pop @paren_groups;\n    }\n    else {\n        $paren_level--;\n\
    \        if ($paren_level == -1) {\n            push @paren_groups, 0;\n     \
    \   }\n    }\n    return @paren_groups;\n}", "    my @paren_list;\n    my $level\
    \ = 1;\n    my $paren_depth = 0;\n    for (my $i = 0; $i < length($paren_string);\
    \ $i++) {\n        my $c = substr($paren_string, $i, 1);\n        if ($c == \"\
    (\") {\n            $level++;\n            push (@paren_list, $level);\n     \
    \   }\n        elsif ($c == \")\") {\n            $level--;\n            push\
    \ (@paren_list, $level);\n        }\n        elsif ($c eq \" \") {\n         \
    \   $level++;\n            push (@paren_list, $level);\n        }\n    }\n   \
    \ return @paren_list;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice solution,\
    \ thanks for sharing! However, in practice, I found that using `re` for matching\
    \ nested parentheses (`/(?=\\()|\\))|(?<=\\())/`) was a bit faster.\n<|/ c |>\n\
    <| a dscore=3 |>\nThis regex will work even for nested parentheses\n<code>\n(?<=(\\\
    ([^\\(]+\\))+) \n</code>\nhttps://regex101.com/r/pK6rR2/1\n<|/ a tags=regex,perl\
    \ |>\n<| c |>\nThis solution works perfectly for my case. I just replaced `+`\
    \ with `*` since I don't need nested parens.\n<|/ c |>\n<| a |>\nThis seems to\
    \ work:\n<code>\nuse strict;\nuse warnings;", "    # Count number of parentheses\n\
    \    my($num_parens, $num_nests);\n    $num_parens = 0;\n    $num_nests  = 0;\n\
    \    while($paren_string) {\n        my $c = $paren_string[0];\n        $num_parens++;\n\
    \        if ($c eq '(') {\n            $num_nests++;\n        } elsif ($c eq ')')\
    \ {\n            $num_nests--;\n        }\n        $paren_string = substr($paren_string,\
    \ 1);\n    }\n    if ($num_parens eq 0) {\n        return 0;\n    }\n    my @nests;\n\
    \    my $i = 0;\n    while($i < $num_parens) {\n        my $c = $paren_string[$i];\n\
    \        if ($c eq '(') {\n            $i++;\n            my $nest = $i;\n   \
    \         while(--$i < $num_parens) {\n                my $d = $paren_string[$i];\n\
    \                $nests[$nest] += $d eq '(' ? 1 : 0;\n            }\n        \
    \    $nests[$nest]++;\n        } elsif ($c eq ')') {\n            my $nest = $i;\n\
    \            while(--$i < $num_parens) {\n                my $d = $paren_string[$i];\n\
    \                $nests[$nest] += $d eq ')' ? 1 : 0;\n            }\n        \
    \    $nests[$nest]--;\n        }\n        $i++;\n    }\n    return @nests;\n}",
  "    my @levels;\n    my $paren_depth = 0;\n    my $paren_char = $paren_string[0];\n\
    \    while (length > 1) {\n        my $sub_string = substr($paren_string, 0, 1);\n\
    \        if ($sub_string eq $paren_char) {\n            push @levels, $paren_depth;\n\
    \        }\n        elsif ($sub_string eq \")\") {\n            ++$paren_depth;\n\
    \        }\n        elsif ($sub_string eq \"(\") {\n            --$paren_depth;\n\
    \        }\n        elsif ($sub_string eq \"\") {\n            last;\n       \
    \ }\n        $paren_string = substr($paren_string, 1);\n    }\n    return @levels;\n\
    }", "    my @paren_groups = ();\n    my($level);\n    foreach my $group_string\
    \ ( split /\\s+/, $paren_string ) {\n        my($group_level) = parse_nested_parens_level($group_string);\n\
    \        if ($group_level <= 0) {\n            push @paren_groups, $group_level;\n\
    \        } else {\n            push @paren_groups, $group_level - 1;\n       \
    \ }\n    }\n    return @paren_groups;\n}", "    my(@groups);\n    my($max_level);\n\
    \    my($level);\n    my $index = 0;\n    while ($index < length($paren_string))\
    \ {\n        if ($paren_string[$index] eq '(') {\n            push @groups, 1;\n\
    \            $level++;\n        }\n        if ($paren_string[$index] eq ')') {\n\
    \            pop @groups;\n            $level--;\n        }\n        $index++;\n\
    \    }\n    if ($level > ($max_level)) {\n        $max_level = $level;\n    }\n\
    \    return $max_level;\n}", "    $paren_string =~ s/^\\s*//g;\n    $paren_string\
    \ =~ s/\\s*$//g;\n    my = ();\n    my(@parsing_group);\n    my($open_bracket,\
    \ $level);\n    my($close_bracket, $level);\n    my $i = 0;\n    while (@paren_string)\
    \ {\n        if ($paren_string[$i] =~ /^(\\()/) {\n            $level = 1;\n \
    \       }\n        elsif ($paren_string[$i] =~ /^(\\))/) {\n            $level--;\n\
    \        }\n        if ($level > 0) {\n            push, 1;\n        }\n     \
    \   if ($level < 0) {\n            push, 0;\n        }\n        $i++;\n    }\n\
    \    return \\@parsing_group;\n}", "    my @paren_groups = ();\n    my @paren_group_depths\
    \ = ();\n    my @max_depth = ();", "    my($nested_parens) = 0;\n    my($depth)\
    \ = 0;\n    my($i) = 0;\n    my($open_paren_count);\n    my($close_paren_count);\n\
    \    my($max_depth);\n    my($open_brace_count);\n    my($close_brace_count);\n\
    \    my($max_open_brace);\n    my($max_close_brace);\n    \n    # Initialize the\
    \ $max_depth and $max_open_brace and $max_close_brace.\n    # Since $max_depth\
    \ is initialized to 0, we assume that if $max_depth is not\n    # initialized\
    \ at this point then it has not yet been initialized and thus\n    # will have\
    \ a value of 0.\n    $max_depth = undef;\n    $max_open_brace = undef;\n    $max_close_brace\
    \ = undef;\n    \n    for ($i = 0; $i < length($paren_string); $i++) {\n     \
    \   if ($paren_string[$i] eq '(') {\n            if ($open_paren_count == 0) {\n\
    \                $open_paren_count++;\n                $depth++;\n           \
    \ }\n            else {\n                $open_paren_count++;\n              \
    \  if ($max_depth == 0) {\n                    $max_depth = $depth;\n        \
    \            $max_open_brace = $open_paren_count;\n                    $max_close_brace\
    \ = $open_paren_count;\n                }\n                $depth = $open_paren_count;\n\
    \            }\n        }\n        elsif ($paren_string[$i] eq ')') {\n      \
    \      if ($depth == 0) {\n                die \"Parsing error. Encountered a\
    \ close paren without an open paren\";\n            }\n            $depth--;\n\
    \            $close_paren_count++;\n        }\n    }\n    \n    if ($depth ==\
    \ 0) {\n        die \"Parsing error. Encountered a close paren without an open\
    \ paren\";\n    }", "    $paren_string =~ s/^\\s*//;\n    $paren_string =~ s/\\\
    s*$//;\n    $paren_string =~ s/\\(\\s*(\\((?!\\)\\s*\\))*\\s*\\)//g;\n    $paren_string\
    \ =~ s/\\(\\s*(\\((?!\\)\\s*\\))*\\)//g;\n    $paren_string =~ s/\\(\\s*\\((?!\\\
    )\\s*\\)\\s*\\)//g;\n    my($count) = &get_nested_parens_count($paren_string);\n\
    \    my @return_array = ();\n    my $i = 0;\n    $count += 1;\n    my $level =\
    \ 0;\n    my $counts = ();", "    $paren_string = join(\")\", map {s/^((\\().*?\\\
    ))/\\1/} split /\\s+/, $paren_string);\n    return grep { length() <= 2 } @$paren_string;\n\
    }", '    my(@paren_levels);', "    my($nesting_level);\n    my @paren_pairs;\n\
    \    my @paren_groups;", "    my @paren_strings;\n    $paren_string = \"\" if\
    \ !defined $paren_string;\n    foreach my $line (split /[()]+/, $paren_string)\
    \ {\n        my @line = split /[\\(\\)]+/, $line;\n        @paren_strings = @{$paren_strings}\
    \ if @paren_strings > @line;\n        if (@line == 0) {\n            last;\n \
    \       }\n        push @paren_strings, @line;\n    }\n    return @paren_strings;\n\
    }", "    my($paren_char) = qr{(}|)};\n    my($opening_parens = 0);\n    my($open_stack\
    \ = 1);\n    my($current_level);\n    my(@output);", "    my($level, $depth) =\
    \ (0, 0);\n    my($last_paren, $parens);\n    while(1) {\n        last unless\
    \ $paren_string =~ m{^\\s*\\(\\s*\\((?&parens)\\)\\s*\\)\\s*}x;\n        $depth++;\n\
    \        $last_paren = $+{parens};\n        $paren_string =~ s{^\\s*\\(\\s*\\\
    ((?&parens)\\)\\s*\\)\\s*}\n                           {print \"$last_paren $depth\"\
    } =~\n                           tr{()}{()};\n    }\n    return;\n}\n</code>\n\
    <|/ a tags=perl,regex |>\n<| c |>\nThanks mate! You made my day! You really made\
    \ my day!\n<|/ c |>\n<| c |>\nCan you please explain the regex a bit. I would\
    \ appreciate that. Thanks!\n<|/ c |>\n<| c |>\nThe regex is explained in [perlre\
    \ - Regular Expressions](http://perldoc.perl.org/perlre.html). The basic idea\
    \ is that instead of iterating over the nested parenthesis, we can just keep a\
    \ counter to how many times we have seen a nested parentheses.\n<|/ c |>\n<| c\
    \ |>\nThanks. One more question, if you please. How could i modify the code to\
    \ remove parenthesis from the string as well. i.e. \"((()))\" should just output\
    \ \"()\". Thanks!\n<|/ c |>\n<| c |>\n: Just remove the second `tr{()}{()}`.\n\
    <|/ c |>\n<| a |>\nI wouldn't use regex for this, I would use recursion:\n<code>",
  "    my($level) = [0];\n    my(@return_levels) = [];\n    my($curr_level);\n   \
    \ my(@paren_groups) = split(/ /, $paren_string);\n    my($curr_group_index);\n\
    \    my($max_group_level);\n    foreach my $p (@paren_groups) {\n        if (!defined($curr_group_index))\
    \ {\n            $curr_group_index = 0;\n            $curr_level = 0;\n      \
    \  } elsif ($curr_group_index != $curr_level) {\n            @return_levels[$curr_group_index]\
    \ = $max_group_level;\n            $max_group_level = $curr_level;\n         \
    \   $curr_level = $curr_group_index;\n            $curr_group_index = 0;\n   \
    \     }\n        elsif ($p eq '(') {\n            $curr_group_index++;\n     \
    \   } elsif ($p eq ')') {\n            $curr_group_index--;\n        } elsif ($curr_group_index\
    \ > $curr_level) {\n            $curr_group_index = 0;\n            $curr_level\
    \ = $curr_group_index;\n        } elsif ($curr_group_index < $curr_level) {\n\
    \            $curr_group_index++;\n        }\n    }\n    @return_levels[$curr_group_index]\
    \ = $max_group_level;\n    return @return_levels;\n}", "    my;\n    my $paren_level\
    \ = 0;\n    my $opening_symbol;\n    foreach my $char (split(//, $paren_string))\
    \ {\n        if ($char eq '(') {\n            if ($opening_symbol eq '(') {\n\
    \                push, $paren_level;\n                $paren_level++;\n      \
    \      }\n            elsif ($opening_symbol eq ')') {\n                $paren_level--;\n\
    \            }\n            else {\n                $opening_symbol = $char;\n\
    \                $paren_level = 1;\n            }\n        }\n        elsif ($opening_symbol)\
    \ {\n            push, $paren_level;\n        }\n        else {\n            push,\
    \ $char;\n        }\n    }\n    my $output_count = @paren_levels;\n    if (@paren_levels\
    \ > $output_count) {\n        $output_count = $output_count;\n    }\n    return\
    \ @paren_levels;\n}", "    my($max_level);\n    my($paren_stack, $paren_stack_count);\n\
    \    my($last_closed_paren);\n    my($level_stack, $level_stack_count);\n    my(@paren_list);\n\
    \    \n    $level_stack_count = 0;\n    $level_stack[0] = 0;\n    \n    $paren_stack_count\
    \ = 0;\n    $paren_stack[0] = 0;\n    \n    while (length($paren_string) > 0)\
    \ {\n        \n        $paren_string = substr($paren_string, 0, 1);\n        \n\
    \        my $closed_parens = $paren_string =~ tr/\\(\\)\\//\\(\\)\\//;\n     \
    \   $closed_parens = $closed_parens + 1;\n        \n        # Update the number\
    \ of open parentheses in the stack\n        $paren_stack_count = $paren_stack_count\
    \ + $closed_parens;\n        \n        # If all parentheses have been opened in\
    \ the stack, pop\n        # them one level up and increase the level counter\n\
    \        if ($paren_stack_count == $paren_stack_count) {\n            $level_stack_count\
    \ = $level_stack_count + 1;\n            $level_stack[0] = $level_stack[0] + 1;\
    \ \n        }\n        \n        my $new_level = $level_stack[$level_stack_count];\n\
    \        \n        # If a level of nesting is popped, pop the highest level from\
    \ that level of nesting\n        if ($level_stack_count > $new_level) {\n    \
    \        \n            $level_stack_count = $level_stack_count - 1;\n        \
    \    \n            $level_stack[$level_stack_count] = $new_level;\n        }\n\
    \        \n        # A new level of nesting is opened. Increase the level counter\
    \ and push the new level of nesting onto the stack\n        if ($paren_stack_count\
    \ == 1) {\n            $level_stack_count = $level_stack_count + 1;\n        \
    \    $level_stack[$level_stack_count] = $new_level;\n        }\n        \n   \
    \     # Pop the highest level of nesting from the level of nesting stack and decrease\
    \ the level counter\n        if ($level_stack_count > 0) {\n            \n   \
    \         $level_stack_count = $level_stack_count - 1;\n            \n       \
    \     $level_stack[$level_stack_count] = $new_level;\n        }\n        \n  \
    \      # Pop the highest level of nesting from the level of nesting stack and\
    \ decrease the level counter\n        if ($level_stack_count < 0) {\n        \
    \    \n            $level_stack_count = $level_stack_count + 1;\n            \n\
    \            $level_stack[$level_stack_count] = $new_level;\n        }\n     \
    \   \n        # A new level of nesting is opened. Increase the level counter and\
    \ push the new level of nesting onto the stack\n        if (", "    my($paren_level)\
    \ = -1;\n    my($current_paren_level) = -1;\n    my @parens = ();\n    my @paren_strings\
    \ = ();\n    my($next_paren_string) = undef;\n    my($next_paren_level) = undef;\n\
    \    my @group_parens = ();\n    my @group_paren_strings = ();\n    my $current_group\
    \ = undef;", "    my($nested_parens) = ();\n    my($level) = -1;\n    my($start_idx)\
    \ = -1;\n    my($end_idx) = -1;\n    my($new_parens_string) = ();\n    my($start_idx)\
    \ = -1;\n    my($end_idx) = -1;\n    my($level) = -1;\n    my($start_idx) = -1;\n\
    \    my($end_idx) = -1;\n    my($new_parens_string) = ();\n    my($start_idx)\
    \ = -1;\n    my($end_idx) = -1;\n    my($level) = -1;\n    my($start_idx) = -1;\n\
    \    my($end_idx) = -1;\n    my($paren_stack) = ();\n    my($paren_stack_count)\
    \ = ();\n    my($last_paren_open) = 1;\n    my($last_paren_close) = 1;\n    my($last_paren_level)\
    \ = -1;\n    my $curr_char;\n    my $curr_paren_level;\n    my $paren_start_idx;\n\
    \    my $paren_end_idx;\n    my $paren_level = 0;\n    my $paren_stack_size =\
    \ 0;\n    $paren_start_idx = 0;\n    $paren_end_idx = 0;\n    $level = 0;\n  \
    \  $curr_char = 0;\n    $curr_paren_level = 0;\n    $paren_stack = [];\n    $paren_stack_count\
    \ = [];\n    $paren_start_idx = -1;\n    $paren_end_idx = -1;\n    $level = 0;\n\
    \    $paren_level = 0;\n    $start_idx = 0;\n    $end_idx = 0;\n    $new_parens_string\
    \ = \"\";\n    $last_paren_open = 1;\n    $last_paren_close = 1;\n    $last_paren_level\
    \ = -1;\n    for ($start_idx = 0; $start_idx < length($paren_string); $start_idx++)\
    \ {\n        $curr_char = $paren_string[$start_idx];\n        if ($curr_char ==\
    \ ')') {\n            if ($paren_level > 0) {\n                # We encountered\
    \ closing parenthesis without any opening parenthesis\n                last;\n\
    \            } else {\n                $paren_stack[$paren_stack_size++] = $start_idx;\n\
    \            }\n        } elsif ($curr_char == '(') {\n            $paren_stack[$paren_stack_size++]\
    \ = $start_idx;\n            $paren_level = $paren_level + 1;\n        } elsif\
    \ ($curr_char == ' ') {\n            $paren_level = $paren_level + 1;\n      \
    \  } elsif ($curr_char == ')') {\n            if ($paren_level == $curr_paren_level)\
    \ {\n                if ($paren_level > 0) {\n                    # We encountered\
    \ closing parenthesis with matching opening paren", "    my(@nested_parens) =\
    \ ();\n    my($nest_level);", "    my @paren_count = ();\n    my @paren_level;",
  "    my($number_of_open) = 0;\n    my($number_of_close) = 0;\n    my($max_level);",
  "    my($nested_paren_level);\n    my @paren_groups = $paren_string =~ m/([^()]+|[()]+)/sg;\n\
    \    my @paren_groups_len = map { length($_) } @paren_groups;\n    for (my $i\
    \ = 0; $i < @paren_groups_len; $i++) {\n        my $paren_group_len = @paren_groups_len\
    \ - $i;\n        if ($paren_group_len > @paren_groups) {\n            $nested_paren_level\
    \ = $i + 1;\n        }\n    }\n    my @nested_parens = ();\n    for (my $i = 0;\
    \ $i < @paren_groups_len; $i++) {\n        my $paren_group_len = @paren_groups_len\
    \ - $i;\n        if ($paren_group_len > @paren_groups) {\n            push @nested_parens,\
    \ $nested_paren_level;\n        }\n    }\n    return @nested_parens;\n}", "  \
    \  my(@paren_strings) = $paren_string =~ m/([^()]+)\\(([^()]+)\\)/g;\n    return\
    \ @paren_strings;\n}", '    my(@max_level, $level, $i);', "    my(@paren_level)\
    \ = ();\n    my($current_paren_level = -1);\n    my($paren_level_max) = -1;\n\
    \    my($last_paren_level) = -1;\n    my($current_nested_level) = -1;", "    my($nesting);\n\
    \    my(@return_val);", "    my($max_level,$level,$paranthesized_parens,$max_paranthesized_parens);\n\
    \    my @paranthesized_parens;\n    my $index = 0;\n    my $open_brackets = 0;\n\
    \    $max_level = -1;\n    $level = 0;\n    $paranthesized_parens = [];\n    $max_paranthesized_parens\
    \ = 0;\n    while($index < length($paren_string)){\n        if($paren_string[$index]\
    \ eq '('){\n            $open_brackets++;\n        }\n        elsif($paren_string[$index]\
    \ eq ')'){\n            $open_brackets--;\n        }\n        if($open_brackets\
    \ == 0){\n            $level++;\n        }\n        $paranthesized_parens[$level]\
    \ .= $paren_string[$index];\n        $max_level = length($paranthesized_parens[$level]);\n\
    \        last if($max_level == -1);\n        $index++;\n    }\n    return @paranthesized_parens;\n\
    }", "    $paren_string =~ tr/()/ /;\n    my @paren_levels = $paren_string =~ m/^\\\
    (+/gs;\n    my $level;\n    my $num_levels = @paren_levels;\n    for (my $i =\
    \ 0; $i < $num_levels; $i++) {\n        $level = $paren_levels[$i];\n        $level\
    \ =~ s/^\\(//;\n        $level =~ s/\\)$//;\n    }\n    return $level;\n}\n</code>\n\
    <|/ a tags=algorithm,parentheses,language-agnostic |>\n<| c |>\nFor my example\
    \ input your implementation returns 3, which is incorrect according to this definition:\
    \ https://en.wikipedia.org/wiki/Parenthesis_nesting_definition . Also your implementation\
    \ returns 1 for my example input which is also incorrect according to this definition:\
    \ https://en.wikipedia.org/wiki/Brace_balancing_(computer_science) .\n<|/ c |>\n\
    <| a tags=algorithm,parentheses,language-agnostic |>\nI have an optimized algorithm\
    \ for this problem. It's not recursive but it's more efficient. Let me walk you\
    \ through it step by step:", '    my $depth;', "    my @paren_levels;\n    $paren_string\
    \ =~ tr/()()/()/g;\n    my @levels = split(//, $paren_string);\n    @paren_levels\
    \ = map(@levels, @paren_levels);\n    my $max_level = max(@paren_levels);\n  \
    \  my @result;\n    for(my $i=0; $i < $max_level; $i++) {\n        my @temp =\
    \ @paren_levels[$i..$#paren_levels];\n        push @result, @temp;\n    }\n  \
    \  delete @paren_levels[$max_level];\n    delete @result[$max_level];\n    return\
    \ \\@result;\n}", "    my(@paren_groups) = ();\n    my($level_of_nesting);\n \
    \   my($nesting_level) = -1;\n    my($nesting_level_offset);", "    my($max_nesting)\
    \ = -1;\n    my(@nested_paren) = ($paren_string =~ m!\\(([^()]+|\\([^)]*\\))*\\\
    )!g);\n    \n    $max_nesting += $nested_paren[0] =~ tr/()//;\n    \n    foreach\
    \ my $paren(@nested_paren) {\n        $max_nesting += parse_nested_parens($paren);\n\
    \    }\n    return $max_nesting;\n}", "    my;\n    my;\n    my;\n    my;\n  \
    \  my $i = 0;\n    my $open_paren = 0;\n    my $paren_level = 0;\n    my $last_paren\
    \ = -1;", "    my(@paren_groups) = ();\n    my(@max_nesting) = ();\n    my($max_level_of_paren_group);\n\
    \    my $paren_stack = 0;\n    my $paren_level = 0;\n    my $last_closed_paren_group;\n\
    \    my $open_paren_group;\n    my $open_paren_group_level;\n    my $open_bracket_level;\n\
    \    my $closed_bracket_level;\n    my $open_bracket_group;\n    my $open_bracket_group_level;\n\
    \    my $bracket_stack = 0;\n    my $bracket_level = 0;\n    my $last_closed_bracket_group;",
  '    my($max);', "    my($max_level);\n    my(@paren_array);\n    my($current_level);\n\
    \    my($current_level_count);\n    my @paren_count;\n    my @paren_level;\n \
    \   my $paren_level_string;", "    $paren_string = strip_parens($paren_string);\n\
    \    $paren_string =~ tr/()//d;\n    my @paren_strings = split(//, $paren_string);\n\
    \    my @paren_levels;\n    my $i = 0;\n    my $paren_count;\n    my $current_level;",
  "    my($nesting_level,$nested_level);\n    my($new_string);\n    # $new_string\
    \ = \"\"\n    while ($paren_string) {\n        if ($paren_string{index($paren_string{'\
    \ '},'(')} != -1 ) {\n            $nested_level++;\n        }\n        elsif ($paren_string{index($paren_string{'\
    \ '},')')} != -1) {\n            $nesting_level--;\n        }\n        elsif ($nesting_level\
    \ < $nested_level) {\n            $nesting_level = $nested_level;\n        }\n\
    \        elsif ($nesting_level > $nested_level) {\n            $nested_level =\
    \ $nesting_level;\n        }\n        $new_string.=\"$paren_string{index($paren_string{'\
    \ '},'(')}, \";\n        $paren_string = substr($paren_string,index($paren_string,'\
    \ '));\n    }\n    push(@result,$new_string);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I believe this will fail for `()()()`, since it will only parse `()`, then `()`,\
    \ then `()` again. The idea is correct, but you need a change to detect parenthesis\
    \ mismatches.\n<|/ c |>\n<| c |>\nThanks for your suggestion, I'll try to change\
    \ the code later on.\n<|/ c |>\n<| c |>\nIt was my mistake, please take a look\
    \ now.\n<|/ c |>\n<| c |>\nThanks so much for your help.  I'm going to be using\
    \ this answer for another related question (http://stackoverflow.com/questions/16205569/recursive-regex-split-by-character-or-regex-in-perl),\
    \ but I was trying to simplify my question to what I actually need (and it was\
    \ unclear that my simple example was incorrect).  Sorry to waste your time.\n\
    <|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;", "    my(@output) = ();\n\
    \    my($level, $opened, $closed);\n    my($last_opened_paren = $paren_string);\n\
    \    $paren_string = join(' ', @{$paren_string});\n    foreach $level (split(/\
    \ /, $paren_string)) {\n        $opened = 0;\n        $closed = 0;\n        for\
    \ (my $i = 0; $i < length($level); $i++) {\n            if ($level[$i] eq '(')\
    \ {\n                $opened++;\n            }\n            elsif ($level[$i]\
    \ eq ')') {\n                $closed++;\n            }\n            elsif ($opened\
    \ > $closed && $closed != 1) {\n                $output[$level[$i] - '0'] += $opened;\n\
    \                $last_opened_paren = $level[$i];\n            }\n        }\n\
    \    }\n    return @output;\n}", "    my(@levels) = ();\n    my($maxlevel, $lastlevel,\
    \ $lastlevelex);", "    my;\n    my $paren_depth = 0;\n    for (@$paren_string)\
    \ {\n        if ($paren_depth > 0) {\n            push, $paren_depth;\n      \
    \  }\n        elsif (my $bracket_count = () = s/^.*\\(([^()]*)\\)$//) {\n    \
    \        push, $bracket_count;\n        }\n        elsif (my $bracket_count =\
    \ () = s/^.*(\\([^()]*\\))$//) {\n            push, $bracket_count;\n        }\n\
    \        $paren_depth = $paren_depth || $bracket_count if $bracket_count;\n  \
    \  }\n    pop if @$paren_string > 0;\n    return @levels;\n}", "    my($max_level,\
    \ $max_paren_level) = ();\n    my($paren_stack) = ();", "    my($paren_count,\
    \ $level, $opening_paren_count);\n    my $parens = $paren_string;\n    my @parens;\n\
    \    # Go through the string to count how many parentheses are opened\n    for\
    \ ($paren_count = 1, $level = 0; $paren_count > 0; ++$paren_count) {\n       \
    \ last if $paren_count == 0;\n        if ($paren_count == 1) {\n            $opening_paren_count\
    \ = pos($parens) - 1;\n        }\n        if ($paren_count > $opening_paren_count)\
    \ {\n            $level++;\n        }\n    }\n    # Store the result in the array\n\
    \    push(@parens, $level);\n    # Remove all the closed parentheses\n    substr($parens,\
    \ 0, $opening_paren_count);\n    $parens;\n}", "    my($levels) = @$paren_string;\n\
    \    my($output) = @$paren_string;\n    my(@groups) = @$paren_string;", '    my(@levels,
    $nesting_level, @open_parens);', "    my @paren_levels;\n    my $level = 0;\n\
    \    my $open_brackets = 0;\n    my $closed_brackets = 0;\n    my $is_open = 1;\n\
    \    foreach my $char (split(//, $paren_string)) {\n        if ($char == \")\"\
    ) {\n            $closed_brackets++;\n            if ($open_brackets == 0) {\n\
    \                $level++;\n            }\n        }\n        elsif ($char ==\
    \ \"(\") {\n            $open_brackets++;\n        }\n        elsif ($char ==\
    \ \")\") {\n            $open_brackets--;\n        }\n        elsif ($char ==\
    \ \"(\") {\n            $closed_brackets--;\n        }\n        elsif ($char ==\
    \ \" \") {\n            my $spaces = $level - $open_brackets;\n            $open_brackets\
    \ = 0;\n            $closed_brackets = 0;\n            $level = $spaces;\n   \
    \         $is_open = 1;\n        }\n        elsif ($char == \"\\n\" || $char ==\
    \ \"\\t\" || $char == \"\\r\") {\n            $is_open = 0;\n        }\n     \
    \   elsif ($char == \"(\") {\n            $is_open = 1;\n        }\n        elsif\
    \ ($char == \")\") {\n            $is_open = 0;\n        }\n        elsif ($char\
    \ == \"{\" || $char == \"}\") {\n            $open_brackets = 0;\n           \
    \ $closed_brackets = 0;\n            $level = 0;\n            $is_open = 1;\n\
    \        }\n        elsif ($char == \"(\") {\n            $open_brackets++;\n\
    \            $is_open = 1;\n        }\n        elsif ($char == \")\") {\n    \
    \        $open_brackets--;\n            $is_open = 0;\n        }\n        else\
    \ {\n            $open_brackets = 0;\n            $closed_brackets = 0;\n    \
    \        $level = 0;\n        }\n        push @paren_levels, $level;\n    }\n\
    \    return @paren_levels;\n}", "    my($paren_stack) = @{$paren_stack};\n   \
    \ my(@paren_levels);\n    my($paren_level);\n    my($level);\n    my($level_open);\n\
    \    my($level_close);\n    my(@paren_level_strings);\n    my($max_level);\n \
    \   \n    while (length $paren_string) {\n        if ($paren_string =~ /^\\((\\\
    ))*\\)$/ || $paren_string =~ /^(\\(|\\))*\\)$/ || $paren_string =~ /^(\\((\\))*\\\
    )$/ || $paren_string =~ /^(\\(|\\))*$/ || $paren_string =~ /^(\\(|\\)$/ || $paren_string\
    \ =~ /^\\((\\))*$/ || $paren_string =~ /^\\((\\)|\\))*$/ || $paren_string =~ /^\\\
    ((\\)|\\))*\\)$/ || $paren_string =~ /^(\\((\\)|\\))*$/ || $paren_string =~ /^(\\\
    (|\\)|\\))*$/) {\n            $paren_level_strings[$level_open][$level_close]\
    \ = $paren_string;\n            $paren_string = \"\";\n        } else {\n    \
    \        chomp $paren_string;\n            $level_open++;\n            $level_close++;\n\
    \        }\n    }\n    \n    foreach $level_open (1..$level_open) {\n        $level_close++;\n\
    \        $level_open--;\n        $level_close--;\n        \n        foreach $level_close\
    \ (1..$level_close) {\n            push @paren_level_strings, $level_open;\n \
    \           $level_open--;\n            $level_close--;\n        }\n    }\n  \
    \  \n    $max_level = -1;\n    \n    foreach $level_open (reverse @paren_level_strings)\
    \ {\n        foreach $level_close (1..$max_level) {\n            if ($level_open\
    \ eq $level_close) {\n                $max_level = $level_open;\n            }\n\
    \        }\n    }\n    \n    foreach $level_open (reverse @paren_level_strings)\
    \ {\n        foreach $level_close (1..$max_level) {\n            if ($level_open\
    \ eq $level_close) {\n                $max_level = $level_open;\n            }\n\
    \        }\n    }\n    \n    @paren_level_strings = reverse @paren_level_strings;\n\
    \    @paren_level_strings = map { scalar @{$_} } @paren_level_strings;\n    @paren",
  "    my @paren_groups = $paren_string =~ m/(\\([^()]*\\))/g;\n    my @paren_levels\
    \ = @paren_groups;\n    my $level = 0;\n    my @paren_levels_array;\n    foreach\
    \ my $group (@paren_groups) {\n        my $level_count = 0;\n        foreach my\
    \ $c ($group) {\n            if ($c eq '(') {\n                $level_count++;\n\
    \            }\n            elsif ($c eq ')') {\n                $level_count--;\n\
    \            }\n        }\n        if ($level_count == 0) {\n            push(@paren_levels_array,\
    \ $level);\n        }\n        $level++;\n    }\n    @paren_levels_array = sort\
    \ {$a <=> $b} @paren_levels_array;\n    return @paren_levels_array;\n}", "   \
    \ my @paren_levels;\n    my $paren_count = 0;\n    my @paren_strings = ();\n \
    \   my $last_index = 0;\n    my $level = 0;\n    my $paren_start_index = 0;\n\
    \    my $paren_end_index = 0;\n    my $paren_start_char;\n    my $paren_end_char;\n\
    \    my $paren_string;", "    my(@max_level);\n    my($level) = -1;", "    my\
    \ $paren_stack = [];\n    my $paren_count = 0;\n    my @paren_level_hash;\n  \
    \  my $is_paren_match = 0;\n    my $num_paren_levels = 0;\n    my @paren_levels;\n\
    \    while ($paren_string =~ /([^()]+)(\\(|$)/ig) {\n        # push matching groups\
    \ to stack\n        push(@paren_stack, uc($1));\n        $num_paren_levels++;\n\
    \    }", '    $paren_string = lc($paren_string); # make string lower case', " \
    \   my @paren_list;\n    my $paren_count = 0;", '    my %paren_stack = ();', " \
    \   my($group, $nesting_level, $max_nesting_level);\n    my(@results);", '    my($current_depth);',
  "    my($max_level) = -1;\n    my($level, $opening_paren) = (0, 0);\n    my(@paren_groups)\
    \ = ($paren_string);\n    \n    foreach my $nested_paren_group (@paren_groups)\
    \ {\n        if ($opening_paren != $nested_paren_group) {\n            die \"\
    Error: String $paren_string does not contain an opening paren\";\n        }\n\
    \        $level += 1;\n        if ($level > $max_level) {\n            $max_level\
    \ = $level;\n        }\n    }\n    return $max_level;\n}", "    my($depth) = 0;\n\
    \    my($i) = 0;\n    my($paren_stack) = [];\n    my($open_paren_count) = 0;\n\
    \    my(@output) = [];\n    my($curr_level);", "    my($opening_paren_level);\n\
    \    my(@opening_paren_groups);\n    my(@groups_to_remove);\n    my @final_paren_groups;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
