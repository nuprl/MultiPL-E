name: HumanEval_12_longest
language: pl
prompt: "# Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return undef in case the input\
  \ array is empty.\n# >>> longest([])\n# undef\n# >>> longest([\"a\", \"b\", \"c\"\
  ])\n# \"a\"\n# >>> longest([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\nsub longest {\n\
  \    my($strings) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&longest;\n\
  \        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"\
  z\"]),\"x\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n    \
  \    if(eq_deeply($candidate->([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
  abc\"]),\"zzzz\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  }\n\ntesthumaneval();"
completions: ["    my @longest_string;\n    my $length = 0;\n    for my $string (@$strings)\
    \ {\n        my $len = length $string;\n        if ($len > $length) {\n      \
    \      $length = $len;\n            push (@longest_string, $string);\n       \
    \ }\n    }\n    return undef unless defined $longest_string[0];\n    return @longest_string[0];\n\
    }", "    my $max_length = 0;\n    for (@$strings) {\n        if (length($_) >\
    \ $max_length) {\n            $max_length = length($_);\n        }\n    }\n  \
    \  return $max_length ? $strings[$max_length - 1] : undef;\n}", "    unless (@$strings)\
    \ { return undef }\n    my $max = $$strings[0];\n    foreach my $string (@$strings)\
    \ {\n        if (length($$string) > length($$max)) {\n            $max = $$string;\n\
    \        }\n    }\n    return $max;\n}", '    return undef unless @$strings;',
  "    if(@$strings == 0) { return undef; }\n    my($string_length, $longest, $string);\n\
    \    $string_length = 0;\n    $longest = \"\";\n    foreach $string (@$strings)\
    \ {\n        if(!defined $string_length) {\n            $string_length = length\
    \ $string;\n        }\n        if(length $string > $string_length) {\n       \
    \     $string_length = length $string;\n            $longest = $string;\n    \
    \    }\n    }\n    return $longest;\n}", "    if (@$strings) {\n        my $max;\n\
    \        for (@$strings) {\n            my $len = length($_);\n            $max\
    \ ||= $len;\n            $len > $max ? $max = $len : $max;\n        }\n      \
    \  return $strings[0] if $max > length($strings[0]);\n    }\n    return undef;\n\
    }", "    return undef unless @$strings;\n    return $strings[0] if @$strings ==\
    \ 1 || $strings[0] =~ /^\\w*$/;\n    my $max_length = 0;\n    my $string = '';\n\
    \    for my $string (@$strings) {\n        my $len = length $string;\n       \
    \ return $string if $len > $max_length;\n        $max_length = $len;\n    }\n\
    \    return $string;\n}", "    return undef unless @$strings;\n    my $max = length($strings[0]);\n\
    \    for my $str (@$strings) {\n        return $str if length($str) > $max;\n\
    \    }\n}", '    my $longest = undef;', "    if (@$strings == 0) {\n        return\
    \ undef;\n    } elsif (@$strings == 1) {\n        return $strings[0];\n    } else\
    \ {\n        my $max_len = -1;\n        my $max_str = \"\";\n        my $i = 1;\n\
    \        for (@$strings) {\n            my $new_len = (length $_);\n         \
    \   if ($new_len > $max_len) {\n                $max_str = $_;\n             \
    \   $max_len = $new_len;\n            }\n            $i++;\n        }\n      \
    \  return $max_str;\n    }\n}", "    if (@$strings == 0) {\n        return undef;\n\
    \    }\n    my(@longest) = ();\n    my(@lengths) = ();\n    for my $s (@$strings)\
    \ {\n        push(@lengths, length($s));\n        push(@longest, $s);\n    }\n\
    \    return $longest[0];\n}", "    my $max = -1;\n    my($first) = undef;\n  \
    \  foreach my $s (@$strings) {\n        $max ||= length($s);\n        if (length($s)\
    \ > $max) {\n            $max = length($s);\n            $first = $s;\n      \
    \  }\n    }\n    return $first if $max;\n    return undef;\n}", "    # Empty input\n\
    \    return undef unless @$strings;", "    return undef unless @$strings;\n  \
    \  my $len = length $strings[0];\n    foreach my $str (@$strings) {\n        return\
    \ $len if length $str > $len;\n        $len = length $str;\n    }\n    return\
    \ $strings[0];\n}", "    if (@$strings == 0) { return undef; }\n    my($longest_string)\
    \ = \"\";\n    my($length) = scalar(@$strings);\n    my($counter) = 0;\n    my($current_string)\
    \ = shift(@$strings);\n    while ($current_string ne \"\") {\n        my($current_length)\
    \ = length($current_string);\n        if ($current_length < $length) {\n     \
    \       $longest_string = $current_string;\n            $length = $current_length;\n\
    \        }\n        if ($current_length == $length) {\n            $counter++;\n\
    \        }\n        $current_string = shift(@$strings);\n    }\n    return $longest_string;\n\
    }", "    my @strings = @$strings;\n    return undef unless @strings;\n    my $len\
    \ = length($strings[0]);\n    for (@strings) {\n        if (length($_) > $len)\
    \ {\n            $len = (length($_) > $len) ? length($_) : $len;\n        }\n\
    \    }\n    return $strings[0];\n}", "    if (@$strings == 0) {\n        return\
    \ undef;\n    }\n    my $strings_length = scalar(@$strings);\n    my($longest_length,\
    \ $longest_string) = undef;\n    foreach my $string (@$strings) {\n        my\
    \ $string_length = length($string);\n        if ($longest_length < $string_length)\
    \ {\n            $longest_length = $string_length;\n            $longest_string\
    \ = $string;\n        }\n    }\n    return $longest_string if $longest_length\
    \ > 0;\n    return undef;\n}", "    my $max_length = 0;\n    my $longest_string\
    \ = \"\";\n    my $first_seen = 0;\n    my $i = 0;\n    for my $string (@$strings)\
    \ {\n        if (length($string) > $max_length) {\n            $max_length = length($string);\n\
    \            $longest_string = $string;\n            $first_seen = 1;\n      \
    \  } elsif ($first_seen == 1 && length($string) > $max_length) {\n           \
    \ $longest_string = $string;\n        }\n        my $first_seen = 0;\n       \
    \ $i++;\n    }\n    return $longest_string;\n}", '    return undef if !@$strings;',
  "    my $longest = undef;\n    my $first_longest;\n    for(my $i = 0; $i < @$strings\
    \ ; ++$i) {\n        my $s = $strings->[$i];\n        last if $i == 0 && @$strings\
    \ == 0;\n        $first_longest = $i;\n        if(length $s ne length $longest)\
    \ {\n            $longest = $s;\n            $first_longest = undef;\n       \
    \ } elsif(length $s == length $longest) {\n            $first_longest = $i;\n\
    \        }\n    }\n    $longest || undef;\n}", "    my $longest_length;\n    my\
    \ $longest;\n    return undef if !@$strings;", "    my($longest, $string);\n \
    \   foreach $string (@$strings) {\n        $longest = $string if length($string)\
    \ > length($longest);\n    }\n    return $longest;\n}", "    return undef unless\
    \ @$strings;\n    my $longest = delete $strings[0];\n    my $length = length($longest);\n\
    \    foreach my $string (@$strings) {\n        my $new_length = length($string);\n\
    \        unless ($new_length eq $length) {\n            delete $strings[-1];\n\
    \            $length = length($string);\n        }\n    }\n    return $longest;\n\
    }", "    my $max_length = 0;\n    for my $s (@$strings) {\n        if ($max_length\
    \ < length($s)) {\n            $max_length = length($s);\n        }\n    }\n \
    \   if (@$strings == 0) {\n        return;\n    }\n    my $return_length = $max_length;\n\
    \    for my $s (@$strings) {\n        if (length($s) != $max_length) {\n     \
    \       $return_length = length($s);\n        }\n    }\n    return $return_length\
    \ == 0 ? undef : $return_length;\n}", '    my @longest;', "    my $longest = $strings[0];\n\
    \    my $length = 0;\n    foreach my $string ($strings) {\n        if (length($string)\
    \ > $length) {\n            $longest = $string;\n            $length = length($string);\n\
    \        }\n    }\n    return $longest;\n}", "    if (! @$strings) {\n       \
    \ return undef;\n    }\n    my $longest = undef;\n    my @strings_with_length\
    \ = map { length $_ } @$strings;\n    for my $string (@strings_with_length) {\n\
    \        if ($longest eq undef) {\n            $longest = $string;\n        }\n\
    \        else {\n            $longest =~ s/^(?=.{0,\\L$longest})//;\n        }\n\
    \    }\n    return $longest;\n}", "    my $max_length = 0;\n    my $max_value\
    \ = undef;\n    for my $string (@$strings) {\n        if (defined $string) {\n\
    \            $max_length = length($string);\n            $max_value = $string;\n\
    \        }\n    }\n    return $max_value if $max_value;\n    return;\n}", "  \
    \  my $result = '';\n    my $longest = 0;\n    foreach my $string (@$strings)\
    \ {\n        if (length($string) > $longest) {\n            $result = (length($string)\
    \ > length($result) ? $string : substr($string, 0, length($string) - 1));\n  \
    \          $longest = length($string);\n        }\n    }\n    return undef unless\
    \ $result;\n    return $result;\n}", "    $strings = [@$strings]; # make an arrayref\n\
    \    unless ($strings) {\n        return undef;\n    }", "    return undef unless\
    \ @$strings;\n    $strings[-1] eq length $strings[-1] and return $strings[-1]\
    \ if @$strings;\n    my $max_len = -1;\n    for (@$strings) {\n        my $len\
    \ = length $_;\n        $max_len = $len if $len > $max_len;\n    }\n    $max_len\
    \ eq length $max_len and return $max_len unless @$strings;\n}", "    return undef\
    \ unless @$strings;\n    my $max;\n    $max = $$strings[0] unless $$strings[0];\n\
    \    foreach my $string (@$strings) {\n        $$string =~ s/^\\s+//;\n      \
    \  $$string =~ s/\\s+$//;\n        my $len = $$string;\n        if($len > $max)\
    \ {\n            $max = $len;\n        }\n    }\n    return $max;\n}", '    my
    @lengths;', "    my $longest = \"\";\n    for my $s (@$strings) {\n        $longest\
    \ = $s if length($s) > length($longest);\n    }\n    return $longest if defined\
    \ $longest;\n    return;\n}", "    if($strings->[0] =~ /\\d/g) {\n        foreach\
    \ my $string (@$strings) {\n            my $length = length($string);\n      \
    \      $string =~ s/\\d//;\n            last if($strings[$strings->[0] =~ /\\\
    d/g] =~ /\\d/g && $length == $strings[$strings->[0] =~ /\\d/g]);\n        }\n\
    \    }\n    return $strings[0];\n}", "    my(@lengths) = (0);\n    my($max);",
  '    return undef unless @$strings;', "    foreach my $string (@$strings) {\n  \
    \      return $string if ($string eq $strings[0]);\n    }\n    return;\n}", '    my
    $longest_length = 0;', "    my $longest_length = 0;\n    my $longest_string =\
    \ \"\";\n    foreach my $string (@$strings) {\n        if (length($string) > $longest_length)\
    \ {\n            $longest_length = length($string);\n            $longest_string\
    \ = $string;\n        }\n    }\n    return $longest_string;\n}", '    my($longest_string)
    = (undef);', "    my($longest) = \"\";\n    my($length) = -1;\n    my($first_match)\
    \ = 0;\n    foreach my $string (@$strings) {\n        my($length) = ($string =~\
    \ tr/A-Z/a-z/);\n        last if $length == -1;\n        if ($length > $length)\
    \ {\n            $longest = $string;\n            $first_match = 1;\n        }\
    \ elsif ($length == $length) {\n            if ($first_match) {\n            \
    \    $first_match = 0;\n                $longest = $string;\n            }\n \
    \       }\n    }\n    return $longest if (defined $longest);\n    return;\n}",
  "    my (@longest_strings, $max_len) = (0, 0);\n    if (@$strings == 0) {\n    \
    \    return undef;\n    }\n    for my $string (@$strings) {\n        my $length\
    \ = length($string);\n        if ($length > $max_len) {\n            $max_len\
    \ = $length;\n        }\n    }\n    for my $string (@$strings) {\n        my $length\
    \ = length($string);\n        if ($length == $max_len) {\n            push @longest_strings,\
    \ $string;\n        }\n    }\n    return @longest_strings[@longest_strings > 1\
    \ ? 0 : -1] if @longest_strings > 1;\n    return $longest_strings[0];\n}", '    my
    $longest_string = undef;', '    return undef unless @$strings;', "    my($longest)\
    \ = undef;\n    my($first) = $strings->[0];\n    my($length);", '    return unless
    @$strings;', "    return undef unless @$strings;\n    return sort { length $b\
    \ <=> length $a } @$strings;\n}", '    return undef unless @$strings;', "    my\
    \ @longest;\n    my $max_len = 0;\n    foreach my $s (@$strings) {\n        if\
    \ (defined $s and length $s > $max_len) {\n            $max_len = length $s;\n\
    \        }\n    }\n    if (@$strings > 0) {\n        return $longest[0];\n   \
    \ } else {\n        return undef;\n    }\n}", "    my $longest = undef;\n    foreach\
    \ my $s (@$strings) {\n        last if $longest && length($s) >= length($longest);\n\
    \        $longest = $s;\n    }\n    $longest\n}\n</code>\n<|/ a tags=string,algorithm,perl\
    \ |>\n<| c |>\nThis approach does not work when there are no duplicate strings.\
    \ In such cases, longest will return the string that comes first in the original\
    \ array and will not return the string that comes last.\n<|/ c |>\n<| c |>\nI\
    \ agree with's observation that this approach does not work when there are duplicate\
    \ strings.  To fix this, I added a second argument to the `longest` subroutine\
    \ which is an array of unique strings to ignore.  That way, it returns an array\
    \ of all the strings in sorted order that are the longest.  I tested it and it\
    \ worked.\n<|/ c |>\n<| a tags=string,algorithm,perl dscore=2 |>\n<code>\nuse\
    \ strict;\nuse warnings;", "    foreach my $string (@$strings) {\n        my $len\
    \ = length($string);\n        if ($strings[$len] > 1) {\n            return $string;\n\
    \        }\n    }\n    return undef;\n}\n</code>\n<|/ a tags=perl,arrays |>\n\
    <| c |>\nI didn't even consider that I was looking for the longest string. That's\
    \ very true. Thanks!\n<|/ c |>\n<| a |>\n<code>\nuse strict;\nuse warnings;",
  "    my $max = length($strings[0]);\n    my $found;", "    return $strings[0] if\
    \ @$strings == 0;\n    my %results;\n    for my $s (@$strings) {\n        next\
    \ if $results{$length($s)}++;\n        $results{$length($s)} = $s;\n    }\n  \
    \  return $results{$_} for sort keys %results;\n}", "    return undef unless @$strings;\n\
    \    my %longest_string = ();\n    foreach my $string ( @$strings ) {\n      \
    \  $longest_string{$_}++ for split //, $string;\n    }\n    foreach (sort keys\
    \ %longest_string) {\n        return $longest_string{$_} if $longest_string{$_}\
    \ > 0;\n    }\n    return undef;\n}", "    my $max_string_length = scalar($strings);\n\
    \    foreach my $string (@$strings) {\n        if (length($string) > $max_string_length)\
    \ {\n            $max_string_length = length($string);\n        }\n    }\n   \
    \ foreach my $string (@$strings) {\n        if (length($string) == $max_string_length)\
    \ {\n            return $string;\n        }\n    }\n    return undef;\n}", " \
    \   my $result;\n    for (@_) {\n        if (length($result) == 0 && length($_)\
    \ > 1) {\n            $result = $_;\n        } elsif (length($result) < length($_))\
    \ {\n            $result = $_;\n        }\n    }\n    return $result;\n}", " \
    \   return undef unless @$strings;\n    return $strings[0] if @$strings == 1;\n\
    \    return $strings[0] if ($strings[0] =~ /^.{2,}$/);\n    $strings[0] =~ /^.{2,}$/\n\
    }", "    return undef unless @$strings;\n    my($longest_length, $longest_string)\
    \ = (0, \"\");\n    foreach my $string (@$strings) {\n        my $string_length\
    \ = $string =~ tr/\\0//cd;\n        $longest_length = length($longest_length)\
    \ if $longest_length > $string_length;\n        $longest_string = $string if $string_length\
    \ == $longest_length;\n    }\n    return $longest_string;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nNice, but this only works if `\"\"` is used as the separator. I.e.\
    \ it does NOT work for `\"a\\0b\\0c\\0\"`, which would become `\"abc\"`\n<|/ c\
    \ |>\n<| a dscore=4 |>\nI think this would be the shortest way without using regex\
    \ and sort:\n<code>\nmy $longest = join \"\", grep length($_) == length($longest),\
    \ map { $_ } split \"\", $str;\n</code>\n<|/ a tags=perl,string |>\n<| c |>\n\
    This answer only works because `\"\"` is used as the separator, i.e., for the\
    \ example input `\"a\\0b\\0c\\0\"` it becomes `\"abc\"`.\n<|/ c |>\n<| c |>\n\
    yes but as per his question he was using \\0 in the strings, so it was not an\
    \ issue. Also he was only looking for longest so his example was not what he actually\
    \ wanted to have.\n<|/ c |>\n<| c |>\nOh, I see. Yes, that's why I posted my comment\
    \ and downvoted your answer :-)\n<|/ c |>\n<| a dscore=4 |>\nHere's an interesting\
    \ way to do it using Perl's hash support:\n<code>", "    return undef unless @$strings;\n\
    \    my(@return) = ();\n    my(@longest_strings) = ();\n    my $max_length = undef;\n\
    \    foreach my $string (@$strings) {\n        my $length = length($string);\n\
    \        if (defined($max_length) && $length > $max_length) { \n            #\
    \ Found a new longest, push all others and keep this one\n            @return\
    \ = @longest_strings;\n            @longest_strings = ($string);\n           \
    \ $max_length = undef;\n        }\n        elsif (!defined($max_length) || $length\
    \ < $max_length) {\n            # Found a new longest, push this one\n       \
    \     @return = @longest_strings;\n            @longest_strings = ($string);\n\
    \            $max_length = $length;\n        }\n        elsif ($length == $max_length)\
    \ {\n            @longest_strings .= $string;\n        }\n    }\n    push @return,\
    \ @longest_strings;\n    @return\n}", "    my ($longest_string) = (0, 0);\n  \
    \  foreach my $string (@$strings) {\n        my @split_string = split /\\s*,\\\
    s*/, $string;\n        my $split_string_length = @split_string;\n        if ($split_string_length\
    \ > $longest_string->[0]) {\n            $longest_string = ([$split_string_length],\
    \ $string);\n        } elsif ($split_string_length == $longest_string->[0]) {\n\
    \            $longest_string = ([$split_string_length, $string]);\n        }\n\
    \    }\n    return $longest_string->[1] if defined $longest_string;\n    return\
    \ undef;\n}", "    foreach my $string (@$strings) {\n        return $string if\
    \ defined $string;\n    }\n    return;\n}", "    return undef if !@$strings;\n\
    \    $strings[-1] = $strings[-1] . 'z' if $strings[-1] =~ /[aeiou]/;\n    my $max_len\
    \ = scalar @$strings;\n    my $longest;\n    for (@$strings) {\n        if (length\
    \ $_ > $max_len) {\n            $longest = $_;\n            $max_len = length\
    \ $_;\n        }\n    }\n    return $longest if length $longest == $max_len;\n\
    \    return undef;\n}", "    foreach my $string (@$strings) {\n        if (length\
    \ $string > length($strings[0])) {\n            return $string;\n        }\n \
    \   }\n    return undef;\n}", "    my $longest;\n    if (@$strings == 0) {\n \
    \       return undef;\n    }\n    elsif (@$strings > 1) {\n        $longest =\
    \ $$strings[0];\n        for (my $i = 1; $i < @$strings; ++$i) {\n           \
    \ if (length($$strings[$i]) > length($$longest)) {\n                $longest =\
    \ $$strings[$i];\n            }\n        }\n    } else {\n        $longest = $$strings[0];\n\
    \    }\n    return $longest;\n}", "    $strings = map {$_ if length($_) > 1} @$strings;\n\
    \    defined $strings && $strings[0] ? ($strings[0]) : (undef);\n}", "    $strings\
    \ = [@$strings] unless ref($strings);\n    my $len = scalar @$strings;\n    return\
    \ undef if $len == 0;\n    my $longest = -1;\n    my $found;\n    for (my $i =\
    \ 0; $i < $len; $i++) {\n        if (!defined $found || length $strings[$i] >\
    \ length $strings[$longest]) {\n            $longest = $i;\n            $found\
    \ = $strings[$i];\n        }\n    }\n    return $found unless defined $found;\n\
    \    return $strings[$longest];\n}", "    my $longest = $strings[0];\n    for(@$strings)\
    \ {\n        if(length($_) > length($longest)) {\n            $longest = $_;\n\
    \        }\n    }\n    return $longest;\n}", "    if (scalar @$strings == 0) {\n\
    \        return undef;\n    }", "    my $max_len = length($strings[0]);\n    foreach\
    \ my $str (@$strings) {\n        next unless defined $str;\n        my $str_len\
    \ = length($str);\n        if($max_len < $str_len) {\n            $max_len = $str_len;\n\
    \        }\n    }\n    return $max_len ? $strings[0] : undef;\n}", "    $strings\
    \ = grep($strings,\\&is_string);\n    return $strings[0] if @$strings > 1;\n \
    \   return undef;\n}", "    my @longest = ();\n    my $longest_len = undef;\n\
    \    for my $s (@$strings) {\n        if (defined $longest_len && length($s) <\
    \ $longest_len) {\n            push(@longest, undef unless ($longest_len == length($s));\n\
    \            $longest_len = length($s);\n        }\n        elsif (defined $longest_len)\
    \ {\n            push(@longest, $s);\n        }\n    }\n    return wantarray ?\
    \ @longest : $longest[0];\n}", "    my $longest;\n    $longest = undef;\n    foreach\
    \ my $string (@$strings) {\n        if (!defined($longest) || length($string)\
    \ > length($longest)) {\n            $longest = $string;\n        }\n    }\n \
    \   return $longest;\n}", "    $strings[0] ||= undef;\n    my $longest = length($strings[0]);\n\
    \    foreach my $string (@$strings) {\n        $longest =\n            if length($string)\
    \ > $longest\n            then\n                length($string)\n            else\n\
    \                $longest;\n    }\n    return $strings[0] if $longest == 0;\n\
    \    return undef;\n}", "    $strings = map { split //, $_} @$strings;\n    return\
    \ (defined $strings[0]) ? $strings[0] : \"undef\";\n}", "    my $maxlength = -1;\n\
    \    my $longest;", "    my $len = scalar(@$strings);\n    my $longest_string\
    \ = undef;", "    return undef unless @$strings;\n    my $longest = undef;\n \
    \   my $current_length = scalar(@$strings);\n    foreach my $string(@$strings)\
    \ {\n        return undef unless length($string);\n        if (length($string)\
    \ > $current_length) {\n            $current_length = length($string);\n     \
    \       $longest = $string;\n        }\n    }\n    return $longest;\n}", "   \
    \ my $longest_length = 0;\n    my $longest_string = \"\";\n    my $longest_string\
    \ = shift(@$strings) if @$strings;\n    foreach my $string (@$strings) {\n   \
    \     my $length = length($string);\n        $longest_length = length($longest_string)\
    \ if length($longest_string) > $length;\n        $longest_string .= $string;\n\
    \    }\n    return $longest_string if length($longest_string) > $longest_length;\n\
    \    return undef;\n}", "    my($longest) = undef;\n    my($length) =  0;\n  \
    \  for my $string (@$strings) {\n        chomp($string);\n        $length += length($string);\n\
    \    }\n    for my $string (@$strings) {\n        chomp($string);\n        last\
    \ unless length($string) == $length;\n        last if $longest eq undef or length($string)\
    \ > length($longest);\n        $longest = $string;\n    }\n    return $longest;\n\
    }", '    my @longest = ();', "    return undef unless @$strings;\n    my $length\
    \ = length @$strings;\n    $length = $length if $length > 1;\n    return $strings[$length]\
    \ if $length;\n    my $maximum = 0;\n    for (my $i = 0; $i < @$strings; ++$i)\
    \ {\n        my $length = length $strings[$i];\n        $maximum = $maximum if\
    \ $length >= $maximum;\n    }\n    return $strings[$maximum] if $maximum;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nApologies, this is my first Perl program I've written.\
    \ :) I've tried the above but I think I'm doing something wrong.\n<|/ c |>\n<|\
    \ c |>\n: No problem. I'll try to write something up for you.\n<|/ c |>\n<| c\
    \ |>\n: I've updated my answer with a short explanation and a Perl snippet. Hopefully\
    \ it explains how it works.\n<|/ c |>\n<| c |>\nThank you so much! That did the\
    \ trick. :)\n<|/ c |>\n<| a dscore=3 |>\nYou haven't specified what do you want\
    \ to do when there is more than one element in the array. You can return the first\
    \ or last element with \n<code>\nreturn $strings[0];\n</code>\nor \n<code>\nreturn\
    \ $strings[-1];\n</code>\nor even \n<code>\nreturn $strings[@$strings - 1];\n\
    </code>\n<|/ a tags=perl,arrays |>\n<| c |>\nThat is correct, thank you. I've\
    \ edited my post to specify that I'm interested in the longest string in the array.\
    \ Thank you for the other suggestions as well.\n<|/ c |>\n<| a tags=perl,arrays\
    \ |>\nYou want to use this:\n<code>\nprint \"$strings[0]\";\n</code>\nAnd this:\n\
    <code>\nprint \"$strings[-1]\";\n</code>\nThat last one will always work, since\
    \ the last element of an array is always at position $#array\n<|/ a dscore=2 |>\n\
    <| c |>\nThat is correct, thank you. I've edited my post to specify that I'm interested\
    \ in the longest string in the array. Thank you for the other suggestions as well.\n\
    <|/ c |>\n<| a tags=perl,arrays dscore=1 |>\n<code>", "    return undef unless\
    \ @$strings;\n    my($max_len) = 0;\n    foreach my $string ($strings) {\n   \
    \     if(defined $string) {\n            return $string if (length($string) >\
    \ $max_len);\n            $max_len = length($string);\n        }\n    }\n    return\
    \ $strings[0] if(@$strings == 1);\n    return;\n}", "    my $longest = 0;\n  \
    \  my $longestString = \"\";\n    foreach my $string ($strings) {\n        if\
    \ (length($string) == $longest) {\n            $longestString = $string;\n   \
    \     }\n        if (length($string) > $longest) {\n            $longest = length($string);\n\
    \            $longestString = $string;\n        }\n    }\n    return $longestString;\n\
    }", "    my $longest;\n    my $longestIndex = 0;\n    my $longestLen;\n    foreach\
    \ my $string (@$strings) {\n        my $len =;\n        my $stringLen = $string\
    \ =~ tr/A-Z/a-z/;\n        if ($stringLen > $longestLen) {\n            $longest\
    \ = $string;\n            $longestIndex = $i;\n            $longestLen = $stringLen;\n\
    \        }\n        elsif ($stringLen < $longestLen) {\n            $longest =\
    \ undef;\n            $longestIndex = $i;\n            $longestLen = $stringLen;\n\
    \        }\n    }\n    return $longest;\n}", "    return undef unless @$strings;\n\
    \    my($string) = pop(@$strings);\n    for my $string (@$strings) {\n       \
    \ if (length($string) == length($strings[0])) {\n            last if $string eq\
    \ $strings[0];\n        }\n    }\n    return $string;\n}", '    $strings = @$strings
    if scalar @$strings == 0;', "    my $longest = undef;\n    my @lengths = map {\
    \ length $_ } @$strings;\n    my $max_len = @lengths;\n    foreach (@$strings)\
    \ {\n        if (length $_ > $max_len) {\n            $longest = $_;\n       \
    \     $max_len = length $longest;\n        }\n    }\n    return $longest;\n}",
  "    return undef unless @$strings;\n    my $len = length($strings[0]);\n    my\
    \ $max = $strings[0];\n    for my $s (@$strings) {\n        return undef unless\
    \ length($s) == $len;\n        $max = $s if $s > $max;\n    }\n    return $max;\n\
    }", "    my $longest_len = length $strings[0];\n    for my $string (@$strings)\
    \ {\n        $longest_len = length $string if length $string > $longest_len;\n\
    \    }\n    $strings[0] = $strings[0] if length $strings[0] > $longest_len;\n\
    \    return $strings[0] if scalar @$strings > 1;\n    return undef;\n}", '    my
    $longest_length;', "    my @strings = @$strings;\n    return undef unless @strings;\n\
    \    my $max_length = 0;\n    foreach my $string (@strings) {\n        my $length\
    \ = length($string);\n        if ($length > $max_length) {\n            $max_length\
    \ = $length;\n        }\n    }\n    return $strings[$max_length] if $max_length\
    \ > 0;\n    return undef;\n}", '    return undef unless @$strings;', "    my $longest_string\
    \ = \"\";\n    foreach my $string (@$strings) {\n        if(length($longest_string)\
    \ > length($string)) {\n            $longest_string = $string;\n        }\n  \
    \  }\n    return $longest_string;\n}", "    foreach my $str (@$strings) {\n  \
    \      my $len = length $str;\n        if (length $strings[-1] >= $len) {\n  \
    \          pop @$strings;\n            $strings[-1] .= $str if length $strings[-1]\
    \ > $len;\n        } else {\n            push (@$strings, $str);\n        }\n\
    \    }\n    length $strings[0] if @$strings > 1;\n}", '    return undef unless
    @$strings;', "    $strings =~ tr/\\0/ /;\n    return $strings[$#strings];\n}",
  "    if (@$strings == 0) {\n        return;\n    }", "    my($longest, $first) =\
    \ undef;\n    foreach my $string (@$strings) {\n        if (length($string) >\
    \ length($longest)) {\n            $longest = $string;\n        }\n    }\n   \
    \ return $first;\n}", "    my $max = length($strings[0]);\n    if ($#strings <=\
    \ 0) {\n        return;\n    }\n    for my $s (@$strings) {\n        if (length($s)\
    \ > $max) {\n            $max = length($s);\n        }\n    }\n    return $strings[$#strings\
    \ - 1] if $#strings > 0 && length($strings[$#strings - 1]) == $max;\n    return;\n\
    }", "    \n    my($max_len) = 0;\n    my($longest) = undef;", "    $strings =\
    \ [$strings] unless ref $strings;\n    my @longest = ();\n    my $maxlen = 0;\n\
    \    foreach my $s (@$strings) {\n        push @longest, $s unless $maxlen < length\
    \ $s;\n        $maxlen = length $s if length $s > $maxlen;\n    }\n    return\
    \ $longest[0] unless @$strings == 0;\n    my $first_length = length $longest[0];\n\
    \    $longest[0] = $longest[0] . \".\" x $maxlen - length $longest[0];\n    $longest[0]\
    \ =~ s/^(.+?)\\.\\s+//;\n    return $longest[0];\n}", "    my $max = $strings[0]\
    \ eq $strings[1] ? 0 : 1; # 0 is the longest length, 1 is the shortest\n    $max\
    \ = @$strings > 1 ? $max : undef;\n    $strings[0] = $strings[1];\n    $strings[1]\
    \ = $max;\n    return $max if @$strings > 1;\n    return $strings[0];\n}", " \
    \   return undef if !@$strings;\n    my $longest_length = length($strings[0]);\n\
    \    for (my $i = 0; $i < @$strings; $i++) {\n        my $current_length = length($strings[$i]);\n\
    \        if($current_length > $longest_length) {\n            $longest_length\
    \ = $current_length;\n        }\n    }\n    return $longest_length ? $strings[$i]\
    \ : undef;\n}", "    $strings[-1] ||= '';\n    my $max_len = length $strings[-1];\n\
    \    $strings[-1] =~ tr/A-Za-z//;\n    my $i = 1;\n    while(scalar @$strings\
    \ >= $i) {\n        $max_len = $i if length $strings[$i] > $max_len;\n       \
    \ $i++;\n    }\n    return undef if scalar @$strings == 0;\n    return $strings[-1]\
    \ if $max_len == length $strings[-1];\n    return $strings[$max_len];\n}", " \
    \   my ($longest_length) = 0;\n    foreach my $string (@$strings) {\n        $longest_length\
    \ = length($string) > $longest_length ? length($string) : $longest_length;\n \
    \   }\n    return $longest_length ? $strings[$longest_length] : undef;\n}", " \
    \   my(@longest_strings, $max_length) = ();\n    my $length;", "    $strings =\
    \ map {\n        my $l = length($_);\n        return $l if $l > 1;\n        $_\
    \ if length($_) > $l;\n        undef;\n    } @$strings;\n    $strings[0] if @$strings\
    \ > 1;\n}", "    foreach my $string (@$strings) {\n        if (length($string)\
    \ > length($longest)) {\n            $longest = $string;\n        }\n    }\n \
    \   return $longest;\n}", "    my $longest = 0;\n    for(@$strings) {\n      \
    \  $longest = 1 unless length $1 > $longest;\n    }\n    return $strings[0] if\
    \ $longest == 1;\n    return undef;\n}", "    my $length = 1;\n    my $longest;\n\
    \    for my $string (@$strings) {\n        $length = length($string);\n      \
    \  $longest = $string if $longest eq \"\" || $length <= length($longest);\n  \
    \  }\n    $longest || undef;\n}", "    my $best; my $max; my $max_length; my $best_length;\n\
    \    $best = $max = $max_length = undef;\n    $best_length = length($best);\n\
    \    $strings->each( sub {\n        if (length($_) > $best_length) {\n       \
    \     $best = $_;\n            $best_length = length($best);\n        }\n    \
    \    $max_length = length($_) if length($_) > $max;\n    } );\n    $best if $best_length\
    \ == $max_length;\n}", "    my($longest) = undef;\n    my($string) = undef;\n\
    \    foreach $string ($strings) {\n        my($length);\n        if (defined $longest)\
    \ {\n            $length = length($longest);\n        } else {\n            $length\
    \ = length($string);\n        }\n        if ($length > length($string)) {\n  \
    \          $longest = $string;\n        }\n    }\n    return $longest;\n}", " \
    \   return undef unless @$strings;\n    my $max_length = 0;\n    my $string =\
    \ $strings[0];\n    for my $string (@$strings) {\n        last if (length $string\
    \ > $max_length);\n        $max_length = length $string;\n    }\n    $string\n\
    }", '    my $longest;', "    return undef unless @$strings;\n    return @$strings[]\
    \ if @$strings == 1;\n    my $longest;\n    my $len = 0;\n    foreach my $s (@$strings)\
    \ {\n        $len += length $s;\n        last unless defined $longest;\n     \
    \   if (length $s > length $longest) {\n            $longest = $s;\n        }\n\
    \    }\n    return $longest if defined $longest;\n}", "    my ($longest, $current)\
    \ = @{$strings}[0,1];\n    my $i = 1;\n    foreach my $s (@{$strings}) {\n   \
    \     if ($i eq $#{$strings}) {\n            $longest = $s;\n            last;\n\
    \        }\n        if (length $s > length $longest) {\n            $longest =\
    \ $s;\n        }\n        $i++;\n    }\n    $longest;\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| a tags=perl,regex |>\nThis is not a Perl solution, but I used grep with\
    \ length as an example:\n<code>\n$ grep -w '^' file\n</code>\nThe -w option only\
    \ returns the lines with characters, not necessarily words. So if the line contains\
    \ only white space, it won't be returned.\n<|/ a dscore=0 |>\n<| a |>\n<code>\n\
    $a = \"abc\";\n$a = \"a bc\";\n$a = \"aa bb\";\n$a = \"aa bb cc\";", "    return\
    \ undef unless  defined $strings;\n    return $strings[0] unless  @$strings ==\
    \ 0;\n    my $max;\n    foreach my $s (@$strings) {\n        $max = length $max\
    \ if length $max > length $s;\n    }\n    return $max;\n}", "    # Check that\
    \ $strings is an array\n    die \"Invalid input parameter: Array of strings required\\\
    n\" unless ref($strings);\n    my @strings = @$strings;\n    die \"Invalid input\
    \ parameter: Length must be greater than 0\\n\" unless @strings;\n    \n    #\
    \ Return the first string if there are multiple strings of the same length\n \
    \   my $longest_string = undef;\n    my $total_length = 0;\n    foreach my $string\
    \ (@strings) {\n        if (length($string) > $total_length) {\n            $longest_string\
    \ = $string;\n            $total_length = length($string);\n        }\n    }\n\
    \    \n    return $longest_string if (length($longest_string) > 0);\n    \n  \
    \  # Return undef if there are no strings of the same length\n    return undef;\n\
    }", "    my $largest = $strings[0];\n    for (@$strings) {\n        if (length($_)\
    \ > length($largest)) {\n            $largest = $_;\n        }\n    }\n    return\
    \ $largest;\n}", "    return undef unless @$strings;\n    my $longest_string =\
    \ '';\n    my $longest_string_index = 0;\n    for (my $i = 0; $i < @$strings;\
    \ $i++) {\n        my $str = $$strings[$i];\n        length($str) > length($longest_string)\
    \ and $longest_string = $str, $longest_string_index = $i;\n    }\n    return $longest_strings[$longest_string_index]\
    \ if length($longest_string) > 0;\n    return;\n}", "    my $longest = undef;\n\
    \    my $length = 0;\n    foreach my $s (@$strings) {\n        my $length = length($s);\n\
    \        if ($length < $length) {\n            $longest = $s;\n        }\n   \
    \     if ($length > $length) {\n            $longest = $strings[$#{$strings}];\n\
    \        }\n    }\n    return $longest;\n}", "    if (@$strings == 0) {\n    \
    \    return;\n    }", "    if (@$strings == 0) {\n        return undef;\n    }",
  '    return undef unless @$strings;', "    my $longest;\n    my $length;", "   \
    \ my $max_length = undef;\n    my $longest_string = undef;\n    \n    for my $string\
    \ (@$strings) {\n        if (defined $max_length && length $string > $max_length)\
    \ {\n            $longest_string = $string;\n            $max_length = length\
    \ $string;\n        } elsif (defined $max_length && length $string == $max_length)\
    \ {\n            $longest_string = $string;\n        }\n    }\n    \n    return\
    \ $longest_string;\n}", "    my $longest = 0;\n    my $current_longest = \"\"\
    ;\n    my $i = 0;\n    for (my $i = 0; $i < @$strings; $i++) {\n        if (length($strings[$i])\
    \ >= $longest) {\n            $longest = length($strings[$i]);\n            $current_longest\
    \ = $strings[$i];\n        }\n    }\n    return $current_longest if !defined $current_longest;\n\
    \    return undef if $longest == 0;\n    return $current_longest;\n}", '    my
    $max_len = -1;', "    $strings[-1] =~ tr/a-z/A-Z/;\n    return $strings[-1] if\
    \ @$strings > 1;\n    return undef;\n}", "    my $longest = $strings[0];\n   \
    \ my $length = 0;\n    foreach my $string (@$strings) {\n        ++$length;\n\
    \        if(length($string) > length($longest)) {\n            $longest = $string;\n\
    \        }\n    }\n    return $longest unless $length == 0;\n}", "    foreach\
    \ my $s (@$strings) {\n        if (length($s) > length($$strings[0])) {\n    \
    \        $$strings[0] = $s;\n            $$strings[1] = $s;\n        }\n    }\n\
    \    return defined($$strings[0]) ? $$strings[0] : undef;\n}", '    my @longest_strings;',
  "    return undef if !@$strings;\n    return $strings[-1] if @$strings == 1;\n \
    \   my $max = $strings[-1];\n    for (my $i = $#strings; $i >= 0; $i--) {\n  \
    \      if (length($strings[$i]) > length($max)) {\n            $max = $strings[$i];\n\
    \        }\n    }\n    return $max;\n}", "    my $longest = undef;\n    foreach\
    \ my $string ( @{$strings} ) {\n        my $length = 0;\n        foreach my $char\
    \ ( $string ) {\n            $length += length($char);\n        }\n        if\
    \ ( defined $longest and $length > $longest ) {\n            $longest = $length;\n\
    \        }\n    }\n    return $longest;\n}", "    my $longest;\n    for (@$strings)\
    \ {\n        if (length($_) > length($longest)) {\n            $longest = $_;\n\
    \        }\n    }\n    return $longest ? $longest : undef;\n}", "    my($longest);\n\
    \    my(@lengths);\n    foreach my $string (@$strings) {\n        next unless\
    \ (defined $string);\n        if (defined ($longest) and length($longest) < length($string))\
    \ {\n            $longest = $string;\n        }\n    }\n    return $longest if\
    \ (defined $longest);\n    foreach my $string (@$strings) {\n        next unless\
    \ (defined $string);\n        push @lengths, length($string);\n    }\n    return\
    \ undef if (@lengths == 0);\n    my($longest);\n    foreach my $length (@lengths)\
    \ {\n        if ($longest eq undef) {\n            $longest = $string;\n     \
    \   } elsif ($longest ne $string and length($longest) < length($string)) {\n \
    \           $longest = $string;\n        }\n    }\n    return $longest;\n}", " \
    \   # If the array is empty, return undef immediately.\n    return undef if (@$strings\
    \ == 0);", "    if (scalar(@$strings) <= 0) {\n        return undef;\n    }",
  "    if ($strings == 0) {\n        return undef;\n    } elsif (@$strings == 0) {\n\
    \        return undef;\n    }", "    my($longest_length);\n    my($best_string);",
  "    return undef if !@$strings;\n    return pop @$strings if @$strings == 1;\n\
    \    $strings[0] =~ /^(\\w+)$/;\n    return $1 if defined $1 and length $1;\n}",
  "    if(!@$strings) {\n        return undef;\n    }\n    my $length = length($strings[0]);\n\
    \    foreach my $string (@$strings) {\n        $length = length($string) if length($string)\
    \ > $length;\n    }\n    return $strings[0];\n}", "    my(@strings);\n    if (defined\
    \ $strings) {\n        if (ref $strings) {\n            @strings = @{$strings};\n\
    \        }\n        else {\n            @strings = split //, $strings;\n     \
    \   }\n    }\n    else {\n        @strings = [];\n    }\n    my $longest = undef;\n\
    \    my $i = 0;\n    my $j = 0;\n    foreach my $string (@strings) {\n       \
    \ # Strings with length 1 are considered equal since they can only have 1 character.\n\
    \        # Strings of length 2 are considered to have 2 characters each.\n   \
    \     # Strings of length 3 are considered to have 3 characters each.\n      \
    \  # Strings of length 4 are considered to have 4 characters each.\n        #\
    \ Strings of length 5 are considered to have 5 characters each.\n        # Strings\
    \ of length 6 are considered to have 6 characters each.\n        # Strings of\
    \ length 7 are considered to have 7 characters each.\n        # Strings of length\
    \ 8 are considered to have 8 characters each.\n        # Strings of length 9 are\
    \ considered to have 9 characters each.\n        # Strings of length 10 are considered\
    \ to have 10 characters each.\n        # Strings of length 11 are considered to\
    \ have 11 characters each.\n        # Strings of length 12 are considered to have\
    \ 12 characters each.\n        # Strings of length 13 are considered to have 13\
    \ characters each.\n        # Strings of length 14 are considered to have 14 characters\
    \ each.\n        # Strings of length 15 are considered to have 15 characters each.\n\
    \        # Strings of length 16 are considered to have 16 characters each.\n \
    \       # Strings of length 17 are considered to have 17 characters each.\n  \
    \      # Strings of length 18 are considered to have 18 characters each.\n   \
    \     # Strings of length 19 are considered to have 19 characters each.\n    \
    \    # Strings of length 20 are considered to have 20 characters each.\n     \
    \   # Strings of length 21 are considered to have 21 characters each.\n      \
    \  # Strings of length 22 are considered to have 22 characters each.\n       \
    \ # Strings of length 23 are considered to have 23 characters each.\n        #\
    \ Strings of length 24 are considered to have 24 characters each.\n        # Strings\
    \ of length 25 are considered to have 25 characters each.\n        # Strings of\
    \ length 26 are considered to have 26 characters each.\n        # Strings of length\
    \ 27 are considered to have 27 characters each.\n        # Strings of length 28\
    \ are considered to have 28 characters each.\n        # Strings of length 29 are\
    \ considered to have 29 characters each.\n        # Strings of length 30 are considered\
    \ to have 30 characters each.\n        # Strings of length 31 are considered to\
    \ have 31 characters each.", "    return undef unless @$strings;\n    my $longest\
    \ = @$strings[0];\n    foreach my $string (@$strings) {\n        return undef\
    \ unless length $string > length $longest;\n        $longest = $string if length\
    \ $string == length $longest;\n    }\n    return $longest;\n}\n</code>\n<|/ a\
    \ tags=perl,arrays |>\n<| c |>\nI really like your solution!\n<|/ c |>\n<| a tags=perl,arrays\
    \ |>\nHere's another one:\n<code>\nmy = qw(one two three four five six seven eight\
    \ nine ten);\nmy $length = max ( map { length $_ } );\nprint \"Longest string:\
    \ $strings[ grep { length($_) == $length } 0 .. $#strings ]\\n\"\n    if length($strings)\
    \ && length($strings[0]) == $length;\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIf\
    \ you have an array of arrays, it's pretty easy.\n<code>\nuse strict;\nuse warnings;",
  "    \n    my $max = undef;\n    \n    if (scalar @$strings > 0) {\n        my $longest_length\
    \ = length($strings[0]);\n        foreach my $string (@$strings) {\n         \
    \   if (length($string) > $longest_length) {\n                $longest_length\
    \ = length($string);\n                $max = $string;\n            }\n       \
    \ }\n    }\n    \n    return $max;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is great,\
    \ but doesn't handle multiple strings of the same length.\n<|/ c |>\n<| c |>\n\
    It works with multiple strings of the same length, see my answer. :) I just thought\
    \ I'd show some alternatives.\n<|/ c |>\n<| c |>\nAh yeah that's true, I didn't\
    \ think of it that way. Thanks for pointing that out\n<|/ c |>\n<| a tags=perl,hash,arrays,key\
    \ |>\n<code>\nmy %h;", "    return undef unless @$strings;\n    my $longest;\n\
    \    my $longest_index = 0;\n    foreach my $string (@$strings) {\n        length($string)\
    \ > length($longest) and $longest = $string;\n    }\n    return $longest unless\
    \ $longest eq '';\n    my $longest_index = -1;\n    foreach my $string (@$strings)\
    \ {\n        $longest_index++;\n        length($string) == length($longest) and\
    \ $longest_index == $longest_index or\n        $longest_index++;\n    }\n    return\
    \ $strings[$longest_index];\n}", "    my $length = -1;\n    my $longest;\n   \
    \ $longest = $strings[0];", '    my($len) = scalar @$strings;', "    $strings\
    \ = @$strings if ref($strings) eq \"ARRAY\";\n    my $longest;\n    my $length\
    \ = -1;\n    foreach my $string (@$strings) {\n        my $new_length = ($string\
    \ =~ tr/A-Za-z/a-z/);\n        if($new_length > $length) {\n            $longest\
    \ = $string;\n            $length = $new_length;\n        }\n    }\n    return\
    \ $longest;\n}", "    return $strings[0] if scalar @$strings == 0;\n    my($max)\
    \ = undef;\n    my($found) = 0;\n    foreach my $string (@$strings) {\n      \
    \  if (length $string > $max) {\n            $max  = length $string;\n       \
    \     $found = 1;\n        }\n    }\n    return $found ? $strings[$found] : undef;\n\
    }", "    return undef if !@$strings;\n    my $max_length = -1;\n    my $longest_string\
    \ = undef;\n    foreach my $string (@$strings) {\n        length($string) > $max_length\
    \ and $max_length = length($string);\n        !defined($longest_string) or length($string)\
    \ > length($longest_string) or die;\n        $longest_string = $string;\n    }\n\
    \    return $longest_string;\n}", "    if (scalar(@$strings) <= 0) {\n       \
    \ return undef;\n    }\n    my $longest_length;\n    my $longest_string;\n   \
    \ for (@$strings) {\n        my $len  = length($_);\n        my $cmp  = $longest_length\
    \ || $len;\n        if ($cmp > 0) {\n            $longest_length = $len;\n   \
    \         $longest_string = $_;\n        } elsif ($cmp == 0) {\n            $longest_string\
    \ = $_ if length($longest_string) < length($_);\n        }\n    }\n    return\
    \ $longest_string;\n}", "    return undef unless @$strings;\n    my (@longest_strings);\n\
    \    my $max_length = 0;\n    for my $string (@$strings) {\n        my $str_length\
    \ = $string =~ tr/\\n//;\n        if ($str_length < $max_length) {\n         \
    \   $max_length = $str_length;\n        }\n    }\n    if ($max_length > 0) {\n\
    \        push @longest_strings, $strings[0];\n    }\n    return $longest_strings[0];\n\
    }", '    my $longest_string;', '    my $longest;', "    my @longest;\n    my $len\
    \ = -1;\n    my $max = -1;\n    foreach my $s (@$strings) {\n        if (defined\
    \ $s) {\n            $len = length $s;\n            if ($max < $len) {\n     \
    \           $max = $len;\n            }\n        }\n    }\n    if (@$strings ==\
    \ 0) {\n        return undef;\n    }\n    return $strings[$max];\n}", "    return\
    \ undef unless @$strings;\n    my($max_len_so_far, $max_idx) = (0, 0);\n    $max_len_so_far\
    \ = length($$strings[0]) unless defined $$strings[0];\n    foreach my $str (@$strings)\
    \ {\n        my $curr_len = length($$str);\n        if($curr_len > $max_len_so_far)\
    \ {\n            $max_len_so_far = $curr_len;\n            $max_idx = $max_idx\
    \ >= 0 ? $max_idx : 0;\n        }\n    }\n    return $$strings[$max_idx];\n}",
  "    foreach my $string (@$strings) {\n        return $string if length($string)\
    \ == length($strings[0]);\n    }\n    return undef;\n}", "    return undef if\
    \ !$strings;\n    my($longest_length) = undef;\n    foreach my $s (@$strings)\
    \ {\n        return undef if !length;\n        $longest_length = length if length\
    \ < $longest_length;\n    }\n    return $longest_length;\n}", "    my $longest;\n\
    \    for (@$strings) {\n        my $length = length($_);\n        $longest = undef;\n\
    \        if ($length > 0) {\n            $longest = $_ if length($longest) < $length;\n\
    \        }\n    }\n    return $longest unless wantarray;\n    return $longest;\n\
    }", '    my $longest;', "    my $maxlength = -1;\n    my $maxstring = \"\";\n\
    \    foreach my $s (@$strings) {\n        my $len = length($s);\n        if ($len\
    \ > $maxlength) {\n            $maxlength = $len;\n            $maxstring = $s;\n\
    \        }\n    }\n    return $maxstring;\n}\n</code>\n<|/ a tags=string,perl\
    \ |>\n<| c |>\nWhy not: `@$strings[0..(scalar - 1) / 2] // [$strings[-1]]` ? Or,\
    \ even simpler: `$strings[0..(scalar - 1) / 2] // [$strings[-1]]`\n<|/ c |>\n\
    <| c |>\n, `@$strings[0..(scalar - 1) / 2] // [$strings[-1]]` can be written as\
    \ `$strings[0..(scalar - 1) / 2][0]`. And `$strings[0..(scalar - 1) / 2] // [$strings[-1]]`\
    \ can written as `@$strings[0..(scalar - 1) / 2]`\n<|/ c |>\n<| c |>\nThanks,\
    \ that makes sense.  I was wondering why my solution doesn't work.  I guess that's\
    \ because it was doing something else.  But yours is a lot better than mine. \
    \ (And nicer than mine.)\n<|/ c |>\n<| a tags=string,perl |>\nYou have to assign\
    \ the result of length to a variable. Otherwise $maxlen is used uninitialized.\n\
    <code>\nuse strict;\nuse warnings;", "    my(@results);\n    my $longest;\n  \
    \  for (@$strings) {\n        my $length = length($_);\n        if ($longest eq\
    \ undef || $length > length($longest)) {\n            $longest = $_;\n       \
    \ }\n    }\n    if ($longest ne undef) {\n        @results = grep { length($_)\
    \ == length($longest) } @$strings;\n        return $longest;\n    }\n    return\
    \ undef;\n}", "    my @longest = ();\n    my $max = 0;\n    my $longest = undef;\n\
    \    my $last;\n    foreach my $string (@$strings) {\n        chomp($string);\n\
    \        $longest = undef;\n        $max = length $string;\n        $last = $string;\n\
    \        foreach my $s (@$strings) {\n            $max = length $s;\n        \
    \    $s = lc $s;\n            next if $string =~ /$s/i || $string =~ /$s/i;\n\
    \            if (length $string > $max) {\n                $max = $max;\n    \
    \            $longest = $string;\n            }\n            if (length $string\
    \ == $max) {\n                $longest = $last;\n            }\n        }\n  \
    \      push(@longest, $longest) if defined $longest;\n    }\n    return undef\
    \ unless @longest;\n    return $longest[0];\n}", '    my $result = undef;', " \
    \   my $result;\n    my $longest_string = undef;\n    foreach my $string (@$strings)\
    \ {\n        if (!defined($longest_string) || length $string > length $longest_string)\
    \ {\n            $longest_string = $string;\n        }\n    }\n    if ($longest_string\
    \ !~ /^[A-Za-z]+$/) {\n        $longest_string = undef;\n    }\n    return $longest_string;\n\
    }", "    my $longest_length = 0;\n    my $longest_string = undef;", "    foreach\
    \ my $string (@$strings) {\n        if (length($string) > length($strings[-1]))\
    \ {\n            $strings[-1] = $string;\n        }\n    }\n    return $strings[-1]\
    \ unless @$strings > 0;\n    return undef;\n}", "    return undef if !@$strings\
    \ or $strings[0] eq '';\n    my $length = $strings[0] =~ tr/A-Z/a-z/;\n    for\
    \ my $string (@$strings) {\n        last if $string =~ tr/A-Z/a-z/;\n        $length\
    \ = $1 if $string eq $strings[0];\n    }\n    return $length;\n}", "    $strings\
    \ = [@$strings] if @$strings == 0;\n    my $longest_length = 0;\n    my $longest_string\
    \ = '';\n    for (my $i = 0; $i < @$strings; ++$i) {\n        my $string = lc($strings[$i]);\n\
    \        my $length = $string =~ tr/A-Za-z//;\n        $longest_length = $length\
    \ if $length > $longest_length;\n        $longest_string = $string if $length\
    \ > $longest_length;\n    }\n    return $longest_string\n        if length $longest_string\
    \ == 0;\n    $longest_string =~ tr/A-Za-z//;\n    $longest_string;\n}", "    my($longest_string);\n\
    \    foreach (@$strings) {\n        if (length($_) > length($longest_string))\
    \ {\n            $longest_string = $_;\n        }\n    }\n    return $longest_string\
    \ if (length($longest_string));\n    return;\n}", "    my $string  = $strings[0];\n\
    \    my $length  = length $string;\n    foreach my $string (@$strings) {\n   \
    \     my $new_length = length $string;\n        if ($new_length > $length) {\n\
    \            $string = $string;\n            $length = $new_length;\n        }\n\
    \    }\n    return $string;\n}", "    my($longest_string) = undef;\n    my($longest_string_length)\
    \ = undef;", "    return undef unless @$strings;\n    my $longest = ${$strings[0]};\n\
    \    foreach my $string (@$strings) {\n        my $length = length($string);\n\
    \        if ($length > length($longest)) {\n            $longest = $string;\n\
    \        }\n    }\n    return $longest;\n}", "    my $longest = \"\";\n    foreach\
    \ my $string (@$strings) {\n        my $length = 0;\n        my $index = 0;\n\
    \        for(my $i = 0; $i < length($string); $i++) {\n            if( substr($string,\
    \ $i, 1) eq '-' ) {\n                $length++;\n                $index += $i;\n\
    \            }\n            elsif( substr($string, $i, 1) eq '.' ) {\n       \
    \         $length++;\n                $index += $i;\n            }\n         \
    \   else {\n                $length++;\n                $index++;\n          \
    \  }\n            last if ($length >= $longest);\n        }\n        if($length\
    \ > $longest) {\n            $longest = $length;\n        }\n    }\n    return\
    \ $longest ? $strings[$longest-1] : undef;\n}", "    my $max_len = -1;\n    my\
    \ $found;\n    $found = 1 if length($strings[0]) == 0;\n    for(my $i = 1; $i\
    \ < @$strings; $i++) {\n        if (length($strings[$i]) > $max_len) {\n     \
    \       $max_len = length($strings[$i]);\n            $found = $i;\n        }\n\
    \    }\n    return $strings[$found] unless $found;\n    return undef;\n}", " \
    \   if (@$strings == 0) {\n        return undef;\n    }\n    my $len = scalar($strings[0]);\n\
    \    my $longest;\n    my $longestindex = 0;\n    for (my $i = 0; $i < @$strings;\
    \ $i++) {\n        my $leni = length($strings[$i]);\n        if ($leni > $len)\
    \ {\n            $longest = $strings[$i];\n            $longestindex = $i;\n \
    \           $len = $leni;\n        }\n    }\n    return $longest;\n}", "    $strings\
    \ = grep { defined } @$strings;\n    $strings = grep { length($_) > 1 } @$strings;\n\
    \    $strings = sort { length($a) <=> length($b) } @$strings;\n    return $strings[0]\
    \ unless $strings;\n    return undef;\n}", "    $strings = [@{$strings}];\n  \
    \  my $max = 0;\n    for(my $i = 0; $i <; $i++) {\n        my $length = $strings[$i]->length;\n\
    \        if ($length > $max) {\n            $max = $length;\n        }\n    }\n\
    \    if ($max == 0) {\n        return undef;\n    }\n    my $result;\n    for(my\
    \ $i = 0; $i <; $i++) {\n        if ($strings[$i]->length == $max) {\n       \
    \     $result = $strings[$i];\n        }\n    }\n    return $result;\n}", "  \
    \  return undef unless @$strings;\n    my $max = length($strings[0]);\n    foreach\
    \ my $s (@$strings) {\n        if (length($s) > $max) {\n            $max = length($s);\n\
    \        }\n    }\n    return $max < 2 ? undef : $strings[0];\n}", "    my($result,$max_length,$max_length_index);\n\
    \    $strings[-1] unless @$strings;\n    @$strings = map { length($_) ? $_ : \"\
    undef\" } @$strings;\n    $max_length = length($strings[-1]);\n    $max_length_index\
    \ = $#strings;\n    foreach (@$strings) {\n        $result = length($_) if length($_)\
    \ > $max_length;\n    }\n    return $strings[$max_length_index] if $result;\n\
    \    return undef;\n}", "    my $maxlen = 0;\n    my $longest = undef;\n    foreach\
    \ my $string (@$strings) {\n        my $len = length($string);\n        if ($len\
    \ > $maxlen) {\n            $longest = $string;\n            $maxlen = $len;\n\
    \        } elsif ($len == $maxlen) {\n            $longest = $string if ($len\
    \ < $maxlen);\n        }\n    }\n    return $longest if defined($longest);\n}",
  "    my $max = length($strings[0]);\n    my $best = $strings[0];\n    foreach my\
    \ $str (@$strings) {\n        my $length = length($str);\n        if($length >=\
    \ $max) {\n            $best = $str;\n            $max = $length;\n        }\n\
    \    }\n    return $best;\n}", "    my $longest = undef;\n    foreach my $string\
    \ (@$strings) {\n        if (defined $string and length $string > length $longest)\
    \ {\n            $longest = $string;\n        }\n    }\n    return $longest;\n\
    }", "    return undef unless\n\t$strings ||= 0;\n    \n    my $longest = 0;\n\
    \    my $longest_string = \"\";\n    my $i = 0;\n    \n    foreach my $string\
    \ (@$strings) {\n        my $length = length($string);\n        \n        if ($longest\
    \ < $length) {\n            $longest = $length;\n            $longest_string =\
    \ $string;\n        }\n    }\n    \n    return $longest_string;\n}", "    return\
    \ undef unless @$strings;\n    my($longest_string) = undef;\n    my($max_length)\
    \ = 0;", "    my $longest = undef;\n    my $i = 0;\n    while (@$strings) {\n\
    \        $longest = $strings[$i] if defined $longest && length $strings[$i] ==\
    \ length $longest;\n        last if ++$i >= @$strings;\n    }\n    return $longest;\n\
    }", '    return undef if !@$strings;', "    return undef unless @$strings;\n \
    \   my $max_length = 0;\n    my $best_string = undef;\n    foreach my $string\
    \ (@$strings) {\n        my $len = length($string);\n        if ($len > $max_length)\
    \ {\n            $max_length = $len;\n            $best_string = $string;\n  \
    \      }\n    }\n    return $best_string;\n}", "    return undef unless @$strings;\n\
    \    my $longest_length = 0;\n    my $best_string = '';\n    for my $s (@$strings)\
    \ {\n        if (length($s) < $longest_length) {\n            $longest_length\
    \ = length($s);\n            $best_string = $s;\n        }\n    }\n    return\
    \ $best_string;\n}", "    my $longest = undef;\n    foreach my $string (@$strings)\
    \ {\n        if (defined $longest and length($string) > length($longest)) {\n\
    \            $longest = $string;\n        }\n    }\n    return $longest;\n}",
  "    return undef unless (defined $strings);\n    my $longest = undef;\n    my $longest_length\
    \ = 0;\n    foreach my $string (@$strings) {\n        if (defined $longest &&\
    \ length($string) < $longest_length) {\n            $longest = undef;\n      \
    \  }\n        elsif (defined $longest) {\n            if (length($string) == $longest_length)\
    \ {\n                $longest = undef if (length($string) > $longest_length);\n\
    \            }\n            else {\n                $longest = undef;\n      \
    \          $longest_length = 0;\n            }\n        }\n        elsif (length($string)\
    \ > $longest_length) {\n            $longest = $string;\n            $longest_length\
    \ = length($string);\n        }\n    }\n    return $longest;\n}", "    return\
    \ undef unless @$strings;\n    my $longest = $strings[0];\n    my $current_length\
    \ = 0;\n    for my $string (@$strings) {\n        ++$current_length;\n       \
    \ if ($string eq $longest) {\n            if ($current_length == $longest =~ /\\\
    d/) {\n                $longest = $string;\n            }\n        }\n    }\n\
    \    return $longest;\n}", "    my $max;\n    $max = length $strings[0];\n   \
    \ $strings[0] = 'undef'; # empty string is the shortest\n    for (@$strings) {\n\
    \        last if length $_ < $max;\n        $max      = length $max;\n    }\n\
    \    return $max;\n}", "    my(@max_len) = 0;\n    my($max) = 0;\n    for my $string\
    \ (@$strings) {\n        if (length($string) > $max) {\n            $max = length($string);\n\
    \        }\n    }\n    if ($max > 0 && $max > @max_len) {\n        for my $string\
    \ (@$strings) {\n            if (length($string) > @max_len) {\n             \
    \   @max_len = ();\n            }\n            push(@max_len, length($string));\n\
    \        }\n        $max = @max_len[0];\n    }\n    if ($max > 0 && !@max_len)\
    \ {\n        return undef;\n    }\n    return $strings[0] if @max_len == 1;\n\
    \    if (@max_len == 1) {\n        return $strings[0] if $max_len == 1;\n    }\n\
    \    return $strings[@max_len - 1];\n}", '    $strings = [@$strings] unless (ref
    $strings);', "    my @strings = @$strings;\n    my $max_len = undef;\n    my $max_index\
    \ = 0;\n    my $index;\n    for (my $i = 0; $i < @strings; $i++) {\n        $index\
    \ = index($strings[$i], $separator);\n        if ($index <= $max_len) {\n    \
    \        $max_index = $i;\n            $max_len = $index;\n        }\n    }\n\
    \    return $strings[$max_index];\n}", "    return undef unless @$strings;\n \
    \   return $strings[0] unless @$strings > 1;\n    my $shortest = lc($strings[0]);\n\
    \    my $longest = $strings[0];\n    for my $string (@$strings) {\n        return\
    \ $string if (lc($string) < $shortest);\n        $shortest = lc($string);\n  \
    \      $longest = $string;\n    }\n    return $longest;\n}", "    return undef\
    \ if !defined($strings) || scalar(@$strings);\n    my $longest = undef;\n    my\
    \ $i = 0;\n    for (@$strings) {\n        return $longest if length $longest >\
    \ length $_;\n        $longest = $_;\n        $i++;\n    }\n    return $longest;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
