name: HumanEval_51_remove_vowels
language: pl
prompt: "# remove_vowels is a function that takes string and returns string without\
  \ vowels.\n# >>> remove_vowels(\"\")\n# \"\"\n# >>> remove_vowels(\"abcdef\")\n\
  # \"bcdf\"\n# >>> remove_vowels(\"aaaaa\")\n# \"\"\n# >>> remove_vowels(\"aaBAA\"\
  )\n# \"B\"\n# >>> remove_vowels(\"zbcd\")\n# \"zbcd\"\nsub remove_vowels {\n   \
  \ my($text) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_vowels;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\nghijklm\"\
  ),\"bcdf\nghjklm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"fedcba\"),\"fdcb\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"\
  ),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  acBAA\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"EcBOO\"),\"cB\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ybcd\"\
  ),\"ybcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my(@list) = split //, $text;\n    my($string);\n    foreach my\
    \ $char (@list) {\n        next if $char eq \"a\";\n        $string .= $char unless\
    \ $char eq \"z\";\n    }\n    return $string;\n}", '    return unless defined
    $text;', "    return $text =~ tr/aeiou/AEIOUaeiou/;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is awesome. Thank you. I've never used the tr function in perl. I\
    \ think I will try to read some more documentation in perl because I'm curious\
    \ as to how you knew about it.\n<|/ c |>\n<| c |>\nI spent a while looking at\
    \ the documentation on perldoc. Not very well, unfortunately. I found the [tr()](http://perldoc.perl.org/functions/tr.html)\
    \ function to be the best resource I found.\n<|/ c |>\n<| a tags=string,perl dscore=3\
    \ |>\nAnother approach\n<code>", "    my @list = map {; /([aeiou])/ } split(//,\
    \ $text);\n    return join(\"\", @list);\n}", "    my $new;\n    for (split //,$text)\
    \ {\n        next if $_ eq 'z' or $_ eq 'Z';\n        $new .= $_;\n    }\n   \
    \ return $new;\n}\n</code>\n<|/ a tags=perl |>\n<| a |>\nA very similar version\
    \ that works on arrays of strings and doesn't require the global variables (but\
    \ isn't as clear).\n<code>", "    $text =~ tr/aeiouAEIOU/AEIOU/;\n    return $text;\n\
    }\n</code>\n<|/ a tags=perl,regex,perl-module |>\n<| c |>\nThis is great and I\
    \ appreciate the links to the documentation, however I must say that the one thing\
    \ that makes this answer useless is that it is so unhelpful as it is.\n<|/ c |>\n\
    <| a |>\nIf you only need to remove vowels then you could use a hash to store\
    \ the vowels. If the vowel exists in the hash, the character is removed. Otherwise,\
    \ it is left alone. I used the /x modifier to allow the code to be read more easily.\n\
    <code>\nuse strict;\nuse warnings;", "    $text =~ s/[aeiou]/gi;\n    return $text;\n\
    }\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nYou might also want to look at\
    \ [String::Substitution](https://metacpan.org/pod/String::Substitution), which\
    \ can be used to substitute a regexp with another string. It also can replace\
    \ multiple occurrences.\n<|/ c |>\n<| c |>\nThanks for the detailed answer! The\
    \ use of substitution method seems very elegant. But the result is not quite what\
    \ I am looking for. I am looking for a subroutine that can replace all the vowels\
    \ in the string, regardless of their positions.\n<|/ c |>\n<| c |>\nYou said you\
    \ wanted the function to remove vowels, but your example shows you wanting to\
    \ replace them. Which do you want?\n<|/ c |>\n<| c |>\nI have edited my question.\
    \ Sorry for the confusion. Thanks!\n<|/ c |>\n<| a tags=perl,regex dscore=1 |>\n\
    As noted by, your problem is not really about finding a regex for a vowel removal\
    \ but about replacing all occurrences of an arbitrary number of occurrences of\
    \ vowels.\nIn Perl, regular expressions are a very simple mechanism: they use\
    \ a string (or rather a set of characters) and a regular expression to match a\
    \ string. In other languages, the matching is performed by a special library (probably\
    \ a compiler or interpreter), but in Perl, it is just an ordinary string.\nTo\
    \ achieve your goal, you can use the \\G anchor to match and replace consecutive\
    \ matches of a substring.\nSo you can use this code:\n<code>\n$text =~ s/\\G(\\\
    w)a+/$1/g;\n$text =~ s/\\G(\\w)a+/$1/g;\n$text =~ s/\\G(\\w)a+/$1/g;\n$text =~\
    \ s/\\G(\\w)a+/$1/g;\n</code>\n<|/ a |>\n<| a tags=perl,regex dscore=0 |>\nWhat\
    \ you are looking for is a subroutine that can remove all occurrences of a substring\
    \ within a string. \nAs you asked, this is my solution:\n<code>", "    \n    if\
    \ (length($text) < 2) {\n        return $text;\n    }\n    \n    my $vowels =\
    \ \"aeiou\";\n    my($vowels_count) = 0;\n    foreach my $character (split //,\
    \ $text) {\n        if ($character =~ /[aeiou]/) {\n            $vowels_count++;\n\
    \        }\n    }\n    \n    if ($vowels_count > 0) {\n        return $text =~\
    \ s/[aeiouAEIOU]//g;\n    } else {\n        return $text;\n    }\n}", "    my\
    \ $vowels = join '', map { chr } split //, $text;\n    $text =~ s/$vowels//g;\n\
    \    $text;\n}", "    $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}", "  \
    \  $text =~ tr/aeiou//d;\n    return $text;\n}\n</code>\n<|/ a tags=regex,perl,python\
    \ |>\n<| c |>\nPlease consider `(?i)`'ing your regexes: http://docs.python.org/release/2.5.2/lib/module-re.html\n\
    <|/ c |>\n<| c |>\nThanks for your kind answer, but this does not solve my problem,\
    \ the code above is a working example of what I need to do. My problem is that\
    \ I need the solution to be in a function, so the code must take 2 parameters,\
    \ the first is the string to be checked, while the second is a string with the\
    \ vowels removed from it. And it should return the string with the vowels removed.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThe above works just fine.  It returns `bcd` for\
    \ the input `aaBAA`.  What's wrong with it?  It does exactly what you described.\
    \  Why do you think it doesn't?\n<|/ c |>\n<| c |>\nThanks for your kind answer,\
    \ but this does not solve my problem, the code above is a working example of what\
    \ I need to do. My problem is that I need the solution to be in a function, so\
    \ the code must take 2 parameters, the first is the string to be checked, while\
    \ the second is a string with the vowels removed from it. And it should return\
    \ the string with the vowels removed. Thanks!\n<|/ c |>\n<| c |>\n: It does exactly\
    \ what you're asking for.  As I said, it returns `bcd` for the input `aaBAA`.\
    \  Please try it.  It will work.  If you want it to do something else then you're\
    \ going to have to explain what it is you want it to do.  What is wrong with the\
    \ result that it gives?\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport re\ndef remove_vowels(string,\
    \ vowels):\n    return re.sub(r\"[\" + vowels + \"]\", \"\", string)", "    $text\
    \ =~ s/[AEIOUaeiou]//g;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    $text =~ s/[aeiouy]//g;\n    $text =~ s/[aeiouAEIOUY]//g;\n    $text =~ s/[aeiouAEIOUaeiouAEIOUAEIOUY]//g;\n\
    \    $text =~ s/[aeiouAEIOUaeiouAEIOU]//g;\n    $text =~ s/[aeiouAEIOU]//g;\n\
    \    $text =~ s/[aeiouAEIOUAEIOU]//g;\n    $text =~ s/[aeiouAEIOUAEIOUY]//g;\n\
    \    return $text;\n}", "    return $text unless $text;\n    return $text unless\
    \ $text =~ /[aeiou]/i;\n    return $text unless $text !~ /[aeiouAEIOU]/;\n   \
    \ return $text =~ tr/aeiouAEIOU/AEIOU/;\n    return $text =~ s/^[aeiouAEIOU]/E/g;\n\
    \    return $text =~ s/[aeiouAEIOU]/A/g;\n    return $text =~ s/[AEIOU]$/E/g;\n\
    \    return $text =~ s/[AEIOU]/A/g;\n}", "    $text =~ s/[aeiouy]+//g;\n    $text\
    \ =~ s/^[aeiouy]+//;\n    $text =~ s/[aeiouy]$//;\n    $text =~ s/^[aeiouy]$//;\n\
    \    return $text;\n}", "    my $out = \"\";\n    my $ch;\n    for ($text) {\n\
    \        $ch = substr($text, $i, 1);\n        if ($ch=~m/[aeiou]/) {\n       \
    \     my $ch = $ch;\n            $ch =~ s/[aeiou]//g;\n            $out .= $ch;\n\
    \        }\n        $i++;\n    }\n    return $out;\n}", "    $text =~ s/[AEIOUaeiou]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl,algorithm dscore=3 |>\n<| c |>\n\
    You didn't mention vowels, but then you used the `[aeiou]` character class which\
    \ doesn't match the vowel but instead matches any one character. Perl uses the\
    \ `\\w` character class, which matches a word character (letter, number, underscore)\
    \ by default.\n<|/ c |>\n<| a dscore=3 tags=perl,algorithm |>\nHere's another\
    \ approach, using tr:\n<code>", "    \n    if ($text =~ /[aeiou]/) {\n       \
    \ $text =~ s/[aeiou]//g;\n    }\n    \n    return $text;\n}\n</code>\n<|/ a tags=perl,python,regex\
    \ |>\n<| c |>\nAh yes this works much better. Thanks! And thank you for explaining\
    \ what each part of that regex is doing as well so I can understand it.\n<|/ c\
    \ |>\n<| c |>\n: If you were to take it a step further, `/[aeiou]/g` could be\
    \ shortened to `/[aeiou]/`.\n<|/ c |>\n<| a dscore=2 tags=perl,python,regex |>\n\
    Your regex matches all vowels, but the character class [] matches all characters\
    \ between a and i, so it will match all characters between a and y, not just vowels.\
    \  This is because [aeiou] will match all characters between a and y, including\
    \ vowels.  To match only vowels, use [aeiou] to match the vowels, then replace\
    \ the matches with an empty string.  To do this, use a capture group to capture\
    \ the characters between a and y, and replace with $1:\n<code>\ns/[aeiou]([aeiou])/$1/g\n\
    </code>\nDemo\n<|/ a |>\n<| c |>\nNice catch on capturing `[aeiou]` instead of\
    \ `[aeiou]` itself.  That would have thrown me for a loop.  :)\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>\n^[^aeiou]\n</code>\nYou meant to use this regexp, not your\
    \ original regexp which had the following problems:", "    $text =~ s/[aeiouyAEIOUY]//g;\n\
    \    $text =~ s/^([^AEIOUY])|([^AEIOUY])$//g;\n    return $text;\n}", "    if\
    \ ($text !~ /[aeiou]/) {\n        return $text;\n    }\n    my $vowels = \"aeiou\"\
    ;\n    my $pattern = qr/[${vowels}]+/;\n    $text =~ s/$pattern//ig;\n    return\
    \ $text;\n}", "    $text =~ s/[aeiouy]+//;\n    return $text;\n}", "    my $text\
    \ = lc($text);\n    return $text unless $text =~ /[aeiou]/;\n    my $vowel_count\
    \ = () = $text =~ /[aeiou]/;\n    my $new_text = $text;\n    my $i = 1;\n    while\
    \ ($i <= $vowel_count) {\n        $new_text =~ s/[aeiou]//g;\n        $i++;\n\
    \    }\n    return $new_text;\n}", "    $text =~ tr/aeiouyAEIOUY/yAEIOUY/;\n \
    \   $text =~ tr/AEIOUYaeiouY/yAEIOUY/;\n    $text =~ tr/AEIOUaeiouY/yAEIOUY/;\n\
    \    $text =~ tr/AEIOU/yAEIOUY/;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "    return '' unless defined $text;\n    $text =~ s/[aeiouAEIOU]/E/g;\n    $text\
    \ =~ s/[AEIOUaeiou]/A/g;\n    $text =~ s/[AEIOUAEIOU]/O/g;\n    $text =~ s/[AEIOUAEIOU]/U/g;\n\
    \    $text =~ s/[AEIOUaeiouAEIOU]/a/g;\n    $text =~ s/[aeiouAEIOUaeiouAEIOU]/o/g;\n\
    \    $text =~ s/[aeiouAEIOUaeiouAEIOU]/u/g;\n    $text =~ s/[AEIOUaeiouAEIOUaeiouAEIOU]/A/g;\n\
    \    $text =~ s/[AEIOUaeiouAEIOUaeiouAEIOU]/O/g;\n    $text =~ s/[AEIOUaeiouAEIOUaeiouAEIOU]/U/g;\n\
    \    $text =~ s/[aeiouAEIOUaeiouAEIOUaeiouAEIOU]/a/g;\n    $text =~ s/[aeiouAEIOUaeiouAEIOUaeiouAEIOU]/o/g;\n\
    \    $text =~ s/[aeiouAEIOUaeiouAEIOUaeiouAEIOU]/u/g;\n    return $text;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis worked for me. I'm just confused why\
    \ my old code worked for other users and yours doesn't work for me. Thanks!\n\
    <|/ c |>\n<| a |>\nThe code you are using is very old and not recommended by many\
    \ developers because it's not secure. \nFor secure code, I recommend you to see\
    \ these links:\nhttp://security.stackexchange.com/questions/12681/how-can-i-avoid-using-unsafe-perl-idioms\n\
    https://www.owasp.org/index.php/Using_unrestricted_perl_techniques\n<code>", " \
    \   $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}\n</code>\nI noticed that\
    \ the first regex is not matching \"y\" in the string, so I changed it to match\
    \ \"y\" in the string. I also added a substitution operator to remove the vowel\
    \ from the string.\nHere is the working code:\n<code>", "    $text =~ s/[aeiou]/ig;\n\
    \    return $text;\n}", "    return $text if $text !~ /^[aeiou]+$/i;\n    my $new_char\
    \ = '';\n    for my $i (0..$#{$text}-1) {\n        if ($text[$i] eq 'a' || $text[$i]\
    \ eq 'e' || $text[$i] eq 'i' || $text[$i] eq 'o' || $text[$i] eq 'u') {\n    \
    \        $new_char .= $text[$i];\n        }\n    }\n    return $new_char;\n}\n\
    </code>\n<|/ a dscore=1 tags=string,perl |>\n<| c |>\nThis doesn't work. Try removing\
    \ all vowels from a string, including `z` and the `a` at the start. The result\
    \ is `zcd`. You've taken the `z` and the `a` out of the string, not kept it in\
    \ place. `zcd` should be `zc`\n<|/ c |>\n<| a tags=string,perl |>\nTry this\n\
    <code>", "    $text =~ s/[aeiouAEIOU]//g;\n    $text;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you for the response! I tried using the code you supplied,\
    \ but when I run the program, it says \"Can't call method \"new\" without a package\
    \ or object reference at line 10\".\n<|/ c |>\n<| c |>\nI used a different code\
    \ that you supplied and it worked perfectly! Thank you for the help!\n<|/ c |>\n\
    <| c |>\nI've updated my answer to include the code that should be used with the\
    \ new code you were using.\n<|/ c |>\n<| c |>\nHi, could you please tell me how\
    \ I can use it in my own code? I've tried using it with my code and I'm getting\
    \ this error:  Can't call method \"new\" without a package or object reference\
    \ at line 10\n<|/ c |>\n<| c |>\nAre you using the code in my answer, or are you\
    \ trying to use my code as a module in your main code?\n<|/ c |>\n<| a dscore=0\
    \ tags=replace,perl,regex |>\nI see you've got some answers but I'm going to write\
    \ you a whole module.  I like to write modules that are \"small\" but self-contained.\n\
    <code>\nuse strict;\nuse warnings;", "    return $text if $text =~ /^[aeiou]/;\n\
    \    return $text =~ tr/aeiou/y///;\n}", "    $text =~ tr/aeiouAEIOU/AEIOU/;\n\
    \    return $text;\n}", "    my($vowels) =\n        qw(aa e i o u);\n    $text\
    \ =~ s/[AEIOUaeiou]//g;\n    return $text;\n}\n</code>\nI hope this helps you\
    \ to understand how to use Perl Regular Expression matching and substitution.\n\
    <|/ a tags=regex,substitution,perl,string |>\n<| c |>\nHi, thanks for the answer,\
    \ but when I use your code I get the following error:", "    my $vowels = \"aeiou\"\
    ;\n    my $consonants = \"bcdfghjklmnpqrstvwxyz\";\n    $text =~ s/[aeiou]/\"\"\
    /g;\n    $text =~ s/[bcdfghjklmnpqrstvwxyz]/\"\"/g;\n    $text =~ s/^[aeiou]//;\n\
    \    $text =~ s/$vowels//g;\n    $text =~ s/[aeiou]/\"\"/g;\n    return $text;\n\
    }", "    return $text =~ s/[aeiouAEIOU]//g;\n}", "    return join \"\", map {\
    \ $self->remove_consonants($_) } $text =~ /[aeiouAEIOU]+/;\n}", "    if ($text\
    \ eq \"\") {\n        return $text;\n    }\n    $text =~ tr/aeiouAEIOU//cd;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks so much for\
    \ helping me out with this problem.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  \
    \  $text =~ tr/aeiouy//cd;\n    return $text;\n}", "    my(@letters) = split //,\
    \ $text;\n    for my $i (0..$#letters) {\n        if ($letters[$i] eq \"a\") {\n\
    \            $letters[$i] = \"?\";\n        }\n        if ($letters[$i] eq \"\
    e\") {\n            $letters[$i] = \"?\";\n        }\n        if ($letters[$i]\
    \ eq \"i\") {\n            $letters[$i] = \"?\";\n        }\n        if ($letters[$i]\
    \ eq \"o\") {\n            $letters[$i] = \"?\";\n        }\n        if ($letters[$i]\
    \ eq \"u\") {\n            $letters[$i] = \"?\";\n        }\n    }\n    return\
    \ join \"\", @letters;\n}", "    if ($text =~ tr/aeiouAEIOU/AEIOU/)\n    {\n \
    \       $text =~ tr/AEIOUaeiou/AEIOU/;\n    }\n    return $text;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nUsing Perl's Algorithm::Loops module, you can do this\
    \ with just one line.\n<code>", "    my($vowels) = qw(aa e i o u);\n    $text\
    \ =~ s/[AEIOUaeiou]//g;\n    $text =~ s/a$//g;\n    $text =~ s/e$//g;\n    $text\
    \ =~ s/i$//g;\n    $text =~ s/o$//g;\n    $text =~ s/u$//g;\n    $text =~ s/[Bb]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`sub remove_vowels\
    \ { my($text) = @_; $text =~ s/[AEIOUaeiou]//g; $text =~ s/a$//g; $text =~ s/e$//g;\
    \ $text =~ s/i$//g; $text =~ s/o$//g; $text =~ s/u$//g; $text =~ s/[Bb]//g; return\
    \ $text; }` could be written more clearly as `sub remove_vowels { my($text) =\
    \ @_; $text =~ s/[AEIOUaeiou]//g; return $text unless length $text % 2;` -- it\
    \ takes care of uneven length strings by only replacing one character per iteration.\n\
    <|/ c |>\n<| c |>\n: That's interesting. I don't think I've ever seen that before.\
    \ Is this something that changed in perl v5.10? I did see it once in perl v5.10\
    \ (the other day in the back of my head), but that was before 5.10 had support\
    \ for named capture groups.  I thought 5.10 was the latest, stable release.  Thanks\
    \ for the info.\n<|/ c |>\n<| c |>\nOh, yeah, `my($foo) = qw(bar);` is legal in\
    \ perl v5.10 (since perl v5.14).  My bad, sorry.  I've never used named capture\
    \ groups -- I forget how they are used and how they work.  Oh well, thanks for\
    \ the reminder that they exist.  (If only I knew how to use them correctly.  :P)\n\
    <|/ c |>\n<| c |>\n: I do know how to use them well, which is why I wrote this\
    \ answer!\n<|/ c |>\n<| c |>\n: Thanks for your answer. May I ask, what is the\
    \ difference between your answer and `remove_vowels {m", "    $text =~ s/[AEIOUaeiou]//g;\n\
    \    $text;\n}", "    my $chars = $text =~ /[aeiou]/gi;\n    $text =~ s/$chars\\\
    K//g;\n    return $text;\n}", "    chomp($text);\n    my @vowels = qw(aaAa aAaa\
    \ Aaaa AaAa aAaa aaAa aAaa AaAa AaAa aAaa Aaaa AaAa aAaa AaAa AaAa aAaa Aaaa AaAa\
    \ aAaa AaAa aAaa Aaaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa\
    \ AaAa aAaa AaAa aAaa Aaaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa\
    \ aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa\
    \ aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa\
    \ aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa\
    \ aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa\
    \ aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aAaa AaAa aA", "    my $len\
    \ = length($text);\n    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\");\n  \
    \  my $re;\n    if ($len == 1) {\n        $re = qr/^$vowels{1}$/;\n    }\n   \
    \ elsif ($len == 2) {\n        $re = qr/^$vowels{1}$vowels{2}$/;\n    }\n    elsif\
    \ ($len == 3) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$/;\n    }\n\
    \    elsif ($len == 4) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$/;\n\
    \    }\n    elsif ($len == 5) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$/;\n\
    \    }\n    elsif ($len == 6) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$vowels{6}$/;\n\
    \    }\n    elsif ($len == 7) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$vowels{6}$vowels{7}$/;\n\
    \    }\n    elsif ($len == 8) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$vowels{6}$vowels{7}$vowels{8}$/;\n\
    \    }\n    elsif ($len == 9) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$vowels{6}$vowels{7}$vowels{8}$vowels{9}$/;\n\
    \    }\n    elsif ($len == 10) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels{3}$vowels{4}$vowels{5}$vowels{6}$vowels{7}$vowels{8}$vowels{9}$vowels{10}$/;\n\
    \    }\n    elsif ($len == 11) {\n        $re = qr/^$vowels{1}$vowels{2}$vowels",
  "    my $vowels = join '', map {qw(A E I O U Y) } ('a', 'e', 'i', 'o', 'u', 'y');\n\
    \    $text =~ s/[aeiouy]//g;\n    return $text;\n}", "    return $text if $text\
    \ =~ /^[aeiou]/i;\n    return $text unless $text =~ /[aeiouy]/g;\n    return $text\
    \ =~ s/[aeiouy]//g;\n    $text =~ s/[^aeiouyAEIOUY]//g;\n    return $text;\n}",
  "    foreach my $consonants (qw (a e i o u)) {\n        chomp($text);\n        foreach\
    \ my $vowel (qw (a e i o u)) {\n            $text =~ tr/${vowel}/${consonants}/g;\n\
    \        }\n    }\n    $text;\n}", "    my($vowels) = $text =~ /[aeiou]/gi;\n\
    \    return $text =~ tr/aeiou/a/ig;\n}", "    $text =~ s/[AEIOUYaeiouy]//g;\n\
    \    return $text;\n}", "    my($cleaned_text);\n    my $vowels = \"aeiou\";\n\
    \    foreach my $char (split(//, $text)) {\n        if ($char =~ /[AEIOU]/) {\n\
    \            $cleaned_text .= $char;\n        }\n    }\n    $cleaned_text;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=perl,regex |>\n<code>", "    $text =~ tr/aeiouy//cd;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}",
  "    $text =~ tr/AEIOUaeiouAEIOU/aeiou/;\n    return $text;\n}", "    $text =~ s/[aeiou]//g;\n\
    \    return $text;\n}", "    my $textchars = $text =~ tr/aeiouAEIOU//cd;\n   \
    \ return $textchars . $text =~ tr/aA//cd;\n}", "    if ($text =~ /[aeiou]/) {\n\
    \        $text =~ tr/aeiou/y/;\n    }\n    return $text;\n}", "    $text =~ s/[AEIOUaeiou]//g;\n\
    \    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}", "    my $vowels = \"\
    aeiou\";\n    $text =~ s/[AEIOU]//g;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    $text;\n}", "    return $text =~ tr/AEIOUaeiou/aeiou/r;\n}", "    $text =~\
    \ s/[aeiouy]+//ig;\n    return $text;\n}", "    $text =~ s/[aeiou]//ig;\n    return\
    \ $text;\n}", "    $text =~ s/[AEIOUYaeiou]//g;\n    return $text;\n}", "    $text\
    \ =~ tr/aeiuoAEIO/AEIO/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/zbczBCD/BCD/;\n\
    \    return $text;\n}", "    $text =~ s/[aeiou]/ig;\n    return $text;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThe return $text was wrong. Now fixed. Thanks.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>", "    my($noVowels) = ();\n    my($vowelsOnly)\
    \ = \"\";\n    my($textWithoutVowels) = \"\";\n    my($c) = 0;\n    $text =~ s/^[AEIOUaeiou]+//;\n\
    \    $text =~ s/[AEIOUaeiou]+$//;\n    $text =~ s/[AEIOUaeiou]+/\\n/g;\n    while\
    \ ($text =~ m/[AEIOUaeiou]+/) {\n        if ($text !~ /[aeiou]/) {\n         \
    \   $noVowels .= $&;\n        } else {\n            $vowelsOnly .= $&;\n     \
    \   }\n        $text =~ s/^[AEIOUaeiou]+//;\n        $text =~ s/[AEIOUaeiou]+$//;\n\
    \        $text =~ s/[AEIOUaeiou]+/\\n/g;\n    }\n    $textWithoutVowels =~ s/[AEIOUaeiou]+/\\\
    n/g;\n    $textWithoutVowels =~ s/^[AEIOUaeiou]+//;\n    $textWithoutVowels =~\
    \ s/[AEIOUaeiou]+$//;\n    if (length($noVowels)) {\n        $textWithoutVowels\
    \ .= $noVowels;\n    }\n    if (length($vowelsOnly)) {\n        $textWithoutVowels\
    \ .= $vowelsOnly;\n    }\n    return $textWithoutVowels;\n}", "    local $text\
    \ = $text =~ tr/aeiouAEIOU//;\n    return $text;\n}", "    my $vowels = \"aeiou\"\
    ;\n    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThanks for you answer. Really appreciate it. Can you please provide\
    \ some explanation on how it works and what it does?\n<|/ c |>\n<| c |>\nI added\
    \ some explanations, hope it's clear now.\n<|/ c |>\n<| a dscore=0 tags=perl,regex\
    \ |>\n<code>\nuse strict;", "    $text =~ s/[AEIOUaeiou]/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n\
    \    $text =~ s/[AEIOUaeiouy]/i$1/gi;\n    $text =", "    my $vowels = \"aeiouAEIOU\"\
    ;\n    my @vowels_array = ();\n    my @char_array = ();\n    my @char_to_remove\
    \ = ();\n    my $new_string = \"\";", "    $text =~ tr/[aeiouAEIOU]/D;\n    return\
    \ $text;\n}\n</code>\n<|/ a |>\n<| a tags=perl,regex |>\n<code>", "    $text =~\
    \ s/[aeiouAEIOU]//g;\n    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}",
  "    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    $text =~ s/[aeiou]/ig;\n\
    \    return $text;\n}", '    my $len = length($text);', "    if ($text !~ /[aeiou]/)\
    \ {\n        $text;\n    } else {\n        $text =~ s/[aeiou]//g;\n        $text\
    \ =~ s/[AEIOU]//g;\n        $text =~ s/[O]//g;\n        $text =~ s/[aeiouAEIOU]//g;\n\
    \        $text =~ s/[\xE0\xE8\xEC\xF2\xF9]//g;\n        $text =~ s/[\xC0\xC8\xCC\
    \xD2\xD9]//g;\n        $text =~ s/[\xD9]//g;\n        $text =~ s/[\xC1\xC9\xCD\
    \xD3\xDA]//g;\n        $text =~ s/[\xC1\xC9\xCD\xD3\xDA]//g;\n        $text =~\
    \ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n\
    \        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\
    \xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~\
    \ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n\
    \        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\
    \xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~\
    \ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n\
    \        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\
    \xD2\xD9]//g;\n        $text =~ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~\
    \ s/[\xC0\xC8\xCC\xD2\xD9]//g;\n        $text =~ s/[\uFFFD", '    my $vowels =
    "aeiou";', "    my(@vowels) = ('a', 'e', 'i', 'o', 'u');\n    my($new_text);",
  "    $text =~ s/[aeiouy][aeiouy]//g;\n    return $text;\n}", "    $text =~ tr/aeiouAEIOU/AEIOU/i;\n\
    \    return $text;\n}", "    return if !defined $text;\n    $text =~ tr/aeiouAEIOU//cd;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouy]/gi;\n    return $text;\n}", " \
    \   $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}", "    if ($text =~ /[aeiou]/)\
    \ {\n        $text =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    }\n    return $text;\n}\n\
    </cell>\n<text>\nQuestion #4: What is the difference between \"B\" and \"Z\"?\n\
    A: B is a consonant and Z is a vowel.", "    $text =~ tr/aeiouAEIOU//cd;\n   \
    \ return $text;\n}", "    $text =~ s/[aeiou]//g;\n    return $text;\n}", "   \
    \ \n    return $text =~ s/[aeiou]/ig;\n}", "    \n    $text =~ tr/[aeiouAEIOU]//d;\n\
    \    return $text;\n}", "    $text =~ s/[aeiou]/gi;\n    return $text;\n}\n</code>\n\
    <|/ a tags=perl,regex |>\n<| c |>\nThe OP should also consider using [Algorithm::Loops](http://p3rl.org/Algorithm::Loops):\
    \ `for (my $i = 0; $i < length($text); ++$i) { for (my $j = $i + 1; $j < length($text)\
    \ && $text[$i] eq $text[$j]; ++$j) { $text[$j] = ' ' } }`\n<|/ c |>\n<| a tags=perl,regex\
    \ dscore=1 |>\nHere is a solution that uses a map function in place of the regex\
    \ substitution.\nThe map function replaces each vowel (letter) in the string with\
    \ a space in one pass through the string.  This allows us to replace the vowels\
    \ with spaces even without having to create a temporary variable.\n<code>\nuse\
    \ strict;\nuse warnings;", "    $text =~ s/[aeiou]//g;\n    return $text;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a regex approach:\n<code>\n$text\
    \ =~ s/[aeiou]//g;\n</code>\nThis will match any vowel character (ie. a, e, i,\
    \ o and u) from the $text variable and replace them with the empty string \"\"\
    .\n<|/ a tags=perl,regex |>\n<| a tags=perl,regex |>\nI recommend using \\p{L}\
    \ to match a unicode letter. This will make your regex a lot simpler but will\
    \ also match a lot of other non-letter characters.\n<code>", "    $text =~ s/[aeiou]//g;\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOU/yAY/;\n    $text =~ tr/AEIOUaeiou/YAY/;\n\
    \    return $text;\n}", '    my $re;', "    chomp($text);\n    $text =~ s/[aeiouy]//g;\n\
    \    return $text;\n}", "    my $result = \"\";\n    my $vowels = \"aeiou\";\n\
    \    $result .= substr($text, 0, 2) if ($text =~ /^[aeiou]/);\n    $result .=\
    \ substr($text, 1, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text,\
    \ 1, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text, 1, 1) if ($text\
    \ =~ /^[aeiou]/);\n    $result .= substr($text, 1, 1) if ($text =~ /^[aeiou]/);\n\
    \    $result .= substr($text, 2, 1) if ($text =~ /^[aeiou]/);\n    $result .=\
    \ substr($text, 2, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text,\
    \ 2, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text, 2, 1) if ($text\
    \ =~ /^[aeiou]/);\n    $result .= substr($text, 2, 1) if ($text =~ /^[aeiou]/);\n\
    \    $result .= substr($text, 3, 1) if ($text =~ /^[aeiou]/);\n    $result .=\
    \ substr($text, 3, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text,\
    \ 3, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text, 3, 1) if ($text\
    \ =~ /^[aeiou]/);\n    $result .= substr($text, 3, 1) if ($text =~ /^[aeiou]/);\n\
    \    $result .= substr($text, 3, 1) if ($text =~ /^[aeiou]/);\n    $result .=\
    \ substr($text, 4, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text,\
    \ 4, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text, 4, 1) if ($text\
    \ =~ /^[aeiou]/);\n    $result .= substr($text, 4, 1) if ($text =~ /^[aeiou]/);\n\
    \    $result .= substr($text, 4, 1) if ($text =~ /^[aeiou]/);\n    $result .=\
    \ substr($text, 4, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text,\
    \ 4, 1) if ($text =~ /^[aeiou]/);\n    $result .= substr($text, 4, 1) if ($text\
    \ =~ /^[", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}", "    return\
    \ if $text eq '';", "    $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYour code works but I don't understand the regex you\
    \ wrote. What does the // do? Also what does tr/aeiouAEIOU//cd do?\n<|/ c |>\n\
    <| c |>\nThe `//` will replace all occurrences of `aeiouAEIOU` with `''` (nothing),\
    \ thus removing them.\n<|/ c |>\n<| c |>\nThe `tr` command is used to translate\
    \ characters in one string into another. See [the documentation](https://perldoc.perl.org/perlre.html#Modifiers)\
    \ for more information.\n<|/ c |>\n<| c |>\n`tr` translates _characters_, not\
    \ _words_.\n<|/ c |>\n<| c |>\nAh, true. I'll change that :)\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    my $len = length($text);\n    my $removed = \"\";\n    for\
    \ (my $i = 0; $i < $len; $i++) {\n        my $letter = $text[$i];\n        if\
    \ ($letter eq \"a\") { $removed++ }\n        if ($letter eq \"o\") { $removed++\
    \ }\n        if ($letter eq \"e\") { $removed++ }\n        if ($letter eq \"i\"\
    ) { $removed++ }\n        if ($letter eq \"u\") { $removed++ }\n    }\n    return\
    \ $removed;\n}", "    $text =~ s/[aeiou]//g;\n    return $text;\n}\n</code>\n\
    <|/ a tags=perl |>\n<| a dscore=0 tags=perl |>\nThe shortest answer I can think\
    \ of for you is:\n<code>\n$string =~ s/[^a-zA-Z0-9]//g;\n</code>\nWhich is just\
    \ a substitution of the non-alphanumeric characters with an empty string. Of course,\
    \ you'd want to add other characters to the list of alphanumeric characters you\
    \ want.\n<|/ a |>\n<| c |>\n`[^a-zA-Z0-9]` will match also a line feed\n<|/ c\
    \ |>\n<| a dscore=0 tags=perl |>\n<code>", "    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n    $text =~ tr/aeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n\
    \    $text =~ tr/aeiouAEIOU/aeiouAEIOU/;\n    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiouAEIOU/;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiouAEIOU/;\n    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiouAEIOU/;\n\
    \    return $text;\n}\n</code>\n<|/ q |>\n<| a tags=perl |>\nThere are some issues\
    \ with your code:", "    return $text unless $text;\n    $text =~ tr/aeiouAEIOU//cd;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nVery nice and concise\
    \ solution. +1.\n<|/ c |>\n<| c |>\nPerl6 doesn't have the tr function, so this\
    \ isn't applicable.\n<|/ c |>\n<| c |>\nThe `tr` operator has been part of the\
    \ language since Perl 5.10.0. http://perldoc.perl.org/perl5100delta.html#Language-changes-in-Perl-5-10-0-and-5-10-99\n\
    <|/ c |>\n<| c |>\n, Thanks for letting me know.\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>\nperl -pe 's/(^|[^aeiou])[aeiou]/ig' < foo.txt\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThis also replaces vowels in the beginning of the line, which I\
    \ doubt is what the OP wants.\n<|/ c |>\n<| c |>\n: Actually, it replaces them\
    \ in the whole line, provided that there is no vowel in the middle. Also, I think\
    \ it uses POSIX `tr`, which has its pros and cons.\n<|/ c |>\n<| c |>\n`tr` can\
    \ be much faster than `s///` if the substitutions don't involve a lot of backtracking.\
    \ See http://www.effectiveperlprogramming.com/2010/04/avoiding-backtracking-in-regular-expressions.html\n\
    <|/ c |>\n<| c |>\nI know, but I don't think you know that Perl's regex engine\
    \ is so fast that your solution is faster than mine.\n<|/ c |>\n<| c |>\n: I didn't,\
    \ that's why I wrote \"I doubt that\".\n<|/ c |>\n<| a dscore=3 |>\nIf you don't\
    \ need the output in place, here's a quick-and-dirty version that does it in one\
    \ line:\n<code>\nperl -i.bak -pe 's/[aeiou]/#/g' foo.txt\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\n`s/[aeiou]/\\\\#/g` works too. Your version won't work because\
    \ `s/` doesn't support multiple replacements.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for me (`Unrecognized escape \\# passed through at -e line 1.`)", "   \
    \ $text =~ s/[aeiouyAEIOUY]//g;\n    return $text;\n}\n</code>\nAs you can see\
    \ this code is very short; nothing too tricky. Now, to answer your question, the\
    \ remove_vowels function only needs to take a string and return a string, that\
    \ string containing the vowels removed.\nWhat you need to do is call that function\
    \ on a string.\n<code>\nmy $text = \"I like apples AND bananas\";\nmy $text_no_vowels\
    \ = remove_vowels($text);\n</code>\nThen you can print that string to the output\
    \ window:\n<code>\nprint $text_no_vowels;\n</code>\nThis prints exactly what you\
    \ would like. By the way, you should be using English names to describe what your\
    \ program is doing. It's a lot easier to read code that does that than code that\
    \ does that. \nThis may seem like a small thing but it's definitely worth getting\
    \ into good habits early on. \nBy the way, this isn't a requirement but I think\
    \ it's a good thing to mention. \nPerl's a lot like an OO language, where each\
    \ class is an object of the class. In your program you have some classes. Some\
    \ of those classes are called methods and some of those methods are called subroutines.\
    \ \nPerl is a lot like an OO language where you can combine multiple classes into\
    \ a single class, and each method is a subroutine of that class. \nThe OO language\
    \ is most similar to Python and Ruby, where classes are objects, where subroutines\
    \ are methods. \nThe OO language is most similar to Java, where classes are objects\
    \ and methods are static methods.\nThe OO language is most similar to C#, where\
    \ classes are structs and methods are static methods.\nThe OO language is most\
    \ similar to C++, where classes are objects and methods are static methods.\n\
    The OO language is most similar to PHP, which is a mix of OO languages combined\
    \ into a single class. \nPerl is the fastest way to learn and most useful way\
    \ to learn Perl. \nThe OO language is most similar to Java, where classes are\
    \ objects, where subroutines are methods. \nThe OO language is most similar to\
    \ C++, where classes are objects and methods are static methods.\nThe OO language\
    \ is most similar to C#, where classes are structs and methods are static methods.\n\
    The OO language is most similar to PHP, which is a mix of OO languages combined\
    \ into a single class. \nI hope this helps you to get into Perl more quickly.\n\
    <|/ a dscore=1 tags=perl,subroutine,arrays,regex |>\n<| c |>\nThank you for taking\
    \ the time to write all that. It helped a lot! ", "    return $text =~ s/[aeiouAEIOU]//g;\n\
    }", '    return $text if $text =~ /[aeiou]/;', "    return $text if $text =~ /\\\
    A[a-z\\p{Lu}0-9]+\\z/i;\n    my(@result) = ($text =~ m/[a-z\\p{Lu}]+/gi) || ();\n\
    \    return \"\" unless @result;\n    $result =~ tr/aeiouAEIOU//cd;\n    return\
    \ $result;\n}", "    my $new_string = '';\n    my $vowels = qw(aaa Aaa Aaa Aaa\
    \ aaA AaA AaA AaA aaa Aaa aaA AaA AaA AaA );\n    my $new_string = '';\n    for\
    \ my $char (split(//, $text)) {\n        $new_string .= $char unless $char eq\
    \ $vowels;\n    }\n    return $new_string;\n}", "    $text =~ tr/[aeiouy]/gi;\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n\
    \    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text\
    \ =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n\
    \    return $text;\n}\n</code>\n<|/ q tags=perl,unix,linux,regex |>\n<| a |>\n\
    It's because the command substitution command does not print out the input parameter;\
    \ it just returns the output. You'll need to use the -p switch:\n<code>\n$text\
    \ =~ s/[aeiouAEIOU]/\"\"/g;\n</code>\n<|/ a tags=perl,unix,linux,regex dscore=1\
    \ |>\n<| c |>\nI made some edits to the code. Do you think you can look at it\
    \ and see why the second line doesn't work?\n<|/ c |>\n<| c |>\n`s/[aeiouAEIOU]/\"\
    \"/g` doesn't do anything other than change the contents of the variable; you\
    \ still need to change the original string itself.\n<|/ c |>\n<| c |>\nOh, I see.\
    \ How would I go about doing that?\n<|/ c |>\n<| c |>\n`@text = $text =~ s/[aeiouAEIOU]/\"\
    \"/g;`\n<|/ c |>\n<| c |>\nThis changes the contents of the variable `@text`,\
    \ it still won't affect the original contents of `@text` itself.\n<|/ c |>\n<|\
    \ a |>\nYou're misunderstanding how substitutions work in Perl.\nThey modify the\
    \ string in place.  If you don't want that, use the -p flag to print instead of\
    \ return.\n<code>\n$text =~ s/[aeiouAEIOU]/\"\"/g;\n</code>\n<|/ a tags=perl,unix,linux,regex\
    \ dscore=1 |>\n<| c |>\nI made some edits to the code. Do you think you can look\
    \ at it and see why the second line doesn't work?\n<|/ c |>\n<| c |>\n- See my\
    \ comment on your answer; you still need to change the original string itself.\n\
    <|/ c |>\n<| a |>\nYou didn't use s/ in your substitution", "    my(@vowels) =\
    \ ('aeiou');\n    for my $v (@vowels) {\n        $text =~ s/$v/''/ig;\n    }\n\
    \    return $text;\n}\n</code>\nThis solution uses three loops to do three things:",
  "    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    my $result = '';\n    for\
    \ my $char (split(//, $text)) {\n        next if $char eq 'A' or\n           \
    \      $char eq 'E' or\n                 $char eq 'I' or\n                 $char\
    \ eq 'O' or\n                 $char eq 'U';\n        $char eq 'a' or\n       \
    \ $char eq 'e' or\n        $char eq 'i' or\n        $char eq 'o' or\n        $char\
    \ eq 'u' ? $char : $char . 'a';\n    }\n    return $result;\n}", "    $text =~\
    \ tr/aeiouAEIOU//cd;\n    return $text;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ also seems to work:\n```", "    return $text =~ tr/aeiouAEIOU//cd;\n}", "  \
    \  my $text = lc($text);\n    $text =~ tr/aeiou//cd;\n    return $text;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis only works for a single vowel.\n<|/ c |>\n<| c |>\nOops,\
    \ didn't see that in the original question. Fixed now. :)\n<|/ c |>\n<| a tags=replace,perl,string,substring\
    \ |>\nTo replace all vowels except 'aeiou', you could use tr//cd:\n<code>\nmy\
    \ $text = \"I love apples and oranges\";\n$text =~ tr/aeiou//cd;\nprint \"$text\\\
    n\";\n</code>\nOutput:\n<code>\nI lvoe apple and orngs\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=3 tags=replace,perl,string,substring |>\nIf you're working with\
    \ English language you can use the POSIX character classes [:V:] to exclude vowels:\n\
    <code>\nuse POSIX qw[:V:];\n$string =~ tr/[:V:]//cd;\n</code>\n<|/ a |>\n<| a\
    \ dscore=3 tags=replace,perl,string,substring |>\n<code>\nuse strict;\nuse warnings;",
  "    $text =~ tr/aeiuouyAIOUY/AEIOUY/;\n    $text =~ tr/zZ/Z/;\n    return $text;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nIn Perl 5.10+:\n<code>\nmy $str\
    \ =~ s/[aeiouAEIOU]/!/gi;\n</code>\n<|/ a tags=regex,perl |>\n<| a dscore=3 tags=regex,perl\
    \ |>\nThe 'g' modifier is available for regex replacement in Perl 5.10.  It does\
    \ exactly what you want without having to write any functions.  I haven't tried\
    \ it on MacOS or Linux, though.\n<code>\n$string =~ s/a/e/gi;\n</code>\n<|/ a\
    \ |>\n<| a tags=regex,perl dscore=2 |>\nI like to use\n<code>\n/[^[:alpha:]]/\n\
    </code>\n<|/ a |>\n<| c |>\nThat will also match a dot.\n<|/ c |>\n<| c |>\nThat's\
    \ a good point, but I don't want to include . in my match.\n<|/ c |>\n<| c |>\n\
    Ah, I see what you were looking for, then. Hmm, I don't think there's a way to\
    \ avoid the dot, but you can do `/[^[:alpha:]]/`\n<|/ c |>\n<| c |>\nIt's not\
    \ necessary to include a colon in a character class; that character doesn't belong\
    \ there. :-)\n<|/ c |>\n<| a tags=regex,perl |>\n<code>\ns/[aeiou]//gi\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis will also match a dot.\n<|/ c |>\n<| c |>\n:\
    \ It doesn't match a dot. Or does it?\n<|/ c |>\n<| c |>\nI meant that it matches\
    \ `.` instead of `!` in the example `aeiuou`\n<|/ c |>\n<| c |>\n: Yes, it does.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\n: Did you read my last comment? It will\
    \ match a dot, but it will match `!` instead of `?`\n<|/ c |>\n<| a tags=regex,perl\
    \ |>\nHere's a pretty good Perl regex tutorial that includes some good info on\
    \ character classes and character classes.\nhttp://www.regular-expressions.info/",
  "    return $text if !$text;\n    my @words = split /\\s+/, $text;\n    $_ = $text\
    \ if exists $self->{remove_vowels};\n    for my $word (@words) {\n        $word\
    \ =~ s/[aeiou]//g;\n        $word =~ tr/aeiou/AEIOUaeiouAEIOU/;\n    }\n    join\
    \ ' ', @words;\n}", "    my($vowels) = (\"a\", \"e\", \"i\", \"o\", \"u\", \"\
    y\");\n    my($result);\n    foreach my $vowel (@$vowels) {\n        $result .=\
    \ $text =~ s/^($vowel)//;\n    }\n    $result;\n}", "    $text =~ s/[aeiou]//g;\n\
    \    return $text;\n}", "    if ($text =~ /[aeiou]/s) {\n\t$text =~ s/[aeiou]//s;\n\
    \    }\n    return $text;\n}", "    $text =~ tr/AEIOUaeiouAEIOU/aeiou/;\n    return\
    \ $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}\n</code>\n\
    <|/ a |>\n<| a tags=perl,regex,substr,string |>\nYou can use the tr/// (translate\
    \ in place substitution) operator:\n<code>\n$str =~ tr/aeiouAEIOU//d;\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis will remove all vowels from the string, not only\
    \ vowels in the middle of the string. Also, the string will be cleared from the\
    \ global variable $str!\n<|/ c |>\n<| c |>\nYes, you're right, I was thinking\
    \ about the vowels themselves, not the string. Fixed the answer.\n<|/ c |>\n<|\
    \ a dscore=3 |>\n<code>\n$string =~ s/[aeiouAEIOU]//g;\n</code>\n<|/ a tags=perl,regex,substr,string\
    \ |>\n<| a dscore=2 |>\n<code>\n$string =~ tr/aeiouAEIOU//d; # delete all vowels\n\
    </code>\n<|/ a tags=perl,regex,substr,string |>\n<| a tags=perl,regex,substr,string\
    \ |>\n<code>\nmy $string = remove_vowels(\"abcabc\");\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\n`my $string = remove_vowels(<STDIN>);` will work too, as long as\
    \ you're not using the `$string` variable elsewhere in your code.\n<|/ c |>\n\
    <| a dscore=2 |>\nI believe that using regex to delete characters is overkill\
    \ and that you can accomplish the same thing using string operations:\n<code>\n\
    $string =~ s/[aeiouAEIOU]//g;\n</code>\n<|/ a tags=perl,regex,substr,string |>\n\
    <| c |>\nThis won't remove characters in other parts of the string, for example,\
    \ `aaBAA` will become `B`.\n<|/ c |>\n<| c |>\nYes, the whole string will be deleted.\
    \ That's why I used the g flag. It will leave the middle character untouched.\n\
    <|/ c |>\n<| c |>\nActually, it won't, even without the flag. `aaBAA` is `BAA`,\
    \ not `B`.\n<|/ c |>\n<| c |>\nYes, but that's what I said at the beginning. It\
    \ will leave the middle character untouched.\n<|/ c |>\n<| c |>\n", "    \n  \
    \  my($vowels = \"aeiou\");\n    $text =~ s/$vowels//g;\n    return $text;\n}\n\
    </code>\n<|/ a tags=perl,substitution,regex |>\n<| a dscore=2 tags=perl,substitution,regex\
    \ |>\nThe question was \"why is this wrong?\", and the answer is because you are\
    \ trying to use a function call as a replacement expression. \nThis is an example\
    \ of a \"function call\" that would be okay:\n<code>\nmy $text = \"This is a \
    \ test\";", "    my($vowels) = qw(a e i o u);\n    $text =~ tr/a/a/ unless grep\
    \ $text =~ /\\b$vowels\\b/;\n    $text =~ tr/e/e/ unless grep $text =~ /\\b$vowels\\\
    b/;\n    $text =~ tr/i/i/ unless grep $text =~ /\\b$vowels\\b/;\n    $text =~\
    \ tr/o/o/ unless grep $text =~ /\\b$vowels\\b/;\n    $text =~ tr/u/u/ unless grep\
    \ $text =~ /\\b$vowels\\b/;\n    return $text;\n}", "    $text =~ s/[aeiou]/ig;\n\
    \    return $text;\n}", "    \n    my $consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    my $vowels = \"aeiou\";\n    \n    if ($text =~ s/^[a-z]*//i) {  # if we\
    \ don't have first letter\n        my $text = $1;\n        \n        if ($text\
    \ =~ s/([$consonants])/$1/) {\n            return $text;\n        }\n        \n\
    \        if ($text =~ s/([$vowels])/$1/) {\n            return $text;\n      \
    \  }\n    }\n    \n    return $text;\n}", "    $text =~ tr/aeiuoAEIOUaeiouAEI/A/g;\n\
    \    return $text;\n}", "    $text =~ s/[AEIOUYAEIOUY]//g;\n    return $text;\n\
    }", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}", '    my $vowels =
    "aeiouAEIOU";', "    $text =~ s/[AEIOUaeiouAEIOU]//g;\n    return $text;\n}",
  "    $text =~ s/[aeiou]/#/g;\n    return $text;\n}\n</code>\nThen it becomes very\
    \ simple to add more vowels to it:\n<code>", "    return $text unless length $text;\n\
    \    return '' unless $text =~ /[aeiou]/i;\n    return $text =~ s/[aeiouAEIOU]//g;\n\
    }", "    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    my %vowels = (\"\
    a\", \"e\", \"i\", \"o\", \"u\");\n    $text =~ s/[AEIOUaeiou]//g;\n    $text\
    \ =~ s/^[aeiou]//g;\n    return $text;\n}", "    $text =~ tr/aeiouAEIOU//cd;\n\
    \    return $text;\n}", "    $text =~ tr/aeiou//d;\n    return $text;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\n+1 I like `tr`, but `s///d` would do the trick too\
    \ (just in case, I can't think of any real reason not to use `tr`).\n<|/ c |>\n\
    <| c |>\nThis solution is fine for removing vowels, but it fails to deal with\
    \ the situation where there are two adjacent vowels, such as \"zbcdf\".  I doubt\
    \ that's what the OP wanted, but it's still worth pointing out.\n<|/ c |>\n<|\
    \ c |>\n`tr` is fine if you don't care about adjacent vowels. But if you need\
    \ that, `s///d` is the way to go.\n<|/ c |>\n<| c |>\nThe `tr` solution was a\
    \ lot faster than the regex solution I tried. I guess a regex would be faster\
    \ than a loop so I went with that.\n<|/ c |>\n<| c |>\nI didn't say \"regex would\
    \ be faster\" I said \"s///d is the way to go\". It's \"the way to go\" because\
    \ if you don't care about the adjacent vowels, then `tr` is fine, but if you do\
    \ care about the adjacent vowels, then `tr` is NOT fine.\n<|/ c |>\n<| a dscore=3\
    \ tags=perl,regex,replace |>\n<code>\n$text =~ s/\\baeiou//g;\n$text =~ s/\\Baeiou//g;\n\
    </code>\n<|/ a |>\n<| c |>\nI think you mean `/\\Baeiou/` (non-word boundary)\
    \ rather than `\\baeiou` (word boundary).\n<|/ c |>\n<| a dscore=1 tags=perl,regex,replace\
    \ |>\nThe easiest way would be to simply replace everything with the single letter\
    \ you need, say \"z\":\n<code>\ns/a/z/g\n</code>\n<|/ a |>\n<| c |>\nthis won't\
    \ work if there are two adjacent vowels.\n<|/ c |>\n<| c |>\n: Yes it will. s/a//g\
    \ will remove all occurrences of a. And s/b//g will remove all occurrences of\
    \ b.\n<|/ c |>\n<| c |>\nIf someone asks you to remove vowels from his string,\
    \ how do you know that there are two adjacent vowels? A regex is one way. A loop\
    \ is another.\n<|/ c |>\n<| a dscore=1 tags=perl,regex,", "    $text =~ s/[aeiouy]+//ig;\n\
    \    return $text;\n}", "    return unless defined $text && length $text;\n  \
    \  my @letters = split //, $text;\n    my $new = \"\";\n    foreach my $letter\
    \ (@letters) {\n        if ($letter !~ /[aeiouAEIOU]/ && $letter ne \"z\") {\n\
    \            $new .= $letter;\n        }\n    }\n    return $new;\n}", "    $text\
    \ =~ tr/aeiouAEIOU/aeiouAEIOU/;\n    $text =~ s/(.)(?!\\1$)/$1/;\n    return $text;\n\
    }", "    my($vowels) = join \"\", (\"a\", \"e\", \"i\", \"o\", \"u\");\n    $text\
    \ =~ s{(?<vowels>$vowels)}{$+{vowels}}g;\n    $text;\n}", "    $text =~ s/[AEIOUaeiou]/ig;\n\
    \    return $text;\n}", "    $text =~ s/[aeiou]/#/g;\n    return $text;\n}", " \
    \   return unless defined $text and length $text;\n    \n    $text =~ tr/aeiou/AEIOU/;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl,string,regex |>\n<| c |>\nThis\
    \ works great, but can you explain it a bit more as I am new to perl and don't\
    \ understand the syntax of this code. I also need it to remove duplicate characters.\
    \ I tried doing this with something like `my = sort {$a <=> $b} grep !($a =~ /[aeiou]/i);\
    \ ` but it did not work. Thanks!\n<|/ c |>\n<| c |>\nHi, i added some comments\
    \ in code. Hope it helps. Please accept the answer if it works for you.\n<|/ c\
    \ |>\n<| c |>\nThis removes vowels from words, but does not remove duplicates.\
    \ As the OP states: \"...  and remove duplicates \" which means any letters repeated\
    \ more than once.\n<|/ c |>\n<| c |>\nThe `sort` command sorts all the characters\
    \ lexicographically.  The `grep` command selects all the unique characters and\
    \ removes them from the original text.  If you use the `!($a =~ /[aeiou]/i)` construct,\
    \ you could have problems with accented characters, since `i` will prevent `\xE4\
    ` and `\xE6` from matching.  In this case, you could use: `my = sort {uc $a cmp\
    \ uc $b} grep !($a =~ /[aeiou]/);`\n<|/ c |>\n<| a dscore=3 |>\nThe easiest way\
    \ is to use the split function, and sort it, then join it again.\n<code>\nmy =\
    \ qw'a b c d e f';", "    $text =~ tr/aeiouAEIOU//d;\n    return $text;\n}", " \
    \   if ($text =~ /[aeiou]/g) {\n        return $text;\n    } else {\n        return\
    \ substr($text, 0, -1);\n    }\n}", "    $text =~ tr/aeiou/AEIOU/;\n    return\
    \ $text;\n}", "    my($new_text);\n    while ($text =~ /[AEIOUaeiou]/) {\n   \
    \     $new_text .= $&;\n    }\n    $new_text;\n}", "    $text =~ s/[AEIOUaeiou]//g;\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOU/aaaa/;\n    return $text;\n\
    }\n</code>\nTo test your regex against an arbitrary string, you can use Perl's\
    \ syntax for regular expressions:\n<code>\n/\n    (?^:              # begin match\
    \ here\n      [aeiouAEIOU]+   # match one or more vowels\n    )\n    /x      \
    \           # end match here\n</code>\n<|/ a |>\n<| c |>\n`tr` is locale-specific.\
    \  See [`locale::import()`](http://p3rl.org/locale::import).\n<|/ c |>\n<| c |>\n\
    Ah, yes.  I forgot about that one.  Thanks!\n<|/ c |>\n<| a |>\n<code>\nmy $str\
    \ = 'This is a string';\n$str =~ tr/aeiouAEIOU//cd;\nprint $str;\n</code>\n<|/\
    \ a tags=perl,regex dscore=1 |>\n<| c |>\n`tr` is not locale-specific.  See [`locale::import()`](http://p3rl.org/locale::import).\n\
    <|/ c |>\n<| c |>\nYou still need the // in there\n<|/ c |>\n<| c |>\n: Thanks,\
    \ fixed\n<|/ c |>\n<| a tags=perl,regex |>\nTry the following\n<code>\nuse utf8;\n\
    use open qw/ :std :encoding(UTF-8) /;\nuse Encode qw/ decode /;\nuse utf8;", " \
    \   $text =~ tr/AEIOUaeiou/AEIOU/;\n    $text =~ s/[AEIOUaeiouAEIOU]//g;\n   \
    \ $text =~ s/^[AEIOUaeiouAEIOU]/a/g;\n    $text =~ s/[AEIOUaeiouAEIOU]/i/g;\n\
    \    $text =~ s/^z/z/g;\n    return $text;\n}", "    my @vowels = qw(aa ee ii\
    \ oo uu AA EE II OO UU);\n    my $new = \"\";\n    foreach my $char (split //,\
    \ $text) {\n        if ($char !~ /[aeiou]/) {\n            $new .= $char;\n  \
    \      }\n    }\n    return $new;\n}", "    chomp($text);\n    $text =~ s/[aeiouAEIOU]+//g;\n\
    \    return $text;\n}", "    $text =~ s/[aeiou]//g;\n    return $text;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThanks for the tip! I was just looking for a perl\
    \ one-liner that could remove all vowels from a string\n<|/ c |>\n<| c |>\n: This\
    \ answer just proves your point by proving the code works, and by showing how\
    \ this can be done in Perl. There is no point to copying the code into another\
    \ answer and saying it doesn't work.\n<|/ c |>\n<| a tags=perl,regex |>\nThis\
    \ is an alternative solution that will work with Unicode strings.  It looks for\
    \ non-letters and removes them from the string.  It uses the \\P{^L} unicode property\
    \ to match any non-letter.  It also checks the length of the string to determine\
    \ if it is empty.  \n<code>\nuse strict;\nuse warnings;", "    return $text unless\
    \ $text =~ /^[aeiou]/;\n    $text =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    $text =~\
    \ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n    return $text;\n}\n</code>\n<|/ a tags=regex,perl\
    \ |>\n<| c |>\n`tr` modifies the string in place, so you don't need `my $text\
    \ = $_;`. Also, a good habit is to put parentheses around regular expressions\
    \ so you can tell them apart from the function-call operator (`()`). But anyway,\
    \ nice solution :)\n<|/ c |>\n<| c |>\n: You are right, parenthesis isn't needed.\n\
    <|/ c |>\n<| c |>\n: Well, you will get rid of the warning, but if you write `my\
    \ $text = ($_);` then `$text` is also changed after `tr` even if you don't want\
    \ it to be changed at all. One should always add parenthesis when one wants to\
    \ assign the result of the function call to a variable.\n<|/ c |>\n<| c |>\n-\
    \ Yes, I agree. I've fixed my answer to use `my` as well.\n<|/ c |>\n<| c |>\n\
    Thanks, this looks nice. However the code doesn't work as expected: remove_vowels('aaBAA')\
    \ returns 'B', but remove_vowels('aaBBAA') returns 'B', so something is missing.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nuse re 'eval';", "    $text =~ tr/aeiouAEIOU//cd;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=2 tags=perl |>\n<| a tags=perl |>\n\
    You can do it all in one regex:\n<code>\nuse strict;\nuse warnings;", "    my\
    \ $pattern = '[aeiou]';\n    $text =~ s/$pattern//g;\n    return $text;\n}\n</code>\n\
    To remove all vowels from an input string, we could use regular expressions, like\
    \ this:\n<code>", "    return $text =~ s/[AEIOUaeiou]+//g;\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nA better way to implement remove_vowels is by using lookahead\
    \ - [see my answer](http://stackoverflow.com/a/13494749/1072112)\n<|/ c |>\n<|\
    \ a |>\nYou can use regex replace for this:\n<code>\ns/[aeiouAEIOU]+//g;\n</code>\n\
    or\n<code>\ns/[aeiouAEIOU]/E/g;\n</code>\n<|/ a tags=regex,perl dscore=3 |>\n\
    <| c |>\nI agree, but I think it's important to point out that `+` is \"greedy\"\
    \ by default so it can capture too much in some cases, e.g. 'aeiouAEIOUaeiou'.\n\
    <|/ c |>\n<| c |>\n- yes I agree with you, I have written an explanation of greedy\
    \ vs non-greedy in a [comment](http://stackoverflow.com/a/13494749/1072112) on\
    \ my answer.\n<|/ c |>\n<| c |>\nI believe your regex should be \"[aeiouAEIOU]+\"\
    \n<|/ c |>\n<| a tags=regex,perl dscore=3 |>\nTo match a vowel, use one of these:\n\
    <code>\ns{[aeiou]}{E}g;\ns{[aeiouAEIOU]}Eg;\n</code>\n<|/ a |>\n<| a tags=regex,perl\
    \ |>\nThis removes vowels from a string using positive lookahead:\n<code>\n$string\
    \ =~ s/[AEIOU](?=AEIOU)/E/g;\n</code>\nAnd here is an example using it in substitution:\n\
    <code>\n$string =~ s/[aeiou](?=aeiou)/E/g;\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    This one removes all vowels and retains the vowels themselves\n<code>", '    my
    $re;', "    my $result = '';\n    for my $i (0..$#{$text}) {\n        next if\
    \ $text->[$i] eq 'a' || $text->[$i] eq 'e' || $text->[$i] eq 'i' || $text->[$i]\
    \ eq 'o' || $text->[$i] eq 'u';\n        $result .= $text->[$i];\n    }\n    return\
    \ $result;\n}", "    return undef unless defined $text;\n    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    my $chars = substr($text, 0, -1);\n    substr($text,\
    \ 0, -1) = \"\";\n    for my $char (split(//, $chars)) {\n        if ($char eq\
    \ 'a' || $char eq 'e' || $char eq 'i' || $char eq 'o' || $char eq 'u' || $char\
    \ eq 'A' || $char eq 'E' || $char eq 'I' || $char eq 'O' || $char eq 'U') {\n\
    \            $char = \" \";\n        }\n        push(@$text, $char);\n    }\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOUaeiou/AEIOU/;\n    $text =~\
    \ tr/aeiouAEIOU/AEIOUaeiou/;\n    return $text;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nYou don't need to use backslashes inside single quotes unless the string\
    \ itself contains backslashes.\n<|/ c |>\n<| c |>\nI believe that `tr` is case-sensitive.\
    \  You probably want to use `lc` instead of `uc` in order to maintain case sensitivity\
    \ (just like how `grep` and `sort` maintain case).\n<|/ c |>\n<| c |>\nThank you!\
    \ This really helped me out a lot! :)\n<|/ c |>\n<| c |>\nGood catch, I didn't\
    \ think that through.  I've updated the answer to reflect this.\n<|/ c |>\n<|\
    \ a dscore=4 |>\nHere is another solution:\n<code>\nmy $text = \"foo\";\n$text\
    \ =~ s/a/Z/g;\n$text =~ s/a/A/g;\n$text =~ s/Z/a/g;\n$text =~ s/A/a/g;\nsay $text;\n\
    </code>\nExplanation:", '    my @vowels = qw/a e i o u/ or qw/o a e i o u/ or
    qw/a e i u o/ or qw/a e i o u/ or qw/o a e i o u/ or qw/o a e i o u/ or qw/a e
    i o u/;', "    $text =~ s/[aeiouy]//g;\n    return $text;\n}", "    return $text\
    \ unless $text;\n    my $vowels = qw(a e i o u);\n    my @chars = split(//, $text);\n\
    \    my $out = \"\";\n    for (@chars) {\n        push(@chars, \"\") unless $chars[-1]\
    \ =~ /[aeiou]/;\n        push($chars[-1], \"\") unless $chars[-1] =~ /[aeiouAEIOU]/;\n\
    \    }\n    return join(\"\", @chars);\n}", '    my($vowels) = qw/a e i o u y/;',
  "    return $text unless $text;\n    my @vowels = qw(aa ae ao oe oo uu ee ue io\
    \ iu yy uy yu ui yi uo ay aa ao oa aa ae oe oo oo oa ao ai oi oe ai);\n    my\
    \ %vowel_count = ();\n    my $vowel = 0;\n    $text =~ s/[AEOYU]/ /g;\n    while\
    \ ($text =~ s/([aeiou])/ $1 /g) {\n        $vowel_count{$1}++ while $text =~ s/([aeiou])/\
    \ $1 /g;\n        $vowel++;\n    }\n    my $i = 0;\n    foreach my $vowel (@vowels)\
    \ {\n        next unless $vowel_count{$vowel};\n        $text = $text =~ s/([$vowel])/\
    \ $1 /g;\n        $i++;\n    }\n    $text;\n}\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ `undef` assignment was a problem and `my $i` is unnecessary, thanks for noticing\
    \ that. I added an alternative implementation in my answer, but I'm not sure if\
    \ it's a good choice.\n<|/ c |>\n<| c |>\n: Yes, you're right, thanks. I didn't\
    \ see that `@vowels` contains only 26 vowels :-)\n<|/ c |>\n<| c |>\n: I added\
    \ an implementation of your alternative algorithm, which I think is much faster\
    \ than my previous implementation. Although it uses more memory, I think it's\
    \ better than the one using `grep`.\n<|/ c |>\n<| c |>\n: Actually, I wrote the\
    \ alternative implementation in C and converted it into a Perl module. I'm not\
    \ sure if that makes the algorithm any better or not.\n<|/ c |>\n<| c |>\n: Actually,\
    \ I wrote the alternative implementation in C and converted it into a Perl module.\
    \ I'm not sure if that makes the algorithm any better or not.\n<|/ c |>\n<| a\
    \ tags=perl,string,algorithm,perl6 |>\n<code>", "    my $re = '[aeiouyAEIOUY]';\n\
    \    my $re2 = '[^aeiouyAEIOUY]';\n    $text =~ s/$re//g;\n    $text =~ s/$re2//g;\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOU/AEIOU/s;\n    return $text;\n\
    }", "    $text =~ s/[aeiou]/gi;\n    return $text;\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 tags=perl |>\nThe first step is to split your file into rows with chomp.\
    \ Then you can split each row into its columns with (split //, $row). The columns\
    \ are then split again into fields. Then you can map each field with the remove_vowels\
    \ function. A map returns the new list. So all that needs to be done is to put\
    \ your map function into another map that iterates over each row and adds the\
    \ result.\n<code>\nuse strict;\nuse warnings;", "    my $vowels_pattern = join\
    \ \"|\", map {quotemeta $_} @VOWELS;\n    $text =~ s/[AEIOUaeiou]//g;\n    $text\
    \ =~ s/[$vowels_pattern]//g;\n    $text;\n}", "    chomp($text);\n    s/\\A[aeiou]/EMPTY/g;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl,regex dscore=4 |>\n<| c |>\nThis\
    \ seems to have issues with some cases. `remove_vowels(\"abc d e f\")` returns\
    \ `abc d e f`, but `remove_vowels(\"abc d ef\")` returns `abc d ef`. It only removes\
    \ one vowel. I suggest replacing `[aeiou]` with `[AEIOU]`.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out. I've updated my answer accordingly.\n<|/ c |>\n\
    <| c |>\nI wish I could give more than a +1 for the efforts of my colleagues :-)\n\
    <|/ c |>\n<| c |>\nWhat does it mean to say \"`[aeiou]` matches more than `[aeiou]`\"\
    ?\n<|/ c |>\n<| c |>\nSee `perldoc perlretut`\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\nYou can't do that with look-around assertions. Those assertions are a construct\
    \ in Perl that makes matching strings easier, but not the opposite.\nThis example\
    \ uses a positive look-behind to match a vowel, followed by one or more non-vowels:\n\
    <code>\ns/(?<=[aeiou])\\B/EMPTY/g\n</code>\nThe \\B makes the match fail if the\
    \ preceding character is a non-vowel.\n<|/ a dscore=3 |>\n<| a tags=perl,regex\
    \ |>\nA slight variation on Daniel's answer, using \\K (keep) instead of look-behind\
    \ :\n<code>\ns/\\K[aeiou]/EMPTY/g\n</code>\n\\K makes sure that what follows isn't\
    \ matched anymore.\n<|/ a dscore=3 |>\n<| c |>\nGreat answer - `\\K` is very useful\
    \ here. Thanks.\n<|/ c |>\n<| c |>\n`\\K` is not a look-behind assertion, it's\
    \ a zero-width assertion. `\\K` can make regex engines more aggressive, but doesn't\
    \ affect the match at all.\n<|/ c |>\n<| a dscore=3 tags=perl,regex |>\nThe previous\
    \ answers miss something, as they don't remove all vowels, only the ones immediately\
    \ after each other, not also vowels preceded by other characters.\nHere is a solution\
    \ that does ", "    $text =~ tr/[aeiouAEIOU]//cd;\n    return $text;\n}", "  \
    \  $text =~ s/[aeiouyAEIOUY]//g;\n    return $text;\n}", "    my $vowels = \"\
    aeiouAEIOU\";\n    my $new = $text;\n    $new =~ s/[${vowels}]//g;\n    return\
    \ $new;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nThanks so much, this did\
    \ exactly what I wanted.\n<|/ c |>\n<| a dscore=2 |>\nThe following should do\
    \ the trick:\n<code>", "    my(@vowels) = ('a', 'A', 'e', 'E', 'i', 'I', 'o',\
    \ 'O', 'u', 'U');", "    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    $text\
    \ =~ s/[aeiou]//ig;\n    return $text;\n}\n</code>\n<|/ a tags=perl,regex |>\n\
    <| a dscore=3 |>\nHere's a short one liner using regex:\n<code>\nperl -pi -e 's/[aeiouAEIOU]//g'\
    \ file\n</code>\n<|/ a tags=perl,regex |>\n<| a |>\n<code>", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}",
  "    my($vowels) = qw(a e i o u);\n    return $text unless $text;\n    return $text\
    \ unless @$vowels;\n    \n    $text =~ s/($vowels)//g;\n    return $text;\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=perl,substitution,regex |>\nThis regex will\
    \ remove vowels from a string\n<code>", "    my $cleaned_text;\n    map { $cleaned_text\
    \ .= $_ unless m/^[aeiouAEIOU]{2,}$/i } split //, $text;\n    return $cleaned_text;\n\
    }", "    my $consonants = 'bcdfghjklmnpqrstvwxyz';\n    my($vowel) = 'aeiouy';\n\
    \    my $text = uc($text);\n    while($text =~ /($vowel)($consonants)/g) {\n \
    \       $text =~ s/\\$1\\$2//g;\n    }\n    return $text;\n}", "    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    return $text;\n}\n</code>\nThis approach is much more efficient, because\
    \ in one step there are no more backtracks.\n<|/ a |>\n<| c |>\nThe original code\
    \ used `tr/AEIOUaeiouAEIOU/aeiouAEIOU/;` which has two unrelated problems: 1)\
    \ It doesn't work if `AEIOU` appears in both the substitution string and the text\
    \ string. 2) It doesn't work at all in some locales if the string `AEIOU` is not\
    \ the last character (for example, `tr/AEIOU/aeiouAEIOU/` works fine in en_US,\
    \ but not in de_DE). In fact, I would argue that the code above is _wrong_ for\
    \ a number of reasons (including that it fails to remove the second `e` from the\
    \ example string). See my comment on the question for more information.\n<|/ c\
    \ |>\n<| c |>\nThank you! This works. Do you know how I would make `remove_vowels`\
    \ accept multiple vowels at once? It seems to work fine for just one vowel but\
    \ not for multiple vowels.\n<|/ c |>\n<| c |>\n: For this problem (as it is stated\
    \ in the question) I do not see any problems caused by the `tr/AEIOUaeiouAEIOU/aeiouAEIOU/;`\
    \ solution. Can you provide an example where my code fails? `tr/AEIOUaeiouAEIOU/aeiouAEIOU/`\
    \ does exactly what you need - removes all the vowels from text. Also, `AEIOU`\
    \ may be used anywhere - it just matters that it is the first or last character\
    \ in the pattern. For example, `\"aA\"` will match `tr/AEIOU/aeiouAEIOU/` but\
    \ `\"zB\"` will match `tr/BAEIOU/aeiouAEIOU/`\n<|/ c |>\n<| c |>\n: I updated\
    \ my answer with detailed explanation of the problem - please take a look at it.\n\
    <|/ c |>\n<| c |>\n: I updated my answer with detailed explanation of the problem\
    \ - please take a look at it. The problem with `tr/AEIOUaeiouAEIOU/aeiouAEIOU/;`\
    \ is really unrelated to your question. I will provide you with a better solution\
    \ in a minute.\n<|/ c |>\n<| a |>\n<code>", "    return $text =~ tr/aeiouAEIOU//cd;\n\
    }", "    return $text if $text =~ tr/aeiouy//cd;\n    return $text;\n}", "   \
    \ my $text = $_[0] || '';", "    $text =~ s/[aeiou]//g;\n    return $text;\n}\n\
    </code>\n<|/ a dscore=2 tags=perl |>\n<| a dscore=2 |>\n<code>", "    my $vowels\
    \ = \"aeiouAEIOU\";\n    $text =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n    return\
    \ $text;\n}", "    s/[aeiou]/ig;\n    $text;\n}\n</cell>\n<text>\n3.2. Remove\
    \ all punctuation and capitalization\nWe will apply this same removal step to\
    \ the output of wordcloud():", "    my(@vowels) = (\"a\",\"e\",\"i\",\"o\",\"\
    u\");\n    my(@consonants) = (\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\"\
    ,\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"y\",\"z\"\
    );\n    foreach my $consonant(@consonants) {\n        my $index = index($text,\
    \ $consonant);\n        if ($index > 0) {\n            $text =~ s/^.*$consonant//;\n\
    \            $text =~ s/.$consonant$//;\n        }\n    }\n    foreach my $vowel(@vowels)\
    \ {\n        my $index = index($text, $vowel);\n        if ($index > 0) {\n  \
    \          $text =~ s/^.*$vowel//;\n            $text =~ s/.$vowel$//;\n     \
    \   }\n    }\n    return $text;\n}", "    my $vowels = \"aeiouy\";\n    $text\
    \ =~ s/[aeiouy]/ig;", "    $text =~ tr/[aeiouAEIOU]//d;\n    return $text;\n}",
  "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}", "    my $no_vowels = '';\n\
    \    my $no_consonants = '';\n    foreach my $c (@{$text}){\n        if ($c =~\
    \ /^[aeiouy]+$/){\n            $no_consonants .= $c;\n        } else {\n     \
    \       $no_vowels .= $c;\n        }\n    }\n    return $no_consonants;\n}\n</code>\n\
    <|/ a tags=perl,string |>\n<| a dscore=0 |>\nHere is an OO implementation in Perl\n\
    <code>\nuse strict;\nuse warnings;", "    $text =~ s/[aeiou]//g;\n    $text =~\
    \ s/^/@/;\n    return $text;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a\
    \ simple program that uses Perl's Regular Expression capabilities to remove vowels\
    \ from a string:\n<code>", "    $text =~ tr/aeiouyAEIOUY/AEIOUY/;\n    return\
    \ $text;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| a dscore=0 |>\nI like to use\
    \ the following regex which I find more flexible:\n<code>\n^[aeiouy][aeiouy]+$\n\
    </code>\nThis regular expression will match exactly 4 characters, where each character\
    \ is either a vowel followed by a vowel, or a single vowel\n<|/ a tags=perl,regex\
    \ |>\n<| c |>\nThat would not match \"aaaa\".\n<|/ c |>\n<| c |>\n, well yes,\
    \ I guess I should have made it clear that each character should be either an\
    \ vowel or a non-vowel\n<|/ c |>\n<| a dscore=0 tags=perl,regex |>\nI see there\
    \ are quite a lot of answers here on how to remove vowels from the string using\
    \ tr/// (which I like to). But you also wanted to see what was wrong with your\
    \ regex.\n<code>\nuse strict;\nuse warnings;\nmy $text = <STDIN>;\n$text =~ s/[aeiouyAEIOUY]/]/;\n\
    print $text;\n</code>\nIt will remove any vowels from the string including y.\
    \ The regex is greedy and will eat up the string until it can find a vowel.\n\
    <code>\nuse strict;\nuse warnings;\nmy $text = <STDIN>;\n$text =~ s/[aeiouyAEIOUY]/]/;\n\
    print $text;\n</code>\nIt will replace all vowels with only one vowel. The regex\
    \ is greedy and will eat up all the vowels until it can find a vowel.\n<code>\n\
    use strict;\nuse warnings;\nmy $text = <STDIN>;\n$text =~ s/[aeiouyAEIOUY]/]/;\n\
    print $text;\n</code>\nIt will replace all vowels with only one vowel. The regex\
    \ is greedy and will eat up all the vowels until it finds a vowel.\nIn other words,\
    \ your regex will remove any vowel character or an empty string from the string.\
    \ Which means it will remove all vowels from the string.\n<|/ a |>\n<| c |>\n\
    `tr///` does not replace anything but rather removes all occurrences. Therefore,\
    \ `s/[aeiouyAEIOUY]/]/;` removes all vowels.\n<|/ c |>\n<| c |>\nYes it does.\
    \ All occurrences are replaced by an empty string.\n<|/ c |>\n<| c |>\nNope. It\
    \ won't remove anything. Try it ", "    return \"\" if $text eq \"\";\n    my\
    \ $chars = $text;\n    $chars =~ s/[aeiouAEIOU]//g;\n    return $chars;\n}", " \
    \   my $string = uc($text);\n    $string =~ tr/aeiouAEIOU/AEIOUaeiouAEIOU/;\n\
    \    $string;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
