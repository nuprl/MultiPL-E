name: HumanEval_51_remove_vowels
language: pl
prompt: "# remove_vowels is a function that takes string and returns string without\
  \ vowels.\n# >>> remove_vowels(\"\")\n# \"\"\n# >>> remove_vowels(\"abcdef\")\n\
  # \"bcdf\"\n# >>> remove_vowels(\"aaaaa\")\n# \"\"\n# >>> remove_vowels(\"aaBAA\"\
  )\n# \"B\"\n# >>> remove_vowels(\"zbcd\")\n# \"zbcd\"\nsub remove_vowels {\n   \
  \ my($text) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_vowels;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\nghijklm\"\
  ),\"bcdf\nghjklm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"fedcba\"),\"fdcb\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"\
  ),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  acBAA\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"EcBOO\"),\"cB\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ybcd\"\
  ),\"ybcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    $text =~ tr/aeiuouyAEIUYaeiouy//cd;\n    return $text;\n}", " \
    \   chomp($text);\n    $text =~ s/[aeiouy]//g;\n    $text =~ s/y$//g;\n    return\
    \ $text;\n}", "    my(@chars) = split(//, $text);\n    my $result = \"\";\n  \
    \  foreach my $char (@chars) {\n        if (!grep( $char eq \"A\" || $char eq\
    \ \"E\" || $char eq \"I\" || $char eq \"O\" || $char eq \"U\" || $char eq \"a\"\
    ,\n                $text)) {\n            $result .= $char;\n        }\n    }\n\
    \    $result;\n}", "    $text =~ s/[aeiou]//g;\n    return $text;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is a lot more pythonic - thank you.\n<|/ c |>\n<| c |>\n\
    This is a lot more pythonic than mine.  But my code also works - as does your\
    \ code - but yours is a lot more concise.\n<|/ c |>\n<| c |>\n: I like yours too.\
    \ :)\n<|/ c |>\n<| c |>\nI like the `map { s/[aeiou]//g; $_ } split //` style\
    \ for doing things with lists I haven't used before. I also like the `join` style\
    \ for doing the same thing with strings. I was thinking about using `map` myself,\
    \ but I didn't think of it because I'm more used to `map` used on lists than strings.\n\
    <|/ c |>\n<| c |>\n: I like `map` too. :)\n<|/ c |>\n<| a tags=regex,perl |>\n\
    Here's how I would do it.  Note the use of regex capture groups to get your matches\
    \ out in the order you want.\n<code>", "    my(@vowels) = ('a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U');\n    chomp $text;\n    foreach my $v (@vowels)\
    \ {\n        if ($text =~ m/\\Q$v\\E/) {\n            $text =~ s/\\Q$v\\E//g;\n\
    \        }\n    }\n    $text;\n}", "    $text =~ tr/aeiouAEIOU//cd;\n    $text\
    \ =~ tr/o//cd;\n    return $text;\n}", "    $text =~ s/[aeiouyAEIOUY]+//g;\n \
    \   return $text;\n}", '    my $text = $text;', "    my $vowels = \"aeiouAEIOU\"\
    ;\n    $text =~ s/[${vowels}]/ig;\n    return $text;\n}", "    chomp($text);\n\
    \    foreach my $c (split('', $text)) {\n        if($c eq \"a\" || $c eq \"e\"\
    \ || $c eq \"i\" || $c eq \"o\" || $c eq \"u\") {\n            $text =~ s/$c/\"\
    \";\n        }\n    }\n    return $text;\n}", "    return $text unless $text;\n\
    \    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    $text =~ s/[aeiouy]//g;\n\
    \    $text =~ s/[aeiou]//g;\n    return $text;\n}", "    my $no_vowels;\n    my\
    \ $vowels_regexp = qr{[aeiouAEIOU]{2,}};\n    while(my $c = substr($text,pos($text),1))\
    \ {\n        last if $c =~ $vowels_regexp;\n        $no_vowels .= $c;\n    }\n\
    \    return $no_vowels;\n}", "    my(@vowels) = ('a', 'e', 'i', 'o', 'u');\n \
    \   my $vowel_re = \"\";\n    for my $i (0 .. $#vowels) {\n        $vowel_re .=\
    \ $text->[$_] if $text->[$_] =~ $vowels[$i];\n    }\n    $text->[0] = uc($text->[0])\
    \ if $text->[0] !~ /[aeiou]/;\n    $text->[0] = lc($text->[0]) if $text->[0] !~\
    \ /[AEIOU]/;\n    $text->[0] = $vowel_re;\n    return $text;\n}", "    my $text_len\
    \ = length($text);\n    my(@vowels) = (\"a\", \"e\", \"i\", \"o\", \"u\");\n \
    \   my $i = 0;\n    my $text = \"\";\n    my $vowel = \"\";\n    while (!eof($text))\
    \ {\n        $vowel = substr($text, $i, 1);\n        if (index($vowels, $vowel)\
    \ != -1) {\n            $text .= substr($text, 0, $i);\n            $text .= substr($text,\
    \ 0, $i);\n            $i++;\n        }\n        $i++;\n    }\n    return $text;\n\
    }", "    return lc $text if $text !~ /\\A[a-zA-Z]+\\z/;\n    $text =~ tr/aeiou//d;\n\
    \    return $text;\n}", "    my $result = '';\n    foreach my $ch (split //, $text)\
    \ {\n        my $i = 0;\n        $result .= $ch;\n        $ch = '';\n        for(my\
    \ $x = 1; $x <= length($ch); $x++) {\n            next unless $ch->[$x] in 'aeiou';\n\
    \            $i++;\n        }\n        $result .= $ch->[0..$i];\n    }\n    $result;\n\
    }", "    my($vowels) = @_;\n    if($vowels) {\n        my @vowels = split('',\
    \ $_[0]);\n        $_[0] =~ s/[aeiou]/ig;\n        $_[0] =~ s/^$vowels//;\n  \
    \      $_[0] =~ s/$vowels$/ig;\n    }\n    return $text;\n}", "    $text =~ tr/aeiouAEIOU//cd;\n\
    \    $text =~ tr/aeiouAEIOU//d;\n    return $text;\n}", "    $text =~ tr/aeiouAEIOU/eiouAEIOU/;\n\
    \    return $text;\n}", "    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"y\");\n    $text =~ s/[AEIOUY]//g;\n    return $text;\n}", "    $text =~ s/[aeiouy]+//g;\n\
    \    return $text;\n}", "    my $vowels = \"aeiouAEIOU\";\n    return $text =~\
    \ s/[($vowels)]//g;\n}", "    my $vowels = 'aeiou';\n    $text =~ s/[AEIOU]//g;\n\
    \    $text =~ s/($vowels)/$1/g;\n    $text;\n}", "    $text =~ s/[aeiou]/ig;\n\
    \    return $text;\n}\n</code>\nThe main difference between our version and your\
    \ version is that mine is a function and your is a subroutine. As you see, there\
    \ are other differences. In Perl a sub behaves a lot like C's function than a\
    \ subroutine.\nNow that we know how to create a function, we can use it in our\
    \ code in the following ways:\nUsing a function:\n<code>\nmy $text = remove_vowels(\"\
    zzzz\");\n</code>\nUsing a subroutine:\n<code>", "    $text =~ tr/aeiouAEIOU/aeiouAEIOU/;\n\
    \    return $text;\n}\n</code>\nThe other solutions offered here are also fine,\
    \ but using tr is the more efficient and easiest way to achieve your aim.\n<|/\
    \ a tags=perl,python,ruby,string |>\n<| c |>\n\"Efficiency\"? I would guess that\
    \ `tr` has to do with how it performs the matching. The efficiency of `tr` is\
    \ very dependent on the size of the string to operate on. On a small string, I'd\
    \ expect `tr` being much slower than `split` and `join` (which would involve more\
    \ string building).\n<|/ c |>\n<| c |>\n: That depends on how you define efficiency.\
    \ `tr` is probably slightly faster than `split` and `join`, but it does have a\
    \ slightly higher overhead (it needs to loop over every character in a string),\
    \ so if you have a very small string, you're likely to see it being slower. On\
    \ the other hand, `split` and `join` are more readable, and if you have more than\
    \ one thing to do, they offer some amount of readability.\n<|/ c |>\n<| a tags=perl,python,ruby,string\
    \ |>\nThe most efficient way is probably using Regular Expressions.\nI haven't\
    \ benchmarked them, but they are definitely the way to go if you want to perform\
    \ several operations on a string. In my experience, Regexp's are usually the most\
    \ efficient ways to manipulate strings in any programming language that uses them,\
    \ such as Perl, Ruby, or Python.\nI did a quick test with Regexp's and the String::Substitution\
    \ module and found that String::Substitution was the fastest (by about a factor\
    \ of 2). Here are the results for string \"abcdef\":\n<code>\nperl -MBenchmark\
    \ -lwe '$str=\"abcdef\"; my $s=benchmark(\"g\",sub{s/a/X/g},$str); print \"$s\\\
    n\";'\ng\nBenchmark: timing 1000000 iterations of g...\n       Rate  String::Substitution\
    \ string\ng      83,061   0.223 usr/s\n</code>\nSo, in this case it appears that\
    \ String::Substitution is the best way to go. I know this is an old post, but\
    \ I wanted to let anyone who is searching for the best solution to a problem know\
    \ that it's no longer true.\n<|/ a dscore=3 |>\n<| c |>\nYou have to consider\
    \ the size of the string. Regexps perform faster if strings are less than 1000\
    \ characters long. I suspect that `tr` is the fastest ", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    my $vowels = \"aAeEiIoOuU\";\n    $text =~ s/[AEIOUaeiou]//g;\n\
    \    return $text;\n}", "    my $result;\n    $result .= $text if $text =~ m/^[a-z]$/i;\n\
    \    $result .= $text if $text =~ m/([aeiou])[aeiou]\\1/;\n    $result .= $text\
    \ if $text =~ m/[aeiou][aeiou]\\1/;\n    return $result;\n}", "    my $vowels\
    \ = \"aeiouAEIOU\";\n    $text =~ s/$vowels//g;\n    return $text;\n}", "    $text\
    \ =~ s/[aeiouy]/e/g;\n    $text =~ s/[aeiou]/y/g;\n    return $text;\n}", "  \
    \  chomp($text);\n    my @chars = split(//,$text);\n    $_ = $chars[$#chars];\n\
    \    return join \"\", grep {!/[aeiouAEIOU]/} @chars;\n}\n</code>\n<|/ a dscore=3\
    \ tags=perl |>\n<| c |>\nThanks for the code. I would like to know if there is\
    \ a way we can refactor the code so it looks a bit cleaner and doesn't contain\
    \ nested code blocks.\n<|/ c |>\n<| c |>\nThe code looks clean and well structured\
    \ if you have your `sub { ... }` wrapped around a couple of `if` statements. \
    \ I think I got it right.  I wouldn't write it like that, but you probably already\
    \ have your mindset set on it.\n<|/ c |>\n<| a dscore=2 |>\nHere is a cleaner\
    \ way to remove vowels from a string. \n<code>\nuse strict;\nuse warnings;\nuse\
    \ feature 'say';", "    my($vowels) = (\"a\",\"e\",\"i\",\"o\",\"u\");\n    \n\
    \    $text =~ s/^[aeiou]//;\n    $text =~ s/[AEIOU]//g;\n    $text =~ s/[aeiou]$/../;\n\
    \    $text =~ s/^././;\n    return $text;\n}", "    my $vowels = 'aeiou';\n  \
    \  $text =~ s/[${vowels}]//g;\n    return $text;\n}", "    my $re = join '|',\
    \ map quotemeta($_), qw(A E I O U Y); # Build regex from list of vowels.\n   \
    \ return $text =~ s/$re//;\n}", "    my($no_vowels);\n    my($vowels);", "   \
    \ return $text unless $text;\n    $text =~ s/[aeiouy]+//g;\n    return $text;\n\
    }\n</code>\nNow we can see how it works and what it does:\n<code>\n$ perl -le\
    \ \"print remove_vowels('aaaaa'); print remove_vowels('zbcd');\"\naaaaa\nzbcd",
  "    $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}", "    my($vowels) = qw(a\
    \ e i o u);\n    my @vowel_positions;\n    for my $i (0..$#$text) {\n        my\
    \ $char = $text[$i];\n        if (grep($char =~ /^[AEIOU]$/, @$vowels)) {\n  \
    \          push @vowel_positions, $i;\n        }\n    }\n    my $final_text =\
    \ \"\";\n    my $i;\n    for $i (0..$#$vowel_positions) {\n        $final_text\
    \ .= substr($text, $vowel_positions[$i], 1);\n    }\n    return $final_text;\n\
    }\n</code>\n<|/ a tags=string,perl |>\n<| c |>\nThanks! Can you explain what `grep`\
    \ does in `grep($char =~ /^[AEIOU]$/, @$vowels)` ?\n<|/ c |>\n<| c |>\n[perldoc](http://perldoc.perl.org/functions/grep.html)\
    \ says it returns an array with all the matches of `$char` in `@$vowels`; so `grep($char\
    \ =~ /^[AEIOU]$/, @$vowels)` returns all the positions where `$char` matches any\
    \ element of `@$vowels`. So `grep($char =~ /^[AEIOU]$/, @$vowels)` returns all\
    \ the positions where `$char` matches any of the elements of `@$vowels`, and `grep($char\
    \ =~ /^[AEIOU]$/, @$vowels)` returns all the positions where `$char` matches any\
    \ of the elements of `@$vowels` that is also a string, so it returns an array\
    \ with all matches in `@$vowels` where `$char` matches any element of `@$vowels`.\n\
    <|/ c |>\n<| a |>\nThis seems like the sort of thing that Text::Diff would be\
    \ good for.\nIt has a function to diff sequences of strings, called diff_seq,\
    \ which will return a list of the differences.\n<code>\nuse Text::Diff;", "  \
    \  $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>\npackage perl;", "    $text =~ tr/[AEIOUYaeiouy]//d;\n \
    \   return $text;\n}", '    my($vowels) =  qw(aae ao uo o au);', "    $text =~\
    \ tr/aeiou//cd;\n    return $text;\n}", "    my @vowels = \"aeiouAEIOU\";\n  \
    \  grep { !/${vowels}/ } $text;\n}", "    my($vowels) = qw(a e i o u);\n    my($new);\n\
    \    $text =~ s/[aeiouAEIOU]//g;\n    foreach my $letter (split(//, $text)) {\n\
    \        my $index = index($vowels, $letter);\n        if ($index <= -1) {\n \
    \           $new .= $letter;\n        } else {\n            $new .= substr($text,\
    \ 0, $index);\n            $new .= substr($text, $index + 1) if $index > 0;\n\
    \        }\n    }\n    return $new;\n}\n</code>\n<|/ a tags=regex,perl |>\n<|\
    \ a tags=regex,perl dscore=0 |>\nUsing a regexp to filter out vowels just to remove\
    \ them is overkill and just complicates things. It's also a lot less efficient\
    \ than simple character comparisons.\n<code>\nuse strict;\nuse warnings;\nuse\
    \ 5.010;", "    $text =~ s/[AEIOUaeiou]//g;\n    return $text;\n}", "    $text\
    \ =~ s/[AEIOUaeiou]//g;\n    return $text;\n}", "    my(@new_text);\n    \n  \
    \  foreach $char (split(//, $text)) {\n        if (lc($char) eq \"a\") { $new_text[$#new_text]\
    \ = \"a\" }\n        elsif (lc($char) eq \"e\") { $new_text[$#new_text] = \"e\"\
    \ }\n        elsif (lc($char) eq \"i\") { $new_text[$#new_text] = \"i\" }\n  \
    \      elsif (lc($char) eq \"o\") { $new_text[$#new_text] = \"o\" }\n        elsif\
    \ (lc($char) eq \"u\") { $new_text[$#new_text] = \"u\" }\n        elsif (lc($char)\
    \ eq \"y\") { $new_text[$#new_text] = \"y\" }\n    }\n    \n    return join(\"\
    \", @new_text);\n}", "    $text =~ tr/AEIOUaeiouAEIOU/aaaaaAEIOU/;\n    $text\
    \ =~ tr/AEIOUaeiouAEIOU/a//;\n    $text =~ tr/aeiouAEIOU/o//;\n    $text =~ tr/AEIOUaeiouAEIOU/A//;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/e//;\n    $text =~ tr/AEIOUaeiouAEIOU/I//;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/O//;\n    $text =~ tr/AEIOUaeiouAEIOU/U//;\n\
    \    return $text;\n}\n</code>\n<|/ a |>\n<| c |>\nI agree with you about the\
    \ `tr` usage, but the `tr` usage is really bad. `tr`/`tr///` is *expensive*: it\
    \ is really slower than a direct substitution. Try it yourself with `\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    `, for example.\n<|/ c |>\n<| c |>\nI agree with you for the `tr` part, but `s/^/\\\
    n/;` = `s/^\\n/\\n/;`, which might be faster than `tr`/`tr///`. As I see it `tr`\
    \ does two things: it looks for `$text` beginning with `\\n`; and it is much faster\
    \ since it does a single `str_replace`.\n<|/ c |>\n<| c |>\nI see! So I made a\
    \ benchmark test and the direct substitution is ~3 times faster than `tr`/`tr///`.\
    \ So I guess the answer is that `tr`/`tr///` will be faster if the string is bigger\
    \ than ~100 characters.\n<|/ c |>\n<| c |>\nIt doesn't look like you tested `remove_vowels`.\
    \ You just tested `tr`.\n<|/ c |>\n<| c |>\nYeah, but I tested `remove_vowels`\
    \ as well. I will edit my answer to include both `tr` tests and `remove_vowels`.\n\
    <|/ c |>\n<| a tags=regex,perl,substitution,string |>\n<code>\n$text =~ s/a//g;\n\
    $text =~ s/A//g;\n$text =~ s/e//g;\n$text =~ s/E//g;\n$text =~ s/I//g;", "   \
    \ return join(\"\", grep !($_ =~ /[aeiou]/g), $text);\n}", "    $text =~ tr/aeiouAEIOU/aaaa/;\n\
    \    $text =~ tr/bcdfghjklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;\n    $text\
    \ =~ tr/zbcdfghjklmnopqrstuvwxyz/ZBCDEFGHIJKLMNOPQRSTUVWXYZ/;\n    $text =~ tr/yzbcdfghjklmnopqrstuvwxyz/YZBCDEFGHIJKLMNOPQRSTUVWXYZ/;\n\
    \    return $text;\n}\n</code>\nFor your code, I have two recommendations:", " \
    \   return $text =~ s/[aeiouy]/ig;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy\
    \ not `$text =~ s/[aeiouy]/ig;`?\n<|/ c |>\n<| c |>\nThanks, I updated the answer\
    \ with your suggestion.\n<|/ c |>\n<| c |>\nThe result is the same, doesn't work.\
    \ Maybe it's something else. I think it's because the `sub` function doesn't seem\
    \ to work as I expect.\n<|/ c |>\n<| c |>\nThanks for the example. Really appreciate\
    \ the effort. Still didn't work, so I'm going to try and test some other things\
    \ out first.\n<|/ c |>\n<| a tags=perl,regex,substitution dscore=0 |>\nI think\
    \ you have to be careful with how you call your subroutine.\nPerl has a special\
    \ variable $_ that contains the current line.  When you use $_ in a subroutine,\
    \ it returns the value of $_.  It does not return the value of the argument passed\
    \ to it.  \nThus, your program might look like this:\n<code>\nmy $a = 'abcde';\n\
    my $b = remove_vowels($a);\n</code>\n$a is the same as $_ and $b is the same as\
    \ $_.\nIf you do this:\n<code>\nmy $a = 'abcde';\nmy $b = remove_vowels($a);\n\
    print $b;\n</code>\nThe result will again be abcde because $_ is set to the current\
    \ line and $a is set to the argument.\nIf you want your function to return the\
    \ value of the argument, you should make it a subroutine and give it an argument.\
    \  It should look like this (note the lack of parens):\n<code>", "    $text =~\
    \ tr/aeiouAEIOU//d;\n    $text =~ tr/AEIOUaeiouAEIOU//d;\n    return $text;\n\
    }\n</code>\n<|/ a tags=perl dscore=1 |>\n<| c |>\nPlease explain how this would\
    \ be used in place of existing code. For example, how would you replace the string\
    \ `remove_vowels` with `tr/aeiouAEIOU//d` ?\n<|/ c |>\n<| a dscore=1 tags=perl\
    \ |>\n<code>\nmy $text = \"aaBAA\";\nprint \"$text with vowel removed\" unless\
    \ $text =~ tr/aeiouAEIOU//d;\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", " \
    \   $text =~ s/[AEIOUaeiou]/ig;\n    return $text;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe `if` can be omitted and just `$text =~ s/[AEIOUaeiou]/ig` will\
    \ do. Also, you can use the alternation (`/|/`) instead of the concatenation (`/+`).\
    \ Also, you don't need to add `/ig` at the end. That option only affects [global\
    \ flags](https://perldoc.perl.org/perlre.html#Modifiers-for-regular-expressions)\
    \ (`$~`)\n<|/ c |>\n<| c |>\nYou also don't need to write `return $text;`. A subroutine\
    \ with no `return` returns `undef`.\n<|/ c |>\n<| c |>\nAnd this `if` statement\
    \ is superfluous: `if ($text =~ /^([aeiou])+$/) { $text =~ s/[AEIOUaeiou]/ig;\
    \ }`\n<|/ c |>\n<| a |>\nThis one also works well\n<code>\n$text=\"aaaaa\";\n\
    $text=~s/[aeiou]//g;\n</code>\n<|/ a dscore=2 tags=perl,regex |>\n<| c |>\nWhat\
    \ if `aeiou` was in `$text` like \"aeiouAEIOUaeiou\"?\n<|/ c |>\n<| a tags=perl,regex\
    \ dscore=1 |>\nTry this one\n<code>\n$text=\"aaaaa\";\n$text=~s/[aeiou]/ig;\n\
    </code>\n<|/ a |>\n<| c |>\nThis deletes the vowels, but you still get \"aeiou\"\
    \ in the end which is what OP does not want.\n<|/ c |>\n<| c |>\n: No, it doesn't.\
    \ The regex `[aeiou]` matches *only* the vowels. The replace part is `/ig`, which\
    \ means \"replace with all matches of the regex\".\n<|/ c |>\n<| c |>\nYour answer\
    \ was missing a `$` sign: `$text=~s/[aeiou]/ig;`\n<|/ c |>\n<| a dscore=1 tags=perl,regex\
    \ |>\nThis will remove all vowels from $text\n<code>\n$text = \"aaaaa\";\n$text\
    \ =~ s/[aeiouAEIOU]/ig;\n</code>\n<|/ a |>\n<| c |>\nYour solution removes the\
    \ vowels but it leaves the letters 'a' and '", "    my @vowels = (\"a\", \"e\"\
    , \"i\", \"o\", \"u\");\n    my @text = split(//, $text);", "    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiou/;\n    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiou/;\n    $text =~ tr/AEIOUaeiouAEIOU/aeiouAEIOU/;\n\
    \    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiou/;\n    $text =~ tr/aeiouAEIOUaeiouAEIOU/AEIOUaeiou/;\n\
    \    $text =~ tr/aeiouAEIOUaeiouAEIOU/aeiouAEIOU/;\n    $text =~ tr/aeiouAEIOUaeiouAEIOU/AEIOUaeiou/;\n\
    \    $text =~ tr/aeiouAEIOUaeiouAEIOU/aeiouAEIOU/;\n    $text =~ tr/aeiouAEIOUaeiouAEIOU/AEIOUaeiou/;\n\
    \    return $text;\n}", "    return $text if $text =~ m{[^aeiou]+}ig;\n    return\
    \ $text;\n}", "    $text =~ tr/aeiouAEIOU/AEIOUaeiou/;\n    return $text;\n}",
  "    if ($text !~ /[AEIOUaeiou]/) {\n       return $text;\n    }\n    my @text =\
    \ split //, $text;\n    shift @text;\n    my $result = join '', @text;\n    $result\
    \ =~ s/(.)(?!\\1)//g;\n    $result;\n}", '    if ($text eq "") { return $text;
    }', "    s/[aeiou]/gi;\n    return $text;\n}", "    if ($text !~ /[aeiou]/) {\n\
    \        return $text;\n    }\n    else {\n        return $text =~ /[aeiou]/g;\n\
    \    }\n}", "    my $text = $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nfunction vowel_filter($text){\n \
    \   #remove all vowels except the 'a'\n    $text =~ s/[aeiou]/ig;\n    #replace\
    \ all vowels with nothing\n    $text =~ s/[AEIOU]/ig;\n    return $text;\n}",
  "    $text =~ s/[aeiouy]//g;\n    return $text;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>", "    $text =~ s/[aeiouAEIOU]//ig;\n    return $text;\n\
    }", "    $text =~ tr/aeiouAEIOU/AEIOU/;\n    return $text;\n}", "    return substr($text,\
    \ 0, 1) . substr($text, -1) unless $text =~ /[aeiouAEIOU]/g;\n    return $text;\n\
    }", "    my(@vowels) = ('a', 'e', 'i', 'o', 'u');\n    my $vowel = shift @vowels;\n\
    \    my ($vowel_count, $vowel_count_total) = find_vowel_count($text);\n    $text\
    \ =~ tr/[aeiouAEIOU]/d; # remove vowels\n    $text =~ tr/[aeiou]/d; # remove consonants\n\
    \    return $text if $vowel_count == $vowel_count_total;\n    my $new;\n    while\
    \ ($vowel_count > 0) {\n        $new .= substr($text, 0, 1);\n        $vowel_count\
    \ -= 1;\n    }\n    $new .= substr($text, 1);\n    return $new;\n}", "    $text\
    \ =~ s/[aeiouy\xE0\xE1\u1EA3\xE3\u1EA1\u0103\u0111\xE2\u1EA5\u1EAD\u1EA9\u1EAB\
    \xE8\xE9\u1EBB\u1EBD\xEA\u1EBF\u1EC1\u1EC3\u1EC5\xEC\xED\u1EC9\u0129\xED\uFFFD\
    \uFFFD\uFFFD\uFFFD\uFFFD\u0129\xF3\xF2\xF5\xF4\u1ECF\xF8\u1ECD\xF9\xFA\u1ED1\xFB\
    \xFC\xFD\xC1\xC0\xC2\u1EA2\xC3\u1EA0\u0102\u0110\xC2\u1EA4\u1EA6\u1EAC\u1EA8\u1EAA\
    \xC9\xC8\xCA\u1EBA\u1EBC\xCA\u1EBE\u1EC0\u1EC2\u1EC4\xCD\xCC\xCC\xCC\xCC\xD4\xD2\
    \xD4\xD4\xD4\xD5\xD5\xD5\xDA\xD9\xD9\xD9\xDA\xDC\xDD\xDD\xDD\xDF\u014A\u014C\u014D\
    \u014E\u014F\u0150\u0151\u0170\u0150\u0150\u0170\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\u0150\
    \u0150\u0150\u0150\u0150\u0150\u0150", "    $text =~ s/[aeiouy]+//ig;\n    return\
    \ $text;\n}", "    my($vowels, $non_vowels);\n    my($vowels_count, @vowels);\n\
    \    my($non_vowels_count, @non_vowels);\n    my(@non_vowels_count, @non_vowels);",
  "    local $text =~ s/[aeiouAEIOU]//g;\n    $text =~ s/(?<!^)\\B([aeiouAEIOU])(?!$)//g;\n\
    \    $text;\n}\n</code>\n<|/ a tags=string,perl,regex dscore=4 |>\n<| c |>\n:\
    \ You're right, my mistake. Should have used `/a` instead of `/A`\n<|/ c |>\n\
    <| c |>\nIt would be better if you could explain what this is doing. I've been\
    \ reading it all day and still don't understand it. Especially the `/g` and then\
    \ `/gc`.\n<|/ c |>\n<| c |>\n: It uses global matching mode. Basically, the code\
    \ only matches a single occurrence of 'a', then 'A', then 'e', then 'E', etc.\
    \ and removes the characters. Then it uses global matching mode again to remove\
    \ every occurrence of 'A', 'B', etc. (`c` matches 'c', `C`, `d` matches 'd', `D`,\
    \ etc.). Then it uses global matching mode again to remove every occurrence of\
    \ 'E', 'F', etc. (`g` matches `e`, `E`, `g`, `G`, etc.).\n<|/ c |>\n<| c |>\n\
    : I added an explanation and a link to a page explaining Perl's regexp syntax.\
    \ I'm sorry if my explanation is lacking.\n<|/ c |>\n<| c |>\nPerl's regexp syntax\
    \ is deceptively complex so it's hard for me to wrap my head around this code.\
    \ I think I need to start from scratch. Thanks for the answer, though! I'll play\
    \ around with it later when I get some time.\n<|/ c |>\n<| a tags=string,perl,regex\
    \ dscore=3 |>\nHere is another way:\n<code>\nmy %vowels = ( 'a' => 'A', 'e' =>\
    \ 'E', 'i' => 'I', 'o' => 'O', 'u' => 'U' );\nprint join '', map { $vowels{$_}\
    \ } split //, $your_string;\n</code>\n<|/ a |>\n<| c |>\n+1 but I would use `split\
    \ //, ...` instead of `split '', ...` because `//` avoids having to escape the\
    \ delimiters.\n<|/ c |>\n<| c |>\nThis is perfect. Thanks for sharing.\n<|/ c\
    \ |>\n<| a tags=string,perl,regex |>\nThis is another way:\n<code>", "    $text\
    \ =~ tr/aeiouyAEIOUY/yAEIOUY/;\n    return $text;\n}\n</code>\nAnd I suggest using\
    \ Perl 6. It\u2019s much easier to use and easier to learn than Perl 5, and it\u2019\
    s supported on most Unix platforms.\n<code>\nuse v6;\nuse String::Random;\nsay\
    \ rand + rand + rand;\n</code>\n<|/ a |>\n<| c |>\nThat said, you probably want\
    \ a better PRNG, since `rand` is [not cryptographically secure](http://security.stackexchange.com/questions/63818/is-it-possible-to-use-rand-in-java).\
    \ You might consider [the answer here](http://security.stackexchange.com/questions/15708/why-do-rand-functions-not-use-random-sources-to-populate-the-seed)\
    \ instead.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    $text =~ s/[aeiouAEIOU]/?/g;\n\
    \    return $text;\n}", "    chomp($text);\n    $text =~ s/[aeiouAEIOU]+//ig;\n\
    \    $text =~ s/^[aeiouAEIOU]//ig;\n    $text =~ s/[aeiouAEIOU]+$//ig;\n    return\
    \ $text;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=regex,perl,string |>\n<code>",
  "    $text =~ tr/aeiouAEIOU//cd;\n    $text =~ tr/AEIOUaeiouAEIOU//cd;\n    return\
    \ $text;\n}", "    my $noVowels = $text =~ tr/aeiou//cd;\n    return $noVowels\
    \ . $text;\n}", "    my(@chars);\n    $text =~ s/[aeiouyAEIOUY]//g;\n    push,\
    \ @chars;\n    return $text;\n}", "    map { $_ eq 'a' || $_ eq 'e' || $_ eq 'i'\
    \ || $_ eq 'o' || $_ eq 'u' || $_ eq 'y' ? $_ : $_ } $text;\n}", "    if ($text\
    \ =~ m/[aeiouy]/) {\n        $text =~ s/[aeiouy]+//ig;\n    }\n    return $text;\n\
    }", "    $text =~ s/[aeiouAEIOU]//g;\n    $text =~ s/[bcdfghjklmnpqrstvwxyz]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl,subroutine,substring dscore=0\
    \ |>\n<| c |>\nYour regex is incorrect. it also removes some characters that you\
    \ did not intend it to.\n<|/ c |>\n<| c |>\nYou're right! Thanks for the correction!\
    \ I fixed it now.\n<|/ c |>\n<| a |>\nHow about using regex replace?\n<code>\n\
    $str =~ s/[aeiouAEIOU]//g;\n</code>\n<|/ a tags=perl,subroutine,substring dscore=0\
    \ |>\n<| c |>\nThanks Mitra. I tried that, but I get a warning, saying:\nUse of\
    \ uninitialized value $str in concatenation (.) or string at replace.pl line 7.",
  "    return $text unless $text;\n    $text =~ s/[AEIOUaeiou]/gi;\n    return $text;\n\
    }", "    my($c) = qr{[aeiou]}; # create regex for vowels\n    return join '',\
    \ map { chr grep { !$c->match($_) } unpack('C*', $text) };\n}\n</code>\n<|/ a\
    \ tags=perl,regex dscore=2 |>\n<| c |>\nThanks for this.  It took me a while to\
    \ wrap my head around it, but this approach is very clean and simple.\n<|/ c |>\n\
    <| a dscore=1 tags=perl,regex |>\nTo remove every vowel from a string you can\
    \ use the following regex:\n<code>\n$text =~ s/[aeiou]//g;\n</code>\n<|/ a |>\n\
    <| a tags=perl,regex |>\nTry this,\n<code>", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouy]+//g;\n    return $text;\n}",
  "    return $text =~ s/[aeiou]/ig;\n}\n</code>\n<|/ a dscore=4 tags=regex,perl |>\n\
    <| a dscore=3 |>\nIf performance is critical, here is a benchmark for all three\
    \ solutions.\nThe test data is generated from the file \"words\" (one word per\
    \ line):\n<code>\n$ cat words\napple\nbook\nchicken\ndog\nelephant\nfish\ngoldfish\n\
    hen\nice\nink\nkite\nlemon\nlime\nmango\nmouse\norange\npanda\npig\npuppy\nrock\n\
    rum\nsnake\ntiger\ntuna\nwater\nwatermelon\n</code>\nThe benchmark results (in\
    \ milliseconds):\n<code>\nremove_vowels - 0.18\nremove_vowels_re_1 - 0.07\nremove_vowels_re_2\
    \ - 0.06\n</code>\nThe test code:\n<code>\nuse strict;\nuse warnings;\nuse feature\
    \ 'say';\nuse Benchmark qw(:all);", "    $text =~ s/[aeiouy]+//g;\n    return\
    \ $text;\n}\n</cell>\n<cell>", "    return $text if $text eq '';\n    return $text\
    \ =~ s/[aeiouAEIOU]//g;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| a tags=perl,regex\
    \ |>\nHere is another one:\n<code>", "    $text =~ tr/aeiou/AEIOU/;\n    $text\
    \ =~ tr/AEIOUaeiou/AEIOU/;\n    $text =~ tr/aeiouAEIOU/AEIOU/;\n    $text =~ tr/\xE6\
    \xF8\xE5AEIOU\xE6\xF8\xE5/AEIOU/;\n    return $text;\n}", "    my($vowels) = qw(a\
    \ e i o u);\n    $text =~ s/[AEIOUY]+//g;\n    return $text;\n}", "    \n    return\
    \ \"\" if $text eq '';\n    \n    # split into chars\n    my(@chars) = split //,\
    \ $text;", "    $text =~ tr/AEIOUaeiouAEIOU/AEIOU/;\n    $text =~ tr/bcdfghjklmnopqrstuvwxyzBCDFGHJKLMNOPQRSTUVWXYZ/bcdfghjklmnopqrstuvwxyzBCDFGHJKLMNOPQRSTUVWXYZ/;\n\
    \    return $text;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nAwesome! Your remove_vowels()\
    \ is much cleaner!\n<|/ c |>\n<| a tags=regex,perl |>\nThe code in the question\
    \ didn't work as intended, as the regex was trying to match 'o' or 'i' at the\
    \ beginning of the word. I've updated it to ignore case and to allow for multiple\
    \ vowels anywhere in the word. I've also added code to remove all non-vowel chars.\n\
    <code>", "    return lc $text if $text =~ /[aeiou]/g;\n    return $text;\n}",
  "    return $text =~ s/[aeiou]/undef/g;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nmy $str = \"abcde\";\nmy $repl = join(\"\",map {if(/[aeiou]/){\"\
    \"}else{substr($_,-1,1)}} split //, $str);\nprint $repl;\n</code>\n<|/ a tags=perl,regex\
    \ |>\n<| a tags=perl,regex dscore=0 |>\n<code>\n$text =~ s/\\W\\K.*\\K\\W//g;\n\
    </code>\nThis should remove the characters from the end of your string. \\K keeps\
    \ the characters you match from being deleted so you don't lose them. \\W matches\
    \ all non-word characters.\n<code>\nmy $str = \"abcdef\";\n$str =~ s/\\W\\K.*\\\
    K\\W//g;\nprint $str;\n</code>\nprints bcdef\n<code>\nmy $str = \"abcdef\";\n\
    $str =~ s/\\W\\K.*\\K$//g;\nprint $str;\n</code>\nprints bcdf\n<code>\nmy $str\
    \ = \"abcdef\";\n$str =~ s/\\W\\K.*//g;\nprint $str;\n</code>\nprints bcdef\n\
    <|/ a |>\n<| a |>\nHere are some ways to do it.  \n<code>\n$string =~ s/[aeiou]//ig;\n\
    $string =~ s/(.)\\1+/$1/g;\n</code>\n<|/ a tags=perl,regex dscore=0 |>\n<| a |>\n\
    <code>\n$string =~ s/(.)\\1+/$1/g;\n</code>\n<|/ a dscore=0 tags=perl,regex |>\n\
    <| c |>\nPlease add some explanation to your answer, rather than just posting\
    \ some code.\n<|/ c |>\n<| a tags=perl,regex dscore=0 |>\n<code>\n$string =~ s/^.*(..).*$/\\\
    1/g;\n</code>\n<|/ a |>\n<| c |>\nPlease add some explanation to your answer,\
    \ rather than just posting some code.\n<|/ c |>\n<| c |>\n$string =~ s/^.*(..).*$/\\\
    1/g will remove all but last two characters from string\n<|/ c |>\n<| c |>\nPlease\
    \ add some explanation to your answer, rather than just posting some code.\n<|/\
    \ c |>\n<| a |>\nRemove last 2 characters from a string $str\n<code>", "    my\
    \ %vowels = map { $_ => 1 } \"aeiou\";\n    $text =~ s/[AEIOU]//g;\n    return\
    \ $text;\n}", "    $text =~ s/[aeiouAEIOU]//ig;\n    $text =~ s/^[aeiouAEIOU]//ig;\n\
    \    $text =~ s/[aeiouAEIOU^]//ig;\n    $text =~ s/^[aeiouAEIOU^]//ig;\n    $text\
    \ =~ s/[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+$//ig;\n    $text =~\
    \ s/^[aeiouAEIOU^]+//ig;\n    $text =~ s/^[aeiouAEIOU^]+$//ig;\n    $text =~ s/^[aeiouAEIOU^]+//ig;\n\
    \    $text =~ s/[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+$//ig;\n   \
    \ $text =~ s/^[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+//ig;\n    $text\
    \ =~ s/[aeiouAEIOU^]+$//ig;\n    $text =~ s/^[aeiouAEIOU^]+//ig;\n    $text =~\
    \ s/[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+$//ig;\n    $text =~ s/^[aeiouAEIOU^]+//ig;\n\
    \    $text =~ s/[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+$//ig;\n   \
    \ $text =~ s/^[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+//ig;\n    $text\
    \ =~ s/[aeiouAEIOU^]+$//ig;\n    $text =~ s/^[aeiouAEIOU^]+//ig;\n    $text =~\
    \ s/[aeiouAEIOU^]+//ig;\n    $text =~ s/[aeiouAEIOU^]+$//ig;\n    return $text;\n\
    }", "    $text =~ s/[aeiou]/#/g;\n    return $text;\n}", "    return undef if\
    \ !defined($text);\n    return $text =~ s/[AEIOUaeiouAEIOU]/o/g;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI'm voting for you, but I've chosen to keep this answer\
    \ as unvoted as I do not understand what is the motivation behind it (no offense).\n\
    <|/ c |>\n<| c |>\nthanks for your suggestion, but i have to keep my existing\
    \ codes because of other reasons.\n<|/ c |>\n<| c |>\nWhat is wrong with my answer,\
    \ why you vote for it?\n<|/ c |>\n<| c |>\nThe point is that you do not understand\
    \ why the given script is bad practice, yet you propose an improved version of\
    \ it that is also bad practice and leaves room for errors and misunderstanding.\
    \ Thus, I think it is better to ask a question about your specific situation instead\
    \ of criticizing my answer that makes me think your code is fine.\n<|/ c |>\n\
    <| c |>\n, i agree with your point and i appreciate you to  help me and i also\
    \ agree with you.\n<|/ c |>\n<| a |>\n<code>\nuse v5.10;\nuse strict;\nuse warnings;",
  "    return $text if $text eq '';\n    my $vowels = \"AEIOUaeiou\";\n    $text =~\
    \ tr/aeiou//cd;\n    $text =~ s/(?<![AEIOUaeiou])[AEIOUaeiou]//g;\n    return\
    \ $text;\n}\n</code>\n<|/ a tags=perl dscore=0 |>\n<| c |>\nThanks for the answer.\
    \ Your code is really good but I am not very good with Perl and would need some\
    \ time to decipher it for me to understand it. I am just looking for a code that\
    \ can do the same thing as my code and will help me understand it better so I\
    \ can apply it to other problems.\n<|/ c |>\n<| c |>\nI added comments to the\
    \ code to help you. Hope it helps.\n<|/ c |>\n<| a tags=perl dscore=0 |>\nHere\
    \ is a one-liner solution that uses map and split\n<code>\n$ perl -MList::Util=uniq\
    \ -E 'say map { m/(.)(.+)/; m$1 }\n                       uniq(map { m/([AEIOUaeiou])\\\
    1/ ? '$1' : undef }\n                         split //' <<< \"abcdeaeiuo\"\nabcde\n\
    $ perl -MList::Util=uniq -E 'say map { m/(.)(.+)/; m$1 }\n                   \
    \    uniq(map { m/([AEIOUaeiou])\\1/ ? '$1' : undef }\n                      \
    \   split //' <<< \"aBcdefgAeioou\"\nBcdef\n</code>\nHere is a longer explanation.\
    \ uniq is a function that takes a list and returns only unique elements. Here\
    \ it filters away duplicated elements within each line by using a regex that matches\
    \ any character followed by itself (repeated twice). Then it filters away all\
    \ strings that are not repeated (except the last character).\n<code>\n$ perl -MList::Util=uniq\
    \ -E 'say map { m/(.)(.+)/; m$1 }'\n       uniq(map { m/([AEIOUaeiou])\\1/ ? '$1'\
    \ : undef }\n         split //\n           <<< \"abcdeaeiuo\"\nabcde\n$ perl -MList::Util=uniq\
    \ -E 'say map { m/(.)(.+)/; m$1 }'\n       uniq(map { m/([AEIOUaeiou])\\1/ ? '$1'\
    \ : undef }\n         split //", "    $text =~ s/[aeiouAEIOU]/EMPTY/g;\n    $text\
    \ =~ s/(EMPTY|[a-z]+)\\z//;\n    return $text;\n}\n</code>\n<|/ a dscore=3 tags=perl\
    \ |>\n<| c |>\nThanks, it works fine but I can't understand how it works. Can\
    \ you explain it?\n<|/ c |>\n<| c |>\nThe `$text =~ s/[aeiouAEIOU]/EMPTY/g` replaces\
    \ all vowels by a space. This way `remove_vowels` can return an arbitrary string\
    \ of any number of spaces.\n<|/ c |>\n<| a dscore=2 tags=perl |>\nHere's another\
    \ version that is functionally identical (modulo whitespace)\n<code>", "    my\
    \ @chars = split(//, $text);\n    my $no_vowels;\n    foreach my $c (@chars) {\n\
    \        my $i = $c;\n        if (($i - 1 .. $i + 1) =~ m/[AEIOUaeiou]/) {\n \
    \           $no_vowels .= $c;\n        } else {\n            $no_vowels .= $_\
    \ unless $c eq \"a\" or $c eq \"e\" or $c eq \"i\" or $c eq \"o\" or $c eq \"\
    u\";\n        }\n    }\n    return $no_vowels;\n}", "    $text =~ s/[AEIOUaeiou]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nI haven't used this\
    \ before, but it looks like it's exactly what I was looking for. I'll have to\
    \ read up on it. I just posted a question here before I realized that my professor\
    \ had already solved the problem in another language using regex. His solution\
    \ was just as complicated as mine, which I felt was weird. Anyway, I'll read up\
    \ on it now, and if it works, I'll mark it as the correct answer.\n<|/ c |>\n\
    <| c |>\nOkay, I've read up on it. It looks like it'll work. However, when I try\
    \ using it, it removes every other character from the string as well. I've posted\
    \ my code in the original question. It's in perl. Any idea why this happens?\n\
    <|/ c |>\n<| c |>\n: I believe you're supposed to use the `s` modifier, to tell\
    \ it what to do. See `perldoc perlrun` for details.\n<|/ c |>\n<| c |>\n: I don't\
    \ think you need the `g` modifier for this. Try this: `$text =~ s/[AEIOUaeiou]//s`.\n\
    <|/ c |>\n<| a |>\nYou can use the transliteration function of String::Unidecode.\
    \ See this question on SO.\n<code>\nuse String::Unidecode qw(unidecode translit);",
  "    $text =~ s/[aeiou]//ig;\n    return $text;\n}", "    $text =~ s/[AEIOUaeiouAEIOU]//g;\n\
    \    return $text;\n}", "    return $text if $text eq '';", "    $text =~ s/[aeiou]//g;\n\
    \    $text =~ s/^[aeiou]//g;\n    $text =~ s/$[aeiou]//g;\n    return $text;\n\
    }\n</code>\n<|/ a tags=perl |>\n<| c |>\n`/[aeiou]/` is a \"character class\"\
    \ that matches any of the characters inside the brackets *inclusive*. `/a|e|i|o|u/`\
    \ matches any of the characters `a`, `e`, `i`, `o`, `u`, but not `a` *or* `e`.\n\
    <|/ c |>\n<| c |>\nyes, you are right. I'll fix it.\n<|/ c |>\n<| a tags=perl\
    \ |>\n<code>", "    my $vowels = \"aeiou\";\n    return $text unless $text;\n\
    \    return $text if $text =~ m/[^aeiou]/g;\n    $text =~ s/[^$vowels]//g;\n \
    \   return $text;\n}", "    $text =~ s/[aeiouyAEIOUY]+//g;\n    return $text;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI believe that you should remove the `+`\
    \ at the end of your pattern (`s/[aeiouyAEIOUY]+//g`) because otherwise there\
    \ will be a double replacement.\n<|/ c |>\n<| a tags=perl,pattern-matching,regex\
    \ dscore=1 |>\nThis code works as you want:\n<code>\nuse strict;\nuse warnings;",
  "    $text =~ tr/aeiouAEIOUaeiouAEIOU//cd;\n    return $text;\n}", "    $text =~\
    \ tr/aeiouAEIOU//cd;\n    return $text;\n}\n</code>\n<|/ a tags=string,perl,regex,substring\
    \ |>\n<| a |>\nI realise this is pretty late to the party, but I wrote an answer\
    \ for someone who was looking for a solution to this problem that would work for\
    \ non-ASCII characters:\n<code>", "    $text =~ s/[aeiouyAEIOUY]//g;\n    return\
    \ $text;\n}\n</code>\nThe last step is to use the remove_vowels function in remove_dup_words.\
    \ Notice that remove_dup_words is a function which takes list of strings as parameter\
    \ and returns a list of strings without repeated words. \n<code>", "    my(@vowels)\
    \ =\n        map { chr 32 } # !A\n        map { chr 33 } # !O\n        map { chr\
    \ 34 } # !U\n        map { chr 35 } # !A\n        map { chr 36 } # !E\n      \
    \  map { chr 37 } # !O\n        map { chr 38 } # !U\n        map { chr 39 } #\
    \ !I\n        map { chr 40 } # !O\n        map { chr 41 } # !U\n        map {\
    \ chr 42 } # !A\n        map { chr 43 } # !E\n        map { chr 44 } # !O\n  \
    \      map { chr 45 } # !U\n        map { chr 46 } # !A\n        map { chr 47\
    \ } # !E\n        map { chr 48 } # !O\n        map { chr 49 } # !U\n        map\
    \ { chr 50 } # !A\n        map { chr 51 } # !E\n        map { chr 52 } # !O\n\
    \        map { chr 53 } # !U\n        map { chr 54 } # !A\n        map { chr 55\
    \ } # !E\n        map { chr 56 } # !O\n        map { chr 57 } # !U\n        map\
    \ { chr 58 } # !A\n        map { chr 59 } # !E\n        map { chr 60 } # !O\n\
    \        map { chr 61 } # !U\n        map { chr 62 } # !A\n        map { chr 63\
    \ } # !E\n        map { chr 64 } # !O\n        map { chr 65 } # !U\n        map\
    \ { chr 66 } # !A\n        map { chr 67 } # !E\n        map { chr 68 } # !O\n\
    \        map { chr 69 } # !U\n        map { chr 70 } # !A\n        map { chr 71\
    \ } # !E\n        map { chr 72 } # !O\n        map { chr 73 } # !U\n        map\
    \ { chr 74 } # !A\n", "    my $vowels = \"aeiou\";\n    $text =~ tr/aeiou//d;\n\
    \    return $text;\n}", "    my $vowels = \"aeiouy\";\n    $text =~ s/[aeiouy]//g;\n\
    \    $text =~ s/^[aeiouy]//g;\n    return $text;\n}", "    my($vowels) = ('a',\
    \ 'e', 'i', 'o', 'u');\n    my $filtered_text = \"\";\n    while($text ne '')\
    \ {\n        foreach my $vowel (@$vowels) {\n            if($text =~ m/$vowel/)\
    \ {\n                $filtered_text .= $vowel;\n            }\n        }\n   \
    \     $filtered_text .= $text;\n        $text = \"\";\n    }\n    return $filtered_text;\n\
    }\n</code>\n<|/ a tags=perl,replace |>\n<| a tags=perl,replace |>\nHere's a solution\
    \ that doesn't do an in-place replacement:\n<code>", "    my $len = length($text);\n\
    \    \n    $text =~ s/[aeiouy]//g;\n    \n    for (my $i = $len; $i > 0; $i--)\
    \ {\n\tmy $char = $text[$i];\n\tif ($char eq $_) {\n\t    splice(@text, $i, 1);\n\
    \t    last;\n\t}\n    }\n    \n    return $text;\n}", "    $text =~ s/[aeiouyAEIOUY]//g;\n\
    \    return $text;\n}\n</code>\nAnd here is the perl code without regexes:\n<code>\n\
    use strict;\nuse warnings;\nuse List::Util qw(uniq);", "    local $text =~ tr/aeiuoAEIOUaeiou/ydD/;\n\
    \    $text =~ tr/ydD/aeiuoAEIOUaeiou/;\n    return $text;\n}", "    my($vowels)\
    \ = qw(a e i o u);\n    my($consonants) = qw(d f g h j k l m n p q r s t v w x\
    \ z j k l m n p q r s t v w x z);\n    my($output) = ();\n    my($i);", "    $text\
    \ =~ s/[aeiouy]+//ig;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nPerl can do such manipulations\
    \ with a regular expression, just like in other languages (Java, C#, C++, etc.)\n\
    <code>", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n}", "    $text =~\
    \ tr/AEIOUaeiou/aeiou/;\n    $text =~ tr/AEIOUaeiou/AEIOU/;\n    return $text;\n\
    }", "    $text =~ tr/AEIOUaeiouAEIOU/AEIOU/;\n    return $text;\n}", "    return\
    \ \"\" if $text eq '';\n    my $vowels = \"aeiouAEIOU\";\n    $text =~ s/[^$vowels]//g;\n\
    \    return $text;\n}", "    my(@vowels) = qw(a e i o u);\n    map {\n       \
    \ foreach my $v (@vowels) {\n            next if $text =~ /$v/;\n        }\n \
    \       $_;\n    } split //, $text;\n}\n</code>\n<|/ a |>\n<| c |>\nNice.  I didn't\
    \ know that map could take a block as it's 2nd argument.\n<|/ c |>\n<| c |>\n\
    Nice job with the `remove_vowels` function -- it's so much more flexible than\
    \ the other solutions that I think it would benefit from being named `remove_non_vowels`\
    \ (or something)\n<|/ c |>\n<| c |>\n: I think `remove_non_vowels` is better :)\n\
    <|/ c |>\n<| c |>\nI'd argue that `remove_vowels` should return an empty string\
    \ rather than removing vowels.  If there are no vowels, it should return an empty\
    \ string, otherwise it should return the string.  So it should either return an\
    \ empty string, or return the same string as its parameter.  `remove_vowels` should\
    \ probably also be passed the `$vowels` array.\n<|/ c |>\n<| c |>\n: Yes, that's\
    \ a better way of doing it.\n<|/ c |>\n<| a |>\nAnother solution using map and\
    \ grep is as follows:\n<code>\nmy $text = 'The quick brown fox jumps over the\
    \ lazy dog';\nmy = qw(a e i o u);\nmy = map {chomp; grep {$_ !~~/[AEIOU]/} split\
    \ //, $_} grep {$_ !~~/[AEIOU]/} split //, $text;\nprint \"@filtered\\n\";\n</code>\n\
    This produces:\n<code>\nthe quick brown fox jumps over the lazy\n</code>\n<|/\
    \ a dscore=4 tags=string,perl |>\n<| c |>\nI like the `map grep {...}` idea. \
    \ I still think it'd be easier to understand if it were written `map {chomp; grep\
    \ {$_ !~~/[AEIOU]/} split //, $_}`.\n<|/ c |>\n<| c |>\n: You're right.  I was\
    \ thinking I couldn't do `map grep {...}`, but that isn't true.  However, I do\
    \ think it is better written as `map {chomp; grep {$_ !~~/[AEIOU]/} split //,\
    \ $_}` -- it is easier to understand for future maintainers.\n<|/ c |>\n<| c |>\n\
    I don't think that's right.  `map {chomp", "    chomp $text;\n    $text =~ s/[AEIOUYaeiouy]+//g;\n\
    \    $text =~ s/^[a-z]+//;\n    $text =~ s/\\s+/ /g;\n    return $text;\n}\n</code>\n\
    <|/ a tags=perl,regex |>\n<| c |>\nThis isn't the only way to solve the problem\
    \ since you can also use the /g flag to find all occurrences.\n<|/ c |>\n<| c\
    \ |>\nI did something very similar with your answer but used a subroutine. Thanks\
    \ anyway.\n<|/ c |>\n<| a tags=perl,regex |>\nHere's a solution that doesn't use\
    \ regexes at all. I'm sure this is an exercise for the student, though, since\
    \ I'm sure this kind of question would be marked down if you posted it here, so\
    \ I'm just posting this solution here:\n<code>", "    $text =~ s/[aeiou]/e/g;\n\
    \    return $text;\n}\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\n: You're welcome.\
    \ Your code was also very short and clear - that's why it took me a while to see\
    \ it.\n<|/ c |>\n<| a tags=perl,regex dscore=2 |>\nI reckon that you are trying\
    \ to implement the classic Hilbert Transform algorithm, in Perl.\nPerl has several\
    \ libraries implementing this algorithm, as you already know.\nThe most commonly\
    \ used is Algorithm::Hilbert. Here is an example using it:\n<code>", "    chomp($text);\n\
    \    return join '', map {\n        my $char = chr $_;\n        map {\n      \
    \      my $vowel = $_;\n            $char eq $vowel ? \"\" : \"$vowel\"\n    \
    \    } qw(a e i o u);\n    } split //, $text;\n}", "    $text =~ s/[aeiou]//g;\n\
    \    return $text;\n}\n</code>\n<|/ a |>\n<| a |>\nYou can do it with just one\
    \ regular expression:\n<code>\n$text =~ s/([^aeiou])[aeiou]+$//;\n</code>\nThe\
    \ () create a group that you can refer to with $1, $2, etc.\n[aeiou] matches one\
    \ vowel (ie. a, e, i, o, u).\n+ means one or more of the preceding expression\
    \ (ie. one vowel followed by one or more (ie. aeiou)\n$ means the end of the string.\n\
    Thus the regular expression matches any string that doesn't have at least two\
    \ vowels anywhere in it.\n<|/ a dscore=1 tags=regex,perl |>\n<| a dscore=1 tags=regex,perl\
    \ |>\nAs a slight improvement on's answer, you can also write your program in\
    \ a single substitution operation:\n<code>\nuse strict;\nuse warnings;", "   \
    \ my ($vowels) = @_;\n    \n    # Return empty string if there is no vowel to\
    \ remove.\n    return $text if ($text !~ /^[^aeiouAEIOU]$/);\n    \n    # Delete\
    \ the vowels from the string. \n    my $result = $text =~ s/[AEIOUaeiouAEIOU]//g;\n\
    \    \n    # Return original string if there are not vowels.\n    return $text\
    \ if ($result !~ /^[^aeiouAEIOU]$/);\n    \n    # Return string without vowels.\n\
    \    return $result;\n}", "    $text =~ s/[AEIOUYaeiouy]+//g;\n    return $text;\n\
    }\n</code>\n<|/ a dscore=2 tags=regex,perl |>\n<| c |>\n`/^[^aeiouy]+/` would\
    \ be simpler as `/^[aeiouy]*/` The only other thing that needs to be taken care\
    \ of is empty strings and strings with only `y`s.\n<|/ c |>\n<| c |>\nI like that\
    \ one. And I like the use of ranges. I always forget that you can use them in\
    \ character ranges. However, I am curious to know if there's a better way to do\
    \ this (since I am still a Perl beginner).\n<|/ c |>\n<| c |>\n`y/aeiouy//` also\
    \ works. But `y` is an abbreviation for [`tr///r`](http://perldoc.perl.org/functions/y.html),\
    \ so I tend to find it easier to remember.\n<|/ c |>\n<| a tags=regex,perl |>\n\
    I would do this:\n<code>", "    $text =~ s/[aeiouy\xE0\xE8\xEC\xF2\xF9]//g;\n\
    \    return $text;\n}", "    $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}",
  "    $text =~ s/[aeiouyAEIOUY]/ig;\n    $text =~ s/[aeiouAEIOU]//ig;\n    $text\
    \ =~ s/[aeiouAEIOU]//ig;\n    return $text;\n}", "    my $result = $text =~ tr/aeiouAEIOUaeiou/AaeiouAEIOU/;\n\
    \    return $result ? $result : $text;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The OP is also asking how to remove \"-\" from string, so you might add `tr/-//`\n\
    <|/ c |>\n<| c |>\nThe second part is not working. Maybe my regex is wrong. I\
    \ am not much familiar with regex.\n<|/ c |>\n<| c |>\nMaybe your regex is wrong.\
    \ I can't tell from your question what your requirements are exactly, but I think\
    \ I've given you the regex you should use. Can you explain what parts of my answer\
    \ are unclear and I'll try to clarify.\n<|/ c |>\n<| c |>\nThe regex should be\
    \ correct. Your problem is somewhere else.\n<|/ c |>\n<| a tags=perl,substitution,regex\
    \ |>\n<code>", "    my @chars = split(//, $text);\n    my $result = \"\";\n  \
    \  foreach my $char (@chars) {\n        next unless ($char =~ /[aeiou]/);\n  \
    \      $result .= $char;\n    }\n    return $result;\n}", "    $text =~ tr/AEIOUaeiouAEIOU/AEIOUaeiou/;\n\
    \    return $text;\n}", "    map { $text =~ s/[aeiouAEIOU]//g; $text } $text;\n\
    \    return $text;\n}", "    return undef unless(defined $text);\n    my($vowels)\
    \ = \"aeiouAEIOU\";\n    $text =~ tr/aeiouAEIOU//cd;\n    return $text;\n}", " \
    \   $text =~ s/[aeiou]//g;\n    return $text;\n}", "    chomp($text);\n    if\
    \ ($text =~ /[aeiou]/g) {\n        $text =~ s/[aeiou]//g;\n        return $text;\n\
    \    } else {\n        return $text;\n    }\n}", "    return $text =~ tr/aeiouAEIOU//cd;\n\
    }", "    $text =~ s/[aeiouyAEIOUY]//g;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    $text =~ s/^\\s*//;\n    $text =~ s/\\s*$//;\n    $text =~ s/([aeiouAEIOU])\\\
    1{2,}//g;\n    return $text;\n}", "    my(@vowels) = ('a', 'e', 'i', 'o', 'u');\n\
    \    foreach my $v (@vowels) {\n        $text =~ s/$v/_/g;\n    }\n    return\
    \ $text;\n}", "    my @vowels = qw(a e i o u);\n    return $text if $text eq '';\n\
    \    $text =~ s/[aeiou]/+/g;\n    $text =~ s/[aeiouy]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[aeiou]/y/g;\n\
    \    $text =~ s/[aeiou]/y/g;\n    $text =~ s/[", "    $text =~ tr/aeiouAEIOU//d;\n\
    \    $text =~ tr/aeiouAEIOU/.//d;\n    return $text;\n}", "    $text =~ s/[aeiouy]//gi;\n\
    \    $text =~ s/[AEIOUY]//gi;\n    $text =~ s/[aeiou]//gi;\n    $text =~ s/[AEIOU]//gi;\n\
    \    $text =~ s/[aeo]//gi;\n    $text =~ s/[AEO]//gi;\n    $text =~ s/[aey]//gi;\n\
    \    $text =~ s/[AEY]//gi;\n    $text =~ s/[ae]//gi;\n    $text =~ s/[AE]//gi;\n\
    \    return $text;\n}", "    my $letters = map {chr $_} 65..90;\n    my $new =\
    \ $text;\n    $text =~ s/([$letters])[^$letters]/\\1/g;\n    return $text;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThe `s/[b-z]/\\n/g` is totally unnecessary here. You\
    \ can just do `$text =~ tr/bcd/\\n/;`. Also, you should *not* use regex to parse\
    \ HTML.\n<|/ c |>\n<| c |>\nThanks for the answer! I'm just starting to learn\
    \ perl, so the regex was probably a bad choice for me. I guess i have to look\
    \ into better ways to do it\n<|/ c |>\n<| c |>\nRegex is not the way to go when\
    \ it comes to HTML parsing. It will work for the examples you provided, but you\
    \ will get unreliable results when parsing things like `<p>...</p>` or embedded\
    \ `<img>` tags. You should use a proper HTML parser. [Here is a tutorial on parsing\
    \ HTML with Perl.](http://www.perlmonks.org/?node_id=615114)\n<|/ c |>\n<| c |>\n\
    thanks for the tip, I'm going to check it out!\n<|/ c |>\n<| c |>\nI agree with\
    \ you, HTML parsing should be avoided when possible. I only used regex to demonstrate\
    \ how it can be done.\n<|/ c |>\n<| a |>\nThis simple one-liner will remove the\
    \ vowels from a string:\n<code>\nperl -pe 's/[aeiou]//g'\n</code>\nIt replaces\
    \ any character in [aeiou] with the empty string ''.\n<|/ a tags=regex,perl,string\
    \ dscore=0 |>\n<| c |>\nThis isn't what the OP was looking for.\n<|/ c |>\n<|\
    \ c |>\n\"Remove\" means that you replace them with an empty string.\n<|/ c |>\n\
    <| c |>\n: I guess you could say that. But it looks like that's what he actually\
    \ wants to do. His question is ambiguous.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    perl -pi -e 's/[aeiou]//g' file\n</code>\n<|/ a tags=regex,perl,string |>\n<|\
    \ c |>\nThis isn't what the OP was looking for.\n<|/ c |>\n<| a dscore=0 |>\n\
    Perl's chomp command might be helpful:\n<code>\nuse strict;\nuse warning", " \
    \   $text =~ tr/aeiouAEIOU/AEIOU/;\n    return $text;\n}\n</code>\nThis isn't\
    \ an ideal solution, but it works okay.  There are other ways of doing it, but\
    \ they all seem a bit too complicated for this problem, and I don't have time\
    \ to think about it right now.\n<|/ a dscore=2 |>\n<| a dscore=1 tags=perl,string,regex\
    \ |>\nJust for the record, here is how you might implement it in Perl:\n<code>\n\
    use strict;\nuse warnings;", "    $text =~ tr/aeiouAEIOU/aeiou/;\n    return $text;\n\
    }", "    my(@vowels) = ('a','e','i','o','u');", "    my $novowels = \"\";\n  \
    \  my $len = length($text);\n    my $i = 0;\n    while ($i < $len) {\n       \
    \ my $char = $text[$i];\n        if ($char eq \"A\" || $char eq \"E\" || $char\
    \ eq \"I\" || $char eq \"O\" || $char eq \"U\") {\n            $novowels .= $char;\n\
    \        }\n        $i++;\n    }\n    return $novowels;\n}", "    chomp($text);\n\
    \    my $vowels = \"aeiouAEIOU\";\n    $text =~ s/($vowels)//g;\n    return $text;\n\
    }", "    return \"\" unless defined($text);\n    my @chars = split(//, $text);\n\
    \    foreach my $char (@chars) {\n        next if $char eq \"a\" || $char eq \"\
    e\" || $char eq \"i\" || $char eq \"o\" || $char eq \"u\";\n        $char =~ s/[AEIOUaeiou]//g;\n\
    \    }\n    join(\"\", @chars);\n}\n</code>\nThe code above will remove all vowels\
    \ from the text string. \n<code>\nremove_vowels(\"aA\")\n</code>\nwill result\
    \ in a \"a\" as desired.\nHowever, this can be optimized.\n<code>", "    $text\
    \ =~ s/[aeiou]//g;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    my $len = length($text);\n    my $i = 0;\n    my\
    \ $lastvowel;\n    while ($i < $len) {\n        $lastvowel = substr($text, $i,\
    \ 1);\n        last if $lastvowel =~ /^[aeiouAEIOU]/i;\n        ++$i;\n    }\n\
    \    return substr($text, 0, $i);\n}", "    return $text =~ tr/aeiouAEIOU//cd;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`tr/aeiouAEIOU//cd` can be written as\
    \ `tr/aeiouAEIOU//c` or `tr/aeiouAEIOU/cd`\n<|/ c |>\n<| a dscore=3 |>\nSince\
    \ removing vowels from strings is a common and common problem, let's have a look\
    \ at an elegant solution that is very similar to one already provided. Let's keep\
    \ our original function and add a new one, remove_vowels_imp(), that implements\
    \ remove_vowels() using map and grep:\n<code>", "    $text =~ tr/aeiouAEIOU//cd;\n\
    \    $text;\n}\n</code>\nUsing regexes, the above can be done as such:\n<code>",
  "    my($result) = \"\";\n    my($vowels = qw( a e i o u y ));\n    while ($text\
    \ ne \"\") {\n\tmy($found, $pos) = qr{([aeiouy])};\n\tmy($replace, $remove) =\
    \ qr{(.)(?!$found)(?!$pos)};\n\twhile ($found =~ m/(.)/g) {\n\t    my($first)\
    \ = $1;\n\t    $first = $1 if $first =~ /^y/;\n\t    $result = $first . $result\
    \ unless $first =~ /$vowels$/i;\n\t}\n\t$text = substr $text, $pos, length $text;\n\
    \    }\n    return $result;\n}", "    $text =~ s/[aeiouy]/ig;\n    $text;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks! I will remember this for next time. :)\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\nmy $str = \"some text\";\n$str =~ s/[^a-z]/ig;\n\
    print \"$str\\n\";\n</code>\n<|/ a tags=perl,regex |>\n<| c |>\nThis will remove\
    \ all non-alphabetic characters, not only vowels.\n<|/ c |>\n<| c |>\nYou are\
    \ right. But the question was about vowels only so i wrote this.\n<|/ c |>\n<|\
    \ c |>\nOh, I see. Just add `y` after the `[aeiou]`.\n<|/ c |>\n<| c |>\n: Yeah,\
    \ I agree with you about using `y`. It is a habit to use. But I wasn't sure if\
    \ we were looking for vowels or not. I am just writing here in case the OP wants\
    \ vowels also.\n<|/ c |>\n<| a tags=perl,regex |>\nYou can use this regular expression\
    \ to match the vowels:\n<code>\nm/[aeiou]/\n</code>\n<|/ a dscore=0 |>\n<| a tags=perl,regex\
    \ |>\nTo match only vowels, you can use one of the following:\n<code>\ns/[aeiou]/ig;\n\
    s/[aeiouy]/ig;\ns/[aeiouy]/igy;\ns/[aeiouAEIOU]/ig;\ns/[aeiouAEIOUY]/ig;\ns/[aeiouAEIOUY]/igy;\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=perl,regex dscore=0 |>\n<code>\n$str =~\
    \ s/[aeiouyAEIOUY]/ig;\n</code>\n<|/ a |>\n<| c |>\nPlease don't post only code\
    \ as an answer, but also provide an explanation of what your code does and how\
    \ it solves the problem of the question. Answers with an explanation are usually\
    \ more helpful and of better quality, and are more likely to attract upvotes.\n\
    <|/ c |>\n<| c |>\nOkay, I made it more readable. Thanks for helping out.\n<|/\
    \ c |>\n<| c |>\nI didn't downvote, but you might want to explain how this works.\n\
    <|/ c |>\n<| a |>\n<code>\n$string = \"my awesome string\";\n$string =", "   \
    \ $text =~ s/[AEIOUYaeiouy]//g;\n    $text =~ s/[AEIOUYaeiouy]/-/g;\n    return\
    \ $text;\n}", "    return \"\" if $text eq \"\";\n    my @vowels = (\"a\",\"e\"\
    ,\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"\
    ,\"A\",\"E\",\"I\",\"O\",\"U\");\n    $text =~ s/[AEIOUaeiouAEIOU]//g;\n    $text\
    \ =~ s/$vowels//ig;\n    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n\
    \    return $text;\n}", "    return $text unless $text;\n    my $vowels = \"aeiouy\"\
    ;\n    return $text if $text =~ /^[^$vowels]+/;\n    return $text if $text =~\
    \ /^[^$vowels]*[aeiouy]/;\n    $text =~ tr/aeiouy//cd;\n    return $text;\n}",
  "    my @text = split //, $text;\n    my @vowels = qw(a e i o u);\n    $text =~\
    \ s/^\\s+//; # remove leading spaces\n    $text =~ s/\\s+$//; # remove trailing\
    \ spaces\n    for (@text) {\n        s/[AEIOUaeiouAEIOU]//g;\n    }\n    return\
    \ join(\"\", @text);\n}\n</code>\n<|/ a tags=perl,string,regex dscore=2 |>\n<|\
    \ c |>\n`s/^\\s+//; # remove leading spaces` You don't need to anchor to the start\
    \ of the string with `^`; `s{^}{}g` will remove all leading whitespace.\n<|/ c\
    \ |>\n<| c |>\n: Good point, but `^\\s+` would be `\\s{2,}` for that matter. I'll\
    \ edit that in. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    my($result,$i);\n\
    \    my($vowels,$i);\n    \n    $text = uc $text;\n    \n    for ($i=0;$i<length($text);$i++)\
    \ {\n        $vowels = qw(a e i o u);\n        $result = \"\";\n        for ($j=0;$j<length($vowels);$j++)\
    \ {\n            if ($text[$i] == $vowels[$j]) {\n                $result = $result\
    \ . $vowels[$j];\n            }\n        }\n        $result = uc $result;\n  \
    \      $text = substr($text,0,$i).$result.substr($text,$i+1);\n    }\n    return\
    \ $text;\n}", "    $text =~ s/[AEIOUaeiouAEIOU]/gi;\n    return $text;\n}", " \
    \   $text =~ s/[aeiou]//g;\n    return $text;\n}", "    $text =~ s/[AEIOUYaeiouyAEIOUY]/ig;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouy]+//g;\n    return $text;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI'm glad you added your notes, I always prefer\
    \ to keep it simple and straightforward, especially if it works.\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>\nuse strict;\nuse warnings;\nuse feature qw(say);", " \
    \   my $vowels = \"aeiouAEIOU\";\n    my $result = \"\";\n    \n    foreach my\
    \ $x (split(//, $text)) {\n        $x =~ tr/aeiouAEIOU//cd;\n        $result .=\
    \ $x;\n    }\n    \n    return $result;\n}", "    return $text =~ s/[aeiouy]+//g;\n\
    }", "    my $result = '';", "    $text =~ s/[aeiouAEIOU]//g;\n    return $text;\n\
    }\n</code>\n<|/ a tags=perl,regex dscore=1 |>\n<| a |>\nHow about this\n<code>\n\
    s/(^|\\.|\\[|\\]|\\s+|!|\\?|\\!|\\(|\\)|\\[|\\]|$)//g\n</code>\n<|/ a tags=perl,regex\
    \ dscore=0 |>\n<| a tags=perl,regex |>\nIn a script with lots of lines of code,\
    \ a perl one-liner is often not as readable as the equivalent bash one.\n<code>\n\
    perl -ne 'print unless /^[AEIOUaeiou]+$/' file.txt\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nThe other solutions use Perl regular expressions, but this particular\
    \ solution has two problems:", "    my $vowels = \"aeiou\";\n    my $replace =\
    \ join '', grep(!($_ =~ m/\\Q$vowels\\E/), split //, $text);\n    return $replace;\n\
    }", "    $text =~ tr/aeiouAEIOU//cd;\n    $text =~ tr/A-Z//cd;\n    $text =~ tr/Z//cd;\n\
    \    return $text;\n}\n</code>\n<|/ a |>\n<| a tags=perl dscore=2 |>\nThis may\
    \ help you understanding the concept of subroutine.\n<code>\nuse strict;\nuse\
    \ warnings;", "    $text =~ s/[^aeiouAEIOU]//g;\n    return $text;\n}", "    my\
    \ $s = $text;\n    $s =~ s/[aeiouAEIOU]//g;\n    return $s;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=2 |>\nHere is a solution written in perl\n<code>",
  "    $text =~ s/[aeiouAEIOU]/ig;\n    return $text;\n}", "    return $text =~ s/[aeiouy]+//g;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat if I want to remove all vowels other\
    \ than 'y' from a string?\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    $text =~\
    \ s/[aeiouAEIOU]//g;\n    return $text;\n}", "    return $text unless $text;\n\
    \    return $text if $text =~ /[aeiou]/;\n    return $text =~ s/[aeiouy]+//g;\n\
    \    return $text;\n}", "    $text =~ tr/aeiou//cd;\n    return $text;\n}", " \
    \   return substr($text, 0, length $text) =~ s/[AEIOUYaeiouy]//g;\n}\n</code>\n\
    <|/ a tags=perl,regex |>\n<| a |>\nAnother solution:\n<code>\nmy $string = \"\
    this is my string\";\n$string =~ tr/AEIOUaeiouy//cd;\nprint $string;\n</code>\n\
    <|/ a tags=perl,regex dscore=0 |>\n<| a |>\n<code>", "    map { /[AEIOUaeiou]/\
    \ && ! $_++ ? $_ : \"$&\" } split //, $text;\n}", "    chomp($text);\n    $text\
    \ =~ tr/aeiuoAEIO/AFIUE/g;\n    return $text;\n}", "    my(@vowels) = qw(a e i\
    \ o u);\n    my(@removed) = ();\n    my(@keep) = ();\n    \n    # Remove all vowels.\n\
    \    # If the string only contains consonants then\n    # simply return the string.\n\
    \    if($text =~ /[aeiou]/) {\n        return $text;\n    }\n    \n    # Loop\
    \ over vowels and remove them from the string.\n    foreach my $v (@vowels) {\n\
    \        if($text =~ /$v+/) {\n            push(@removed, $v);\n        }\n  \
    \  }\n    \n    # Keep consonants and add them to keep.\n    if($text =~ /[^aeiou]/)\
    \ {\n        foreach my $k (split(//, $text)) {\n            push(@keep, $k);\n\
    \        }\n    }\n    \n    return join(\"\", @removed) . join(\"\", @keep);\n\
    }", "    my $re = qr{[aeiouAEIOU]{2,}};\n    $text =~ s/$re//g;\n    return $text;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for the answer but that didn't\
    \ work for me. It just returns \"The page you were looking for is temporarily\
    \ unavailable\"\n<|/ c |>\n<| c |>\nMy mistake, I just realised that your code\
    \ didn't work either. However I just noticed that the regex isn't working. I'll\
    \ update my question.\n<|/ c |>\n<| c |>\nI updated my answer. Try this one. Also,\
    \ I'm assuming that your original method worked somehow, that's why I didn't change\
    \ anything. :)\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works if\
    \ I remove any duplicate spaces. But it doesn't work if I leave them in. Is that\
    \ a common problem?\n<|/ c |>\n<| c |>\nI'm sorry. Your code actually works. I\
    \ accidentally had two spaces before the beginning of the string and that's why\
    \ it didn't work. Thanks for your help. Really appreciate it.\n<|/ c |>\n<| a\
    \ |>\n<code>\n$text =~ s/[aeiou]+//gi;\n</code>\n<|/ a tags=perl,regex dscore=2\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nI didn't know that you could add modifiers at the\
    \ end of a regular expression. Thanks for the tip!\n<|/ c |>\n<| c |>\n: Yeah,\
    \ you can do that but you shouldn't be doing it that way.\n<|/ c |>\n<| a tags=perl,regex\
    \ |>\n<code>\n$text =~ s/[aeiou]/ig; #case insensitive\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThat works if your vowels are only one character but if your vowels\
    \ are more than 1, it still just removes one vowel.\n<|/ c |>\n<| a dscore=1 tags=perl,regex\
    \ |>\nThis will remove all vowels from your string\n<code>\n$str =~ s/[aeiouAEIOU]//g;\n\
    </code>\n<|/ a |>\n<| a tags=perl,regex |>\n<code>\n$text =~ s/[aeiouAEIOU]",
  '    return "" unless defined $text;', "    chomp($text);\n    $text =~ s/[aeiou]//g;\n\
    \    return $text;\n}", "    $text =~ s/[aeiouAEIOU]//g;\n    $text;\n}", '    my
    @vowels = qw( a e i o u y );', "    my $regex = qr/^([aeiou])(.)\\1([aeiou])\\\
    2$/g;\n    return $text =~ /$regex/s ? $3 : \"\";\n}", "    \n    if ($text eq\
    \ \"\") {\n        return $text;\n    }\n    \n    foreach my $char (split(//,\
    \ $text)) {\n        if ($char eq \"a\") {\n            $char = \"\";\n      \
    \  } elsif ($char eq \"e\") {\n            $char = \"\";\n        } elsif ($char\
    \ eq \"i\") {\n            $char = \"\";\n        } elsif ($char eq \"o\") {\n\
    \            $char = \"\";\n        } elsif ($char eq \"u\") {\n            $char\
    \ = \"\";\n        } elsif ($char eq \"A\") {\n            $char = \"\";\n   \
    \     } elsif ($char eq \"E\") {\n            $char = \"\";\n        } elsif ($char\
    \ eq \"I\") {\n            $char = \"\";\n        } elsif ($char eq \"O\") {\n\
    \            $char = \"\";\n        } elsif ($char eq \"U\") {\n            $char\
    \ = \"\";\n        } else {\n            $char = \"\";\n        }\n    }\n   \
    \ \n    return $text;\n}", "    $text =~ tr/aeiouy//cd;\n    return $text;\n}\n\
    </code>\nI recommend using Perl6::Awful for your subroutines as it makes things\
    \ much easier.\n<code>", "    $text =~ tr/aeiouAEIOU/aeiouAEIOU/;\n    return\
    \ $text;\n}", "    my @text = split(//, $text);\n    my $len = scalar(@text);\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        my $letter = $text[$i];\n   \
    \     if ($letter =~ /[aeiou]/) {\n            splice(@text, $i, 1);\n       \
    \     $len--;\n        }\n    }\n    my $out = join(\"\", @text);\n    return\
    \ $out;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
