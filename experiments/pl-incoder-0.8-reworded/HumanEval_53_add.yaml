name: HumanEval_53_add
language: pl
prompt: "# Add two numbers x and y\n# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\n\
  sub add {\n    my($x, $y) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add;\n  \
  \      if(eq_deeply($candidate->(0, 1),1)) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(1, 0),1)) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2,\
  \ 3),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5,\
  \ 7),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7,\
  \ 5),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $tmp = $x + $y;\n    my $ret = ${$_[0]}; $ret -= $tmp; $tmp\
    \ += $ret; $ret -= $tmp; $tmp += $ret;\n    $_[0] = $tmp;\n}", "    return $x\
    \ - $y;\n}", "    $x -= $y;\n    return $x;\n}", "    return $x - $y;\n}", " \
    \   ($x->{value} + $y->{value}) * $x->{scale} + $x->{offset};\n}", "    return\
    \ $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}", "    my $result\
    \ = $x - $y;\n    \n    # If $x is zero then subtract $y if $y > 0\n    for(0\
    \ .. $x) {\n        $result += $y if $y > 0;\n    }\n    \n    return $result;\n\
    }", "    return $x - $y;\n}", "    return $x - $y if $x > $y;\n    return $y -\
    \ $x if $x < $y;\n    return $x - $y;\n}", "    return $x - $y;\n}", "    return\
    \ $x + $y - abs($x + $y);\n}", "    $x -= $y;\n}", "    if (defined $x) { $x +=\
    \ $y; $x; }\n}", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\n\
    As you can see, we can use the function's return value. We don't have to explicitly\
    \ declare a variable.\nThe only variable is $x. If you want to return two values\
    \ (which we do), you can use references.\n<code>", "    return $x - $y;\n}", " \
    \   return $x - $y;\n}", "    $x + $y - $x;\n}", "    $x += $y;\n    $x -= $y;\n\
    \    $x %= $y;\n    $x += $y;\n    $x &= $y;\n    return $x;\n}", "    return\
    \ $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\nYou\
    \ can even write your own functions.\n<code>", "    $x -= $y;\n    $x *= $y;\n\
    \    return $x;\n}", "    return $x - $y;\n}", "    $x += $y;\n    $x;\n}", " \
    \   my $u = $x - $y;\n    $u > 0 ? $u : -$u\n}\n</code>\nSo now we can do\n<code>",
  "    my $x_ref = $x;\n    my $y_ref = $y;\n    my $x_value = $x_ref;\n    my $y_value\
    \ = $y_ref;\n    # $x_value /= $x_ref; # This isn't needed\n    # $y_value /=\
    \ $y_ref;\n    return $x_value - $y_value;\n}", "    $x -= $y;\n    $x *= $y;\n\
    \    $x += $y;\n    return $x;\n}\n</code>\nThen to implement the add function\
    \ we use a conditional operator to see if we need to do a subtraction or a multiplication.\n\
    <code>", "    $x - $y;\n}", "    $x - $y\n}", "    $x -= $y;\n}", "    $x + $y\n\
    }", "    $x - $y\n}\n1;\n</code>\n<|/ a dscore=5 tags=module,perl |>\n<| c |>\n\
    The `add` sub is unnecessary, it's just an example to show a function in the package\
    \ body. But the `sub` keyword is also unnecessary; it does nothing useful.\n<|/\
    \ c |>\n<| c |>\nWhy not `use strict;`?\n<|/ c |>\n<| c |>\n`use strict;` enables\
    \ many useful features that might not be enabled by other pragmas. For example,\
    \ it enables lexical scoping in subroutines because in Perl subroutines live in\
    \ their own \"scope\" (which has its own namespace), while lexical variables live\
    \ in the \"package\" scope.\n<|/ c |>\n<| c |>\nThanks Jonathan! I completely\
    \ agree that `sub` is unnecessary.\n<|/ c |>\n<| a tags=module,perl |>\nThe only\
    \ thing missing from Jonathan's example is the use of a fully qualified subroutine\
    \ name in your example. Perl allows you to use fully qualified subroutine names\
    \ if the subroutine is defined in a package that is in the current package or\
    \ package namespace:\n<code>", "    return $x - $y;\n}", "    my $z = $x - $y;\n\
    \    return $z if $z >= 0;\n    return $x + $y;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI like the `add` solution but I don't like the `sub` solution. One could\
    \ argue that `sub` is more readable than `add`, but I would agree that it should\
    \ be avoided, especially when the goal is to add two numbers.\n<|/ c |>\n<| c\
    \ |>\nI like this idea and will use it often, but I really don't like that `+`\
    \ is an alias for `add`. It looks strange that `+` has different semantics for\
    \ numeric and non-numeric arguments. Maybe I'm missing something, but I would\
    \ prefer `sub` over `add` since it avoids unnecessarily complicating things (adding\
    \ one number twice is one addition).\n<|/ c |>\n<| c |>\nI agree, the semantics\
    \ are very different and `+` could be confusing.\n<|/ c |>\n<| c |>\n`+` has different\
    \ semantics for numeric and non-numeric arguments is an interesting point. It\
    \ sounds like the designers of Perl thought about it differently than I would\
    \ think.\n<|/ c |>\n<| c |>\n- I agree. Unary operators are really weird. `+`\
    \ has different semantics for numeric and non-numeric arguments.\n<|/ c |>\n<|\
    \ a dscore=5 |>\nIn Perl 5, you have the addition operator which does this exact\
    \ same thing:\n<code>\nmy $x = 4; \nmy $y = 3;\nmy $z = $x + $y;\nprint \"$z\\\
    n\"; # prints 7\n</code>\n<|/ a tags=perl |>\n<| a dscore=5 |>\nThe Perl 5's +\
    \ operator does this.\nIn Perl 6, the addition operator also does this: It is\
    \ a \"binary operator\" that happens to be both addition and string concatenation\
    \ operator, as well as \"boolean operator\" that happens to be the addition operator\
    \ with precedence 1.\nIt is important to keep in mind that in Perl 5, the addition\
    \ operator also has different semantics for numeric and non-numeric arguments,\
    \ and that is why the addition operator is now part of the core language and not\
    \ an inherent extension.\nAs a result, it is now \"recommended\" to always use\
    \ the addition operator when adding two numeric values, as it is more readable\
    \ and less error prone than using any other arithmetic operator.\nThe addition\
    \ operator is used in various places, for example when doing some maths:\n<code>\n\
    my $x = 4;\n", "    my $op = $x ? \"+\" : \"-\";\n    $x or return $y ? $op $y\
    \ : $x;\n    return $y ? $op $x : $y;\n}", "    return $x - $y;\n}", "    return\
    \ $x - $y;\n}", "    return $x + $y - $x->{value};\n}", "    $x + $y;\n}", " \
    \   return $x + $y;\n}", "    $x + $y;\n}", "    return $x - $y;\n}", "    return\
    \ $x - $y;\n}", "    $x += $y;\n    return $x;\n}", "    return $x - $y;\n}",
  "    $x + $y;\n}\n</code>\n<|/ a dscore=3 tags=perl,operators |>\n<| c |>\nNice\
    \ one. I will probably use a \"do { } while\" instead of \"{ }\" for the conditional\
    \ part of my subroutine.\n<|/ c |>\n<| a dscore=3 |>\nThe perlfaq3 answers your\
    \ question:", "    return $x - $y;\n}", "    return $x + $y - $x;\n}", "    ($x\
    \ - $y) if (defined $x && defined $y);\n}", "    my $sum = abs($x - $y);\n   \
    \ # Don't do any subtractions unless absolutely necessary\n    if ($sum != 0)\
    \ {\n        return $sum;\n    }\n    # Add when negative\n    if ($x < $y) {\n\
    \        return $x;\n    }\n    # Add when positive\n    return $y;\n}\n</code>\n\
    This also takes care of any negative numbers, by reversing them and adding them.\n\
    <|/ a tags=perl,math,subtraction |>\n<| c |>\nThis only handles subtractions,\
    \ not additions.\n<|/ c |>\n<| c |>\nThis is just a matter of adding an `if` to\
    \ the subtraction code. Just remember that in Perl you just need to use the `+`\
    \ operator instead of `+`. Also, it's more idiomatic to use `abs` or `<=>` instead\
    \ of `-`\n<|/ c |>\n<| c |>\n`abs` also doesn't work for negative numbers!\n<|/\
    \ c |>\n<| a tags=perl,math,subtraction |>\nTry using the absolute value operator:\n\
    <code>\nmy $x = 10\nmy $y = 15\nmy $difference = abs($x-$y);\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n`abs` only works on positive numbers, not negative numbers.\n<|/\
    \ c |>\n<| a |>\nThe function you need is abs, not -.  -x is shorthand for -x\
    \ + x.\n<|/ a tags=perl,math,subtraction dscore=5 |>\n<| c |>\nIn Perl, `-x` is\
    \ shorthand for `-x + x` (`-x + x` returns `-x` which is then negated). `abs`\
    \ does not return the same value if `x` is a negative number.\n<|/ c |>\n<| c\
    \ |>\n: `-x` does `-x if $x > 0`\n<|/ c |>\n<| a |>\nThe function you are looking\
    \ for is abs, not - -- it returns the absolute value of the number.\n<code>\n\
    use warnings;\nuse strict;", "    $x + $y;\n}", "    $x -= $y;\n    $x;\n}", " \
    \   $x -= $y;\n    $x //= 2;\n}", "    $_ = $x + $y;\n}", "    return $x - $y;\n\
    }", "    return $x - $y;\n}", "    $x -= $y;\n    $x += $y;\n    return $x;\n}",
  "    if ($x == 0) {\n\treturn $y;\n    }\n    if ($y == 0) {\n\treturn $x;\n   \
    \ }\n    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\nYou can then import\
    \ the sub routine into your namespace by adding it to the __END__ of the same\
    \ file as your other subroutines:\n<code>\nuse Add;\n</code>\nThen you can just\
    \ use it like any other function in the same namespace:\n<code>\n$x + $y\n</code>\n\
    Which is much easier than typing out its full name:\n<code>\nAdd::add($x, $y)\n\
    </code>\nAnd it has the advantage of being available anywhere in your script without\
    \ having to import the sub routine or require the file.", "    return $x - $y;\n\
    }\n</code>\nIn this case it appears that the best you can do is use lexical aliases.\n\
    <|/ a dscore=2 tags=perl,oop |>\n<| c |>\nThanks. That does look promising, but\
    \ I don't think that will get me what I want. I'm looking to emulate something\
    \ similar to Perl's __PACKAGE__ and __INC__ variables.\n<|/ c |>\n<| c |>\nPerhaps\
    \ I misunderstood, but lexical variables don't do that.  You seem to be talking\
    \ about lexical scope and lexical variables.\n<|/ c |>\n<| c |>\nI believe Lexical\
    \ aliases would do the trick though. I'll look into that.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThere are a few things that you're not telling us, so I am going to make\
    \ an educated guess and assume that you want a module that looks like this:\n\
    <code>\npackage SomeClass;\nuse strict;\nuse warnings;", "    $x + $y;\n}", " \
    \   return $x - $y;\n}", "    $x += $y;\n    $x -= $y;\n    return $x;\n}", " \
    \   return $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\n\
    You will notice how I named the functions in lowercase and how I used them. I\
    \ can now use the function and name it however I like without worrying about naming\
    \ conflicts.\n<|/ a |>\n<| c |>\nHaha, I just realized that and deleted my comment.\
    \ Thank you!\n<|/ c |>\n<| c |>\n`my ($x,$y) = @_` is probably better style than\
    \ `my ($x, $y) = split \" \", shift; shift || die \"Not enough arguments\";`\n\
    <|/ c |>\n<| c |>\nI agree, it's also shorter. I was just trying to give the OP\
    \ a starting point on his own.\n<|/ c |>\n<| a dscore=3 |>\nAs far as I can see,\
    \ these are the best ways to make your function and what to do with it:\n1) Using\
    \ subroutines\n<code>", "    return $x - $y;\n}", "    my $out = $x - $y;\n  \
    \  $out == 0 ? ($out * -1) : $out;\n}", "    my $result = $x - $y;\n    $result\
    \ = 0 if $result < 0;\n    return $result;\n}", "    return $x - $y;\n}", "  \
    \  $x + $y - $y;\n}", "    $x->num - $y->num\n}", "    $x -= $y;\n    1;\n}",
  "    return $x - $y;\n}\n</code>\nThe method call is the same as you already did,\
    \ just with parenthesis.\n<code>", "    return $x - $y;\n}", "    return $x -\
    \ $y;\n}", "    $x + $y - $x if defined $y;\n}", "    return $x - $y;\n}", " \
    \   if ($x == $y) {\n        return 0;\n    }\n    return $x - $y;\n}", "    return\
    \ $x - $y;\n}", "    return $x - $y;\n}", "    $x -= $y;\n    $x if $x != 0;\n\
    }", "    return $x - $y;\n}\n</code>\nNote that in perl6 it is more common to\
    \ call the functions with a trailing _ (aka inplace addition):\n<code>", "   \
    \ return $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}", " \
    \   $x + $y - $y\n}", "    $x -= $y;\n    return $x;\n}", "    return $x + $y;\n\
    }\n</code>\nand call it like so\n<code>", "    my $rv = $x - $y;\n    $rv >= 0\
    \ ? $rv : $rv + 0x100000000 + 1;\n}", "    return $x - $y;\n}", "    $x - $y\n\
    }", "    $x -= $y;\n    $x += $y;\n    return $x;\n}", "    return $x - $y;\n}",
  "    return $x - $y unless $x > $y;\n    return $y - $x unless $y > $x;\n    return\
    \ 0;\n}", "    $x - $y\n}\n</code>\nIf you have to use the Perl 5 core libraries,\
    \ this is how it would be done in perl 5:\n<code>\nuse v5.10;\nmy $x = 2;\nmy\
    \ $y = 3;\nsay $x - $y;\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 |>\nPerl's\
    \ core libraries are a lot older than the language. \nThe language, however, is\
    \ much more mature, is very simple, and it supports most modern features of Perl\
    \ 5. It is also quite easy to extend Perl 5 to your needs.\nTo add two numbers,\
    \ you need:\n<code>\nmy $x = 2;\nmy $y = 3;\n$x + $y;\n</code>\nTo multiply them\
    \ (which is not the same as adding them):\n<code>\nmy $x = 2;\nmy $y = 3;\n$x\
    \ * $y;\n</code>\nTo subtract them (which is not the same as adding them):\n<code>\n\
    my $x = 2;\nmy $y = 3;\n$x - $y;\n</code>\nTo divide them (which is not the same\
    \ as adding them):\n<code>\nmy $x = 2;\nmy $y = 3;\n$x / $y;\n</code>\nTo round\
    \ them off (which is not the same as adding them):\n<code>\nmy $x = 2.5;\nmy $y\
    \ = 3;\n$x + $y;\n</code>\nTo raise them to their power:\n<code>\nmy $x = 2;\n\
    my $y = 3;\n$x ** $y;\n</code>\nTo check if a number is negative:\n<code>\nmy\
    \ $x = 2;\nmy $y = 3;\n$x < $y;\n</code>\n<|/ a tags=perl |>\n<| c |>\nI think\
    \ you meant `$x + $y` to multiply them :P\n<|/ c |>\n<| a |>\nIf you're looking\
    \ to get the current date and time, you could use the core DateTime module.\n\
    <code>\nuse DateTime::Format::Strptime;\nmy $now  = DateTime::Format::Strptime->new(\n\
    \   pattern  => '%Y-%m-%d %H:%M:%S'\n)->format_datetime();\nsay $now;\n</code>\n\
    Output:\n<code>\n2015-07-10 16:49:12\n</code>\n<|/ a dscore=4 tags=perl |>\n<|\
    \ a tags=perl |>\nIf you want a basic calculator you can try this simple code\n\
    <code>\nmy $num1=10;\nmy $num2=20;\nmy $sum=$num1+$num2;\nprint $sum;\n</code>\n\
    You can use this to add and subtract as well.\n<|/ a dscore=3 |>\n<| a tags=perl\
    \ |>\nPerl's core libraries are a ", "    return $x - $y;\n}", "    return $x\
    \ - $y;\n}\n</code>\n<|/ a tags=perl |>\n<| a tags=perl |>\nThe standard way of\
    \ doing it is the one you already know (adding numbers). There may be times when\
    \ you have to do something like adding a number to a string in Perl, for example\
    \ in some code golf. The following example will add 2 to $x and print it.\n<code>\n\
    $x += 2;\nprint $x;\n</code>\n<|/ a dscore=1 |>\n<| a tags=perl |>\nI guess what\
    \ you're looking for is something like the following, which doesn't require a\
    \ separate subroutine:\n<code>\n$x + ($x =~ /\\d/) ? 0 : 1;\n</code>\nThis checks\
    \ $x for a digit (\\d) and if it finds one, it adds 0 to $x instead of 1. This\
    \ way, you only need to declare your variable once. The other answer will work\
    \ fine in that regard too, but this one is more concise and doesn't involve a\
    \ separate subroutine.\n<|/ a dscore=1 |>\n<| a |>\n<code>\n$x = 1;\n$x += 2 if\
    \ $x =~ /\\d/;\nprint $x; # output: 2\n</code>\n<|/ a dscore=1 tags=perl |>\n\
    <| a |>\n<code>\nmy $x = 1;\n$x += 1; \n</code>\n<|/ a tags=perl dscore=0 |>\n\
    <| c |>\nHe has asked how to add and not how to subtract (as your answer implies).\n\
    <|/ c |>\n<| c |>\nAnd why is this wrong? It does what the OP asked for. Unless\
    \ I'm missing something here of course.\n<|/ c |>\n<| c |>\nThe OP wants to add\
    \ and that his code works. He wants to know if his code is optimal (I guess he\
    \ does, but he's just asking if there are better ways to add numbers) so he asked\
    \ how to add and not subtract.\n<|/ c |>\n<| c |>\nBut it doesn't add or subtract\
    \ anything in the code example. Also, there is no addition shown in the question,\
    \ so I guess he didn't realize that he wanted addition.\n<|/ c |>\n<| c |>\nNo,\
    \ it doesn't add anything, it only modifies the variable $x.\n<|/ c |>\n<| a tags=perl\
    \ |>\n<code>\n$x = $x + 2\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat doesn't really\
    \ add anything.\n<|/ c |>\n<| c ", "    return $x + $y;\n}", "    $x + $y;\n}",
  "    my $sum = $x + $y;\n    $sum += $sum - $x * $x;\n    $sum;\n}", "    return\
    \ $x - $y;\n}\n</code>\n<|/ a tags=perl |>\n<| c |>\nNote that this doesn't work\
    \ if $x is a string. `sub` wants an array reference but `@x` would dereference\
    \ a string which would cause the script to die.\n<|/ c |>\n<| c |>\nIt will die\
    \ if the array isn't even bigger. `sub add {\n    my($x, $y) = @_;\n    return\
    \ $x + $y;\n}`\n<|/ c |>\n<| c |>\nOh, yes of course. Perl does strange things\
    \ with array references. I feel silly now :/\n<|/ c |>\n<| a dscore=4 tags=perl\
    \ |>\n<code>\nmy $add = (+) x 2;\n</code>\n<|/ a |>\n<| c |>\nThis works well\
    \ when doing math with strings too.  +1 for perl.\n<|/ c |>\n<| a dscore=4 tags=perl\
    \ |>\nIf you need to do mathematical operations on strings, and you want the result\
    \ to be a string, then you can use sprintf to format the number. \n<code>\nmy\
    \ $add = sprintf \"%.1f\", $x + $y;\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if $x is a string and $y is an integer.\n<|/ c |>\n<| c |>\n`sprintf \"\
    %.0f\" $x + $y`\n<|/ c |>\n<| a dscore=4 |>\nThis works for Perl 5.10+:\n<code>\n\
    my $add = ($x+$y);\n</code>\n<|/ a tags=perl |>\n<| c |>\n`($x + $y)` is slightly\
    \ more efficient, as it doesn't involve a function\n<|/ c |>\n<| c |>\nNote that\
    \ this doesn't work if $x is a string. `sub` wants an array reference but `@x`\
    \ would dereference a string which would cause the script to die.\n<|/ c |>\n\
    <| c |>\nThe same applies to strings with leading zeros e.g. `my $add = ($x .\
    \ '0');`\n<|/ c |>\n<| a dscore=4 tags=perl |>\n<code>\n$add += $x . $y\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\nHere's a quick hack I came up with:\n<code>\nmy $add\
    \ = join(' ',@x,@y);\n</code>\n<|/ a tags=perl |>\n", "    $x -= $y;\n    my $result\
    \ = $x - $y;\n    $x\n}", "    return $x - $y;\n}", "    $x - $y;\n}", "    return\
    \ $x - $y;\n}", "    return $x - $y;\n}", "    $x -= $y;\n}", "    my $s = $x\
    \ - $y;\n    $s .= $s > 0 ? 1 : 0;\n    $s / abs($y);\n}", "    return $x - $y;\n\
    }\n</code>\nI then did a similar process in my Perl script and got the desired\
    \ result.\n<|/ a dscore=4 tags=perl |>\n<| c |>\nYes, this works perfectly. Although,\
    \ I have no idea why the order matters.\n<|/ c |>\n<| c |>\nThe order matters\
    \ because it is a subroutine and sub declarations in Perl are always executed\
    \ in the order they appear in the file.\n<|/ c |>\n<| c |>\n: You mean the order\
    \ in which functions are declared doesn't matter? And how could you declare a\
    \ function before calling it?\n<|/ c |>\n<| c |>\n: Actually, that might be the\
    \ case... Thanks.\n<|/ c |>\n<| c |>\n: At the time Perl compiles your file, all\
    \ functions are declared and defined, then they are executed. This isn't true\
    \ of subroutine calls, because Perl doesn't execute a subroutine until it's explicitly\
    \ called.\n<|/ c |>\n<| a |>\nPerl supports multiple inheritance and you can subclass\
    \ a method as well.\n<|/ a dscore=2 tags=perl |>\n<| a tags=perl |>\nI came across\
    \ this question while trying to understand the difference between the use and\
    \ require statements in Perl.\nThe use statement loads a module/subroutine/method\
    \ into your Perl namespace. It has two main uses:", "    return $x - $y;\n}",
  "    return $x - $y;\n}", "    my $tmp = $x;\n    $tmp -= $y;\n    return $tmp;\n\
    }", "    return $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n\
    }", "    my $r = $x - $y;\n    $r > $x ? $r : $r;\n}", "    return $x - $y;\n}",
  "    return $x - $y;\n}", "    $x * $y - $x + $y;\n}", "    return $x - $y;\n}",
  "    $x -= $y;\n    $x *= -1;\n    return $x;\n}", "    return $x - $y;\n}", " \
    \   my $rv = $x - $y;\n    my $gv = $y - $x;\n    $rv if $rv;\n    $gv if $gv;\n\
    }", "    return $x - $y;\n}", "    $x - $y\n}", "    return $x - $y;\n}", "  \
    \  $x + $y - $x * $y;\n}", "    return $x - $y;\n}", "    $x * $y - $y;\n}", " \
    \   return $x - $y;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}", " \
    \   return $x - $y;\n}", "    $x += $y;\n    $x -= $y;\n    $x *= $y;\n    $x\
    \ /= $y;\n    $x %= $y;\n    $x += $y;\n    $x -= $y;\n    $x *= $y;\n    $x /=\
    \ $y;\n    $x %= $y;\n    $x -= $y;\n    $x *= $y;\n    $x /= $y;\n    $x %= $y;\n\
    \    return $x;\n}", "    $x -= $y;\n    return $x;\n}\n</code>\n<|/ a dscore=5\
    \ tags=perl,oop,syntax,functional-programming |>\n<| c |>\nThanks, this is exactly\
    \ what I was looking for. I was trying to solve it by subroutine call. That's\
    \ why my code wasn't working.\n<|/ c |>\n<| a tags=perl,oop,syntax,functional-programming\
    \ |>\nThe simple answer - using subs and returns:\n<code>", "    return $x - $y;\n\
    }", "    return $x - $y;\n}", "    my $n = $x - $y;\n    $n >= 0 ? $n : $n * -1;\n\
    }", "    return $x - $y;\n}", "    my $sub = $x - $y;\n    croak \" The sub routine\
    \ can not be defined for negative numbers.\\n\" if $sub < 0;\n    return $sub;\n\
    }\n</cell>\n<cell>", "    return $x - $y;\n}", "    $x + $y;\n}", "    return\
    \ $x - $y;\n}", "    return $x - $y;\n}", "    $x -= $y;\n}", "    return $x -\
    \ $y;\n}", "    return $x - $y;\n}", "    $x -= $y;\n    $x *= -1;\n    return\
    \ $x;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}", "    return $x\
    \ - $y;\n}", "    $x -= $y;\n    return $x;\n}", "    return $x - $y;\n}", " \
    \   $x + $y;\n}\n</code>\nThe @-signs tell perl to put all the arguments into\
    \ array-context so that you can iterate over them. They also tell perl to put\
    \ the result back into scalar context, which is the default if you do not do any\
    \ other action. This will make your add function act like it does in other languages,\
    \ like Ruby, Perl, or Ruby.\nThe sub part is called a subroutine or subroutine\
    \ reference. sub adds two numbers together and returns them in scalar context\
    \ (the default if you don't explicitly specify something else with return), so\
    \ I changed the line\n<code>\n$x + $y;\n</code>\nto\n<code>\nreturn $x + $y;\n\
    </code>\nThat is what it does: it returns the value of $x + $y, which happens\
    \ to be the sum of x and y.\nFinally, the return command tells perl to put the\
    \ result back into scalar context, which happens to be the default if you don't\
    \ do any other action.\n<|/ a dscore=5 tags=perl |>\n<| c |>\nI like how you put\
    \ in that last paragraph about how the return command actually tells perl to put\
    \ it back into scalar context.\n<|/ c |>\n<| a |>\nI always think of these commands\
    \ as \"functions\" that operate on an argument list, and return an argument list,\
    \ and they can be written using the sub or function keywords.\n<|/ a dscore=3\
    \ tags=perl |>\n<| c |>\nIn Perl it really is functions, as in \"subroutines\"\
    \ (although some people refer to them as subroutines as well).\n<|/ c |>\n<| a\
    \ tags=perl |>\nPerl has a few different kinds of syntax for subroutines -- they\
    \ are documented in the perlfunc man page.\nHere are some examples of how they\
    \ differ:", "    return $x - $y;\n}", "    return $x - $y;\n}", "    my $rv =\
    \ $x - $y;\n    if ($rv < 0) {\n\t$rv = -$rv;\n\t$rv |= $x >> 31;\n\t$rv |= $y\
    \ >> 31;\n\t$rv |= $x >> 63 | $y >> 63 if ($rv >= 2**62);\n    }\n    return $rv;\n\
    }\n</code>\n<|/ a tags=64-bit,bigint,bignum,perl |>\n<| c |>\nI see you've added\
    \ a comment about avoiding `++$x if ++$y == 0` to the `add` subroutine - would\
    \ you do that in production code? It would seem like a nice way to avoid the possibility\
    \ of overflow when doing `add($x,$y)`, but then you wouldn't be able to *subtract*\
    \ either.\n<|/ c |>\n<| c |>\nI agree that `++$x if ++$y == 0` doesn't look very\
    \ good, but it's not easy to replace with something better. I've added the comment\
    \ to point out that using such tricks leads to undefined behaviour on overflow\
    \ - see [perl operators](http://perldoc.perl.org/perlop.html#Arithmetic-and-bitwise-operations).\
    \ Another way would be to add an extra parameter (`&+`) but then you have to pass\
    \ the second argument to `add`.\n<|/ c |>\n<| a dscore=5 |>\nI wanted to write\
    \ a module to help me with this. While the answers given here are correct, I wanted\
    \ to show how I might go about doing this in a more generic manner. \nSo let's\
    \ say I had a 64-bit integer, which I would want to handle as if it were a bignum.\
    \ The bignum module in CPAN has a number of functions that help you handle bignums.\
    \ For example, you can convert them to integers, add them, etc. \nTo make things\
    \ simple, let's say I want to multiply two 64bit integers together. If I wanted\
    \ to do this in a generic manner, I could do something like this: \n<code>\nmy\
    \ $x = bignum->new('9223372036854775808');\nmy $y = bignum->new('9223372036854775807');",
  "    return $x - $y;\n}", "    $x -= $y;\n    return $x;\n}", "    return $x - $y;\n\
    }", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\nIn other words,\
    \ I used the return keyword here to return the new value, so when I call the function,\
    \ I can assign it to a variable.\nIn Python, this is often done with the assignment\
    \ operator (=):\n<code>\n>>> def add_two(x):\n...     return x + 2\n...\n>>> x\
    \ = add_two(3)\n>>> x\n5\n</code>\nIn Perl, you just use the +:\n<code>", "  \
    \  $x - $y\n}", "    return $x - $y;\n}", "    if ($x > $y) {\n        $x - $y;\n\
    \    } elsif ($x < $y) {\n        $y - $x;\n    } else {\n        $x;\n    }\n\
    }", "    return $x - $y;\n}\n</code>\nAt the very least, you can do that to make\
    \ it clear that the numbers are actually scalars:\n<code>", "    return $x - $y;\n\
    }", "    return $x - $y;\n}\n</code>\nA more complex example might be adding two\
    \ lists together but keeping the original order.\n<code>", "    return $x - $y;\n\
    }", "    my $res = $x - $y;\n    print \"Subtracting $x and $y gives: $res\\n\"\
    ;\n    $res;\n}", "    return $x - $y;\n}", "    return $x - $y;\n}", "    return\
    \ $x - $y;\n}", "    ($x - $y) if ($x && $y);\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=3 tags=perl,perl-module |>\nThe standard module Math::BigInt does\
    \ add and subtraction and has some extra nice features. You might want to look\
    \ at the documentation and try some of its examples.\n<|/ a |>\n<| a |>\n<code>\n\
    use integer;\nuse bignum;\n</code>\n<|/ a dscore=3 tags=perl,perl-module |>\n\
    <| a tags=perl,perl-module |>\nMath::BigInt\n<|/ a dscore=3 |>\n<| a dscore=2\
    \ |>\nThe Math::BigInt::FastCalc module can handle integer arithmetic much faster\
    \ than\nthe Math::BigInt module and provides many other nice features.\n<|/ a\
    \ tags=perl,perl-module |>\n<| a tags=perl,perl-module dscore=2 |>\nMath::BigInt\
    \ has some nice features and is very fast in most cases. If you need more speed,\
    \ you might want to look at Math::BigInt::FastCalc.\n<|/ a |>\n<| a tags=perl,perl-module\
    \ dscore=2 |>\nThe Decimal module is really simple to use and has some nice features.\
    \  It also has a few neat algorithms and other useful things.  \nIt has some nice\
    \ interfaces too. e.g. one way to convert between binary and decimal is by multiplying\
    \ the decimal by a constant and then dividing by it.  The module also has some\
    \ nice methods that take an array and return a decimal number.\n<code>\nuse Decimal\
    \ qw( );\nmy $x = Decimal->new(123);\nprint 123 * $x . \"\\n\";\nprint 123 * $x\
    \ . \"\\n\";", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\nThe\
    \ syntax is a bit tricky though, especially for beginners. Here is an explanation\
    \ of what happens:\nThe sub add { is interpreted as in subroutine add(), and then\
    \ you pass the arguments ($x, $y) to it by placing the parens () around them.\
    \ Perl understands this as sub add($x, $y).\nWithin the subroutine, the function\
    \ add() is assigned to a variable ($sub = add()) and then Perl checks whether\
    \ this variable is referenced (ref($sub)) and that it can be called (call($sub)).\
    \ Because the subroutine add can be called (call($sub)), this code is evaluated.\n\
    The next part of the code is the actual function body. Perl evaluates all the\
    \ code between { and } and binds the result to the variable $sub. You can think\
    \ of it as a function body with parameters being bound to variables.\nThe return\
    \ $x - $y; line is really short for return $x;. \nSince $x is not referenced,\
    \ the return value is assigned to $sub.\nFinally, you call $sub by placing the\
    \ parens () around it. This will execute the subroutine and return the result\
    \ to the caller.\nThe other solution is to use prototypes:\n<code>", "    $x +\
    \ $y\n}", "    return $x - $y;\n}", "    return $x - $y;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThe point is not to solve the problem in Perl, but to understand how\
    \ it works. Also, this is Perl, not Perl 5.\n<|/ c |>\n<| c |>\nThe point is not\
    \ to solve the problem in Perl, but to understand how it works. Also, this is\
    \ Perl, not Perl 5.\n<|/ c |>\n<| a dscore=3 |>\nOne line solution in Perl 5\n\
    <code>", "    $x - $y;\n}", "    return $x - $y;\n}", "    $x - $y;\n}", "   \
    \ my $rv = $x - $y;\n    # $rv is overwritten in the next line!\n    $_[0] = $rv;\n\
    }", "    return $x - $y;\n}", "    my $c = $x - $y;\n    if ($c < 0) {\n     \
    \   return $x + $c;\n    } else {\n        return $y - $c;\n    }\n}", "    return\
    \ $x - $y;\n}", "    my $tmp = $x - $y;\n    $tmp > 0 ? $tmp : $tmp * -1;\n}",
  "    my $z = $x - $y;\n    $z if $z > 0;\n}", "    $x -= $y;\n    $x += $y;\n  \
    \  $x;\n}\n</code>\nThe function sub can do all sorts of complex math operations.\
    \ The function add can do addition and subtraction. You can even mix and match\
    \ them. The function sub can do all sorts of complex math operations. \nSome languages\
    \ use sub as an operator. Python doesn't use sub as an operator, it uses subtract\
    \ as an operator. Perl also doesn't use subtract as an operator, it uses sub as\
    \ an operator. \n<code>", "    return $x - $y;\n}", "    return $x - $y;\n}",
  "    return $x - $y;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=perl,perl-data-structures\
    \ |>\nIn addition to ikegami's answer, I suggest using List::Util::reduce instead\
    \ of List::Util::reduce since it makes more sense to you when you look at it that\
    \ way. The example above would look like this:\n<code>", "    $x + $y;\n}", " \
    \   return $x - $y;\n}", "    return $x - $y;\n}", "    $x -= $y;\n    return\
    \ $x;\n}\n</code>\nTo call it:\n<code>\nmy $res = add(2, 3);\n</code>\n<|/ a tags=perl,perl-module\
    \ |>\n<| a dscore=0 |>\nHere is another simple solution I found on another post.\
    \ \n<code>"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
