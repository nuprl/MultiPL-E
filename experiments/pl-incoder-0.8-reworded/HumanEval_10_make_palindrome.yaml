name: HumanEval_10_make_palindrome
language: pl
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome(\"\")\n# \"\"\n# >>> make_palindrome(\"\
  cat\")\n# \"catac\"\n# >>> make_palindrome(\"cata\")\n# \"catac\"\nsub make_palindrome\
  \ {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_palindrome;\n\
  \        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),\"x\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  xyz\"),\"xyzyx\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"xyx\"),\"xyx\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"jerry\"),\"jerryrrej\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    # Find the longest palindrome of $string.\n    my $longest = $string;\n\
    \    my $max_length = 1;\n    foreach my $char (reverse $string) {\n        last\
    \ unless $char eq $string[$max_length];\n        $max_length++;\n    }\n    #\
    \ Find a palindrome of $max_length + 1 starting with the prefix.\n    my $prefix\
    \ = '';\n    while $string[$longest-1] eq substr($string, -$max_length, $max_length)\
    \ {\n        $prefix .= substr($string, 0, $longest);\n        $max_length++;\n\
    \    }\n    $prefix .= reverse substr($string, 0, $longest);\n    return $prefix;\n\
    }", "    $string =~ s/^([a-zA-Z]*)(.*?)\\1$/$string_reverse($2)/e;\n    return\
    \ $string;\n}", "    $string =~ s/^([a-zA-Z]+)(.*)\\1$//;\n    return $string\
    \ . reverse($1) . $2;\n}\n</cell>\n<text>\nLet's see how this works.", "    my\
    \ @suffix = ();\n    for (my $i = 0; $i < ( length($string) ); $i += 2) {\n  \
    \      push(@suffix, substr($string, $i, 2));\n    }\n    my(@suffix_reverse)\
    \ = reverse(@suffix);\n    my($palindrome_string) = \"\";\n    for (my $i = 0;\
    \ $i < ( length($string) ); $i += 2) {\n        my($suffix_reverse) = $suffix_reverse\
    \ . substr($string, $i, 2);\n        $palindrome_string .= $suffix_reverse if\
    \ is_palindrome($suffix_reverse);\n    }\n    return $palindrome_string;\n}",
  "    my $reversed_string;\n    my $palindrome_suffix;", '    my($palindrome,$reversed_palindrome);',
  '    return $string if $string eq "";', "    my($length);\n    my($palindrome);\n\
    \    my($reverse_string);\n    my($suffix_length);\n    my($suffix_offset);\n\
    \    my(@suffix_string);", "    my($longest_palindrome);\n    my($prefix_of_longest_palindrome);\n\
    \    my($suffix_of_longest_palindrome);\n    my($palindromic_suffix);\n    my($prefix_of_palindromic_suffix);\n\
    \    my($suffix_of_palindromic_suffix);\n    my($reversed_prefix_of_palindromic_suffix);\n\
    \    my($reversed_suffix_of_palindromic_suffix);", "    my @palindrome;\n    my\
    \ $length = 0;\n    my $longest_palindrome = \"\";\n    while ($string ne \"\"\
    ) {\n        $longest_palindrome .= $string;\n        my $last_index = $string\
    \ ne \"-\" ? $string->length() : length($string) - 1;\n        for (my $i = 0;\
    \ $i < $last_index; $i++) {\n            my $char = $string->[$i];\n         \
    \   my $reversed_char = $string->[$i];\n            my $new_char = $char . $reversed_char;\n\
    \            $string =~ s/$char/$new_char/g;\n        }\n        $length = length($string);\n\
    \        if ($length < $longest_palindrome->length()) {\n            push(@palindrome,\
    \ $string);\n        }\n        $string =~ s/-$//;\n    }\n    return $longest_palindrome;\n\
    }", "    $string =~ s/^.*//;\n    $string .= reverse $string;\n    return $string;\n\
    }\n</code>\n<|/ a tags=algorithm,python |>\n<| c |>\nYes. This is correct. My\
    \ first approach was to find longest palindrome in reverse by looping through\
    \ each character. But that turned out to be too slow for my needs. Your algorithm\
    \ is much faster. Thank you.\n<|/ c |>\n<| c |>\nWhat do you mean too slow? This\
    \ code is O(n) and the longest palindrome check is O(1), so it should be reasonably\
    \ fast.\n<|/ c |>\n<| c |>\nI ran your method and my method using your algorithm\
    \ for the palindrome \"racecar\" and I got different times. Your method took 4707\
    \ milliseconds and the palindrome method took 3684 milliseconds. How is that possible?\n\
    <|/ c |>\n<| c |>\nI ran a test to find what was actually happening. I noticed\
    \ that your algorithm was being called a lot. I ran your algorithm on \"racecar\"\
    \ several times. In each call the method was being called a lot. So I realized\
    \ that your algorithm was being called more and more often. Since your algorithm\
    \ is faster, I decided to stick with it. Your algorithm is faster.\n<|/ c |>\n\
    <| a |>\nA palindrome is a string that, when read from its middle, appears the\
    \ same forwards and backwards.\nA palindrome is a substring of some string that\
    \ reads the same forwards and backwards.\nA palindrome is usually defined as \"\
    is a substring of a string that reads the same forwards and backwards\" (but that's\
    \ not strictly true -- a palindrome can have one more character or one less character\
    \ -- so the definition is more general, though often not very useful).\nSo you\
    \ have a function that determines if a substring is a palindrome -- you already\
    \ have that in make_palindrome. Now you just need to find out which string is\
    \ a palindrome (by calling make_palindrome on it). To do that, just use slicing\
    \ to chop off the last character and compare to the original string, and return\
    \ the shorter one.\n<|/ a tags=algorithm,python dscore=0 |>\n<| a tags=algorithm,python\
    \ |>\nI think this approach is very easy to understand and easy and fast.\n<code>\n\
    def isPalindrome(s):\n    if len(s) < 1:\n        return True\n    if s == s[::-1]:\n\
    \        return True\n    else:", '    my($palindrome);', "    my $palindrome\
    \ = reverse $string;\n    if ( $string =~ /^$palindrome$/ ) {\n        $palindrome\
    \ .= \"$string\";\n    }\n    $palindrome;\n}", "    return $string if $string\
    \ eq ''; # empty string", "    my(@ls, @rs);\n    my(@lc, @rc);", '    my(@return)
    = ($string);', "    my($postfix_length, $palindrome_length) = @$string;\n    my($reverse_string,\
    \ $reverse_postfix);\n    my($reversed_postfix, $reversed_palindrome);\n    my($reversed_postfix_length,\
    \ $reversed_palindrome_length);", '    return $string if $string =~ /^\W*$/;',
  "    my($longest) = length($string);\n    my($start);\n    my($suffix_start);\n\
    \    my($suffix_end);", "    my $prefix_length = 0;\n    my $palindrome_prefix;\n\
    \    my $palindrome_suffix;\n    my $length = 0;\n    my $reverse = \"\";\n  \
    \  while ($length > 0) {\n        $palindrome_prefix = substr($string, $prefix_length,\
    \ $length) if $length < length;\n        $palindrome_suffix = substr($string,\
    \ $prefix_length + $length, $length) if $length > length;\n        $reverse =\
    \ reverse $palindrome_prefix;\n        $string .= $reverse;\n        $length -=\
    \ length($reverse) - length($palindrome_suffix);\n        $prefix_length += length($reverse)\
    \ - 1;\n    }\n    return $string;\n}", "    $string .= make_palindrome($string,\
    \ scalar(@{$string}-1));\n    return $string;\n}", "    my $lstring = $string\
    \ =~ s/^$string$/$string^/r;\n    my $result = $lstring . $string;\n    my $len\
    \ = length($result);\n    my $i = 0;\n    for (my $j = $len - 1; $j >= 0; $j--)\
    \ {\n        my $char = $result[$j];\n        $result[$j] = $char if ($char eq\
    \ $string[$j]);\n        $i--;\n        if ($i == 0) {\n            $result[$j+1]\
    \ = $string;\n            $len -= $j + 1;\n        }\n    }\n    return $result;\n\
    }", "    my($length) = length($string);\n    my($palindrome);\n    my($suffix_length);",
  "    return '' if !defined($string);\n    $string =~ s/^$string//;\n    return ''\
    \ unless $string =~ /^\\Q$string\\E$/;\n    my $longest = length($string);\n \
    \   my $palindrome = $string;\n    for (my $i = length($string)-1;; $i--) {\n\
    \        my $start = substr($palindrome,0,$i);\n        my $end = substr($palindrome,0,$longest-$i);\n\
    \        $palindrome .= reverse $start . $end;\n        $palindrome =~ s/\\Q$start\\\
    E//;\n        last if $start eq $palindrome;\n    }\n    $palindrome =~ s/\\Q$string\\\
    E//;\n    return $palindrome;\n}", "    $string .= \"0\"xlength($string) if $string\
    \ =~ /\\d/;\n    my($longest, $prefix, $postfix, $reverse, $palindrome, $palindromic_suffix);",
  "    $string = \"\" if !defined($string);\n    $string = \"\" if $string eq \"\"\
    ;", "    # Don't do anything if there is no string to begin with\n    return $string\
    \ if !defined($string);", '    my(@result) = (0, "", "");', "    my $max_length\
    \ = 0;\n    my $max_length_suffix = 0;\n    my $max_length_prefix = 0;\n    my\
    \ @possible_suffixes = ();\n    my @possible_prefixes = ();\n    while ($string\
    \ =~ /(.)(.+)/) {\n        push @possible_suffixes, $1;\n        push @possible_prefixes,\
    \ $2;\n    }\n    my $longest_suffix = $possible_suffixes[0];\n    my $longest_prefix\
    \ = $possible_prefixes[0];\n    $longest_suffix = length($longest_suffix) > length($longest_prefix)\
    \ ? $longest_suffix : $longest_prefix;\n    my $longest_possible_palindrome =\
    \ \"\";\n    my $longest_possible_suffixe = \"\";\n    my $longest_possible_prefix\
    \ = \"\";\n    foreach my $suffix (@possible_suffixes) {\n        my $string_to_append\
    \ = \"$longest_suffix$suffix\";\n        my $palindrome = $string;\n        my\
    \ $reversed_suffix = reverse($suffix);\n        $palindrome .= $reversed_suffix;\n\
    \        if (\"$palindrome\" eq make_palindrome($palindrome)) {\n            $longest_possible_suffix\
    \ = $suffix;\n        }\n    }\n    foreach my $prefix (@possible_prefixes) {\n\
    \        my $string_to_append = \"$longest_prefix$prefix\";\n        my $palindrome\
    \ = $string;\n        $palindrome .= reverse($prefix);\n        if (\"$palindrome\"\
    \ eq make_palindrome($palindrome)) {\n            $longest_possible_prefix = $prefix;\n\
    \        }\n    }\n    my $palindrome = $string;\n    $palindrome .= \"$longest_possible_suffix\"\
    ;\n    $palindrome .= reverse($longest_possible_prefix);\n    return $palindrome;\n\
    }", "    return $string if $string eq \"\";\n    my($postfix, $reverse, @postfix,\
    \ @reverse, @prefix);\n    if ($string =~ /^(\\S*)/) {\n        my $shortest =\
    \ length $1;\n        $prefix ||= \"\"; $reverse ||= \"\"; @postfix ||= ();\n\
    \        @prefix = grep {length($_) == $shortest} split /(?=[a-zA-Z])/, $1;\n\
    \        for (@prefix) {\n            push (@postfix, $_ . \"_\" . $reverse);\n\
    \            push (@reverse, uc substr($_, 0, length($_) - 1) . $reverse);\n \
    \       }\n    }\n    return $string unless @prefix && @postfix;\n    my $shortest\
    \ = 0;\n    my $longest = 0;\n    for (@prefix) {\n        for (@postfix) {\n\
    \            my $longer = length($_);\n            my $smaller = length($_);\n\
    \            my $palindrome = $_ . \"_\" . $reverse[$shortest];\n            if\
    \ ($longer > $shortest && length($palindrome) == $shortest && $palindrome eq $_)\
    \ {\n                $longest = $shortest; $shortest = length($_);\n         \
    \   }\n            if ($smaller > $longest) {\n                $longest = $smaller;\n\
    \            }\n        }\n    }\n    return $reverse[$shortest] . \"_\" . $postfix[0];\n\
    }", '    return "" if length($string) == 0 or $string eq lc $string;', "    return\
    \ $string if $string eq ''; # No empty strings\n    return $string if length($string)\
    \ < 2; # Strings shorter than 2 characters are never palindromes.", "    my $longest\
    \ = $string =~ /^(.).*\\1(.*)$/;\n    $string .= \"^\".reverse($longest).\"$\"\
    ;\n    return $string;\n}", "    return \"\" unless defined $string;\n    my @part;\n\
    \    my $palindromic = \"\";\n    my $max_length = 0;\n    for (split //, $string)\
    \ {\n        $max_length = length if length < length || length == 0;\n       \
    \ push @part, $_;\n        my $length = 0;\n        for (split //) {\n       \
    \     $length++;\n            last if $length == $max_length;\n        }\n   \
    \     my $new_length = $length - 1;\n        my $new_sub = substr($string, 0,\
    \ $new_length);\n        my $reversed_sub = substr($string, $new_length) =~ tr/a-z/A-Z/;\n\
    \        $palindromic = $new_sub . $reversed_sub if $new_length <= $max_length;\n\
    \    }\n    return $palindromic;\n}", "    \n    my($prefix_reversed) = '';\n\
    \    my($prefix_longest) = '';\n    my($suffix_reversed) = '';\n    my($suffix_longest)\
    \ = '';\n    \n    # Find the longest postfix of supplied string that is a palindrome.\n\
    \    while ($string =~ m/(.)\\1/) {\n        $prefix_reversed = reverse $prefix_reversed.$1;\n\
    \        $prefix_longest = $1; \n    }\n    \n    # Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    while\
    \ ($string =~ m/(.).$prefix_longest/) {\n        $suffix_reversed = reverse $suffix_reversed.$1;\n\
    \        $suffix_longest = $1; \n    }\n    \n    # Return string prepended by\
    \ prefix and suffix reversed.\n    return $prefix_reversed.$suffix_reversed;\n\
    }", "    \n    my(@postfix_list);\n    # Find the longest postfix string that\
    \ is a palindrome\n    while($string =~ /([A-Za-z0-9]+)($|\\z)/) {\n        push(@postfix_list,\
    \ $1);\n    }\n    \n    my($longest_postfix_list) = grep($postfix_list[scalar(@postfix_list)\
    \ - 1] =~ /[a-z]$/, @postfix_list);\n    \n    # Construct the reverse of the\
    \ string prefix\n    my $reverse_string = $string . reverse($postfix_list[$longest_postfix_list]);\n\
    \    \n    # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix\n    $string .= \"$reverse_string\";\n    \n \
    \   return $string;\n}\n</code>\nThis works but is not very elegant as we have\
    \ to maintain two lists to find the longest postfix string and reverse the prefix.\
    \ Also, the grep is O(n). An alternative is to use a hash to avoid the grep.\n\
    <code>\nuse List::Util qw( max );\nuse v5.10.0;", "    return $string if length($string)\
    \ == 0;\n    my($longest_postfix_string) = longest($string);\n    my($reversed_longest_postfix_string);\n\
    \    my($prefix);\n    if (length($longest_postfix_string) > 0) {\n        $reversed_longest_postfix_string\
    \ = reverse $longest_postfix_string;\n        $prefix = $string . $reversed_longest_postfix_string;\n\
    \    }\n    else {\n        return $string;\n    }\n    return $prefix . $string;\n\
    }", "    my(@suffix) = reverse $string =~ /(.)(.*)/g;\n    return $string . reverse\
    \ substr($string, 0, pos($string)-@suffix[0]-@suffix[-1]);\n}\n</code>\nOutput:\n\
    <code>", "    my $length = $string->length;\n    $string .= reverse($string) if\
    \ $length > 1;\n    return $string;\n}", "    my($longest);\n    my($palindrome);",
  '    my($prefix, $suffix, $reverse);', "    $string .= reverse $string if $string\
    \ =~ /^(\\Q$string\\E)\\Q$string\\E$/;\n    return $string;\n}", '    my($palindrome,
    $reversed_string);', "    my($palindrome);\n    my($length);", "    return $string\
    \ unless $string =~ m{^([a-z])+([a-z]+?)$};\n    my($longest_postfix_to_be_a_palindrome);\n\
    \    my(@longest_postfix_to_be_a_palindrome);\n    my($longest_postfix_to_be_a_palindrome_idx);\n\
    \    my($longest_postfix_to_be_a_palindrome_reverse);\n    my($longest_postfix_to_be_a_palindrome_start_idx);\n\
    \    my($longest_postfix_to_be_a_palindrome_end_idx);\n    my($longest_postfix_to_be_a_palindrome_string);\n\
    \    my($longest_postfix_to_be_a_palindrome_reverse_string);\n    my($longest_postfix_to_be_a_palindrome_suffix_length\
    \ = 0);\n    my($longest_postfix_to_be_a_palindrome_suffix_idx);", "    my(@results);\n\
    \    $string =~ m!([^$string]*)!;\n    my $length = $#matches + 1;\n    my $reverse\
    \ = $string;\n    $reverse = reverse $reverse;\n    $string .= $reverse;", " \
    \   # Make sure we're not dealing with an empty string.\n    return \"\" unless\
    \ length $string;\n    my $len = length($string);\n    my $reverse = $string;\n\
    \    $reverse = reverse $reverse if $string =~ /^(.)\\1$/;\n    # Make sure the\
    \ reverse string is longer.\n    return \"\" unless length $reverse;\n    # If\
    \ the reverse string is the same length, we're done.\n    return $reverse if $len\
    \ == length($reverse);\n    # Otherwise we're going to have to make a new palindrome.\n\
    \    my $palindrome = \"\";\n    my $prefix = \"\";\n    my $suffix = 0;\n   \
    \ while ($suffix < $len) {\n        my $last_letter = $reverse[$suffix];\n   \
    \     $prefix .= $last_letter;\n        my $new = $string =~ /($prefix)([^$prefix]+)/;\n\
    \        if ($new and $new eq $prefix . $last) {\n            $palindrome .= $prefix\
    \ . $last;\n            $suffix += length($prefix . $last);\n        } else {\n\
    \            $suffix = $len + 1 if ++$suffix;\n        }\n    }\n    return $palindrome;\n\
    }", "    my $length = length($string);\n    my $max_length = 0;\n    my $max_suffix;\n\
    \    my $suffix;\n    my $prefix_reversed;\n    my $palindrome_max_length = 0;\n\
    \    my $palindrome;", "    \n    if (length($string) == 0) {\n        return\
    \ $string;\n    }\n    \n    my($palindromic_suffix) = reverse $string;\n    \n\
    \    if (length($palindromic_suffix) > 0) {\n        my $postfix_with_suffix_reversed\
    \ = reverse $palindromic_suffix . $string;\n        \n        return $postfix_with_suffix_reversed;\n\
    \    }\n    \n    return $string;\n}", "    $string =~ s/([a-z])/$1_/g;  # convert\
    \ all letters to lower case\n    $string =~ s/^([a-z])/${reverse($1)}_/;  # replace\
    \ prefix with suffix\n    $string =~ s/_([a-z])/$1/;  # replace suffix with prefix\n\
    \    return $string;\n}", "    my($suffix) = $string =~ /(.)\\1*$/;\n    $string\
    \ .= reverse $suffix;\n    return $string;\n}", "    my($suffix) = substr($string,\
    \ length($string) - 1, 1);\n    my($prefix) = substr($string, 0, length($string)\
    \ - 1);", "    return $string if $string eq \"\";\n    $string =~ s/^\\s+//;\n\
    \    $string =~ s/\\s+$//;", "    # Start with an empty string\n    my($palindrome);",
  "    my($reverse_string = $string);\n    my($max_postfix = length($string));\n \
    \   my($longest_postfix = $max_postfix);\n    my($palindromic_suffix_start);\n\
    \    my($palindromic_suffix_end);", "    $string =~ s/^(.)/$1 reversed/;\n   \
    \ $string =~ s/^(.)$/\\1/;\n    return $string;\n}", "    my(@rslt) = (\"\");\n\
    \    my($suffix) = $string =~ /([^$string]*)$string/;\n    if ($suffix eq $string)\
    \ {\n        return $string;\n    }\n    while (1) {\n        push (@rslt, $string);\n\
    \        $suffix  = reverse ($suffix);\n        $string  = $suffix =~ /([^$string]*)$string/;\n\
    \        unless ($string eq $suffix) {\n            return join(\"\", @rslt);\n\
    \        }\n    }\n}", "    return $string if $string eq '';", "    my $reverse;\n\
    \    my $longest_postfix = length $string;\n    $reverse = $string if length($string)\
    \ <= $longest_postfix;\n    $longest_postfix -= 1;\n    $reverse .= substr($string,\
    \ -$longest_postfix);\n    $reverse .= substr($string, 0, $longest_postfix);\n\
    \    return $reverse;\n}", '    return $string if $string =~ /^.$/;', "    my\
    \ $longest;\n    $longest = length($string);\n    my $suffix;\n    my $longestPal;\n\
    \    for (my $i = $longest; $i > 1; $i -= 1) {\n        $suffix = substr($string,\
    \ $i-1);\n        $longestPal = substr($string, 0, $i-1) . $suffix;\n        if\
    \ ($longestPal eq $string) {\n            return $longestPal;\n        }\n   \
    \ }\n}", '    my($palindrome_suffix);', "    my($reverse_string);\n    my($max_postfix,\
    \ $length_of_prefix, $result);", "    $string .= make_palindrome(substr $string,\
    \ 0, -1);\n    $string .= reverse substr($string, 1);\n    $string;\n}", "   \
    \ my(@chars) = split(//, $string);\n    my($longest, @palindromes);\n    foreach\
    \ $char (@chars) {\n        my $rt = reverse($char);\n        my $palindrome =\
    \ $char . $rt;\n        if (length($palindrome) > length($longest)) {\n      \
    \      $longest = $palindrome;\n        }\n    }\n    push(@palindromes, $longest);\n\
    \    join(\"\", @palindromes);\n}\n</code>\n<|/ a tags=perl,palindrome,algorithm\
    \ dscore=0 |>\n<| a tags=perl,palindrome,algorithm |>\n<code>", "    chomp($string);\n\
    \    if ($string =~ /^.*([.]\\p{Alnum}+?)(\\p{Alnum}+?)(.)*$/) {\n        return\
    \ $string; # already a palindrome.\n    }\n    $string .= reverse($string =~ /^(.)\\\
    p{Alnum}+?/);\n    return $string;\n}", '    return $string if $string =~ /^[A-z]+$/;',
  "    return \"\" if $string eq \"\";\n    $string =~ tr/a-zA-Z//cd;\n    $string\
    \ = \"\" if $string eq \"\";\n    $longest = 0;\n    $length = $string.length;\n\
    \    for($i = 1; $i <= $length; $i++) {\n        # print \"$i $string[$i] $string[$i-1]\\\
    n\";\n        $left = $string[$i];\n        $right = $string[$i-1];\n        $left_count\
    \ = 1;\n        $right_count = 1;\n        for(; ($i == $length) || ($string[$i-1]\
    \ != $string[$i]); $i--) {\n            $left_count++;\n            $left_count++\
    \ if $string[$i] == $left;\n            $right_count++;\n            $right_count++\
    \ if $string[$i] == $right;\n        }\n        if ($left_count > $longest) {\n\
    \            $longest = $left_count;\n        }\n        if ($right_count > $longest)\
    \ {\n            $longest = $right_count;\n        }\n    }\n    my $palind =\
    \ $string[$longest];\n    $palind = $palind.reverse;\n    $string = $string.\"\
    $palind \";\n    $string =~ tr/a-zA-Z//cd;\n    return $string;\n}\n</code>\n\
    <|/ a tags=perl,algorithm,optimization,palindrome |>\n<| c |>\nthank you very\
    \ much for the answer! I do understand your code and what you are trying to do,\
    \ but there are some things I don't get at all.  What is \"catac\"?  How do you\
    \ know it's \"cata\"?\n<|/ c |>\n<| c |>\nOh cata would be a palindrome too. \
    \ It would just be one character long.  \"cata\" could be made from any number\
    \ of characters, so \"cat\" and cata are both valid answers.  But \"cata\" is\
    \ the correct answer (the one that ends with the longest).\n<|/ c |>\n<| c |>\n\
    catac is catacata because we count right to left, but left to right.\n<|/ c |>\n\
    <| c |>\nOh I see - you're counting all the letters, and then choosing the longest\
    \ one right.  I'm still trying to wrap my head around how that works.\n<|/ c |>\n\
    <| c |>\nYes, it does count, it counts the number of times a character appears\
    \ in the string.  It's a little complicated, but the end result is that the longest\
    \ palindrome that ends with a letter that appears more than once is the one that\
    \ ends before the next letter in the string.  ", "    my($string_palindrome);\n\
    \    my($longest_palindrome);\n    my($longest_palindrome_index);\n    my($longest_palindrome_length);",
  "    my($longest, $longestStart, $longestEnd);\n    \n    $string =~ s/^\\s+//;\
    \  # Trim leading whitespace.\n    \n    # Find longest palindrome suffix that\
    \ starts with a supplied string.\n    while ($string =~ s/(^| )(.)\\2(?!.*\\2)(.)/$1$3$2$4/sg)\
    \ {\n        # Found a palindrome. Check length.\n        $longest = $1;\n   \
    \     $longestStart = length($1) - length($2) + 1;\n        $longestEnd = length($2)\
    \ - length($1) + 1;\n    }\n    \n    return $string.substr($longestStart, length($string)\
    \ - $longestEnd);\n}", "    my $reversed_string = \"\";\n    my $prefix = '';\n\
    \    my $suffix = '';\n    my $longest = 0;\n    while (1) {\n        $longest\
    \ = $prefix . ($longest < length $string ? substr($string, $longest) : $string);\n\
    \        $reversed_string .= substr($prefix, 0, $longest) . $suffix . reverse($prefix);\n\
    \        $string = substr($string, 0, -$longest);\n        if (substr($string,\
    \ -1) == $string) {\n            $suffix = \"'$string'\";\n            last;\n\
    \        }\n    }\n    return $reversed_string;\n}", "    # Find largest palindrome\
    \ suffix that is also a palindrome.\n    my $suffix_len = length($string) - 1;\n\
    \    $suffix_len = $suffix_len if length($string) > 1;\n    my $suffix = substr($string,\
    \ $suffix_len);\n    my $suffix_rev = reverse($suffix);\n    my $palindrome =\
    \ $string.$suffix_rev;\n    return $palindrome;\n}", "    my $longest = length($string);\n\
    \    my $palindrome = \"\";\n    for (my $i = 0; $i < $longest; $i++) {\n    \
    \    my $index = index($string, substr($string, $i, 1));\n        $palindrome\
    \ .= substr($string, $i, 1) . substr($string, $index, -1);\n    }\n    return\
    \ $palindrome;\n}", "    my($postfix, $palindrome);\n    my $longest = 0;\n  \
    \  my $longestPrefix;", "    # Step 1: Find the longest postfix of supplied string\
    \ that is a palindrome.\n    my(@suffix_lengths) = ();\n    for my $suffix (@$string)\
    \ {\n        push @suffix_lengths, length($suffix)\n            if $suffix =~\
    \ m/^(.+)\\Q$string\\E\\Q.*\\Q\\E\\Q$suffix\\E$/;\n    }\n    my($max_length)\
    \ = reverse @suffix_lengths;\n    # Step 2: Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    my $suffix\
    \ = ($string eq \"-\")\n               ? (\"-\" x $max_length)\n             \
    \  : $string =~ m/^(.{0,$max_length})\\Q$string\\E$/;\n    return \"$string$suffix\"\
    ;\n}\n</code>\n<|/ a tags=perl dscore=0 |>\n<| c |>\nThis does not give the correct\
    \ answer when the string ends with dashes (-). Please fix it.\n<|/ c |>\n<| c\
    \ |>\nFixed, thanks. But I see no reason for such limitations in OP's task.\n\
    <|/ c |>\n<| c |>\nOP's task is to find the shortest palindrome in a string, not\
    \ find the longest one.\n<|/ c |>\n<| c |>\nOk, fixed, thanks for noticing that.\n\
    <|/ c |>\n<| a |>\nIf all your input strings are one character long, you can use\
    \ a hash to map each string to a single value. The value is itself the string\
    \ that starts with the original string and ends with the same string:\n<code>",
  "    return '' unless $string;", "    my($palindrome);\n    my($length = $string);\n\
    \    my($reversed_string);\n    my($first_character_index);\n    my($last_character_index);\n\
    \    my($index_of_first_character);\n    my($index_of_last_character);\n    my($character);",
  "    my($max_length);\n    my($string_to_reverse);\n    my($palindromic_suffix);\n\
    \    my($reverse_prefix);\n    my($reversed_string);\n    my($reversed_suffix);\n\
    \    $string_to_reverse = $string;\n    $string_to_reverse =~ s/^$string_to_reverse//;\n\
    \    $reverse_prefix = substr($string_to_reverse, 0, -1);\n    $reversed_suffix\
    \ = substr($string_to_reverse, -1);\n    $reversed_string = $reverse_prefix .\
    \ reverse $reversed_suffix;\n    # print \"$string_to_reverse: $reverse_prefix\
    \ $reversed_suffix $reversed_string $string \\n\";\n    # print \"Reversed $reverse_prefix\
    \ $reversed_suffix $reversed_string $string \\n\";\n    while($reversed_string\
    \ =~ /([a-z])/i) {\n        $max_length = $1 + $max_length;\n        $reversed_suffix\
    \ = substr($reversed_string, 1);\n        $reversed_string = $reverse_prefix .\
    \ $reversed_suffix;\n    }\n    # print \"Reversed $reverse_prefix $reversed_suffix\
    \ $reversed_string $string \\n\";\n    $palindromic_suffix = $reversed_suffix\
    \ . reverse($reversed_string);\n    $palindromic_suffix = \"a\" . $palindromic_suffix\
    \ . \"a\";\n    return \"$string$palindromic_suffix\";\n}", "    my $max_len =\
    \ length($string);\n    my $max_idx = 0;\n    my @postfix = split(//, $string);",
  "    $string =~ s/(^|[\\s\\n])//;\n    my($reverse, @suffixes) = map { $string =~\
    \ s/([a-z])/lc($1)./ge; $_ } qw/ a b c d e f g h i j k l m n o p q r s t u v w\
    \ x y z /;\n    my($palindrome);\n    # Try all possible combinations of suffix\
    \ to see if we can find the palindrome\n    foreach my $suffix (@suffixes) {\n\
    \        my($suffixed_string = $string.$suffix);\n        my($suffix_length =\
    \ length($suffix));\n        $palindrome = \"\";\n        # Try all possible combinations\
    \ of prefix to see if we can find the palindrome\n        foreach my $prefix (reverse\
    \ @suffixes) {\n            my $prefix_length = length($prefix);\n           \
    \ if ($prefix_length < $suffix_length) { last; }\n            my $prefixed_string\
    \ = $string.$prefix;\n            my $prefixed_length = length($prefixed_string);\n\
    \            if ($prefixed_length >= $suffix_length) {\n                my($reversed_string\
    \ = $prefix.substr($reverse, $suffix_length));\n                my($palindrome_length\
    \ = $reversed_string eq $string ? $suffix_length : $prefixed_length - ($suffix_length\
    \ - $reversed_string));\n                if ($palindrome_length > 0) { $palindrome\
    \ = $reversed_string; }\n            }\n        }\n        if (length($palindrome)\
    \ > 0) { $palindrome .= $suffix; }\n        if (length($palindrome) > 0) { return\
    \ $palindrome; }\n    }\n    return $string;\n}", '    my($postfix, $reverse,
    $palindrome);', "    $string =~ s/^\\s+//;\n    $string =~ s/\\s+$//;\n    my\
    \ $longest = length($string);\n    my $longest_palindrome = substr($string, 0,\
    \ $longest);\n    my $middle = length($string) / 2;\n    my $middle_palindrome\
    \ = substr($string, $longest, $middle);\n    my $rev_middle = reverse($middle_palindrome);\n\
    \    $middle_palindrome .= $rev_middle;\n    $string .= $middle_palindrome;\n\
    \    return $string;\n}", "    my($longest);\n    my($reverse);\n    my($results);\n\
    \    my($first);\n    my($last);\n    my($longestLength);\n    my($longestStart);\n\
    \    my($longestEnd);", '    return $string if length($string) <= 1;', "    my($suffix)\
    \ = \"\";\n    my($reverse) = \"\";\n    my($max_length) = 0;\n    my($result)\
    \ = \"\";", "    return \"$string\" if $string eq '';", "    # Find longest possible\
    \ post fix palindromic suffix of $string\n    # and append reverse of that suffix\n\
    \    my $length = scalar reverse $string;\n    my $suffix = substr($string, 0,\
    \ $length);\n    return $suffix . reverse($suffix);\n}", '    my($postfix, @suffix_list);',
  '    return unless defined $string;', "    if (length($string) < 2) {\n        return\
    \ $string;\n    }\n    my $suffix = reverse $string;\n    my $postfix = substr($string,\
    \ 0, -1);\n    if ($suffix eq substr($postfix, 0, -1)) {\n        return $string\
    \ . $suffix;\n    }\n    my $prefix = substr($string, 0, 0);\n    if ($suffix\
    \ eq substr($prefix, 0, -1)) {\n        return $string . $suffix;\n    }\n   \
    \ my @suffixes = split //, $string;\n    my $suffix_postfix = join \"\", @suffixes;\n\
    \    my $postfix_postfix = join \"\", @suffixes;\n    my $longest_postfix = \"\
    \";\n    my $prefix_postfix = \"\";\n    foreach my $s (@suffixes) {\n       \
    \ my $p = make_palindrome($s);\n        if ($p eq $suffix_postfix) {\n       \
    \     $longest_postfix = $s;\n        }\n        if ($p eq $postfix_postfix) {\n\
    \            $prefix_postfix = $s;\n        }\n    }\n    if ($longest_postfix\
    \ eq $postfix_postfix) {\n        return \"$prefix_postfix $longest_postfix\"\
    ;\n    }\n    if ($longest_postfix eq $prefix_postfix) {\n        return \"$longest_postfix\
    \ $suffix_postfix\";\n    }\n    return $string;\n}", "    my($suffix) = $string\
    \ =~ s/^([^$string]*).*/$1/;\n    return $string .\n        \"${reverse($suffix)}\"\
    ;\n}", "    my $longest = 0;\n    my $palindrome = \"\";\n    my $reversed = \"\
    \";\n    my $i = 0;\n    my $j = $#string;\n    while($i <= $j) {\n        $reversed.=substr($string,\
    \ $i, 1);\n        $reversed.=reverse substr($string, $j);\n        if($reversed\
    \ == $string) {\n            $longest = $i;\n            $palindrome=$string;\n\
    \            last;\n        }\n        $i++;\n        $j--;\n    }\n    return\
    \ $palindrome;\n}", "    $string .= substr($string, -1);\n    return $string if\
    \ $string =~ /\\P/ || length($string) == 0;\n    my($prefix, $suffix);\n    ($prefix,\
    \ $suffix) = ($string, substr($string, 0, length($string) - 1));\n    return $prefix\
    \ if $prefix =~ /\\P/ || $prefix =~ /^\\W*$/;\n    return $prefix . $suffix if\
    \ $suffix =~ /\\P/ || $suffix =~ /^\\W*$/;\n    my $longest = 0;\n    my $longestPrefix;\n\
    \    my $longestSuffix;\n    my $longestSuffixReversed;\n    for (my $i = length($string);\
    \ $i > 0; $i--) {\n        ($prefix, $suffix) = ($string, substr($string, 0, $i));\n\
    \        ($longest, $longestPrefix, $longestSuffix) = (length($prefix), length($prefix),\
    \ length($suffix));\n        ($longest, $longestPrefix) = (length($prefix) if\
    \ ($longestPrefix < $longest));\n        ($longest, $longestSuffix) = (length($suffix)\
    \ if ($longestSuffix < $longest));\n        ($longest, $longestSuffixReversed)\
    \ = (length($suffix) if ($suffix =~ /(?<!\\W)[\\W](?!\\W)/));\n        $longest\
    \ = $longestPrefix if $longestPrefix < $longestSuffix;\n    }\n    my $stringPalindrome\
    \ = $string;\n    $stringPalindrome .= substr($string, $longest - length($string)\
    \ - 1, 1) if ($longest > 1);\n    $stringPalindrome = reverse $stringPalindrome\
    \ if ($longest > 1);\n    return $stringPalindrome;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI'm voting this up for its effort, but the code doesn't work if you call\
    \ it with a string like `make_palindrome(\"abc\")`.\n<|/ c |>\n<| c |>\nGood catch!\
    \ I've modified it to use reverse on longest suffix, which is more efficient and\
    \ should always produce a palindrome.\n<|/ c |>\n<| c |>\nThanks for your answers.\
    \ But I am afraid my code is not working. It returns an empty string. I tested\
    \ your function with all the example given in my question. It returns an empty\
    \ string for all of them. As I see from the code, you are testing only the first\
    \ letter. Thats why I posted my question. I am not able to modify your code to\
    \ test all cases and get the right answer.\n<|/ c |>\n<|", "    my($longest_palindromic_suffix)\
    \ = \"\";\n    my($longest_palindromic_suffix_pos) = -1;", '    my($string2, $reverse,
    $suffix);', "    my(@result) = (0, \"\", 0, \"\");\n    my($suffix) = 0;\n   \
    \ my $length = 0;", '    my($longest);', '    my(@post_postfix) = reverse($string);',
  "    my $reverse;\n    if($string =~ /(?<=\\w)(\\w+)(?=\\w)/){\n        $reverse\
    \ = $1 . $2 . $1;\n    } else {\n        $reverse = $string;\n    }\n    $reverse\
    \ .= reverse($reverse);\n    return $string;\n}\n</code>\n<|/ a tags=algorithm,perl\
    \ |>\n<| c |>\nOh man, I've been scratching my head trying to figure out what's\
    \ going on.  I haven't even realized that `reverse` works like that.  Thanks!\n\
    <|/ c |>\n<| a dscore=0 |>\nI think this would be your best bet. It also has the\
    \ benefit of not using recursion. \n<code>", "    return $string if $string !~\
    \ /^[[:alpha:]]*$/;\n    my($longest_palindrome_postfix) = make_palindrome_postfix($string);\n\
    \    my($longest_palindrome_prepostfix) = reverse($longest_palindrome_postfix);\n\
    \    return $string . reverse($longest_palindrome_prepostfix . $longest_palindrome_postfix);\n\
    }", "    my($longest, $longestlen, @palindrome);\n    foreach my $i (0 .. length($string))\
    \ {\n        my $c = substr($string, $i, 1);\n        my $j = $i + 1;\n      \
    \  while ($j + 1 < length($string) && substr($string, $j, 1) eq substr($string,\
    \ $j + 1, 1)) {\n            $j++;\n        }\n        my $s = substr($string,\
    \ $i, length($string) - $j - 1);\n        if ($s eq $c) { # longest palindrome\n\
    \            if ($longestlen eq length($s)) {\n                push(@palindrome,\
    \ $s);\n            }\n            $longest = substr($string, $i, length($string)\
    \ - $i - 1);\n            $longestlen = length($longest);\n        } else {\n\
    \            push(@palindrome, \"\");\n        }\n    }\n    if (length($longest)\
    \ > 0) {\n        $longest = reverse($longest);\n        push(@palindrome, $longest);\n\
    \    }\n    if ($palindrome[0] != \"\") {\n        return join(\"\", @palindrome);\n\
    \    }\n    return \"\";\n}", "    my $longest = $string if $string !~ /([a-zA-Z]+)(?=(?=[a-z]{1})|$)/g;\n\
    \    my $reverse = reverse $string if $string =~ /([a-zA-Z]+)(?=(?=[a-z]{1})|$)/g;\n\
    \    $string = $longest . $reverse;\n    $string =~ s/([a-zA-Z]+)/_$1/g;\n   \
    \ return $string;\n}", '    my $longest;', "    my($postfix, $palindrome, $prefix);\n\
    \    \n    # Find the longest postfix that is a palindrome.\n    # Am I really\
    \ missing something? Is there an easier way?\n    while ($string =~ /(.)(.+)/s)\
    \ {\n        $postfix    = $1;\n        $palindrome = $2;\n    }\n    \n    #\
    \ Create the palindrome string from its components.\n    # Am I missing something?\
    \ Is there an easier way?\n    $palindrome .= reverse($postfix);\n    \n    #\
    \ Append the prefix to it to create the final palindrome string.\n    $palindrome\
    \ .= $prefix;\n    return $palindrome;\n}", "    my($longest_postfix_postfix_of_string_palindromic);\n\
    \    my(@longest_postfix_postfix_of_string_palindromic);", "    my @prefix = ();\n\
    \    my @suffix = ();\n    for (my $i = 0; $i < $#$string; $i++) {\n        my\
    \ $str = $string[$i];\n        push (@suffix, reverse $str);\n        if ($str\
    \ =~ /^(.)(.*)(.)$/) {\n            push (@prefix, $1);\n        }\n    }\n  \
    \  my $longest = &longest_postfix (@suffix);\n    $longest = &longest_postfix\
    \ (@prefix, @suffix);\n    if ($longest ne \"0\") {\n        return \"$string$longest\"\
    ;\n    }\n    elsif (@prefix > @suffix) {\n        return \"$string$longest\"\
    ;\n    }\n    else {\n        return \"$string\";\n    }\n}", '    return $string
    if $string eq "";', "    chomp $string;\n    $string =~ s/^([a-z]+)/$1/i;\n  \
    \  my $palindrome = $string;\n    $palindrome =~ s/^[a-z]+//i;\n    $palindrome\
    \ .= reverse substr($string, 0, length($string) - length($palindrome));\n    return\
    \ $palindrome;\n}", '    my @strings = split //, $string;', "    my(@pref, $pref,\
    \ $postfix, $post);\n    my(@rev, $rev);", "    return $string if $string !~ /^[a-z\\\
    d_]+$/i;\n    my($len, $suffix, $start) = length($string), 0, 0;\n    while ($len\
    \ > 1) {\n        if ($len > 3) {\n            $start = length($string) - 1;\n\
    \            $suffix = (substr($string, $start, $len) eq reverse(substr($string,\
    \ $start, $len))) ? $len : 0;\n        } else {\n            $suffix = $len;\n\
    \        }\n        last unless substr($string, 0, $start) = reverse(substr($string,\
    \ 0, $start));\n        $string = $string.substr($start, $suffix);\n        $len--;\n\
    \    }\n    return $string;\n}", "    return '' unless $string;\n    my($longest,\
    \ $shortest, $reverse, $palindrome);", "    $string =~ s/^.//;\n    $string .=\
    \ $string =~ /^(.)\\1$/;\n    return $string;\n}\n</code>\n<|/ a tags=string,algorithm,perl,reverse\
    \ |>\n<| c |>\nI don't think your `make_palindrome` function handles the case\
    \ where the first letter of the string is `a`; your function produces `'aac'`\
    \ as the palindrome.  Your `make_palindrome` doesn't seem to handle `'abcd'`.\
    \  Perhaps you meant `'abcc'` instead of `'cba'`?\n<|/ c |>\n<| c |>\nThis solution\
    \ is simple and beautiful. My solution is a little more elegant but more verbose.\
    \ Just thought I'd share the other solution. My first solution had a bug which\
    \ resulted in false positives. I just corrected it.\n<|/ c |>\n<| c |>\nThanks,\
    \ your first solution was more elegant than mine; however, it wasn't working correctly\
    \ for `abc`. Try it out here: http://codepad.org/yO7j5nq8.  I suppose the issue\
    \ with your solution is that it doesn't handle the case where the string begins\
    \ with a palindrome.\n<|/ c |>\n<| c |>\nYes, I think your first solution could\
    \ be modified so that it handles the case where the string begins with a palindrome.\
    \ I will update my solution.\n<|/ c |>\n<| c |>\n, I have updated the answer.\
    \ Thanks for pointing that out!\n<|/ c |>\n<| a tags=string,algorithm,perl,reverse\
    \ |>\n<code>\nuse strict;\nuse warnings;\nuse 5.10.0;", "    $string =~ s/^\\\
    s+//;\n    $string =~ s/\\s+$//;\n    $string =~ s/^\\s+|\\s+$//g;\n    my $palindromic\
    \ = $string;\n    $palindromic =~ s/^.//;\n    $palindromic =~ s/(.).*$/$1/;\n\
    \    $palindromic =~ s/(.).*\\1/;\n    $palindromic =~ s/(.).*$/\\1/;\n    $palindromic\
    \ =~ s/(.).*$/\\1/;\n    $palindromic =~ s/(.).*$/$1/;\n    $palindromic =~ s/(.).*$/$1/;\n\
    \    return $palindromic;\n}", "    $string =~ s/(.)\\1{2,}//;\n    my $max_length\
    \ = length($string);\n    my $max_postfix = $max_length - 1;\n    my $prefix;\n\
    \    for ($max_postfix;  $max_postfix > 0;  $max_postfix -= 1) {\n        my $suffix_start\
    \ = $max_postfix - 1;\n        my $suffix_end = $max_length - 1;\n        $suffix_start\
    \ -= 1 while $suffix_start >= 0 and $string->[$suffix_start] eq $string->[$suffix_end];\n\
    \        $suffix_end += 1 while $suffix_end >= 0 and $string->[$suffix_end] eq\
    \ $string->[$suffix_start];\n        my $reverse_suffix = $string->[$suffix_end];\n\
    \        $string->[$suffix_end] = $string->[$suffix_start];\n        $string->[$suffix_start]\
    \ = $reverse_suffix;\n        if ($string->[$suffix_start] == $string->[$suffix_end])\
    \ {\n            $prefix = $string->[$suffix_start];\n        }\n    }\n    $string\n\
    }", "    $string =~ s/^([a-z]+)\\z// if $string;\n    my $suffix = ($string =~\
    \ s/([^a-z]+)\\z// ? $1 : \"$string\");\n    my $reversed = reverse $string;\n\
    \    return $string . $reversed . $suffix;\n}\n</code>\n<|/ a tags=perl,string,palindrome\
    \ |>\n<| c |>\nThat won't work because you can have \"cataca\" or \"cataaac\"\
    \ and they will both be palindromic strings, but your code will not recognize\
    \ them.\n<|/ c |>\n<| c |>\n: Indeed it does not. I missed that in my solution.\
    \ Good catch, I will amend my answer.\n<|/ c |>\n<| a dscore=2 |>\nYou can use\
    \ the following script to check the palindrome:\n<code>", "    $string =~ s/^(.)\\\
    W*$/$1$1/s;\n    $string =~ s/\\W*(.)\\W*$/$1$2/s;\n    $string;\n}", '    my(@postfix_string,
    $postfix, $result);', "    if ($string =~ /^(.*)(.)\\1$/) {\n        $string .=\
    \ reverse $1 . substr($2, length($2));\n    }\n    return $string;\n}", "    my(@characters);\n\
    \    my(@characters_copy);\n    my($characters_count) = 0;\n    my($palindrome);\n\
    \    my($new_string);", "    return '' unless $string;\n    my(@postfix_string)\
    \ = &get_longest_palindromic_substring_from(@$string, $string);\n    my(@reversed_postfix_string)\
    \ = reverse(@postfix_string);\n    my(@palindrome_postfix, @palindrome_substring)\
    \ = ();\n    push(@palindrome_postfix, $string) unless @postfix_string;\n    for\
    \ (@postfix_string) {\n        push(@palindrome_substring, (@reversed_postfix_string\
    \ if $_ eq $_)) unless $_;\n    }\n    join(\"@\",);\n}", '    my $suffix;', " \
    \   return $string if length($string) == 1;\n    return substr(reverse($string),\
    \ 0, length($string)/2) . \"p\" . substr($string, 0, length($string)/2);\n}",
  "    my $postfix = $string;\n    my($reversed_prefix_string);\n    my($longest_postfix,\
    \ $longest_postfix_len, $longest_postfix_end);\n    my(@postfix_array);", "  \
    \  $string .= \"0\"\n        if length($string) == 1;", "    my($longest, $suffix)\
    \ = (\"\", \"\");\n    my @candidates;\n    foreach $char (split //, $string)\
    \ {\n        push(@candidates, $char);\n        push(@candidates, reverse($char));\n\
    \    }", '    return $string if length $string <= 1;', "    my($reverse, $postfix,\
    \ $reversed_postfix);\n    local $\" = \", \";\n    if ($string eq '') {\n   \
    \     return '';\n    }\n    # Step 1: Find the longest postfix of supplied string\
    \ that is a palindrome.\n    $postfix = reverse $string;\n    $reversed_postfix\
    \ = reverse $postfix;\n    if ($reversed_postfix eq $postfix) {\n        $reversed_postfix\
    \ .= '\\0';\n        return $reversed_postfix;\n    }\n    # Step 2: Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    if ($reversed_postfix =~ /^([a-zA-Z]+)(.*)$/) {\n        $reverse\
    \ = $1;\n        $string = $2;\n    }\n    if ($reverse eq '-') {\n        $reverse\
    \ = '\\0';\n    }\n    if ($string eq '-') {\n        $string = '\\0';\n    }\n\
    \    return $reverse . $string;\n}", "    my $prefix;\n    if ($string eq \"\"\
    ) {\n        return $string;\n    }\n    $prefix = substr(reverse($string), 0,\
    \ -1);\n    return $prefix . $string;\n}\n</code>\n<|/ a |>\n<| c |>\nThat code\
    \ doesn't work. `$string` has to be at least two characters long. If it's not,\
    \ nothing will be returned at all. Even if the `if` statement is removed, this\
    \ code still doesn't work. `$string` has to consist entirely of characters from\
    \ the original string except for a single character that should be appended to\
    \ the end of the reversed string. Also, the last line is wrong, it should be `return\
    \ $prefix . $string;`.\n<|/ c |>\n<| c |>\nThis code works perfectly on my system\
    \ (Windows 7 Professional, Perl 5.10.1). Thanks for testing it yourself!\n<|/\
    \ c |>\n<| c |>\nI apologize, my comment was a little misleading. The code doesn't\
    \ work on my machine. When I type `print \"abcdeabcdeabcdeabcdeabcde\".make_palindrome(\"\
    abcde\")` into my editor, I get `abcdea` printed to my screen. When I type `print\
    \ \"abcdeabcdeabcdeabcdeabcde\".make_palindrome(\"abcde\")` into my editor, I\
    \ get no output. I'm using Windows 7 and Perl v5.10.1.\n<|/ c |>\n<| c |>\n, sorry\
    \ about that. I've fixed my answer and provided a version that works on my machine.\
    \ Thanks!\n<|/ c |>\n<| c |>\n, Thanks for the correction. I've modified the code\
    \ in my answer to make it more permissive.\n<|/ c |>\n<| a dscore=0 |>\nHere is\
    \ my version of a palindrome checker that takes care of edge-case cases and is\
    \ written in pure perl. It returns the original string if the original string\
    \ is empty and otherwise returns the string that ends with a palindrome that begins\
    \ with the original string. I believe that it is more readable.\n<code>", '    my
    $palindrome = "";', '    my(@result,$i);', "    return $string if length($string)\
    \ <= 1;\n    $string =~ s/^([a-zA-Z]*)(.*)$/$2$1/;\n    $string =~ s/(.)(.*)$/\\\
    1$2/;\n    return $string;\n}", "    my $reverse = reverse $string;\n    my $postfix\
    \ = join \"\", map {$reverse[$_]} 0..$#reverse;\n    return $string . $postfix;\n\
    }", "    # Start with the supplied string being reversed.\n    my $reversed =\
    \ reverse $string;\n    # If it's already a palindrome, return it.\n    return\
    \ $string if $string eq $reversed;\n    # Find the longest postfix that is palindrome.\n\
    \    my $reversed_length = 0;\n    my $longest = undef;\n    foreach my $letter\
    \ (split //, $string) {\n        $reversed_length += length($letter);\n      \
    \  $reversed_length -= length($reversed) if $reversed_length > length($reversed);\n\
    \        last if $reversed_length == 0;\n        last if $letter == $reversed[$reversed_length];\n\
    \        $longest = $letter;\n    }\n    # Append the postfix to the end of the\
    \ supplied string.\n    $string .= reverse $longest;\n    return $string;\n}\n\
    </code>\n<|/ a dscore=4 tags=palindrome,perl,algorithm |>\n<| a dscore=3 |>\n\
    I have found a really simple solution for your problem which is based on the fact\
    \ that the first two characters are mirror images of the last two characters.\
    \ So if we can flip the letters, we can simply flip the two first characters of\
    \ the input string. That is why the solution looks something like this:\n<code>\n\
    use strict;\nuse warnings;", "    # Find longest palindrome of $string that starts\
    \ with a letter.\n    my $longest = length($string);\n    my $start = $string;\n\
    \    while ($start ne \"0\") { # Find longest postfix of $string that is a palindrome.\n\
    \        my $postfix = substr($string, -$longest);\n        $postfix = reverse($postfix);\n\
    \        if ($string eq $postfix) {\n            $longest = length($postfix);\n\
    \            $start = $postfix . $string;\n        }\n    }\n    return $start;\n\
    }", "    my $reversed_string = \"\";\n    my($longest) = make_palindrome_with_longest($string);\n\
    \    return $string if $longest ne $string;\n    $string =~ s/^(.{$longest})\\\
    R//;\n    $string .= reverse $1;\n    $string =~ s/(.{$longest})\\R(.)$/\\1\\\
    3/;\n    return $string;\n}", "    my($longest);\n    my($reverse);\n    my ($firstchar);\n\
    \    my(@words);\n    my($lastchar);\n    $string =~ m/(\\S*)(\\S*)/;\n    $longest\
    \ = $1;\n    $reverse = $2;\n    $firstchar = $string =~ /(\\S*)$/;\n    while\
    \ (length($reverse) > length($longest)) {\n        $lastchar = $string =~ /(\\\
    S*)/;\n        my($suffix) = $string =~ /(\\S*)(\\S*)$/;\n        $reverse = $reverse\
    \ . $lastchar . $suffix;\n    }\n    $longest = $reverse . $longest;\n    push(@words,\
    \ \"$longest\");\n    push(@words, reverse $firstchar);\n    return join(\" \"\
    ,);\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. However, it seems\
    \ like my code only works if the first word of a string is palindrome. Other than\
    \ that, I can't understand it.\n<|/ c |>\n<| c |>\nI added some more explanation.\n\
    <|/ c |>\n<| c |>\n`substr($string,-1,1)` should be `substr($string,-1)` - you\
    \ want the last character in the string, not a character before that. Your method\
    \ only works for strings of one character (e.g. \"cata\"). Your method also doesn't\
    \ return the palindrome itself. It's probably better if you just explain how you\
    \ do it in your answer.\n<|/ c |>\n<| c |>\nAh yeah. I missed that one. Thanks.\
    \ I've updated the answer.\n<|/ c |>\n<| c |>\nThanks for your detailed answer,\
    \ it really helps.\n<|/ c |>\n<| a tags=perl,palindrome dscore=2 |>\nI think this\
    \ works, if you don't want to use reverse.\n<code>", "    $string =~ s/^\\s+//;\n\
    \    my $prefix_len = $string =~ tr/A-Za-z//;\n    my $suffix = $string =~ s/^(.*)\\\
    z/$1/;\n    my $reversed_suffix = reverse($suffix);\n    $string .= $reversed_suffix;\n\
    \    my $palindrome = reverse $string;\n    $palindrome =~ s/\\Q$string\\E//;\n\
    \    $palindrome = join(\"\", map { chr $_ } (ord($_) - ord('A') .. ord($_) -\
    \ ord('z')), $palindrome);\n    return $palindrome;\n}", "    my($suffix) = reverse\
    \ $string;\n    my($postfix, $result) = ();\n    my($max_len, @palindromes) =\
    \ ();", '    my($postfix, $prefix);', "    my($reverse_palindrome, $reverse);\n\
    \    my($end_of_string, $end_of, reverse, suffix_length);\n    my($start, $end,\
    \ $end_of_substring);\n    my($i, $j, $k);", "    return unless $string =~ /^\\\
    p{Lower}+$/i;\n    my $reversed = reverse $string;\n    $string .= $reversed;\n\
    \    return $string;\n}", "    my $longest = 0;\n    my $longestString = $string;\n\
    \    my $longestPalindrome = $string;\n    my $longestSuffix = 0;", "    my($longest);\n\
    \    my($reverse);\n    my($post);", "    # Slurp up entire string if supplied\
    \ string is empty.\n    if ($string eq \"\") {\n        $palindrome = \"\";\n\
    \    }\n    else {\n        # Pad end with null bytes.\n        $string .= \"\\\
    0\";\n        # Find the longest postfix that is a palindrome.\n        my($max_len,\
    \ $max_len_idx) = (0, 0);\n        for my $postfix (reverse split //, $string)\
    \ {\n            if (length($postfix . reverse $postfix) eq length($postfix))\
    \ {\n                # Found one.\n                $max_len = $#postfix;\n   \
    \             $max_len_idx = $#postfix;\n            }\n        }\n        # Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        $string .= reverse substr($string, 0, $max_len);\n        #\
    \ Return palindrome with null bytes appended.\n        $palindrome = $string.\"\
    \\0\";\n    }\n    return $palindrome;\n}", "    my @strings;\n    my $max_suffix\
    \ = 0;\n    foreach my $suffix (reverse split //, $string) {\n        my $postfix\
    \ = $string . $suffix;\n        my $postfix_length = length($postfix);\n     \
    \   if ($postfix_length > $max_suffix) {\n            $max_suffix = $postfix_length;\n\
    \        }\n        push(@strings, $postfix . $string);\n    }\n    my $prefix\
    \ = join \"\", reverse(@strings);\n    return $prefix . $string;\n}", "    my(@postfix,\
    \ $reverse_string);\n    my(@prefix, $prefix_string);\n    my($longest, @longest_postfix,\
    \ $longest_prefix);", '    my($longest_postfix_of_string_to_be_a_palindrome);',
  "    return $string if length($string) <= 1;\n    my($prefix_string) = substr($string,\
    \ 0, -1);\n    return $prefix_string if length($prefix_string) > length($string);",
  "    my($suffix) = $string =~ s/^.//;\n    my($longest) = $string =~ s/(\\w)(\\\
    w*)/$2 eq $1 ? $1 : $1/eg;\n    $string = $string.$longest.reverse if $string\
    \ =~ m/(\\w)(\\w*)\\1\\w\\1\\w/;\n    return $string;\n}", "    my($suffix_length,\
    \ $suffix, $palindrome_start_pos);\n    my ($first_palindrome, @suffix_lengths);",
  "    my($palindrome) = \"\";\n    my($longest_postfix) = 0;\n    my($suffix);",
  "    my($start_index) = index($string, \" \");\n    my $end_index = $start_index+length($string)-1;\n\
    \    my($palindrome) = $string;\n    my $prefix_index = $start_index-1;\n    my\
    \ $suffix_index = $start_index;\n    my $suffix;", "    my($l, $r);\n    my($l,\
    \ $r);\n    # find the longest postfix of $string\n    my $len = 0;\n    while(1)\
    \ {\n        ($l, $r) = split(/(.+?)(.+)/, $string);\n        if(length($r) >\
    \ length($l)) {\n            $len = $r;\n            $string = $l;\n        }\
    \ else {\n            $string = $r;\n            $len = $l;\n        }\n     \
    \   if(length($string) <= 1) {\n            last;\n        }\n    }\n    # build\
    \ the reverse of the string prefix\n    my $prefix = $string;\n    my $reverse\
    \ = \"\";\n    my $pos = 0;\n    while($pos < length($prefix)) {\n        my $c\
    \ = substr($prefix, $pos, 1);\n        if($c eq \"-\") {\n            $reverse\
    \ = \"-\".$reverse;\n            next;\n        } elsif($c eq \"-$reverse\") {\n\
    \            $reverse = \"-\".$reverse;\n            next;\n        } elsif($c\
    \ eq \"-\") {\n            $reverse = \"-\".$reverse;\n            next;\n   \
    \     } elsif($c eq \"-\") {\n            $reverse = \"-\".$reverse;\n       \
    \     next;\n        } elsif($c eq \"-\") {\n            $reverse = \"-\".$reverse;\n\
    \            next;\n        } elsif($c eq \"-\") {\n            $reverse = \"\
    -\".$reverse;\n            next;\n        } elsif($c eq \"-\") {\n           \
    \ $reverse = \"-\".$reverse;\n            next;\n        } elsif($c eq \"-\")\
    \ {\n            $reverse = \"-\".$reverse;\n            next;\n        } elsif($c\
    \ eq \"-\") {\n            $reverse = \"-\".$reverse;\n            next;\n   \
    \     } elsif($c eq \"-\") {\n            $reverse = \"-\".$reverse;\n       \
    \     next;\n        } elsif($c eq \"-\") {\n            $reverse = \"-\".$reverse;\n\
    \            next;\n        } elsif($c eq \"-\") {\n            $reverse = \"\
    -\".$reverse;\n            next;\n        } else {\n            $reverse = $c.$reverse;\n\
    \        }\n        $pos++;\n    }\n    return $prefix.$reverse;\n}", "    # Make\
    \ a string with length equal to string\n    my $len = length($string);\n    $string\
    \ .= \"\" if $len == 0;", "    chomp($string);\n    my $length = $string->length;",
  "    my $longest = $string;\n    my $reverse_suffix;", "    my(@prefix);\n    my(@suffix);\n\
    \    my(@longest);\n    my(@longestpalindrome);\n    my($longestpalindrome);\n\
    \    my($longestpalindromelength) = undef;\n    my($longestpalindromenum) = undef;\n\
    \    my($longestpalindromeprefix) = undef;\n    my($longestpalindromesuffix) =\
    \ undef;\n    my($longestpalindromeprefixlength) = 0;\n    my($longestpalindromenum)\
    \ = 0;", "    # Slightly more complex algorithm for finding longest palindrome:\n\
    \    # - Find the longest prefix that is a palindrome.\n    # - Find the longest\
    \ postfix that is a palindrome.\n    # - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    my $prefix;\n\
    \    my $postfix;\n    my $reversed;\n    my $max_length = 0;\n    for(my $i =\
    \ 0; $i < length($string); $i++) {\n        for(my $j = 0; $j < length($string);\
    \ $j++) {\n            $reversed = reverse substr($string, $i, 1);\n         \
    \   $prefix = substr($string, 0, $i);\n            $postfix = substr($string,\
    \ $i, 1);\n            if($reversed eq $postfix) {\n                if(length($prefix)\
    \ > $max_length) {\n                    $max_length = length($prefix);\n     \
    \               $max_length_prefix = $prefix;\n                    $max_length_postfix\
    \ = $postfix;\n                }\n            }\n        }\n    }\n    my $longest\
    \ = $max_length;\n    if(length($max_length_prefix) > length($max_length_postfix))\
    \ {\n        $longest = $max_length_prefix;\n    } else {\n        $longest =\
    \ $max_length_postfix;\n    }\n    $longest .= reverse substr($string, 0, $longest);\n\
    \    return $longest;\n}", "    $string =~ s/^\\s+//;\n    $string =~ s/\\s+$//;",
  "    $string =~ s/(.)\\1+/\\1/g;\n    $string =~ tr/a-z/A-Z/;\n    return $string;\n\
    }", "    return unless defined $string;\n    return if $string eq ''; # Empty\
    \ string is not a palindrome.\n    # Strip off any leading or trailing spaces.\n\
    \    $string =~ s/^\\s+|\\s+$//g;\n    # Find palindromic suffix.\n    my($suffix);\n\
    \    if ($string =~ m{^([a-z]+)([a-z0-9]+)}ix) {\n        $suffix = $1;\n    \
    \    $string =~ s/^$suffix[a-z]+//i;\n    }\n    else {\n        $suffix = $string;\n\
    \    }\n    my $palindrome = $string;\n    my $prefix = $string;\n    # Find longest\
    \ postfix of supplied string.\n    while ($prefix =~ m{^([a-z]+)([a-z0-9]+)$}i)\
    \ {\n        $palindrome .= $3;\n        $prefix =~ s/^([a-z]+)$/\\L$1/g;\n  \
    \  }\n    $palindrome .= reverse $suffix;\n    return $palindrome;\n}\n</code>\n\
    <|/ a tags=perl,string,algorithm,palindrome |>\n<| c |>\nIt's worth noting that\
    \ this approach doesn't handle cases where there are duplicate letters e.g. \"\
    madam\"\n<|/ c |>\n<| c |>\nThanks for adding that caveat, I was just about to\
    \ go crazy trying to work out why mine didn't work. Fixed now.\n<|/ c |>\n<| c\
    \ |>\nThanks again! I noticed that my code was giving a false positive for \"\
    abcdef\" but after I saw that you had added a check for 'a-z', I went back and\
    \ made a similar check for 'a-z' in the prefix check, which I didn't think would\
    \ work. I'm sure that you've seen the error in my code.\n<|/ c |>\n<| c |>\nYeah,\
    \ I didn't see that problem either. I've made it a little more robust now so that\
    \ it handles more than just ascii, so it can handle \"abba\", \"abc\", or \"abcdab\"\
    . I think it may still be slow for large strings, but it's a lot more readable\
    \ than my original answer.\n<|/ c |>\n<| c |>\nSorry I didn't see that earlier.\
    \ Your code doesn't work for \"abba\" though it works for \"abc\".\n<|/ c |>\n\
    <| a tags=perl,string,algorithm,palindrome dscore=2 |>\n<code>\nuse strict;\n\
    use warnings;", "    $string .= reverse $string;\n    $string =~ s/^.*(\\Q$string\\\
    E).*/$1/;\n    return $string;\n}", "    my ($longest, $shortest) = (1, 1);\n\
    \    foreach my $i (reverse $string) {\n        next if ($i =~ /^\\W/);\n    \
    \    if ((length($shortest . $i) <= length($longest . $string))) {\n         \
    \   $longest = $i;\n        }\n        if ((length($shortest . $i) >= length($longest\
    \ . $string))) {\n            $shortest = $i;\n        }\n    }\n    return $longest\
    \ . $shortest;\n}", "    \n    # 1. Find the longest postfix that is a palindrome.\n\
    \    # Find longest postfix such that $string =~ s/^.*\\K(.*?)($string)/$1/\n\
    \    # e.g. \"abc\" => \"cba\"\n    my $match = $string =~ s/^.*\\K(.*?)($string)/$1/;\n\
    \    \n    # 2. Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    my $reversed_match = reverse($match);\n\
    \    \n    return $reversed_match.$string;\n}\n</textarea></div>", "    my($longest)\
    \ = $string =~ /([^a-zA-Z]*)(.)(.*)(\\1\\2)/g;\n    my($suffix) = $string =~ /(.*)(\\\
    1\\2)(.*)/g;\n    my($postfix, $prefix);\n    if ($longest =~ /([^a-zA-Z]*)(.)(.*)(\\\
    1\\2)/g) {\n        $longest = $1 . $2 . reverse($3);\n        $prefix = $longest\
    \ . $4;\n    }\n    else {\n        $longest = $string . $string;\n        $prefix\
    \ = $string;\n    }\n    $longest = $prefix . $longest;\n    return $longest;\n\
    }", "    my $suffix;\n    my $reverse_string;\n    my $palindromic;", '    return
    $string if $string =~ /^\s*$/;', '    my($postfix, $reverse_postfix);', "    my($longest_postfix);\n\
    \    my($longest_prefix_postfix);\n    my(@suffixes);\n    my($suffix);\n    my($suffix_postfix_reverse);\n\
    \    my($prefix_postfix_reverse);\n    my($palindrome);", "    $string .= \"\"\
    \ if length $string < 1;\n    my($palindrome, $start);\n    foreach $start (length($string)\
    \ - 1) {\n        my($suffix) = substr($string, $start);\n        my($reversed)\
    \ = substr($string, $start, 1);\n        my($newReversed) = $reversed x length($suffix);\n\
    \        $palindrome .= $suffix . $newReversed;\n    }\n    return $palindrome;\n\
    }", "    my $max_length = 0;\n    my(@max_lengths, $max_length);", "    my $palindrome\
    \ = \"\";\n    my $longest;\n    my $reversed_suffix;\n    while($string ne \"\
    \") {\n        $longest = 0;\n        my $postfix_index = 0;\n        my $suffix\
    \ = \"\";\n        while($postfix_index < length($string)) {\n            my $c\
    \ = substr($string,$postfix_index,1);\n            $postfix_index++;\n       \
    \     if ($c eq $string[$longest] ) {\n                $longest++;\n         \
    \   }\n            else {\n                last;\n            }\n        }\n \
    \       $postfix_index = 0;\n        my $prefix = substr($string,0,$longest);\n\
    \        my $reversed_prefix = reverse($prefix);\n        while ($postfix_index\
    \ < length($string)) {\n            my $c = substr($string,$postfix_index,1);\n\
    \            $postfix_index++;\n            if ($c eq $string[$longest] ) {\n\
    \                $longest++;\n            }\n            elsif ($longest > $reversed_suffix)\
    \ {\n                $reversed_suffix = $longest;\n            }\n           \
    \ else {\n                last;\n            }\n        }\n        $palindrome\
    \ .= $reversed_prefix . $string . $suffix;\n        $string = $reversed_suffix;\n\
    \    }\n    $palindrome;\n}", "    my $reversed_prefix;\n    my $longest = length($string);\n\
    \    foreach my $i(1..$longest) {\n        my $prefix = substr($string, 0, $i);\n\
    \        my $postfix = substr($string, $i);\n        if ( make_palindrome($prefix)\
    \ == $postfix ) {\n            $reversed_prefix = $prefix;\n            last;\n\
    \        }\n    }\n    return \"$reversed_prefix$string\";\n}", "    return $string\
    \ if scalar $string eq \"\";\n    my($prefix);\n    for(my $i = 0; $i < scalar\
    \ $string; ++$i) {\n        $prefix = $string[$i] if $i < scalar $prefix and $string[$i]\
    \ eq $prefix[$i];\n    }\n    my($post);\n    for(my $i = scalar $string; $i >=\
    \ 0; --$i) {\n        $post = $string[$i] if $i < scalar $post and $string[$i]\
    \ eq $post[$i];\n    }\n    return $prefix . $string . $post;\n}", "    $string\
    \ =~ tr/a-z/A-Z/;\n    my $postfix_length = (length $string) / 2;\n    my $prefix_length\
    \ = length $string - $postfix_length;\n    my $prefix_string = substr($string,\
    \ 0, $prefix_length);\n    my $suffix = reverse substr($string, $prefix_length);\n\
    \    return $prefix_string . $suffix;\n}", "    my($max_length) = ($string =~\
    \ tr/a-zA-Z//);\n    my($result) = $string;\n    my($reverse_string);\n    my($palindromic);",
  '    return $string if $string eq "";', "    my($longest) = length($string);\n \
    \   my $postfix = reverse $string;\n    my $reversed_prefix = reverse $string;\n\
    \    # Find the longest postfix that is a palindrome.\n    while ($postfix =~\
    \ s/(.)\\1+/$1/gc) {\n        $longest = length($longest) < length($1) ? length($1)\
    \ : $longest;\n    }\n    # Append the reverse of the suffix that comes before\
    \ the palindromic suffix.\n    $reversed_prefix .= substr $string, 0, $longest\
    \ - 1;\n    return $reversed_prefix;\n}\n</code>\n<|/ a tags=perl,algorithm |>\n\
    <| a |>\nA single regex with a look-ahead:\n<code>\nmy $longest = (length $string)\
    \ * (length $string) + 1;\n$string =~ s/(.)\\1+/$1 .= reverse($1)/eg;\n</code>\n\
    Or you could use a regex with a look-behind:\n<code>\n$string =~ s/(?<=\\G(?<length>))(.)(?=\\\
    1{2,})/$1 .= reverse($1)/eg;\n</code>\n<|/ a tags=perl,algorithm dscore=0 |>\n\
    <| c |>\n`/e` means \"use extended syntax\", which means you can do stuff like\
    \ `(?<length>)` instead of just `(?<length>)`.\n<|/ c |>\n<| c |>\nThat's a good\
    \ idea, but as far as I know you cannot use a look-behind in an atomic substitution\
    \ regex like that.  You'd have to either use the `/e` modifier or `(?{})` blocks\
    \ to create named groups, or use a zero-width look-ahead assertion (`(?=\\1?$)`).\n\
    <|/ c |>\n<| a tags=perl,algorithm |>\nI tested out several of the answers and\
    \ found the following is the fastest and most concise answer:\n<code>\n$string\
    \ =~ s/(\\w)(\\w*)\\1\\2/reverse($1)/egr;\n</code>\nTest output:\n<code>\n$ perl\
    \ -MData::Dumper -E'\n   $string = \"abc\"; \n   my $longest = (length $string)\
    \ * (length $string) + 1;\n   $string =~ s/(.)\\1+/$1 .= reverse($1)/eg;\n   $string\
    \ =~ s/(\\w)(\\w*)\\1\\2/reverse($1)/egr;\n   $string =~ s/(\\w)(\\w*)\\1\\2",
  "    return \"\" unless $string;\n    $string =~ s/^(((?!$)\\w)+)\\z/$1 . reverse\
    \ $1/eeg;\n    return $string;\n}", "    my(@palindromes) = ();\n    foreach my\
    \ $c (reverse $string) {\n        if($c eq $string[-1]) {\n            push @palindromes,\
    \ $string;\n            last;\n        }\n    }\n    unshift @palindromes, reverse\
    \ $string;\n    return $palindromes[0];\n}", "    my($l, $r) = find_longest_postfix_that_is_palindrome($string);\n\
    \    return $string.$l.$r;\n}", "    my($maxlen, $minlen) = (0,0);\n    my($postfix,\
    \ @suffix);", "    my(@characters);\n    my(@strings);\n    my(@reverse_strings);\n\
    \    my(@results);\n    my($longest);\n    my($longest_index);", "    my $reversed_string;\n\
    \    if (length $string < 2) {\n        return $string;\n    } elsif ($string\
    \ eq reverse($string)) {\n        return $string;\n    } else {\n        $reversed_string\
    \ = reverse($string);\n        $string .= $reversed_string;\n    }\n    return\
    \ $string;\n}", "    my $longest;\n    my $longest_prefix = \"\";\n    my $longest_suffix;\n\
    \    for my $suffix_length (1..length($string)) {\n        my $prefix = substr($string,\
    \ 0, $suffix_length);\n        my $reverse_prefix = reverse($prefix);\n      \
    \  my $reverse_suffix;\n        if ($suffix_length <= length($string)) {\n   \
    \         $reverse_suffix = substr($string, $suffix_length-1);\n        } else\
    \ {\n            $reverse_suffix = substr($string, 0, $suffix_length-1);\n   \
    \     }\n        next if $suffix ne $reverse_suffix;\n        my $palindrome =\
    \ $string.$reverse_prefix;\n        next unless $palindrome =~ /^(.).*\\1$/;\n\
    \        next if $palindrome eq $reverse_suffix;\n        $longest = $palindrome;\n\
    \        $longest_prefix = $prefix;\n        $longest_suffix = $reverse_suffix;\n\
    \        last;\n    }\n    $longest_suffix .= $longest_prefix;\n    $longest;\n\
    }", "    return \"\" unless ($string);\n    my(@suffixes) = @_;", "    $string\
    \ .= \"$string\" =~ tr/a//d;\n    $string .= \"$string\" =~ tr/a//d;\n    $string\
    \ =~ s/^\\Q$string\\E$//;\n    return $string;\n}", "    my(@suffix_strings);\n\
    \    my($palindrome, $suffix_string, $suffix_index, $suffix_string);\n    if ($string\
    \ eq \"\") {\n        $palindrome = $string;\n    }\n    else {\n        @suffix_strings\
    \ = reverse($string);\n        @suffix_strings[0..scalar(@suffix_strings)-1];\n\
    \        @suffix_strings[0..scalar(@suffix_strings) - 1];\n        @suffix_strings[0..scalar(@suffix_strings)\
    \ - 1];\n        @suffix_strings[0..scalar(@suffix_strings) - 1];\n        @suffix_strings\
    \ = reverse(\\@suffix_strings);\n        $suffix_index = index($string, $string[-scalar(@suffix_strings)])+1;\n\
    \        $suffix_string = $string[$suffix_index..$#string];\n        $palindrome\
    \ = $string.$suffix_string;\n    }\n    return $palindrome;\n}", "    \n    if(!defined($string))\
    \ {\n        $string = \"\";\n    }\n    \n    # Find longest postfix of supplied\
    \ string that is a palindrome.\n    my $max_palindrome = 0;\n    \n    my @prefixes\
    \ = ();\n    my @postfix = split(//, $string);\n    \n    foreach my $postfix\
    \ (@postfix) {\n        # Find prefix that comes before the longest postfix of\
    \ supplied string.\n        my $prefix = substr($string, 0, $max_palindrome);\n\
    \        \n        push(@prefixes, $prefix);\n        \n        $max_palindrome\
    \ = length($prefix) - length($postfix) - 1;\n    }\n    \n    return join(\"\"\
    , @prefixes).\"-\".substr($string, $max_palindrome+1, length($string));\n}", " \
    \   return $string unless $string;\n    my($palindromic_suffix) = find_longest_palindromic_suffix($string);\n\
    \    my($beginning_of_palindromic_suffix) = $palindromic_suffix;\n    my($length_of_palindromic_suffix)\
    \ = $palindromic_suffix =~ tr/a-zA-Z//;\n    my(@suffix_chars) = $string;\n  \
    \  @suffix_chars[$length_of_palindromic_suffix..-1] =\n      $string[$length_of_palindromic_suffix..-1]\
    \ =~ tr/a-zA-Z//;\n    return reverse join '',\n      $beginning_of_palindromic_suffix\
    \ . join '',\n      @suffix_chars;\n}", "    my($reverse_string) = \"\";\n   \
    \ my($length_of_longest_postfix_palindrome) = 0;", '    my $max_len = length($string);',
  "    $string =~ m/(.+?)(\\w)/;\n    my $prefix = $1;\n    my $suffix = reverse($2);\n\
    \    if ($string =~ m/(\\w)$/) {\n        $prefix .= $1;\n    }\n    if ($suffix\
    \ eq $prefix) {\n        return $string;\n    }\n    return $prefix.$suffix;\n\
    }", "    # Find the longest postfix of $string that is a palindrome.\n    my $longest_postfix_length\
    \ = 0;\n    my $longest_postfix_substr;\n    while (length($string) > $longest_postfix_length)\
    \ {\n        $longest_postfix_substr = substr($string, -$longest_postfix_length,\
    \ $longest_postfix_length);\n        if (is_palindrome($longest_postfix_substr))\
    \ {\n            $longest_postfix_length++;\n        }\n        else {\n     \
    \       last;\n        }\n    }\n    # Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    my $reverse_suffix\
    \ = reverse($string);\n    my $reverse_prefix_substr = substr($string, 0, -$longest_postfix_length);\n\
    \    return $string . $reverse_prefix_substr . $reverse_suffix;\n}", "    my($suffix)\
    \ = $string =~ /([^$string]{1})(\\w*)/s;\n    my($prefix) = $string =~ /(\\w*)(\\\
    w*)/s;\n    my($reverse_prefix) = $prefix =~ /([^$string]{1})/s;\n    $string\
    \ .= $reverse_prefix;\n    $string .= reverse(substr($suffix, 0, length($suffix)));\n\
    \    return $string;\n}\n</code>\nNote that this will only work on single word\
    \ palindromes.\n<|/ a dscore=1 tags=perl,algorithm |>\n<| a tags=perl,algorithm\
    \ |>\n<code>", "    # Find the length of the shortest postfix of $string that\
    \ is a palindrome.\n    # Assume $string starts with a postfix of length 1 or\
    \ longer.\n    my($postfix_length) = length($string) - 1;\n    # Find the longest\
    \ postfix of $string that is a palindrome.\n    # Assume $string starts with a\
    \ postfix of length 0 or longer.\n    my($longest_postfix) = reverse($string);\n\
    \    # Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    $string .= reverse($longest_postfix, 0, $postfix_length);\n\
    \    return $string;\n}", "    my(@postfixes) = ();\n    my($start_index) = -1;",
  "    $string =~ s/^/Palindrome: / if $string =~ /Palindrome: ([^\\s]+)\\s*$/;\n\
    \    $string;\n}", "    my @array = split(//, $string);\n    my $reverse_prefix\
    \ = reverse(@array);\n    if (substr($string, 0, length($reverse_prefix)) == $reverse_prefix)\
    \ {\n        $string .= \"{$reverse_prefix}\";\n    }\n    return $string;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
