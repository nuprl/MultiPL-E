completions:
- '      return 0;'
- '        return n * (n-1) / 2;'
- "        List<Integer> leftToRight = IntStream.range(0, n).boxed().collect(Collectors.toList());\n\
  \        List<Integer> rightToLeft = IntStream.range(0, n).boxed().map(i -> -i).collect(Collectors.toList());\n\
  \        Collections.sort(leftToRight);\n        Collections.sort(rightToLeft);\n\
  \        int collisions = 0;\n        while (!leftToRight.isEmpty() && !rightToLeft.isEmpty())\
  \ {\n            if (leftToRight.get(0) < rightToLeft.get(0)) {\n              \
  \  collisions++;\n                leftToRight.remove(0);\n            } else {\n\
  \                rightToLeft.remove(0);\n            }\n        }\n        return\
  \ collisions;"
- '        return 0;'
- "        // We will use an array of n tuples.  Each tuple represents the location\
  \ of the i-th car\n        // going right to left; each tuple has two elements:\
  \ the initial position and the speed.\n        Tuple2<Integer, Integer> cars[] =\
  \ new Tuple2[n];\n        for (int i = 0; i < n; i++) {\n            cars[i] = Tuple2.fromArray(new\
  \ Integer[] {2 * i, i + 1});\n        }\n        // Let's also create an array of\
  \ the same length for the cars going left to right.\n        Tuple2<Integer, Integer>\
  \ cars2[] = new Tuple2[n];\n        for (int i = 0; i < n; i++) {\n            cars2[i]\
  \ = Tuple2.fromArray(new Integer[] {-2 * i, i + 1});\n        }\n        // Now\
  \ let's simulate the race.\n        int numCollisions = 0;\n        while (true)\
  \ {\n            // We will simulate one second of the race.\n            // In\
  \ the next loop, we will go through all the cars and update their positions.\n \
  \           for (int i = 0; i < n; i++) {\n                // Update the position\
  \ of the i-th car.\n                cars[i] = Tuple2.fromArray(new Integer[] {cars[i].getValue0()\
  \ + cars[i].getValue1(), cars[i].getValue1()});\n                cars2[i] = Tuple2.fromArray(new\
  \ Integer[] {cars2[i].getValue0() - cars2[i].getValue1(), cars2[i].getValue1()});\n\
  \            }\n            // Now we can detect if there is a collision.\n    \
  \        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++)\
  \ {\n                    if (cars[i].getValue0() > cars2[j].getValue0()) {\n   \
  \                     numCollisions++;\n                    }\n                }\n\
  \            }\n            // Now we can check if all cars have already past each\
  \ other.\n            boolean allCarsHavePastEachOther = true;\n            for\
  \ (int i = 0; i < n; i++) {\n               "
- '        return 0;'
- "        int[] leftCars = new int[n];\n        int[] rightCars = new int[n];\n \
  \       for (int i = 0; i < n; i++) {\n            leftCars[i] = n - i;\n      \
  \      rightCars[i] = i + 1;\n        }\n        int ans = 0;\n        int cur =\
  \ 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = cur; j < n;\
  \ j++) {\n                if (leftCars[i] < rightCars[j]) {\n                  \
  \  cur = j;\n                    break;\n                }\n                ans++;\n\
  \            }\n        }\n        return ans;"
- '        return 0;'
- "        int[][] cars = new int[n][2];\n        for (int i = 0; i < n; i++) {\n\
  \            cars[i][0] = i;\n            cars[i][1] = i + n;\n        }\n     \
  \   return Helper.mergeSortAndCount(cars, 0, n - 1, 0);"
- "        // Implement me\n        return 0;"
- "        boolean[] movingL2R = new boolean[n];\n        for (int i = 0; i < n; i++)\
  \ {\n            movingL2R[i] = true;\n        }\n        boolean[] movingR2L =\
  \ new boolean[n];\n        for (int i = 0; i < n; i++) {\n            movingR2L[i]\
  \ = false;\n        }\n        int colls = 0;\n        while (true) {\n        \
  \    boolean hasL2R = false;\n            boolean hasR2L = false;\n            for\
  \ (int i = 0; i < n; i++) {\n                if (movingL2R[i]) {\n             \
  \       hasL2R = true;\n                }\n                if (movingR2L[i]) {\n\
  \                    hasR2L = true;\n                }\n            }\n        \
  \    if (!hasL2R && !hasR2L) {\n                break;\n            }\n        \
  \    for (int i = 0; i < n; i++) {\n                if (movingL2R[i]) {\n      \
  \              for (int j = 0; j < n; j++) {\n                        if (movingR2L[j])\
  \ {\n                            colls++;\n                        }\n         \
  \           }\n                }\n            }\n            for (int i = 0; i <\
  \ n; i++) {\n                if (movingL2R[i]) {\n                    movingL2R[i]\
  \ = false;\n                }\n                if (movingR2L[i]) {\n           \
  \         movingR2L[i] = false;\n                }\n            }\n        }\n \
  \       return colls;"
- "        int[] a = new int[n];\n        int[] b = new int[n];\n        Random random\
  \ = new Random();\n        for (int i = 0; i < n; i++) {\n            a[i] = random.nextInt(n)\
  \ + 1;\n            b[i] = random.nextInt(n) + 1;\n        }\n        // Your code\
  \ here.\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n       \
  \     for (int j = 0; j < n; j++) {\n                if (a[i] == b[j]) {\n     \
  \               count++;\n                }\n            }\n        }\n        return\
  \ count;"
- "        // ASSUME n > 0, n is an integer.\n        int collisions = 0;\n      \
  \  // TODO: FILL THIS IN!\n        return collisions;"
- "        // WRITE YOUR CODE HERE\n        return 0;"
- "        int[] left = new int[n];\n        int[] right = new int[n];\n        Random\
  \ r = new Random();\n        for (int i = 0; i < n; i++) {\n            left[i]\
  \ = r.nextInt(1000);\n            right[i] = r.nextInt(1000);\n        }\n     \
  \   Arrays.sort(left);\n        Arrays.sort(right);\n        int result = 0;\n \
  \       int i = 0;\n        int j = 0;\n        while (i < n && j < n) {\n     \
  \       if (left[i] < right[j]) {\n                result += j;\n              \
  \  i++;\n            } else {\n                j++;\n            }\n        }\n\
  \        result += (n - i) * n;\n        return result;"
- "        // Write your code here.\n        // If you find this problem difficult,\
  \ you can solve an easier problem first:\n        // 1. You can assume the cars\
  \ all move at different speeds.  How would you modify the above code\n        //\
  \    to support this case?\n        // 2. You can assume the cars move at the same\
  \ speed, but there are only 2 cars that drive in\n        //    opposite directions.\n\
  \        return -1;"
- '        return n == 0 ? 0 : n + carRaceCollision(n - 1);'
- "        int [] LTR = new int[n];\n        int [] RTL = new int[n];\n        for\
  \ (int i = 0; i < n; i++) {\n            LTR[i] = 2 * i + 2;\n            RTL[i]\
  \ = -(2 * i + 1);\n        }\n        for (int i = 0; i < n; i++) {\n          \
  \  if (LTR[i] == RTL[i]) {\n                System.out.printf(\"%d %d\\n\", i, i);\n\
  \            }\n        }\n        for (int i = 0; i < n; i++) {\n            for\
  \ (int j = i + 1; j < n; j++) {\n                if (LTR[i] == RTL[j]) {\n     \
  \               System.out.printf(\"%d %d\\n\", i, j);\n                }\n    \
  \        }\n        }\n        return 0;"
- "        // Your code goes here.\n        // Imagine a road that's a perfectly straight\
  \ infinitely long line.\n        // n cars are driving left to right;  simultaneously,\
  \ a different set of n cars\n        // are driving right to left.   The two sets\
  \ of cars start out being very far from\n        // each other.  All cars move in\
  \ the same speed.  Two cars are said to collide\n        // when a car that's moving\
  \ left to right hits a car that's moving right to left.\n        // However, the\
  \ cars are infinitely sturdy and strong; as a result, they continue moving\n   \
  \     // in their trajectory as if they did not collide.\n        // This function\
  \ outputs the number of such collisions.\n        //\n        // You should write\
  \ the tests first.  These tests should be very simple.\n        //\n        // Sample\
  \ tests:\n        //    carRaceCollision(0) returns 0.\n        //    carRaceCollision(1)\
  \ returns 0.\n        //    carRaceCollision(2) returns 1.\n        //    carRaceCollision(3)\
  \ returns 3.\n        //    carRaceCollision(4) returns 6.\n        //    carRaceCollision(5)\
  \ returns 10.\n        //    carRaceCollision(6) returns 15.\n        //    carRaceCollision(7)\
  \ returns 21.\n        //    carRaceCollision(8) returns 28.\n        //    carRaceCollision(9)\
  \ returns 36.\n        //    carRaceCollision(10) returns 45.\n        //    carRaceCollision(11)\
  \ returns 55.\n        //    carRaceCollision(12) returns 66.\n        //    carRaceCollision(13)\
  \ returns 78.\n        //    carRaceCollision(14) returns 91.\n        //    carRaceCollision(15)\
  \ returns 105.\n        //    carRaceCollision(16) returns 120.\n        //    carRaceCollision(17)\
  \ returns 136.\n        //    carRaceCollision(18) returns 153.\n        //    carRaceCollision(19)\
  \ returns 171.\n        //    carRaceCollision(20) returns 190.\n        //    carRaceCollision(21)\
  \ returns 210.\n        //    carRaceCollision(22) returns 231.\n        //    carRaceColl"
- "        int result = 0;\n        // result = 2 + 5 + 8 + 11 + ...  + (3*n-1)\n\
  \        result = (3*n-1)*n/2;\n        return result;"
- '        //Fill your code here'
- "        //Let's simulate the motion of these cars.\n        //We'll represent a\
  \ car's state as a Pair:\n        //The first element will be an integer between\
  \ 1 and n\n        //indicating which car it is, and the second element\n      \
  \  //will be an integer indicating the distance traveled\n        //by the car.\n\
  \        //Cars driving right to left will have a negative distance.\n        //At\
  \ time t=0, the n cars driving left to right will have\n        //distances 0,1,2,3,...n-1.\n\
  \        //The n cars driving right to left will have distances\n        //n-1,-(n-1),-(n-2),-(n-3),...,-1.\n\
  \        //For example, if n=4, then we have the following\n        //states for\
  \ the cars:\n        //(1,0),(2,1),(3,2),(4,3),(4,-3),(3,-2),(2,-1),(1,-0)\n   \
  \     //The cars move in a cycle.  The left-to-right cars move\n        //distance\
  \ 1 per cycle, and the right-to-left cars move\n        //distance 1 per cycle.\
  \  For example, after 2 cycles,\n        //the cars will be in states:\n       \
  \ //(1,2),(2,3),(3,4),(4,5),(4,-1),(3,-2),(2,-3),(1,-2)\n        //Again, the cars\
  \ move in a cycle.  The left-to-right cars move\n        //distance 1 per cycle,\
  \ and the right-to-left cars move\n        //distance 1 per cycle.  For example,\
  \ after 2 cycles,\n        //the cars will be in states:\n        //(1,4),(2,5),(3,6),(4,7),(4,-1),(3,-2),(2,-3),(1,-2)\n\
  \        //We stop when a car's distance from the origin is >=n.\n        //At this\
  \ point, the car has completed a complete cycle,\n        //and the car's distance\
  \ from the origin is zero.\n        //At this point, we could stop and count the\
  \ number of collisions.\n        //However, for the sake of"
- '        return n;'
- '        return 0;'
- '        return 0;'
- "        int collisions = 0;\n        List<Pair<Integer, Integer>> cars = new ArrayList<>();\n\
  \        Random rand = new Random();\n        int SIZE = 10000000;\n\n        //\
  \ Populate the list of cars.\n        for (int i = 0; i < n; i++) {\n          \
  \  int left = rand.nextInt(SIZE*2);\n            int right = left + SIZE;\n    \
  \        cars.add(new Pair<>(left, right));\n        }\n\n        // Sort the left-to-right\
  \ cars.\n        Collections.sort(cars, new Comparator<Pair<Integer, Integer>>()\
  \ {\n            @Override\n            public int compare(Pair<Integer, Integer>\
  \ o1, Pair<Integer, Integer> o2) {\n                return o1.getValue0().compareTo(o2.getValue0());\n\
  \            }\n        });\n\n        // Now go through the list of cars and compare\
  \ them with each other.\n        // The idea is that we keep an index of which cars\
  \ have collided with the current car.\n        // At the end of the loop, we can\
  \ just add the size of the list to collisions.\n        int index = 0;\n       \
  \ for (int i = 0; i < n; i++) {\n            Pair<Integer, Integer> car = cars.get(i);\n\
  \            for (int j = index; j < n; j++) {\n                Pair<Integer, Integer>\
  \ temp = cars.get(j);\n                if (temp.getValue1() < car.getValue0()) {\n\
  \                    continue;\n                }\n                if (temp.getValue0()\
  \ > car.getValue1()) {\n                    break;\n                }\n        \
  \        index++;\n            }\n            collisions += index - i;\n       \
  \ }\n        return collisions;"
- "        long total_collisions = 0;\n        int [] car_1 = new int[n];\n      \
  \  int [] car_2 = new int[n];\n        for (int i = 0; i < n; i++) {\n         \
  \   car_1[i] = i;\n            car_2[i] = n - i - 1;\n        }\n        // System.out.println(Arrays.toString(car_1));\n\
  \        // System.out.println(Arrays.toString(car_2));\n        for (int i = 0;\
  \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (car_1[i]\
  \ == car_2[j]) {\n                    total_collisions++;\n                }\n \
  \           }\n        }\n        return (int) total_collisions;"
- "        // Assume that n is even.\n        if (n % 2 != 0)\n            throw new\
  \ IllegalArgumentException(\"n is not even\");\n        return n * (n - 2);"
- "        // Assume the n cars that are moving left to right are numbered from 0\
  \ to n-1.\n        // Assume the n cars that are moving right to left are numbered\
  \ from 0 to n-1.\n        // Let car i be a car moving left to right with position\
  \ function x(t) = t.\n        // Let car j be a car moving right to left with position\
  \ function x(t) = n-1-t.\n        // Then, car i collides with car j at time t =\
  \ n-1-x(0) = n-1-j.\n        // So, for each collision, we need to add to the result\
  \ the number of cars that are\n        // moving right to left with positions less\
  \ than n-1-i.  This is simply i, since\n        // the car numbering starts from\
  \ 0.\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n         \
  \   result += i;\n        }\n        return result;"
- "        if (n == 0) return 0;\n        int result = 0;\n        int[] left_to_right\
  \ = new int[n];\n        int[] right_to_left = new int[n];\n        for (int i =\
  \ 0; i < n; i++) {\n            left_to_right[i] = i;\n            right_to_left[i]\
  \ = n - i - 1;\n        }\n        for (int i = 0; i < n; i++) {\n            for\
  \ (int j = 0; j < n; j++) {\n                if (right_to_left[j] == left_to_right[i])\
  \ {\n                    result++;\n                }\n            }\n        }\n\
  \        return result;"
- "        // Invariant:\n        // no_of_collisions[i] represents the number of\
  \ collisions before i + 1-th car\n        // moving left to right gets started.\
  \  This will be used to compute the\n        // number of collisions before the\
  \ ith car moving left to right gets started.\n        // Note: no_of_collisions[0]\
  \ = 0\n        int[] no_of_collisions = new int[n];\n        // Note: There are\
  \ n cars moving left to right; let's call these cars\n        // car_1, car_2, ...,\
  \ car_n.  We know that car_1 started first, followed by\n        // car_2 and so\
  \ on.  So the ith car moving left to right started t_i seconds\n        // after\
  \ car_1 started, where t_i = i - 1.\n        // Now, suppose car_i collides with\
  \ car_j moving right to left.  This means\n        // that car_i overtook car_j.\
  \  However, car_i started only t_i seconds\n        // after car_1 started, and\
  \ car_j started only t_j seconds after car_1 started.\n        // Therefore, car_i\
  \ should have overtaken car_j t_i - t_j = i - j seconds\n        // after car_1\
  \ started.  Now, car_i and car_j are infinitely strong, so they\n        // continue\
  \ moving and hence we say that a collision took place.\n        // (Note: if i <\
  \ j, then i - j < 0 and so car_i should have overtaken car_j before\n        //\
  \ car_1 got started.  However, this is impossible.)\n        // Therefore, the total\
  \ number of collisions between the ith car moving left to right\n        // and\
  \ the cars moving right to left is equal to the number of j such that 0 < j < i\
  \ and\n        // i - j = 0.  This is equal to i - 1.\n        for (int i = 1; i\
  \ < n; i++) {\n            no_of_collisions[i] = no_of_collisions[i - 1] + i - 1;\n\
  \        }\n        return no_of_collisions[n - 1];"
- '        return 0;'
- "        // Implement this placeholder.\n        return 0;"
- "        // if n is odd, then the rightmost car collides with the leftmost car.\n\
  \        // if n is even, then there is no collision.\n        if (n % 2 == 1) {\n\
  \            return 1;\n        } else {\n            return 0;\n        }"
- '        return n * (n - 1) / 2;'
- '        return n;'
- "        // We assume that car i moves from i to 2n-i.\n        // car i collides\
  \ with car 2n-i.\n\n        // Thus, the number of collisions is n/2.\n        return\
  \ n/2;"
- "\tint[] carpos = new int[n];\n\t\n\tfor (int i = 0; i < n; i++) {\n\t    carpos[i]\
  \ = 0;\n\t}\n\t\n\tint counter = 0;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t   \
  \ carpos[i]++;\n\t    counter += carpos[i];\n\t}\n\t\n\tint m = n;\n\tint[] carneg\
  \ = new int[m];\n\t\n\tfor (int i = 0; i < m; i++) {\n\t    carneg[i] = 0;\n\t}\n\
  \t\n\tfor (int i = 0; i < m; i++) {\n\t    carneg[i]--;\n\t    counter += carneg[i];\n\
  \t}\n\t\n\treturn counter;"
- "        Map<Integer, Integer> pos = new HashMap<>();\n        for (int i = 0; i\
  \ < n; i++)\n            pos.put(i, i);\n        List<Integer> rev = new ArrayList<>();\n\
  \        for (int i = 0; i < n; i++)\n            rev.add(i);\n        Collections.reverse(rev);\n\
  \        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            for (int\
  \ j = 0; j < n; j++) {\n                int delta = pos.get(i) - pos.get(rev.get(j));\n\
  \                cnt += Math.abs(delta);\n                pos.put(i, i + delta);\n\
  \                pos.put(rev.get(j), rev.get(j) - delta);\n            }\n     \
  \   }\n        return cnt;"
- "        int collisions = 0;\n        // array of length n. each index indicates\
  \ whether or not that car collides\n        boolean [] leftToRight = new boolean[n];\n\
  \        boolean [] rightToLeft = new boolean[n];\n        for (int i = 0; i < n;\
  \ i++) {\n            for (int j = n - 1; j >= 0; j--) {\n                // colliding\
  \ to the left\n                if (leftToRight[i] && rightToLeft[j]) {\n       \
  \             collisions++;\n                }\n                // colliding to\
  \ the right\n                else if (rightToLeft[j] && leftToRight[i]) {\n    \
  \                collisions++;\n                }\n            }\n        }\n  \
  \      return collisions;"
- "        // The speed of all cars are irrelevant.\n        // Assume all cars travel\
  \ at the same speed of 1.\n        // Left to right cars:  1, 2, 3, ..., n\n   \
  \     // Right to left cars:  n, n-1, n-2, ..., 1\n        // If the left to right\
  \ car with speed i meets the right to left car with speed j,\n        // then i\
  \ = j.\n        // So, if i < j, then the left to right car with speed i will reach\
  \ the right to left\n        // car with speed j before the left to right car with\
  \ speed j meets the right to left\n        // car with speed i.\n        // So,\
  \ the left to right car with speed i will never meet the right to left car with\n\
  \        // speed j.\n        // So, the left to right car with speed i and the\
  \ right to left car with speed j\n        // never collide.\n        // So, i <\
  \ j never happens.\n        // So, i <= j always happens.\n        // So, there\
  \ is only a collision when i = j.\n        // So, there are n/2 pairs of cars that\
  \ collide.\n        // So, there are n^2/4 collisions.\n        return n * n / 4;"
- "        // Use input n to solve the problem and return the result.\n        //\
  \ If n is 0, there are no cars.  If n is 1, there are no collisions.\n        //\
  \ If n is 2, there's 1 collision.  If n is 3, there are 2 collisions.\n        //\
  \ If n is 4, there are 6 collisions.  And so on.\n        // Now, for the base case.\
  \  If n is 1, just return 0.\n        if (n == 1) {\n            return 0;\n   \
  \     }\n        else {\n            // Now, for the inductive case.  We can solve\
  \ the problem by solving\n            // the same problem recursively.  Let's say\
  \ n is 5.  Then, there are\n            // n-1 collisions between the n-1 cars going\
  \ left to right and the n-1\n            // cars going right to left.  Also, the\
  \ first car going left to right\n            // and the last car going right to\
  \ left would collide.  In other words,\n            // there are n-1 + 1 = n collisions.\
  \  Let's implement this.\n            return carRaceCollision(n-1) + n;\n      \
  \  }"
- "        int collisions = 0;\n        // Type your code here.\n        int[] car1\
  \ = new int[n];\n        int[] car2 = new int[n];\n        int[] pos1 = new int[n];\n\
  \        int[] pos2 = new int[n];\n        for(int i = 0; i < n; i++){\n       \
  \     car1[i] = i;\n            car2[i] = i;\n            pos1[i] = i;\n       \
  \     pos2[i] = n + i;\n        }\n        for(int i = 0; i < n; i++){\n       \
  \     if(pos1[i] == pos2[i])\n                collisions++;\n        }\n       \
  \ return collisions;"
- "        // Assume the infinite line is divided into 1000 units.\n        // Each\
  \ car is said to have a position on this number line.\n        // There are n cars\
  \ going left to right and n cars going right to left.\n        // The problem is\
  \ to find the number of collisions between them.\n        // So, we have n cars\
  \ moving left to right starting at position 0.\n        // There are n cars moving\
  \ right to left starting at position 1000.\n        // We have to find the number\
  \ of collisions.\n        // We can do it through simulation.\n        // Instead\
  \ of 1000 units, we are taking n iterations.\n        // Each unit is a time t.\n\
  \        // A car moving left to right is said to be in a given unit t, if the car\n\
  \        // position is the same as the time t.\n        // A car moving right to\
  \ left is said to be in a given unit t, if the car\n        // position is the same\
  \ as the time -t.\n        // So, a car moving left to right is said to be in a\
  \ given unit t, if the car\n        // position is the same as the time t.\n   \
  \     // A car moving right to left is said to be in a given unit t, if the car\n\
  \        // position is the same as the time 1000 - t.\n        // Since the car\
  \ positions are integers, we can treat this as a discrete\n        // simulation.\n\
  \        // The cars move in discrete steps, according to the time they are in.\n\
  \        // So we can construct a simulation that runs n units of time.\n      \
  \  // At the end of the simulation, we will have the positions of the n cars\n \
  \       // moving right to left, as well as the positions of the n cars moving left\
  \ to right.\n        // So the cars moving left to right will be in units 0, 1,\
  \ 2, ..., n.\n        // The cars moving right to left will be in units 0, 1, 2,\
  \ ..., n.\n        // We have to find the number of collisions between them.\n \
  \       // We can do that by counting the number of times the two arrays have the\
  \ same number in them.\n        // We can do that by constructing a hashtable that\
  \ has the numbers of the array, left to right,\n        // with the value being\
  \ the number of times the car position appears in the array.\n        //"
- "        // O(n) time and O(n) space\n        PriorityQueue<Integer> pqLeft = new\
  \ PriorityQueue<>();\n        PriorityQueue<Integer> pqRight = new PriorityQueue<>();\n\
  \        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            pqLeft.add(i);\n\
  \            pqRight.add(i);\n        }\n        // push cars from left until next\
  \ left car has a higher position than the current\n        // max position of a\
  \ right car.  If the positions are equal, then there is a collision.\n        //\
  \ Do the same for right cars.\n        for (int i = 0; i < n; i++) {\n         \
  \   // first left car has a higher position than the max right car\n           \
  \ if (pqLeft.peek() > pqRight.peek()) {\n                break;\n            }\n\
  \            // positions are equal, so there is a collision\n            if (pqLeft.peek()\
  \ == pqRight.peek()) {\n                cnt++;\n            }\n            pqLeft.poll();\n\
  \        }\n        for (int i = 0; i < n; i++) {\n            // first right car\
  \ has a higher position than the max left car\n            if (pqRight.peek() >\
  \ pqLeft.peek()) {\n                break;\n            }\n            // positions\
  \ are equal, so there is a collision\n            if (pqRight.peek() == pqLeft.peek())\
  \ {\n                cnt++;\n            }\n            pqRight.poll();\n      \
  \  }\n        return cnt;"
- "        HashSet<Integer> h = new HashSet<Integer>();\n        for (int i = 0; i\
  \ < n; i++) {\n            h.add(i);\n        }\n        int ans = 0;\n        for\
  \ (int i = 0; i < n; i++) {\n            int v = n - i - 1;\n            if (h.contains(v))\
  \ {\n                ans++;\n                h.remove(v);\n            }\n     \
  \   }\n        return ans;"
- "        if (n == 0) {\n            return 0;\n        } else {\n            return\
  \ n + carRaceCollision(n - 1);\n        }"
- '        return n * (n - 1) / 2;'
- '        return 2*(n-1)*n;'
- '        return (n * (n - 1)) / 2;'
- "        // Your code goes here.\n        int count = 0;\n        int[] lefttoRight\
  \ = new int[n];\n        int[] righttoLeft = new int[n];\n        for (int i = 0;\
  \ i < n; i++) {\n            lefttoRight[i] = i;\n            righttoLeft[i] = -i;\n\
  \        }\n        Arrays.sort(lefttoRight);\n        Arrays.sort(righttoLeft);\n\
  \        int left = 0;\n        int right = 0;\n        while (left < n && right\
  \ < n) {\n            if (lefttoRight[left] < -righttoLeft[right]) {\n         \
  \       left++;\n            } else if (lefttoRight[left] > -righttoLeft[right])\
  \ {\n                right++;\n            } else {\n                count++;\n\
  \                left++;\n                right++;\n            }\n        }\n \
  \       return count;"
- "        int count = 0;\n        return count;"
- '        return n * (n - 1) / 2;'
- "        Random rand = new Random();\n        int car[] = new int[n];\n        int\
  \ k = 0;\n        for (int i = 0; i < n; i++) {\n            car[i] = rand.nextInt(n)\
  \ + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j\
  \ = i + 1; j < n; j++) {\n                if (car[i] == car[j]) {\n            \
  \        k++;\n                }\n            }\n        }\n        return k;"
- "        if (n < 1) {\n            return 0;\n        }\n        // Create n cars\
  \ moving right to left.\n        // They have the same lane as the cars that are\
  \ moving left to right.\n        // Their starting position on the road is randomized.\n\
  \        // Their speeds are randomized.\n        // The speeds are sampled from\
  \ a uniform distribution.\n        Car[] rlCars = new Car[n];\n        Random rnd\
  \ = new Random();\n        for (int i = 0; i < n; i++) {\n            double speed\
  \ = rnd.nextDouble();\n            int startPos = rnd.nextInt(Integer.MAX_VALUE);\n\
  \            rlCars[i] = new Car(i, startPos, speed, true);\n        }\n       \
  \ // Same for cars that are moving left to right.\n        Car[] lrCars = new Car[n];\n\
  \        for (int i = 0; i < n; i++) {\n            double speed = rnd.nextDouble();\n\
  \            int startPos = rnd.nextInt(Integer.MAX_VALUE);\n            lrCars[i]\
  \ = new Car(i, startPos, speed, false);\n        }\n        // Sort the right to\
  \ left cars by their starting position.\n        Arrays.sort(rlCars, new Comparator<Car>()\
  \ {\n            @Override\n            public int compare(Car c1, Car c2) {\n \
  \               return c1.getStartPos() - c2.getStartPos();\n            }\n   \
  \     });\n        // Sort the left to right cars by their starting position.\n\
  \        Arrays.sort(lrCars, new Comparator<Car>() {\n            @Override\n  \
  \          public int compare(Car c1, Car c2) {\n                return c1.getStartPos()\
  \ - c2.getStartPos();\n            }\n        });\n        // Run a simulation,\
  \ moving the cars.\n        int result = 0;\n        for (int t = 0; t < Integer.MAX_VALUE;\
  \ t++) {\n            for (int i = 0; i < n; i++) {\n                // Check for\
  \ collisions between each pair of cars.\n                if (lrCars[i].getPos(t)\
  \ >= rlCars[i].getPos("
- '        return -1;'
- "        // sample input:\n        // n = 3\n        // carRightToLeft = [2, 3,\
  \ 1]\n        // carLeftToRight = [1, 2, 3]\n        // sample output: 1\n     \
  \   // Explanation: The car #1 is the one that's moving right to left, and it collides\
  \ with the car #1 that's moving left to right\n\n        // carRightToLeft[i] =\
  \ the number of the car that's moving right to left\n        // carLeftToRight[i]\
  \ = the number of the car that's moving left to right\n        // move the arrays\
  \ and return the count of collisions\n        int[] carRightToLeft = new int[n];\n\
  \        int[] carLeftToRight = new int[n];\n        for (int i = 0; i < n; i++)\
  \ {\n            carRightToLeft[i] = i + 1;\n            carLeftToRight[i] = n -\
  \ i;\n        }\n        int count = 0;\n        int i = 0;\n        int j = 0;\n\
  \        while (i < n && j < n) {\n            if (carRightToLeft[i] < carLeftToRight[j])\
  \ {\n                i++;\n            } else if (carRightToLeft[i] > carLeftToRight[j])\
  \ {\n                j++;\n            } else {\n                count++;\n    \
  \            i++;\n                j++;\n            }\n        }\n        return\
  \ count;"
- '        return 0;'
- "        // We will first set up the problem in the form of an array.  We will\n\
  \        // have an array of size 2n.  n of the elements will have a value of 1,\n\
  \        // and the other n elements will have a value of -1.  The 1's will\n  \
  \      // represent cars going right to left, and the -1's will represent cars\n\
  \        // going left to right.\n        int[] arr = new int[2*n];\n        for\
  \ (int i = 0; i < n; i++) {\n            arr[i] = 1;\n        }\n        for (int\
  \ i = n; i < 2*n; i++) {\n            arr[i] = -1;\n        }\n        // Now we\
  \ shuffle the array.  We will use the built-in shuffle function\n        // in the\
  \ java Random class.\n        Random rand = new Random();\n        rand.setSeed(System.currentTimeMillis());\n\
  \        rand.nextInt();\n        for (int i = 0; i < arr.length; i++) {\n     \
  \       int randIndex = rand.nextInt(arr.length);\n            int temp = arr[i];\n\
  \            arr[i] = arr[randIndex];\n            arr[randIndex] = temp;\n    \
  \    }\n        // Now we will simulate the cars driving.  We will loop through\
  \ the array,\n        // and if we find a 1, we will increment the value at that\
  \ index, until\n        // that index has a value of 0.  If we find a -1, we will\
  \ decrement the\n        // value at that index, until that index has a value of\
  \ 0.  If a 1 hits\n        // a -1, it will effectively pass through.  Thus, we\
  \ won't increment a 1\n        // any further if the value at the current index\
  \ is a -1.  Likewise, we\n        // won't decrement a -1 any further if the value\
  \ at the current index is\n        // a 1.  In this way, we will simulate the cars\
  \ passing through each other.\n        // We will keep track of the number of times\
  \ that we've moved a car up or\n        // down.  That number will represent the\
  \ number of cars that were hit.\n        int numCollisions = 0;\n        for (int\
  \ i = 0;"
- "        int r = 0;\n        // One possible solution:\n        // Pair up the cars\
  \ moving in opposite directions.\n        // The number of collisions is equal to\
  \ the number of pairs that are unmatched.\n        // Use the Hungarian algorithm\
  \ to match up the pairs.\n        return r;"
- '        return n;'
- "\t    ArrayList<Integer> positions = new ArrayList<>();\n\t    for (int i = 0;\
  \ i < n; i++) {\n\t\t    positions.add(i);\n\t    }\n\t    int colls = 0;\n\t  \
  \  while (!positions.isEmpty()) {\n\t\t    int leftCar = positions.get(0);\n\t\t\
  \    positions.remove(0);\n\t\t    for (int i = 0; i < positions.size(); i++) {\n\
  \t\t\t    if (positions.get(i) < leftCar) {\n\t\t\t\t    colls++;\n\t\t\t    }\n\
  \t\t    }\n\t    }\n\t    return colls;"
- "        int result = 0;\n        // Feel free to modify it as you wish.\n     \
  \   return result;"
- "        // We represent cars as pairs of (start,end) values.\n        // The first\
  \ car is at position 0 and going right, hence (0,1).\n        // The second car\
  \ is at position n and going left, hence (n,-1).\n        Pair<Integer,Integer>[]\
  \ cars = new Pair[2*n];\n        for (int i=0; i<n; i++) {\n            cars[i]\
  \ = new Pair<Integer,Integer>(0,i+1);\n            cars[i+n] = new Pair<Integer,Integer>(i+1,-1);\n\
  \        }\n        // Sort the cars by their start position;  this way, all cars\
  \ that\n        // start at the same position will be next to each other.\n    \
  \    Arrays.sort(cars, new Comparator<Pair<Integer,Integer>>() {\n            public\
  \ int compare(Pair<Integer,Integer> p1, Pair<Integer,Integer> p2) {\n          \
  \      return p1.getValue0().compareTo(p2.getValue0());\n            }\n       \
  \ });\n        // Now start moving the cars.  Each time two cars meet,\n       \
  \ // decrement the collision counter by one.\n        // There are at most n cars\
  \ that start at the same position.\n        // It takes O(n) time to move them.\n\
  \        int collisions = 0;\n        for (int i=0; i<2*n; i++) {\n            int\
  \ start = cars[i].getValue0();\n            int end = cars[i].getValue1();\n   \
  \         if (start > end) collisions--;\n            else collisions++;\n     \
  \   }\n        return collisions;"
- '        return -1;'
- "        // Fill this in.\n        int count = 0;\n        int[][] arr = new int[n][2];\n\
  \        Random r = new Random();\n        for(int i = 0; i < n; i++) {\n      \
  \      arr[i][0] = r.nextInt(n);\n            arr[i][1] = r.nextInt(n);\n      \
  \  }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++)\
  \ {\n                if(arr[i][0] == arr[j][1]) {\n                    count++;\n\
  \                }\n            }\n        }\n        return count;"
- '        return 0;'
- "        // carPos[i] stores the position of the i'th car.\n        // carLeftToRight[i]\
  \ is true if the i'th car is moving left to right,\n        // false otherwise.\n\
  \        // carPos[i] and carLeftToRight[i] together represent the state of the\
  \ i'th car.\n        int[] carPos = new int[n];\n        boolean[] carLeftToRight\
  \ = new boolean[n];\n        int i;\n        int numCollisions = 0;\n        //\
  \ Returns a random integer in the range [lower, upper].\n        // This function\
  \ is only used for testing purposes.\n        int rand(int lower, int upper) {\n\
  \            return (int)(Math.random() * (upper - lower + 1)) + lower;\n      \
  \  }\n        // Randomly generates the initial states of the n cars.\n        //\
  \ This function is only used for testing purposes.\n        void init(int n) {\n\
  \            for (i = 0; i < n; i++) {\n                carPos[i] = rand(-n, n);\n\
  \                carLeftToRight[i] = Math.random() < 0.5;\n            }\n     \
  \   }\n        // Returns true if the two cars' states represent a collision,\n\
  \        // false otherwise.\n        boolean doCarsCollide(int i, int j) {\n  \
  \          return carPos[i] == carPos[j] && carLeftToRight[i] != carLeftToRight[j];\n\
  \        }\n        // Prints the state of each car.\n        // This function is\
  \ only used for testing purposes.\n        void printState(int n) {\n          \
  \  for (i = 0; i < n; i++) {\n                if (carLeftToRight[i]) {\n       \
  \             System.out.print(\"(\" + carPos[i] + \") \");\n                } else\
  \ {\n                    System.out.print(\"[\" + carPos[i] + \"] \");\n       \
  \         }\n            }\n            System.out.println();\n        }\n     \
  \   // Generates the initial state of the cars.\n        // Replace the code inside\
  \ this function with the code for\n        // generating the initial state of the\
  \ cars.\n        void generateInitialState(int n) {\n            for (i ="
- "        // The order in which the cars collide is totally arbitrary.\n        //\
  \ However, if each car is defined by its starting position,\n        // then it\
  \ is possible to arrange the cars in the order of collision.\n        // So let's\
  \ define the state of each car by its starting position.\n        // Let's say that\
  \ a car at position X is moving right to left.\n        // Let's say that a car\
  \ at position Y is moving left to right.\n        // It is now evident that car\
  \ X collides with car Y if X < Y.\n        // Imagine that the road is a line segment\
  \ [0,1].  It is possible\n        // to think about the cars as being points on\
  \ the line segment.\n        // Then it is evident that if X < Y, then the collision\
  \ X-Y is\n        // equivalent to the intersection of line segments\n        //\
  \ [0,X] and [Y,1].  The length of that intersection is X-Y.\n        // So now the\
  \ problem is to find the sum of pairwise intersections\n        // between line\
  \ segments [0,X] and [Y,1].  This is going to be\n        // equivalent to finding\
  \ the sum of distances between X and Y.\n        // So the solution to the problem\
  \ is the sum of distances between\n        // n points on the line segment [0,1].\
  \  This is known to be equal\n        // to 1 / 6.  In fact, the proof is given\
  \ by the same person who\n        // proved a similar fact about the sum of distances\
  \ between points\n        // in a triangle; so if you were to Google for \"triangle\
  \ inequality\"\n        // you would find a proof that the answer to this question\
  \ is 1 / 6.\n        // However, we will give a proof here.\n        // Let d(X,Y)\
  \ denote the distance between X and Y.\n        // Then the sum of distances between\
  \ the n points is\n        // SUM(X,Y) d(X,Y) where X != Y.\n        // Now let\
  \ n points be denoted by X[1], X[2], ..., X[n].\n        // Then the left hand side\
  \ can be written as\n        // SUM(K) SUM(L) d(X[K],X[L]) where K != L.\n     \
  \   // Now let's use the assumption that the sum of"
- "        int result = 0;\n        // Each car has a location and a direction.\n\
  \        // Left-to-right cars start out at (-100, -100, 1); right-to-left cars\n\
  \        // start out at (100, 100, -1).  Both are very far away from each other,\
  \ and thus\n        // there are no collisions at the beginning.\n        // At\
  \ time t, car at (x, y, d) is at position y + d * t.\n        // For any time t,\
  \ if there's a collision at t, then there's a car from each\n        // group that\
  \ are at the same location and moving towards each other at t.\n        // This\
  \ means the left-to-right car is at (-100, -100, 1) + t * (1, 1, 1) and\n      \
  \  // the right-to-left car is at (100, 100, -1) + t * (-1, -1, -1).\n        //\
  \ These two points are at (0, 0, 0) + t * (0, 0, 0), which is always\n        //\
  \ the origin.  So if the vector between the two cars is the origin,\n        //\
  \ there's a collision.\n        // For example, if the origin is the vector between\
  \ the two cars,\n        // then the two points lie on two different lines, and\
  \ their dot product\n        // must be zero.  Because the left-to-right car has\
  \ speed 1, the left-to-right\n        // car is at (x1, y1, d1) = (-100, -100, 1)\
  \ + t * (1, 1, 1).\n        // Similarly, the right-to-left car is at (x2, y2, d2)\
  \ = (100, 100, -1) + t * (-1, -1, -1).\n        // If their dot product is zero,\
  \ then their difference is zero.\n        // This means (x1 - x2, y1 - y2, d1 -\
  \ d2) = (200, 200, 2) + t * (2, 2, 2) = 0 + t * (0, 0, 0)\n        // must be zero.\
  \  This implies (200, 200, 2) = 0, which is true.\n        // Thus, there is a collision\
  \ at"
- "        int[] movements = new int[n];\n        for (int i = 0; i < n; i++) {\n\
  \            movements[i] = rnd(1, 2);\n        }\n        int collisions = 0;\n\
  \        while (true) {\n            boolean allStop = true;\n            boolean[]\
  \ stopped = new boolean[n];\n            for (int i = 0; i < n; i++) {\n       \
  \         if (movements[i] == 1) {\n                    for (int j = 0; j < n; j++)\
  \ {\n                        if (movements[j] == 2) {\n                        \
  \    collisions++;\n                            stopped[i] = true;\n           \
  \                 stopped[j] = true;\n                        }\n              \
  \      }\n                }\n            }\n            for (int i = 0; i < n; i++)\
  \ {\n                if (!stopped[i]) {\n                    allStop = false;\n\
  \                }\n            }\n            if (allStop) {\n                break;\n\
  \            }\n        }\n        return collisions;"
- "        // Fill in.  Note that this function is pretty easy to solve with pen and\
  \ paper.\n        int num_collisions = 0;\n        //Create a list of all cars from\
  \ the left\n        List<Integer> left_cars = new ArrayList<Integer>();\n      \
  \  for(int i = 0; i < n; i++){\n            left_cars.add(i);\n        }\n     \
  \   //Create a list of all cars from the right\n        List<Integer> right_cars\
  \ = new ArrayList<Integer>();\n        for(int i = 0; i < n; i++){\n           \
  \ right_cars.add(i);\n        }\n        //While there are still cars moving in\
  \ either direction, the two lists are not completely empty\n        while(!left_cars.isEmpty()\
  \ && !right_cars.isEmpty()){\n            //Remove the first car from the left,\
  \ which is the car closest to the origin\n            left_cars.remove(0);\n   \
  \         //Remove the last car from the right, which is the car closest to the\
  \ origin\n            right_cars.remove(right_cars.size() - 1);\n            //Increment\
  \ the number of collisions\n            num_collisions++;\n        }\n        return\
  \ num_collisions;"
- "        PriorityQueue<Integer> leftToRight = new PriorityQueue<>();\n        PriorityQueue<Integer>\
  \ rightToLeft = new PriorityQueue<>();\n        Random r = new Random();\n     \
  \   while (n > 0) {\n            leftToRight.add(r.nextInt(10));\n            rightToLeft.add(r.nextInt(10));\n\
  \            n--;\n        }\n        int count = 0;\n        while (leftToRight.size()\
  \ > 0 && rightToLeft.size() > 0) {\n            int left = leftToRight.poll();\n\
  \            int right = rightToLeft.poll();\n            if (left < right) {\n\
  \                leftToRight.add(left);\n                count++;\n            }\
  \ else {\n                rightToLeft.add(right);\n            }\n        }\n  \
  \      return count;"
- "        int count = 0;\n        //use a set to keep track of the positions\n  \
  \      Set<Integer> left = new HashSet<>();\n        Set<Integer> right = new HashSet<>();\n\
  \        // iterate through each car\n        for (int i = 0; i < n; i++) {\n  \
  \          // each car starts at a random position along the road\n            int\
  \ leftCar = random(0, 10000);\n            int rightCar = random(0, 10000);\n  \
  \          // check if there is a collision\n            // each time a collision\
  \ occurs, update the count by one\n            if (left.contains(rightCar)) count++;\n\
  \            if (right.contains(leftCar)) count++;\n            // add the position\
  \ of the car to the set\n            left.add(leftCar);\n            right.add(rightCar);\n\
  \        }\n        return count;"
- "        int result = 0;\n        // The road is a straight line, and we don't need\
  \ to store all of it.\n        // To store a car, we have to store its position\
  \ and direction.\n        // We use a list for each direction.\n        // The time\
  \ complexity of the following code is O(n^2) since\n        // we use 2 nested for\
  \ loops.\n        ArrayList<Integer> leftToRight = new ArrayList<Integer>();\n \
  \       ArrayList<Integer> rightToLeft = new ArrayList<Integer>();\n        for\
  \ (int i = 0; i < n; i++) {\n            leftToRight.add(0);\n            rightToLeft.add(0);\n\
  \        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j\
  \ < n; j++) {\n                // ith car moving left to right, jth car moving right\
  \ to left\n                if (leftToRight.get(i) + i == rightToLeft.get(j) + j)\
  \ {\n                    result++;\n                }\n            }\n        }\n\
  \        return result;"
- "        // TODO\n        return 0;"
- '        return 0;'
- "\treturn 0;"
- "        Map<Integer,Integer> left = new HashMap<>();\n        Map<Integer,Integer>\
  \ right = new HashMap<>();\n        List<Integer> cars = new ArrayList<>();\n  \
  \      while(n>0) {\n            int carId = (int)(Math.random()*100000);\n    \
  \        left.put(carId,(int)(Math.random()*100000));\n            right.put(carId,(int)(Math.random()*100000));\n\
  \            cars.add(carId);\n            n--;\n        }\n        Map<Integer,Pair<Integer,Integer>>\
  \ carsLeft = new HashMap<>();\n        Map<Integer,Pair<Integer,Integer>> carsRight\
  \ = new HashMap<>();\n        //\n        cars.stream().forEach(c->{\n         \
  \   if(Math.random()>0.5) {\n                carsLeft.put(c,new Pair<>(left.get(c),right.get(c)));\n\
  \            } else {\n                carsRight.put(c,new Pair<>(left.get(c),right.get(c)));\n\
  \            }\n        });\n        for(Map.Entry<Integer,Pair<Integer,Integer>>\
  \ e:carsLeft.entrySet()) {\n            Integer carId = e.getKey();\n          \
  \  Integer l = e.getValue().getValue0();\n            Integer r = e.getValue().getValue1();\n\
  \            for(Map.Entry<Integer,Pair<Integer,Integer>> e1:carsRight.entrySet())\
  \ {\n                Integer carId1 = e1.getKey();\n                Integer l1 =\
  \ e1.getValue().getValue0();\n                Integer r1 = e1.getValue().getValue1();\n\
  \                if(!carId.equals(carId1) &&\n                        !(r<l1 ||\
  \ r1<l)) {\n                    System.out.println(\"Collision between \"+carId+\"\
  \ and \"+carId1);\n                }\n            }\n        }\n        return 0;"
- "        int collisions = 0;\n        int[] leftToRight = new int[n];\n        int[]\
  \ rightToLeft = new int[n];\n        for (int i = 0; i < n; i++) {\n           \
  \ leftToRight[i] = 0;\n            rightToLeft[i] = 0;\n        }\n        boolean[]\
  \ reachedEndLeft = new boolean[n];\n        boolean[] reachedEndRight = new boolean[n];\n\
  \        for (int i = 0; i < n; i++) {\n            reachedEndLeft[i] = false;\n\
  \            reachedEndRight[i] = false;\n        }\n        while (true) {\n  \
  \          for (int i = 0; i < n; i++) {\n                if (!reachedEndLeft[i])\
  \ {\n                    leftToRight[i]++;\n                    if (leftToRight[i]\
  \ == n) {\n                        reachedEndLeft[i] = true;\n                 \
  \   }\n                }\n            }\n            for (int i = 0; i < n; i++)\
  \ {\n                if (!reachedEndRight[i]) {\n                    rightToLeft[i]++;\n\
  \                    if (rightToLeft[i] == n) {\n                        reachedEndRight[i]\
  \ = true;\n                    }\n                }\n            }\n           \
  \ boolean done = true;\n            for (int i = 0; i < n; i++) {\n            \
  \    if (!reachedEndLeft[i] || !reachedEndRight[i]) {\n                    done\
  \ = false;\n                    break;\n                }\n            }\n     \
  \       if (done) {\n                break;\n            }\n            // Check\
  \ if there is any collision.\n            boolean foundCollision = false;\n    \
  \        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++)\
  \ {\n                    if (leftToRight[i] == rightToLeft[j]) {\n             \
  \           foundCollision = true;\n                        break;\n           \
  \         }\n                }\n                if (foundCollision) {\n        \
  \            break;\n                }\n            }\n            if (foundCollision)\
  \ {\n                collisions++;\n            }\n        }\n        return collisions;"
- "        // IMPLEMENTATION RESTRICTION: \n        // You may not use an ArrayList\
  \ or any other collections class to store the locations\n        // of the cars.\
  \  Therefore, you have to solve this problem with arrays alone.\n        // In addition,\
  \ you are not allowed to use any auxiliary space other than the parameter n.\n \
  \       int[] leftToRight = new int[n];\n        int[] rightToLeft = new int[n];\n\
  \        for (int i = 0; i < n; i++) {\n            leftToRight[i] = i;\n      \
  \      rightToLeft[i] = n - i - 1;\n        }\n        return getNumberOfCollisions(leftToRight,\
  \ rightToLeft);"
- '        return 0;'
- "        if (n == 0) return 0;\n        int mid = n / 2;\n        return n % 2 ==\
  \ 0 ? n * n / 4 : n * n / 4 + mid;"
- "        int totalCollisions = 0;\n        Queue<Integer> rightToLeftQueue = new\
  \ LinkedList<>();\n        Queue<Integer> leftToRightQueue = new LinkedList<>();\n\
  \        for (int i = 0; i < n; i++) {\n            rightToLeftQueue.add(i);\n \
  \           leftToRightQueue.add(i);\n        }\n        while (!rightToLeftQueue.isEmpty()\
  \ && !leftToRightQueue.isEmpty()) {\n            int currentRightToLeft = rightToLeftQueue.poll();\n\
  \            int currentLeftToRight = leftToRightQueue.poll();\n            // if\
  \ (!rightToLeftQueue.isEmpty() && !leftToRightQueue.isEmpty()) {\n            if\
  \ (currentRightToLeft > currentLeftToRight) {\n                rightToLeftQueue.add(currentRightToLeft);\n\
  \                leftToRightQueue.add(currentLeftToRight);\n            } else {\n\
  \                totalCollisions++;\n            }\n            // }\n        }\n\
  \        return totalCollisions;"
- "      // We could sort the cars by x, y and speed and then walk the line of cars\n\
  \      // until a collision appears.  This takes O(n log n) time.  However, it is\n\
  \      // sufficient to just look at the endpoints of the car distribution, so we\n\
  \      // can do better.  The endpoints are the two cars with greatest and smallest\
  \ speed\n      // going in opposite directions.  These cars determine the smallest\
  \ time to collision.\n      // Given this smallest time, we can then determine how\
  \ many other cars collide\n      // with the cars of smallest and largest speed.\
  \  For example, say the two cars\n      // of smallest and largest speed collide\
  \ in t time.  That is, the car of smallest\n      // speed travels x in t time,\
  \ and the car of largest speed travels y in t time.\n      // Now, to count the\
  \ number of collisions with these two cars, we need to determine\n      // which\
  \ cars have speeds between x and y.  By sorting the cars by speed, it is\n     \
  \ // easy to do this in linear time.\n      // All in all, this approach is O(n\
  \ log n) time and O(n) space.\n      // In summary, the algorithm is as follows:\n\
  \      //\n      // 1. Sort the cars by speed.\n      // 2. Determine the time to\
  \ collision between the two cars of smallest and largest speed.\n      // 3. Count\
  \ the number of cars between these two speed ranges that collide.\n      // 4. Output\
  \ the results.\n      //\n      // We outline this implementation below.\n     \
  \ //\n      // STEP 1:\n      //\n      //\n      //\n      //\n      //\n     \
  \ //\n      //\n      //\n      //\n      //\n      //\n      //\n      //\n   \
  \   //\n      //\n      //\n      //\n      //\n      //\n      //\n      //\n \
  \     //\n      //\n      //\n      //\n      //\n      //\n      //\n      //\n\
  \      //\n      //\n      //\n      //\n      //\n      //\n      //\n      //\n\
  \      //\n      //\n      //\n      //\n      //\n      //\n      //\n      //\n\
  \      //\n      //\n      //\n      //\n      //\n      //\n      //\n      //"
- '        return 42;'
- "        if (n == 0) return 0;\n        return carRaceCollision(n - 1) + n - 1;"
- "        ArrayList<Tuple2<Double, Double>> rightLeft = new ArrayList<>();\n    \
  \    ArrayList<Tuple2<Double, Double>> leftRight = new ArrayList<>();\n        Random\
  \ random = new Random();\n        for (int i = 0; i < n; i++) {\n            double\
  \ x = random.nextDouble();\n            double v = random.nextDouble();\n      \
  \      leftRight.add(new Tuple2<>(x, v));\n            rightLeft.add(new Tuple2<>(1.0\
  \ - x, -v));\n        }\n        leftRight.sort((a, b) -> a.getValue1().compareTo(b.getValue1()));\n\
  \        rightLeft.sort((a, b) -> a.getValue1().compareTo(b.getValue1()));\n   \
  \     int collision = 0;\n        while (true) {\n            boolean change = false;\n\
  \            for (int i = 0; i < n; i++) {\n                Tuple2<Double, Double>\
  \ right = rightLeft.get(i);\n                Tuple2<Double, Double> left = leftRight.get(i);\n\
  \                if (right.getValue1() <= left.getValue1()) {\n                \
  \    collision++;\n                    rightLeft.remove(i);\n                  \
  \  leftRight.remove(i);\n                    n--;\n                    change =\
  \ true;\n                    break;\n                }\n            }\n        \
  \    if (!change) {\n                break;\n            }\n        }\n        return\
  \ collision;"
- "        // Note the collision will only happen at the middle of the road (zero).\n\
  \        // We can label each car with a pair of number, where the first number\
  \ is\n        // the distance of the car to the right (positive) or to the left\
  \ (negative).\n        // The second number is the speed the car is going.\n   \
  \     // The labels can be anything that uniquely determines the cars.\n       \
  \ // For example, we can use the pair of (1) and (2) as labels.\n        // This\
  \ is equivalent to saying we have four cars:\n        // car 1 moves left to right\
  \ with speed 1.\n        // car 2 moves left to right with speed 2.\n        //\
  \ car 3 moves right to left with speed 1.\n        // car 4 moves right to left\
  \ with speed 2.\n        // Notice car 1 and car 3, and car 2 and car 4, have the\
  \ same speed.\n        // We call them a match.   A match is a pair of cars that\
  \ can collide,\n        // because they are moving at the same speed.\n        //\
  \ The problem is equivalent to finding all the matches.\n        // We can iterate\
  \ over all pairs of cars and check whether they match.\n        // That is, we iterate\
  \ over all pairs of integers from 0 to 2n - 1.\n        // These are two labels\
  \ for two cars.\n        // Then we need to determine whether these two cars match.\n\
  \        // This can be done by using %2 to extract the second number (the speed),\n\
  \        // and using /2 to extract the first number (the distance).\n        //\
  \ The two cars are a match if and only if their speed are the same and\n       \
  \ // the second number's signs are different.\n        int res = 0;\n        for\
  \ (int i = 0; i < 2 * n; i++) {\n            for (int j = i + 1; j < 2 * n; j++)\
  \ {\n                if ((i % 2) == (j % 2) && ((i / 2) * (j / 2)) < 0) {\n    \
  \                res++;\n                }\n            }\n        }\n        return\
  \ res;"
- "        // return 0 if a car does not collide\n        // return 1 if a car collides\n\
  \        // return 2 if we got a hint that the car collided but we do not know yet\n\
  \        int[] rightToLeft = new int[n];\n        Arrays.fill(rightToLeft, 0);\n\
  \        int[] leftToRight = new int[n];\n        Arrays.fill(leftToRight, 0);\n\
  \        int[] arrayOne = new int[n];\n        Arrays.fill(arrayOne, 0);\n     \
  \   int[] arrayTwo = new int[n];\n        Arrays.fill(arrayTwo, 0);\n        int[]\
  \ arrayThree = new int[n];\n        Arrays.fill(arrayThree, 0);\n        int[] arrayFour\
  \ = new int[n];\n        Arrays.fill(arrayFour, 0);\n        int counter = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            int outcome = nextState(rightToLeft,\
  \ leftToRight, arrayOne, arrayTwo, arrayThree, arrayFour);\n            if (outcome\
  \ == 1) {\n                counter++;\n            }\n        }\n        return\
  \ counter;"
- "        // input: an integer n\n        // output: an integer representing the\
  \ number of collisions\n\n        // if n = 1, then there are 0 collisions\n   \
  \     if (n == 1) return 0;\n\n        // if n = 2, then there are 1 collision\n\
  \        if (n == 2) return 1;\n\n        // if n > 2, then there are n! - (n-1)!\
  \ - (n-2)! - (n-3)! - (n-4)! - ... - 1 collisions\n        if (n > 2) {\n      \
  \      int collisions = factorial(n);\n            for (int x = 1; x < n; x++) {\n\
  \                collisions -= factorial(n - x);\n            }\n            return\
  \ collisions;\n        }\n\n        return 0;"
- '        return (n*(n-1))/2;'
- "        assert(n > 0);\n        // The left2right and right2left arrays store cars\
  \ moving left to right\n        // and cars moving right to left respectively. \
  \ Each car has an id\n        // and a position.  The number of elements in left2right\
  \ and right2left\n        // is at most 2n.  The id of cars in left2right is in\
  \ the range [0..n-1].\n        // The id of cars in right2left is in the range [n..2n-1].\n\
  \        // position of a car is never negative.\n        // The code below returns\
  \ the number of collisions.\n        int[] left2right = new int[2*n];\n        int[]\
  \ right2left = new int[2*n];\n        return -1;"
- '        return 0;'
- '        return 0;'
- "        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for (int i =\
  \ 0; i < n; i++) {\n            int val = (n - i) * (i + 1);\n            q.add(val);\n\
  \        }\n        return q.stream().mapToInt(x -> x).sum();"
- "        if (n < 1)\n            return 0;\n        int collisions = 0;\n      \
  \  List<Pair<Integer, Integer>> leftToRight = new ArrayList<>();\n        List<Pair<Integer,\
  \ Integer>> rightToLeft = new ArrayList<>();\n        for (int i = 0; i < n; i++)\
  \ {\n            leftToRight.add(new Pair<>(i,i));\n            rightToLeft.add(new\
  \ Pair<>(i,-i));\n        }\n        while (!leftToRight.isEmpty() && !rightToLeft.isEmpty())\
  \ {\n            int leftToRightFront = leftToRight.get(0).getValue0();\n      \
  \      int rightToLeftFront = rightToLeft.get(0).getValue0();\n            if (leftToRightFront\
  \ < rightToLeftFront) {\n                // cars are moving in the same direction\n\
  \                leftToRight.remove(0);\n            } else if (leftToRightFront\
  \ > rightToLeftFront) {\n                // no collision;  cars continue moving\n\
  \                rightToLeft.remove(0);\n            } else {\n                //\
  \ collision;  cars continue moving\n                leftToRight.remove(0);\n   \
  \             rightToLeft.remove(0);\n                collisions++;\n          \
  \  }\n        }\n        return collisions;"
- "        //Initialize the two sets of cars.  We'll use a binary tree to\n      \
  \  // keep track of the set of cars driving left to right;  a binary\n        //\
  \ tree to keep track of the set of cars driving right to left;\n        // and a\
  \ third binary tree to keep track of the set of collisions\n        // that have\
  \ occurred.  That way, we can get an O(n log n) solution.\n        TreeSet<Integer>\
  \ leftRight = new TreeSet<Integer>();\n        TreeSet<Integer> rightLeft = new\
  \ TreeSet<Integer>();\n        TreeSet<Integer> collisions = new TreeSet<Integer>();\n\
  \        int collisionsCount = 0;\n        //The two sets of cars start out being\
  \ very far from each other.\n        //Since they drive in the same speed, they'll\
  \ never collide.\n        if (n == 0) {\n            return 0;\n        }\n    \
  \    //The first set of cars drives left to right at position 1, 2, 3, ..., n\n\
  \        //The second set of cars drives right to left at position n, n-1, n-2,\
  \ ..., 1\n        for (int i = 1; i <= n; i++) {\n            leftRight.add(i);\n\
  \            rightLeft.add(n - i + 1);\n        }\n        while (leftRight.size()\
  \ > 0 && rightLeft.size() > 0) {\n            //The car that drives left to right\
  \ is at position leftRight.first()\n            //The car that drives right to left\
  \ is at position rightLeft.first()\n            //If the two cars are at the same\
  \ position, then we have a collision.\n            //Otherwise, we move the two\
  \ cars forward by one place.\n            if (leftRight.first() == rightLeft.first())\
  \ {\n                collisions.add(leftRight.first());\n                collisionsCount++;\n\
  \                leftRight.remove(leftRight.first());\n                rightLeft.remove(rightLeft.first());\n\
  \            } else {\n                leftRight.add(leftRight.first() + 1);\n \
  \               rightLeft.add(rightLeft.first() - 1);\n                leftRight.remove(leftRight.first());\n\
  \                rightLeft.remove(rightLeft.first());\n            }\n        }\n\
  \        return collisionsCount;\n   "
- "        // ------ Please complete this function. Don't forget to run this program\
  \ ------\n        // ------ to test your implementation. When you are confident\
  \ with your ------\n        // ------ solution, submit it to the staff. ------"
- "        // leftToRightArray is an array of length n and contains the position of\n\
  \        // the cars that are moving left to right.  If a car is at position x,\
  \ then\n        // it is either moving left to right or right to left (this function\
  \ will\n        // determine which one), and it will continue to drive until it\
  \ either reaches\n        // position 100000 or collides with another car.\n   \
  \     int[] leftToRightArray = new int[n];\n        for (int i = 0; i < n; i++)\n\
  \            leftToRightArray[i] = 1 + 100000 * i / n;\n        // rightToLeftArray\
  \ is the same as leftToRightArray, but for the cars that are moving\n        //\
  \ right to left.\n        int[] rightToLeftArray = new int[n];\n        for (int\
  \ i = 0; i < n; i++)\n            rightToLeftArray[i] = 100000 - leftToRightArray[i];\n\
  \        // driverDirectionArray is an array of length n.  For each car, \n    \
  \    // if driverDirectionArray[i] = 1, then it means that car i is moving left\
  \ to right.\n        // If driverDirectionArray[i] = -1, then it means that car\
  \ i is moving right to left.\n        int[] driverDirectionArray = new int[n];\n\
  \        for (int i = 0; i < n; i++)\n            driverDirectionArray[i] = (i %\
  \ 2 == 0) ? 1 : -1;\n        // positionArray is an array of length n.  For each\
  \ car, positionArray[i]\n        // is the current position of that car.\n     \
  \   int[] positionArray = new int[n];\n        for (int i = 0; i < n; i++)\n   \
  \         positionArray[i] = leftToRightArray[i];\n        int collisionCount =\
  \ 0;\n        for (int second = 0; second < 100000; second++) {\n            for\
  \ (int i = 0; i < n; i++) {\n                positionArray[i] += driverDirectionArray[i];\n\
  \                if (positionArray[i] == 100000)\n                    positionArray[i]\
  \ = -1;\n            }\n            for (int i = 0; i < n; i"
- "        // Assume the line is a real number line.\n        // Assume all cars start\
  \ at the same speed, and they all move at the same speed.\n        // Assume the\
  \ n cars moving left to right are labeled 1 to n.\n        // Assume the n cars\
  \ moving right to left are labeled n+1 to 2n.\n        // Assume car i going left\
  \ to right starts at position i and moves at speed 1 (left to right).\n        //\
  \ Assume car i going right to left starts at position -i and moves at speed 1 (right\
  \ to left).\n        // For example, if n = 1, the cars are:\n        //     Car\
  \ 1, starting at 1, moving left to right\n        //     Car 2, starting at -1,\
  \ moving right to left\n        // Then, the two cars collide at position 0.\n \
  \       // Create a method called carRaceCollision that returns the number of collisions.\n\
  \        // Hint: there is an O(n) solution.\n        // run your method on test\
  \ cases 1 to 100, and plot your results.\n        int collisions = 0;\n        ArrayList<Integer>\
  \ leftRight = new ArrayList<Integer>();\n        ArrayList<Integer> rightLeft =\
  \ new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) {\n          \
  \  leftRight.add(i);\n            rightLeft.add(-i);\n        }\n        int i =\
  \ 0;\n        int j = 0;\n        while (i < leftRight.size() && j < rightLeft.size())\
  \ {\n            if (leftRight.get(i) < rightLeft.get(j)) {\n                i++;\n\
  \            } else if (leftRight.get(i) > rightLeft.get(j)) {\n               \
  \ j++;\n            } else {\n                collisions++;\n                i++;\n\
  \                j++;\n            }\n        }\n        return collisions;"
- '      return 0;'
- "        int[] leftToRight = new int[n];\n        int[] rightToLeft = new int[n];\n\
  \        for (int i = 0; i < n; i++) {\n            leftToRight[i] = i;\n      \
  \      rightToLeft[i] = i;\n        }\n        Arrays.sort(leftToRight);\n     \
  \   Arrays.sort(rightToLeft);\n        int ret = 0;\n        for (int i = 0; i <\
  \ n; i++) {\n            if (leftToRight[i] == rightToLeft[i]) {\n             \
  \   ret++;\n            }\n        }\n        return ret;"
- "        // The goal is to find the closest pairs of cars.\n        // To make it\
  \ easier, we'll first use the \"plane sweeping\" technique.\n        // We'll sort\
  \ the cars by their starting positions.  The cars going left to right\n        //\
  \ will be sorted by their starting position.  The cars going right to left\n   \
  \     // will be sorted by their starting position.  We'll place the cars on\n \
  \       // two straight lines perpendicular to the road.  We'll do the sorting\n\
  \        // by the starting position on these perpendicular lines.\n        // Now\
  \ it's easier to find the closest pair.\n        // (Why?)\n        return 0;"
- "        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int\
  \ j = 0; j < n; j++)\n                if (i < j)\n                    ans++;\n \
  \       return ans;"
- "        int ret = 0;\n        // TODO: Your code here.  You may not use a custom\
  \ comparator.\n        ret = ((n * (n + 1)) / 2);\n        return ret;"
- '        return -1;'
- "        // YOUR CODE GOES HERE\n        return 0;"
- "        // Let's call L + and L - the set of cars moving left to right and\n  \
  \      // right to left, respectively.  The cars in L + have positions x_1, x_2,\
  \ ..., x_n\n        // where x_1 < x_2 < ... < x_n.  Similarly, the cars in L -\
  \ have positions\n        // y_1, y_2, ..., y_n, where y_1 < y_2 < ... < y_n.\n\
  \        // If a car in L + is at position x_i and a car in L - is at position y_j,\n\
  \        // then they collide if x_i > y_j.  Furthermore, they collide at time x_i\
  \ - y_j.\n        // That is, they collide once they are at least (x_i - y_j) units\
  \ away from the center.\n        // The way to think about this is that once y_j\
  \ reaches x_i, y_j can no longer\n        // collide with any other cars in L +.\n\
  \        // The easiest way to answer this question is to iterate through all cars\n\
  \        // in L + and L -, and for each car, keep track of the number of cars that\n\
  \        // collided with it.\n        int[] left_cars = new int[n];\n        int[]\
  \ right_cars = new int[n];\n        for (int i = 0; i < n; i++) {\n            left_cars[i]\
  \ = i;\n            right_cars[i] = i;\n        }\n        Arrays.sort(left_cars);\n\
  \        Arrays.sort(right_cars);\n        int[] left_ans = new int[n];\n      \
  \  int[] right_ans = new int[n];\n        int ptr = 0;\n        for (int i = 0;\
  \ i < n; i++) {\n            while (ptr < n && right_cars[ptr] < left_cars[i]) {\n\
  \                ptr++;\n            }\n            left_ans[i] = n - ptr;\n   \
  \     }\n        ptr = 0;\n        for (int i = 0; i < n; i++) {\n            while\
  \ (ptr < n && left_cars[ptr] < right_cars[i]) {\n                ptr++;"
- "        // Use a data structure to store the cars' movement locations.\n      \
  \  // This can be done with a two-element array of integers,\n        // where each\
  \ car's position is in the array at the array index of the car's id.\n        //\
  \ Car 0's position is array[0], car 1's position is array[1], etc.\n        // The\
  \ goal of this problem is to optimize the time complexity of this function.\n  \
  \      //\n        // Example: If n is 8 and car id 0 is at position 10, car id\
  \ 1 is at position 12,\n        // car id 2 is at position 5, etc, then the array\
  \ is:\n        // array[0] = 10\n        // array[1] = 12\n        // array[2] =\
  \ 5\n        // array[3] = 9\n        // array[4] = 18\n        // array[5] = 21\n\
  \        // array[6] = 6\n        // array[7] = 2\n        //\n        // Complete\
  \ the code below\n        //\n        // Below is an example of one correct function\
  \ signature.\n        // Since the return type is Integer,\n        // you can return\
  \ any integer as the output of this function, as long as\n        // the number\
  \ of collisions returned is correct.\n        //\n        // Hint: You may use the\
  \ java.util package\n        //\n        //\n        // Sort the cars' positions:\n\
  \        // 5, 6, 9, 10, 12, 18, 21, 2\n        //\n        // Iterate through the\
  \ cars one by one:\n        // 5, 6, 9, 10, 12, 18, 21, 2\n        //  |  ,  | \
  \  |   |   |   |   |\n        //  |  ,  |   |   |   |   |   \\  no collision with\
  \ car 7\n        //  |  ,  |   |   |   |   |\n        //  |  ,  |   |   |   |  \
  \ \\  no collision with car 6\n        //  |  ,  |   |   |   |\n        //  |  ,\
  \  |   |   |   \\  no collision with car 5\n        //  |  ,  |   |   |\n      \
  \  //  |  ,  |   |   \\  collision with car 4"
- '        return (int) Math.pow(n, 2);'
- "        // i = 0, j = n-1 --> i = 1, j = n-2;   i = 2, j = n-3;\n        // i =\
  \ 0, j = n-1 --> i = 1, j = n-2;   i = 2, j = n-3;  i = 3, j = n-4;\n        //\
  \ i = 0, j = n-1 --> i = 1, j = n-2;   i = 2, j = n-3;  i = 3, j = n-4;  i = 4,\
  \ j = n-5;\n        // i = 0, j = n-1 --> i = 1, j = n-2;   i = 2, j = n-3;  i =\
  \ 3, j = n-4;  i = 4, j = n-5;  i = 5, j = n-6;\n        // i = 0, j = n-1 --> i\
  \ = 1, j = n-2;   i = 2, j = n-3;  i = 3, j = n-4;  i = 4, j = n-5;  i = 5, j =\
  \ n-6;  i = 6, j = n-7;\n        // i = 0, j = n-1 --> i = 1, j = n-2;   i = 2,\
  \ j = n-3;  i = 3, j = n-4;  i = 4, j = n-5;  i = 5, j = n-6;  i = 6, j = n-7; \
  \ i = 7, j = n-8;\n        // i = 0, j = n-1 --> i = 1, j = n-2;   i = 2, j = n-3;\
  \  i = 3, j = n-4;  i = 4, j = n-5;  i = 5, j = n-6;  i = 6, j = n-7;  i = 7, j\
  \ = n-8;  i = 8, j = n-9;\n        // i = 0, j = n-1 --> i = 1, j = n-2;   i = 2,\
  \ j = n-3;  i = 3, j = n-"
- '        return n;'
- '        return n*(n-1)/2;'
- "        int coll = 0;\n        for (int i = 0; i < n; i++) {\n            for (int\
  \ j = n - 1; j >= 0; j--) {\n                if (i == j) {\n                   \
  \ coll++;\n                }\n            }\n        }\n        return coll;"
- '        return n * (n - 1) / 2;'
- "        if (n == 0) return 0;\n        int count = 0;\n        for (int i = 0;\
  \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i\
  \ == j) {\n                    count++;\n                }\n            }\n    \
  \    }\n        return count;"
- "        int result = 0;\n        // ---------- Start of your code ----------\n\
  \        result = (n*(n-1))/2;\n        // ----------- End of your code ------------\n\
  \        return result;"
- "        int result = 0;\n        return result;"
- "        // declare a counter  -- we will use it to count the number of collisions\n\
  \        int counter = 0;\n        // create a queue that will hold the positions\
  \ of the cars that are moving left to right\n        // IMPORTANT:  when adding\
  \ cars to this queue, make sure that you add the cars in order of their\n      \
  \  // arrival time.  In other words, use a PriorityQueue with a custom comparator\
  \ that uses a car's arrival\n        // time to determine the order in which the\
  \ cars are removed from the queue.\n        PriorityQueue<Car> q = new PriorityQueue<Car>(new\
  \ CarComparator());\n        // create a set that will hold the positions of the\
  \ cars that are moving right to left\n        // IMPORTANT:  when adding cars to\
  \ this set, make sure that you use a custom comparator that uses a car's arrival\n\
  \        // time to determine if two cars are equal.\n        HashSet<Car> s = new\
  \ HashSet<Car>(new CarComparator());\n        // add the n cars that are moving\
  \ left to right to the queue\n        for (int i = 0; i < n; i++) {\n          \
  \  q.add(new Car(i,true));\n        }\n        // add the n cars that are moving\
  \ right to left to the set\n        for (int i = 0; i < n; i++) {\n            s.add(new\
  \ Car(i,false));\n        }\n        // while there are cars in both the queue and\
  \ the set\n        while (!q.isEmpty() && !s.isEmpty()) {\n            // get the\
  \ car at the front of the queue\n            Car c = q.peek();\n            // remove\
  \ the car at the front of the queue\n            q.remove();\n            // get\
  \ the car that's identical to the car at the front of the queue (same arrival time)\n\
  \            // from the set\n            Car c2 = new Car(c.arrivalTime,false);\n\
  \            // if the car was in the set\n            if (s.contains(c2)) {\n \
  \               // remove the car from the set\n                s.remove(c2);\n\
  \                // increment the counter\n                counter++;\n        \
  \    }\n        }\n        // return the counter\n        return counter;"
- "        // If an odd number of cars are moving in the same direction, then no collisions.\n\
  \        // Note: for this problem, if all cars are moving in the same direction,\
  \ then\n        // no collisions.  However, if an odd number of cars are moving\
  \ in the same direction,\n        // then there are collisions.\n        if (n %\
  \ 2 == 1) return 0;\n        // we can image the cars being in a circle;  first\
  \ car is the 0th position,\n        // second car is the 1st position, third car\
  \ is the 2nd position, and so on.\n        //\n        // We have n cars moving\
  \ counter-clockwise and n cars moving clockwise.\n        // The cars move in the\
  \ same speed.  The cars are also very sturdy and\n        // strong, so when they\
  \ collide, they continue moving.\n        //\n        // This problem is equivalent\
  \ to finding the number of people who will\n        // have to switch seats if n\
  \ people move counter-clockwise in a circle\n        // and n people move clockwise\
  \ in a circle.\n        //\n        // For example, if there are 4 people, then\
  \ the 0th person moves\n        // counter-clockwise and the 2nd person moves clockwise.\
  \  The 1st\n        // person moves counter-clockwise and the 3rd person moves clockwise.\n\
  \        //\n        // So, the 0th person and the 2nd person will switch seats.\
  \  The 1st\n        // person and the 3rd person will switch seats.  That's 2 people\
  \ who\n        // will switch seats.\n        //\n        // If there are 5 people,\
  \ then the 0th person moves counter-clockwise,\n        // the 2nd person moves\
  \ clockwise, the 4th person moves counter-clockwise,\n        // and the 1st person\
  \ and the 3rd person move clockwise.\n        //\n        // So, the 0th person\
  \ and the 2nd person will switch seats.  The 4th\n        // person and the 1st\
  \ person will switch seats.  That's 2 people who\n        // will switch seats.\n\
  \        //\n        // For example, if there are 6 people, then the 0th person\
  \ moves\n        // counter-clockwise, the 3rd person moves clockwise, the 5th person\n\
  \        // moves counter-clockwise, and the 1st person, the 2"
- "        // TODO: Implement this function.\n        int collisions = 0;\n      \
  \  int[] leftToRight = new int[n];\n        int[] rightToLeft = new int[n];\n  \
  \      for (int i = 0; i < n; i++) {\n            leftToRight[i] = i;\n        \
  \    rightToLeft[i] = n + i;\n        }\n        for (int i = 0; i < n; i++) {\n\
  \            for (int j = 0; j < n; j++) {\n                if (leftToRight[i] ==\
  \ rightToLeft[j]) {\n                    collisions++;\n                }\n    \
  \        }\n        }\n        return collisions;"
- "        int result = 0;\n        // put your code here\n        // Hint: you need\
  \ a polynomial-time algorithm.\n        // You can assume that n is very large.\n\
  \        return result;"
- "        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n        \
  \    a[i] = i;\n        }\n        int[] b = new int[n];\n        for (int i = 0;\
  \ i < n; i++) {\n            b[i] = n - i - 1;\n        }\n        int coll = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\
  \ {\n                if (a[i] == b[j]) {\n                    coll++;\n        \
  \        }\n            }\n        }\n        return coll;"
- "        if (n < 2) {\n            return 0;\n        }\n        int num_collisions\
  \ = 0;\n        // NOTE: The following line is optimized from O(n^2) to O(n).\n\
  \        num_collisions = n * (n - 1) / 2;\n        return num_collisions;"
- "        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for\
  \ (int j = n - 1; j >= 0; j--) {\n                if (i == j) count++;\n       \
  \     }\n        }\n        return count;"
- "        // STUDENTS: FILL IN CODE HERE\n    \tint numberOfCollisions = 0;\n   \
  \ \t\n    \t//TODO\n        return numberOfCollisions;"
- "        // Note:  if you want to use helper methods, such as carRaceCollisionHelper,\n\
  \        // this main method will not call them.  This means you should submit your\n\
  \        // solution with carRaceCollisionHelper.  However, if you do so, you will\n\
  \        // be flagged by the cheating system.  Thus, you should write your solution\n\
  \        // entirely in this main method.\n        int count = 0;\n        Set<Integer>\
  \ left = new HashSet<>();\n        Set<Integer> right = new HashSet<>();\n     \
  \   for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n \
  \               if (i + j == n) {\n                    left.add(i);\n          \
  \          right.add(j);\n                }\n            }\n        }\n        for\
  \ (int l : left) {\n            for (int r : right) {\n                if (l ==\
  \ r) {\n                    count++;\n                }\n            }\n       \
  \ }\n        return count;"
- "        if (n == 0) return 0;\n        int[] left = new int[n];\n        int[]\
  \ right = new int[n];\n        for (int i = 0; i < n; i++) {\n            left[i]\
  \ = n - i;\n            right[i] = i + 1;\n        }\n        int count = 0;\n \
  \       for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n\
  \                if (left[i] == right[j]) count++;\n            }\n        }\n \
  \       return count;"
- "        if (n < 1) return 0;\n        int[] a = new int[n];\n        int[] b =\
  \ new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = Math.abs(n\
  \ - i);\n            b[i] = i + 1;\n        }\n        Arrays.sort(a);\n       \
  \ Arrays.sort(b);\n        int i = 0;\n        int j = 0;\n        int ans = 0;\n\
  \        while (i < n && j < n) {\n            if (a[i] < b[j]) {\n            \
  \    i++;\n            } else if (a[i] > b[j]) {\n                j++;\n       \
  \     } else {\n                ans++;\n                i++;\n                j++;\n\
  \            }\n        }\n        return ans;"
- "        // Let's say the cars are moving at a speed of 1 meter per second.\n  \
  \      // Let's call the right-to-left cars R1, R2, R3, ... and the left-to-right\
  \ cars L1, L2, L3, ...\n        // Let's say Ri starts at location i.  Similarly,\
  \ let's say Li starts at location i.\n        // Assume that Ri is moving at the\
  \ speed of 1 meter per second to the left.\n        // Assume that Li is moving\
  \ at the speed of 1 meter per second to the right.\n        // Let's say Ri is at\
  \ location x.  Similarly, let's say Li is at location y.\n        // Let's say Ri\
  \ and Li collide at moment t.\n        // We know that x-t = y+t.\n        // We\
  \ know that x-y = 2*i.\n        // We know that t = i.\n        // Therefore, we\
  \ have the number of collisions n*(n-1)/2.\n        // Because the numbers are so\
  \ small (n <= 10^5), the function below computes\n        // the value without using\
  \ BigInteger.\n        return n*(n-1)/2;"
- "        int output = 0;\n        // ADD YOUR CODE HERE\n        return output;"
- "        int collisions = 0;\n        // your code goes here\n        for (int i\
  \ = 0; i < n; i++) {\n            for (int j = n; j > 0; j--) {\n              \
  \  if (i == j) {\n                    collisions++;\n                }\n       \
  \     }\n        }\n        return collisions;"
- "        // Write your code here.\n        int collisions = 0;\n        Car[] cars\
  \ = new Car[n];\n        for (int i = 0; i < n; i++) {\n            cars[i] = new\
  \ Car(i + 1, true);\n        }\n        for (int i = 0; i < n; i++) {\n        \
  \    cars[i].move(1);\n            for (int j = 0; j < n; j++) {\n             \
  \   if (cars[i].getId() < cars[j].getId() && cars[i].getDirection() == false &&\
  \ cars[j].getDirection() == true) {\n                    collisions++;\n       \
  \         }\n            }\n        }\n        return collisions;"
- '        return 3;'
- '        return 0;'
- "        // ask the interviewer about the speed and the gap between the cars\n \
  \       if (n < 1) return 0;\n\n        int[] forward = new int[n];\n        int[]\
  \ backward = new int[n];\n\n        // assume all cars speed is 1\n        for (int\
  \ i = 0; i < n; i++) {\n            forward[i] = i + 1;\n            backward[i]\
  \ = n - i;\n        }\n\n        int count = 0;\n        for (int i = 0; i < n;\
  \ i++) {\n            for (int j = 0; j < n; j++) {\n                if (forward[i]\
  \ == backward[j]) {\n                    count++;\n                }\n         \
  \   }\n        }\n\n        return count;"
- "      // for instance, if n = 0, then it does not make sense.  That case is not\
  \ considered here.\n      if (n < 1) {\n        return 0;\n      }\n      // computes\
  \ the number of car pairs that collide.\n      // I wish I could do this in one\
  \ expression.\n      // I couldn't come up with one.\n      return (((2 * n) - 1)\
  \ * n) / 2;"
- "        Random r = new Random();\n        // The locations of the cars starting\
  \ from the left.\n        int[] left = new int[n];\n        for (int i = 0; i <\
  \ n; i++) {\n            left[i] = r.nextInt(100000);\n        }\n        // The\
  \ locations of the cars starting from the right.\n        int[] right = new int[n];\n\
  \        for (int i = 0; i < n; i++) {\n            right[i] = r.nextInt(100000);\n\
  \        }\n        // Sort the two sets of cars by location.\n        Arrays.sort(left);\n\
  \        Arrays.sort(right);\n        // Create a new array indicating the direction\
  \ of movement of each car.\n        // In the case of the cars on the left, this\
  \ array indicates that they\n        // are moving right to left.\n        int[]\
  \ directions = new int[n];\n        for (int i = 0; i < n; i++) {\n            directions[i]\
  \ = -1;\n        }\n        // Perform a merge of the locations.  At each step,\
  \ compute the number of collisions\n        // of cars that are moving towards each\
  \ other.\n        int left_i = 0;\n        int right_i = 0;\n        int answer\
  \ = 0;\n        for (int i = 0; i < n; i++) {\n            if (left_i == n) {\n\
  \                // All cars from the left side have been placed.\n            \
  \    answer += Math.max(0, right_i - (n - i));\n                // i - right_i is\
  \ the number of cars moving right to left\n                // (n - i) is the number\
  \ of cars moving left to right\n                // right_i is the number of cars\
  \ that have been placed so far\n                right_i++;\n            } else if\
  \ (right_i == n) {\n                // All cars from the right side have been placed.\n\
  \                answer += Math.max(0, left_i - (n - i));\n                left_i++;\n\
  \            } else if (left[left_i] < right[right_i]) {\n                answer\
  \ += Math.max(0, right_i - (n - i));\n                left_i++;\n            } else\
  \ {\n"
- "        //return 0;  // stub code\n        List<Integer> leftToRight = new ArrayList<Integer>();\n\
  \        List<Integer> rightToLeft = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < n; i++) {\n            leftToRight.add(i);\n            rightToLeft.add(n+i);\n\
  \        }\n        return carRaceCollision(leftToRight, rightToLeft);"
- "        if (n < 1) {\n            return 0;\n        }\n        int closest = n\
  \ * 2;\n        int count = 0;\n        for (int left = 1; left <= n; left++) {\n\
  \            int right = n - left + 1;\n            while (right < closest) {\n\
  \                closest = right;\n                count++;\n                right\
  \ += n;\n            }\n        }\n        return count;"
- "        //\n        // INSERT YOUR CODE HERE\n        //\n        return -1;"
- "        // IMPLEMENT THIS FUNCTION\n        if (n == 0) {\n            return 0;\n\
  \        }\n        else {\n            return carRaceCollision(n - 1) + n - 1;\n\
  \        }"
- '        return 0;'
- '      return 0;'
- "        // 1) Write the function body\n        return 0;"
- "        if (n == 0) return 0;\n        int count = 0;\n        int[][] collisionArr\
  \ = new int[n][n];\n        int[] leftToRightArr = new int[n];\n        int[] rightToLeftArr\
  \ = new int[n];\n        // initialize array\n        for (int i = 0; i < n; i++)\
  \ {\n            leftToRightArr[i] = n + i;\n            rightToLeftArr[i] = n -\
  \ i;\n        }\n        // Sort\n        Arrays.sort(leftToRightArr);\n       \
  \ Arrays.sort(rightToLeftArr);\n        // Count collisions\n        for (int i\
  \ = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n              \
  \  if (rightToLeftArr[i] < leftToRightArr[j]) count++;\n            }\n        }\n\
  \        return count;"
- "        if (n == 0) return 0;\n        else if (n == 1) return 0;\n        else\
  \ if (n == 2) return 0;\n        else if (n == 3) return 1;\n        else return\
  \ carRaceCollision(n - 1) + n - 1;"
- '        return 0;'
- "        int counter = 0;\n        ArrayList<Pair<Integer, Integer>> car = new ArrayList<Pair<Integer,\
  \ Integer>>();\n        for (int i = 0; i < n; i++) {\n            Pair<Integer,\
  \ Integer> car1 = new Pair<Integer, Integer>(i, 0);\n            Pair<Integer, Integer>\
  \ car2 = new Pair<Integer, Integer>(i, 1);\n            car.add(car1);\n       \
  \     car.add(car2);\n        }\n        for (int i = 0; i < car.size(); i++) {\n\
  \            for (int j = i + 1; j < car.size(); j++) {\n                Pair<Integer,\
  \ Integer> first = car.get(i);\n                Pair<Integer, Integer> second =\
  \ car.get(j);\n                if (first.getValue0() == second.getValue0() && first.getValue1()\
  \ != second.getValue1()) {\n                    counter += 1;\n                }\n\
  \            }\n        }\n        return counter;"
- '        return n;'
- '        return n;'
- "        // fill in your code here.\n        return 0;"
- "        // Fill out the body of this function\n        int array[] = new int[2*n];\n\
  \        for(int i=0;i<2*n;i++) {\n            Random rand = new Random();\n   \
  \         int randNum = rand.nextInt(10) + 1;\n            array[i] = randNum;\n\
  \        }\n        int count = 0;\n        for(int i=0;i<2*n;i++) {\n         \
  \   for(int j=i+1;j<2*n;j++) {\n                if(i<n && j>=n) {\n            \
  \        if(array[i] > array[j]) {\n                        count++;\n         \
  \           }\n                }\n            }\n        }\n        return count;"
- '        return (n*(n-1))/2;'
- '        return 0;'
- "        ///////////////////\n        // BEGIN SOLUTION\n        ///////////////////\n\
  \        return (int) Math.ceil(n / 2.0);\n        //////////////////\n        //\
  \ END SOLUTION\n        //////////////////"
- "        // TODO: Implement this\n        int result = 0;\n        for (int i =\
  \ 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n              \
  \  if (i > j) {\n                    result++;\n                }\n            }\n\
  \        }\n        return result;"
- "      int[] a = new int[n];\n      for (int i = 0; i < n; i++) a[i] = i;\n    \
  \  return permutation(a, 0);"
- '        return n * (n - 1) / 2;'
- "        int collisions = 0;\n        // Write your code here\n        return collisions;"
- "        if (n == 0) return 0;\n        if (n == 1) return 0;\n        int collisions\
  \ = 0;\n        // fill in the body of this function; see the oracle function at\
  \ the end\n        // which is the same as the body of this function\n        return\
  \ collisions;"
- "        Random random = new Random();\n        // set up n cars, car i starts at\
  \ position 2*i, and moves left to right with\n        // speed i.\n        int []\
  \ pos = new int[n];\n        int [] dir = new int[n];\n        for (int i = 0; i\
  \ < n; i++) {\n            pos[i] = 2*i;\n            dir[i] = i;\n        }\n \
  \       // now set up n cars moving right to left, starting at 2*n, moving at speed\n\
  \        // n - i;\n        for (int i = 0; i < n; i++) {\n            pos[i+n]\
  \ = 2*n - i;\n            dir[i+n] = n - i;\n        }\n        // now run our simulation\n\
  \        int collisions = 0;\n        for (int i = 0; i < n; i++) {\n          \
  \  for (int j = n; j < 2*n; j++) {\n                if (pos[i] < pos[j]) {\n   \
  \                 collisions++;\n                }\n            }\n        }\n \
  \       // move the cars at their respective speeds\n        for (int i = 0; i <\
  \ 2*n; i++) {\n            pos[i] += dir[i];\n        }\n        return collisions;"
- "        int collisions = 0;\n        int[] left2right = new int[n];\n        int[]\
  \ right2left = new int[n];\n        for (int i = 0; i < n; i++) {\n            left2right[i]\
  \ = i;\n            right2left[i] = n - i - 1;\n        }\n        while (left2right[n\
  \ - 1] != n - 1) {\n            for (int i = 0; i < n; i++) {\n                if\
  \ (left2right[i] != n - 1) {\n                    if (left2right[i] + 1 == right2left[i])\
  \ {\n                        collisions++;\n                    }\n            \
  \        left2right[i]++;\n                }\n                if (right2left[i]\
  \ != 0) {\n                    if (right2left[i] - 1 == left2right[i]) {\n     \
  \                   collisions++;\n                    }\n                    right2left[i]--;\n\
  \                }\n            }\n        }\n        return collisions;"
- "        int result = 0;\n        //------------------------------------------------\n\
  \        // Your code goes here.\n        //------------------------------------------------\n\
  \        return result;"
- "        // YOUR CODE HERE\n        int count = 0;\n        List<Integer> currentPos\
  \ = new ArrayList<Integer>();\n        List<Integer> nextPos = new ArrayList<Integer>();\n\
  \        for (int i = 0; i < n; i++) {\n            currentPos.add(Integer.MAX_VALUE);\n\
  \            nextPos.add(0);\n        }\n        while (currentPos.size() != 0)\
  \ {\n            //System.out.println(currentPos);\n            for (int i = 0;\
  \ i < n; i++) {\n                nextPos.set(i, currentPos.get(i) - 1);\n      \
  \      }\n            count += checkCollision(currentPos, nextPos);\n          \
  \  currentPos = nextPos;\n            nextPos = new ArrayList<Integer>();\n    \
  \        for (int i = 0; i < n; i++) {\n                nextPos.add(0);\n      \
  \      }\n        }\n        return count;"
- '        return n * (n - 1) / 2;'
- "        int left = 1;\n        int right = 1;\n        int collisions = 0;\n  \
  \      while (left <= n && right <= n) {\n            if (left == right) {\n   \
  \             collisions++;\n                left++;\n                right++;\n\
  \            } else if (left < right) {\n                left++;\n            }\
  \ else {\n                right++;\n            }\n        }\n        return collisions;"
- '        return 0;'
- '        throw new UnsupportedOperationException("Please implement the carRaceCollision()
  method");'
- "        int answer = 0;\n        return answer;"
- "        if (n == 0) return 0;\n        // lastCarLtoR maps the position of the\
  \ last car L to R to its index.\n        TreeMap<Integer, Integer> lastCarLtoR =\
  \ new TreeMap<>();\n        // lastCarRtoL maps the position of the last car R to\
  \ L to its index.\n        TreeMap<Integer, Integer> lastCarRtoL = new TreeMap<>();\n\
  \        for (int i = 0; i < n; i++) {\n            lastCarLtoR.put(i, i);\n   \
  \         lastCarRtoL.put(n - i - 1, i);\n        }\n        int collisions = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            // i represents the \"age\"\
  \ of the car, or the time it's been moving.\n            // When we look at a car\
  \ of age i, we look for the closest car that's older\n            // than i.  That's\
  \ because we're looking for a car that's already collided with\n            // something,\
  \ and traveled a \"distance\" of i.\n            collisions += lastCarLtoR.floorEntry(i).getValue()\
  \ + 1;\n            collisions += lastCarRtoL.floorEntry(i).getValue() + 1;\n  \
  \          lastCarLtoR.remove(i);\n            lastCarRtoL.remove(i);\n        }\n\
  \        return collisions;"
- "        if (n < 1)\n            return 0;\n        // vector1 and vector2 are parallel\
  \ vectors;  they represent the positions\n        // of the n cars moving left to\
  \ right and right to left, respectively.\n        Vector<Integer> vector1 = new\
  \ Vector<Integer>();\n        Vector<Integer> vector2 = new Vector<Integer>();\n\
  \        for (int i = 0; i < n; i++) {\n            vector1.add(i);\n          \
  \  vector2.add(i);\n        }\n        // Sort the two vectors so that we can efficiently\
  \ find out if\n        // a car collides with another one.\n        Collections.sort(vector1);\n\
  \        Collections.sort(vector2);\n        // Count the number of collisions.\n\
  \        int collisions = 0;\n        for (int i = 0; i < n; i++) {\n          \
  \  // The cars that have the same position collide with each other.\n          \
  \  if (vector1.get(i) == vector2.get(i))\n                collisions++;\n      \
  \  }\n        return collisions;"
- "        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for\
  \ (int j = 0; j < n; j++) {\n                result += 1;\n            }\n     \
  \   }\n        return result;"
- "        int collisions = 0;\n        // write your code here\n        return collisions;"
- "        // [4/4] Complete this function.\n        int collisions = 0;\n       \
  \ for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n   \
  \             if (i < j) {\n                    collisions++;\n                }\n\
  \            }\n        }\n        return collisions;"
- "        HashMap<Integer, Integer> hm = new HashMap<>();\n        int ans = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            int a = -1 * (i + 1);\n    \
  \        int b = i + 1;\n            if (hm.containsKey(a)) {\n                int\
  \ c = hm.get(a);\n                ans += c;\n            }\n            if (hm.containsKey(b))\
  \ {\n                int c = hm.get(b);\n                hm.put(b, c + 1);\n   \
  \         } else {\n                hm.put(b, 1);\n            }\n        }\n  \
  \      return ans;"
- '        throw new UnsupportedOperationException("This method is not yet implemented");'
- "        int collisions = 0;\n        // your code goes here\n        return collisions;"
- "        int a = n-1;\n        int b = n-1;\n        int ans = 0;\n        while\
  \ (a>=0 && b>=0) {\n            if (a<=b) {\n                ans+=a;\n         \
  \       b--;\n            } else {\n                ans+=b;\n                a--;\n\
  \            }\n        }\n        return ans;"
- "        //int[][] cars = new int[2][n];\n        //return carRaceCollision(cars,0,cars.length-1,0,cars[0].length-1);\n\
  \        \n        return carRaceCollision(new int[2][n],0,1,0,n-1);"
- "        // You need to fill this in.\n        //\n        // Hint: You can assume\
  \ n is a positive power of 2 (1, 2, 4, 8, ...).  The function\n        // should\
  \ work correctly for any positive integer n, but you don't need to worry about\n\
  \        // how to do it for non-powers of 2.\n        int collisions = 0;\n   \
  \     if (n <= 1) {\n            return collisions;\n        }\n        else {\n\
  \            return n/2 + carRaceCollision(n/2);\n        }"
- '        return 0;'
- '        return 1;'
- "        // The number of collisions can be thought of as the number of inversions.\n\
  \        // That's because if the left-to-right cars are in the order of a1, a2,\
  \ a3, ..., an,\n        // and the right-to-left cars are in the order of b1, b2,\
  \ b3, ..., bn, then each\n        // collision will occur if and only if ai > bi,\
  \ where i is the index.\n        // The number of collisions is equal to the number\
  \ of inversions, which\n        // can be computed in O(n log n) time.\n       \
  \ return 0;"
- "        //\n        // Fill in your code here!\n        //\n        // NOTE: your\
  \ return is of type int\n        return 0;"
- "        if (n <= 0) {\n            return 0;\n        }\n        int num = 0;\n\
  \        int[] l2r = new int[n];\n        int[] r2l = new int[n];\n        l2r[0]\
  \ = 1;\n        r2l[0] = -1;\n        // Iterate through different cars.\n     \
  \   for (int i = 1; i < n; i++) {\n            // Iterate through all cars that\
  \ are moving left to right.\n            for (int j = 0; j < i; j++) {\n       \
  \         // Iterate through all cars that are moving right to left.\n         \
  \       for (int k = 0; k < i; k++) {\n                    if (l2r[j] == 1 && r2l[k]\
  \ == -1) {\n                        num++;\n                    }\n            \
  \    }\n            }\n            l2r[i] = 1;\n            r2l[i] = -1;\n     \
  \   }\n        return num;"
- "        long ret = 0;\n        for (int i = 0; i < n; i++) {\n            for (int\
  \ j = 0; j < n; j++) {\n                ret += ((long) i + j) * (long) (i + j);\n\
  \            }\n        }\n        return (int) ret;"
- "        // Your code should go here.\n        // The input n is the number of left-to-right\
  \ cars and right-to-left cars.\n        int result = 0;\n        int[] right = new\
  \ int[n];\n        int[] left = new int[n];\n        for (int i = 0; i < n; i++)\
  \ {\n            right[i] = i;\n            left[i] = i;\n        }\n        for\
  \ (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n       \
  \         if (right[i] == left[j]) {\n                    result++;\n          \
  \      }\n            }\n        }\n        return result;"
- '        return 0;'
- '        return n;'
- "        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for\
  \ (int j = 0; j < n; j++) {\n                count++;\n            }\n        }\n\
  \        return count;"
- "        // algorithm:\n        // first we assume n is even.\n        // after\
  \ the first n cars from the left and n cars from the right meet each other\n   \
  \     // they will not collide because they move in the same direction\n       \
  \ // so we only need to look at 1, 3, 5, 7, 9, ... cars\n        // this is a geomtric\
  \ series sum of 1/2 + 1/4 + 1/8 + ... = 1\n        // so the answer is n\n     \
  \   // what if n is odd?  then we add 1 more car, which will collide with 1 more\
  \ car\n        // so the answer is n + 1\n        // how do we compute n % 2?\n\
  \        // we could use the method n % 2, but that's cheating and\n        // Java\
  \ may not have an implementation of modulo\n        // so we use the following algorithm\n\
  \        // if n is even, then n/2 is an integer\n        // if n is odd, then n/2\
  \ is not an integer\n        // if n/2 is an integer, n is even\n        // if n/2\
  \ is not an integer, n is odd\n        // but how do we know if n/2 is an integer\
  \ or not?\n        // we use the function  n % (2 * (n/2))\n        // if n is even,\
  \ (n/2) is an integer\n        // so n % (2 * (n/2)) = 0\n        // if n is odd,\
  \ (n/2) is not an integer\n        // so n % (2 * (n/2)) = n % (2 * (n/2)) = n %\
  \ n = 0\n        // so the answer is n + (n % (2 * (n/2)))\n        return n + (n\
  \ % (2 * (n/2)));"
- '        return 0;'
- "        // Your code here\n        return 0;"
- "        // Your code here.\n        // Hint: Java doesn't have a default constructor\
  \ for an array, e.g. `new int[3]` does not set every element of the array to 0.\
  \  Instead, use `new int[3] {0, 0, 0}`.\n        int[] carPositions = new int[n];\n\
  \        Arrays.fill(carPositions, 0);\n        int collisions = 0;\n        for\
  \ (int i = 0; i < n; i++) {\n            carPositions[i] = (i + 1) * 10;\n     \
  \   }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n;\
  \ j++) {\n                if (carPositions[i] == carPositions[j]) {\n          \
  \          collisions++;\n                }\n            }\n        }\n        return\
  \ collisions;"
- "        // a car that moves left to right starts at position n and moves to position\
  \ 1\n        // a car that moves right to left starts at position 1 and moves to\
  \ position n\n        // car i starts at position i\n        // two cars collide\
  \ if they are in the same position in the same time step\n        // after t time\
  \ steps, the cars are at position:\n        // left to right: n-t\n        // right\
  \ to left: 1+t\n        // if n-t == 1+t, then the cars collide, else the cars do\
  \ not collide\n        // if t >= n, then there are no collisions\n        // if\
  \ n-t == 1+t, then there is a collision\n        // t == n-2 => n - t == 1+t\n \
  \       // t == n-1 => n - t == 1+t\n        // t == n => n - t != 1+t\n       \
  \ // t == n+1 => n - t != 1+t\n        // ...\n        // t >= n  => n - t != 1+t\n\
  \        // t <= n-2 => n - t == 1+t\n        // so, t = n-2 results in a collision\n\
  \        return n < 2 ? 0 : n-2;"
- '        return n == 0 ? 0 : n - 1;'
- "        int collisionCount = 0;\n        // We need to be sure that if the cars\
  \ are perfectly symmetric and the starting\n        // position of the cars are\
  \ identical, then there will be 0 collisions\n        Random random = new Random();\n\
  \        int[] posLeft = new int[n];\n        int[] posRight = new int[n];\n   \
  \     for (int i = 0; i < n; i++) {\n            posLeft[i] = random.nextInt(2*n)\
  \ + 1;\n            posRight[i] = random.nextInt(2*n) + 1;\n        }\n        Arrays.sort(posLeft);\n\
  \        Arrays.sort(posRight);\n        int i = 0;\n        int j = 0;\n      \
  \  while (i < n && j < n) {\n            if (posLeft[i] == posRight[j]) {\n    \
  \            collisionCount++;\n                i++;\n                j++;\n   \
  \         } else if (posLeft[i] < posRight[j]) {\n                i++;\n       \
  \     } else {\n                j++;\n            }\n        }\n        return collisionCount;"
- "        // A car is represented by (position, velocity) of the form (double, int).\n\
  \        // Cars are ordered by the position.\n        List<Pair<Double, Integer>>\
  \ leftToRightCars = new ArrayList<>();\n        List<Pair<Double, Integer>> rightToLeftCars\
  \ = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            // pos\
  \ between 0 and 1.\n            double pos = Math.random();\n            // velocity\
  \ 1 or -1.\n            int velocity = 1;\n            if (Math.random() < 0.5)\
  \ {\n                velocity = -1;\n            }\n            if (velocity ==\
  \ 1) {\n                leftToRightCars.add(new Pair<>(pos, velocity));\n      \
  \      } else {\n                rightToLeftCars.add(new Pair<>(pos, velocity));\n\
  \            }\n        }\n        // Sort the cars by position.\n        leftToRightCars.sort((a,\
  \ b) -> a.getValue0().compareTo(b.getValue0()));\n        rightToLeftCars.sort((a,\
  \ b) -> b.getValue0().compareTo(a.getValue0()));\n        // The cars move until\
  \ the cars at the extreme left and extreme right stop moving.\n        int l = 0;\n\
  \        int r = 0;\n        int count = 0;\n        while (l < leftToRightCars.size()\
  \ && r < rightToLeftCars.size()) {\n            Pair<Double, Integer> lCar = leftToRightCars.get(l);\n\
  \            Pair<Double, Integer> rCar = rightToLeftCars.get(r);\n            if\
  \ (lCar.getValue0() <= rCar.getValue0()) {\n                count++;\n         \
  \       l++;\n            } else {\n                r++;\n            }\n      \
  \  }\n        return count;"
language: java
name: HumanEval_41_car_race_collision
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Imagine a road that's a perfectly straight infinitely long\
  \ line.\n    // n cars are driving left to right;  simultaneously, a different set\
  \ of n cars\n    // are driving right to left.   The two sets of cars start out\
  \ being very far from\n    // each other.  All cars move in the same speed.  Two\
  \ cars are said to collide\n    // when a car that's moving left to right hits a\
  \ car that's moving right to left.\n    // However, the cars are infinitely sturdy\
  \ and strong; as a result, they continue moving\n    // in their trajectory as if\
  \ they did not collide.\n    // This function outputs the number of such collisions.\n\
  \    public static int carRaceCollision(int n) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(carRaceCollision((2))\
  \ == (4));\n    assert(carRaceCollision((3)) == (9));\n    assert(carRaceCollision((4))\
  \ == (16));\n    assert(carRaceCollision((8)) == (64));\n    assert(carRaceCollision((10))\
  \ == (100));\n    }\n\n}\n"
