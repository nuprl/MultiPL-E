completions:
- "        // Fill in here\n        return null;"
- '        return new Pair<Optional<Integer>, Optional<Integer>>(null, null);'
- "        Optional<Integer> neg = lst.stream().filter(n -> n < 0).max(Integer::compare);\n\
  \        Optional<Integer> pos = lst.stream().filter(n -> n > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(neg, pos);"
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        Integer min = lst.get(0);\n        Integer max = lst.get(0);\n\
  \        for (Integer i : lst) {\n            if (i >= 0 && i < min) min = i;\n\
  \            if (i < 0 && i > max) max = i;\n        }\n        if (min >= 0) return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(), Optional.of(min));\n\
  \        if (max < 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max),\
  \ Optional.empty());\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max),\
  \ Optional.of(min));"
- '        // Write your solution here'
- '        // you code here'
- '        return null;'
- "        Optional<Integer> maxNegativeOpt = Optional.empty();\n        Optional<Integer>\
  \ minPositiveOpt = Optional.empty();\n        for (Integer i : lst) {\n        \
  \    if (i < 0) {\n                if (!maxNegativeOpt.isPresent() || maxNegativeOpt.get()\
  \ < i) {\n                    maxNegativeOpt = Optional.of(i);\n               \
  \ }\n            } else if (i > 0) {\n                if (!minPositiveOpt.isPresent()\
  \ || minPositiveOpt.get() > i) {\n                    minPositiveOpt = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(maxNegativeOpt,\
  \ minPositiveOpt);"
- "        // Your code here.\n        // No need to include the class \"Options\"\
  \ in the import list,\n        // since it's already imported.\n        return null;"
- '        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),
  Optional.empty());'
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(x\
  \ -> x < 0).max(Integer::compare),\n            lst.stream().filter(x -> x > 0).min(Integer::compare)\n\
  \        );"
- '        return null;'
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        boolean l = false;\n        boolean s =\
  \ false;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i)\
  \ > 0) {\n                if (!s) {\n                    smallest = Optional.of(lst.get(i));\n\
  \                    s = true;\n                } else {\n                    if\
  \ (lst.get(i) < smallest.get()) {\n                        smallest = Optional.of(lst.get(i));\n\
  \                    }\n                }\n            } else if (lst.get(i) < 0)\
  \ {\n                if (!l) {\n                    largest = Optional.of(lst.get(i));\n\
  \                    l = true;\n                } else {\n                    if\
  \ (lst.get(i) > largest.get()) {\n                        largest = Optional.of(lst.get(i));\n\
  \                    }\n                }\n            }\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        Pair<Optional<Integer>, Optional<Integer>> result = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        for (Integer\
  \ i : lst) {\n            if (i > 0) {\n                if (result.getValue1().isPresent())\
  \ {\n                    if (i < result.getValue1().get()) {\n                 \
  \       result = result.setAt1(Optional.of(i));\n                    }\n       \
  \         } else {\n                    result = result.setAt1(Optional.of(i));\n\
  \                }\n            } else if (i < 0) {\n                if (result.getValue0().isPresent())\
  \ {\n                    if (i > result.getValue0().get()) {\n                 \
  \       result = result.setAt0(Optional.of(i));\n                    }\n       \
  \         } else {\n                    result = result.setAt0(Optional.of(i));\n\
  \                }\n            }\n        }\n        return result;"
- '        return null;'
- "        // Write your code here\n        Optional<Integer> negMax = Optional.empty();\n\
  \        Optional<Integer> posMin = Optional.empty();\n        for (Integer i :\
  \ lst) {\n            if (i < 0) {\n                if (!negMax.isPresent() || i\
  \ > negMax.get()) {\n                    negMax = Optional.of(i);\n            \
  \    }\n            } else if (i > 0) {\n                if (!posMin.isPresent()\
  \ || i < posMin.get()) {\n                    posMin = Optional.of(i);\n       \
  \         }\n            }\n        }\n        return Pair.with(negMax, posMin);"
- "        // Your code here\n        return null;"
- "        var largestNegative = Optional.empty();\n        var smallestPositive =\
  \ Optional.empty();\n        for (var i : lst) {\n            if (i > 0) {\n   \
  \             if (smallestPositive.isEmpty() || i < smallestPositive.get()) {\n\
  \                    smallestPositive = Optional.of(i);\n                }\n   \
  \         } else if (i < 0) {\n                if (largestNegative.isEmpty() ||\
  \ i > largestNegative.get()) {\n                    largestNegative = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNegative,\
  \ smallestPositive);"
- "        ArrayList<Integer> pos = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ neg = new ArrayList<Integer>();\n        for (int i = 0; i < lst.size(); i++)\
  \ {\n            if (lst.get(i) < 0) {\n                neg.add(lst.get(i));\n \
  \           } else if (lst.get(i) > 0) {\n                pos.add(lst.get(i));\n\
  \            }\n        }\n        int max_neg = neg.size() > 0 ? Collections.max(neg)\
  \ : -1;\n        int min_pos = pos.size() > 0 ? Collections.min(pos) : -1;\n   \
  \     return new Pair<Optional<Integer>, Optional<Integer>>(\n                Optional.of(max_neg).filter(i\
  \ -> i > -1),\n                Optional.of(min_pos).filter(i -> i > -1)\n      \
  \  );"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (Integer i : lst) {\n            if\
  \ (i > 0) {\n                if (smallest.isPresent()) {\n                    if\
  \ (i < smallest.get()) {\n                        smallest = Optional.of(i);\n \
  \                   }\n                } else {\n                    smallest =\
  \ Optional.of(i);\n                }\n            } else if (i < 0) {\n        \
  \        if (largest.isPresent()) {\n                    if (i > largest.get())\
  \ {\n                        largest = Optional.of(i);\n                    }\n\
  \                } else {\n                    largest = Optional.of(i);\n     \
  \           }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(largest, smallest);"
- "\t\tfinal Optional<Integer> one = Optional.of(1);\n\t\tfinal Optional<Integer>\
  \ none = Optional.empty();\n\t\tint max = 0;\n\t\tint min = 0;\n\t\tPair<Optional<Integer>,\
  \ Optional<Integer>> result = new Pair<Optional<Integer>, Optional<Integer>>(none,\
  \ none);\n\t\t\n\t\tif(lst.size() == 0){\n\t\t\treturn result;\n\t\t}\n\t\tfor(int\
  \ i = 0; i < lst.size(); i++){\n\t\t\tif(lst.get(i) < 0){\n\t\t\t\tif(lst.get(i)\
  \ > max){\n\t\t\t\t\tmax = lst.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(lst.get(i)\
  \ > 0){\n\t\t\t\tif(min == 0){\n\t\t\t\t\tmin = lst.get(i);\n\t\t\t\t}\n\t\t\t\t\
  if(lst.get(i) < min){\n\t\t\t\t\tmin = lst.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
  \tif(max == 0){\n\t\t\tresult = new Pair<Optional<Integer>, Optional<Integer>>(none,\
  \ one);\n\t\t}\n\t\telse if(min == 0){\n\t\t\tresult = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(one, none);\n\t\t}\n\t\telse{\n\t\t\tresult = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(one, one);\n\t\t}\n\t\treturn result;"
- '        // Write your code here'
- "        Optional<Integer> oNeg = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> oPos = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(oNeg, oPos);"
- "        // Write your code here\n        // To print results to the standard output\
  \ you can use System.out.println()\n        // Example: System.out.println(\"Hello\
  \ world!\");\n        return null;"
- "        // write code here!\n        return null;"
- '        // Your code here'
- "        int negative = 0;\n        int positive = 0;\n        for (int i = 0; i\
  \ < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n                negative\
  \ = lst.get(i);\n            }\n            if (lst.get(i) > 0) {\n            \
  \    positive = lst.get(i);\n            }\n        }\n        Optional<Integer>\
  \ first = Optional.of(negative);\n        Optional<Integer> second = Optional.of(positive);\n\
  \        Pair<Optional<Integer>, Optional<Integer>> pair = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(first, second);\n        return pair;"
- "        Optional<Integer> pos = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        Optional<Integer> neg = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(neg, pos);"
- "        Optional<Integer> maxNeg = Optional.empty();\n        Optional<Integer>\
  \ minPos = Optional.empty();\n        for (Integer e : lst) {\n            if (e\
  \ < 0) {\n                if (!maxNeg.isPresent() || e > maxNeg.get()) {\n     \
  \               maxNeg = Optional.of(e);\n                }\n            } else\
  \ if (e > 0) {\n                if (!minPos.isPresent() || e < minPos.get()) {\n\
  \                    minPos = Optional.of(e);\n                }\n            }\n\
  \        }\n        return Pair.with(maxNeg, minPos);"
- "        ArrayList<Integer> pos = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ neg = new ArrayList<Integer>();\n        for (int i = 0; i < lst.size(); i++)\
  \ {\n            if (lst.get(i) < 0) {\n                neg.add(lst.get(i));\n \
  \           } else if (lst.get(i) > 0) {\n                pos.add(lst.get(i));\n\
  \            }\n        }\n        Optional<Integer> largest = Optional.empty();\n\
  \        Optional<Integer> smallest = Optional.empty();\n        if (neg.size()\
  \ > 0) {\n            largest = Optional.of(Collections.max(neg));\n        }\n\
  \        if (pos.size() > 0) {\n            smallest = Optional.of(Collections.min(pos));\n\
  \        }\n        return Pair.with(largest, smallest);"
- "        Optional<Integer> negative_max = lst.stream().filter(e -> e < 0).max(Integer::compare);\n\
  \        Optional<Integer> positive_min = lst.stream().filter(e -> e > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(negative_max, positive_min);"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (Integer element : lst) {\n        \
  \    if (element > 0) {\n                if (smallest.isPresent()) {\n         \
  \           if (element < smallest.get()) {\n                        smallest =\
  \ Optional.of(element);\n                    }\n                } else {\n     \
  \               smallest = Optional.of(element);\n                }\n          \
  \  } else if (element < 0) {\n                if (largest.isPresent()) {\n     \
  \               if (element > largest.get()) {\n                        largest\
  \ = Optional.of(element);\n                    }\n                } else {\n   \
  \                 largest = Optional.of(element);\n                }\n         \
  \   }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(largest,\
  \ smallest);"
- "        Pair<Optional<Integer>, Optional<Integer>> result = null;\n        Optional<Integer>\
  \ maxNegative = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> minPositive = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        result = new Pair<Optional<Integer>, Optional<Integer>>(maxNegative, minPositive);\n\
  \        return result;"
- '        // Your code here'
- "        int[] max = {Integer.MIN_VALUE};\n        int[] min = {Integer.MAX_VALUE};\n\
  \        lst.stream().forEach(x -> {\n            if (x < 0) {\n               \
  \ max[0] = Math.max(max[0], x);\n            } else if (x > 0) {\n             \
  \   min[0] = Math.min(min[0], x);\n            }\n        });\n        return new\
  \ Pair<Optional<Integer>, Optional<Integer>>(\n            max[0] != Integer.MIN_VALUE\
  \ ? Optional.of(max[0]) : Optional.empty(),\n            min[0] != Integer.MAX_VALUE\
  \ ? Optional.of(min[0]) : Optional.empty()\n        );"
- '        // your code here'
- "        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n  \
  \      for (int num : lst) {\n            if (num < 0) {\n                max =\
  \ Math.max(max, num);\n            } else if (num > 0) {\n                min =\
  \ Math.min(min, num);\n            }\n        }\n        Pair<Optional<Integer>,\
  \ Optional<Integer>> pair = new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max),\
  \ Optional.of(min));\n        if (min == Integer.MAX_VALUE) {\n            pair\
  \ = new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max), Optional.empty());\n\
  \        }\n        if (max == Integer.MIN_VALUE) {\n            pair = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.of(min));\n        }\n        if\
  \ (min == Integer.MAX_VALUE && max == Integer.MIN_VALUE) {\n            pair = new\
  \ Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(), Optional.empty());\n\
  \        }\n        return pair;"
- "        int pos = 0;\n        int neg = 0;\n        if (lst.size() == 0) {\n  \
  \          return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        for (int i = 0; i < lst.size(); i++) {\n\
  \            if (lst.get(i) > 0) {\n                pos = lst.get(i);\n        \
  \        break;\n            }\n        }\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) < 0) {\n                neg = lst.get(i);\n\
  \                break;\n            }\n        }\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) > 0 && lst.get(i) < pos) {\n              \
  \  pos = lst.get(i);\n            }\n        }\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) < 0 && lst.get(i) > neg) {\n              \
  \  neg = lst.get(i);\n            }\n        }\n        if (pos == 0 && neg == 0)\
  \ {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        if (pos == 0) {\n            return new\
  \ Pair<Optional<Integer>, Optional<Integer>>(Optional.of(neg), Optional.empty());\n\
  \        }\n        if (neg == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.of(pos));\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(neg), Optional.of(pos));"
- "        Integer maxNeg = null;\n        Integer minPos = null;\n        for (Integer\
  \ i : lst) {\n            if (i < 0) {\n                if (maxNeg == null || i\
  \ > maxNeg) {\n                    maxNeg = i;\n                }\n            }\
  \ else if (i > 0) {\n                if (minPos == null || i < minPos) {\n     \
  \               minPos = i;\n                }\n            }\n        }\n     \
  \   return new Pair<Optional<Integer>, Optional<Integer>>(\n            maxNeg ==\
  \ null ? Optional.empty() : Optional.of(maxNeg),\n            minPos == null ? Optional.empty()\
  \ : Optional.of(minPos)\n        );"
- '        throw new UnsupportedOperationException("Not implemented yet");'
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n\n       \
  \ int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        boolean\
  \ hasPositives = false;\n        boolean hasNegatives = false;\n\n        for (int\
  \ n : lst) {\n            if (n < 0) {\n                if (n > max) {\n       \
  \             max = n;\n                }\n                hasNegatives = true;\n\
  \            } else if (n > 0) {\n                if (n < min) {\n             \
  \       min = n;\n                }\n                hasPositives = true;\n    \
  \        }\n        }\n\n        return new Pair<Optional<Integer>, Optional<Integer>>(\n\
  \            hasNegatives ? Optional.of(max) : Optional.empty(),\n            hasPositives\
  \ ? Optional.of(min) : Optional.empty()\n        );"
- "        // return the pair\n        return null;"
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        if (lst.size() == 1) return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        int min = lst.get(0);\n\
  \        int max = lst.get(0);\n        for (int i = 1; i < lst.size(); i++) {\n\
  \            if (lst.get(i) > max) max = lst.get(i);\n            if (lst.get(i)\
  \ < min) min = lst.get(i);\n        }\n        if (min > 0) min = Optional.empty();\n\
  \        if (max < 0) max = Optional.empty();\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.of(max), Optional.of(min));"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        boolean isNegative = false;\n        boolean\
  \ isPositive = false;\n        for (int i : lst) {\n            if (i < 0) {\n \
  \               if (!isNegative) {\n                    largest = Optional.of(i);\n\
  \                    isNegative = true;\n                } else {\n            \
  \        largest = largest.filter(y -> y < i).isPresent() ? largest : Optional.of(i);\n\
  \                }\n            } else if (i > 0) {\n                if (!isPositive)\
  \ {\n                    smallest = Optional.of(i);\n                    isPositive\
  \ = true;\n                } else {\n                    smallest = smallest.filter(y\
  \ -> y > i).isPresent() ? smallest : Optional.of(i);\n                }\n      \
  \      }\n        }\n        return Pair.with(largest, smallest);"
- '        return null;'
- "        Optional<Integer> maxNegative = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> minPositive = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(maxNegative, minPositive);"
- '        // YOUR CODE HERE'
- "        int min_pos = Integer.MAX_VALUE;\n        int max_neg = Integer.MIN_VALUE;\n\
  \        boolean all_zero = true;\n        boolean all_pos = true;\n        boolean\
  \ all_neg = true;\n        for (int n : lst) {\n            if (n > 0) {\n     \
  \           all_neg = false;\n                if (n < min_pos) {\n             \
  \       min_pos = n;\n                }\n            } else if (n < 0) {\n     \
  \           all_pos = false;\n                if (n > max_neg) {\n             \
  \       max_neg = n;\n                }\n            } else {\n                all_zero\
  \ = false;\n            }\n        }\n        if (all_pos) {\n            return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(), Optional.of(min_pos));\n\
  \        } else if (all_neg) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max_neg),\
  \ Optional.empty());\n        } else if (all_zero) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        } else {\n  \
  \          return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max_neg),\
  \ Optional.of(min_pos));\n        }"
- "        Optional<Integer> min = lst.stream().filter(x -> x > 0).min(Integer::compare);\n\
  \        Optional<Integer> max = lst.stream().filter(x -> x < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(max, min);"
- "        ArrayList<Integer> positiveNumbers = new ArrayList<Integer>();\n      \
  \  ArrayList<Integer> negativeNumbers = new ArrayList<Integer>();\n        for (int\
  \ i : lst) {\n            if (i < 0) {\n                negativeNumbers.add(i);\n\
  \            } else if (i > 0) {\n                positiveNumbers.add(i);\n    \
  \        }\n        }\n        Collections.sort(positiveNumbers);\n        Collections.sort(negativeNumbers);\n\
  \        Collections.reverse(negativeNumbers);\n        Optional<Integer> largest\
  \ = negativeNumbers.size() > 0 ? Optional.of(negativeNumbers.get(0)) : Optional.empty();\n\
  \        Optional<Integer> smallest = positiveNumbers.size() > 0 ? Optional.of(positiveNumbers.get(0))\
  \ : Optional.empty();\n        return Pair.with(largest, smallest);"
- '        return null;'
- "        Optional<Integer> positive = lst.stream().filter(x -> x > 0).min(Integer::compare);\n\
  \        Optional<Integer> negative = lst.stream().filter(x -> x < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(negative, positive);"
- '        throw new UnsupportedOperationException("Waiting to be implemented.");'
- '        // Implement me.'
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(e\
  \ -> e < 0).max(Comparator.naturalOrder()),\n            lst.stream().filter(e ->\
  \ e > 0).min(Comparator.naturalOrder())\n        );"
- "        Optional<Integer> largestNegative = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> smallestPositive = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largestNegative,\
  \ smallestPositive);"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            Optional.ofNullable(lst.stream().filter(i\
  \ -> i < 0).max(Integer::compare).orElse(null)),\n            Optional.ofNullable(lst.stream().filter(i\
  \ -> i > 0).min(Integer::compare).orElse(null))\n        );"
- "        Optional<Integer> maxNegative = lst.stream().filter(e -> e < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> minPositive = lst.stream().filter(e -> e > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(maxNegative, minPositive);"
- "        // TODO:\n        // Iterate through the list, and calculate the largest\
  \ negative\n        // and smallest positive integer.\n        // Once found, return\
  \ them in a tuple (a, b).\n        // If no negative or positive integer is found,\
  \ return the tuple\n        // (None, None).\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(null, null);"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        for (Integer i : lst) {\n            if (i < 0) {\n\
  \                if (!a.isPresent() || i > a.get()) {\n                    a = Optional.of(i);\n\
  \                }\n            } else if (i > 0) {\n                if (!b.isPresent()\
  \ || i < b.get()) {\n                    b = Optional.of(i);\n                }\n\
  \            }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(a,\
  \ b);"
- '      // Insert your code here'
- "        Optional<Integer> negs = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> poss = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(negs, poss);"
- "        // note the usage of Pair to return a tuple\n        Pair<Optional<Integer>,\
  \ Optional<Integer>> result = null;\n        // write your code here\n\n       \
  \ return result;"
- "        Integer min = null;\n        Integer max = null;\n        Optional<Integer>\
  \ optMin = Optional.empty();\n        Optional<Integer> optMax = Optional.empty();\n\
  \        for (Integer e : lst) {\n            if (e < 0) {\n                if (max\
  \ == null || e > max) {\n                    max = e;\n                }\n     \
  \       } else if (e > 0) {\n                if (min == null || e < min) {\n   \
  \                 min = e;\n                }\n            }\n        }\n      \
  \  if (min != null) {\n            optMin = Optional.of(min);\n        }\n     \
  \   if (max != null) {\n            optMax = Optional.of(max);\n        }\n    \
  \    return new Pair<Optional<Integer>, Optional<Integer>>(optMax, optMin);"
- "        // show me the code\n        return null;"
- "      ArrayList<Integer> negative = new ArrayList<Integer>();\n      ArrayList<Integer>\
  \ positive = new ArrayList<Integer>();\n      for (int i = 0; i < lst.size(); i++)\
  \ {\n        if (lst.get(i) < 0) {\n          negative.add(lst.get(i));\n      \
  \  } else if (lst.get(i) > 0) {\n          positive.add(lst.get(i));\n        }\n\
  \      }\n      Optional<Integer> negative_max = Optional.empty();\n      Optional<Integer>\
  \ positive_min = Optional.empty();\n      if (negative.size() > 0) {\n        negative_max\
  \ = Optional.of(Collections.max(negative));\n      }\n      if (positive.size()\
  \ > 0) {\n        positive_min = Optional.of(Collections.min(positive));\n     \
  \ }\n      return Pair.with(negative_max, positive_min);"
- "        int a = 0;\n        int b = 0;\n        int largest = 0;\n        int smallest\
  \ = 0;\n        if(lst.size() == 0)\n        {\n            a = 0;\n           \
  \ b = 0;\n        }\n        for(int i = 0; i < lst.size(); i++)\n        {\n  \
  \          if(lst.get(i) > 0)\n            {\n                b = lst.get(i);\n\
  \                if(b < smallest)\n                {\n                    smallest\
  \ = b;\n                }\n            }\n            else if(lst.get(i) < 0)\n\
  \            {\n                a = lst.get(i);\n                if(a > largest)\n\
  \                {\n                    largest = a;\n                }\n      \
  \      }\n        }\n        if(largest == 0)\n        {\n            largest =\
  \ -1;\n        }\n        if(smallest == 0)\n        {\n            smallest = 1;\n\
  \        }\n        Pair<Optional<Integer>, Optional<Integer>> ret = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.of(largest), Optional.of(smallest));\n        return\
  \ ret;"
- "        // Write your code here.\n        Optional<Integer> a=Optional.empty();\n\
  \        Optional<Integer> b=Optional.empty();\n        for(int i=0;i<lst.size();i++){\n\
  \            if(lst.get(i)<0 && (a.isEmpty() || a.get()<lst.get(i))){\n        \
  \        a=Optional.of(lst.get(i));\n            }\n            if(lst.get(i)>0\
  \ && (b.isEmpty() || b.get()>lst.get(i))){\n                b=Optional.of(lst.get(i));\n\
  \            }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(a,b);"
- '        // Write your code here'
- "        Optional<Integer> opt = lst.stream().filter(x -> x > 0).min(Integer::compare);\n\
  \        Optional<Integer> opt2 = lst.stream().filter(x -> x < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(opt2, opt);"
- '        return null;'
- "        int smallest = 0;\n        int largest = 0;\n        if(lst.size() != 0){\n\
  \            smallest = lst.get(0);\n            largest = lst.get(0);\n       \
  \     for(int i = 0; i < lst.size(); i++){\n                if(lst.get(i) > largest){\n\
  \                    largest = lst.get(i);\n                }\n                if(lst.get(i)\
  \ < smallest){\n                    smallest = lst.get(i);\n                }\n\
  \            }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(largest),\
  \ Optional.of(smallest));"
- "        int maxNeg = Integer.MIN_VALUE;\n        int minPos = Integer.MAX_VALUE;\n\
  \        for (int num : lst) {\n            if (num > 0 && num < minPos) {\n   \
  \             minPos = num;\n            }\n            if (num < 0 && num > maxNeg)\
  \ {\n                maxNeg = num;\n            }\n        }\n        if (minPos\
  \ == Integer.MAX_VALUE) {\n            minPos = -1;\n        }\n        if (maxNeg\
  \ == Integer.MIN_VALUE) {\n            maxNeg = -1;\n        }\n        return new\
  \ Pair<Optional<Integer>, Optional<Integer>>(maxNeg == -1 ? Optional.empty() : Optional.of(maxNeg),\
  \ minPos == -1 ? Optional.empty() : Optional.of(minPos));"
- "        Optional<Integer> largestOfNegativeIntegers = lst.stream().filter(x ->\
  \ x < 0).max(Comparator.naturalOrder());\n        Optional<Integer> smallestOfPositiveIntegers\
  \ = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largestOfNegativeIntegers, smallestOfPositiveIntegers);"
- "        // Your code here\n        return null;"
- "        // Your code here\n        return null;"
- "        Integer largest = null;\n        Integer smallest = null;\n        if (lst.size()\
  \ == 0) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        boolean containsNegative = false;\n   \
  \     boolean containsPositive = false;\n        for (Integer x : lst) {\n     \
  \       if (x < 0) {\n                containsNegative = true;\n               \
  \ if (largest == null || x > largest) {\n                    largest = x;\n    \
  \            }\n            } else if (x > 0) {\n                containsPositive\
  \ = true;\n                if (smallest == null || x < smallest) {\n           \
  \         smallest = x;\n                }\n            }\n        }\n        if\
  \ (!containsNegative) {\n            largest = null;\n        }\n        if (!containsPositive)\
  \ {\n            smallest = null;\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.ofNullable(largest), Optional.ofNullable(smallest));"
- "        Pair<Optional<Integer>, Optional<Integer>> result = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        if (lst.size()\
  \ == 0) return result;\n        ArrayList<Integer> negativeNumbers = lst.stream().filter(i\
  \ -> i < 0).collect(Collectors.toCollection(ArrayList::new));\n        ArrayList<Integer>\
  \ positiveNumbers = lst.stream().filter(i -> i > 0).collect(Collectors.toCollection(ArrayList::new));\n\
  \        if (negativeNumbers.size() > 0) result.setValue0(Optional.of(negativeNumbers.stream().mapToInt(Integer::intValue).max().getAsInt()));\n\
  \        if (positiveNumbers.size() > 0) result.setValue1(Optional.of(positiveNumbers.stream().mapToInt(Integer::intValue).min().getAsInt()));\n\
  \        return result;"
- "        Pair<Optional<Integer>, Optional<Integer>> res = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        for (Integer\
  \ i : lst) {\n            if (i > 0) {\n                if (res.getValue1().isPresent())\
  \ {\n                    if (i < res.getValue1().get()) {\n                    \
  \    res = res.setAt1(Optional.of(i));\n                    }\n                }\
  \ else {\n                    res = res.setAt1(Optional.of(i));\n              \
  \  }\n            } else if (i < 0) {\n                if (res.getValue0().isPresent())\
  \ {\n                    if (i > res.getValue0().get()) {\n                    \
  \    res = res.setAt0(Optional.of(i));\n                    }\n                }\
  \ else {\n                    res = res.setAt0(Optional.of(i));\n              \
  \  }\n            }\n        }\n        return res;"
- "        if (lst.size() < 1) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\
  \        for (int i : lst) {\n            if (i >= 0 && i < min) min = i;\n    \
  \        if (i < 0 && i > max) max = i;\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(max == Integer.MIN_VALUE ? Optional.empty() : Optional.of(max),\
  \ min == Integer.MAX_VALUE ? Optional.empty() : Optional.of(min));"
- "        Optional<Integer> oLargeInt = Optional.empty();\n        Optional<Integer>\
  \ oSmallInt = Optional.empty();\n        for (Integer i : lst) {\n            if\
  \ (i > 0) {\n                if (oSmallInt.isEmpty()) {\n                    oSmallInt\
  \ = Optional.of(i);\n                } else {\n                    if (i < oSmallInt.get())\
  \ {\n                        oSmallInt = Optional.of(i);\n                    }\n\
  \                }\n            } else if (i < 0) {\n                if (oLargeInt.isEmpty())\
  \ {\n                    oLargeInt = Optional.of(i);\n                } else {\n\
  \                    if (i > oLargeInt.get()) {\n                        oLargeInt\
  \ = Optional.of(i);\n                    }\n                }\n            }\n \
  \       }\n        return new Pair<Optional<Integer>, Optional<Integer>>(oLargeInt,\
  \ oSmallInt);"
- "        // ... implementation\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());"
- '        return null;'
- "        Optional<Integer> maxNeg = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> minPos = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(maxNeg, minPos);"
- "      Pair<Optional<Integer>, Optional<Integer>> result = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n      if (lst.size()\
  \ > 0) {\n        int maxNegative = Integer.MIN_VALUE;\n        int minPositive\
  \ = Integer.MAX_VALUE;\n        for (int num : lst) {\n          if (num < 0) {\n\
  \            maxNegative = Math.max(maxNegative, num);\n          } else if (num\
  \ > 0) {\n            minPositive = Math.min(minPositive, num);\n          }\n \
  \       }\n        result = new Pair<Optional<Integer>, Optional<Integer>>(\n  \
  \        (maxNegative != Integer.MIN_VALUE) ? Optional.of(maxNegative) : Optional.empty(),\n\
  \          (minPositive != Integer.MAX_VALUE) ? Optional.of(minPositive) : Optional.empty()\n\
  \        );\n      }\n      return result;"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(e\
  \ -> e < 0).reduce((a, b) -> b),\n            lst.stream().filter(e -> e > 0).reduce((a,\
  \ b) -> a)\n        );"
- '        return null;'
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        Collections.sort(lst);\n        Integer min = null;\n\
  \        Integer max = null;\n        for (Integer i : lst) {\n            if (i\
  \ < 0) max = i;\n            if (i > 0) {\n                min = i;\n          \
  \      break;\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.ofNullable(max), Optional.ofNullable(min));"
- "        Pair<Optional<Integer>, Optional<Integer>> p = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        if (lst.size()\
  \ < 1) return p;\n        Optional<Integer> min = Optional.of(lst.get(0));\n   \
  \     Optional<Integer> max = Optional.of(lst.get(0));\n        for (int i = 1;\
  \ i < lst.size(); i++) {\n            Integer v = lst.get(i);\n            if (v\
  \ > 0) {\n                if (v < min.get()) {\n                    min = Optional.of(v);\n\
  \                }\n            } else if (v < 0) {\n                if (v > max.get())\
  \ {\n                    max = Optional.of(v);\n                }\n            }\n\
  \        }\n        if (max.get() > 0) max = Optional.empty();\n        if (min.get()\
  \ < 0) min = Optional.empty();\n        return new Pair<Optional<Integer>, Optional<Integer>>(max,\
  \ min);"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (Integer x : lst) {\n            if\
  \ (x > 0) {\n                if (smallest.isPresent()) {\n                    if\
  \ (x < smallest.get()) {\n                        smallest = Optional.of(x);\n \
  \                   }\n                } else {\n                    smallest =\
  \ Optional.of(x);\n                }\n            } else if (x < 0) {\n        \
  \        if (largest.isPresent()) {\n                    if (x > largest.get())\
  \ {\n                        largest = Optional.of(x);\n                    }\n\
  \                } else {\n                    largest = Optional.of(x);\n     \
  \           }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(largest, smallest);"
- "        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer>\
  \ smallestPositive = Optional.empty();\n        for (Integer i : lst) {\n      \
  \      if (i < 0) {\n                if (!largestNegative.isPresent() || i > largestNegative.get())\
  \ {\n                    largestNegative = Optional.of(i);\n                }\n\
  \            } else if (i > 0) {\n                if (!smallestPositive.isPresent()\
  \ || i < smallestPositive.get()) {\n                    smallestPositive = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNegative,\
  \ smallestPositive);"
- "        ArrayList<Integer> negativeNumbers = new ArrayList<Integer>();\n      \
  \  ArrayList<Integer> positiveNumbers = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n           \
  \     negativeNumbers.add(lst.get(i));\n            } else if (lst.get(i) > 0) {\n\
  \                positiveNumbers.add(lst.get(i));\n            }\n        }\n  \
  \      Optional<Integer> a = Optional.empty();\n        Optional<Integer> b = Optional.empty();\n\
  \        if (negativeNumbers.size() > 0) {\n            int largestNegative = Collections.max(negativeNumbers);\n\
  \            a = Optional.of(largestNegative);\n        }\n        if (positiveNumbers.size()\
  \ > 0) {\n            int smallestPositive = Collections.min(positiveNumbers);\n\
  \            b = Optional.of(smallestPositive);\n        }\n        return Pair.with(a,\
  \ b);"
- "        int lNeg = Integer.MIN_VALUE;\n        int sPos = Integer.MAX_VALUE;\n\
  \        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0)\
  \ {\n                lNeg = Math.max(lNeg, lst.get(i));\n            } else if (lst.get(i)\
  \ > 0) {\n                sPos = Math.min(sPos, lst.get(i));\n            }\n  \
  \      }\n        return new Pair<Optional<Integer>, Optional<Integer>>(\n     \
  \       (lNeg == Integer.MIN_VALUE) ? Optional.empty() : Optional.of(lNeg),\n  \
  \          (sPos == Integer.MAX_VALUE) ? Optional.empty() : Optional.of(sPos)\n\
  \        );"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ largestNegativeInteger = Optional.empty();\n        Optional<Integer> smallestPositiveInteger\
  \ = Optional.empty();\n        for (Integer item : lst) {\n            if (item\
  \ < 0) {\n                if (!largestNegativeInteger.isPresent() ||\n         \
  \               largestNegativeInteger.get() < item) {\n                    largestNegativeInteger\
  \ = Optional.of(item);\n                }\n            } else if (item > 0) {\n\
  \                if (!smallestPositiveInteger.isPresent() ||\n                 \
  \       smallestPositiveInteger.get() > item) {\n                    smallestPositiveInteger\
  \ = Optional.of(item);\n                }\n            }\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largestNegativeInteger, smallestPositiveInteger);"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        boolean\
  \ found_positive = false;\n        boolean found_negative = false;\n        int\
  \ min_positive = 0;\n        int max_negative = 0;\n        for (int i = 0; i <\
  \ lst.size(); i++) {\n            if (lst.get(i) > 0) {\n                found_positive\
  \ = true;\n                if (lst.get(i) < min_positive) {\n                  \
  \  min_positive = lst.get(i);\n                }\n            } else if (lst.get(i)\
  \ < 0) {\n                found_negative = true;\n                if (lst.get(i)\
  \ > max_negative) {\n                    max_negative = lst.get(i);\n          \
  \      }\n            }\n        }\n        Optional<Integer> opt_pos = Optional.empty();\n\
  \        Optional<Integer> opt_neg = Optional.empty();\n        if (found_positive)\
  \ {\n            opt_pos = Optional.of(min_positive);\n        }\n        if (found_negative)\
  \ {\n            opt_neg = Optional.of(max_negative);\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(opt_neg, opt_pos);"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(x\
  \ -> x < 0).max(Comparator.naturalOrder()),\n            lst.stream().filter(x ->\
  \ x > 0).min(Comparator.naturalOrder())\n        );"
- "        int maxNeg = Integer.MIN_VALUE;\n        int minPos = Integer.MAX_VALUE;\n\
  \        boolean hasNeg = false;\n        boolean hasPos = false;\n        for (int\
  \ i : lst) {\n            if (i < 0) {\n                if (i > maxNeg) {\n    \
  \                maxNeg = i;\n                }\n                hasNeg = true;\n\
  \            } else if (i > 0) {\n                if (i < minPos) {\n          \
  \          minPos = i;\n                }\n                hasPos = true;\n    \
  \        }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(\n\
  \            hasNeg ? Optional.of(maxNeg) : Optional.empty(),\n            hasPos\
  \ ? Optional.of(minPos) : Optional.empty()\n        );"
- "        // write code here\n        return null;"
- "        // Your code here:\n        // try {\n        //     return new Pair<Optional<Integer>,\
  \ Optional<Integer>>();\n        // } catch (Exception e) {\n        //     throw\
  \ new RuntimeException(e);\n        // }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());"
- "        Integer small = null;\n        Integer large = null;\n        for (Integer\
  \ i : lst) {\n            if (i < 0) {\n                if (large == null || i >\
  \ large) {\n                    large = i;\n                }\n            } else\
  \ if (i > 0) {\n                if (small == null || i < small) {\n            \
  \        small = i;\n                }\n            }\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.ofNullable(large), Optional.ofNullable(small));"
- "\t\tArrayList<Integer> positives = new ArrayList<Integer>();\n\t\tArrayList<Integer>\
  \ negatives = new ArrayList<Integer>();\n\t\t\n\t\tfor (int i = 0; i < lst.size();\
  \ i++) {\n\t\t\tif (lst.get(i) > 0) {\n\t\t\t\tpositives.add(lst.get(i));\n\t\t\t\
  } else if (lst.get(i) < 0) {\n\t\t\t\tnegatives.add(lst.get(i));\n\t\t\t}\n\t\t\
  }\n\t\t\n\t\tOptional<Integer> smallest_positive = Optional.empty();\n\t\tOptional<Integer>\
  \ largest_negative = Optional.empty();\n\t\t\n\t\tif (positives.size() > 0) {\n\t\
  \t\tint min_positive = Collections.min(positives);\n\t\t\tsmallest_positive = Optional.of(min_positive);\n\
  \t\t}\n\t\t\n\t\tif (negatives.size() > 0) {\n\t\t\tint max_negative = Collections.max(negatives);\n\
  \t\t\tlargest_negative = Optional.of(max_negative);\n\t\t}\n\t\t\n\t\treturn Pair.with(largest_negative,\
  \ smallest_positive);"
- "        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer>\
  \ minPositive = Optional.empty();\n        for (Integer i : lst) {\n           \
  \ if (i >= 0) {\n                if (!minPositive.isPresent() || i < minPositive.get())\
  \ {\n                    minPositive = Optional.of(i);\n                }\n    \
  \        } else {\n                if (!maxNegative.isPresent() || i > maxNegative.get())\
  \ {\n                    maxNegative = Optional.of(i);\n                }\n    \
  \        }\n        }\n        return Pair.with(maxNegative, minPositive);"
- "        // YOUR CODE HERE\n        return null;"
- '        return null;'
- '        // your code here'
- "        //*\n        return new Pair<Optional<Integer>, Optional<Integer>>(\n \
  \           lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder()),\n  \
  \          lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder())\n    \
  \    );\n        //*/\n        /*\n        Optional<Integer> min = Optional.empty();\n\
  \        Optional<Integer> max = Optional.empty();\n        for (Integer x : lst)\
  \ {\n            if (x > 0) {\n                if (min.isPresent()) {\n        \
  \            if (x < min.get()) {\n                        min = Optional.of(x);\n\
  \                    }\n                } else {\n                    min = Optional.of(x);\n\
  \                }\n            } else if (x < 0) {\n                if (max.isPresent())\
  \ {\n                    if (x > max.get()) {\n                        max = Optional.of(x);\n\
  \                    }\n                } else {\n                    max = Optional.of(x);\n\
  \                }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(max, min);\n        //*/"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(i\
  \ -> i < 0).max(Integer::compareTo),\n            lst.stream().filter(i -> i > 0).min(Integer::compareTo)\n\
  \        );"
- "        int posNum = 0;\n        int negNum = 0;\n        int posIndex = 0;\n \
  \       int negIndex = 0;\n        int posTest = 0;\n        int negTest = 0;\n\
  \        int posCounter = 0;\n        int negCounter = 0;\n        for (int i =\
  \ 0; i < lst.size(); i++) {\n            if (lst.get(i) >= 0) {\n              \
  \  posNum = lst.get(i);\n                posIndex = i;\n                posCounter++;\n\
  \            }\n            if (lst.get(i) < 0) {\n                negNum = lst.get(i);\n\
  \                negIndex = i;\n                negCounter++;\n            }\n \
  \       }\n        if (posCounter > 0) {\n            posTest = posNum;\n      \
  \  }\n        if (negCounter > 0) {\n            negTest = negNum;\n        }\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(negTest),\
  \ Optional.of(posTest));"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ largest = lst.stream().filter(i -> i < 0).max(Integer::compare);\n        Optional<Integer>\
  \ smallest = lst.stream().filter(i -> i > 0).min(Integer::compare);\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        Optional<Integer> negMax = lst.stream().filter(v -> v < 0).max(Integer::compare);\n\
  \        Optional<Integer> posMin = lst.stream().filter(v -> v > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(negMax, posMin);"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Integer[]\
  \ lst2 = lst.toArray(new Integer[lst.size()]);\n        Arrays.sort(lst2);\n   \
  \     Integer last = lst2[lst2.length - 1];\n        Integer first = lst2[0];\n\
  \        Optional<Integer> lastOptional = last < 0 ? Optional.of(last) : Optional.empty();\n\
  \        Optional<Integer> firstOptional = first > 0 ? Optional.of(first) : Optional.empty();\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(lastOptional, firstOptional);"
- "        // Write your code here\n        int maxNeg = Integer.MIN_VALUE;\n    \
  \    int minPos = Integer.MAX_VALUE;\n        Optional<Integer> maxNegOpt = Optional.empty();\n\
  \        Optional<Integer> minPosOpt = Optional.empty();\n        if (lst.size()\
  \ > 0) {\n            for (int i = 0; i < lst.size(); i++) {\n                if\
  \ (lst.get(i) < 0) {\n                    if (lst.get(i) > maxNeg) {\n         \
  \               maxNeg = lst.get(i);\n                    }\n                } else\
  \ if (lst.get(i) > 0) {\n                    if (lst.get(i) < minPos) {\n      \
  \                  minPos = lst.get(i);\n                    }\n               \
  \ }\n            }\n            if (maxNeg != Integer.MIN_VALUE) {\n           \
  \     maxNegOpt = Optional.of(maxNeg);\n            }\n            if (minPos !=\
  \ Integer.MAX_VALUE) {\n                minPosOpt = Optional.of(minPos);\n     \
  \       }\n        }\n        return Pair.with(maxNegOpt, minPosOpt);"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        ArrayList<Integer> negatives = new ArrayList<Integer>();\n\
  \        ArrayList<Integer> positives = new ArrayList<Integer>();\n        for (Integer\
  \ i : lst) {\n            if (i > 0) {\n                positives.add(i);\n    \
  \        } else if (i < 0) {\n                negatives.add(i);\n            }\n\
  \        }\n        if (negatives.size() > 0) {\n            a = Optional.of(Collections.max(negatives));\n\
  \        }\n        if (positives.size() > 0) {\n            b = Optional.of(Collections.min(positives));\n\
  \        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(a, b);"
- "        Optional<Integer> largest_of_negative = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> smallest_of_positive = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest_of_negative,\
  \ smallest_of_positive);"
- "        // TODO: Implement this function.\n        return null;"
- "        if (lst.size() > 0) {\n            Optional<Integer> max = Optional.of(Integer.MIN_VALUE);\n\
  \            Optional<Integer> min = Optional.of(Integer.MAX_VALUE);\n         \
  \   for (Integer i : lst) {\n                if (i > 0) {\n                    if\
  \ (i < min.get()) {\n                        min = Optional.of(i);\n           \
  \         }\n                } else if (i < 0) {\n                    if (i > max.get())\
  \ {\n                        max = Optional.of(i);\n                    }\n    \
  \            }\n            }\n            if (max.get() == Integer.MIN_VALUE) {\n\
  \                max = Optional.empty();\n            }\n            if (min.get()\
  \ == Integer.MAX_VALUE) {\n                min = Optional.empty();\n           \
  \ }\n            return Pair.with(max, min);\n        } else {\n            return\
  \ Pair.with(Optional.empty(), Optional.empty());\n        }"
- "        // ???\n        return null;"
- '        return null;'
- '        throw new UnsupportedOperationException("Delete this line and replace with
  your solution.");'
- "        int[] arr = lst.stream().mapToInt(Integer::intValue).toArray();\n     \
  \   Arrays.sort(arr);\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\
  \        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] < 0) {\n\
  \                max = arr[i];\n            } else {\n                min = arr[i];\n\
  \                break;\n            }\n        }\n        min = min == Integer.MAX_VALUE\
  \ ? 0 : min;\n        max = max == Integer.MIN_VALUE ? 0 : max;\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max), Optional.of(min));"
- '        return null;'
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        if (lst.size() == 1) return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        int l = Collections.min(lst);\n\
  \        int m = Collections.max(lst);\n        Optional<Integer> pos = Optional.empty();\n\
  \        Optional<Integer> neg = Optional.empty();\n        for (int i : lst) {\n\
  \            if (i < 0) {\n                neg = Optional.of(i);\n            }\n\
  \            if (i > 0) {\n                pos = Optional.of(i);\n            }\n\
  \        }\n        if (neg.isPresent()) l = neg.get();\n        if (pos.isPresent())\
  \ m = pos.get();\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(l),\
  \ Optional.of(m));"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ min = Optional.empty();\n        Optional<Integer> max = Optional.empty();\n \
  \       for (Integer i : lst) {\n            if (i > 0) {\n                if (min.isPresent())\
  \ {\n                    if (i < min.get()) {\n                        min = Optional.of(i);\n\
  \                    }\n                } else {\n                    min = Optional.of(i);\n\
  \                }\n            } else if (i < 0) {\n                if (max.isPresent())\
  \ {\n                    if (i > max.get()) {\n                        max = Optional.of(i);\n\
  \                    }\n                } else {\n                    max = Optional.of(i);\n\
  \                }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(max, min);"
- "        return Pair.with(\n          lst.stream().filter(n -> n < 0).max(Comparator.naturalOrder()),\n\
  \          lst.stream().filter(n -> n > 0).min(Comparator.naturalOrder())\n    \
  \    );"
- "      // Your code here\n        int largestNegative = Integer.MIN_VALUE;\n   \
  \     int smallestPositive = Integer.MAX_VALUE;\n        for (int i : lst) {\n \
  \           if (i < 0 && i > largestNegative) {\n                largestNegative\
  \ = i;\n            }\n            if (i > 0 && i < smallestPositive) {\n      \
  \          smallestPositive = i;\n            }\n        }\n        Optional<Integer>\
  \ largestNegativeOptional = Optional.of(largestNegative);\n        Optional<Integer>\
  \ smallestPositiveOptional = Optional.of(smallestPositive);\n        if (largestNegative\
  \ == Integer.MIN_VALUE) {\n            largestNegativeOptional = Optional.empty();\n\
  \        }\n        if (smallestPositive == Integer.MAX_VALUE) {\n            smallestPositiveOptional\
  \ = Optional.empty();\n        }\n        return Pair.with(largestNegativeOptional,\
  \ smallestPositiveOptional);"
- "        return Pair.with(\n            lst.stream().filter(v -> v < 0).max(Comparator.naturalOrder()),\n\
  \            lst.stream().filter(v -> v > 0).min(Comparator.naturalOrder())\n  \
  \      );"
- "        Pair<Optional<Integer>, Optional<Integer>> result = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        if (lst.size()\
  \ == 0) {\n            return result;\n        }\n\n        List<Integer> negative\
  \ = lst.stream().filter(x -> x < 0).collect(Collectors.toList());\n        List<Integer>\
  \ positive = lst.stream().filter(x -> x > 0).collect(Collectors.toList());\n\n \
  \       if (negative.size() > 0) {\n            result.setValue0(Optional.of(Collections.max(negative)));\n\
  \        }\n        if (positive.size() > 0) {\n            result.setValue1(Optional.of(Collections.min(positive)));\n\
  \        }\n\n        return result;"
- "        Optional<Integer> min = lst.stream().filter(e -> e > 0).min(Integer::compare);\n\
  \        Optional<Integer> max = lst.stream().filter(e -> e < 0).max(Integer::compare);\n\
  \        if (!min.isPresent()) {\n            min = Optional.empty();\n        }\n\
  \        if (!max.isPresent()) {\n            max = Optional.empty();\n        }\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(max, min);"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        //\
  \ Find min and max values.\n        Integer min = Integer.MAX_VALUE;\n        Integer\
  \ max = Integer.MIN_VALUE;\n        for (Integer i : lst) {\n            if (i <\
  \ 0) {\n                max = Math.max(max, i);\n            } else if (i > 0) {\n\
  \                min = Math.min(min, i);\n            }\n        }\n        // Return\
  \ result.\n        if (min == Integer.MAX_VALUE) {\n            min = null;\n  \
  \      }\n        if (max == Integer.MIN_VALUE) {\n            max = null;\n   \
  \     }\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.ofNullable(max),\
  \ Optional.ofNullable(min));"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\
  \        for (Integer i : lst) {\n            if (i < 0) {\n                if (!maxNegative.isPresent()\
  \ || i > maxNegative.get()) {\n                    maxNegative = Optional.of(i);\n\
  \                }\n            } else if (i > 0) {\n                if (!minPositive.isPresent()\
  \ || i < minPositive.get()) {\n                    minPositive = Optional.of(i);\n\
  \                }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(maxNegative, minPositive);"
- "        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n  \
  \      for (int i : lst) {\n            if (i > 0 && i < min) {\n              \
  \  min = i;\n            }\n            if (i < 0 && i > max) {\n              \
  \  max = i;\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(\n                (max == Integer.MIN_VALUE) ? Optional.empty()\
  \ : Optional.of(max),\n                (min == Integer.MAX_VALUE) ? Optional.empty()\
  \ : Optional.of(min));"
- "        // throw new Exception(\"Not implemented\");\n        int biggestN = Integer.MIN_VALUE;\n\
  \        int smallestP = Integer.MAX_VALUE;\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) < 0) {\n                if (lst.get(i) > biggestN)\
  \ {\n                    biggestN = lst.get(i);\n                }\n           \
  \ } else if (lst.get(i) > 0) {\n                if (lst.get(i) < smallestP) {\n\
  \                    smallestP = lst.get(i);\n                }\n            }\n\
  \        }\n        Optional<Integer> largest = Optional.of(biggestN);\n       \
  \ Optional<Integer> smallest = Optional.of(smallestP);\n        return Pair.with(largest,\
  \ smallest);"
- "        Optional<Integer> largest = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> smallest = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        Integer max = null;\n        Integer min = null;\n        for (Integer\
  \ e : lst) {\n            if (e < 0) {\n                if (max == null || e > max)\
  \ {\n                    max = e;\n                }\n            } else if (e >\
  \ 0) {\n                if (min == null || e < min) {\n                    min =\
  \ e;\n                }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.ofNullable(max), Optional.ofNullable(min));"
- "        // Your code here...\n        return null;"
- "        Optional<Integer> largestNegativeInteger = lst.stream().filter(x -> x <\
  \ 0).max(Comparator.naturalOrder());\n        Optional<Integer> smallestPositiveInteger\
  \ = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largestNegativeInteger, smallestPositiveInteger);"
- "        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer>\
  \ smallestPositive = Optional.empty();\n        for (Integer i : lst) {\n      \
  \      if (i < 0) {\n                if (!largestNegative.isPresent() || i > largestNegative.get())\
  \ {\n                    largestNegative = Optional.of(i);\n                }\n\
  \            } else if (i > 0) {\n                if (!smallestPositive.isPresent()\
  \ || i < smallestPositive.get()) {\n                    smallestPositive = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNegative,\
  \ smallestPositive);"
- "        int largestNeg = Integer.MIN_VALUE;\n        int smallestPos = Integer.MAX_VALUE;\n\
  \        for (int i : lst) {\n            if (i < 0 && i > largestNeg) {\n     \
  \           largestNeg = i;\n            }\n            if (i > 0 && i < smallestPos)\
  \ {\n                smallestPos = i;\n            }\n        }\n        Optional<Integer>\
  \ largOp = Optional.of(largestNeg);\n        Optional<Integer> smallOp = Optional.of(smallestPos);\n\
  \        if (largestNeg == Integer.MIN_VALUE) {\n            largOp = Optional.empty();\n\
  \        }\n        if (smallestPos == Integer.MAX_VALUE) {\n            smallOp\
  \ = Optional.empty();\n        }\n        return Pair.with(largOp, smallOp);"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        int\
  \ smallest = Integer.MAX_VALUE;\n        int largest = Integer.MIN_VALUE;\n    \
  \    for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n\
  \                if (lst.get(i) > largest) {\n                    largest = lst.get(i);\n\
  \                }\n            } else if (lst.get(i) > 0) {\n                if\
  \ (lst.get(i) < smallest) {\n                    smallest = lst.get(i);\n      \
  \          }\n            }\n        }\n        if (largest == Integer.MIN_VALUE)\
  \ {\n            largest = Integer.MAX_VALUE;\n        }\n        if (smallest ==\
  \ Integer.MAX_VALUE) {\n            smallest = Integer.MIN_VALUE;\n        }\n \
  \       return new Pair<Optional<Integer>, Optional<Integer>>(\n            largest\
  \ == Integer.MAX_VALUE ? Optional.empty() : Optional.of(largest),\n            smallest\
  \ == Integer.MIN_VALUE ? Optional.empty() : Optional.of(smallest)\n        );"
- "        Optional<Integer> smallest = Optional.empty();\n        Optional<Integer>\
  \ largest = Optional.empty();\n        for (Integer i : lst) {\n            if (i\
  \ < 0) {\n                if (!largest.isPresent() || i > largest.get()) {\n   \
  \                 largest = Optional.of(i);\n                }\n            } else\
  \ if (i > 0) {\n                if (!smallest.isPresent() || i < smallest.get())\
  \ {\n                    smallest = Optional.of(i);\n                }\n       \
  \     }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(largest,\
  \ smallest);"
- "        Optional<Integer> largest_negative = null;\n        Optional<Integer> smallest_positive\
  \ = null;\n        for (Integer i : lst) {\n            if (i < 0) {\n         \
  \       if (largest_negative == null) {\n                    largest_negative =\
  \ Optional.of(i);\n                } else {\n                    if (i > largest_negative.get())\
  \ {\n                        largest_negative = Optional.of(i);\n              \
  \      }\n                }\n            } else if (i > 0) {\n                if\
  \ (smallest_positive == null) {\n                    smallest_positive = Optional.of(i);\n\
  \                } else {\n                    if (i < smallest_positive.get())\
  \ {\n                        smallest_positive = Optional.of(i);\n             \
  \       }\n                }\n            }\n        }\n        return Pair.with(largest_negative,\
  \ smallest_positive);"
- "        // Write your code here\n        return null;"
- '        return null;'
- "        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer>\
  \ smallestPositive = Optional.empty();\n        for (Integer x : lst) {\n      \
  \      if (x < 0) {\n                if (!largestNegative.isPresent() || x > largestNegative.get())\
  \ {\n                    largestNegative = Optional.of(x);\n                }\n\
  \            } else if (x > 0) {\n                if (!smallestPositive.isPresent()\
  \ || x < smallestPositive.get()) {\n                    smallestPositive = Optional.of(x);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNegative,\
  \ smallestPositive);"
- "        // ^^^ this is where your code goes ^^^\n        Integer[] array = lst.toArray(new\
  \ Integer[lst.size()]);\n        if (lst.size() == 0) {\n            return new\
  \ Pair<Optional<Integer>, Optional<Integer>>(\n                    Optional.empty(),\
  \ Optional.empty());\n        }\n        int min = Integer.MAX_VALUE;\n        int\
  \ max = Integer.MIN_VALUE;\n        for (int i = 0; i < array.length; i++) {\n \
  \           if (array[i] > 0 && array[i] < min) {\n                min = array[i];\n\
  \            }\n            if (array[i] < 0 && array[i] > max) {\n            \
  \    max = array[i];\n            }\n        }\n        if (min == Integer.MAX_VALUE)\
  \ {\n            min = Optional.empty();\n        }\n        if (max == Integer.MIN_VALUE)\
  \ {\n            max = Optional.empty();\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(\n                Optional.of(max), Optional.of(min));"
- '        return null;'
- "        // +++Your Code+++\n        return null;"
- "        // Write your code here\n        Optional<Integer> smallestPos = Optional.empty();\n\
  \        Optional<Integer> largestNeg = Optional.empty();\n        for (Integer\
  \ i : lst) {\n            if (i < 0) {\n                if (!largestNeg.isPresent()\
  \ || i > largestNeg.get()) {\n                    largestNeg = Optional.of(i);\n\
  \                }\n            } else if (i > 0) {\n                if (!smallestPos.isPresent()\
  \ || i < smallestPos.get()) {\n                    smallestPos = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNeg,\
  \ smallestPos);"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        if\
  \ (lst.size() == 1) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        Integer[] negativeNumbers = lst.stream().filter(n\
  \ -> n < 0).toArray(Integer[]::new);\n        Integer[] positiveNumbers = lst.stream().filter(n\
  \ -> n > 0).toArray(Integer[]::new);\n        Pair<Optional<Integer>, Optional<Integer>>\
  \ largestSmallest;\n        if (negativeNumbers.length > 0 && positiveNumbers.length\
  \ > 0) {\n            Arrays.sort(negativeNumbers);\n            Arrays.sort(positiveNumbers);\n\
  \            largestSmallest = new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(negativeNumbers[negativeNumbers.length\
  \ - 1]), Optional.of(positiveNumbers[0]));\n        } else if (negativeNumbers.length\
  \ > 0) {\n            Arrays.sort(negativeNumbers);\n            largestSmallest\
  \ = new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(negativeNumbers[negativeNumbers.length\
  \ - 1]), Optional.empty());\n        } else if (positiveNumbers.length > 0) {\n\
  \            Arrays.sort(positiveNumbers);\n            largestSmallest = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.of(positiveNumbers[0]));\n     \
  \   } else {\n            largestSmallest = new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        return largestSmallest;"
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        int\
  \ maxNeg = Integer.MIN_VALUE;\n        int minPos = Integer.MAX_VALUE;\n       \
  \ for (int i : lst) {\n            if (i < 0) {\n                maxNeg = Math.max(maxNeg,\
  \ i);\n            } else if (i > 0) {\n                minPos = Math.min(minPos,\
  \ i);\n            }\n        }\n        if (maxNeg == Integer.MIN_VALUE) {\n  \
  \          maxNeg = Optional.empty();\n        } else {\n            maxNeg = Optional.of(maxNeg);\n\
  \        }\n        if (minPos == Integer.MAX_VALUE) {\n            minPos = Optional.empty();\n\
  \        } else {\n            minPos = Optional.of(minPos);\n        }\n      \
  \  return new Pair<Optional<Integer>, Optional<Integer>>(maxNeg, minPos);"
- "        // we can use streams to create a sorted list without modifying the\n \
  \       // original.\n        ArrayList<Integer> sorted = new ArrayList<Integer>(lst);\n\
  \        sorted.sort(Collections.reverseOrder());\n        Optional<Integer> largest\
  \ = Optional.empty();\n        Optional<Integer> smallest = Optional.empty();\n\
  \        for (Integer i : sorted) {\n            if (i < 0) {\n                largest\
  \ = Optional.of(i);\n                break;\n            }\n        }\n        //\
  \ this time we want the smallest integers.\n        sorted.sort(Comparator.naturalOrder());\n\
  \        for (Integer i : sorted) {\n            if (i > 0) {\n                smallest\
  \ = Optional.of(i);\n                break;\n            }\n        }\n        return\
  \ Pair.with(largest, smallest);"
- "        Optional<Integer> largest = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> smallest = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- '        return null;'
- "        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer>\
  \ neg = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n   \
  \         if (lst.get(i) < 0) {\n                neg.add(lst.get(i));\n        \
  \    } else if (lst.get(i) > 0) {\n                pos.add(lst.get(i));\n      \
  \      }\n        }\n        Pair<Optional<Integer>, Optional<Integer>> result =\
  \ new Pair<>(Optional.empty(), Optional.empty());\n        if (neg.size() != 0)\
  \ {\n            Collections.sort(neg);\n            result = result.setAt0(Optional.of(neg.get(neg.size()\
  \ - 1)));\n        }\n        if (pos.size() != 0) {\n            Collections.sort(pos);\n\
  \            result = result.setAt1(Optional.of(pos.get(0)));\n        }\n     \
  \   return result;"
- "        // Initialize variables\n        Integer maxNeg = null;\n        Integer\
  \ minPos = null;\n        for (Integer x : lst) {\n            if (x < 0) {\n  \
  \              if (maxNeg == null || x > maxNeg)\n                    maxNeg = x;\n\
  \            } else if (x > 0) {\n                if (minPos == null || x < minPos)\n\
  \                    minPos = x;\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.ofNullable(maxNeg), Optional.ofNullable(minPos));"
- '        throw new RuntimeException("Not yet implemented");'
- "        // Write your code here\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());"
- "        Optional<Integer> largestOfNegatives = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> smallestOfPositives = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largestOfNegatives,\
  \ smallestOfPositives);"
- '        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),
  Optional.empty());'
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Integer[]\
  \ arr = new Integer[lst.size()];\n        lst.toArray(arr);\n        Optional<Integer>\
  \ largestNegative = Arrays.stream(arr).filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> smallestPositive = Arrays.stream(arr).filter(x -> x >\
  \ 0).min(Comparator.naturalOrder());\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(largestNegative, smallestPositive);"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(x\
  \ -> x < 0).max(Integer::compareTo),\n            lst.stream().filter(x -> x > 0).min(Integer::compareTo)\n\
  \        );"
- "        Integer maxNegative = null;\n        Integer minPositive = null;\n    \
  \    for (Integer i : lst) {\n            if (i > 0) {\n                if (minPositive\
  \ == null || i < minPositive) {\n                    minPositive = i;\n        \
  \        }\n            } else if (i < 0) {\n                if (maxNegative ==\
  \ null || i > maxNegative) {\n                    maxNegative = i;\n           \
  \     }\n            }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.ofNullable(maxNegative),\
  \ Optional.ofNullable(minPositive));"
- "        Optional<Integer> maxNeg = lst.stream().filter(e -> e < 0).max(Integer::compare);\n\
  \        Optional<Integer> minPos = lst.stream().filter(e -> e > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(maxNeg, minPos);"
- '        // ...'
- "        Optional<Integer> largestNegative;\n        Optional<Integer> smallestPositive;\n\
  \        // Your code here\n        return new Pair<Optional<Integer>, Optional<Integer>>(largestNegative,\
  \ smallestPositive);"
- '        // write your code here'
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        Optional<Integer> positive = Optional.empty();\n \
  \       Optional<Integer> negative = Optional.empty();\n        for (Integer i :\
  \ lst) {\n            if (i < 0) {\n                if (negative.isPresent()) negative\
  \ = Optional.of(Math.max(negative.get(), i));\n                else negative = Optional.of(i);\n\
  \            } else if (i > 0) {\n                if (positive.isPresent()) positive\
  \ = Optional.of(Math.min(positive.get(), i));\n                else positive = Optional.of(i);\n\
  \            }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(negative,\
  \ positive);"
- "\tOptional<Integer> op1 = Optional.empty();\n\tOptional<Integer> op2 = Optional.empty();\n\
  \tfor (int i : lst) {\n\t    if (i < 0) {\n\t\tif (op1.isPresent()) {\n\t\t    if\
  \ (i > op1.get()) {\n\t\t\top1 = Optional.of(i);\n\t\t    }\n\t\t} else {\n\t\t\
  \    op1 = Optional.of(i);\n\t\t}\n\t    } else if (i > 0) {\n\t\tif (op2.isPresent())\
  \ {\n\t\t    if (i < op2.get()) {\n\t\t\top2 = Optional.of(i);\n\t\t    }\n\t\t\
  } else {\n\t\t    op2 = Optional.of(i);\n\t\t}\n\t    }\n\t}\n\treturn new Pair<Optional<Integer>,\
  \ Optional<Integer>>(op1, op2);"
- "        Optional<Integer> a = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> b = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(a, b);"
- "        Pair<Optional<Integer>, Optional<Integer>> result = new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        Optional<Integer>\
  \ negativeMin;\n        Optional<Integer> positiveMin;\n        if (lst.size() ==\
  \ 0) {\n            return result;\n        }\n        negativeMin = lst.stream().filter(val\
  \ -> val < 0).min(Comparator.naturalOrder());\n        positiveMin = lst.stream().filter(val\
  \ -> val > 0).min(Comparator.naturalOrder());\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(negativeMin, positiveMin);"
- "        // Your code here\n        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        int size = lst.size();\n        if (size\
  \ == 0) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(largest,\
  \ smallest);\n        }\n        for (int i = 0; i < size; i++) {\n            int\
  \ val = lst.get(i);\n            if (val < 0) {\n                if (!largest.isPresent())\
  \ {\n                    largest = Optional.of(val);\n                } else {\n\
  \                    if (val > largest.get()) {\n                        largest\
  \ = Optional.of(val);\n                    }\n                }\n            } else\
  \ if (val > 0) {\n                if (!smallest.isPresent()) {\n               \
  \     smallest = Optional.of(val);\n                } else {\n                 \
  \   if (val < smallest.get()) {\n                        smallest = Optional.of(val);\n\
  \                    }\n                }\n            }\n        }\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- '        return null;'
- "        Optional<Integer> max = Optional.empty();\n        Optional<Integer> min\
  \ = Optional.empty();\n        for (Integer i : lst) {\n            if (i > 0) {\n\
  \                if (min.isPresent()) {\n                    if (i < min.get())\
  \ min = Optional.of(i);\n                } else {\n                    min = Optional.of(i);\n\
  \                }\n            } else if (i < 0) {\n                if (max.isPresent())\
  \ {\n                    if (i > max.get()) max = Optional.of(i);\n            \
  \    } else {\n                    max = Optional.of(i);\n                }\n  \
  \          }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(max,\
  \ min);"
- '        return null;'
- "        Optional<Integer> oi1 = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> oi2 = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(oi1, oi2);"
- "        //write the code here\n        return null;"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (Integer x : lst) {\n            if\
  \ (x < 0) {\n                if (!largest.isPresent() || x > largest.get()) {\n\
  \                    largest = Optional.of(x);\n                }\n            }\
  \ else if (x > 0) {\n                if (!smallest.isPresent() || x < smallest.get())\
  \ {\n                    smallest = Optional.of(x);\n                }\n       \
  \     }\n        }\n        return new Pair<Optional<Integer>, Optional<Integer>>(largest,\
  \ smallest);"
- '        // YOUR CODE HERE'
- '        return new Pair<Optional<Integer>, Optional<Integer>>(null, null);'
- "        if (lst.size() == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive\
  \ = Optional.empty();\n        for (Integer num : lst) {\n            if (num <\
  \ 0) {\n                if (!largestNegative.isPresent() || largestNegative.get()\
  \ < num) {\n                    largestNegative = Optional.of(num);\n          \
  \      }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent()\
  \ || smallestPositive.get() > num) {\n                    smallestPositive = Optional.of(num);\n\
  \                }\n            }\n        }\n        return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(largestNegative, smallestPositive);"
- "        Optional<Integer> max = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> min = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(max, min);"
- '        return null;'
- "        Optional<Integer> smallest = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        Optional<Integer> largest = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        // Remove this line, and write the function instead.\n        throw new\
  \ RuntimeException(\"Please implement the largestSmallestIntegers() function\");"
- "        Optional<Integer> a = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> b = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(a, b);"
- "        // Your code here.\n        return null;"
- "        Optional<Integer> largest_of_negative = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
  \        Optional<Integer> smallest_of_positive = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest_of_negative,\
  \ smallest_of_positive);"
- "        if (lst.size() < 1) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n\n        var negatives = new ArrayList<Integer>();\n\
  \        var positives = new ArrayList<Integer>();\n\n        for (var value : lst)\
  \ {\n            if (value > 0) {\n                positives.add(value);\n     \
  \       }\n            else if (value < 0) {\n                negatives.add(value);\n\
  \            }\n        }\n\n        var answer = new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n\n        if (negatives.size() > 0) {\n            answer.setValue0(Optional.of(Collections.max(negatives)));\n\
  \        }\n\n        if (positives.size() > 0) {\n            answer.setValue1(Optional.of(Collections.min(positives)));\n\
  \        }\n\n        return answer;"
- "        // Your code here!\n        return null;"
- "        ArrayList<Integer> neg = new ArrayList<>();\n        ArrayList<Integer>\
  \ pos = new ArrayList<>();\n        for (int i : lst) {\n            if (i < 0)\
  \ neg.add(i);\n            if (i > 0) pos.add(i);\n        }\n        if (neg.size()\
  \ == 0) neg.add(null);\n        if (pos.size() == 0) pos.add(null);\n        return\
  \ new Pair<>(Optional.of(Collections.max(neg)), Optional.of(Collections.min(pos)));"
- "        Optional<Integer> a = lst.stream().filter(i -> i < 0).max(Integer::compare);\n\
  \        Optional<Integer> b = lst.stream().filter(i -> i > 0).min(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(a, b);"
- "        Optional<Integer> smallest = lst.stream().filter(x -> x > 0).min(Integer::compare);\n\
  \        Optional<Integer> largest = lst.stream().filter(x -> x < 0).max(Integer::compare);\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer>\
  \ smallestPositive = Optional.empty();\n        for (Integer i : lst) {\n      \
  \      if (i < 0) {\n                if (!largestNegative.isPresent() || largestNegative.get()\
  \ < i) {\n                    largestNegative = Optional.of(i);\n              \
  \  }\n            } else if (i > 0) {\n                if (!smallestPositive.isPresent()\
  \ || smallestPositive.get() > i) {\n                    smallestPositive = Optional.of(i);\n\
  \                }\n            }\n        }\n        return Pair.with(largestNegative,\
  \ smallestPositive);"
- "        return new Pair<Optional<Integer>, Optional<Integer>>(\n            lst.stream().filter(x\
  \ -> x < 0).max(Comparator.naturalOrder()),\n            lst.stream().filter(x ->\
  \ x > 0).min(Comparator.naturalOrder())\n        );"
- "        if (lst.size() == 0) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        int max = 0;\n        int min = 0;\n        for (int\
  \ i : lst) {\n            if (i > 0) {\n                if (min == 0) min = i;\n\
  \                else if (i < min) min = i;\n            }\n            if (i <\
  \ 0) {\n                if (max == 0) max = i;\n                else if (i > max)\
  \ max = i;\n            }\n        }\n        if (max == 0) return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.of(min));\n        if (min == 0)\
  \ return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max), Optional.empty());\n\
  \        return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max),\
  \ Optional.of(min));"
- "        Optional<Integer> largestNegativeInteger = Optional.empty();\n        Optional<Integer>\
  \ smallestPositiveInteger = Optional.empty();\n        for (Integer integer : lst)\
  \ {\n            if (integer < 0) {\n                if (!largestNegativeInteger.isPresent()\
  \ || integer > largestNegativeInteger.get()) {\n                    largestNegativeInteger\
  \ = Optional.of(integer);\n                }\n            } else if (integer > 0)\
  \ {\n                if (!smallestPositiveInteger.isPresent() || integer < smallestPositiveInteger.get())\
  \ {\n                    smallestPositiveInteger = Optional.of(integer);\n     \
  \           }\n            }\n        }\n        return new Pair<>(largestNegativeInteger,\
  \ smallestPositiveInteger);"
- '        // Your code here'
- "        // convert list to stream\n        Stream<Integer> st = lst.stream();\n\
  \        // filter out negative numbers and collect them in an ArrayList\n     \
  \   // use Integer.MIN_VALUE so there is a default value to start\n        // with\n\
  \        ArrayList<Integer> neg = st.filter(x -> x < 0).collect(ArrayList::new,\
  \ ArrayList::add, ArrayList::addAll);\n        // filter out positive numbers and\
  \ collect them in an ArrayList\n        // use Integer.MAX_VALUE so there is a default\
  \ value to start\n        // with\n        ArrayList<Integer> pos = st.filter(x\
  \ -> x > 0).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n      \
  \  // create Optional objects for negative and positive lists\n        Optional<Integer>\
  \ negOpt = neg.stream().max(Integer::compare);\n        Optional<Integer> posOpt\
  \ = pos.stream().min(Integer::compare);\n        // check for empty lists (NONE)\
  \ and remove default values\n        if (negOpt.isPresent() && negOpt.get() == Integer.MIN_VALUE)\
  \ {\n            negOpt = Optional.empty();\n        }\n        if (posOpt.isPresent()\
  \ && posOpt.get() == Integer.MAX_VALUE) {\n            posOpt = Optional.empty();\n\
  \        }\n        // return Pair object\n        return Pair.with(negOpt, posOpt);"
- "        ArrayList<Integer> pos = new ArrayList<>();\n        ArrayList<Integer>\
  \ neg = new ArrayList<>();\n        for (int x : lst) {\n            if (x < 0)\
  \ {\n                neg.add(x);\n            } else if (x > 0) {\n            \
  \    pos.add(x);\n            }\n        }\n        Optional<Integer> smallestPos\
  \ = pos.size() == 0 ? Optional.empty() : Optional.of(Collections.min(pos));\n  \
  \      Optional<Integer> largestNeg = neg.size() == 0 ? Optional.empty() : Optional.of(Collections.max(neg));\n\
  \        return new Pair<>(largestNeg, smallestPos);"
language: java
name: HumanEval_136_largest_smallest_integers
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Create a function that returns a tuple (a, b), where 'a'\
  \ is\n    // the largest of negative integers, and 'b' is the smallest\n    // of\
  \ positive integers in a list.\n    // If there is no negative or positive integers,\
  \ return them as None.\n    // Examples:\n    // largest_smallest_integers([2, 4,\
  \ 1, 3, 5, 7]) == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n\
  \    // largest_smallest_integers([0]) == (None, None)\n    public static Pair<Optional<Integer>,\
  \ Optional<Integer>> largestSmallestIntegers(ArrayList<Integer> lst) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Integer>(Arrays.asList((int)2, (int)4, (int)1, (int)3, (int)5, (int)7)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)2,\
  \ (int)4, (int)1, (int)3, (int)5, (int)7, (int)0)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)1,\
  \ (int)3, (int)2, (int)4, (int)5, (int)6, (int)-2)))).equals(Pair.with(-2, 1)));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)4,\
  \ (int)5, (int)3, (int)6, (int)2, (int)7, (int)-7)))).equals(Pair.with(-7, 2)));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)7,\
  \ (int)3, (int)8, (int)4, (int)9, (int)2, (int)5, (int)-9)))).equals(Pair.with(-9,\
  \ 2)));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList()))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)0)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-1,\
  \ (int)-3, (int)-5, (int)-6)))).equals(Pair.with(Optional.of(-1), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-1,\
  \ (int)-3, (int)-5, (int)-6, (int)0)))).equals(Pair.with(Optional.of(-1), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-6,\
  \ (int)-4, (int)-4, (int)-3, (int)1)))).equals(Pair.with(-3, 1)));\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Integer>(Arrays.asList((int)-6, (int)-4, (int)-4, (int)-3, (int)-100,\
  \ (int)1)))).equals(Pair.with(-3, 1)));\n    }\n\n}\n"
