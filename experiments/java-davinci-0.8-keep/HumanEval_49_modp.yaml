completions:
- "        if (n == 0) return 1;\n        long ans = modp(n/2, p);\n        ans =\
  \ (ans * ans) % p;\n        if (n % 2 == 1) ans = (ans * 2) % p;\n        return\
  \ (int) ans;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            return square(modp(n\
  \ / 2, p)) % p;\n        } else {\n            return (square(modp(n / 2, p)) *\
  \ 2) % p;\n        }"
- "        int s = 1;\n        int r = 0;\n        for (int i = 0; i < 32; i++) {\n\
  \            if ((n & 1) == 1)\n                r = (r + s) % p;\n            s\
  \ = (s + s) % p;\n            n >>= 1;\n        }\n        return r;"
- "        // TODO: implement this function.\n        return 0;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return 2;\n        }\n        long half = modp(n/2, p);\n        if\
  \ (n % 2 == 0) {\n            return (int)((half * half) % p);\n        } else {\n\
  \            return (int)((half * half * 2) % p);\n        }"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n   \
  \         return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int tmp = modp(n / 2, p);\n            return (tmp * tmp) % p;\n  \
  \      } else {\n            return (2 * modp(n - 1, p)) % p;\n        }"
- "        if (n == 0) return 1;\n        int l = modp(n / 2, p);\n        int r =\
  \ (int) ((long) l * l % p);\n        if (n % 2 == 1) r = (int) ((long) r * 2 % p);\n\
  \        return r;"
- "        int a = 1;\n        for (int i = 0; i < n; i++) {\n            a = (a *\
  \ 2) % p;\n        }\n        return a;"
- "        if (n == 0) {\n            return 1;\n        }\n        // My original\
  \ method that was very slow.  I was too\n        // hung up on the mod operator.\n\
  \        // int m = modp(n/2, p);\n        // return (2*m) % p * (n%2 == 0 ? 1 :\
  \ modp(n-1, p)) % p;\n        // What I should have done:\n        int m = modp(n/2,\
  \ p);\n        return (2*m) % p * (n%2 == 0 ? 1 : m) % p;"
- "        int product = 1;\n        for (int i = 0; i < n; i++) {\n            product\
  \ = (product * 2) % p;\n        }\n        return product;"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\
  \ {\n                result = (result * 2) % p;\n            }\n            n >>=\
  \ 1;\n        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        int[] facts =\
  \ {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,\
  \ 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432,\
  \ 67108864, 134217728, 268435456, 536870912, 1073741824};\n        int j = 0;\n\
  \        while (n >= facts[j]) {\n            j++;\n        }\n        int acc =\
  \ 1;\n        for (int i = j - 1; i >= 0; i--) {\n            acc = (acc * acc)\
  \ % p;\n            if (n >= facts[i]) {\n                n -= facts[i];\n     \
  \           acc = (acc * 2) % p;\n            }\n        }\n        return acc;"
- "        // TODO: add your code here\n        return -1;"
- "        int a = 1;\n        for (int i = 0; i < n; i++) {\n            a = a *\
  \ 2 % p;\n        }\n        return a;"
- "        BigInteger result = BigInteger.valueOf(2).modPow(BigInteger.valueOf(n),\
  \ BigInteger.valueOf(p));\n        return result.intValue();"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n\
  \                result = (result * 2) % p;\n            n >>= 1;\n        }\n \
  \       return result;"
- "        assert n >= 0;\n        assert p >= 1;\n        if (n == 0) {\n       \
  \     return 1;\n        }\n        int ans = 1;\n        for (int i = 0; i < n;\
  \ i++) {\n            ans = (ans * 2) % p;\n        }\n        return ans;"
- "        int a = 1;\n        for (int i = 0; i < n; i++)\n            a = (2 * a)\
  \ % p;\n        return a;"
- "        // this implementation is O(log n) instead of O(n).\n        int res =\
  \ 1;\n        int base = 2;\n        while (n > 0) {\n            if (n % 2 == 1)\
  \ {\n                res = (res * base) % p;\n            }\n            base =\
  \ (base * base) % p;\n            n /= 2;\n        }\n        return res;"
- "        if (n == 0) return 1;\n        int a = modp(n/2, p);\n        a = (a *\
  \ a) % p;\n        if (n % 2 == 1) a = (a * 2) % p;\n        return a;"
- "        assert n >= 0;\n        assert p >= 2;\n        if (n < p) {\n        \
  \    return n;\n        }\n        if (n % 2 == 0) {\n            return (modp(n\
  \ / 2, p) * modp(n / 2, p)) % p;\n        } else {\n            return (modp(n /\
  \ 2, p) * modp(n / 2, p) * 2) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n\
  \            return 2 * modp(n - 1, p) % p;\n        }"
- "        // TODO: Implement this method\n        int power = n;\n        int result\
  \ = 1;\n        while (power > 0) {\n            if ((power & 1) == 1) {\n     \
  \           result = (result * n) % p;\n            }\n            n = (n * n) %\
  \ p;\n            power >>= 1;\n        }\n        return result;"
- "        int a = 1;\n        int b = 2;\n        while (n > 0) {\n            if\
  \ (n % 2 == 1) {\n                a = (a * b) % p;\n            }\n            b\
  \ = (b * b) % p;\n            n = n / 2;\n        }\n        return a;"
- "        if (n == 0) {\n            return 1;\n        }\n        else if (n % 2\
  \ == 0) {\n            int val = modp(n / 2, p);\n            return (val * val)\
  \ % p;\n        }\n        else {\n            return (modp(n - 1, p) * 2) % p;\n\
  \        }"
- "        if (n == 0) return 1;\n        int res = modp(n/2, p);\n        res = (res\
  \ * res) % p;\n        if (n % 2 == 1) res = (res * 2) % p;\n        return res;"
- "        int q = p - 2;\n        int x = 1;\n        int y = n;\n        while (q\
  \ > 0) {\n            if (q % 2 == 1) {\n                x = (x * y) % p;\n    \
  \        }\n            y = (y * y) % p;\n            q = q / 2;\n        }\n  \
  \      return x;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        long tmp\
  \ = modp(n / 2, p);\n        if (n % 2 == 0) return (int) ((tmp * tmp) % p);\n \
  \       else return (int) ((2 * tmp * tmp) % p);"
- "        int a = 1;\n        int e = n;\n        while (e > 0) {\n            if\
  \ ((e & 1) != 0) {\n                a = (a * n) % p;\n            }\n          \
  \  n = (n * n) % p;\n            e >>= 1;\n        }\n        return a;"
- "        int res = 1;\n        for (int i = 0; i < n; i++) {\n            res =\
  \ (res * 2) % p;\n        }\n        return res;"
- "        if (n == 0) return 1;\n        int x = modp(n/2, p);\n        if (n % 2\
  \ == 0) return (x * x) % p;\n        else return (x * x * 2) % p;"
- "        if (n == 0) {\n            return 1;\n        }\n        int m = (n % p);\n\
  \        return ((m * modp(n / 2, p)) % p) * (n % 2 == 0 ? 1 : p);"
- "        if (n == 0) return 1;\n        long res = modp(n / 2, p);\n        res\
  \ = (res * res) % p;\n        if (n % 2 != 0) res = (res * 2) % p;\n        return\
  \ (int) res;"
- "        assert (p > 0);\n        assert (n >= 0);\n        assert (n < 10_000_000);\n\
  \n        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return 2;\n        }\n        assert (n >= 2);\n        int res = 2\
  \ * modp(n - 1, p);\n        res %= p;\n        return res;"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
  \                res = (res * 2) % p;\n            }\n            n = n >> 1;\n\
  \        }\n        return res;"
- "        if (n < 0) {\n            return -1;\n        }\n        int res = 1;\n\
  \        int r = n;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n\
  \                res = (res * n) % p;\n            }\n            n = (n * n) %\
  \ p;\n            r = r >> 1;\n        }\n        return res;"
- "        int res = 1;\n        int cur = 2;\n        while (n > 0) {\n         \
  \   if ((n & 1) == 1) {\n                res = (int)(((long)res * cur) % p);\n \
  \           }\n            cur = (int)(((long)cur * cur) % p);\n            n >>=\
  \ 1;\n        }\n        return res;"
- "        int r = 1;\n        for (int i = 0; i < n; i++) {\n            r = r *\
  \ 2 % p;\n        }\n        return r;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        if (n % 2\
  \ == 0) {\n            int x = modp(n / 2, p);\n            return (x * x) % p;\n\
  \        } else {\n            return (2 * modp(n - 1, p)) % p;\n        }"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        int half = modp(n/2,\
  \ p);\n        int quarter = modp(n/4, p);\n        int halfsquared = (int) ((long)\
  \ half * half % p);\n        if (n % 2 == 0) {\n            return halfsquared;\n\
  \        } else if (n % 4 == 1) {\n            return (int) ((long) halfsquared\
  \ * 2 % p);\n        } else {\n            return (int) ((long) halfsquared * 4\
  \ % p);\n        }"
- "        if (n == 0) return 1;\n        int ans = 1;\n        for (int i = 0; i\
  \ < n; i++) {\n            ans = (ans * 2) % p;\n        }\n        return ans;"
- "        int r = 1;\n        for (int i = 0; i < n; i++) {\n            r = (r *\
  \ 2) % p;\n        }\n        return r;"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n\
  \                result = (result * 2) % p;\n            n >>= 1;\n        }\n \
  \       return result;"
- '        return mod(new BigInteger(String.valueOf(n)), new BigInteger(String.valueOf(p))).intValue();'
- "        int b = 2;\n        int r = 1;\n        while (n > 0) {\n            if\
  \ ((n & 1) == 1) {\n                r = (r * b) % p;\n            }\n          \
  \  b = (b * b) % p;\n            n >>= 1;\n        }\n        return r;"
- "        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret =\
  \ (ret * 2) % p;\n        }\n        return ret;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        return ((2*modp(n-1,\
  \ p)) % p);"
- "        int r = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n  \
  \              r = (r * 2) % p;\n            n >>= 1;\n        }\n        return\
  \ r;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            return modp(n\
  \ / 2, p) * modp(n / 2, p) % p;\n        } else {\n            return modp(n / 2,\
  \ p) * modp(n / 2, p) * 2 % p;\n        }"
- "        int r = 1;\n        for (int i = 0; i < n; i++) {\n            r = r *\
  \ 2 % p;\n        }\n        return r;"
- "        if (n == 0) return 1;\n        int tmp = modp(n / 2, p);\n        return\
  \ (2 * tmp) % p;"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int half = modp(n / 2, p);\n            return (half * half) % p;\n\
  \        } else {\n            return (2 * modp(n - 1, p)) % p;\n        }"
- "        int a = 1;\n        for (int i = 0; i < n; i++)\n            a = (a * 2)\
  \ % p;\n        return a;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int t = modp(n\
  \ / 2, p);\n            return t * t % p;\n        } else {\n            return\
  \ (2 * modp(n - 1, p)) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int t = modp(n / 2, p);\n            return (int) ((long) t * t\
  \ % p);\n        }\n        return (int) ((long) modp(n - 1, p) * n % p);"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int x = modp(n / 2, p);\n            return x * x % p;\n        } else\
  \ {\n            return modp(n - 1, p) * 2 % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        int recurse =\
  \ modp(n/2, p);\n        recurse = (recurse * recurse) % p;\n        if (n % 2 ==\
  \ 1) {\n            recurse = (recurse * 2) % p;\n        }\n        return recurse;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n\
  \            return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }"
- "        if (n == 0) return 1;\n        return (2 * modp(n - 1, p)) % p;"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int x = modp(n / 2, p);\n            return (x * x) % p;\n        }\
  \ else {\n            return (2 * modp(n - 1, p)) % p;\n        }"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n\
  \                result = (result * 2) % p;\n            n = n >> 1;\n        }\n\
  \        return result;"
- "        if (n == 0) return 1;\n        long r = modp(n/2, p);\n        r = (r*r)\
  \ % p;\n        if (n % 2 == 1) r = (r*2) % p;\n        return (int) r;"
- "        BigInteger N = BigInteger.valueOf(n);\n        BigInteger P = BigInteger.valueOf(p);\n\
  \        return N.modPow(BigInteger.valueOf(2), P).intValue();"
- "        int a = 1;\n        for (int i = 0; i < n; i++)\n            a = (a * 2)\
  \ % p;\n        return a;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int x = modp(n\
  \ / 2, p);\n            return (x * x) % p;\n        } else {\n            return\
  \ (2 * modp(n - 1, p)) % p;\n        }"
- "        int res = 1;\n        int base = 2;\n        while (n > 0) {\n        \
  \    if (n % 2 == 1) {\n                res = (res * base) % p;\n            }\n\
  \            base = (base * base) % p;\n            n /= 2;\n        }\n       \
  \ return res;"
- '        return (int) (BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(p))).intValue();'
- "        int res = 1;\n        int pow = n;\n        while (pow > 0) {\n       \
  \     if ((pow & 1) != 0) {\n                res = (res * n) % p;\n            }\n\
  \            n = (n * n) % p;\n            pow >>= 1;\n        }\n        return\
  \ res;"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int t = modp(n / 2, p);\n            return (int) (((long) t * t) %\
  \ p);\n        } else {\n            return (int) (((long) modp(n - 1, p) * n) %\
  \ p);\n        }"
- '        return (int) Math.pow(2, n) % p;'
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        return (int)\
  \ (Math.pow(2, modp(n - 1, p)) % p);"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return 2;\n        }\n        int res = 1;\n        for (int i = 0;\
  \ i < n; i++) {\n            res = (2 * res) % p;\n        }\n        return res;"
- "        if (n == 0) {\n            return 1;\n        }\n        int prod = 1;\n\
  \        for (int i = 0; i < n; i++) {\n            prod = prod * 2;\n         \
  \   prod = prod % p;\n        }\n        return prod;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        int ans = 1;\n        int base = 2;\n        while (n > 0) {\n        \
  \    if (n % 2 == 1) {\n                ans = (ans * base) % p;\n            }\n\
  \            base = (base * base) % p;\n            n /= 2;\n        }\n       \
  \ return ans;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int t = modp(n / 2, p);\n            return (int) ((long) t * t\
  \ % p);\n        }\n        return (int) ((long) modp(n - 1, p) * n % p);"
- '        return modp(n, p, 1);'
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        if (n % 2\
  \ == 0) {\n            int temp = modp(n / 2, p);\n            return (temp * temp)\
  \ % p;\n        } else {\n            return (2 * modp(n - 1, p)) % p;\n       \
  \ }"
- "        int result = 1;\n        int power = n % (p - 1);\n        int base = 2;\n\
  \        while (power > 0) {\n            if (power % 2 == 1) {\n              \
  \  result = (result * base) % p;\n            }\n            base = (base * base)\
  \ % p;\n            power = power / 2;\n        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        else if (n % 2\
  \ == 0) {\n            int res = modp(n / 2, p);\n            return (res * res)\
  \ % p;\n        }\n        else {\n            return (2 * modp(n - 1, p)) % p;\n\
  \        }"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        int res = 1;\n        for (int i = 0; i < n; i++) {\n            res =\
  \ (res * 2) % p;\n        }\n        return res;"
- "        if (n == 0) {\n            return 1;\n        }\n        int x = modp(n\
  \ / 2, p);\n        if (n % 2 == 0) {\n            return (x * x) % p;\n       \
  \ } else {\n            return (x * x * 2) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int l = modp(n / 2, p);\n            return (l * l) % p;\n    \
  \    } else {\n            return (modp(n - 1, p) * 2) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        int r = modp(n\
  \ / 2, p);\n        if (n % 2 == 0) {\n            r = (r * r) % p;\n        } else\
  \ {\n            r = (r * r * 2) % p;\n        }\n        return r;"
- "        // TODO: implement\n        if (n == 0) return 1;\n        int a = modp(n/2,\
  \ p);\n        a = (a * a) % p;\n        if (n % 2 == 1) a = (a * 2) % p;\n    \
  \    return a;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        int half\
  \ = modp(n/2, p);\n        long res = (long)half * half;\n        res %= p;\n  \
  \      if (n % 2 == 1) {\n            res *= 2;\n            res %= p;\n       \
  \ }\n        return (int)res;"
- "        int res = 1;\n        for (int b = 0; b < n; b++) {\n            res =\
  \ (2 * res) % p;\n        }\n        return res;"
- "        int r = 1;\n        for (int i = 0; i < n; i++) {\n            r = r *\
  \ 2 % p;\n        }\n        return r;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret =\
  \ (ret * 2) % p;\n        }\n        return ret;"
- "        if (n == 0) {\n            return 1;\n        }\n        int result = 1;\n\
  \        for (int i = 0; i < n; i++) {\n            result = result * 2 % p;\n \
  \       }\n        return result;"
- "        int x = 1;\n        while (n > 0) {\n            if ((n & 1) != 0)\n  \
  \              x = (x * 2) % p;\n            n >>= 1;\n        }\n        return\
  \ x;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int half = modp(n / 2, p);\n            return half * half % p;\n\
  \        } else {\n            return modp(n - 1, p) * 2 % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int x = modp(n / 2, p);\n            return x * x % p;\n        } else\
  \ {\n            return modp(n - 1, p) * 2 % p;\n        }"
- "        // complete this function\n        int s = 1;\n        while (n > 0) {\n\
  \            s = s * 2 % p;\n            n--;\n        }\n        return s;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        int res =\
  \ modp(n/2, p);\n        res = res * res % p;\n        if (n % 2 == 1) res = res\
  \ * 2 % p;\n        return res;"
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be\
  \ a non-negative integer.\");\n        }\n        if (p <= 0) {\n            throw\
  \ new IllegalArgumentException(\"p must be a positive integer.\");\n        }\n\
  \        if (n == 0) {\n            return 1;\n        }\n        BigInteger res\
  \ = BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(p));\n\
  \        return res.intValue();"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int x = modp(n\
  \ / 2, p);\n            return (x * x) % p;\n        } else {\n            return\
  \ (2 * modp(n - 1, p)) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        long mod = modp(n\
  \ / 2, p);\n        mod = (mod * mod) % p;\n        if (n % 2 == 1) {\n        \
  \    mod = (mod * 2) % p;\n        }\n        return (int) mod;"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\
  \ {\n                result = (result * 2) % p;\n            }\n            n >>=\
  \ 1;\n        }\n        return result;"
- "        int r = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
  \                r = r * 2 % p;\n            }\n            n >>= 1;\n         \
  \   if (n > 0) {\n                int x = r * r % p;\n                if (x == 1\
  \ && r != 1 && r != p - 1) {\n                    throw new AssertionError();\n\
  \                }\n                r = x;\n            }\n        }\n        return\
  \ r;"
- "        int prod = 1;\n        for (int i = 0; i < n; i++) {\n            prod\
  \ = (prod * 2) % p;\n        }\n        return prod;"
- "        int r = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
  \                r = (r * 2) % p;\n            }\n            n >>= 1;\n       \
  \ }\n        return r;"
- "        int r = 1;\n        int e = n;\n        while (true) {\n            if\
  \ (e % 2 == 1) {\n                r = (r * n) % p;\n            }\n            e\
  \ /= 2;\n            if (e == 0) {\n                break;\n            }\n    \
  \        n = (n * n) % p;\n        }\n        return r;"
- "        int q = n/p;\n        int r = n - q*p;\n        return r;"
- "        if (n == 0) {\n            return 1;\n        }\n        int ret = modp(n\
  \ / 2, p);\n        ret = (ret * ret) % p;\n        if (n % 2 == 1) {\n        \
  \    ret = (ret * 2) % p;\n        }\n        return ret;"
- "        int x = 1;\n        int y = n;\n        while (p > 0) {\n            if\
  \ ((p & 1) == 1) {\n                x = (x * y) % 998244353;\n            }\n  \
  \          y = (y * y) % 998244353;\n            p = p >> 1;\n        }\n      \
  \  return x;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int t = modp(n / 2, p);\n            return (int) ((long) t * t\
  \ % p);\n        }\n        return (int) ((long) modp(n - 1, p) * n % p);"
- "        if (n == 0) return 1;\n        int res = modp(n / 2, p);\n        if (n\
  \ % 2 == 0) {\n            return (res * res) % p;\n        } else {\n         \
  \   return (res * res * 2) % p;\n        }"
- "        if (n == 0) return 1;\n        int i = modp(n/2, p);\n        i = (i *\
  \ i) % p;\n        if (n % 2 == 1) i = (i * 2) % p;\n        return i;"
- "        int res = 1;\n        int a = 2;\n        for (int i = 0; i < n; i++) {\n\
  \            res = (res * a) % p;\n        }\n        return res;"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int t = modp(n / 2, p);\n            return t * t % p;\n        } else\
  \ {\n            return 2 * modp(n - 1, p) % p;\n        }"
- "        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret =\
  \ (ret * 2) % p;\n        }\n        return ret;"
- "        int n3 = n;\n        while (n3 > 1) {\n            if (n3 % 2 == 1) {\n\
  \                n3 = (3 * n3 + 1) / 2;\n            } else {\n                n3\
  \ /= 2;\n            }\n        }\n        if (n3 == 0) {\n            return 1;\n\
  \        }\n        return n3;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        // Slow version -- not efficient enough for Hackerrank.\n        // return\
  \ BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(p)).intValue();\n\
  \        int acc = 1;\n        int cur = 2;\n        while (n > 0) {\n         \
  \   if ((n & 1) == 1)\n                acc = (acc * cur) % p;\n            cur =\
  \ (cur * cur) % p;\n            n /= 2;\n        }\n        return acc;"
- "        int[] m = new int[33];\n        m[0] = 1;\n        for (int i = 1; i <\
  \ 33; i++) {\n            m[i] = (m[i - 1] * 2) % p;\n        }\n        int x =\
  \ 1;\n        for (int i = 0; i < 32; i++) {\n            if ((n & (1 << i)) !=\
  \ 0) {\n                x = (x * m[i]) % p;\n            }\n        }\n        return\
  \ x;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        if (n % 2\
  \ == 0) {\n            int tmp = modp(n / 2, p);\n            return (tmp * tmp)\
  \ % p;\n        } else {\n            return (2 * modp(n - 1, p)) % p;\n       \
  \ }"
- "        if (n == 0) return 1;\n        int square = modp(n / 2, p);\n        int\
  \ b = square * square % p;\n        if (n % 2 == 1) {\n            b = b * 2 % p;\n\
  \        }\n        return b;"
- "        BigInteger a = BigInteger.valueOf(2);\n        BigInteger b = BigInteger.valueOf(n);\n\
  \        BigInteger c = BigInteger.valueOf(p);\n        BigInteger d = a.modPow(b,\
  \ c);\n        return d.intValue();"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int t = modp(n / 2, p);\n            return t * t % p;\n      \
  \  } else {\n            return 2 * modp(n - 1, p) % p;\n        }"
- "        // See: https://en.wikipedia.org/wiki/Modular_exponentiation\n        if\
  \ (n == 0) return 1;\n        if (n == 1) return 2;\n        return modp(n / 2,\
  \ p) * modp(n - n / 2, p) % p;"
- "        int ret = 1;\n        int exp = n;\n        int base = 2;\n        while\
  \ (exp > 0) {\n            if (exp % 2 == 1) {\n                ret = (ret * base)\
  \ % p;\n            }\n            base = (base * base) % p;\n            exp /=\
  \ 2;\n        }\n        return ret;"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        int q = modp(n\
  \ / 2, p);\n        if (n % 2 == 0) {\n            return (q * q) % p;\n       \
  \ } else {\n            return (2 * q * q) % p;\n        }"
- "        if (n == 0) return 1;\n        int half = modp(n / 2, p);\n        int\
  \ halfp = (int) ((long) half * half % p);\n        return (n % 2 == 0) ? halfp :\
  \ (int) ((long) halfp * 2 % p);"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int sub =\
  \ modp(n / 2, p);\n            return (int) (1L * sub * sub % p);\n        } else\
  \ {\n            return (int) (1L * modp(n - 1, p) * n % p);\n        }"
- "        // Implement the algorithm in the following paper:\n        // Efficient\
  \ Algorithms for Computing (a+b)^n,(a-b)^n and a^n+b^n\n        // R. J. McEliece\
  \ and S. Plouffe\n        // http://www.ams.org/tran/1994-286-01/S0002-9947-1994-1222157-5/S0002-9947-1994-1222157-5.pdf\n\
  \        // Note: to read this paper, you need to know something about \"Computational\
  \ Algebra\".\n        // But the algorithm here is simple enough to understand:\n\
  \        // you can think of it as a recursive algorithm;\n        // or you can\
  \ think of it as a divide-and-conquer algorithm.\n        // (a+b)^n = a^n + b^n\
  \ + 2*n*(a*b)^(n/2) + 2*(a*b)^(n/2)\n        // and the algorithm begins with a\
  \ check:\n        // if n is even, then (a+b)^n = a^n + b^n + 2*n*(a*b)^(n/2)\n\
  \        // if n is odd, then (a+b)^n = a^n + b^n + 2*n*(a*b)^(n/2) + 2*(a*b)^(n/2)\n\
  \        // and we can recursively compute (a*b)^(n/2).\n        if (n == 0) {\n\
  \            return 1;\n        }\n        if (n % 2 == 0) {\n            int anb\
  \ = modp(n / 2, p);\n            return (anb * anb + anb * anb) % p;\n        }\
  \ else {\n            int anb = modp(n / 2, p);\n            return (anb * anb +\
  \ anb * anb + anb + anb) % p;\n        }"
- "        int res = 1;\n        int cur = 2;\n        while (n > 0) {\n         \
  \   if ((n & 1) != 0) {\n                res = (int)((long)res * cur % p);\n   \
  \         }\n            cur = (int)((long)cur * cur % p);\n            n >>= 1;\n\
  \        }\n        return res;"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        if (n == 0) {\n            return 1;\n        }\n        int c = modp(n\
  \ / 2, p);\n        if (n % 2 == 0) {\n            return (c * c) % p;\n       \
  \ } else {\n            return (c * c * 2) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n   \
  \         return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }"
- "        BigInteger nbig = BigInteger.valueOf(n);\n        return nbig.modPow(BigInteger.valueOf(2),\
  \ BigInteger.valueOf(p)).intValue();"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int half = modp(n / 2, p);\n            return half * half % p;\n\
  \        } else {\n            return 2 * modp(n - 1, p) % p;\n        }"
- "        BigInteger N = BigInteger.valueOf(n);\n        BigInteger P = BigInteger.valueOf(p);\n\
  \        BigInteger E = BigInteger.valueOf(2);\n        BigInteger R = N.modPow(E,\
  \ P);\n        return R.intValue();"
- "        if (n == 0) {\n            return 1;\n        }\n        int half = modp(n\
  \ / 2, p);\n        int halfhalf = (int) ((long) half * half % p);\n        return\
  \ n % 2 == 0 ? halfhalf : (int) ((long) halfhalf * 2 % p);"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int r = modp(n / 2, p);\n            return (r * r) % p;\n    \
  \    } else {\n            return (2 * modp(n - 1, p)) % p;\n        }"
- "        if (n < p) {\n            return n;\n        }\n        if (n % 2 == 0)\
  \ {\n            int a = modp(n / 2, p);\n            return (2 * a) % p;\n    \
  \    } else {\n            int a = modp(n / 2, p);\n            return (2 * a +\
  \ p - 1) % p;\n        }"
- "        int res = 1;\n        for (int i = 0; i < n; i++) {\n            res =\
  \ (res * 2) % p;\n        }\n        return res;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        if (n % 2\
  \ == 0) return modp(n/2, p) * modp(n/2, p) % p;\n        return 2 * modp(n-1, p)\
  \ % p;"
- "        if (n == 0) return 1;\n        long x = modp(n/2, p);\n        x = (x *\
  \ x) % p;\n        if (n % 2 == 1) x = (x * 2) % p;\n        return (int) x;"
- "        int result = 1;\n        for (int i = 0; i < n; i++) {\n            result\
  \ = (result * 2) % p;\n        }\n        return result;"
- "        int k = 1;\n        for (int i = 0; i < n; i++)\n            k = (k * 2)\
  \ % p;\n        return k;"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int r = modp(n / 2, p);\n            return (r * r) % p;\n        }\
  \ else {\n            return (modp(n - 1, p) * n) % p;\n        }"
- "        // Fill in code here.\n        int res = 1;\n        int a = 2;\n     \
  \   while (n > 0) {\n            if (n % 2 == 1) {\n                res = (res *\
  \ a) % p;\n            }\n            a = (a * a) % p;\n            n = n / 2;\n\
  \        }\n        return res;"
- "        if (n == 0) return 1;\n        int ans = 1;\n        for (int i = 0; i\
  \ < n; i++) {\n            ans = (2 * ans) % p;\n        }\n        return ans;"
- "        int[][] M = {{1,1},{1,0}};\n        int[][] v = {{1},{0}};\n        int[][]\
  \ r = id(M.length);\n        int x = n;\n        while (x > 0) {\n            if\
  \ (x % 2 == 1) {\n                r = mult(r, M);\n            }\n            M\
  \ = mult(M, M);\n            x /= 2;\n        }\n        r = mult(r, v);\n     \
  \   return r[0][0];"
- '        return BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(p)).intValue();'
- "        if (n == 0) {\n            return 1;\n        }\n        int prod = 1;\n\
  \        while (n > 0) {\n            if ((n & 1) == 1) {\n                prod\
  \ = (prod * 2) % p;\n            }\n            n >>= 1;\n        }\n        return\
  \ prod;"
- "        assert p >= 2;\n        int a = 1;\n        int b = 2;\n        for (int\
  \ i = 0; i < n; i++) {\n            a = (a * b) % p;\n        }\n        return\
  \ a;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int x = modp(n\
  \ / 2, p);\n            return (x * x) % p;\n        } else {\n            return\
  \ (2 * modp(n - 1, p)) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int x = modp(n / 2, p);\n            return ((x * x) % p);\n  \
  \      } else {\n            return ((2 * modp(n - 1, p)) % p);\n        }"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int x = modp(n\
  \ / 2, p);\n            return (x * x) % p;\n        } else {\n            return\
  \ (modp(n - 1, p) * n) % p;\n        }"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        int x = modp(n\
  \ / 2, p);\n        x = (int) ((x * x) % p);\n        if (n % 2 == 1) x = (int)\
  \ ((x * 2) % p);\n        return x;"
- '        return BigInteger.valueOf(2).modPow(BigInteger.valueOf(n), BigInteger.valueOf(p)).intValue();'
- "        int[] bin = new int[32];\n        int len = 0;\n        while (n > 0) {\n\
  \            bin[len++] = n & 1;\n            n >>= 1;\n        }\n        int result\
  \ = 1;\n        for (int i = len - 1; i >= 0; i--) {\n            result = result\
  \ * result % p;\n            if (bin[i] == 1)\n                result = result *\
  \ 2 % p;\n        }\n        return result;"
- "        assert (p > 0);\n        assert (n >= 0);\n        return BigInteger.valueOf(2).modPow(BigInteger.valueOf(n),\
  \ BigInteger.valueOf(p)).intValue();"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            int sq = modp(n / 2, p);\n            return (sq * sq) % p;\n \
  \       } else {\n            return (modp(n - 1, p) * n) % p;\n        }"
- "        int res = 1;\n        int pow = n;\n        while (pow > 0) {\n       \
  \     if ((pow & 1) == 1) {\n                res = (res * n) % p;\n            }\n\
  \            n = (n * n) % p;\n            pow >>= 1;\n        }\n        return\
  \ res;"
- "        if (n == 0) {\n            return 1;\n        }\n        int y = 1;\n \
  \       int x = (n % p) % 2 == 0 ? 2 : 3;\n        for (int i = n / 2; i > 0; i\
  \ /= 2) {\n            if (i % 2 == 1) {\n                y = (y * x) % p;\n   \
  \         }\n            x = (x * x) % p;\n        }\n        return y;"
- "        int result = 1;\n        int power = n % (p - 1);\n        int multiplier\
  \ = n;\n        while (power > 0) {\n            if (power % 2 == 1) {\n       \
  \         result = (result * multiplier) % p;\n            }\n            multiplier\
  \ = (multiplier * multiplier) % p;\n            power /= 2;\n        }\n       \
  \ return result % p;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) return modp(n / 2, p) *\
  \ modp(n / 2, p) % p;\n        return 2 * modp(n - 1, p) % p;"
- "        if (n == 0) return 1;\n        int res = 1;\n        int cur = 2;\n   \
  \     while (n > 0) {\n            if ((n & 1) != 0) res = (int)(((long)res * cur)\
  \ % p);\n            cur = (int)(((long)cur * cur) % p);\n            n >>= 1;\n\
  \        }\n        return res;"
- "        // Implement this function yourself\n        return 0;"
- "        int a = 1;\n        int b = 2;\n        for (int i = 0; i < n; i++) {\n\
  \            a = (a * b) % p;\n        }\n        return a;"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        if (n < 0)\n            throw new RuntimeException(\"Negative exponents\
  \ not supported.\");\n        if (n == 0)\n            return 1;\n        int a\
  \ = modp(n / 2, p);\n        if (n % 2 == 0)\n            return (a * a) % p;\n\
  \        else\n            return (a * a * 2) % p;"
- "        int ans = 1;\n        int i = 1;\n        while (i <= n) {\n          \
  \  ans = ans * 2 % p;\n            i++;\n        }\n        return ans;"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\
  \ {\n                result = result * 2 % p;\n            }\n            n = n\
  \ >> 1;\n        }\n        return result;"
- '        return p == 0 ? 1 : ((modp(n >> 1, p) % p) * (modp(n - (n >> 1), p) % p))
  % p;'
- "        if (n == 0) return 1;\n        int z = modp(n/2, p);\n        if (n % 2\
  \ == 0) return z*z % p;\n        else return z*z*2 % p;"
- '        return (int) modp((long) n, (long) p);'
- "        if (n == 0) {\n            return 1;\n        }\n        int result = 1;\n\
  \        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n\
  \        }\n        return result;"
- "        if (n == 0) {\n            return 1;\n        }\n        long mod = 1;\n\
  \        for (int i = 0; i < n; i++) {\n            mod = mod * 2 % p;\n       \
  \ }\n        return (int) mod;"
- "        int c = 1;\n        for (int i = 0; i < n; i++) {\n            c = (2 *\
  \ c) % p;\n        }\n        return c;"
- "        int res = 1;\n        int pow = n;\n        while (p > 0) {\n         \
  \   if ((p & 1) != 0) {\n                res = res * pow % p;\n            }\n \
  \           pow = pow * pow % p;\n            p >>= 1;\n        }\n        return\
  \ res;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int p2 =\
  \ modp(n / 2, p);\n            return p2 * p2 % p;\n        } else {\n         \
  \   return (10 * modp(n - 1, p)) % p;\n        }"
- "        int r = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n  \
  \              r = (r * 2) % p;\n            n >>= 1;\n        }\n        return\
  \ r;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
  \ {\n            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n\
  \            return 2 * modp(n - 1, p) % p;\n        }"
- "        int res = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
  \                res = (res * 2) % p;\n            }\n            n >>= 1;\n   \
  \     }\n        return res;"
- "        if (n == 0) return 1;\n        if (n == 1) return 2;\n        int m = modp(n/2,\
  \ p);\n        int t = m*m % p;\n        if (n % 2 == 1) t = t*2 % p;\n        return\
  \ t;"
- "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n            int x = modp(n\
  \ / 2, p);\n            return (x * x) % p;\n        } else {\n            return\
  \ (modp(n - 1, p) * n) % p;\n        }"
- "        if (n == 0) {\n            return 1;\n        }\n        int res = modp(n\
  \ / 2, p);\n        res = res * res % p;\n        if (n % 2 == 1) {\n          \
  \  res = res * 2 % p;\n        }\n        return res;"
- "        BigInteger l = BigInteger.valueOf(2).pow(n);\n        BigInteger r = BigInteger.valueOf(p);\n\
  \        return l.mod(r).intValue();"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            int square = modp(n / 2, p);\n            return (square * square)\
  \ % p;\n        } else {\n            return (2 * modp(n - 1, p)) % p;\n       \
  \ }"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n   \
  \         return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }"
- "        int ans = 1;\n        int pow = n;\n        int acc = pow;\n        while\
  \ (pow > 0) {\n            // If the last bit is 1 then add the power to the answer.\n\
  \            if ((pow & 1) == 1) {\n                ans = ans * acc % p;\n     \
  \       }\n            pow >>= 1;\n            acc = acc * acc % p;\n        }\n\
  \        return ans;"
- "        BigInteger Bn = BigInteger.valueOf(n);\n        BigInteger Bp = BigInteger.valueOf(p);\n\
  \        BigInteger result = Bn.modPow(Bn, Bp);\n        return result.intValue();"
- "        if (n == 0) return 1;\n        int x = modp(n / 2, p);\n        x = (x\
  \ * x) % p;\n        if (n % 2 == 1) {\n            x = (x * 2) % p;\n        }\n\
  \        return x;"
- "        int res = 1;\n        if (n > 0) {\n            int b = 2;\n          \
  \  int e = n;\n            while (e > 0) {\n                if ((e & 1) == 1) {\n\
  \                    res = (res * b) % p;\n                }\n                b\
  \ = (b * b) % p;\n                e >>= 1;\n            }\n        }\n        return\
  \ res;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return 2;\n        }\n        int half = modp(n / 2, p);\n        if\
  \ (n % 2 == 0) {\n            return (half * half) % p;\n        } else {\n    \
  \        return (half * half * 2) % p;\n        }"
- "        // ********* write code below *********\n        int res = 1;\n       \
  \ for (int i = 0; i < n; i++) {\n            res = (res * 2) % p;\n        }\n \
  \       return res;\n        // ********* end of write code block ****"
- "        int result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n\
  \                result = (result * 2) % p;\n            n = n >> 1;\n        }\n\
  \        return result;"
language: java
name: HumanEval_49_modp
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>>\
  \ modp(3, 5)\n    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0,\
  \ 101)\n    // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n\
  \    // 1\n    public static int modp(int n, int p) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(modp((3), (5))\
  \ == (3));\n    assert(modp((1101), (101)) == (2));\n    assert(modp((0), (101))\
  \ == (1));\n    assert(modp((3), (11)) == (8));\n    assert(modp((100), (101)) ==\
  \ (1));\n    assert(modp((30), (5)) == (4));\n    assert(modp((31), (5)) == (3));\n\
  \    }\n\n}\n"
