completions:
- "        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        a[1]\
  \ = 1;\n        for (int i = 2; i <= n; i++) {\n            a[i] = 9 * a[i - 1]\
  \ + 9 * b[i - 1];\n            b[i] = a[i - 1];\n        }\n        return a[n]\
  \ + b[n];"
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 10;\n        }\n        int[] dp = new int[n + 1];\n       \
  \ dp[1] = 1;\n        dp[2] = 10;\n        for (int i = 3; i <= n; i++) {\n    \
  \        dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];"
- '        return (int)Math.pow(10, n - 1) + (int)Math.pow(10, n - 2) * 9;'
- "        if (n == 1) {\n            return 2;\n        }\n        int count = 0;\n\
  \        for (int i = 1; i < n; i++) {\n            count += tenPower(i) * 9;\n\
  \        }\n        return 10 * count + tenPower(n - 1) * 2;"
- "        // str(n) : number of strings of length n\n        // startsOneEnds(n)\
  \ : number of strings of length n that start or end with 1\n        // startsOneEnds(n)\
  \ = str(n-1) + str(n-1) + 1 - startsOneEnds(n-1)\n        int[] s = new int[n +\
  \ 1];\n        s[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int\
  \ k = s[i - 1];\n            s[i] = 2 * k + 1 - s[i - 1];\n        }\n        return\
  \ s[n];"
- "        // ensure n > 0 and integer\n        n = n < 1 ? 1 : n;\n        // start\
  \ with a count of 0\n        int count = 0;\n        // don't count leading zeros\n\
  \        int start = n == 1 ? 1 : 0;\n        // the largest possible number with\
  \ n digits\n        int max = (int)Math.pow(10, n) - 1;\n        // if n is 1, then\
  \ we just return 9\n        if (n == 1) {\n            return 9;\n        }\n  \
  \      // count the number of 1's\n        for (int i = start; i <= max; i++) {\n\
  \            // for each digit in the number i\n            for (int j = 0; j <\
  \ n; j++) {\n                // if the current digit is 1,\n                // then\
  \ increment count\n                if (j == 0 || j == n - 1) {\n               \
  \     int digit = i % 10;\n                    if (digit == 1) {\n             \
  \           count++;\n                        break;\n                    }\n  \
  \              }\n                // remove the last digit\n                i /=\
  \ 10;\n            }\n        }\n        return count;"
- "        // How many numbers in [0, 10^n) start with 1?\n        // This is 10^(n-1).\n\
  \        // Now how many numbers in [0, 10^n) end with 1?\n        // This is 9\
  \ * 10^(n-1).\n        // Now we need to subtract out the numbers in [0, 10^n) that\
  \ start and\n        // end with 1.\n        // This is 10^(n-2).\n        // The\
  \ answer is 10^(n-1) + 9 * 10^(n-1) - 10^(n-2).\n        return (int)Math.pow(10,\
  \ n-1) + 9 * (int)Math.pow(10, n-1) - (int)Math.pow(10, n-2);"
- "        if (n == 1) return 1;\n        // Let x1, x2, ... xn be the digits.\n \
  \       // For starts with 1, x1 must be 1 and x2, ... xn can be any\n        //\
  \ number (except 0). This can be represented as\n        // f(n) = 1 * 9 * 9 * 9\
  \ * ... * 9 + f(n - 1).\n        // For ends with 1, xn must be 1 and x1, ... xn-1\
  \ can be any\n        // number. This can be represented as\n        // f(n) = 9\
  \ * 9 * 9 * ... * 9 + f(n - 1).\n        int count = 0;\n        int power = 1;\n\
  \        for (int i = 0; i < n; i++) power *= 9;\n        for (int i = 0; i < n;\
  \ i++) {\n            count += 2 * power;\n            power /= 9;\n        }\n\
  \        return count;"
- "        // S[n] = n*10^(n-1) - n*10^(n-2) + 9*10^(n-2) + S[n-1]\n        int[][]\
  \ S = new int[n+1][2];\n        S[1][0] = 10;\n        S[1][1] = 1;\n        for\
  \ (int i = 2; i <= n; i++) {\n            S[i][0] = (i-1)*10*(int)Math.pow(10,i-2)\
  \ + S[i-1][0];\n            S[i][1] = (int)Math.pow(10,i-1) - (i-1)*(int)Math.pow(10,i-2)\
  \ + 9*(int)Math.pow(10,i-2) + S[i-1][1];\n        }\n        return S[n][0] + S[n][1];"
- "        if (n == 1) {\n            return 1;\n        }\n        int m = (int)Math.pow(10,\
  \ n - 1);\n        return m + 9 * (m - 1);"
- "        if (n == 1) {\n            return 2;\n        } else {\n            return\
  \ (int) Math.pow(5, n - 1);\n        }"
- "        if (n == 1) {\n            return 10;\n        }\n        int count = 0;\n\
  \        if (n % 2 == 0) {\n            count += 9 * Math.pow(10, n / 2 - 1);\n\
  \        } else {\n            count += 9 * 9 * Math.pow(10, n / 2 - 1);\n     \
  \   }\n        return count;"
- "        if (n == 1) {\n            return 10;\n        }\n        if (n == 2) {\n\
  \            return 99;\n        }\n        if (n == 3) {\n            return 73;\n\
  \        }\n        if (n == 4) {\n            return 10 * (9 + 10 + 73);\n    \
  \    }\n        if (n == 5) {\n            return 10 * (99 + 100 + 73 + 10);\n \
  \       }\n        return 0;"
- "        // Create a list of all numbers that start with 1.\n        int start =\
  \ 1;\n        for (int i = 1; i < n; i++) {\n            start *= 10;\n        }\n\
  \        // Create a list of all numbers that end with 1.\n        int end = 1;\n\
  \        for (int i = 1; i < n; i++) {\n            end = (end * 10) + 1;\n    \
  \    }\n        return end - start + 1;"
- "        if (n == 1) return 2;\n        return (int) (Math.pow(10, n - 1) +\n  \
  \          Math.pow(10, n - 2) * 9);"
- "        if (n == 1) {\n            return 10;\n        }\n        int ans = 10;\n\
  \        while (n > 1) {\n            ans *= 9;\n            n--;\n        }\n \
  \       return ans;"
- "        // Note: Counting the number of integers ending in 1 is equivalent to\n\
  \        // counting the number of integers with no leading zeros.\n        //\n\
  \        // The number of ways of writing n as a sum of non-negative integers is\n\
  \        // the number of integer partitions of n (denoted p(n)).\n        //\n\
  \        // This is because if we have a partition p = [n_1, n_2, ..., n_k] of n,\n\
  \        // then we can write the number n as a sum of positive integers\n     \
  \   // (n_1+1) + (n_2+1) + ... + (n_k+1).\n        //\n        // There are p(n)\
  \ ways of writing n as a sum of non-negative integers.\n        // We must subtract\
  \ 1 because we don't want to include the case where\n        // all n_i are zero.\
  \ This gives us p(n)-1 ways of writing n without\n        // leading zeros.\n  \
  \      //\n        // Since the number of n-digit integers ending in 1 is equal\
  \ to the\n        // number of n-digit integers without leading zeros, the answer\
  \ is\n        // p(n)-1.\n        return p(n)-1;"
- "        int sum = 0;\n        int pow10 = (int) Math.pow(10, n);\n        if (n\
  \ % 2 == 0) {\n            sum += pow10 / 10;\n        } else {\n            sum\
  \ += pow10;\n        }\n        return sum;"
- "        if (n == 1) return 2;\n        else return 10 * startsOneEnds(n - 1) -\
  \ (int)Math.pow(10, n - 2);"
- "        // This is derived as follows. The number of ways to write n = 2m + 1 as\
  \ a\n        // sum of two positive integers equals the number of ways to write\
  \ n as a\n        // sum of two positive integers, except that the larger of the\
  \ two integers\n        // must be divisible by two.\n        //\n        // The\
  \ number of ways to write n = 2m as a sum of two positive integers\n        // equals\
  \ the number of ways to write n - 1 as a sum of two positive\n        // integers.\
  \ This is because any way of writing n - 1 as a sum of two\n        // positive\
  \ integers remains a way of writing n as a sum of two positive\n        // integers.\n\
  \        //\n        // The number of ways to write n = 2m - 1 as a sum of two positive\
  \ integers\n        // equals the number of ways to write n as a sum of two positive\
  \ integers.\n        // This is because for each way of writing n as a sum of two\
  \ positive\n        // integers, there is an associated way of writing n = 2m -\
  \ 1 as a sum of\n        // two positive integers, simply by setting the larger\
  \ of the two integers\n        // equal to the smaller integer.\n        //\n  \
  \      // The base case is that the number of ways to write 0 = 2 * 0 as a sum of\n\
  \        // two positive integers is 1 (choose 0 or 0).\n        //\n        //\
  \ If n is odd, the answer is thus equal to the number of ways to write\n       \
  \ // n - 1 as a sum of two positive integers. If n is even, the answer is\n    \
  \    // thus equal to the number of ways to write n - 1 as a sum of two positive\n\
  \        // integers plus the number of ways to write n - 2 as a sum of two positive\n\
  \        // integers.\n        if (n == 0) {\n            return 1;\n        }\n\
  \        return startsOneEnds(n - 1) + startsOneEnds(n - 2);"
- "        // For example, there are 4 such integers when n = 2. There are\n     \
  \   // 10^(n-1) n-digit positive integers that start with 1. There are\n       \
  \ // 10^(n-2) n-digit positive integers that end with 1.\n        return (int) Math.pow(10,\
  \ n - 1) + (int) Math.pow(10, n - 2);"
- '        return 2*tenPower(n-1)-1;'
- "        if (n == 1) return 2;\n        int sum = 0;\n        sum += startsOneEnds(n\
  \ - 1);\n        sum += (int) Math.pow(10, n - 1);\n        return sum;"
- "        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count\
  \ += pow(9, n - i) * pow(10, i - 1);\n        }\n        return count;"
- "        if (n == 1) {\n            return 10;\n        }\n        if (n == 2) {\n\
  \            return 180;\n        }\n        int[] counts = new int[2];\n      \
  \  counts[0] = 9;\n        counts[1] = 90;\n        for (int i = 2; i < n; i++)\
  \ {\n            int temp = counts[0];\n            counts[0] = counts[1];\n   \
  \         counts[1] = 9 * counts[1] + 10 * temp;\n        }\n        return counts[0]\
  \ + counts[1];"
- "        if (n == 1) return 2;\n        if (n == 2) return 3;\n        // Iterate\
  \ over the integers in the range [10^(n-1), 10^n - 1].\n        // For example,\
  \ if n = 3, we iterate over the numbers [100, 999].\n        // Let k be the length\
  \ of the integer. For example, if the integer is\n        // 100, k is 3.\n    \
  \    // For each such integer, add 10^(k-2) to the count if the integer\n      \
  \  // starts with 1. For example, 100 should be added because 100, 101,\n      \
  \  // ..., 109 all start with 1.\n        // The total number of integers added\
  \ is the number of integers in the\n        // range [100, 999] that start with\
  \ 1.\n        // If we iterate over all integers in the range, we must have added\n\
  \        // every integer that starts with 1 exactly once.\n        // Add another\
  \ 10^(k-2) to the count if the integer ends with 1.\n        // Similarly, the total\
  \ number of integers added is the number of\n        // integers in the range [100,\
  \ 999] that end with 1.\n        // If we iterate over all integers in the range,\
  \ we must have added\n        // every integer that ends with 1 exactly once.\n\
  \        int total = 0;\n        for (int i = (int) Math.pow(10, n - 1); i < Math.pow(10,\
  \ n); i++) {\n            int k = Integer.toString(i).length();\n            if\
  \ (Integer.toString(i).charAt(0) == '1') total += Math.pow(10, k - 2);\n       \
  \     if (Integer.toString(i).charAt(k - 1) == '1') total += Math.pow(10, k - 2);\n\
  \        }\n        return total;"
- "        // This is 1 because the following call would return 0.\n        if (n\
  \ == 1) return 1;\n        if (n % 2 == 0) {\n            // n even\n          \
  \  return 9 * (int) Math.pow(10, n / 2 - 1);\n        } else {\n            // n\
  \ odd\n            return 9 * (int) Math.pow(10, n / 2 - 1) + startsOneEnds(n -\
  \ 1);\n        }"
- '        return (int) (Math.pow(10, n) - Math.pow(9, n) - Math.pow(10, n - 1));'
- "        if (n == 1) {\n            return 2;\n        }\n        // We have n digits,\
  \ one of which has to be 1.\n        // Thus there are 9 choices for each other\
  \ digit.\n        return 9 * (int) Math.pow(10, n - 2);"
- "        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n  \
  \      for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + (int) Math.pow(10,\
  \ i - 1);\n        }\n        return dp[n];"
- "        // Assumes that n is at least 1.\n        int count = 0;\n        if (n\
  \ > 1) {\n            count += 9 * power(10, n - 2);\n        }\n        count +=\
  \ power(10, n - 1);\n        return count;"
- "        if (n == 1) {\n            return 1;\n        }\n        else {\n     \
  \       return n*9 + startsOneEnds(n-1);\n        }"
- "        if (n == 1) return 1;\n        int dp[] = new int[n + 1];\n        dp[1]\
  \ = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] *\
  \ 10 - dp[i - 2];\n        }\n        return dp[n];"
- "        // There are 10 * 10 * 9 * ... * 9 = 9 * 10^(n-2) numbers that begin with\n\
  \        // 1 and end with anything.\n        // For n = 1 there are no such numbers.\n\
  \        return n == 1 ? 0 : 10 * pow(9, n - 2);"
- '        return 0;'
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 1;\n        }\n        if (n == 3) {\n            return 2;\n\
  \        }\n        if (n == 4) {\n            return 2;\n        }\n        return\
  \ 2 * startsOneEnds(n - 1) - startsOneEnds(n - 2);"
- '        return 3 * (int)Math.pow(10, n - 1) - 2 * (int)Math.pow(9, n - 1);'
- '        return count(n);'
- "        // Let f(n) be the number of n-digit numbers that starts with 1, and let\n\
  \        // g(n) be the number of n-digit numbers that ends with 1.\n        //\
  \ We can compute f(n) and g(n) recursively:\n        // f(n) = 9 * f(n - 1)\n  \
  \      // g(n) = 9 * g(n - 1) + f(n - 1)\n        // Initial values f(1) = 1, g(1)\
  \ = 1.\n        // We want f(n) + g(n).\n        // We can use this recurrence to\
  \ compute f(n) + g(n) recursively.\n        // f(n) + g(n) = f(n - 1) + g(n - 1)\
  \ + 9f(n - 1) + 9g(n - 1)\n        //             = 10(f(n - 1) + g(n - 1)) + 9f(n\
  \ - 1)\n        //             = 10(f(n - 1) + g(n - 1)) + f(n - 1) + 8f(n - 1)\n\
  \        //             = f(n - 1) + 9f(n - 1) + g(n - 1) + 8f(n - 1)\n        //\
  \             = 9f(n - 1) + 9g(n - 1)\n        //             = 9(f(n - 1) + g(n\
  \ - 1))\n        //             = 9(f(n - 1) + g(n - 1))\n        // Initial values\
  \ f(1) + g(1) = 2.\n        // Time complexity: O(n). Space complexity: O(1).\n\
  \        int f = 1, g = 1;\n        for (int i = 2; i <= n; i++) {\n           \
  \ int f1 = f, g1 = g;\n            f = 9 * f1 + g1;\n            g = f1 + 8 * g1;\n\
  \        }\n        return f + g;"
- '        return 2 * n;'
- "        if (n <= 1) {\n            return n;\n        }\n        int tens = 1;\n\
  \        for (int i = 1; i < n; i++) {\n            tens *= 10;\n        }\n   \
  \     return 2 * tens - 2;"
- "        if (n == 1) return 2;\n        int[] prev = new int[10];\n        int[]\
  \ current = new int[10];\n        Arrays.fill(prev, 1);\n        for (int i = 2;\
  \ i <= n; i++) {\n            current[0] = 1;\n            for (int j = 1; j < 10;\
  \ j++) {\n                current[j] = current[j - 1] + prev[j];\n            }\n\
  \            prev = current;\n            current = new int[10];\n        }\n  \
  \      return prev[9];"
- "        if (n == 1) return 2;\n        int[] dp = new int[n + 1];\n        dp[1]\
  \ = 2;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] +\
  \ (int)Math.pow(10, i - 1);\n        }\n        return dp[n];"
- "        // We're counting the number of n-digit positive integers that start with\
  \ 1\n        // *minus* the number of n-digit positive integers that start with\
  \ 2.\n        // We do this because 1 and 2 are the only possible first digits.\n\
  \        // TODO: implement me!\n        return -1;"
- "        int[] left = new int[n + 1];\n        int[] right = new int[n + 1];\n \
  \       left[1] = 1;\n        right[1] = 1;\n        for (int i = 2; i <= n; i++)\
  \ {\n            left[i] = 9 * left[i - 1];\n            right[i] = 9 * right[i\
  \ - 1] + left[i - 1];\n        }\n        return left[n] + right[n];"
- "        if (n == 1) return 2;\n        int from = 10;\n        int to = Integer.MAX_VALUE\
  \ / 10;\n        int count = 0;\n        for (int i = from; i < to; i = i * 10)\
  \ {\n            count += (i - 1) * 2;\n        }\n        return count;"
- "        if (n == 1) {\n            return 1;\n        } else {\n            return\
  \ (int) Math.pow(10, n - 1) + 9 * (int) Math.pow(10, n - 2);\n        }"
- "        // we can think of this by assigning a position to the one\n        //\
  \ (1) -> 0\n        // (10) -> 1\n        // (100) -> 2\n        // (1000) -> 3\n\
  \        // where 0 is at the end, 1 is in the center, and 2 is at the beginning\n\
  \        // for n=4, there are 3 possibilities for the one\n        // and for each\
  \ one, there are 9 choices for the remaining digit\n        // so the answer is\
  \ 27\n\n        // for n=5, there are 4 possibilities for the one\n        // and\
  \ for each one, there are 9 choices for the remaining digit\n        // so the answer\
  \ is 36\n\n        // thus, the answer is (n-1)*9\n\n        // in general, (n-1)*9\n\
  \n        return (n-1)*9;"
- "        if (n == 1) return 1;\n        return (int) Math.pow(10, n - 1) + startsOneEnds(n\
  \ - 1);"
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 2;\n        }\n        // number of digits including the last\
  \ digit\n        long count = 10;\n        long last = 11;\n        int i = 3;\n\
  \        while (i <= n) {\n            // count of numbers starting and ending with\
  \ 1 is the same as\n            // the count of numbers ending with 1, which is\
  \ the last element\n            // in the sequence.\n            long temp = last\
  \ * 10;\n            count += last;\n            last = temp;\n            i++;\n\
  \        }\n        return (int) count;"
- "        if (n == 1) {\n            return 1;\n        } else {\n            int\
  \ total = 10;\n            for (int i = 2; i < n; i++) {\n                total\
  \ *= 9;\n            }\n            return total + startsOneEnds(n - 1);\n     \
  \   }"
- "        if (n == 1) {\n            return 1;\n        }\n        // Count the numbers\
  \ that end in 1: they are just n-1 digit numbers that\n        // don't end in 1.\n\
  \        int countEnds = startsOneEnds(n - 1);\n        // Count the numbers that\
  \ start in 1: for each digit d except for the\n        // first digit and the last\
  \ digit, we can place any digit.\n        int countStarts = (int) Math.pow(9, n\
  \ - 2);\n        return countEnds + countStarts;"
- "        int result = 0;\n        return result;"
- "        if (n <= 1) {\n            return n;\n        } else {\n            //\
  \ n digits:\n            // n - 1 free digits, n - 1 choices, 1 leading one, 10\
  \ choices\n            // n - 2 free digits, n - 2 choices, 2 leading ones, 10 choices\n\
  \            // n - 3 free digits, n - 3 choices, 3 leading ones, 10 choices\n \
  \           // ...\n            // 1 free digit, 1 choice, n - 1 leading ones, 10\
  \ choices\n            return IntStream.range(1, n).map(i -> 10 * f(n - i) * i).sum();\n\
  \        }"
- "        // The number of n-digit positive integers is 10^(n-1) to 10^n-1.\n   \
  \     // The number of n-digit positive integers that start with 1 is\n        //\
  \ 10^(n-2) to 10^(n-1)-1.\n        // The number of n-digit positive integers that\
  \ end with 1 is\n        // 10^(n-2) to 10^(n-1)-1.\n        // 10^(n-2) + 10^(n-2)\
  \ = 2*10^(n-2)\n        return 2*(int)Math.pow(10, n-2);"
- "        if (n == 1) {\n            return 10;\n        } else {\n            //\
  \ There are 10 numbers that start with 1.\n            int sum = 10;\n         \
  \   // There are 9*10^(n-2) numbers that end with 1.\n            sum += 9 * (int)\
  \ Math.pow(10, n - 2);\n            // There are 9*10^(n-1) numbers that start and\
  \ end with 1.\n            sum += 9 * (int) Math.pow(10, n - 1);\n            return\
  \ sum;\n        }"
- "        // We use DP to solve this problem\n        if (n == 1) return 2;\n   \
  \     // dp[i] is the number of n-digit positive integers with 1\n        // as\
  \ the first digit\n        int[] dp = new int[n + 1];\n        dp[1] = 2;\n    \
  \    for (int i = 2; i <= n; i++) {\n            dp[i] = (dp[i - 1] + (int) Math.pow(10,\
  \ i - 1)) % 1000000007;\n        }\n        return dp[n];"
- "        if (n < 1) return 0;\n        // Dynamic Programming\n        // dp[i]\
  \ -> count of numbers of i-digit positive integers that start or end with 1\n  \
  \      int[] dp = new int[n + 1];\n        // base case\n        dp[1] = 2;\n  \
  \      // induction hypothesis\n        // dp[n] = dp[n - 1] + dp[n - 2]\n     \
  \   for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n\
  \        }\n        return dp[n];"
- "        if (n == 1) {\n            return 2;\n        }\n        if (n == 2) {\n\
  \            return 2;\n        }\n        if (n == 3) {\n            return 5;\n\
  \        }\n        return startsOneEnds(n - 1) + 2 * startsOneEnds(n - 2) + startsOneEnds(n\
  \ - 3);"
- "        // Returns the number of n-digit positive integers.\n        return (int)\
  \ Math.pow(10, n) - 1;"
- "        if (n == 1) return 1;\n        if (n == 2) return 3;\n        return startsOneEnds(n\
  \ - 1) + startsOneEnds(n - 2);"
- '        return 5;'
- "        if (n == 1) {\n            return 1;\n        } else {\n            return\
  \ (int)Math.pow(10, n - 1) + 9 * (int)Math.pow(10, n - 2);\n        }"
- "        int[] arr = new int[n + 1];\n        int[] allDigits = new int[n + 1];\n\
  \        for (int i = 1; i <= n; i++) {\n            if (i == 1) {\n           \
  \     arr[i] = 1;\n                allDigits[i] = 9;\n            } else {\n   \
  \             arr[i] = arr[i - 1] + (int) Math.pow(10, i - 1);\n               \
  \ allDigits[i] = allDigits[i - 1] * 10;\n            }\n        }\n        int count\
  \ = 0;\n        for (int i = 1; i <= n; i++) {\n            count += arr[i];\n \
  \       }\n        return count + 1;"
- "        if (n == 1) {\n            return 1;\n        } else {\n            //\
  \ We can append a 1 to each (n-1)-digit number that starts with 1.\n           \
  \ // We can append a 1 to each (n-1)-digit number that ends with 1.\n          \
  \  // We can append a 1 to each (n-1)-digit number that has a 1 in the\n       \
  \     // first or last position.\n            // We can append a 1 to each (n-1)-digit\
  \ number that does not have a\n            // 1 in the first or last position.\n\
  \            // All of the numbers that start with 1 have another digit in the\n\
  \            // first position.\n            int has1 = startsOneEnds(n - 1);\n\
  \            int no1 = startsOneEnds(n - 1);\n            int starts1 = startsOneEnds(n\
  \ - 1);\n            int ends1 = startsOneEnds(n - 1);\n            int hasOne =\
  \ has1 - starts1 - ends1;\n            int starts = starts1 - 1;\n            int\
  \ ends = ends1 - 1;\n            return hasOne + starts + ends + starts1 + ends1;\n\
  \        }"
- "        // Recursively compute the answer, where ans[i] is the answer for i\n \
  \       // digits.\n        int[] ans = new int[n + 1];\n        // When i == 1,\
  \ return 1 for \"1\".\n        ans[1] = 1;\n        for (int i = 2; i <= n; i++)\
  \ {\n            // First, consider the case where the leading digit is 1:\n   \
  \         // We can only choose 1 for the second digit, since we can't start\n \
  \           // with 0.\n            // Then, we simply choose any i - 2 digits.\n\
  \            ans[i] += 10 * ans[i - 2];\n            // Then, consider the case\
  \ where the leading digit is not 1:\n            // In this case, we simply choose\
  \ any digit to lead, then choose i -\n            // 1 digits.\n            ans[i]\
  \ += 9 * (int) Math.pow(10, i - 1);\n        }\n        return ans[n];"
- '        return 0;'
- "        // 0 or 1 digits - do nothing\n        if (n <= 1) {\n            return\
  \ 0;\n        }\n        // 2 digits - start and end with 1\n        if (n == 2)\
  \ {\n            return 11;\n        }\n        // more than 2 digits\n        //\
  \ find the number of digits that don't start with one\n        int notFirst = 0;\n\
  \        int power = 1;\n        for (int i = 1; i < n; i++) {\n            power\
  \ *= 10;\n            notFirst += (power - power / 10);\n        }\n        // return\
  \ number of valid digits\n        int numValid = (int) Math.pow(10, n - 1) - notFirst;\n\
  \        return numValid * 2;"
- "        BigInteger k = new BigInteger(\"1\");\n        int res = 0;\n        for\
  \ (int i = 1; i <= n; i++) {\n            BigInteger l = k.add(k.multiply(new BigInteger(\"\
  10\")));\n            k = l;\n            res += 2;\n        }\n        return res;"
- "        if (n == 1) {\n            return 10;\n        } else {\n            return\
  \ 9 * (int) Math.pow(10, n - 1);\n        }"
- "        if (n == 1) {\n            return 10;\n        }\n        if (n == 2) {\n\
  \            return 191;\n        }\n        int total = 0;\n        int full =\
  \ (int) Math.pow(10, n - 1);\n        for (int start = 1; start < 10; start++) {\n\
  \            for (int end = 1; end < 10; end++) {\n                total += start\
  \ * full * end;\n            }\n        }\n        return total;"
- "        if (n == 1) {\n            return 1;\n        }\n        int[] count =\
  \ new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n\
  \                count[i] = 1;\n            } else if (i == 1) {\n             \
  \   count[i] = 10;\n            } else {\n                count[i] = (10 * count[i\
  \ - 1]) - count[i - 2];\n            }\n        }\n        return count[n - 1];"
- "        if (n == 1) {\n            return 1;\n        } else {\n            return\
  \ 9 + startsOneEnds(n - 1);\n        }"
- "        // EXPLANATION: This is a combinatorial problem. The answer is n, n-1,\n\
  \        // n-2...3, 2, 1. If we can find a way to calculate n, n-1, n-2...3, 2,\
  \ 1\n        // in O(n) time, we can build the answer in O(n) time. If we can then\
  \ find\n        // a way to calculate the sum in O(n) time, the whole problem can\
  \ be\n        // solved in O(n) time. To calculate n, n-1, n-2...3, 2, 1, we can\
  \ use\n        // the fact that this sequence is always increasing by 1. This means\n\
  \        // that we can calculate the sum in O(n) time. The final total is thus\n\
  \        // calculated in O(n) time. In conclusion, the answer is calculated in\n\
  \        // O(n) time.\n        int total = 0;\n        for (int i = n; i > 0; i--)\
  \ {\n            total += i;\n        }\n        return total;"
- "        // The count of digits of n must be 1, 2, or 3.\n        if (n < 1 || n\
  \ > 3) {\n            throw new IllegalArgumentException(\"n must be between 1 and\
  \ 3.\");\n        }\n        // Count the number of digits that start with 1.\n\
  \        int count = 0;\n        int digitLeft = n - 1;\n        // if the first\
  \ digit is 1, the remaining digits can be zero.\n        if (digitLeft == 0) {\n\
  \            count++;\n        }\n        // Count the number of digits that end\
  \ with 1.\n        while (digitLeft > 0) {\n            int digitRight = digitLeft\
  \ - 1;\n            // If the last digit is 1, the remaining digits can be zero.\n\
  \            if (digitRight == 0) {\n                count++;\n            }\n \
  \           // Digits that end with 1 and start with 0.\n            // The reamining\
  \ digits can be 1, 2, or 3.\n            count += 3 * Math.pow(3, digitRight);\n\
  \            digitLeft--;\n        }\n        return count;"
- '        throw new UnsupportedOperationException();'
- "        // Given some integer like, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        //\
  \ there are n-1 ways to form a number using these ints.\n        // This is because\
  \ the first int is 1.\n        int base = n - 1;\n        // The number of ways\
  \ to form a positive integer of length n,\n        // where the first int is not\
  \ 1, is the same as the number of ways\n        // to form a positive integer of\
  \ length n-1.\n        int recursive = startsOneEnds(n - 1);\n        // A number\
  \ can be formed from a prefix 1 in 2 ways:\n        // 1 (1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9)\n        // 1 (2, 3, 4, 5, 6, 7, 8, 9, 10)\n        // or a suffix 1 in 2 ways:\n\
  \        // (1, 2, 3, 4, 5, 6, 7, 8, 9) 1\n        // (2, 3, 4, 5, 6, 7, 8, 9, 10)\
  \ 1\n        // The former is the number of ways to form a positive integer of length\
  \ n-1.\n        // The latter is the number of ways to form a positive integer of\
  \ length n-1\n        // with the last int being 0, which is the same as the number\
  \ of ways to form\n        // a positive integer of length n-2.\n        int suffix\
  \ = startsOneEnds(n - 2);\n        // To count the number of positive integers of\
  \ length n, we add together\n        // the number of ways to form a number where\
  \ the first int is 1, which is\n        // 1 * (n-1) + the number of ways to form\
  \ a number where the first int is not 1\n        // and the number of ways to form\
  \ a number that ends in 1.\n        return base + recursive + suffix;"
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 5;\n        }\n        int previous = 1;\n        int current\
  \ = 5;\n        for (int i = 3; i <= n; i++) {\n            int temp = current;\n\
  \            current = 9 * current + previous;\n            previous = temp;\n \
  \       }\n        return current;"
- "        int c = 0;\n        for (int i = 1; i <= n; i++) {\n            c += pow(3,\
  \ i - 1);\n        }\n        return c;"
- "        // Cases:\n        // n = 1, 1\n        // n = 2, 11\n        // n = 3,\
  \ 111, 211, 311\n        // n = 4, 1111, 2111, 1211, 1121, 1112, 3111, 1311, 1131,\
  \ 1113\n        // n = 5, 11111, 21111, 12111, 11211, 11121, 11112, 31111, 13111,\
  \ 11311,\n        // 11131, 11113, 21111, 12111, 11211, 11121, 11112, 32111, 23111,\
  \ 21311,\n        // 21131, 21113, 12211, 21211, 12121, 12112, 11221, 21121, 21112,\
  \ 12211,\n        // 22111, 14111, 11411, 11141, 11114, 41111, 14111, 11411, 11141,\
  \ 11114\n        // n = 6, 111111, 21111, 121111, 112111, 111211, 111121, 111112,\
  \ 311111,\n        // 131111, 113111, 111311, 111131, 111113, 211111, 121111, 112111,\
  \ 111211,\n        // 111121, 111112, 321111, 231111, 213111, 211131, 211113, 122111,\
  \ 212111,\n        // 121211, 121121, 112211, 211211, 211121, 111122, 222111, 141111,\
  \ 114111,\n        // 111411, 111141, 111114, 411111, 141111, 114111, 111411, 111141,\
  \ 111114\n        // Formula: (1*4^(n-1) + 10^(n-1) + 1*4^(n-1))\n        int pow\
  \ = (int) Math.pow(10, n - 1);\n        int ret = (1 * (int) Math.pow(4, n - 1))\
  \ + pow + (1 * (int) Math.pow(4, n - 1));\n        return ret;"
- "        if (n < 1) {\n            return 0;\n        }\n        if (n == 1) {\n\
  \            return 1;\n        }\n        // We need to count the number of ways\
  \ to place n-2 zeros\n        // between the two ones.\n        // The n-2 zeros\
  \ can be split in any way:\n        // 1 <= i <= n-2\n        // and then the n-2\
  \ zeros form i groups.\n        // This gives 9*(n-2) choices.\n        // But we\
  \ have to subtract the cases where the n-2 zeros are all\n        // stuck together.\n\
  \        // This happens if i = 1 in the split.\n        // There are n-2 ways to\
  \ split up the zeros and still have only one group.\n        // This means we have\
  \ to subtract (n-2) choices.\n        // But then we just subtracted the case where\
  \ the two ones are stuck\n        // together.\n        // So we have to add this\
  \ case back in.\n        // So the answer is 9*(n-2) - (n-2) + 1.\n        return\
  \ 9*(n-2) - (n-2) + 1;"
- "        // Write your code here.\n        int[][] dp = new int[n + 1][2];\n   \
  \     dp[1][0] = 1;\n        dp[1][1] = 1;\n        for (int i = 2; i <= n; i++)\
  \ {\n            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) * 10 - 1;\n          \
  \  dp[i][1] = dp[i - 1][0];\n        }\n        return dp[n][0] + dp[n][1];"
- "        // ?????????\n        // ?1???????\n        int result = 0;\n        if\
  \ (n == 1) {\n            result = 2;\n        } else if (n > 1) {\n           \
  \ result = 2;\n            for (int i = 2; i <= n; i++) {\n                result\
  \ *= 2;\n            }\n        }\n        return result;"
- "        if (n == 1) {\n            return 2;\n        }\n        // Let f(n) be\
  \ the number of n-digit positive integers that start or end\n        // with 1.\
  \ Then f(n) is equal to the number of (n-1)-digit integers that\n        // start\
  \ with 1 plus the number of n-digit integers that end with 1. The\n        // latter\
  \ is equal to the number of n-digit integers that start with a\n        // non-1\
  \ digit minus the number of n-digit integers that start with a\n        // 1. We\
  \ can calculate the number of n-digit integers that start with a\n        // non-1\
  \ digit by multiplying the number of choices for each digit\n        // position.\
  \ It's 9 choices for the first digit and 10 choices for each\n        // other digit\
  \ position. Hence, the number of n-digit integers that\n        // start with a\
  \ non-1 digit is 10^(n-1). The number of n-digit integers\n        // that start\
  \ with a 1 is just 1. Hence, the number of n-digit integers\n        // that end\
  \ with a 1 is (10^(n-1) - 1).\n        // The recurrence relation is then f(n) =\
  \ f(n-1) + (10^(n-1) - 1).\n        // It will be more efficient to just calculate\
  \ the answer instead of\n        // having to keep tracking the previous answers\
  \ in an array, for which\n        // we'd need to use the entire solution space.\n\
  \        int answer = 1;\n        int tens = 1;\n        for (int i = 0; i < n-1;\
  \ i++) {\n            tens *= 10;\n            answer += tens - 1;\n        }\n\
  \        return answer;"
- "        if (n == 1) return 1;\n        return 10 * startsOneEnds(n - 1) - 9 * startsOneEnds(n\
  \ - 2);"
- "        // The number of n-digit numbers starting with 1 is 2^(n-1) - 1, since\n\
  \        // the only possible digits after the first one are 0 and 1.\n        //\
  \ For example, if n = 3, the possible numbers are 1xx, 1x0, 10x, 100,\n        //\
  \ where x is any number in {0, 1}.\n        int starts = (int) Math.pow(2, n - 1)\
  \ - 1;\n        // The number of n-digit numbers ending with 1 is also 2^(n-1) -\
  \ 1.\n        // For example, if n = 3, the possible numbers are xx1, x01, 0x1,\
  \ 011,\n        // where x is any number in {0, 1}.\n        int ends = (int) Math.pow(2,\
  \ n - 1) - 1;\n        // Therefore, the total number of n-digit numbers that start\
  \ or end with\n        // 1 is 2*2^(n-1) - 2.\n        return 2 * starts - 2;"
- "        if (n == 1) {\n            return 1;\n        } else {\n            int\
  \ base = (int)Math.pow(10, n - 1);\n            return base + 9 * startsOneEnds(n\
  \ - 1);\n        }"
- "        assert n > 0;\n        if (n == 1) {\n            return 1;\n        }\
  \ else {\n            return (int) Math.pow(2, n - 1) + (int) Math.pow(2, n - 2);\n\
  \        }"
- "        // Start with 0 and 1, so that the count can be incremented in the\n  \
  \      // correct way.\n        int count = 2;\n        int max = (int) Math.pow(10,\
  \ n);\n        // Start at 11 and add 10 each time, until the next number would\
  \ be\n        // larger than the maximum.\n        for (int i = 11; i + 10 < max;\
  \ i += 10) {\n            count++;\n        }\n        return count;"
- "        // 2+2^n-1+2*2^(n-1)\n        int[] fib=new int[n+1];\n        fib[0]=1;\n\
  \        fib[1]=2;\n        for(int i=2;i<=n;i++)\n            fib[i]=fib[i-1]+fib[i-2];\n\
  \        return 2+2*fib[n-1]+fib[n-2];"
- "        if (n == 1) {\n            return 2;\n        } else {\n            return\
  \ (int) Math.pow(10, n - 1) + (int) Math.pow(10, n - 2);\n        }"
- "        if (n == 1) return 1;\n        int[] a = new int[n + 1];\n        a[1]\
  \ = 1;\n        for (int i = 2; i <= n; i++)\n            a[i] = a[i - 1] * 10 -\
  \ a[i - 2];\n        return a[n];"
- "        if (n == 1) return 2;\n\n        // Add the count of n-digit integers starting\
  \ with one\n        int count = 0;\n        // A n-digit number must have at least\
  \ 1 digit 0\n        count += 9 * (int)Math.pow(10, n - 2);\n        // Add the\
  \ count of n-digit integers ending with one\n        count += 9 * (int)Math.pow(10,\
  \ n - 2);\n        return count;"
- "        if (n == 1) {\n            return 2;\n        } else {\n            //\
  \ We don't need to recurse because there is a closed form solution.\n          \
  \  // We can count the number of n-digit numbers that start or end with\n      \
  \      // 1 by counting the number of (n-1)-digit numbers that have no\n       \
  \     // leading zeros and the number of (n-1)-digit numbers that have no\n    \
  \        // trailing zeros.\n            //\n            // We need to subtract\
  \ 1 because there is a single number (1) that\n            // starts and ends with\
  \ 1 and gets counted twice.\n            return countLeading(n-1) + countTrailing(n-1)\
  \ - 1;\n        }"
- '        return 1 + 9 * (n - 1);'
- '        return (int)Math.pow(2, n - 1);'
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 2;\n        }\n        if (n == 3) {\n            return 3;\n\
  \        }\n        int[] arr = new int[n + 1];\n        arr[1] = 1;\n        arr[2]\
  \ = 2;\n        arr[3] = 3;\n        for (int i = 4; i <= n; i++) {\n          \
  \  arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        return arr[n];"
- "        if (n == 1) {\n            return 1;\n        } else {\n            int\
  \ res = 0;\n            for (int i = 0; i < n - 1; i++) {\n                res +=\
  \ Math.pow(10, i);\n            }\n            return res * 2;\n        }"
- "        if (n == 1) {\n            return 10;\n        }\n        if (n == 2) {\n\
  \            return 54;\n        }\n        if (n == 3) {\n            return 218;\n\
  \        }\n        int b = n / 2;\n        int m = 1;\n        int k = 1;\n   \
  \     for (int i = 0; i < b; i++) {\n            m *= 10;\n            k += m;\n\
  \        }\n        return k;"
- "        if (n < 1) return 0;\n        if (n == 1) return 2;\n        if (n == 2)\
  \ return 5;\n        int[] last = new int[n];\n        last[0] = 1;\n        last[1]\
  \ = 2;\n        last[2] = 3;\n        int[] current = new int[n];\n        for (int\
  \ k = 3; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n            \
  \    current[i] = last[i] + current[i];\n            }\n            for (int i =\
  \ 0; i < n; i++) {\n                last[i] = current[i];\n                current[i]\
  \ = 0;\n            }\n        }\n        return 2*current[n-1] + last[n-1];"
- "        // Solve using dynamic programming:\n        // dp[i][j] = number of i-digit\
  \ positive integers that start with j (0 or 1)\n        // dp[i][j] = dp[i-1][j]\
  \ + dp[i-1][(j+1)%2]\n        // dp[i][0] = dp[i-1][0] + dp[i-1][1]\n        //\
  \ dp[i][1] = dp[i-1][0] + dp[i-1][1]\n        // dp[i][0] = 2*dp[i-1][0] + dp[i-1][1]\n\
  \        // dp[i][1] = 2*dp[i-1][0] + dp[i-1][1]\n        // dp[i][0] = 2*dp[i][1]\n\
  \        // dp[i][1] = 3*dp[i-1][1] + dp[i-1][0]\n        // dp[i][1] = 3*dp[i][1]\
  \ + dp[i-1][0]\n        // dp[i][1] = 4*dp[i][1] - dp[i-1][1]\n        // dp[1][0]\
  \ = 1\n        // dp[1][1] = 1\n        // dp[2][0] = 2\n        // dp[2][1] = 2\n\
  \        // dp[3][0] = 6\n        // dp[3][1] = 3\n        // dp[4][0] = 12\n  \
  \      // dp[4][1] = 6\n        // dp[5][0] = 24\n        // dp[5][1] = 12\n   \
  \     // dp[6][0] = 48\n        // dp[6][1] = 24\n        // dp[7][0] = 96\n   \
  \     // dp[7][1] = 48\n        // dp[8][0] = 192\n        // dp[8][1] = 96\n  \
  \      // dp[9][0] = 384\n        // dp["
- "        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum +=\
  \ Math.pow(10, i);\n        }\n        return 2 * sum;"
- '        return 0;'
- "        int total = 0;\n        for (int i = 1; i <= n; i++) {\n            total\
  \ += Math.pow(10, i - 1);\n        }\n        return total;"
- "        if (n == 1) {\n            return 2;\n        }\n        // Count all numbers\
  \ with first digit 1\n        int ans = (int) Math.pow(10, n - 1);\n        // Count\
  \ all numbers that end with 1\n        ans += (int) Math.pow(10, n - 1) - 1;\n \
  \       return ans;"
- "        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 2;\n  \
  \      for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n\
  \        }\n        return dp[n];"
- "        // Write your code here.\n        return 0;"
- "        if (n < 1) return 0;\n        if (n == 1) return 1;\n        if (n == 2)\
  \ return 3;\n        if (n == 3) return 5;\n        return startsOneEnds(n - 1)\
  \ + startsOneEnds(n - 2);"
- "        if (n <= 1) {\n            return 1;\n        }\n        int count = 0;\n\
  \        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n  \
  \      for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n\
  \        }\n        for (int i = 1; i <= n; i++) {\n            count += dp[i];\n\
  \        }\n        return count;"
- "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
  \            return 2;\n        }\n        return 2 * startsOneEnds(n - 1) + (int)\
  \ Math.pow(10, n - 2);"
- "        // Can start with 1\n        int can_start = 9 * (int) Math.pow(10, n -\
  \ 1);\n        // Can end with 1\n        int can_end = (int) Math.pow(10, n - 1);\n\
  \        return can_start + can_end;"
- "        int[][] dp = new int[n + 1][2];\n\n        dp[1][0] = 1;\n        dp[1][1]\
  \ = 1;\n\n        for (int i = 2; i <= n; i++) {\n            dp[i][0] = dp[i -\
  \ 1][0] + dp[i - 1][1];\n            dp[i][1] = dp[i - 1][0];\n        }\n\n   \
  \     return dp[n][0] + dp[n][1];"
- "        int count = 0;\n        for (int i = 1; i <= 9; i++) {\n            int\
  \ tens = 1;\n            for (int j = 1; j < n; j++) {\n                tens *=\
  \ 10;\n            }\n            count += 2*tens;\n        }\n        return count;"
- "        int count = 0;\n        int firstPower = (int) Math.pow(10, n - 1);\n \
  \       int lastPower = (int) Math.pow(10, n);\n        for (int i = firstPower;\
  \ i < lastPower; i++) {\n            String value = String.valueOf(i);\n       \
  \     if (value.startsWith(\"1\") || value.endsWith(\"1\")) {\n                count++;\n\
  \            }\n        }\n        return count;"
- "        // Given that each of these numbers must be less than 10^n, we can\n  \
  \      // eliminate any solutions that are less than 10^(n-1)\n        if (n < 2)\
  \ {\n            return n;\n        }\n        int[] counts = new int[n];\n    \
  \    int[] digits = new int[n];\n        // We count the number of n-digit numbers\
  \ by counting the number of\n        // n-digit numbers that start with 0, then\
  \ with 1, ..., then with 9.\n        // We use the same idea to count numbers that\
  \ start with 1, but we\n        // also add the number of solutions that start with\
  \ 0, since we've\n        // already counted those.\n        for (int i = 0; i <\
  \ n; i++) {\n            int count = 0;\n            for (int j = 0; j < 10; j++)\
  \ {\n                int[] newDigits = Arrays.copyOf(digits, n);\n             \
  \   newDigits[i] = j;\n                // We must increase the number of digits\
  \ by 1, since we're\n                // fixing the digit at position i as j.\n \
  \               count += countRecursive(newDigits, n - i - 1, j == 1);\n       \
  \     }\n            // Add the number of solutions that start with 0, since we've\n\
  \            // already counted those.\n            if (i != 0) {\n            \
  \    count += counts[i - 1];\n            }\n            counts[i] = count;\n  \
  \      }\n        return counts[n - 1];"
- "        if (n == 1) return 1;\n        return startsOneEnds(n - 1) + 10 * startsOneEnds(n\
  \ - 2);"
- "        assert n >= 1;\n        if (n == 1) return 2;\n        // Notice that,\
  \ if a number ends with 1, it must start with a non-zero\n        // digit.\n  \
  \      return startsOneEnds(n - 1) + 1;"
- "        int count = 0;\n        if (n <= 1) {\n            return 1;\n        }\n\
  \        if (n == 2) {\n            return 20;\n        }\n        int[] array =\
  \ new int[n];\n        array[0] = 2;\n        array[1] = 18;\n        for (int i\
  \ = 2; i < n; i++) {\n            array[i] = array[i - 1] * 9;\n        }\n    \
  \    for (int i = 1; i < n; i++) {\n            count += array[i];\n        }\n\
  \        return count + 1;"
- "        // Write a solution with time complexity < O(n)\n        // and space complexity\
  \ < O(1)\n        //..."
- "        int ret = 0;\n        for (int i = 1; i <= n; i++) {\n            ret +=\
  \ Math.pow(10, i - 1);\n        }\n        return ret;"
- "        if (n == 1) {\n            return 1;\n        } else {\n            int\
  \ ans = startsOneEnds(n - 1);\n            ans += (n - 1) * (int) Math.pow(9, n\
  \ - 2);\n            return ans;\n        }"
- "        // We use a dynamic programming approach.\n        // Let dp[i] be the\
  \ answer for n = i, i.e. the number of i-digit\n        // positive integers that\
  \ start or end with 1.\n        // Since our answer is dp[n], we need to compute\
  \ dp[1..n].\n        // We use the DP formula dp[i] = (dp[i-1] * 9) + 1, where\n\
  \        // dp[i-1] * 9 represents the contribution from i-digit numbers\n     \
  \   // ending with 1, and 1 represents the contribution from numbers\n        //\
  \ starting with 1.\n        int[] dp = new int[n+1];\n        dp[1] = 2; // Our\
  \ base case.\n        for (int i = 2; i <= n; i++) {\n            dp[i] = (dp[i-1]\
  \ * 9) + 1;\n        }\n        return dp[n];"
- "        int result = 1;\n        for (int i = 1; i < n; i++) {\n            result\
  \ = result * 8;\n        }\n        return result;"
- "        // Write your code here.\n        int[] dp = new int[n+1];\n        dp[0]\
  \ = 1;\n        for(int len = 1; len <= n; len++) {\n            for(int d = 0;\
  \ d <= 9; d++) {\n                dp[len] += dp[len-1];\n            }\n       \
  \     dp[len] -= dp[len-1];\n        }\n        return dp[n];"
- "        // Return answer\n        return 0;"
- "        int count = (int)Math.pow(3, n - 1);\n        return count;"
- "        if (n == 1) return 2;\n        if (n == 2) return 4;\n        return 4\
  \ * startsOneEnds(n - 1) - 2 * startsOneEnds(n - 2);"
- "        if (n == 1) return 2;\n        int res = 0;\n        // A n-digit number\
  \ starting with 1, can be written as 10...0, with\n        // (n-1) digits between\
  \ the leading 1 and the ending 0. This is a number\n        // with (n-1) digits\
  \ and a leading zero. Therefore, there are 9 *\n        // pow(10, n-2) numbers\
  \ starting with 1, and ending with anything but 0.\n        res += 9 * (int) Math.pow(10,\
  \ n - 2);\n        // A n-digit number ending with 1 can be written as 0...01, with\
  \ (n-1)\n        // digits between the leading 0 and the ending 1. This is a number\
  \ with\n        // (n-1) digits and a trailing one. Therefore, there are 9 * pow(10,\
  \ n-2)\n        // numbers ending with 1, and starting with anything but 0.\n  \
  \      res += 9 * (int) Math.pow(10, n - 2);\n        // A n-digit number starting\
  \ and ending with 1 can be written as 10...01,\n        // with (n-2) digits between\
  \ the leading 1 and the ending 1. This is a\n        // number with (n-2) digits\
  \ and a leading 1 and a trailing 1. Therefore,\n        // there are 8 * pow(10,\
  \ n-3) numbers starting and ending with 1.\n        res += 8 * (int) Math.pow(10,\
  \ n - 3);\n        return res;"
- "        if (n == 1) return 2;\n        else return startsOneEnds(n - 1) + (int)\
  \ Math.pow(9, n - 1);"
- '        return 0;'
- "        int[] digitCounts = new int[n];\n        digitCounts[0] = 1;\n        for\
  \ (int i = 1; i < n; i++) {\n            digitCounts[i] = digitCounts[i - 1] * 9\
  \ + (int) Math.pow(10, i - 1);\n        }\n        return digitCounts[n - 1] * 2;"
- "        long[][] DP = new long[n + 1][2];\n        DP[1][0] = 1;\n        DP[1][1]\
  \ = 1;\n        for (int k = 2; k <= n; k++) {\n            DP[k][0] = DP[k - 1][0]\
  \ + DP[k - 1][1];\n            DP[k][1] = DP[k - 1][0];\n        }\n        return\
  \ (int) (DP[n][0] + DP[n][1]);"
- "        if (n == 1) return 2;\n        return 4*(int)Math.pow(3, n-2);"
- "        // Your code here\n        return 0;"
- "        // If n is 1, return 1.\n        if (n == 1) return 1;\n        // If n\
  \ is not 1, return startsOneEnds(n-1) + startsOneEnds(n-2).\n        return startsOneEnds(n-1)\
  \ + startsOneEnds(n-2);"
- "        if (n == 1) return 1;\n        // We count those numbers that end with\
  \ 1 and multiply by 10.\n        // Note that numbers that start with 1 and end\
  \ with 1 must belong to\n        // the count of numbers that end with 1 (because\
  \ to end with 1 is a\n        // more restrictive property).\n        return 10\
  \ * startsOneEnds(n - 1) + (int)Math.pow(10, n - 1);"
- "        // We use a dynamic programming approach. Let dp[i] be the number of\n\
  \        // positive integers of length i which start or end with 1. We have:\n\
  \        // dp[0] = 0, dp[1] = 1\n        // dp[2] = 9, since:\n        // 1x\n\
  \        // x1\n        // dp[3] = 90, since:\n        // xx1, 1xx\n        // dp[4]\
  \ = 900, since:\n        // xxx1, 1xxx\n        // dp[5] = 9000, since:\n      \
  \  // xxxx1, 1xxxx\n        // For dp[i], when building a number of length i, we\
  \ can either attach\n        // a 1 to the front or back of a length i-1 number.\
  \ When attaching 1 to\n        // the front, we have 0 options for the first digit\
  \ as it's already 1.\n        // There are 10 options for the rest of the number,\
  \ so we have 10(dp[i-1]\n        // options). When attaching 1 to the back, we have\
  \ 9 options for the\n        // last digit as it's already 1. There are 9 options\
  \ for the rest of the\n        // number, so we have 9(dp[i-1]). In total, we have:\n\
  \        // 10(dp[i-1]) + 9(dp[i-1]) = 19(dp[i-1])\n        // dp[i] = dp[i-1] *\
  \ 19\n        int[] dp = new int[n+1];\n        dp[0] = 0;\n        dp[1] = 1;\n\
  \        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i-1] * 19;\n   \
  \     }\n        return dp[n];"
- "        if (n == 1) return 2;\n        if (n == 2) return 4;\n        return (10\
  \ - n + 1) * startsOneEnds(n - 1) + (n - 1) * 10 * startsOneEnds(n - 2);"
- "        if (n == 1) {\n            return 2;\n        } else {\n            return\
  \ startsOneEnds(n - 1) + 9 * ((int) Math.pow(10, n - 2));\n        }"
- "        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n  \
  \      for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + 9 * (int)\
  \ Math.pow(10, i - 2);\n        }\n        return dp[n];"
- "        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        a[1]\
  \ = 1;\n        b[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            a[i]\
  \ = a[i - 1] + b[i - 1];\n            b[i] = a[i - 1];\n        }\n        return\
  \ a[n] + b[n];"
- "        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        a[1]\
  \ = 1;\n        b[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            a[i]\
  \ = 9 * b[i - 1];\n            b[i] = a[i - 1] + b[i - 1];\n        }\n        return\
  \ a[n] + b[n];"
- "        int[] a = new int[n];\n        int[] b = new int[n];\n        int[] c =\
  \ new int[n];\n        int[] d = new int[n];\n        a[0] = b[0] = c[0] = d[0]\
  \ = 1;\n        if (n == 1) return 4;\n        a[1] = 1;\n        b[1] = c[1] =\
  \ d[1] = 3;\n        if (n == 2) return 7;\n        for (int i = 2; i < n; i++)\
  \ {\n            a[i] = a[i - 1] + b[i - 1];\n            b[i] = a[i - 1] + b[i\
  \ - 1] + c[i - 1] + d[i - 1];\n            c[i] = a[i - 1] + b[i - 1] + c[i - 1]\
  \ + d[i - 1];\n            d[i] = c[i - 1] + d[i - 1];\n        }\n        return\
  \ a[n - 1] + b[n - 1] + c[n - 1] + d[n - 1];"
- "        if (n == 1) {\n            return 1;\n        }\n        return (int)Math.pow(10,\
  \ n - 1) + 9 * (int)Math.pow(10, n - 2);"
- "        // if n == 1, there is one such number.\n        if (n == 1) return 1;\n\
  \        // if n == 2, there are 11, 21, 31, ..., 91, and count(n-1)\n        if\
  \ (n == 2) return 10 + startsOneEnds(n-1);\n        // if n > 2, there are 1, 11,\
  \ 111, ..., 111...11, and 10*count(n-1).\n        return (int)Math.pow(10, n-1)\
  \ + 10*startsOneEnds(n-1);"
- "        int m = 10;\n        if (n == 1) {\n            return 2;\n        }\n\
  \        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        a[1]\
  \ = 2;\n        b[1] = 2;\n        for (int i = 2; i <= n; i++) {\n            a[i]\
  \ = a[i - 1] + b[i - 1];\n            b[i] = a[i - 1];\n        }\n        return\
  \ a[n] + b[n];"
- '        return 2*(int)Math.pow(9, n-1);'
- '        return (int)Math.pow(9, n - 1);'
- "        if (n == 1) {\n            return 2;\n        }\n        return startsOneEnds(n\
  \ - 1) + endsOne(n - 1);"
- '        return (int) Math.pow(3, n - 1);'
- "        // F[n] is the number of n-digit positive integers that start with 1.\n\
  \        // F[n] = 9 * F[n-1] + 1\n        // Note that F[n] - 1 is the number of\
  \ n-digit positive integers that end\n        // with 1.\n        // F[n] - 1 =\
  \ 8 * F[n-1] + 8 * F[n-2]\n        // Thus, F[n] - 1 = (8 * F[n-1] + 1) - F[n-1]\
  \ = 8 * F[n-1] + 1 - F[n-1]\n        //           = 9 * F[n-1] - F[n-1] = 9 * F[n-1]\
  \ - F[n-1] = 8 * F[n-1]\n        // Thus, the number of n-digit positive integers\
  \ that start or end with 1\n        // is 9 * F[n-1] - F[n-1] + 1 = 8 * F[n-1] +\
  \ 1.\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 1; i < n; i++)\
  \ {\n            int f3 = 9 * f2 + 1;\n            f1 = f2;\n            f2 = f3;\n\
  \        }\n        return 8 * f1 + 1;"
- "        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n  \
  \      for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n\
  \        }\n        return dp[n];"
- "        if (n == 1) return 2;\n        int digit = 1;\n        int total = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            digit *= 10;\n        }\n  \
  \      digit /= 10;\n        for (int i = 1; i < digit; i++) {\n            String\
  \ s = Integer.toString(i);\n            if (s.charAt(0) == '1' || s.charAt(s.length()\
  \ - 1) == '1') {\n                total++;\n            }\n        }\n        return\
  \ total;"
- '        return f(n) - f(n - 1);'
- "        if (n == 1) {\n            return 10;\n        } else {\n            return\
  \ (int) Math.pow(10, n - 1) + 9 * (int) Math.pow(10, n - 2);\n        }"
- "        if (n == 1) return 2;\n        // Count the number of (n-1)-digit positive\
  \ integers that start or end\n        // with a digit other than 1.\n        int\
  \ count = (int) Math.pow(8, n - 1);\n        // Now add the number of (n-1)-digit\
  \ positive integers that start with\n        // 1.\n        count += 2 * startsOneEnds(n\
  \ - 1);\n        return count;"
- "        if (n == 1) return 1;\n        if (n == 2) return 3;\n        int[] a =\
  \ new int[n + 1];\n        a[1] = 1;\n        a[2] = 3;\n        for (int i = 3;\
  \ i <= n; i++) {\n            a[i] = (a[i - 1] + a[i - 2]) * 2;\n        }\n   \
  \     return a[n];"
- '        return n * (n + 1) / 2;'
- "        if (n == 1) {\n            return 2;\n        } else {\n            return\
  \ (int) (n * Math.pow(10, n - 1)) +\n                    (int) (9 * (Math.pow(10,\
  \ n - 1) - 1));\n        }"
- "        // We do this in three steps. First we calculate all the n-digit\n    \
  \    // numbers that start with 1. We do this by generating all n-digit\n      \
  \  // numbers that start with 1 and subtracting all the ones that start\n      \
  \  // with 1 and end with 0. Then we do the same for the n-digit numbers\n     \
  \   // that end with 1.\n        if (n == 1) {\n            return 2;\n        }\n\
  \        // Generate all the numbers that start with 1 and subtract those that\n\
  \        // start with 1 and end with 0.\n        int result = ((int) Math.pow(10,\
  \ n - 1)) - (int) Math.pow(9, n - 1);\n        // Subtract all the numbers that\
  \ start with 0.\n        result -= (int) Math.pow(9, n - 1);\n        // Add all\
  \ the numbers that end with 1.\n        result += (int) Math.pow(9, n - 1);\n  \
  \      return result;"
- "        if (n == 1) {\n            return 1;\n        }\n        int count = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            count +=  Math.pow(10, i) *\
  \ 9;\n        }\n        return count;"
- "        if (n == 1) return 2;\n        if (n == 2) return 3;\n        return 1\
  \ + 2 * (int)Math.pow(10, n - 1);"
- "        // 3, 4, 5, 6, 7, 8, 9\n        // 0, 1, 2, 3, 4, 5, 6\n        // 0, 6,\
  \ 15, 20, 15, 6, 1\n        int[] odd = new int[n + 1];\n        int[] even = new\
  \ int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            if (i % 2 ==\
  \ 0)\n                even[i] = i / 2 + 1;\n            else\n                odd[i]\
  \ = even[i - 1];\n        }\n        int result = 0;\n        for (int i = 0; i\
  \ <= n; i++) {\n            if (i % 2 == 0)\n                result += odd[i];\n\
  \            else\n                result += even[i];\n        }\n        return\
  \ result;"
- "        int res = 0;\n        if (n <= 0) return res;\n        if (n == 1) return\
  \ 1;\n        int lastDigit = 1;\n        int priorDigit = 0;\n        int shift\
  \ = (int)Math.pow(10, n - 1);\n        for (int i = 0; i < n; i++) {\n         \
  \   if (i != 0) {\n                priorDigit += lastDigit;\n                lastDigit\
  \ = 0;\n            }\n            lastDigit += shift - priorDigit;\n        }\n\
  \        res = lastDigit;\n        return res;"
- "        if (n == 1) {\n            return 2;\n        }\n        return 2 * (int)\
  \ Math.pow(5, n - 1);"
- "        if (n == 1) return 2;\n        int count = 3;\n        for (int i = 1;\
  \ i < n - 1; i++) {\n            count = count * 9;\n        }\n        return count;"
- "        int[] dp = new int[n + 1];\n        dp[0] = 1; // empty string.\n     \
  \   for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1] * 9;\n       \
  \     if (i > 1) {\n                dp[i] += dp[i - 2] * 9;\n            }\n   \
  \     }\n        return dp[n];"
- "        if (n == 1) return 1;\n        if (n == 2) return 2;\n        else return\
  \ startsOneEnds(n - 1) + startsOneEnds(n - 2);"
- '        return 0;'
- '        return 0;'
- '        return fib(n+2);'
- "        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            ans +=\
  \ (int) Math.pow(5, i);\n        }\n        return ans;"
- "        // There are n possibilities for the first digit and a total of\n     \
  \   // 9 - 1 = 8 possibilities for the remaining digits.\n        // The first and\
  \ last numbers can't be zero, so there are a total of\n        // n * 8 * (n - 1)\n\
  \        // possibilities.\n        if (n == 1) {\n            return 1;\n     \
  \   }\n        return n * 8 * (n - 1);"
- "        // f[k][x] = the number of k-digit numbers with x as its first digit\n\
  \        // We must count the number of possible k-digit numbers that either start\n\
  \        // or end with 1\n        // for k = n, f[n][1] + f[n][0]\n        // for\
  \ k = n - 1, f[n - 1][1] + f[n - 1][0] - f[n - 1][0] * f[n - 1][0]\n        // for\
  \ k = n - 2, f[n - 2][1] + f[n - 2][0] - f[n - 2][0] * f[n - 2][0]\n        // ...\n\
  \        // for k = 1, f[1][1] + f[1][0] - f[1][0] * f[1][0]\n        // This is\
  \ because the last n - 1 digits are free to be anything other\n        // than 0.\
  \ If they are 0, then the number must start with 0.\n        // This can be simplified\
  \ as\n        // f[n][1] + f[n][0] - (f[n - 1][0] - f[n - 1][1]) * f[n - 1][0]\n\
  \        // f[n][1] + f[n][0] - f[n - 1][0] * f[n - 1][0] + f[n - 1][1] * f[n -\
  \ 1][0]\n        // f[n][1] + f[n][0] - f[n - 1][0] * f[n - 1][0] + f[n - 1][0]\
  \ * f[n - 1][1]\n        // f[n][1] + f[n][0] - f[n - 1][0] * f[n - 1][0] + f[n\
  \ - 1][0] * f[n - 1][1]\n        // Now we can solve the recurrence relation\n \
  \       // f[n][1] + f[n][0] - f[n - 1][0] * f[n - 1][0] + f[n - 1][0] * f[n - 1][1]\n\
  \        // f[n]["
- "        if (n == 1) {\n            return 2;\n        } else {\n            return\
  \ (int) Math.pow(10, n - 1) + (int) Math.pow(10, n - 2);\n        }"
- '        return 1;'
- "        // Include: 1, 10, 100, 1000...\n        if (n == 1) return 1;\n      \
  \  // Include: 1, 11, 21, 31, 41, 51, 61, 71, 81, 91, 110, 210...\n        int endOne\
  \ = (int)Math.pow(10, n-1);\n        // Include: 101, 201, 301, 401, 501, 601, 701,\
  \ 801, 901, 1001, 1101...\n        int startOne = 9 * (int)Math.pow(10, n-2);\n\
  \        return endOne + startOne;"
- "        // Your code goes here.\n        return 0;"
- "        int sum = 0;\n        for (int i = (int) Math.pow(10, n - 1); i < (int)\
  \ Math.pow(10, n); i++) {\n            if (String.valueOf(i).charAt(0) == '1' ||\
  \ String.valueOf(i).charAt(String.valueOf(i).length() - 1) == '1') {\n         \
  \       sum++;\n            }\n        }\n        return sum;"
- "        // There are n * 9 * (10^(n-1)) such numbers.\n        return n * 9 * (int)\
  \ Math.pow(10, n - 1);"
- "        int tot = 0;\n        for (int p = 1; p <= n; p++) {\n            int decs\
  \ = 0;\n            int ds = 1;\n            int q = 1;\n            while (q <=\
  \ p) {\n                decs += ds;\n                q++;\n                ds *=\
  \ 10;\n            }\n            tot += decs;\n        }\n        return tot;"
- "        if (n == 1) return 1;\n        int[][] dp = new int[n][2];\n        for\
  \ (int i = 0; i < 10; i++) dp[0][i == 1 ? 1 : 0]++;\n        for (int i = 1; i <\
  \ n; i++)\n            for (int j = 0; j < 10; j++) {\n                if (j ==\
  \ 1) dp[i][1] += dp[i - 1][0] + dp[i - 1][1];\n                else dp[i][0] +=\
  \ dp[i - 1][0] + dp[i - 1][1];\n            }\n        return dp[n - 1][0] + dp[n\
  \ - 1][1];"
- "        if (n == 1) return 1;\n        if (n == 2) return 2;\n        // f(n) =\
  \ f(n-1) + f(n-2)\n        // f(n) = f(n-1) + f(n-2) + f(n-3)\n        int twoDigits\
  \ = 2;\n        int oneDigit = 1;\n        int sum = 0;\n        for (int i = 3;\
  \ i <= n; i++) {\n            sum = twoDigits + oneDigit;\n            oneDigit\
  \ = twoDigits;\n            twoDigits = sum;\n        }\n        return sum;"
- "        int ans = 0;\n        int[] digits = new int[n];\n        int ways = 0;\n\
  \        for (int i = 0; i < n; i++) {\n            digits[i] = 1;\n        }\n\
  \        for (int i = 0; i < n; i++) {\n            ways = 1;\n            for (int\
  \ j = 0; j < n; j++) {\n                if (j != i) {\n                    ways\
  \ *= (digits[j] - 1);\n                }\n            }\n            ans += ways;\n\
  \        }\n        return ans;"
- "        if (n == 1) return 2;\n        return (int) Math.pow(10, n - 1) + (int)\
  \ Math.pow(10, n - 2);"
- "        if (n == 1) return 2;\n        int r = startsOneEnds(n - 1);\n        return\
  \ r + (int) Math.pow(10, n - 1);"
- "        // If n == 1, you can have 1,2,3,4,5,6,7,8,9\n        if (n == 1) {\n \
  \           return 9;\n        }\n        // If n == 2, you can have 10,11,12,13,14,15,16,17,18,19,\n\
  \        //                             20,21,22,23,24,25,26,27,28,29,\n       \
  \ //                             30,31,32,33,34,35,36,37,38,39,\n        //    \
  \                         40,41,42,43,44,45,46,47,48,49,\n        //           \
  \                  50,51,52,53,54,55,56,57,58,59,\n        //                  \
  \           60,61,62,63,64,65,66,67,68,69,\n        //                         \
  \    70,71,72,73,74,75,76,77,78,79,\n        //                             80,81,82,83,84,85,86,87,88,89,\n\
  \        //                             90,91,92,93,94,95,96,97,98,99\n        if\
  \ (n == 2) {\n            return 9 * 9;\n        }\n        // For n >= 3, if you\
  \ start with 1, you can have any length from\n        // 1 to n-1, therefore you\
  \ have 9 * (1 + 2 + ... + n-1) numbers that\n        // start with 1.\n        int\
  \ count = 9 * (1 + (n - 1) * (n - 1) / 2);\n        // For n >= 2, if you end with\
  \ 1, you can have any length from\n        // 2 to n, therefore you have 9 * (2\
  \ + 3 + ... + n) numbers that\n        // end with 1.\n        count += 9 * (n *\
  \ (n + 1) / 2 - 1);\n        // We counted the numbers ending with 1 twice, because\n\
  \        // for each number that starts with 1, there is a number that ends with\
  \ 1.\n        // Subtract the number of numbers ending with 1 that start with 1.\n\
  \        count -= 9 * (n - 1);\n        return count;"
- '        return 1 + (int) Math.pow(10, n - 1);'
- "        if (n == 1) {\n            return 2;\n        }\n        return startsOneEnds(n\
  \ - 1) + (int) (Math.pow(2, n - 1));"
- "        if (n == 1) {\n            return 1;\n        }\n        int digits = 1;\n\
  \        int count = 1;\n        while (digits <= n) {\n            count += 9 *\
  \ (int) Math.pow(10, digits - 1);\n            digits++;\n        }\n        return\
  \ count;"
- "        // 111\n        // 112\n        // 113\n        // 114\n        // 115\n\
  \        // 116\n        // 117\n        // 118\n        // 119\n        // 1,121\n\
  \        // 1,122\n        // 1,123\n        // 1,124\n        // 1,125\n      \
  \  // 1,126\n        // 1,127\n        // 1,128\n        // 1,129\n        // 11,211\n\
  \        // 11,212\n        // 11,213\n        // 11,214\n        // 11,215\n  \
  \      // 11,216\n        // 11,217\n        // 11,218\n        // 11,219\n    \
  \    // 111,221\n        // 111,222\n        // 111,223\n        // 111,224\n  \
  \      // 111,225\n        // 111,226\n        // 111,227\n        // 111,228\n\
  \        // 111,229\n        // 1111\n        // 1112\n        // 1113\n       \
  \ // 1114\n        // 1115\n        // 1116\n        // 1117\n        // 1118\n\
  \        // 1119\n        // 11,121\n        // 11,122\n        // 11,123\n    \
  \    // 11,124\n        // 11,125\n        // 11,126\n        // 11,127\n      \
  \  // 11,128\n        // 11,129\n        // 111,211\n        // 111,212\n      \
  \  // 111,213\n        // 111,214\n        // 111,215\n        // 111,216\n    \
  \    // 111,217\n        // 111,218\n        // 111,219\n        // 1111,221\n \
  \       // 1111,222\n        // 1111,223\n        // 1111,224\n        // 1111,225\n\
  \        // 1111,226\n        // 1111,227\n        // 1111,228\n        // 1111,229\n\
  \        // 11111\n        // 11112\n        // 11113\n        // 11114\n      \
  \  // 11115\n        // 11116\n        // 11117\n        // 11118\n        // 11119\n\
  \        // 1111,121\n        // 1111,122\n        // 1111,123\n        // 1111,124\n\
  \        // 1111,125\n        // 1111,126\n        // 1111,127\n        // 111"
- '        return 0;'
- "        // For 1-digit numbers, we have 1 and then this is complete.\n        if\
  \ (n == 1) {\n            return 1;\n        }\n        // For 2-digit numbers,\
  \ we have 10 and 11, for 2 possibilities.\n        if (n == 2) {\n            return\
  \ 2;\n        }\n        // Recursively compute the number of possibilities for\
  \ (n-1)-digit numbers.\n        int[] previousDigitPossibilities = new int[n - 1];\n\
  \        int count = 1;\n        previousDigitPossibilities[0] = 1;\n        previousDigitPossibilities[1]\
  \ = 2;\n        for (int i = 2; i < n - 1; i++) {\n            previousDigitPossibilities[i]\
  \ = previousDigitPossibilities[i - 1] + previousDigitPossibilities[i - 2];\n   \
  \     }\n        // We compute the count of n-digit numbers that start with 1 by:\n\
  \        // Adding the count of (n-1)-digit numbers that start with 1.\n       \
  \ // Adding the count of (n-1)-digit numbers that start with 0 that\n        //\
  \ have a 1 in the 2nd to last place.\n        count += previousDigitPossibilities[n\
  \ - 2];\n        count += previousDigitPossibilities[n - 3];\n        // We compute\
  \ the count of n-digit numbers that end with 1 by:\n        // Adding the count\
  \ of (n-1)-digit numbers that end with 1.\n        // Adding the count of (n-1)-digit\
  \ numbers that end with 0 that\n        // have a 1 in the 2nd place.\n        count\
  \ += previousDigitPossibilities[n - 2];\n        count += previousDigitPossibilities[n\
  \ - 3];\n        // We need to subtract n-digit numbers that both start and end\
  \ with 1\n        // because we double-counted them.\n        count -= previousDigitPossibilities[n\
  \ - 3];\n        return count;"
- "        int cnt = 0;\n        for (int i = 1; i <= 9; i++) {\n            for (int\
  \ j = 0; j <= 9; j++) {\n                for (int k = 0; k <= 9; k++) {\n      \
  \              String s = Integer.toString(i) + Integer.toString(j) + Integer.toString(k);\n\
  \                    if (s.startsWith(\"1\") || s.endsWith(\"1\")) {\n         \
  \               cnt++;\n                    }\n                }\n            }\n\
  \        }\n        return cnt;"
- '        return f(n - 1) + 1;'
- '        return 0;'
- "        if (n == 1) {\n            return 1;\n        }\n        int result = 0;\n\
  \        if (n % 2 == 0) {\n            int half = n / 2;\n            result +=\
  \ Math.pow(3, half - 1);\n            result += Math.pow(4, half - 1);\n       \
  \ } else {\n            int half = n / 2;\n            result += Math.pow(4, half);\n\
  \            result += Math.pow(3, half);\n        }\n        return result;"
- '        return -1;'
- "        if (n == 1) return 1;\n        return (int)Math.pow(2, n - 1) - 1;"
- "        int a[] = new int[n + 1];\n        for (int i = 0; i <= n; i++)\n     \
  \       a[i] = i == 0 ? 0 : i == 1 ? 2 : a[i - 1] + a[i - 2];\n        return a[n];"
language: java
name: HumanEval_83_starts_one_ends
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Given a positive integer n, return the count of the numbers\
  \ of n-digit\n    // positive integers that start or end with 1.\n    public static\
  \ int startsOneEnds(int n) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(startsOneEnds((1))\
  \ == (1));\n    assert(startsOneEnds((2)) == (18));\n    assert(startsOneEnds((3))\
  \ == (180));\n    assert(startsOneEnds((4)) == (1800));\n    assert(startsOneEnds((5))\
  \ == (18000));\n    }\n\n}\n"
