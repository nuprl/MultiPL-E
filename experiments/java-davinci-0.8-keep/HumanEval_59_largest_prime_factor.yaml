completions:
- "        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0)\
  \ {\n                return largestPrimeFactor(n / i);\n            }\n        }\n\
  \        return n;"
- "        // >>> largest_prime_factor(13195)\n        // 29\n        // >>> largest_prime_factor(2048)\n\
  \        // 2\n        // >>> largest_prime_factor(600851475143)\n        // 6857\n\
  \        // >>> largest_prime_factor(314159)\n        // 3\n        // >>> largest_prime_factor(315)\n\
  \        // 5\n        // >>> largest_prime_factor(906609)\n        // 906609\n\
  \        // >>> largest_prime_factor(93819012551L)\n        // 379\n        // >>>\
  \ largest_prime_factor(930675566)\n        // 139\n        return 0;"
- '        return primeFactors(n).stream().reduce(Math::max).get();'
- "        // \n        while(n % 2 == 0) {\n            n /= 2;\n        }\n    \
  \    int m = n;\n        for(int i = 3; i <= m; i += 2) {\n            if(n % i\
  \ == 0) {\n                n /= i;\n                m = n;\n            }\n    \
  \    }\n        return n;"
- "\t/* IMPLEMENT THIS METHOD! */\n\t// Fill in the implementation here\n\tint factor\
  \ = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t    while (n % i == 0) {\n\t\tfactor\
  \ = i;\n\t\tn /= i;\n\t    }\n\t}\n\treturn factor;"
- "        if (n <= 1) {\n            throw new IllegalArgumentException(\"n must\
  \ be > 1\");\n        }\n        // write your code here\n        return -1;"
- "        for (int i = 2; i < Math.sqrt(n); i++) {\n            if (n % i == 0) {\n\
  \                return largestPrimeFactor(n / i);\n            }\n        }\n \
  \       return n;"
- "        int max = 1;\n        while (n % 2 == 0) {\n            max = 2;\n    \
  \        n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\
  \ {\n            while (n % i == 0) {\n                max = i;\n              \
  \  n /= i;\n            }\n        }\n        if (n > 2) {\n            max = n;\n\
  \        }\n        return max;"
- "        int prime = 1;\n        int curr = n;\n        while (curr % 2 == 0) {\n\
  \            prime = 2;\n            curr /= 2;\n        }\n        int i = 3;\n\
  \        while (i * i <= curr) {\n            if (curr % i == 0) {\n           \
  \     prime = i;\n                curr /= i;\n            } else {\n           \
  \     i += 2;\n            }\n        }\n        return prime;"
- "        int largest = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n \
  \       }\n        if (n == 1) {\n            return largest;\n        }\n     \
  \   largest = 3;\n        while (n > 1) {\n            while (n % largest == 0)\
  \ {\n                n /= largest;\n            }\n            largest += 2;\n \
  \       }\n        return largest - 2;"
- "        int i = 2;\n        while (i <= n) {\n            if (n % i == 0) {\n \
  \               if (isPrime(n / i)) return n / i;\n                else n /= i;\n\
  \            } else i++;\n        }\n        return 1;"
- "        ArrayList<Integer> factors = new ArrayList<Integer>();\n        int prime\
  \ = 2;\n        while (n > 1) {\n            while (n % prime == 0) {\n        \
  \        factors.add(prime);\n                n /= prime;\n            }\n     \
  \       prime++;\n        }\n        return factors.get(factors.size() - 1);"
- "        int largestPrimeFactor = 0;\n        for (int i = 2; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                boolean isPrime = true;\n       \
  \         for (int j = 2; j <= i / 2; j++) {\n                    if (i % j == 0)\
  \ {\n                        isPrime = false;\n                        break;\n\
  \                    }\n                }\n                if (isPrime) {\n    \
  \                largestPrimeFactor = i;\n                }\n            }\n   \
  \     }\n        return largestPrimeFactor;"
- "        int ans = 2;\n        while (n > ans) {\n            if (n % ans == 0)\
  \ {\n                n /= ans;\n            } else {\n                ans++;\n \
  \           }\n        }\n        return ans;"
- "        while (n % 2 == 0) {\n            n /= 2;\n        }\n        int result\
  \ = 0;\n        while (n > 1) {\n            int factor = 3;\n            while\
  \ (n % factor != 0) {\n                factor += 2;\n            }\n           \
  \ n /= factor;\n            result = factor;\n        }\n        return result;"
- "        // Hint: a number n is prime if and only if it's divisible only by 1 and\
  \ itself.\n        // Hint: 2 is the only even prime number.\n        // Hint: try\
  \ to find the largest prime factor of a number m by finding\n        // the smallest\
  \ prime factor of m.\n        return 0;"
- "        // Fill this in.\n        int largestPrimeFactor = 2;\n        while (n\
  \ > 1) {\n            if (n % largestPrimeFactor == 0) {\n                n /= largestPrimeFactor;\n\
  \            } else {\n                largestPrimeFactor++;\n            }\n  \
  \      }\n        return largestPrimeFactor;"
- "        int factor = 1;\n        while (n % 2 == 0) {\n            factor = 2;\n\
  \            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i +=\
  \ 2) {\n            while (n % i == 0) {\n                factor = i;\n        \
  \        n /= i;\n            }\n        }\n        if (n > 2) {\n            factor\
  \ = n;\n        }\n        return factor;"
- "        assert n > 1;\n        int i = 2;\n        while (n % i != 0)\n       \
  \     i++;\n        while (n % i == 0)\n            n /= i;\n        return n;"
- "        // end is sqrt(n) because n could have at most one prime > sqrt(n)\n  \
  \      for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i ==\
  \ 0) return largestPrimeFactor(n / i);\n        }\n        return n;"
- '        return -1;'
- "        int div = 2;\n        int k = n;\n        while (k > 1) {\n           \
  \ if (k % div == 0) {\n                k /= div;\n            } else {\n       \
  \         div++;\n            }\n        }\n        return div;"
- '        return 0;'
- "        List<Integer> factors = new ArrayList<>();\n        for (int i = 2; i <=\
  \ Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \            }\n        }\n        return largestPrimeFactorHelper(n, factors);"
- "        ArrayList<Integer> factors = new ArrayList<Integer>();\n        int i =\
  \ 2;\n        while (n > 1) {\n            while (n % i == 0) {\n              \
  \  factors.add(i);\n                n /= i;\n            }\n            i++;\n \
  \       }\n        return factors.get(factors.size() - 1);"
- "        int count = 2;\n        while (count * count <= n) {\n            if (n\
  \ % count == 0) {\n                n /= count;\n            } else {\n         \
  \       count++;\n            }\n        }\n        return n;"
- "        // The largest prime factor of n has to be <= sqrt(n).\n        // Try\
  \ all primes <= sqrt(n).\n        int limit = (int) Math.sqrt(n);\n        int largest\
  \ = -1;\n        for (int i = 2; i <= limit; i++) {\n            if (n % i == 0\
  \ && Problem.isPrime(i)) {\n                largest = i;\n            }\n      \
  \  }\n        return largest;"
- "        int largest = 1;\n        int i = 2;\n        while (i <= n) {\n      \
  \      while (n % i == 0) {\n                largest = i;\n                n /=\
  \ i;\n            }\n            i++;\n        }\n        return largest;"
- '        return -1;'
- "        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n        \
  \        int d = n / i;\n                if (isPrime(d)) {\n                   \
  \ return d;\n                }\n            }\n        }\n        return -1;"
- "        if (n % 2 == 0) {\n            return largestPrimeFactor(n / 2);\n    \
  \    }\n        for (int i = 3; i < n; i += 2) {\n            if (n % i == 0) {\n\
  \                return largestPrimeFactor(n / i);\n            }\n        }\n \
  \       return n;"
- "        int max = 0;\n        int d = n;\n        while (d % 2 == 0) {\n      \
  \      max = 2;\n            d /= 2;\n        }\n        int p = 3;\n        while\
  \ (d != 1) {\n            while (d % p == 0) {\n                max = p;\n     \
  \           d /= p;\n            }\n            p += 2;\n        }\n        return\
  \ max;"
- "        int x = n;\n        int i = 2;\n        while (i <= x) {\n            if\
  \ (x % i == 0) {\n                x /= i;\n            } else {\n              \
  \  i++;\n            }\n        }\n        return i;"
- '        throw new RuntimeException("TODO: implement");'
- "        // TODO:\n        // return -1;\n        if (n <= 1) return -1;\n     \
  \   if (n <= 3) return n;\n        int largest = 0;\n        int divisor = 2;\n\
  \        while (n > 1) {\n            if (n % divisor == 0) {\n                n\
  \ /= divisor;\n                largest = divisor;\n            } else {\n      \
  \          divisor++;\n            }\n        }\n        return largest;"
- "        int p = 1;\n        for (int i = 2; i <= n; i++) {\n            if (isFactor(n,\
  \ i) && isPrime(i)) {\n                p = i;\n            }\n        }\n      \
  \  return p;"
- "        ArrayList<Integer> primes = Utils.getPrimes(n);\n        int m = -1;\n\
  \        for (int i = primes.size() - 1; i >= 0; i--) {\n            if (n % primes.get(i)\
  \ == 0) {\n                m = primes.get(i);\n                break;\n        \
  \    }\n        }\n        return m;"
- "        for (int d = 2; d < n; d++) {\n            if (n % d == 0) {\n        \
  \        return largestPrimeFactor(n / d);\n            }\n        }\n        return\
  \ n;"
- "        int largestPrimeFactor = 0;\n        while (n % 2 == 0) {\n           \
  \ largestPrimeFactor = 2;\n            n = n / 2;\n        }\n        for (int i\
  \ = 3; i <= Math.sqrt(n); i = i + 2) {\n            while (n % i == 0) {\n     \
  \           largestPrimeFactor = i;\n                n = n / i;\n            }\n\
  \        }\n        if (n > 2) {\n            largestPrimeFactor = n;\n        }\n\
  \        return largestPrimeFactor;"
- "        int p = 2;\n        while (p < n) {\n            if (n % p == 0) {\n  \
  \              n /= p;\n            } else {\n                p++;\n           \
  \ }\n        }\n        return p;"
- "        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n\
  \                n /= i;\n            } else {\n                i++;\n         \
  \   }\n        }\n        return n;"
- '        return 0;'
- "        int limit = (int) Math.sqrt(n);\n        for (int i = limit; i > 0; i--)\
  \ {\n            if (n % i == 0 && isPrime(i)) {\n                return i;\n  \
  \          }\n        }\n        return 0;"
- '        return 0;'
- "        if (n == 1) {\n            return 1;\n        }\n        int factor = 2;\n\
  \        for (; factor <= n / factor; factor++) {\n            if (n % factor ==\
  \ 0) {\n                n /= factor;\n                break;\n            }\n  \
  \      }\n        return largestPrimeFactor(n);"
- '        throw new UnsupportedOperationException("TODO: implement");'
- "        int cur = 2;\n        while (n > 1) {\n            while (n % cur == 0)\
  \ {\n                n /= cur;\n            }\n            cur++;\n        }\n \
  \       return cur - 1;"
- "        int p = 2;\n        while (n > 1) {\n            if (n % p == 0) {\n  \
  \              n /= p;\n            } else {\n                p++;\n           \
  \ }\n        }\n        return p;"
- "        // >>> largest_prime_factor(2048)\n        // 2\n        return n;"
- "        int largestPrimeFactor = 1;\n        for (int i = 2; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                boolean isPrime = true;\n       \
  \         for (int j = 2; j < i; j++) {\n                    if (i % j == 0) {\n\
  \                        isPrime = false;\n                        break;\n    \
  \                }\n                }\n                if (isPrime) {\n        \
  \            largestPrimeFactor = i;\n                }\n            }\n       \
  \ }\n        return largestPrimeFactor;"
- "        for (int i = 2; i <= n / i; i++) {\n            while (n % i == 0) {\n\
  \                n /= i;\n            }\n        }\n        return n;"
- "        int max = -1;\n        while (n % 2 == 0) {\n            max = 2;\n   \
  \         n >>= 1;\n        }\n        for (int i = 3; i <= n; i += 2) {\n     \
  \       while (n % i == 0) {\n                max = i;\n                n = n /\
  \ i;\n            }\n        }\n        return max;"
- "        int largest_prime_factor = 2;\n        int divisor = 3;\n        while\
  \ (n > largest_prime_factor) {\n            if (n % divisor == 0) {\n          \
  \      largest_prime_factor = divisor;\n                n /= divisor;\n        \
  \    } else {\n                divisor += 2;\n            }\n        }\n       \
  \ return largest_prime_factor;"
- "        int largest_prime_factor = -1;\n        while (n % 2 == 0) {\n        \
  \    largest_prime_factor = 2;\n            n /= 2;\n        }\n        for (int\
  \ i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n      \
  \          largest_prime_factor = i;\n                n /= i;\n            }\n \
  \       }\n        if (n > 2) {\n            largest_prime_factor = n;\n       \
  \ }\n        return largest_prime_factor;"
- "        // Base case\n        if (isPrime(n)) return n;\n        // Recursive case\n\
  \        int[] factors = factor(n);\n        int largestPrimeFactor = 0;\n     \
  \   for (int factor : factors) {\n            int primeFactor = largestPrimeFactor(factor);\n\
  \            if (primeFactor > largestPrimeFactor) largestPrimeFactor = primeFactor;\n\
  \        }\n        return largestPrimeFactor;"
- "        // BEGIN SOLUTION\n        int largest_factor = -1;\n        int d = 2;\n\
  \        while (n > 1) {\n            while (n % d == 0) {\n                largest_factor\
  \ = d;\n                n /= d;\n            }\n            d += 1;\n        }\n\
  \        return largest_factor;\n        // END SOLUTION"
- "        int lpf = 0;\n        for (int i = 2; i <= n; i++) {\n            if (n\
  \ % i == 0) {\n                lpf = i;\n                n /= i;\n             \
  \   i--;\n            }\n        }\n        return lpf;"
- '        return 0;'
- '        return -1;'
- '        return 0;'
- "        // TODO write this code.\n        return 0;"
- "        ArrayList<Integer> factors = new ArrayList<Integer>();\n        for (int\
  \ i = 2; i <= n; i++) {\n            while (n % i == 0) {\n                factors.add(i);\n\
  \                n /= i;\n            }\n        }\n        return factors.get(factors.size()\
  \ - 1);"
- "        if (n % 2 == 0) {\n            return largestPrimeFactor(n / 2);\n    \
  \    }\n        for (int i = 3; i < n / 2; i += 2) {\n            if (n % i == 0)\
  \ {\n                if (isPrime(i)) {\n                    return i;\n        \
  \        }\n            }\n        }\n        return -1;"
- "        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n\
  \                n /= i;\n            } else {\n                i++;\n         \
  \   }\n        }\n        return n;"
- "        if (n < 4) {\n            return 1;\n        }\n\n        int largestPrimeFactor\
  \ = 1;\n        for (int i = 2; i <= n / 2; i++) {\n            if (isPrime(i) &&\
  \ n % i == 0) {\n                largestPrimeFactor = i;\n            }\n      \
  \  }\n\n        return largestPrimeFactor;"
- "        if (n <= 1) {\n            throw new IllegalArgumentException();\n    \
  \    }\n        int i = 2;\n        int max = 1;\n        while (i <= n) {\n   \
  \         if (n % i == 0) {\n                max = i;\n                n /= i;\n\
  \            } else {\n                i++;\n            }\n        }\n        return\
  \ max;"
- "        int largestPrimeFactor = 1;\n        for (int i = 2; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                n /= i;\n                largestPrimeFactor\
  \ = i;\n            }\n        }\n        return largestPrimeFactor;"
- "        int largest_factor = 1;\n        int d = 2;\n        while (n > 1) {\n\
  \            while (n % d == 0) {\n                largest_factor = d;\n       \
  \         n /= d;\n            }\n            d += 1;\n        }\n        return\
  \ largest_factor;"
- '        throw new UnsupportedOperationException("I don''t know how to do this one
  either");'
- "        // YOUR CODE HERE\n        return -1;"
- "        int largestPrimeFactor = 0;\n        for (int i = 2; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                n /= i;\n                largestPrimeFactor\
  \ = i;\n            }\n        }\n        return largestPrimeFactor;"
- '        return (int) largestPrimeFactor(n, 2);'
- "        int factor = 2;\n        while (factor < n) {\n            if (n % factor\
  \ == 0) {\n                n /= factor;\n            } else {\n                factor++;\n\
  \            }\n        }\n        return factor;"
- "        int largestFactor = 0;\n        for (int i = 1; i <= n; i++) {\n      \
  \      if (n % i == 0) {\n                if (isPrime(i)) {\n                  \
  \  largestFactor = i;\n                }\n            }\n        }\n        return\
  \ largestFactor;"
- "        int max = 1;\n        while (n % 2 == 0) {\n            max = 2;\n    \
  \        n = n / 2;\n        }\n        int i = 3;\n        while (i <= Math.sqrt(n))\
  \ {\n            while (n % i == 0) {\n                max = i;\n              \
  \  n = n / i;\n            }\n            i = i + 2;\n        }\n        if (n >\
  \ 2) {\n            max = n;\n        }\n        return max;"
- "        if (n <= 2)\n            return n;\n        // If a number is a prime,\
  \ then the largest prime factor is 1, so\n        // it can be ignored\n       \
  \ int largestPrimeFactor = 1;\n        while (n % 2 == 0) {\n            largestPrimeFactor\
  \ = 2;\n            n /= 2;\n        }\n        // For each odd number starting\
  \ at 3 and going to the square root of\n        // n, if it is a factor, then divide\
  \ n by it as many times as it can\n        // be, keeping track of the largest factor\
  \ found.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while\
  \ (n % i == 0) {\n                largestPrimeFactor = i;\n                n /=\
  \ i;\n            }\n        }\n        // If n is not one, then it is the largest\
  \ prime factor\n        if (n > 2)\n            largestPrimeFactor = n;\n      \
  \  return largestPrimeFactor;"
- "        int p = 2;\n        while (n % p != 0) {\n            p++;\n        }\n\
  \        int q = n / p;\n        if (q > 1) {\n            return largestPrimeFactor(q);\n\
  \        } else {\n            return p;\n        }"
- "        int best = 0;\n        for (int i = 2; i <= n / i; i++) {\n           \
  \ while (n % i == 0) {\n                best = i;\n                n /= i;\n   \
  \         }\n        }\n        if (n > 1) best = n;\n        return best;"
- "        if (n <= 1) {\n            throw new IllegalArgumentException(\"Assume\
  \ n > 1 and is not a prime.\");\n        }\n        int ans = 1;\n        for (int\
  \ i = 2; i < n; i++) {\n            if (n % i == 0) {\n                ans = Math.max(ans,\
  \ largestPrimeFactor(n / i));\n            }\n        }\n        return ans;"
- "        for (int i = 2; i <= n; i++) {\n            if (n % i == 0) {\n       \
  \         return largestPrimeFactor(n / i);\n            }\n        }\n        return\
  \ n;"
- "        int ans = 1;\n        int i = 2;\n        while (i*i <= n) {\n        \
  \    if (n % i == 0) {\n                ans = i;\n                while (n % i ==\
  \ 0) {\n                    n /= i;\n                }\n            }\n        \
  \    i++;\n        }\n        if (n > 1) ans = n;\n        return ans;"
- "        int largest = 1;\n        for (int i = 2; i < n / 2; i++) {\n         \
  \   if (isPrime(i) && (n % i == 0)) {\n                largest = i;\n          \
  \  }\n        }\n        return largest;"
- "        int largestPrimeFactor = 1;\n        int p = 2;\n        while (p <= n)\
  \ {\n            if (n % p == 0) {\n                largestPrimeFactor = p;\n  \
  \              n /= p;\n            } else {\n                p += 1;\n        \
  \    }\n        }\n        return largestPrimeFactor;"
- "        // Your code here.\n        return 0;"
- "        int largest = 0;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n \
  \           if (n % i == 0) {\n                int f = n / i;\n                if\
  \ (isPrime(f)) {\n                    largest = f;\n                    break;\n\
  \                }\n            }\n        }\n        return largest;"
- "        int result = 0;\n        while (n % 2 == 0) {\n            result = 2;\n\
  \            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i +=\
  \ 2) {\n            while (n % i == 0) {\n                result = i;\n        \
  \        n /= i;\n            }\n        }\n        if (n > 2)\n            result\
  \ = n;\n        return result;"
- "        // Your code here.\n        int largest_prime_factor = 2;\n        while\
  \ (n % 2 == 0) {\n            n /= 2;\n        }\n        int factor = 3;\n    \
  \    while (n > 1) {\n            while (n % factor == 0) {\n                largest_prime_factor\
  \ = factor;\n                n /= factor;\n            }\n            factor +=\
  \ 2;\n        }\n        return largest_prime_factor;"
- "        List<Integer> primes = new ArrayList<>();\n        while (n != 1) {\n \
  \           // Find the next smallest prime factor\n            int p = smallestPrimeFactor(n);\n\
  \            // Use this to divide out and reduce the problem size\n           \
  \ n /= p;\n            // Keep track of the smallest prime factor as it is the answer\n\
  \            primes.add(p);\n        }\n        return primes.get(primes.size()\
  \ - 1);"
- "        // ...\n        return 0;"
- "        int factors = 0;\n        int sqr = (int) Math.sqrt(n);\n        for (int\
  \ i = 2; i <= sqr; i++) {\n            while (n % i == 0) {\n                n /=\
  \ i;\n                sqr = (int) Math.sqrt(n);\n                factors = i;\n\
  \            }\n        }\n        if (n > 1) {\n            factors = n;\n    \
  \    }\n        return factors;"
- "        // YOUR CODE HERE\n        //throw new UnsupportedOperationException(\"\
  largestPrimeFactor\");\n\t\tif(n == 1) return 1;\n\t\tif(n % 2 == 0) { \n\t\t\t\
  return largestPrimeFactor(n/2);\n\t\t} else {\n\t\t\tfor(int i = 3; i <= n/2; i+=2)\
  \ {\n\t\t\t\tif(n % i == 0) {\n\t\t\t\t\treturn largestPrimeFactor(n/i);\n\t\t\t\
  \t}\n\t\t\t}\n\t\t}\n\t\treturn n;"
- '        return 1;'
- "        // Get a list of all primes up to n.\n        ArrayList<Integer> primes\
  \ = listOfPrimes(n);\n        // We should have the prime factors of n in this list.\n\
  \        for (int i = primes.size() - 1; i >= 0; i--) {\n            if (n % primes.get(i)\
  \ == 0) {\n                return primes.get(i);\n            }\n        }\n   \
  \     return -1;"
- "        int limit = (int) Math.sqrt(n);\n        for (int i = 2; i <= limit; i++)\
  \ {\n            if (n % i == 0) {\n                return Math.max(largestPrimeFactor(n\
  \ / i), largestPrimeFactor(i));\n            }\n        }\n        return n;"
- "        // TODO: Add your code here\n        return 0;"
- "        int f = 1;\n        while (n % 2 == 0) {\n            f = 2;\n        \
  \    n /= 2;\n        }\n        if (n == 1) return f;\n        // n is odd\n  \
  \      int r = (int) Math.sqrt(n);\n        for (int i = 3; i <= r; i += 2) {\n\
  \            if (n % i == 0) {\n                f = i;\n                n /= i;\n\
  \                r = (int) Math.sqrt(n);\n            }\n        }\n        return\
  \ f;"
- "        for (int i = 2; i <= n / i; i++) {\n            while (n % i == 0) {\n\
  \                n /= i;\n            }\n        }\n        return n;"
- "        int max = -1;\n        for (int i = 2; i * i <= n; i++) {\n           \
  \ if (n % i == 0) {\n                if (max < i) {\n                    max = i;\n\
  \                }\n                n /= i;\n                i--;\n            }\n\
  \        }\n        if (n > 1) {\n            max = n;\n        }\n        return\
  \ max;"
- "\tint largestPrimeFactor = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t    while (n\
  \ % i == 0) {\n\t\tn /= i;\n\t\tlargestPrimeFactor = i;\n\t    }\n\t}\n\treturn\
  \ largestPrimeFactor;"
- "        int factor = 2;\n        while (factor <= n) {\n            if (n % factor\
  \ == 0) {\n                n /= factor;\n            } else {\n                factor++;\n\
  \            }\n        }\n        return factor;"
- "        // >>> largest_prime_factor(13195)\n        // 29\n        // >>> largest_prime_factor(2048)\n\
  \        // 2\n        if (n < 2) {\n            return n;\n        }\n        int\
  \ d = 2;\n        while (n > 1) {\n            while (n % d == 0) {\n          \
  \      n /= d;\n            }\n            d += 1;\n        }\n        return d\
  \ - 1;"
- "        int largestPrimeFactor = 1;\n        for (int i = 2; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                if (isPrime(i)) {\n             \
  \       largestPrimeFactor = i;\n                }\n            }\n        }\n \
  \       return largestPrimeFactor;"
- "        int currentDivisor = 2;\n        int largestPrimeFactor = -1;\n       \
  \ while (n > 1) {\n            if (n % currentDivisor == 0) {\n                largestPrimeFactor\
  \ = currentDivisor;\n                n /= currentDivisor;\n                while\
  \ (n % currentDivisor == 0) {\n                    n /= currentDivisor;\n      \
  \          }\n            }\n            currentDivisor++;\n        }\n        return\
  \ largestPrimeFactor;"
- '        return 0;'
- "        for (int i = 2; i <= n; i++) {\n            if (n % i == 0) {\n       \
  \         if (i == n) {\n                    return i;\n                } else {\n\
  \                    n /= i;\n                    i--;\n                }\n    \
  \        }\n        }\n        return n;"
- "        /* The algorithm is based on the fact that every non-prime is divisible\
  \ by a prime (excluding 1).\n        First, generate a list of primes. Then, repeatedly\
  \ divide n by the first prime that is a factor.\n        The last prime that divides\
  \ n is the largest prime factor. */\n        List<Integer> primes = generatePrimes(Math.min(10_000,\
  \ n)); // generate primes up to 10,000 or n, whichever is smaller\n        for (int\
  \ i = 0; i < primes.size(); i++) {\n            int p = primes.get(i);\n       \
  \     if (n % p == 0) {\n                n /= p;\n                i--;\n       \
  \     }\n        }\n        return n;"
- "        int maxFactor = 1;\n        for (int i = 2; i <= n; i++) {\n          \
  \  if (n % i == 0) {\n                boolean isPrime = true;\n                for\
  \ (int j = 2; j <= i; j++) {\n                    if (i % j == 0 && j != i) {\n\
  \                        isPrime = false;\n                        break;\n    \
  \                }\n                }\n                if (isPrime) {\n        \
  \            maxFactor = i;\n                }\n            }\n        }\n     \
  \   return maxFactor;"
- "        ArrayList<Integer> factors = new ArrayList<Integer>();\n        for (int\
  \ i = 2; i < n; i++) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \            }\n        }\n        for (int i = factors.size() - 1; i >= 0; i--)\
  \ {\n            int isPrime = 1;\n            for (int j = 2; j < factors.get(i);\
  \ j++) {\n                if (factors.get(i) % j == 0) {\n                    isPrime\
  \ = 0;\n                    break;\n                }\n            }\n         \
  \   if (isPrime == 1) {\n                return factors.get(i);\n            }\n\
  \        }\n        return -1;"
- "        int largestPrimeFactor = 0;\n        int i = 2;\n        while (i <= n)\
  \ {\n            if (n % i == 0) {\n                n /= i;\n                largestPrimeFactor\
  \ = i;\n            } else {\n                i++;\n            }\n        }\n \
  \       return largestPrimeFactor;"
- '        throw new UnsupportedOperationException("TODO: implement");'
- "        int i = 2;\n        while (i <= n) {\n            if (n % i == 0) {\n \
  \               n /= i;\n            } else {\n                i++;\n          \
  \  }\n        }\n        return i;"
- "        // Fill in your answer here.\n        int m = 1;\n        for (int i =\
  \ 2; i * i <= n; i++) {\n            while (n % i == 0) {\n                m = i;\n\
  \                n /= i;\n            }\n        }\n        return n == 1 ? m :\
  \ n;"
- "        // find smallest factor with n % f == 0\n        int f = 2;\n        while\
  \ (n % f != 0) {\n            f++;\n        }\n        // remove factor from n until\
  \ n is fully decomposed into prime factors\n        while (n % f == 0) {\n     \
  \       n /= f;\n        }\n        // when n is fully decomposed, f is the largest\
  \ prime factor of n\n        return f;"
- "        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n\
  \                n /= i;\n            } else {\n                i++;\n         \
  \   }\n        }\n        return n;"
- "        // divide by 2 until n odd\n        while (n % 2 == 0) {\n            n\
  \ /= 2;\n        }\n        // test odd numbers up to sqrt(n)\n        int maxPrime\
  \ = 1;\n        for (int d = 3; d * d <= n; d += 2) {\n            while (n % d\
  \ == 0) {\n                maxPrime = d;\n                n /= d;\n            }\n\
  \        }\n        // if n > 2 it is a prime factor\n        if (n > 2) {\n   \
  \         maxPrime = n;\n        }\n        return maxPrime;"
- "        int res = 1;\n        while (n % 2 == 0) {\n            res = 2;\n    \
  \        n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\
  \ {\n            while (n % i == 0) {\n                res = i;\n              \
  \  n /= i;\n            }\n        }\n        if (n > 2) res = n;\n        return\
  \ res;"
- "        int divisor = 2;\n        int remaining = n;\n        int largestFactor\
  \ = 0;\n        while (remaining > 1) {\n            // System.out.printf(\"Divisor:\
  \ %d, Remaining: %d\\n\", divisor, remaining);\n            if (remaining % divisor\
  \ == 0) {\n                largestFactor = divisor;\n                remaining /=\
  \ divisor;\n            } else {\n                divisor++;\n            }\n  \
  \      }\n        return largestFactor;"
- '        throw new RuntimeException("Method not implemented");'
- '        return new Problem().largestPrimeFactorHelper(n);'
- "        if (n < 2) return 0;\n        int maxPrime = 2;\n        // Divide out\
  \ all 2's:\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n     \
  \   // Try dividing out all other primes:\n        for (int i = 3; i <= n; i +=\
  \ 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n      \
  \          n /= i;\n            }\n        }\n        return maxPrime;"
- "        for (int i = 2; i <= n; i++) {\n            if (n % i == 0) {\n       \
  \         n /= i;\n                i--;\n            }\n        }\n        return\
  \ n;"
- "        int max = 1;\n        for (int i = 2; i * i <= n; i++) {\n            if\
  \ (n % i == 0) {\n                max = i;\n                while (n % i == 0) n\
  \ /= i;\n            }\n        }\n        if (n > 1) max = n;\n        return max;"
- "        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n        \
  \        return largestPrimeFactor(n / i);\n            }\n        }\n        return\
  \ n;"
- "        int largest = 0;\n        for (int i = 2; i <= n; i++) {\n            if\
  \ (n % i == 0) {\n                if (isPrime(i)) {\n                    largest\
  \ = i;\n                }\n            }\n        }\n        return largest;"
- "        // Your code here.\n        int val = n;\n        for (int i = 2; i < n;\
  \ i++) {\n            if (val % i == 0) {\n                val = val / i;\n    \
  \            i--;\n            }\n        }\n        return val;"
- '        return 0;'
- "        int prime = -1;\n        for (int i = 2; i <= n; i++) {\n            if\
  \ (n % i == 0) {\n                prime = i;\n                n /= i;\n        \
  \        i--;\n            }\n        }\n        return prime;"
- '        return 0;'
- "        int largest = 0;\n        int i = 2;\n        while (i <= n) {\n      \
  \      if (n % i == 0) {\n                if (isPrime(i))\n                    largest\
  \ = i;\n                n /= i;\n            } else {\n                i++;\n  \
  \          }\n        }\n        return largest;"
- "        int ans = -1;\n        for (int i = 2; i * i <= n; i++) {\n           \
  \ if (n % i == 0) {\n                ans = Math.max(ans, largestPrimeFactor(n /\
  \ i));\n            }\n        }\n        return ans == -1 ? n : ans;"
- "        int factor = 2;\n        while (n > 1) {\n            while (n % factor\
  \ == 0) {\n                n /= factor;\n            }\n            factor++;\n\
  \        }\n        return factor-1;"
- "        int max = 1;\n        for (int i = 2; i <= n; i++) {\n            while\
  \ (n % i == 0) {\n                max = i;\n                n /= i;\n          \
  \  }\n        }\n        return max;"
- "        // Use a prime generator to get the prime factors.\n        PrimeGenerator\
  \ primeGenerator = new PrimeGenerator();\n        ArrayList<Integer> primeFactors\
  \ = new ArrayList<Integer>();\n        while (n > 1) {\n            int prime =\
  \ primeGenerator.next();\n            if (n % prime == 0) {\n                primeFactors.add(prime);\n\
  \                n /= prime;\n            }\n        }\n        return primeFactors.get(primeFactors.size()\
  \ - 1);"
- "        assert n > 1;\n        int x = 2;\n        while (x * x <= n) {\n     \
  \       if (n % x == 0) {\n                n /= x;\n            } else {\n     \
  \           x++;\n            }\n        }\n        return n;"
- "        int[] factors = findPrimeFactors(n);\n        return factors[factors.length\
  \ - 1];"
- "        int largest_prime_factor = 2;\n        for (int i = 3; i <= n / i; i +=\
  \ 2) {\n            if (n % i == 0) {\n                largest_prime_factor = i;\n\
  \                while (n % i == 0) {\n                    n /= i;\n           \
  \     }\n            }\n        }\n        if (n > largest_prime_factor) {\n   \
  \         largest_prime_factor = n;\n        }\n        return largest_prime_factor;"
- '        return -1;'
- "        int prime = -1;\n        for (int i = 2; i <= n; i++) {\n            if\
  \ (n % i == 0) {\n                if (isPrime(i)) prime = i;\n            }\n  \
  \      }\n        return prime;"
- "        // Assuming n > 1 and is not a prime.\n        if (n <= 1) throw new IllegalArgumentException();\n\
  \        if (isPrime(n)) throw new IllegalArgumentException();\n        int max_factor\
  \ = 0;\n        for (int i = 2; i <= n / 2; i++) {\n            if (n % i == 0 &&\
  \ isPrime(i)) max_factor = i;\n        }\n        return max_factor;"
- "        int largest = 1;\n        for (int i = 2; i * i <= n; i++) {\n        \
  \    if (n % i == 0) {\n                boolean isPrime = true;\n              \
  \  for (int j = 2; j * j <= i; j++) {\n                    if (i % j == 0) {\n \
  \                       isPrime = false;\n                        break;\n     \
  \               }\n                }\n                if (isPrime) {\n         \
  \           largest = i;\n                }\n            }\n        }\n        return\
  \ largest;"
- "\t\tfor (int i = (int)Math.sqrt(n); i > 0; i--) {\n\t\t\tif (n % i == 0 && isPrime(i))\
  \ {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;"
- "        int i = 2;\n        while (i <= n) {\n            if (n % i == 0) {\n \
  \               n /= i;\n            } else {\n                i++;\n          \
  \  }\n        }\n        return i;"
- '        return -1;'
- '        return 1;'
- '        return 0;'
- '        return n;'
- '        return 0;'
- "        int result = 1;\n        int factor = 2;\n        while (n > 1) {\n   \
  \         while (n % factor == 0) {\n                result = factor;\n        \
  \        n /= factor;\n            }\n            factor++;\n        }\n       \
  \ return result;"
- "        int f = 2;\n        while (n % f != 0) {\n            f += 1;\n       \
  \ }\n        return f;"
- "        int factor = 2;\n        int lastFactor = 1;\n        while (n > 1) {\n\
  \            if (n % factor == 0) {\n                lastFactor = factor;\n    \
  \            n = n / factor;\n                while (n % factor == 0) {\n      \
  \              n = n / factor;\n                }\n            }\n            factor++;\n\
  \        }\n        return lastFactor;"
- "        int factor = 2;\n        while (n > 1) {\n            while (n % factor\
  \ == 0) {\n                n /= factor;\n            }\n            factor++;\n\
  \        }\n        return factor - 1;"
- "        for (int i = n / 2; i > 1; i--) {\n            if (n % i == 0 && isPrime(i))\
  \ {\n                return i;\n            }\n        }\n        return -1;"
- "        /*\n        // This is the solution from Wikipedia.\n        int num =\
  \ n;\n        int factor = 2;\n        while (factor <= num) {\n            if (num\
  \ % factor == 0) {\n                num /= factor;\n                factor = 2;\n\
  \            } else {\n                factor++;\n            }\n        }\n   \
  \     return factor;\n        */\n        // We can use Fermat's factorization.\n\
  \        BigInteger a = BigInteger.valueOf(2);\n        BigInteger n_BigInteger\
  \ = BigInteger.valueOf(n);\n        BigInteger x = BigInteger.valueOf(1);\n    \
  \    BigInteger y = BigInteger.valueOf(1);\n        while (x.compareTo(y) == 0)\
  \ {\n            a = a.add(BigInteger.ONE);\n            x = a.pow(2).subtract(n_BigInteger);\n\
  \            y = x.sqrt();\n        }\n        return a.subtract(y).intValue();"
- "        int res = 0;\n        int max = (int)Math.sqrt(n);\n        boolean[] flag\
  \ = new boolean[max + 1];\n        Arrays.fill(flag, true);\n        flag[0] = false;\n\
  \        flag[1] = false;\n        for (int i = 2; i < max; i++) {\n           \
  \ if (flag[i]) {\n                for (int j = i * i; j <= max; j += i) {\n    \
  \                flag[j] = false;\n                }\n            }\n        }\n\
  \        for (int i = max; i >= 2; i--) {\n            if (flag[i] && n % i == 0)\
  \ {\n                res = i;\n                break;\n            }\n        }\n\
  \        return res;"
- "        int factor = 1;\n        int largestFactor = 1;\n        for (int i = 2;\
  \ i <= n; i++) {\n            if (factor != 1) {\n                i = factor;\n\
  \                factor = 1;\n            }\n            if (n % i == 0) {\n   \
  \             factor = i;\n                largestFactor = i;\n            }\n \
  \       }\n        return largestFactor;"
- "        int largestPrimeFactor = 1;\n        int current = 2;\n        while (n\
  \ > 1) {\n            if (n % current == 0) {\n                n /= current;\n \
  \               largestPrimeFactor = current;\n            } else {\n          \
  \      current++;\n            }\n        }\n        return largestPrimeFactor;"
- "        // TODO: Fill this in.\n        return n;"
- "        int r = 1;\n        int f = 2;\n        while (f <= n) {\n            if\
  \ (n % f == 0) {\n                r = f;\n                n /= f;\n            }\
  \ else {\n                f++;\n            }\n        }\n        return r;"
- "        int factor = 2;\n        while (n > 1) {\n            while (n % factor\
  \ == 0) {\n                n /= factor;\n            }\n            factor++;\n\
  \        }\n        return factor-1;"
- "        int ans = 0;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n     \
  \       while (n % i == 0) {\n                ans = i;\n                n /= i;\n\
  \            }\n        }\n        if (n > 1) ans = n;\n        return ans;"
- "        if (n % 2 == 0) return largestPrimeFactor(n / 2);\n        for (int d =\
  \ 3; d <= n; d += 2) {\n            if (n % d == 0) return largestPrimeFactor(n\
  \ / d);\n        }\n        return n;"
- '        return 0;'
- "        int i = 2;\n        int res = 0;\n        while (i <= n) {\n          \
  \  if (n % i == 0) {\n                n /= i;\n                res = i;\n      \
  \      } else {\n                i++;\n            }\n        }\n        return\
  \ res;"
- "        int max = 0;\n        for (int i = 2; i < n; i++) {\n            if (n\
  \ % i == 0) {\n                if (isPrime(i)) {\n                    max = i;\n\
  \                }\n            }\n        }\n        return max;"
- '        return largestPrimeFactorHelper(n, 2);'
- "        int factor = 0;\n        // Start divisor with 2, continue to divide n\
  \ by odd numbers until\n        // n can no longer be divided by 2.\n        for\
  \ (int divisor = 2; n > 1; divisor += 1) {\n            if (divisor > 2) {\n   \
  \             divisor += 1;\n            }\n            while (n % divisor == 0)\
  \ {\n                n /= divisor;\n                factor = divisor;\n        \
  \    }\n        }\n        return factor;"
- '        return 0;'
- "        // YOUR CODE HERE\n        return 0;"
- "        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n        \
  \        int div = n / i;\n                if (isPrime(div)) {\n               \
  \     return div;\n                }\n            }\n        }\n        return n;"
- '        return 0;'
- '        return 0;'
- "        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n\
  \                n /= i;\n            } else {\n                i++;\n         \
  \   }\n        }\n        return n;"
- "        int result = 0;\n        int r = (int) Math.sqrt(n);\n        boolean isPrime;\n\
  \        while (r > 0) {\n            isPrime = true;\n            for (int i =\
  \ 2; i <= r; i++) {\n                if (r % i == 0) {\n                    isPrime\
  \ = false;\n                    break;\n                }\n            }\n     \
  \       if (isPrime && n % r == 0) {\n                result = r;\n            \
  \    break;\n            }\n            r--;\n        }\n        return result;"
- "        int largest = 0;\n        while (n % 2 == 0) {\n            largest = 2;\n\
  \            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i +=\
  \ 2) {\n            while (n % i == 0) {\n                largest = i;\n       \
  \         n /= i;\n            }\n        }\n        if (n > 2) {\n            largest\
  \ = n;\n        }\n        return largest;"
- "        // Hint: Modular Arithmetic\n        // Hint: Fermat's little theorem\n\
  \        // Hint: https://en.wikipedia.org/wiki/Fermat's_little_theorem\n      \
  \  return 0;"
- "        for (int factor = n - 1; factor > 1; factor--) {\n            if (n % factor\
  \ == 0 && Utils.isPrime(factor)) {\n                return factor;\n           \
  \ }\n        }\n        return -1;"
- '        return -1;'
- '        throw new UnsupportedOperationException("Delete this line and implement
  this function.");'
- "        int largest_prime_factor = 0;\n        int current_prime = 2;\n       \
  \ while (n > 1) {\n            while (n % current_prime == 0) {\n              \
  \  largest_prime_factor = current_prime;\n                n /= current_prime;\n\
  \            }\n            current_prime += 1;\n        }\n        return largest_prime_factor;"
- "        int largest = 0;\n        // YOUR CODE HERE\n        return largest;"
- "        int i;\n        for (i = 2; i <= n; i++) {\n            if (n % i == 0)\
  \ {\n                n /= i;\n                i--;\n            }\n        }\n \
  \       return i;"
- '        return 0;'
- "        int lastFactor = 1;\n        while (n % 2 == 0) {\n            lastFactor\
  \ = 2;\n            n /= 2;\n        }\n        int factor = 3;\n        while (n\
  \ != 1) {\n            while (n % factor == 0) {\n                lastFactor = factor;\n\
  \                n /= factor;\n            }\n            factor += 2;\n       \
  \ }\n        return lastFactor;"
- "        int i = 2;\n        while (i < n) {\n            if (n % i == 0) {\n  \
  \              n /= i;\n            } else {\n                i++;\n           \
  \ }\n        }\n        return n;"
- "        // edge cases\n        if (n <= 1) return -1;\n        if (isPrime(n))\
  \ return n;\n        // prime factorization\n        // brute force\n        int\
  \ max = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            if (n % i ==\
  \ 0 && isPrime(i)) {\n                max = i;\n            }\n        }\n     \
  \   return max;"
- "        List<Integer> primes = new ArrayList<>();\n        int num = n;\n     \
  \   while (num % 2 == 0) {\n            primes.add(2);\n            num /= 2;\n\
  \        }\n        int limit = (int) Math.sqrt(num);\n        for (int i = 3; i\
  \ <= limit; i += 2) {\n            while (num % i == 0) {\n                primes.add(i);\n\
  \                num /= i;\n            }\n        }\n        if (num > 2) {\n \
  \           primes.add(num);\n        }\n        return primes.get(primes.size()\
  \ - 1);"
- "        ArrayList<Integer> primes = new ArrayList<Integer>();\n        int product\
  \ = 1;\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n \
  \               primes.add(i);\n                product *= i;\n            }\n \
  \           if (product == n) {\n                return primes.get(primes.size()\
  \ - 1);\n            }\n        }\n        return -1;"
- "        for (int divisor = 2; divisor <= n / 2; divisor++) {\n            if (n\
  \ % divisor == 0 && isPrime(divisor)) {\n                return divisor;\n     \
  \       }\n        }\n        return -1;"
- "        int result = 0;\n        for (int i = 2; i <= n; i++) {\n            if\
  \ (n % i == 0) {\n                n /= i;\n                result = i;\n       \
  \     }\n        }\n        return result;"
- "        int factor = 2;\n        while (n > 1) {\n            if (n % factor ==\
  \ 0) {\n                n /= factor;\n            } else {\n                factor++;\n\
  \            }\n        }\n        return factor;"
- "        int result = 0;\n        if (n % 2 == 0) {\n            result = 2;\n \
  \           n /= 2;\n            while (n % 2 == 0) {\n                n /= 2;\n\
  \            }\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n\
  \            if (n % i == 0) {\n                result = i;\n                n /=\
  \ i;\n                while (n % i == 0) {\n                    n /= i;\n      \
  \          }\n            }\n        }\n        if (n > 2) {\n            result\
  \ = n;\n        }\n        return result;"
- "        for (int d = 2; d * d <= n; d++) {\n            if (n % d == 0) {\n   \
  \             return largestPrimeFactor(n / d);\n            }\n        }\n    \
  \    return n;"
- "        int factor = 0;\n        int max = 0;\n        for (int i = 2; i <= n;\
  \ i++) {\n            if (n % i == 0) {\n                factor = i;\n         \
  \       while (n % i == 0) {\n                    n /= i;\n                }\n \
  \               max = Math.max(max, factor);\n            }\n        }\n       \
  \ return max;"
- '        return 0;'
- "        if (n <= 1) {\n            throw new IllegalArgumentException(\"n must\
  \ be greater than 1\");\n        }\n        if (isPrime(n)) {\n            throw\
  \ new IllegalArgumentException(\"n must not be prime\");\n        }\n        //\
  \ The final factor will be the largest prime factor.\n        int factor = 1;\n\
  \        // Divide by 2 until n is odd.\n        while (n % 2 == 0) {\n        \
  \    n /= 2;\n        }\n        // One at a time, check if there is a factor of\
  \ n that is also a prime number.\n        // The last factor will be the largest\
  \ prime factor.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n        \
  \    while (n % i == 0) {\n                factor = i;\n                n /= i;\n\
  \            }\n        }\n        // If the final prime factor is less than the\
  \ square root of n, then the final\n        // factor will be the number itself.\n\
  \        if (n > 2) {\n            factor = n;\n        }\n        return factor;"
- "        int m = 2;\n        while (n > 1) {\n            while (n % m == 0) {\n\
  \                n /= m;\n            }\n            m++;\n        }\n        return\
  \ m-1;"
- "        int i;\n        for (i = 2; i * i <= n; i++) {\n            while (n %\
  \ i == 0) {\n                n /= i;\n            }\n        }\n        return n;"
- "        // Note: 2 is the only even prime, so all other primes are odd.\n     \
  \   // If a number is divisible by 2, all its prime factors are also even.\n   \
  \     // Remove factors of 2 from n, so all remaining prime factors are odd.\n \
  \       while (n % 2 == 0) {\n            n /= 2;\n        }\n        // Now n is\
  \ odd, so skip all even numbers when looping to check if they\n        // are factors\
  \ of n.\n        int factor = 3;\n        while (n > 1) {\n            while (n\
  \ % factor == 0) {\n                n /= factor;\n            }\n            factor\
  \ += 2;\n        }\n        return factor - 2;"
- "        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n\
  \                n /= i;\n            } else {\n                i++;\n         \
  \   }\n        }\n        return n;"
- "        if (n <= 3) {\n            return n;\n        }\n        int largestPrimeFactor\
  \ = 2;\n        int limit = (int) Math.sqrt(n);\n        for (int i = 3; i <= limit;\
  \ i += 2) {\n            while (n % i == 0) {\n                largestPrimeFactor\
  \ = i;\n                n /= i;\n            }\n        }\n        return largestPrimeFactor;"
language: java
name: HumanEval_59_largest_prime_factor
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return the largest prime factor of n. Assume n > 1 and is\
  \ not a prime.\n    // >>> largest_prime_factor(13195)\n    // 29\n    // >>> largest_prime_factor(2048)\n\
  \    // 2\n    public static int largestPrimeFactor(int n) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(largestPrimeFactor((15))\
  \ == (5));\n    assert(largestPrimeFactor((27)) == (3));\n    assert(largestPrimeFactor((63))\
  \ == (7));\n    assert(largestPrimeFactor((330)) == (11));\n    assert(largestPrimeFactor((13195))\
  \ == (29));\n    }\n\n}\n"
