completions:
- "        PriorityQueue<Integer> heap = new PriorityQueue<>();\n        for (int\
  \ i = 0; i < arr.size(); i++) {\n            heap.add(arr.get(i));\n           \
  \ if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n\
  \        ArrayList<Integer> ans = new ArrayList<>();\n        while (heap.size()\
  \ > 0) {\n            ans.add(heap.poll());\n        }\n        return ans;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        // get the\
  \ first k elements\n        for (int i = 0; i < k; i++) {\n            result.add(arr.get(i));\n\
  \        }\n        // sort them\n        result.sort(Comparator.naturalOrder());\n\
  \        // iterate over the remaining elements in the array\n        for (int i\
  \ = k; i < arr.size(); i++) {\n            // if we find a larger element\n    \
  \        if (arr.get(i) > result.get(0)) {\n                // remove the smallest\
  \ element in result\n                result.remove(0);\n                // add the\
  \ new element\n                result.add(arr.get(i));\n                // sort\
  \ result\n                result.sort(Comparator.naturalOrder());\n            }\n\
  \        }\n        return result;"
- "        // Assuming k is less than or equal to the length of arr\n        if (k\
  \ == arr.size()) {\n            return arr;\n        }\n        // Time Complexity:\
  \ O(N * log(k))\n        // Space Complexity: O(k)\n        // Var maxHeap:\n  \
  \      // maxHeap is a max heap that contains the maximum k elements of arr.\n \
  \       // Var solution:\n        // solution is the list of maximum k elements\
  \ of arr.\n        // Begin\n        // 1. Create a max heap maxHeap.\n        PriorityQueue<Integer>\
  \ maxHeap = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n       \
  \ // 2. For element in arr:\n        for (int element : arr) {\n            // 2.1.\
  \ If maxHeap size is less than k:\n            if (maxHeap.size() < k) {\n     \
  \           // 2.1.1. Add element to maxHeap.\n                maxHeap.add(element);\n\
  \            }\n            // 2.2. If maxHeap size is greater than or equal to\
  \ k and element is greater than the top element in maxHeap:\n            else if\
  \ (maxHeap.size() >= k && element > maxHeap.peek()) {\n                // 2.2.1.\
  \ Remove the top element in maxHeap.\n                maxHeap.poll();\n        \
  \        // 2.2.2. Add element to maxHeap.\n                maxHeap.add(element);\n\
  \            }\n        }\n        // 3. Create a list solution.\n        ArrayList<Integer>\
  \ solution = new ArrayList<Integer>();\n        // 4. For element in maxHeap:\n\
  \        for (int element : maxHeap) {\n            // 4.1. Add element to solution.\n\
  \            solution.add(element);\n        }\n        // 5. Return solution.\n\
  \        return solution;\n        // End"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return res;\n        }\n        int max = arr.get(0);\n \
  \       for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) > max)\
  \ {\n                max = arr.get(i);\n            }\n        }\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k);\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            pq.add(arr.get(i));\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            res.add(pq.poll());\n        }\n        return res;"
- "        PriorityQueue<Integer> minQueue = new PriorityQueue<Integer>();\n     \
  \   for (int i = 0; i < arr.size(); i++) {\n            int num = arr.get(i);\n\
  \            if (minQueue.size() < k) {\n                minQueue.add(num);\n  \
  \          } else {\n                if (num > minQueue.peek()) {\n            \
  \        minQueue.remove();\n                    minQueue.add(num);\n          \
  \      }\n            }\n        }\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n\
  \        for (int i = 0; i < k; i++) {\n            ret.add(minQueue.remove());\n\
  \        }\n        return ret;"
- "        // sort the list: O(n log n)\n        Collections.sort(arr);\n        //\
  \ keep the k largest values: O(k)\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n\
  \        for (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n            ret.add(arr.get(i));\n\
  \        }\n        return ret;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(k, Collections.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (pq.size() == k)\
  \ {\n                if (arr.get(i) > pq.peek()) {\n                    pq.poll();\n\
  \                    pq.add(arr.get(i));\n                }\n            } else\
  \ {\n                pq.add(arr.get(i));\n            }\n        }\n        ArrayList<Integer>\
  \ l = new ArrayList<>();\n        while (pq.size() > 0) {\n            l.add(pq.poll());\n\
  \        }\n        return l;"
- "        // build a max heap\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k,\
  \ Collections.reverseOrder());\n        for (int e : arr) {\n            pq.add(e);\n\
  \        }\n        ArrayList<Integer> list = new ArrayList<Integer>();\n      \
  \  while (k-- > 0) {\n            list.add(pq.poll());\n        }\n        return\
  \ list;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1, new Comparator<Integer>()\
  \ {\n            public int compare(Integer i1, Integer i2) {\n                return\
  \ i2 - i1;\n            }\n        });\n        for (int i = 0; i < arr.size();\
  \ i++) {\n            pq.add(arr.get(i));\n            if (pq.size() > k) {\n  \
  \              pq.poll();\n            }\n        }\n        return new ArrayList<Integer>(pq);"
- "        ArrayList<Integer> answer = new ArrayList<Integer>();\n        return answer;"
- "        // [sorted_arr_len=0, ..., sorted_arr_len=k-1] \n        ArrayList<Integer>\
  \ window = new ArrayList<Integer>(k);\n        for (int i = 0; i < k; i++) {\n \
  \           window.add(arr.get(i));\n        }\n        insertionSort(window);\n\
  \        for (int i = k; i < arr.size(); i++) {\n            if (arr.get(i) > window.get(0))\
  \ {\n                window.set(0, arr.get(i));\n                insertionSort(window);\n\
  \            }\n        }\n        return window;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(arr.size(), Collections.reverseOrder());\n\
  \        for (int x : arr) pq.add(x);\n        ArrayList<Integer> ans = new ArrayList<Integer>();\n\
  \        for (int i = 0; i < k; i++) ans.add(pq.poll());\n        return ans;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        Collections.sort(arr);\n\
  \        int i = arr.size() - 1;\n        while (k > 0) {\n            result.add(arr.get(i));\n\
  \            k--;\n            i--;\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        int[] max\
  \ = new int[k];\n        for (int i = 0; i < k; i++) {\n            max[i] = Integer.MIN_VALUE;\n\
  \        }\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i)\
  \ > max[0]) {\n                // replace\n                for (int j = 0; j < k;\
  \ j++) {\n                    if (arr.get(i) > max[j]) {\n                     \
  \   for (int q = 0; q < j; q++) {\n                            max[q] = max[q +\
  \ 1];\n                        }\n                        max[j] = arr.get(i);\n\
  \                        break;\n                    }\n                }\n    \
  \        }\n        }\n        for (int i = 0; i < k; i++) {\n            result.add(max[i]);\n\
  \        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        if (arr.size()\
  \ <= k) {\n            return arr;\n        }\n        PriorityQueue<Integer> maxHeap\
  \ = new PriorityQueue<>(Collections.reverseOrder());\n        for (int i = 0; i\
  \ < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n        }\n      \
  \  for (int i = 0; i < k; i++) {\n            result.add(maxHeap.poll());\n    \
  \    }\n        return result;"
- "        // TODO: Add your code here.\n        return new ArrayList<Integer>();"
- "        var res = new ArrayList<Integer>();\n        if (k > arr.size()) return\
  \ res;\n        var maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\n\
  \        var i = 0;\n        while (i < k) {\n            maxHeap.add(arr.get(i));\n\
  \            i++;\n        }\n        while (i < arr.size()) {\n            if (arr.get(i)\
  \ > maxHeap.peek()) {\n                maxHeap.poll();\n                maxHeap.add(arr.get(i));\n\
  \            }\n            i++;\n        }\n        while (!maxHeap.isEmpty())\
  \ {\n            res.add(maxHeap.poll());\n        }\n        return res;"
- "        ArrayList<Integer> m = new ArrayList<Integer>();\n        for (int i =\
  \ 0; i < k; i++) {\n            int max = -1001;\n            int maxIndex = -1;\n\
  \            for (int j = 0; j < arr.size(); j++) {\n                if (arr.get(j)\
  \ > max) {\n                    max = arr.get(j);\n                    maxIndex\
  \ = j;\n                }\n            }\n            m.add(max);\n            arr.remove(maxIndex);\n\
  \        }\n        return m;"
- "        // because the elements are in the range of [-1000, 1000], we can just\
  \ sort it\n        // and return the first k elements. No need to use a heap.\n\
  \        Collections.sort(arr);\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        for (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n            result.add(arr.get(i));\n\
  \        }\n        return result;"
- "        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k, (a, b) -> (b\
  \ - a));\n        for (int i = 0; i < arr.size(); i++) {\n            heap.add(arr.get(i));\n\
  \        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n    \
  \    for (int i = 0; i < k; i++) {\n            result.add(heap.poll());\n     \
  \   }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        // put the\
  \ largest element at the end of the result array.\n        while (result.size()\
  \ < k) {\n            int max = arr.get(0);\n            int max_index = 0;\n  \
  \          for (int i = 1; i < arr.size(); i++) {\n                if (arr.get(i)\
  \ > max) {\n                    max = arr.get(i);\n                    max_index\
  \ = i;\n                }\n            }\n            result.add(max);\n       \
  \     arr.remove(max_index);\n        }\n        Collections.sort(result);\n   \
  \     return result;"
- "        ArrayList<Integer> list = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < k; i++) {\n            list.add(arr.get(i));\n        }\n        Collections.sort(list);\n\
  \        for (int i = k; i < arr.size(); i++) {\n            if (arr.get(i) > list.get(0))\
  \ {\n                list.remove(0);\n                list.add(arr.get(i));\n  \
  \              Collections.sort(list);\n            }\n        }\n        return\
  \ list;"
- "        assert (arr.size() >= k);\n        // Hash-based algorithm. Use a priority\
  \ queue to store the top K elements.\n        // Use a hash to store whether an\
  \ element is in the priority queue or not.\n        // O(n log k) time and O(k)\
  \ space.\n        // Since every element is retrieved (and polled) at most once,\n\
  \        // the time complexity is O(n log k).\n        PriorityQueue<Integer> q\
  \ = new PriorityQueue<>(k);\n        HashSet<Integer> set = new HashSet<>();\n \
  \       for (int i = 0; i < arr.size(); i++) {\n            int e = arr.get(i);\n\
  \            if (set.contains(e)) continue;\n            set.add(e);\n         \
  \   if (q.size() < k) {\n                q.add(e);\n            } else {\n     \
  \           if (e > q.peek()) {\n                    q.poll();\n               \
  \     q.add(e);\n                }\n            }\n        }\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        while (!q.isEmpty()) {\n            result.add(q.poll());\n\
  \        }\n        return result;"
- "        int N = arr.size();\n        // Step 1: Extract all possible elements from\
  \ the array\n        ArrayList<Integer> map = new ArrayList<Integer>();\n      \
  \  for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n  \
  \              for (int l = i; l <= j; l++) {\n                    map.add(arr.get(l));\n\
  \                }\n            }\n        }\n        Collections.sort(map);\n \
  \       return new ArrayList<Integer>(map.subList(0, k));"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public\
  \ int compare(Integer x, Integer y) {\n                return y - x;\n         \
  \   }\n        });\n        for (int x : arr) {\n            pq.add(x);\n      \
  \  }\n        while (k > 0) {\n            ans.add(pq.poll());\n            k--;\n\
  \        }\n        return ans;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        //if k >\
  \ arr.size(), then k = arr.size()\n        if (k > arr.size()) {\n            k\
  \ = arr.size();\n        }\n        //make a min heap\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<Integer>();\n        //for each number in the array\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            //add the number to\
  \ the heap\n            heap.add(arr.get(i));\n            //if the heap contains\
  \ more than k values\n            if (heap.size() > k) {\n                //remove\
  \ the lowest value in the heap\n                heap.poll();\n            }\n  \
  \      }\n        //after the loop, the heap will contain the k largest values from\
  \ the array\n        //while the heap contains values\n        while (heap.size()\
  \ > 0) {\n            //add the next largest value to the results\n            result.add(heap.poll());\n\
  \        }\n        //reverse the list\n        Collections.reverse(result);\n \
  \       //return the list\n        return result;"
- "        // Edge cases\n        if (arr == null || arr.size() == 0) return new ArrayList<Integer>();\n\
  \        if (k == 0) return new ArrayList<Integer>();\n        // Using a double\
  \ ended queue\n        ArrayDeque<Integer> deque = new ArrayDeque<Integer>();\n\
  \        for (int i : arr) {\n            // Inserting the first element\n     \
  \       if (deque.size() == 0) {\n                deque.addLast(i);\n          \
  \  } else {\n                // If the number is less than the first element do\
  \ nothing.\n                if (i < deque.getFirst()) {\n                    //\
  \ do nothing\n                } else {\n                    // If the number is\
  \ greater than the first element remove all the \n                    // numbers\
  \ until the number is less than the current element or the\n                   \
  \ // queue is empty.\n                    while (deque.size() > 0 && i > deque.getLast())\
  \ {\n                        deque.removeLast();\n                    }\n      \
  \              // Remove the first element if the size is equal to k.\n        \
  \            if (deque.size() == k) {\n                        deque.removeFirst();\n\
  \                    }\n                    // If the queue is still not empty then\
  \ add the current element to the\n                    // queue.\n              \
  \      if (deque.size() < k) {\n                        deque.addLast(i);\n    \
  \                }\n                }\n            }\n        }\n        // Return\
  \ the queue converted to an array list.\n        return new ArrayList<Integer>(deque);"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(k, Collections.reverseOrder());\n\
  \        for (int num : arr) {\n            pq.add(num);\n            if (pq.size()\
  \ > k) {\n                pq.poll();\n            }\n        }\n        ArrayList<Integer>\
  \ ret = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            ret.add(pq.poll());\n\
  \        }\n        return ret;"
- "        // The idea is to use a k-size heap to store the biggest k elements.\n\
  \        // However, it is not straight-forward to use a max-heap to store the\n\
  \        // smallest k elements.\n        // Thus, we can use a min-heap to store\
  \ the biggest k elements in the\n        // following way:\n        // Pop the min\
  \ element.\n        // Then, push the maximum element of the remaining elements.\n\
  \        Comparator<Integer> comparator = (Integer x, Integer y) -> Integer.compare(x,\
  \ y);\n        PriorityQueue<Integer> queue = new PriorityQueue<>(k, comparator);\n\
  \        int end = arr.size();\n        int start = 0;\n        while (start < end)\
  \ {\n            int max = arr.get(start);\n            for (int i = start + 1;\
  \ i < end; i++) {\n                int current = arr.get(i);\n                if\
  \ (current > max) {\n                    max = current;\n                }\n   \
  \         }\n            if (queue.size() < k) {\n                queue.add(max);\n\
  \            } else {\n                if (queue.peek() < max) {\n             \
  \       queue.poll();\n                    queue.add(max);\n                }\n\
  \            }\n            start++;\n        }\n        ArrayList<Integer> result\
  \ = new ArrayList<>(k);\n        while (!queue.isEmpty()) {\n            result.add(queue.poll());\n\
  \        }\n        return result;"
- "        ArrayList<Integer> max = new ArrayList<>();\n        ArrayList<Integer>\
  \ sorted = new ArrayList<>();\n        HashMap<Integer, Integer> counter = new HashMap<>();\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (max.size() < k)\
  \ {\n                max.add(arr.get(i));\n                if (counter.containsKey(arr.get(i)))\
  \ {\n                    counter.put(arr.get(i), counter.get(arr.get(i)) + 1);\n\
  \                } else {\n                    counter.put(arr.get(i), 1);\n   \
  \             }\n            } else {\n                Integer min = Collections.min(max);\n\
  \                if (arr.get(i) > min) {\n                    max.remove(min);\n\
  \                    max.add(arr.get(i));\n                    counter.put(min,\
  \ counter.get(min) - 1);\n                    if (counter.containsKey(arr.get(i)))\
  \ {\n                        counter.put(arr.get(i), counter.get(arr.get(i)) + 1);\n\
  \                    } else {\n                        counter.put(arr.get(i), 1);\n\
  \                    }\n                }\n            }\n        }\n        for\
  \ (int i = 0; i < max.size(); i++) {\n            int count = counter.get(max.get(i));\n\
  \            for (int j = 0; j < count; j++) {\n                sorted.add(max.get(i));\n\
  \            }\n        }\n        return sorted;"
- "        if (arr.size() == 0) return new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        int n = arr.size();\n        PriorityQueue<Integer>\
  \ maxHeap = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n       \
  \ for (int i=0; i<n; i++) {\n            maxHeap.add(arr.get(i));\n            if\
  \ (maxHeap.size() > k) maxHeap.poll();\n        }\n        for (int i=0; i<k; i++)\
  \ {\n            result.add(maxHeap.poll());\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            int maxVal = -1001;\n            int maxIndex\
  \ = -1;\n            for (int j = 0; j < arr.size(); j++) {\n                if\
  \ (arr.get(j) > maxVal) {\n                    maxVal = arr.get(j);\n          \
  \          maxIndex = j;\n                }\n            }\n            result.add(maxVal);\n\
  \            arr.remove(maxIndex);\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ queue = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            if (queue.size() < k) {\n                queue.add(arr.get(i));\n \
  \           } else {\n                if (queue.peek() < arr.get(i)) {\n       \
  \             queue.remove();\n                    queue.add(arr.get(i));\n    \
  \            }\n            }\n        }\n        while (!queue.isEmpty()) {\n \
  \           result.add(queue.remove());\n        }\n        return result;"
- "        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i =\
  \ 0; i < arr.size(); i++) {\n            map.put(arr.get(i), map.getOrDefault(arr.get(i),\
  \ 0) + 1);\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        for (int i = 0; i < k; i++) {\n            if (map.size() == 0) {\n   \
  \             break;\n            }\n            result.add(map.lastKey());\n  \
  \          map.put(map.lastKey(), map.get(map.lastKey()) - 1);\n            if (map.get(map.lastKey())\
  \ == 0) {\n                map.remove(map.lastKey());\n            }\n        }\n\
  \        return result;"
- "        if (arr.size() == 0) return arr;\n        if (arr.size() == 1) return arr;\n\
  \        if (arr.size() == k) return arr;\n        int maxIndex = arr.size() - 1;\n\
  \        int minIndex = 0;\n        while (maxIndex >= minIndex) {\n           \
  \ int pivotIndex = partition(arr, minIndex, maxIndex);\n            if (pivotIndex\
  \ == k - 1) {\n                return new ArrayList<Integer>(arr.subList(0, k));\n\
  \            } else if (pivotIndex > k - 1) {\n                maxIndex = pivotIndex\
  \ - 1;\n            } else {\n                minIndex = pivotIndex + 1;\n     \
  \       }\n        }\n        return arr;"
- "        ArrayList<Integer> list = new ArrayList<Integer>();\n        int max_i\
  \ = 0;\n        for (int i = 0; i < k; i++) {\n            for (int j = 0; j < arr.size();\
  \ j++) {\n                if (arr.get(j) > arr.get(max_i))\n                   \
  \ max_i = j;\n            }\n            list.add(arr.get(max_i));\n           \
  \ arr.remove(max_i);\n        }\n        return list;"
- "        ArrayList<Integer> maximum = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>(Comparator.reverseOrder());\n        for (int i = 0;\
  \ i < arr.size(); i++)\n            pq.add(arr.get(i));\n        while (k-- > 0)\n\
  \            maximum.add(pq.poll());\n        return maximum;"
- "        // This solution sorts the array and returns the first k elements.\n  \
  \      // Time complexity is O(nlogn).\n        Collections.sort(arr);\n       \
  \ return new ArrayList<Integer>(arr.subList(arr.size() - k, arr.size()));"
- "        ArrayList<Integer> res = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            pq.add(arr.get(i));\n            if (pq.size() > k) {\n           \
  \     pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n  \
  \          res.add(pq.poll());\n        }\n        Collections.reverse(res);\n \
  \       return res;"
- "        // Create a sorted set in descending order.\n        // The set will contain\
  \ the first k values of arr.\n        TreeSet<Integer> set = new TreeSet<Integer>(Collections.reverseOrder());\n\
  \        // For each element in arr, if the set is less than k\n        // then\
  \ simply add the element to the set. If the set\n        // is of size k, then compare\
  \ the element to the minimum\n        // value of the set. If the element is greater\
  \ than the \n        // minimum value of the set, then add the element to the\n\
  \        // set and remove the minimum value from the set.\n        for (int i =\
  \ 0; i < arr.size(); i++) {\n            if (set.size() < k) {\n               \
  \ set.add(arr.get(i));\n            } else {\n                if (arr.get(i) > set.first())\
  \ {\n                    set.add(arr.get(i));\n                    set.remove(set.first());\n\
  \                }\n            }\n        }\n        // Return the set as an ArrayList.\n\
  \        return new ArrayList<Integer>(set);"
- "        // We can create an ordered map (i.e. tree map) whose keys are the elements\
  \ of\n        // the array and the values are their respective counts. After that\
  \ we can use\n        // descending order to sort the map and then grab the first\
  \ k values.\n        // We need to use custom comparator to sort the map in descending\
  \ order.\n        // The key of the map is the integer, the value is the count.\n\
  \        // We need to sort the map in descending order.\n        TreeMap<Integer,\
  \ Integer> map = new TreeMap<Integer, Integer>(new Comparator<Integer>() {\n   \
  \         @Override\n            public int compare(Integer x, Integer y) {\n  \
  \              return y - x;\n            }\n        });\n        for (int i = 0;\
  \ i < arr.size(); i++) {\n            int key = arr.get(i);\n            if (map.containsKey(key))\
  \ {\n                map.put(key, map.get(key) + 1);\n            } else {\n   \
  \             map.put(key, 1);\n            }\n        }\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        int index = 0;\n        for (Map.Entry<Integer,\
  \ Integer> entry : map.entrySet()) {\n            for (int i = 0; i < entry.getValue();\
  \ i++) {\n                if (index == k) {\n                    return result;\n\
  \                }\n                result.add(entry.getKey());\n              \
  \  index++;\n            }\n        }\n        return result;"
- "        // Let us find the maximum number in the list.\n        int max_num = arr.get(0);\n\
  \        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) > max_num)\
  \ {\n                max_num = arr.get(i);\n            }\n        }\n        //\
  \ Now, let us compute the minimum number in the list.\n        int min_num = max_num;\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) < min_num)\
  \ {\n                min_num = arr.get(i);\n            }\n        }\n        //\
  \ Now, let us build a special data structure which can hold a number of the\n  \
  \      // array together with its copy.\n        ArrayList<Pair<Integer, Integer>>\
  \ temp = new ArrayList<Pair<Integer, Integer>>();\n        for (int i = 0; i < arr.size();\
  \ i++) {\n            temp.add(new Pair<Integer, Integer>(arr.get(i), arr.get(i)));\n\
  \        }\n        // Now, let us sort the elements in the list.\n        for (int\
  \ i = 0; i < temp.size(); i++) {\n            for (int j = i; j < temp.size(); j++)\
  \ {\n                if (temp.get(i).getValue0() > temp.get(j).getValue0()) {\n\
  \                    Pair<Integer, Integer> temp_pair = temp.get(i);\n         \
  \           temp.set(i, temp.get(j));\n                    temp.set(j, temp_pair);\n\
  \                }\n            }\n        }\n        // Now, let us augment the\
  \ data structure with the maximum copy of the elements.\n        for (int i = 0;\
  \ i < temp.size(); i++) {\n            temp.get(i).setAt1(max_num);\n        }\n\
  \        // Now, let us copy the maximum number to the first element in the list,\
  \ then to\n        // the second element in the list, then to the third element\
  \ in the list, and so\n        // on until k elements in the list are augmented.\n\
  \        int count = 0;\n        for (int i = 0"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return res;\n        }\n        if (arr.size() <= k) {\n\
  \            return arr;\n        }\n        if (k == 0) {\n            return res;\n\
  \        }\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k);\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (pq.size() < k)\
  \ {\n                pq.add(arr.get(i));\n            } else {\n               \
  \ if (pq.peek() < arr.get(i)) {\n                    pq.poll();\n              \
  \      pq.add(arr.get(i));\n                }\n            }\n        }\n      \
  \  for (int i = 0; i < k; i++) {\n            res.add(pq.poll());\n        }\n \
  \       return res;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ copy = (ArrayList<Integer>)arr.clone();\n        copy.sort(Collections.reverseOrder());\n\
  \        for (int i = 0; i < k; i++) {\n            res.add(copy.get(i));\n    \
  \    }\n        return res;"
- "        final Comparator<Integer> comparator = (num1, num2) -> -1 * Integer.compare(num1,\
  \ num2);\n        PriorityQueue<Integer> pq = new PriorityQueue<>(comparator);\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n\
  \        }\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int\
  \ i = 0; i < k; i++) {\n            list.add(pq.poll());\n        }\n        return\
  \ list;"
- "        ArrayList<Integer> ret = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ tmp = new ArrayList<Integer>();\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            if (tmp.size() == 0) tmp.add(arr.get(i));\n            else {\n\
  \                int last = tmp.get(tmp.size() - 1);\n                if (last <\
  \ arr.get(i)) {\n                    int j = tmp.size() - 1;\n                 \
  \   while (j >= 0 && tmp.get(j) < arr.get(i)) {\n                        tmp.remove(j);\n\
  \                        j--;\n                    }\n                    tmp.add(arr.get(i));\n\
  \                } else tmp.add(arr.get(i));\n            }\n        }\n       \
  \ for (int i = 0; i < k; i++) {\n            ret.add(tmp.get(i));\n        }\n \
  \       return ret;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        Collections.sort(arr);\n\
  \        for (int i = arr.size() - 1; i >= 0 && k > 0; --i, --k) {\n           \
  \ result.add(arr.get(i));\n        }\n        return result;"
- "        // Stores the result\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        // Stores the minimum value\n        int min = -1001;\n        // Stores\
  \ the maximum value\n        int max = 1000;\n        // While there are still numbers\
  \ left to choose\n        while (k > 0) {\n            // Iterate through the array\
  \ to find the maximum number\n            int maxIndex = -1;\n            for (int\
  \ i = 0; i < arr.size(); i++) {\n                // If we find a new maximum number\n\
  \                if (arr.get(i) > min && arr.get(i) <= max) {\n                \
  \    // Update the maximum number\n                    max = arr.get(i);\n     \
  \               // Update the index of the maximum number\n                    maxIndex\
  \ = i;\n                }\n            }\n            // If we find a number\n \
  \           if (maxIndex != -1) {\n                // Add the maximum number to\
  \ the result\n                result.add(max);\n                // Update the new\
  \ minimum\n                min = max;\n                // Update the new maximum\n\
  \                max = 1000;\n                // Remove the number from the array\n\
  \                arr.remove(maxIndex);\n                // Decrement k\n       \
  \         k--;\n            }\n            // If we don't find a number\n      \
  \      else {\n                // Stop looking\n                break;\n       \
  \     }\n        }\n        // Return the result\n        return result;"
- "        // keep only k smallest elements in the array.\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int\
  \ x : arr) {\n            heap.add(x);\n            if (heap.size() > k) {\n   \
  \             heap.poll();\n            }\n        }\n        return new ArrayList<Integer>(heap);"
- "        ArrayList<Integer> maxes = new ArrayList<Integer>();\n        // Write\
  \ code here to return the array list with the maximum k integers.\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public\
  \ int compare(Integer a, Integer b) {\n                return b - a;\n         \
  \   }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n           \
  \ heap.add(arr.get(i));\n        }\n        while (maxes.size() < k) {\n       \
  \     maxes.add(heap.poll());\n        }\n        return maxes;"
- "        // return arr.stream().sorted((x, y) -> Integer.compare(y, x)).limit(k).collect(Collectors.toCollection(ArrayList::new));\n\
  \        // return arr.stream().sorted((x, y) -> Integer.compare(y, x)).limit(k).collect(Collectors.toCollection(ArrayList::new));\n\
  \        PriorityQueue<Integer> q = new PriorityQueue<>((x, y) -> Integer.compare(y,\
  \ x));\n        for (int i = 0; i < arr.size(); i++) {\n            q.add(arr.get(i));\n\
  \        }\n        arr.clear();\n        for (int i = 0; i < k; i++) {\n      \
  \      arr.add(q.poll());\n        }\n        return arr;"
- "        assert k >= 0 && k <= arr.size();\n        return new ArrayList<Integer>(arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toList()));"
- "        Queue<Integer> maxHeap = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (maxHeap.size()\
  \ < k) {\n                maxHeap.add(arr.get(i));\n            } else {\n     \
  \           if (maxHeap.peek() < arr.get(i)) {\n                    maxHeap.poll();\n\
  \                    maxHeap.add(arr.get(i));\n                }\n            }\n\
  \        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n    \
  \    while (!maxHeap.isEmpty()) {\n            result.add(maxHeap.poll());\n   \
  \     }\n        return result;"
- "        if (arr.size() == 0) {\n            return arr;\n        }\n        if\
  \ (k == 0) {\n            return new ArrayList<Integer>();\n        }\n        if\
  \ (k >= arr.size()) {\n            Collections.sort(arr);\n            Collections.reverse(arr);\n\
  \            return arr;\n        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
  \        Comparator<Integer> comparator = new Comparator<Integer>() {\n        \
  \    @Override\n            public int compare(Integer first, Integer second) {\n\
  \                return first.compareTo(second);\n            }\n        };\n  \
  \      PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k, comparator);\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (queue.size() <\
  \ k) {\n                queue.add(arr.get(i));\n            } else {\n         \
  \       int min = queue.peek();\n                if (arr.get(i) > min) {\n     \
  \               queue.poll();\n                    queue.add(arr.get(i));\n    \
  \            }\n            }\n        }\n        ArrayList<Integer> sorted = new\
  \ ArrayList<Integer>(queue);\n        Collections.sort(sorted);\n        Collections.reverse(sorted);\n\
  \        return sorted;"
- "        PriorityQueue<Integer> heap = new PriorityQueue<>();\n        for (int\
  \ i = 0; i < arr.size(); i++) {\n            if (heap.size() < k) {\n          \
  \      heap.add(arr.get(i));\n            } else {\n                heap.add(arr.get(i));\n\
  \                heap.poll();\n            }\n        }\n        ArrayList<Integer>\
  \ ans = new ArrayList<>();\n        while (heap.size() > 0) {\n            ans.add(heap.poll());\n\
  \        }\n        Collections.reverse(ans);\n        return ans;"
- "        // Find k elements of the maximum value\n        // If a duplicate value\
  \ exists, the following value must be unique.\n        // This is the opposite of\
  \ sorting by value.\n        // All values in the array must be unique.\n      \
  \  // Time Complexity: O(k * log(k))\n        ArrayList<Integer> new_arr = new ArrayList<Integer>();\n\
  \        if (arr.size() < k) {\n            return new_arr;\n        }\n       \
  \ // Max heap\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new\
  \ Comparator<Integer>() {\n            @Override\n            public int compare(Integer\
  \ o1, Integer o2) {\n                if (o1 > o2) {\n                    return\
  \ -1;\n                } else if (o1 < o2) {\n                    return 1;\n  \
  \              } else {\n                    return 0;\n                }\n    \
  \        }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n      \
  \      if (pq.size() < k) {\n                pq.add(arr.get(i));\n            }\
  \ else {\n                int top = pq.peek();\n                if (top < arr.get(i))\
  \ {\n                    pq.poll();\n                    pq.add(arr.get(i));\n \
  \               }\n            }\n        }\n        while (!pq.isEmpty()) {\n \
  \           new_arr.add(pq.poll());\n        }\n        return new_arr;"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) return ans;\n        for (int i = 0; i < k; i++) ans.add(arr.get(i));\n\
  \        for (int i = k; i < arr.size(); i++) {\n            ans.add(arr.get(i));\n\
  \            Collections.sort(ans);\n            ans.remove(0);\n        }\n   \
  \     Collections.sort(ans);\n        return ans;"
- "        // We can use a max heap to solve this problem. In a max heap, the minimum\
  \ element\n        // is at the root of the heap.\n        // We will add all of\
  \ the elements to the heap and then poll the root k times to\n        // get the\
  \ maximum k elements.\n        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(arr.size(),\
  \ Collections.reverseOrder());\n        heap.addAll(arr);\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n  \
  \          result.add(heap.poll());\n        }\n        return result;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k, new Comparator<Integer>()\
  \ {\n            public int compare(Integer a, Integer b) {\n                return\
  \ Integer.compare(b, a);\n            }\n        });\n        for (int e : arr)\
  \ {\n            pq.add(e);\n            if (pq.size() > k) {\n                pq.poll();\n\
  \            }\n        }\n        ArrayList<Integer> l = new ArrayList<Integer>();\n\
  \        while (!pq.isEmpty()) {\n            l.add(pq.poll());\n        }\n   \
  \     return l;"
- "        ArrayList<Integer> q = new ArrayList<>();\n        int i = 0;\n       \
  \ for (; i < k; i++) {\n            q.add(arr.get(i));\n        }\n        for (;\
  \ i < arr.size(); i++) {\n            int j = 0;\n            for (; j < k; j++)\
  \ {\n                if (arr.get(i) > q.get(j)) {\n                    break;\n\
  \                }\n            }\n            if (j < k) {\n                q.remove(k\
  \ - 1);\n                q.add(j, arr.get(i));\n            }\n        }\n     \
  \   return q;"
- "        // we don't care about the order of numbers in our result\n        // we\
  \ can use a max heap because it preserves the max numbers while we pop k\n     \
  \   // elements out of it\n        ArrayList<Integer> r = new ArrayList<Integer>();\n\
  \        // max heap in descending order\n        Queue<Integer> pq = new PriorityQueue<Integer>(k,\
  \ Collections.reverseOrder());\n        // add first k elements to the heap\n  \
  \      for (int i = 0; i < k; i++) {\n            pq.add(arr.get(i));\n        }\n\
  \        // add and pop for the rest of the array\n        for (int i = k; i < arr.size();\
  \ i++) {\n            // add the next element\n            pq.add(arr.get(i));\n\
  \            // pop the smallest\n            pq.poll();\n        }\n        //\
  \ convert the heap to an arraylist\n        while (pq.size() > 0) {\n          \
  \  r.add(pq.poll());\n        }\n        // I am lazy and I don't care about the\
  \ order of the arraylist\n        Collections.reverse(r);\n        return r;"
- "        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n        for (int\
  \ i = 0; i < arr.size(); i++) {\n            int temp = arr.get(i);\n          \
  \  if (map.containsKey(temp)) {\n                map.get(temp).add(i);\n       \
  \     } else {\n                List<Integer> list = new ArrayList<>();\n      \
  \          list.add(i);\n                map.put(temp, list);\n            }\n \
  \       }\n        ArrayList<Integer> list = new ArrayList<>();\n        while (list.size()\
  \ < k) {\n            Map.Entry<Integer, List<Integer>> entry = map.pollLastEntry();\n\
  \            list.add(entry.getKey());\n            List<Integer> indices = entry.getValue();\n\
  \            if (indices.size() > 1) {\n                map.put(entry.getKey(),\
  \ indices.subList(1, indices.size()));\n            }\n        }\n        return\
  \ list;"
- '        return null;'
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return result;\n        }\n        // Python's heapq.nlargest\
  \ does not support multiple identical keys.\n        // Instead of using a list\
  \ for the heap contents, use a dictionary\n        // in which each element is paired\
  \ with an integer count.\n        // https://stackoverflow.com/questions/31894867/python-implementing-heapq-nlargest-with-multiple-identical-keys\n\
  \        HashMap<Integer, Integer> h = new HashMap<Integer, Integer>();\n      \
  \  // We use a min-heap to solve this problem.\n        // If a number is the n-th\
  \ largest, it is at least the (n + 1)-th smallest.\n        // This makes for a\
  \ quicker evaluation.\n        for (int i = 0; i < arr.size(); i++) {\n        \
  \    int v = arr.get(i);\n            if (h.containsKey(v)) {\n                h.put(v,\
  \ h.get(v) + 1);\n            } else {\n                h.put(v, 1);\n         \
  \   }\n        }\n        // Use the stream API to sort the hashmap.\n        //\
  \ This requires the collector to form a list of entries.\n        // https://stackoverflow.com/questions/45783516/java-8-convert-streamltmapelement-gt-to-list\n\
  \        List<Map.Entry<Integer, Integer>> temp = h.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toList());\n\
  \        ArrayList<Integer> list = new ArrayList<Integer>();\n        // We need\
  \ to reverse the order of the list.\n        for (int i = temp.size() - 1; i >=\
  \ 0; i--) {\n            list.add(temp.get(i).getKey());\n        }\n        for\
  \ (int i = 0; i < k; i++) {\n            result.add(list.get(i));\n        }\n \
  \       return result;"
- "        // Your Code Here\n        return null;"
- "        if (arr.size() <= k) {\n            Collections.sort(arr);\n          \
  \  Collections.reverse(arr);\n            return arr;\n        }\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        PriorityQueue<Integer> queue = new\
  \ PriorityQueue<Integer>();\n        for (int i = 0; i < arr.size(); i++) {\n  \
  \          queue.add(arr.get(i));\n            if (queue.size() > k) {\n       \
  \         queue.poll();\n            }\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            result.add(queue.poll());\n        }\n        Collections.reverse(result);\n\
  \        return result;"
- '        return new ArrayList<Integer>();'
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) return result;\n        if (arr.size() == 1) {\n            result.add(arr.get(0));\n\
  \            return result;\n        }\n        if (arr.size() == k) return arr;\n\
  \        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(new Comparator<Integer>()\
  \ {\n            public int compare(Integer a, Integer b) {\n                return\
  \ b - a;\n            }\n        });\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            heap.add(arr.get(i));\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            result.add(heap.poll());\n        }\n        return result;"
- "        // Iterate over arr, inserting into heap of size k.\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (heap.size() < k)\
  \ {\n                heap.add(arr.get(i));\n            } else {\n             \
  \   if (arr.get(i) > heap.peek()) {\n                    heap.remove();\n      \
  \              heap.add(arr.get(i));\n                }\n            }\n       \
  \ }\n        for (int i = 0; i < k; i++) {\n            result.add(heap.remove());\n\
  \        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ <= k) {\n            return arr;\n        }\n        result.addAll(arr.subList(0,\
  \ k));\n        Collections.sort(result);\n        for (int i = k; i < arr.size();\
  \ i++) {\n            if (arr.get(i) > result.get(0)) {\n                result.remove(0);\n\
  \                int index = Collections.binarySearch(result, arr.get(i));\n   \
  \             if (index < 0) {\n                    index = -(index + 1);\n    \
  \            }\n                result.add(index, arr.get(i));\n            }\n\
  \        }\n        return result;"
- "        if (arr.size() == 0) {\n            return new ArrayList<Integer>();\n\
  \        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n    \
  \    MinHeap minHeap = new MinHeap(k);\n        for (int i = 0; i < arr.size();\
  \ i++) {\n            if (minHeap.size < k) {\n                minHeap.insert(arr.get(i));\n\
  \            } else {\n                if (arr.get(i) > minHeap.peek()) {\n    \
  \                minHeap.delete();\n                    minHeap.insert(arr.get(i));\n\
  \                }\n            }\n        }\n        return minHeap.elements;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ sorted = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n        for\
  \ (int i = 0; i < arr.size(); i++) {\n            sorted.add(arr.get(i));\n    \
  \    }\n        for (int i = 0; i < k; i++) {\n            result.add(sorted.poll());\n\
  \        }\n        return result;"
- "        ArrayList<Integer> list = new ArrayList<Integer>();\n        // You may\
  \ assume that k is a valid integer, and k <= arr.length.\n        // You may also\
  \ assume that arr is sorted.\n        // Time Complexity: O(k * log(k))\n      \
  \  // Space Complexity: O(k)\n        // for(int i = 0; i < k; i++)\n        //\
  \     list.add(arr.get(i));\n        // return list;\n        // Time Complexity:\
  \ O(k * log(k))\n        // Space Complexity: O(k)\n        // for(int i = 0; i\
  \ < k; i++)\n        //     list.add(arr.get(arr.size() - i - 1));\n        // return\
  \ list;\n        // Time Complexity: O(k * log(k))\n        // Space Complexity:\
  \ O(k)\n        // int max = arr.get(0);\n        // list.add(max);\n        //\
  \ for(int i = 1; i < k; i++) {\n        //     max = arr.get(i);\n        //   \
  \  for(int j = 0; j < list.size(); j++) {\n        //         if(max > list.get(j))\
  \ {\n        //             list.add(j, max);\n        //             break;\n \
  \       //         }\n        //     }\n        // }\n        // return list;\n\
  \        // Time Complexity: O(k * log(k))\n        // Space Complexity: O(k)\n\
  \        // int max = arr.get(0);\n        // list.add(max);\n        // for(int\
  \ i = 1; i < k; i++) {\n        //     max = arr.get(i);\n        //     if(max\
  \ > list.get(0)) {\n        //         list.add(0, max);\n        //         continue;\n\
  \        //     }\n        //     if(max < list.get(list.size() - 1)) {\n      \
  \  //         list.add(max);\n        //         continue;\n        //     }\n \
  \       //     for(int j = 0; j < list.size(); j++) {\n        //         if(max\
  \ > list"
- "        ArrayList<Integer> result = new ArrayList<>();\n        if (arr.size()\
  \ == 0) return result;\n        if (arr.size() == 1) {\n            result.add(arr.get(0));\n\
  \            return result;\n        }\n        // remove from the end of the array.\n\
  \        for (int i = 0; i < k; i++) {\n            // get the index of the maximum\n\
  \            int maxIndex = 0;\n            for (int j = 1; j < arr.size(); j++)\
  \ {\n                if (arr.get(j) > arr.get(maxIndex)) {\n                   \
  \ maxIndex = j;\n                }\n            }\n            result.add(arr.get(maxIndex));\n\
  \            arr.remove(maxIndex);\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return result;\n        }\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int\
  \ i : arr) {\n            pq.add(i);\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            result.add(pq.poll());\n        }\n        return result;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        for (int a : arr) {\n            pq.add(a);\n\
  \            if (pq.size() > k) {\n                pq.poll();\n            }\n \
  \       }\n        for (int a : pq) {\n            res.add(a);\n        }\n    \
  \    return res;"
- "        // If the input array is empty, return an empty array list.\n        if\
  \ (arr.size() == 0) {\n            return new ArrayList<Integer>();\n        }\n\
  \        // Create a priority queue with the natural ordering.\n        PriorityQueue<Integer>\
  \ q = new PriorityQueue<Integer>();\n        // Create a new array list to store\
  \ the result.\n        ArrayList<Integer> result = new ArrayList<Integer>();\n \
  \       // For each element in the input array.\n        for (int elem : arr) {\n\
  \            // If the queue has k elements or is not empty and the element is greater\
  \ than the\n            // first element, remove the first element.\n          \
  \  if (q.size() == k || (!q.isEmpty() && elem > q.peek())) {\n                q.poll();\n\
  \            }\n            // If the queue is less than k elements, add the element.\n\
  \            if (q.size() < k) {\n                q.add(elem);\n            }\n\
  \        }\n        // For each element in the queue, add it to the result array\
  \ list.\n        for (int elem : q) {\n            result.add(elem);\n        }\n\
  \        // Sort the result array list in reverse order.\n        Collections.sort(result,\
  \ Collections.reverseOrder());\n        // Return the result array list.\n     \
  \   return result;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (arr.size()\
  \ < k) {\n            return res;\n        }\n        PriorityQueue<Integer> q =\
  \ new PriorityQueue<Integer>(k, (a, b) -> b - a);\n        for (int i = 0; i < arr.size();\
  \ i++) {\n            q.add(arr.get(i));\n        }\n        for (int i = 0; i <\
  \ k; i++) {\n            res.add(q.poll());\n        }\n        return res;"
- "        ArrayList<Integer> answer = new ArrayList<Integer>();\n        answer.addAll(arr.subList(0,\
  \ k));\n        Collections.sort(answer);\n        for (int i = k; i < arr.size();\
  \ i++) {\n            int number = arr.get(i);\n            if (number > answer.get(0))\
  \ {\n                answer.remove(0);\n                answer.add(number);\n  \
  \              Collections.sort(answer);\n            }\n        }\n        return\
  \ answer;"
- "        if (arr.size() == 0) return new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ max = new ArrayList<Integer>();\n        int lower = 0;\n        int upper = arr.size()\
  \ - 1;\n        int sz = arr.size();\n        for (int i = 0; i < k; i++) {\n  \
  \          Integer max_val = Integer.MIN_VALUE;\n            int max_idx = -1;\n\
  \            for (int j = lower; j <= upper; j++) {\n                if (arr.get(j)\
  \ > max_val) {\n                    max_val = arr.get(j);\n                    max_idx\
  \ = j;\n                }\n            }\n            max.add(max_val);\n      \
  \      lower = max_idx + 1;\n            upper = sz - 1;\n        }\n        return\
  \ max;"
- "        // The basic idea is to use a max heap.\n        // The max heap has size\
  \ k, and when the heap is full, if a new element\n        // is larger than the\
  \ max heap head, replace the head with the new element.\n        // So the heap\
  \ always contains the top k largest elements.\n        ArrayList<Integer> res =\
  \ new ArrayList<>();\n        if (arr == null || arr.size() == 0 || k == 0) {\n\
  \            return res;\n        }\n        Queue<Integer> heap = new PriorityQueue<>(k,\
  \ new Comparator<Integer>() {\n            @Override\n            public int compare(Integer\
  \ o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (heap.size() < k)\
  \ {\n                heap.offer(arr.get(i));\n            } else {\n           \
  \     if (arr.get(i) > heap.peek()) {\n                    heap.poll();\n      \
  \              heap.offer(arr.get(i));\n                }\n            }\n     \
  \   }\n        for (int i = 0; i < k; i++) {\n            res.add(heap.poll());\n\
  \        }\n        return res;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            pq.add(arr.get(i));\n            if (pq.size() > k) {\n           \
  \     pq.poll();\n            }\n        }\n        for (int i = 0; i < k; i++)\
  \ {\n            res.add(pq.poll());\n        }\n        return res;"
- "        // a heap is a data structure that is similar to a binary tree except each\
  \ node has at most 2 children\n        // at any given time the smallest element\
  \ is at the top and the largest element is at the bottom\n        // insertion and\
  \ deletion are O(log(n)) because you must traverse the tree\n        // heap sort\
  \ is similar to selection sort in that it uses a heap to select the smallest element\
  \ in each iteration\n        // the main difference is that you don't have to run\
  \ the selection sort algorithm n times, the heap can keep track\n        // of the\
  \ smallest elements and swap them with the largest element\n        // first you\
  \ build the heap, then you take the top element and swap it with the last element,\
  \ then you delete the\n        // last element and change the top element to the\
  \ largest element, then you swap the top element with the last element\n       \
  \ // again and you run this until you have k elements\n        // you can use a\
  \ priority queue to simulate a max heap\n        PriorityQueue<Integer> heap = new\
  \ PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int i = 0; i\
  \ < arr.size(); i++) {\n            heap.add(arr.get(i));\n        }\n        ArrayList<Integer>\
  \ res = new ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n     \
  \       res.add(heap.poll());\n        }\n        return res;"
- "        int n = arr.size();\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        if (k == 0) {\n            return result;\n        }\n        Collections.sort(arr);\n\
  \        int i = n - 1;\n        while (k > 0) {\n            result.add(arr.get(i));\n\
  \            i--;\n            k--;\n        }\n        return result;"
- "        if (arr.size() == 0) {\n            return new ArrayList<Integer>();\n\
  \        }\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(arr.size(),\
  \ Collections.reverseOrder());\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            maxHeap.add(arr.get(i));\n        }\n        ArrayList<Integer> max\
  \ = new ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n         \
  \   max.add(maxHeap.poll());\n        }\n        return max;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ minHeap = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            if (minHeap.size() < k) {\n                minHeap.add(arr.get(i));\n\
  \            } else {\n                if (minHeap.peek() < arr.get(i)) {\n    \
  \                minHeap.poll();\n                    minHeap.add(arr.get(i));\n\
  \                }\n            }\n        }\n        while (!minHeap.isEmpty())\
  \ {\n            result.add(minHeap.poll());\n        }\n        Collections.reverse(result);\n\
  \        return result;"
- "        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k);\n        for\
  \ (int i = 0; i < arr.size(); i++) {\n            if (heap.size() < k) {\n     \
  \           heap.add(arr.get(i));\n            } else {\n                int x =\
  \ heap.peek();\n                if (x < arr.get(i)) {\n                    heap.poll();\n\
  \                    heap.add(arr.get(i));\n                }\n            }\n \
  \       }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n     \
  \   while (heap.size() > 0) result.add(heap.poll());\n        Collections.reverse(result);\n\
  \        return result;"
- "        // declare return array\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        // handle invalid input\n        if (arr == null || arr.size() == 0 ||\
  \ k <= 0 || k > arr.size()) {\n            return result;\n        }\n        //\
  \ define a max heap\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new\
  \ Comparator<Integer>() {\n            @Override\n            public int compare(Integer\
  \ a, Integer b) {\n                return b - a;\n            }\n        });\n \
  \       // go through the array and add to the max heap\n        for (int i = 0;\
  \ i < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n        }\n    \
  \    // process the heap\n        for (int i = 0; i < k; i++) {\n            result.add(maxHeap.poll());\n\
  \        }\n        // return the resulting array\n        return result;"
- "        // O(n log n)\n        Collections.sort(arr);\n        ArrayList<Integer>\
  \ res = new ArrayList<Integer>();\n        for (int i = arr.size() - 1; i >= arr.size()\
  \ - k; i--) {\n            res.add(arr.get(i));\n        }\n        return res;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        if (arr.size()\
  \ == 0) {\n            return result;\n        }\n        result.add(arr.get(0));\n\
  \        if (k == 1) {\n            return result;\n        }\n        for (int\
  \ i = 1; i < arr.size(); i++) {\n            if (result.size() < k) {\n        \
  \        result.add(arr.get(i));\n            } else {\n                result.sort(Collections.reverseOrder());\n\
  \                for (int j = 0; j < result.size(); j++) {\n                   \
  \ if (arr.get(i) > result.get(j)) {\n                        result.remove(j);\n\
  \                        result.add(arr.get(i));\n                        break;\n\
  \                    }\n                }\n            }\n        }\n        result.sort(Collections.reverseOrder());\n\
  \        return result;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        if (arr.size() ==\
  \ 0) return res;\n        if (arr.size() <= k) return arr;\n        int i = 0;\n\
  \        while (i < k) {\n            int max = arr.get(i);\n            int max_i\
  \ = i;\n            for (int j = i + 1; j < arr.size(); j++) {\n               \
  \ if (arr.get(j) > max) {\n                    max = arr.get(j);\n             \
  \       max_i = j;\n                }\n            }\n            arr.set(max_i,\
  \ arr.get(i));\n            arr.set(i, max);\n            res.add(max);\n      \
  \      i++;\n        }\n        return res;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        if (arr.size() ==\
  \ 0) return res;\n        if (arr.size() == 1) {\n            res.add(arr.get(0));\n\
  \            return res;\n        }\n        int min = Collections.min(arr);\n \
  \       if (min >= 0) {\n            Collections.sort(arr, Collections.reverseOrder());\n\
  \            return new ArrayList<Integer>(arr.subList(0, k));\n        }\n    \
  \    ArrayList<Integer> p = new ArrayList<>();\n        ArrayList<Integer> n = new\
  \ ArrayList<>();\n        for (int i : arr) {\n            if (i < 0) n.add(i);\n\
  \            else p.add(i);\n        }\n        Collections.sort(p, Collections.reverseOrder());\n\
  \        Collections.sort(n);\n        int i = 0;\n        int j = 0;\n        for\
  \ (int w = 0; w < k; w++) {\n            if (i < p.size() && j < n.size()) {\n \
  \               if (p.get(i) > -n.get(j)) {\n                    res.add(p.get(i));\n\
  \                    i++;\n                } else {\n                    res.add(n.get(j));\n\
  \                    j++;\n                }\n            } else if (i < p.size())\
  \ {\n                res.add(p.get(i));\n                i++;\n            } else\
  \ {\n                res.add(n.get(j));\n                j++;\n            }\n \
  \       }\n        return res;"
- "        var pq = new PriorityQueue<Integer>(Comparator.reverseOrder());\n     \
  \   for (var num : arr) {\n            pq.add(num);\n            if (pq.size() >\
  \ k) {\n                pq.poll();\n            }\n        }\n        var max =\
  \ new ArrayList<Integer>();\n        for (var i = 0; i < k; i++) {\n           \
  \ max.add(pq.poll());\n        }\n        return max;"
- '        return arr.stream().sorted((a, b) -> b - a).limit(k).collect(Collectors.toCollection(ArrayList::new));'
- "        ArrayList<Integer> ret = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n\
  \            public int compare(Integer a, Integer b) {\n                return\
  \ -1 * a.compareTo(b);\n            }\n        });\n        for (int e : arr) {\n\
  \            pq.add(e);\n        }\n        for (int i = 0; i < k; i++) {\n    \
  \        ret.add(pq.poll());\n        }\n        return ret;"
- "        // We can use a heap of the max-heap type. \n        // If a new element\
  \ is larger than the first element (min element) of the \n        // heap, replace\
  \ it with the new element. Otherwise, ignore the new element.\n        // Time complexity:\
  \ O(n log k) where n is the length of the array, k is the \n        // maximum number\
  \ of numbers.\n        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k,\
  \ Collections.reverseOrder());\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            if (heap.size() < k) {\n                heap.add(arr.get(i));\n   \
  \         } else {\n                int m = heap.peek();\n                if (arr.get(i)\
  \ > m) {\n                    heap.poll();\n                    heap.add(arr.get(i));\n\
  \                }\n            }\n        }\n        return new ArrayList<Integer>(heap);"
- "        if (arr.size() == k) {\n            return arr;\n        }\n        ArrayList<Integer>\
  \ list = new ArrayList<Integer>();\n        ArrayList<Integer> maxList = new ArrayList<Integer>();\n\
  \        list.add(arr.get(0));\n        for (int i = 1; i < arr.size(); i++) {\n\
  \            int max = list.get(0);\n            for (int j = 0; j < list.size();\
  \ j++) {\n                if (list.get(j) > max) {\n                    max = list.get(j);\n\
  \                }\n            }\n            if (arr.get(i) >= max) {\n      \
  \          list.add(arr.get(i));\n            } else {\n                for (int\
  \ j = 0; j < list.size(); j++) {\n                    if (list.get(j) == max) {\n\
  \                        list.set(j, arr.get(i));\n                        break;\n\
  \                    }\n                }\n            }\n        }\n        Collections.sort(list);\n\
  \        for (int i = list.size() - 1; i >= 0; i--) {\n            maxList.add(list.get(i));\n\
  \        }\n        return maxList;"
- "        if (arr.size() <= k) {\n            Collections.sort(arr);\n          \
  \  Collections.reverse(arr);\n            return arr;\n        }\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        for (int i = 0; i < k; i++) result.add(arr.get(i));\n\
  \        Collections.sort(result);\n        Collections.reverse(result);\n     \
  \   for (int i = k; i < arr.size(); i++) {\n            int j = 0;\n           \
  \ int s = result.size();\n            for (; j < s; j++) {\n                if (arr.get(i)\
  \ > result.get(j)) {\n                    result.remove(j);\n                  \
  \  result.add(j, arr.get(i));\n                    break;\n                }\n \
  \           }\n            if (j == s) result.remove(s - 1);\n        }\n      \
  \  return result;"
- "        ArrayList<Integer> max = new ArrayList<>();\n        ArrayList<Integer>\
  \ sortedArr = arr;\n        Collections.sort(sortedArr);\n        for (int i = sortedArr.size()\
  \ - 1; i >= sortedArr.size() - k; i--) {\n            max.add(sortedArr.get(i));\n\
  \        }\n        return max;"
- "        int count = 0;\n        for (int i = 0; i < arr.size(); i++) {\n      \
  \      for (int j = i + 1; j < arr.size(); j++) {\n                if (arr.get(i)\
  \ > arr.get(j)) {\n                    int temp = arr.get(i);\n                \
  \    arr.set(i, arr.get(j));\n                    arr.set(j, temp);\n          \
  \      }\n            }\n            if (count < k) {\n                count++;\n\
  \            } else {\n                arr.remove(i);\n            }\n        }\n\
  \        return arr;"
- "        ArrayList<Integer> kMax = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for\
  \ (int i = 0; i < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n   \
  \     }\n        for (int i = 0; i < k; i++) {\n            kMax.add(maxHeap.poll());\n\
  \        }\n        return kMax;"
- "        // Utilize Maximum Heap and Heap Sort, both are O(log n)\n        // First,\
  \ build a Max Heap that stores the first k elements of arr: O(k)\n        // Next,\
  \ if the length of arr is greater than k, then iterate through each\n        //\
  \ number in arr, starting from the kth number and up to the length of arr:\n   \
  \     // O(n-k)\n        // Insert each number from arr into the Max Heap: O(log\
  \ k)\n        // Remove the Max from the Max Heap and insert the next number from\
  \ arr: O(log k)\n        // Finally, remove each number from the Max Heap and store\
  \ it in a list: O(k)\n        // Total: O(k + (n-k)log k) or O(n log k)\n      \
  \  // This is a solution that takes O(k log k) time and is O(k) space.\n       \
  \ ArrayList<Integer> answer = new ArrayList<Integer>();\n        MaxHeap heap =\
  \ new MaxHeap(k);\n        for (int i = 0; i < k; i++) {\n            heap.insert(arr.get(i));\n\
  \        }\n        if (arr.size() > k) {\n            for (int i = k; i < arr.size();\
  \ i++) {\n                heap.extractMax();\n                heap.insert(arr.get(i));\n\
  \            }\n        }\n        for (int i = 0; i < k; i++) {\n            answer.add(heap.extractMax());\n\
  \        }\n        return answer;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            heap.add(arr.get(i));\n            if (heap.size() > k) {\n       \
  \         heap.poll();\n            }\n        }\n        while (!heap.isEmpty())\
  \ {\n            result.add(heap.poll());\n        }\n        Collections.reverse(result);\n\
  \        return result;"
- "        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(k, (Integer a, Integer\
  \ b) -> b - a);\n        for (int i = 0; i < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n\
  \            if (maxHeap.size() > k) {\n                maxHeap.poll();\n      \
  \      }\n        }\n        ArrayList<Integer> maxNums = new ArrayList<>();\n \
  \       while (maxHeap.size() > 0) {\n            maxNums.add(maxHeap.poll());\n\
  \        }\n        return maxNums;"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n            public\
  \ int compare(Integer a, Integer b) {\n                return Integer.compare(b,\
  \ a);\n            }\n        });\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            pq.add(arr.get(i));\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            ans.add(pq.poll());\n        }\n        return ans;"
- "        if (arr.size() == 0) return new ArrayList<Integer>();\n        // Keep\
  \ track of smallest number in subarray.\n        int min = arr.get(0);\n       \
  \ int minIdx = 0;\n        // Use a stack to keep track of decreasing sequence of\
  \ elements.\n        Stack<Integer> stack = new Stack<Integer>();\n        // Find\
  \ all local maxima.\n        for (int i = 0; i < arr.size(); i++) {\n          \
  \  // If a decreasing sequence is found, remove all elements from the stack\n  \
  \          // that are smaller than the current element.\n            // These elements\
  \ will never be part of a larger subarray.\n            while (!stack.isEmpty()\
  \ && arr.get(i) > stack.peek()) stack.pop();\n            stack.push(arr.get(i));\n\
  \            // Update smallest number in subarray.\n            if (arr.get(i)\
  \ < min) {\n                min = arr.get(i);\n                minIdx = i;\n   \
  \         }\n        }\n        if (k == arr.size()) return arr;\n        // If\
  \ k is larger than stack size, return all elements in stack.\n        if (k > stack.size())\
  \ return new ArrayList<Integer>(stack);\n        // If k is smaller than stack size,\
  \ remove elements from stack until k is satisfied.\n        while (stack.size()\
  \ > k) {\n            // Check if top of stack is larger than minimum element in\
  \ subarray.\n            // If it is, remove top of stack and update minimum element.\n\
  \            if (stack.peek() > min) {\n                stack.pop();\n         \
  \       min = arr.get(minIdx+1);\n                minIdx++;\n            }\n   \
  \         // If top of stack is smaller than minimum element in subarray, replace\
  \ it with\n            // minimum element in subarray.\n            else {\n   \
  \             stack.pop();\n                stack.push(min);\n                min\
  \ = arr.get(minIdx+1);\n                minIdx++;\n            }\n        }\n  \
  \      return new ArrayList<Integer>(stack);"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        int n = arr.size();\n\
  \        ArrayList<Integer> arr2 = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < n; i++) arr2.add(i);\n        Collections.sort(arr2, new Comparator<Integer>()\
  \ {\n            public int compare(Integer a, Integer b) {\n                return\
  \ arr.get(b) - arr.get(a);\n            }\n        });\n        for (int i = 0;\
  \ i < k; i++) ans.add(arr.get(arr2.get(i)));\n        return ans;"
- "        int[] heap = new int[k];\n        for (int i = 0; i < k; i++) {\n     \
  \       heap[i] = arr.get(i);\n        }\n        buildMaxHeap(heap);\n        //\
  \ p(\"heap:\");\n        // p(heap);\n        for (int i = k; i < arr.size(); i++)\
  \ {\n            // p(\"arr.get(i):\");\n            // p(arr.get(i));\n       \
  \     if (arr.get(i) > heap[0]) {\n                heap[0] = arr.get(i);\n     \
  \           maxHeapify(heap, 0);\n            }\n        }\n        // p(\"heap:\"\
  );\n        // p(heap);\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
  \        for (int i = 0; i < k; i++) {\n            result.add(heap[i]);\n     \
  \   }\n        return result;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(k, new Comparator<Integer>()\
  \ {\n            @Override\n            public int compare(Integer a, Integer b)\
  \ {\n                return b - a;\n            }\n        });\n        for (int\
  \ i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n        }\n  \
  \      ArrayList<Integer> res = new ArrayList<>();\n        for (int i = 0; i <\
  \ k; i++) {\n            res.add(pq.poll());\n        }\n        return res;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n\
  \        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int\
  \ i = 0; i < k; i++) {\n            ans.add(pq.poll());\n        }\n        return\
  \ ans;"
- '        return new ArrayList<>();'
- "        ArrayList<Integer> list = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ queue = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n          \
  \  public int compare(Integer i1, Integer i2) {\n                return i2 - i1;\n\
  \            }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n  \
  \          queue.add(arr.get(i));\n        }\n        while (queue.size() > 0) {\n\
  \            list.add(queue.poll());\n        }\n        return list;"
- '        return null;'
- "        ArrayList<Integer> ans = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            pq.add(arr.get(i));\n            if (pq.size() > k) {\n           \
  \     pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n  \
  \          ans.add(pq.poll());\n        }\n        Collections.reverse(ans);\n \
  \       return ans;"
- "        // Define an empty priority queue of integers.\n        PriorityQueue<Integer>\
  \ queue = new PriorityQueue<Integer>();\n        // For each integer in the array,\
  \ add it to the priority queue.\n        for (int num : arr) {\n            queue.add(num);\n\
  \        }\n        // Define an empty array list to store the result.\n       \
  \ ArrayList<Integer> result = new ArrayList<Integer>();\n        // For each integer\
  \ in the priority queue, remove it and add it to the result.\n        for (int i\
  \ = 0; i < k; i++) {\n            result.add(queue.remove());\n        }\n     \
  \   // Return the result.\n        return result;"
- "        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(arr.size(), (a, b)\
  \ -> b - a);\n        for (int i = 0; i < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n\
  \        }\n        ArrayList<Integer> maxValues = new ArrayList<>();\n        for\
  \ (int i = 0; i < k; i++) {\n            maxValues.add(maxHeap.poll());\n      \
  \  }\n        return maxValues;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ maxHeap = new PriorityQueue<>(k, Collections.reverseOrder());\n        int cnt\
  \ = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (cnt < k)\
  \ {\n                maxHeap.add(arr.get(i));\n                cnt++;\n        \
  \    } else {\n                if (arr.get(i) > maxHeap.peek()) {\n            \
  \        maxHeap.poll();\n                    maxHeap.add(arr.get(i));\n       \
  \         }\n            }\n        }\n        while (!maxHeap.isEmpty()) {\n  \
  \          result.add(maxHeap.poll());\n        }\n        return result;"
- "        int n = arr.size();\n        // We need a heap that gives us the maximum\
  \ element\n        // by using an \"inverse\" comparator.\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k,\n                                         \
  \                      Collections.reverseOrder());\n        // Process the first\
  \ k elements by adding them to the heap.\n        for (int i = 0; i < k; i++) {\n\
  \            pq.add(arr.get(i));\n        }\n        // Iterate through the rest\
  \ of the array, adding elements to the heap\n        // and removing the heap's\
  \ minimum element.\n        for (int i = k; i < n; i++) {\n            int x = arr.get(i);\n\
  \            int y = pq.peek();\n            if (x > y) {\n                pq.remove();\n\
  \                pq.add(x);\n            }\n        }\n        // Collect all of\
  \ the elements in the heap and return them as a list.\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        while (!pq.isEmpty()) {\n        \
  \    result.add(pq.remove());\n        }\n        Collections.reverse(result);\n\
  \        return result;"
- "        // Implement the solution here...\n        return new ArrayList<Integer>();"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ == k) {\n            return arr;\n        }\n        // PriorityQueue<Integer>\
  \ minHeap = new PriorityQueue<>();\n        PriorityQueue<Integer> minHeap = new\
  \ PriorityQueue<>(k, new Comparator<Integer>() {\n            @Override\n      \
  \      public int compare(Integer o1, Integer o2) {\n                return o1 -\
  \ o2;\n            }\n        });\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            if (minHeap.size() < k) {\n                minHeap.add(arr.get(i));\n\
  \            } else {\n                if (minHeap.peek() < arr.get(i)) {\n    \
  \                minHeap.poll();\n                    minHeap.add(arr.get(i));\n\
  \                }\n            }\n        }\n        while (!minHeap.isEmpty())\
  \ {\n            result.add(minHeap.poll());\n        }\n        return result;"
- "        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>()\
  \ {\n            public int compare(Integer e1, Integer e2) {\n                return\
  \ e2 - e1;\n            }\n        });\n        ArrayList<Integer> result = new\
  \ ArrayList<Integer>();\n        int i = 0;\n        while (i < arr.size()) {\n\
  \            queue.add(arr.get(i));\n            if (queue.size() > k) {\n     \
  \           queue.poll();\n            }\n            i++;\n        }\n        Iterator<Integer>\
  \ it = queue.iterator();\n        while (it.hasNext()) {\n            result.add(it.next());\n\
  \        }\n        Collections.sort(result);\n        return result;"
- "        final Comparator<Integer> comp = (a, b) -> b - a;\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>(comp);\n        ArrayList<Integer> res = new ArrayList<>();\n\
  \        int i = 0;\n        while (i < arr.size()) {\n            pq.add(arr.get(i));\n\
  \            if (pq.size() > k) {\n                pq.poll();\n            }\n \
  \           i++;\n        }\n        for (int j = 0; j < k; j++) {\n           \
  \ res.add(pq.poll());\n        }\n        return res;"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ temp = new ArrayList<Integer>();\n        for (int i=0; i<arr.size(); i++) {\n\
  \            temp.add(arr.get(i));\n        }\n        Collections.sort(temp);\n\
  \        for (int i=0; i<k; i++) {\n            ans.add(temp.get(temp.size()-1-i));\n\
  \        }\n        return ans;"
- "        if (arr.size() == k) {\n            return arr;\n        }\n        if\
  \ (arr.size() < k) {\n            throw new IllegalArgumentException();\n      \
  \  }\n        int max;\n        int length = arr.size();\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n         \
  \   max = arr.get(0);\n            for (int j = 1; j < length; j++) {\n        \
  \        if (arr.get(j) > max) {\n                    max = arr.get(j);\n      \
  \          }\n            }\n            result.add(max);\n            arr.remove(Integer.valueOf(max));\n\
  \            length--;\n        }\n        return result;"
- "        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = 0; i\
  \ < k; i++) {\n            ans.add(arr.get(i));\n        }\n        for (int i =\
  \ k; i < arr.size(); i++) {\n            for (int j = 0; j < k; j++) {\n       \
  \         if (arr.get(i) > ans.get(j)) {\n                    ans.set(j, arr.get(i));\n\
  \                    break;\n                }\n            }\n        }\n     \
  \   Collections.sort(ans);\n        return ans;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        int len = arr.size();\n\
  \        // the queue is to store the index of the items\n        // the queue is\
  \ in descending order of values\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\n\
  \        // add the first k items\n        for (int i = 0; i < k; i++) queue.add(i);\n\
  \        // check if the other items have greater values\n        for (int i = k;\
  \ i < len; i++) {\n            int lastItem = queue.peek();\n            if (arr.get(i)\
  \ > arr.get(lastItem)) {\n                queue.remove();\n                queue.add(i);\n\
  \            }\n        }\n        // create the resulting array\n        for (int\
  \ i = 0; i < k; i++) {\n            res.add(arr.get(queue.remove()));\n        }\n\
  \        return res;"
- "        // The idea is to keep the k largest elements that we have seen. We can\
  \ do this by\n        // using a max heap of size k.\n        // Time Complexity:\
  \ O(N log k), where N is the length of arr.\n        // Space Complexity: O(k)\n\
  \        ArrayList<Integer> retval = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n           \
  \ public int compare(Integer a, Integer b) {\n                return b.compareTo(a);\n\
  \            }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n  \
  \          heap.add(arr.get(i));\n            if (heap.size() > k) {\n         \
  \       heap.poll();\n            }\n        }\n        Iterator<Integer> it = heap.iterator();\n\
  \        while (it.hasNext()) {\n            retval.add(it.next());\n        }\n\
  \        return retval;"
- "        // Time complexity: O(n log(n)), space complexity: O(1)\n        arr.sort(Collections.reverseOrder());\n\
  \        ArrayList<Integer> output = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            output.add(arr.get(i));\n        }\n       \
  \ return output;"
- "        var heap = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (heap.size() < k)\
  \ {\n                heap.add(arr.get(i));\n            } else {\n             \
  \   if (heap.peek() < arr.get(i)) {\n                    heap.poll();\n        \
  \            heap.add(arr.get(i));\n                }\n            }\n        }\n\
  \        var result = new ArrayList<Integer>();\n        while (heap.size() > 0)\
  \ {\n            result.add(heap.poll());\n        }\n        return result;"
- "        // return bruteForce(arr, k);\n        // return heap(arr, k);\n      \
  \  return heapOpt(arr, k);"
- "        ArrayList<Integer> result = new ArrayList<>();\n        ArrayList<Integer>\
  \ temp = new ArrayList<>();\n        for (int i = 0; i < arr.size(); i++) {\n  \
  \          for (int j = 0; j < result.size(); j++) {\n                if (arr.get(i)\
  \ > result.get(j)) {\n                    temp.add(arr.get(i));\n              \
  \      break;\n                }\n            }\n        }\n        return result;"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        if (arr.size()\
  \ < k) {\n            return arr;\n        }\n        LinkedList<Integer> q = new\
  \ LinkedList<Integer>();\n        for (int i = 0; i < arr.size(); i++) {\n     \
  \       if (q.size() == k) {\n                if (arr.get(i) > q.peekFirst()) {\n\
  \                    q.pollFirst();\n                    q.addLast(arr.get(i));\n\
  \                }\n            } else {\n                q.addLast(arr.get(i));\n\
  \            }\n        }\n        ans.addAll(q);\n        return ans;"
- "        // For each element in arr, iterate through all other elements to see if\
  \ it\n        // is greater than the other.\n        // If so, add it to an arraylist\
  \ of newElements.\n        // repeat until the size of the newElements is <= k.\n\
  \        ArrayList<Integer> newElements = new ArrayList<Integer>();\n        //\
  \ Set a new ArrayList to store the new elements.\n        // If the array is empty,\
  \ return an empty arraylist.\n        if (arr.size() == 0) {\n            return\
  \ newElements;\n        }\n        // Handle the case where k is greater than the\
  \ length of the array.\n        // Just return a sorted array.\n        if (k >\
  \ arr.size()) {\n            Collections.sort(arr);\n            return arr;\n \
  \       }\n        for (int i = 0; i < arr.size(); i++) {\n            int element\
  \ = arr.get(i);\n            for (int j = 0; j < arr.size(); j++) {\n          \
  \      // We only want to add elements of size < k.\n                if (newElements.size()\
  \ < k) {\n                    if (element > arr.get(j)) {\n                    \
  \    newElements.add(element);\n                    }\n                }\n     \
  \       }\n        }\n        Collections.sort(newElements);\n        return newElements;"
- "        // Create a min heap. The heap will be used to find the minimum\n     \
  \   // of the k numbers in the array.\n        PriorityQueue<Integer> heap = new\
  \ PriorityQueue<Integer>();\n        // Add the first k elements of the array to\
  \ the heap.\n        for (int i = 0; i < k; i++)\n            heap.add(arr.get(i));\n\
  \        // Now go through the rest of the array, and compare each item\n      \
  \  // to the smallest element in the heap. If the item is larger,\n        // remove\
  \ the smallest element from the heap and add the new\n        // element.\n    \
  \    for (int i = k; i < arr.size(); i++) {\n            int item = arr.get(i);\n\
  \            if (item > heap.peek()) {\n                heap.poll();\n         \
  \       heap.add(item);\n            }\n        }\n        // We now have the k\
  \ largest elements in the heap.\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
  \        while (heap.size() > 0)\n            result.add(heap.poll());\n       \
  \ // Reverse the list as it is in ascending order.\n        Collections.reverse(result);\n\
  \        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            int curMax = Integer.MIN_VALUE;\n          \
  \  int j = -1;\n            for (int x = 0; x < arr.size(); x++) {\n           \
  \     if (arr.get(x) > curMax) {\n                    curMax = arr.get(x);\n   \
  \                 j = x;\n                }\n            }\n            result.add(curMax);\n\
  \            arr.remove(j);\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            result.add(arr.get(i));\n        }\n       \
  \ for (int i = k; i < arr.size(); i++) {\n            int max = Integer.MIN_VALUE;\n\
  \            int maxIndex = -1;\n            for (int j = 0; j < k; j++) {\n   \
  \             if (result.get(j) > max) {\n                    max = result.get(j);\n\
  \                    maxIndex = j;\n                }\n            }\n         \
  \   if (arr.get(i) > max) {\n                result.set(maxIndex, arr.get(i));\n\
  \            }\n        }\n        return result;"
- "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        int n = arr.size();\n\
  \        int[] tmp = new int[n];\n        for (int i = 0; i < n; i++) {\n      \
  \      tmp[i] = arr.get(i);\n        }\n        Arrays.sort(tmp);\n        for (int\
  \ i = 0; i < k; i++) {\n            ans.add(tmp[n - i - 1]);\n        }\n      \
  \  return ans;"
- "        // Make a priority queue that stores integers\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        // add the first k elements in arr to the\
  \ priority queue\n        for (int i = 0; i < k; i++) {\n            pq.add(arr.get(i));\n\
  \        }\n        // For every element in arr from k to the end, if the element\
  \ is larger than the\n        // smallest element in the priority queue, then we\
  \ remove the smallest element \n        // and add the larger element.\n       \
  \ for (int i = k; i < arr.size(); i++) {\n            if (arr.get(i) > pq.peek())\
  \ {\n                pq.remove();\n                pq.add(arr.get(i));\n       \
  \     }\n        }\n        // Make a new array list. Iterate through the priority\
  \ queue in reverse order, \n        // and add the values to the array list.\n \
  \       ArrayList<Integer> result = new ArrayList<>();\n        while (!pq.isEmpty())\
  \ {\n            result.add(pq.remove());\n        }\n        // Return the array\
  \ list in reverse order.\n        Collections.reverse(result);\n        return result;"
- "        // Assume that k is less than or equal to the length of arr.\n        //\
  \ Use a max heap to store the k maximum elements that are \n        // found as\
  \ you iterate through the array, arr. After you have filled\n        // the max\
  \ heap, remove the top element if the next element in the array,\n        // arr,\
  \ is greater than the top element of the max heap.\n        // Complexity: O(n*log(k))\
  \ - O(k) for creating the heap and O(n*log(k)) for removing \n        // the top\
  \ element.\n        ArrayList<Integer> result = new ArrayList<Integer>();\n    \
  \    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\n\
  \        // Fill the heap with the k maximum elements.\n        for (int i = 0;\
  \ i < k; i++) {\n            maxHeap.add(arr.get(i));\n        }\n        // Remove\
  \ the top element if the next element in the array, arr, is greater.\n        for\
  \ (int i = k; i < arr.size(); i++) {\n            if (arr.get(i) > maxHeap.peek())\
  \ {\n                maxHeap.poll();\n                maxHeap.add(arr.get(i));\n\
  \            }\n        }\n        // Add all of the elements from the max heap\
  \ to the result.\n        while (maxHeap.size() > 0) {\n            result.add(maxHeap.poll());\n\
  \        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ < k) return result;\n        if (arr.size() == k) return arr;\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n            public\
  \ int compare(Integer i1, Integer i2) {\n                return i2.compareTo(i1);\n\
  \            }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n  \
  \          if (pq.size() < k) {\n                pq.add(arr.get(i));\n         \
  \   } else {\n                if (pq.peek() > arr.get(i)) {\n                  \
  \  pq.poll();\n                    pq.add(arr.get(i));\n                }\n    \
  \        }\n        }\n        while (!pq.isEmpty()) {\n            result.add(pq.poll());\n\
  \        }\n        return result;"
- "        assert k > 0 && k <= arr.size();\n        ArrayList<Integer> result = new\
  \ ArrayList<>();\n        // Build a max heap. Note that the Java API is a min heap.\n\
  \        PriorityQueue<Integer> queue = new PriorityQueue<>(arr.size(),\n      \
  \      new Comparator<Integer>() {\n                @Override\n                public\
  \ int compare(Integer x, Integer y) {\n                    return y - x;\n     \
  \           }\n            });\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            if (i < k) {\n                queue.add(arr.get(i));\n            }\
  \ else {\n                if (arr.get(i) > queue.peek()) {\n                   \
  \ queue.remove();\n                    queue.add(arr.get(i));\n                }\n\
  \            }\n        }\n        while (!queue.isEmpty()) {\n            result.add(queue.remove());\n\
  \        }\n        return result;"
- "        ArrayList<Integer> q = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ r = new ArrayList<Integer>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            if (q.size() < k) {\n                q.add(arr.get(i));\n         \
  \   } else {\n                int min = q.get(0);\n                int min_index\
  \ = 0;\n                for (int j = 1; j < q.size(); j++) {\n                 \
  \   if (q.get(j) < min) {\n                        min = q.get(j);\n           \
  \             min_index = j;\n                    }\n                }\n       \
  \         if (arr.get(i) > min) {\n                    q.remove(min_index);\n  \
  \                  q.add(arr.get(i));\n                }\n            }\n      \
  \  }\n        for (int i = 0; i < q.size(); i++) {\n            r.add(q.get(i));\n\
  \        }\n        return r;"
- "        assert arr.size() >= k;\n        if (k == 0) {\n            return new\
  \ ArrayList<Integer>();\n        }\n        int offset = arr.size() - k;\n     \
  \   // Create a min heap to track the largest k elements.\n        PriorityQueue<Integer>\
  \ minHeap = new PriorityQueue<Integer>(k);\n        for (int i = 0; i < arr.size();\
  \ i++) {\n            if (i < offset) {\n                minHeap.add(arr.get(i));\n\
  \            } else {\n                if (arr.get(i) > minHeap.peek()) {\n    \
  \                minHeap.poll();\n                    minHeap.add(arr.get(i));\n\
  \                }\n            }\n        }\n        return new ArrayList<Integer>(minHeap);"
- "        // Algorithm: (1) Max Heapify, (2) Extract-Max, (3) Max-Heapify-Down\n\
  \        int N = arr.size();\n        ArrayList<Integer> heap = new ArrayList<Integer>();\n\
  \        ArrayList<Integer> ans = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < k; i++) heap.add(arr.get(i));\n        for (int i = 0; i < k; i++) {\n\
  \            int pos = (k - 1) / 2;\n            for (int j = pos; j >= 0; j--)\
  \ \n                heap = maxHeapifyDown(heap, j, k);\n        }\n        for (int\
  \ i = k; i < N; i++) {\n            if (arr.get(i) > heap.get(0)) {\n          \
  \      heap.set(0, arr.get(i));\n                heap = maxHeapifyDown(heap, 0,\
  \ k);\n            }\n        }\n        for (int i = 0; i < k; i++) ans.add(heap.get(i));\n\
  \        return ans;"
- "        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (queue.size() <\
  \ k) queue.add(arr.get(i));\n            else {\n                if (queue.peek()\
  \ < arr.get(i)) {\n                    queue.poll();\n                    queue.add(arr.get(i));\n\
  \                }\n            }\n        }\n        return new ArrayList<>(queue);"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ q = new PriorityQueue<Integer>(k, (a, b) -> {\n            return b - a;\n   \
  \     });\n        for (int i = 0; i < arr.size(); i++) {\n            q.add(arr.get(i));\n\
  \        }\n        for (int i = 0; i < k; i++) {\n            result.add(q.poll());\n\
  \        }\n        return result;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(k, Collections.reverseOrder());\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (pq.size() < k)\
  \ {\n                pq.add(arr.get(i));\n            } else {\n               \
  \ if (pq.peek() < arr.get(i)) {\n                    pq.poll();\n              \
  \      pq.add(arr.get(i));\n                }\n            }\n        }\n      \
  \  ArrayList<Integer> ans = new ArrayList<>(pq);\n        return ans;"
- "        // approach 1: use a max heap (priority queue)\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n            @Override\n\
  \            public int compare(Integer n1, Integer n2) {\n                return\
  \ -1 * n1.compareTo(n2);\n            }\n        });\n        for (int i = 0; i\
  \ < arr.size(); i++) {\n            if (pq.size() < k) {\n                pq.add(arr.get(i));\n\
  \            } else {\n                if (pq.peek() < arr.get(i)) {\n         \
  \           pq.poll();\n                    pq.add(arr.get(i));\n              \
  \  }\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n\
  \        while (!pq.isEmpty()) ans.add(pq.poll());\n        return ans;"
- "        ArrayList<Integer> list = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < k; i++) {\n            int max = Integer.MIN_VALUE;\n            int\
  \ index = -1;\n            for (int j = 0; j < arr.size(); j++) {\n            \
  \    if (arr.get(j) > max) {\n                    max = arr.get(j);\n          \
  \          index = j;\n                }\n            }\n            list.add(max);\n\
  \            arr.remove(index);\n        }\n        return list;"
- "        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(arr.size(), (a,\
  \ b) -> b - a);\n        for (int i = 0; i < arr.size(); i++) {\n            queue.add(arr.get(i));\n\
  \        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n    \
  \    for (int i = 0; i < k; i++) {\n            result.add(queue.poll());\n    \
  \    }\n        return result;"
- "        // We could use an array with k elements and use insertion sort to\n  \
  \      // insert each number from arr.\n        // Or we could use a heap with k\
  \ elements.\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k);\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (pq.size() == k)\
  \ {\n                if (arr.get(i) > pq.peek()) {\n                    pq.poll();\n\
  \                    pq.add(arr.get(i));\n                }\n            } else\
  \ {\n                pq.add(arr.get(i));\n            }\n        }\n        return\
  \ new ArrayList<Integer>(pq);"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) return result;\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(arr.size(),\
  \ Collections.reverseOrder());\n        queue.addAll(arr);\n        while (k-- >\
  \ 0) {\n            result.add(queue.poll());\n        }\n        return result;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return res;\n        }\n        if (arr.size() == 1) {\n\
  \            res.add(arr.get(0));\n            return res;\n        }\n        if\
  \ (arr.size() == k) {\n            return arr;\n        }\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n            public\
  \ int compare(Integer a, Integer b) {\n                return -Integer.compare(a,\
  \ b);\n            }\n        });\n        for (int i = 0; i < arr.size(); i++)\
  \ {\n            pq.add(arr.get(i));\n        }\n        for (int i = 0; i < k;\
  \ i++) {\n            res.add(pq.poll());\n        }\n        return res;"
- "        if (arr.size() == k) {\n            return arr;\n        }\n        //\
  \ The list will be in descending order\n        ArrayList<Integer> maxList = new\
  \ ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n            int\
  \ biggest = Integer.MIN_VALUE;\n            for (int j = 0; j < arr.size(); j++)\
  \ {\n                int element = arr.get(j);\n                if (element > biggest)\
  \ {\n                    biggest = element;\n                }\n            }\n\
  \            maxList.add(biggest);\n            arr.remove(arr.indexOf(biggest));\n\
  \        }\n        return maxList;"
- "        ArrayList<Integer> heap = new ArrayList<>();\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        // initialize the heap\n        for (int\
  \ i = 0; i < k; i++) {\n            heap.add(arr.get(i));\n        }\n        Heap.buildMinHeap(heap);\n\
  \        // iterate through the rest of the array\n        for (int i = k; i < arr.size();\
  \ i++) {\n            // replace the root if the element is greater than the root\n\
  \            if (arr.get(i) > heap.get(0)) {\n                Heap.replace(heap,\
  \ arr.get(i));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n\
  \            result.add(Heap.extractRoot(heap));\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        Collections.sort(arr);\n\
  \        for (int i = arr.size() - 1; i >= 0 && k > 0; i--) {\n            result.add(arr.get(i));\n\
  \            k--;\n        }\n        return result;"
- '        return new ArrayList<Integer>();'
- "        // Use a binary search tree to insert and delete the smallest element\n\
  \        TreeSet<Integer> tree = new TreeSet<>();\n        for (int x : arr) {\n\
  \            tree.add(x);\n            if (tree.size() > k) {\n                tree.remove(tree.first());\n\
  \            }\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        for (int x : tree) {\n            result.add(x);\n        }\n        return\
  \ result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        // TODO:\
  \ your code here\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            Integer max = Collections.max(arr);\n      \
  \      result.add(max);\n            arr.remove(max);\n        }\n        return\
  \ result;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        // assume arr is\
  \ sorted\n        for (int i = 0; i < k; i++) {\n            result.add(arr.get(i));\n\
  \        }\n        return result;"
- "        ArrayList<Integer> ret = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(k, Collections.reverseOrder());\n        for (int\
  \ num : arr) {\n            pq.add(num);\n            if (pq.size() > k) {\n   \
  \             pq.poll();\n            }\n        }\n        for (int i = 0; i <\
  \ k; i++) {\n            ret.add(pq.poll());\n        }\n        return ret;"
- "        // Build an array of k empty buckets\n        ArrayList<ArrayList<Integer>>\
  \ bucket = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n         \
  \   bucket.add(new ArrayList<>());\n        }\n        // Go through each element\
  \ of arr and hash it by modulus \n        // with respect to k and then append it\
  \ to the bucket list\n        for (int i = 0; i < arr.size(); i++) {\n         \
  \   bucket.get(arr.get(i) % k).add(arr.get(i));\n        }\n        // Sort each\
  \ of the buckets in the bucket list and then\n        // concatenate the result\
  \ of all of them\n        for (int i = 0; i < k; i++) {\n            bucket.set(i,\
  \ sort(bucket.get(i)));\n        }\n        ArrayList<Integer> res = new ArrayList<>();\n\
  \        for (int i = 0; i < k; i++) {\n            res.addAll(bucket.get(i));\n\
  \        }\n        // Return the first k elements of the concatenated bucket list\n\
  \        return new ArrayList<>(res.subList(0, k));"
- "        ArrayList<Integer> max = new ArrayList<>();\n        if (arr.size() ==\
  \ 0) return max;\n        for (int i = 0; i < k; i++) max.add(arr.get(i));\n   \
  \     max.sort(Comparator.naturalOrder());\n        for (int i = k; i < arr.size();\
  \ i++) {\n            int elem = arr.get(i);\n            if (elem < max.get(0))\
  \ continue;\n            max.set(0, elem);\n            max.sort(Comparator.naturalOrder());\n\
  \        }\n        return max;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        for (int i = 0; i\
  \ < k; i++) {\n            int mx = Integer.MIN_VALUE;\n            int mxI = -1;\n\
  \            for (int j = 0; j < arr.size(); j++) {\n                if (arr.get(j)\
  \ > mx) {\n                    mx = arr.get(j);\n                    mxI = j;\n\
  \                }\n            }\n            res.add(mx);\n            arr.remove(mxI);\n\
  \        }\n        return res;"
- "        // With an arraylist, add the first k elements.\n        // Sort the arraylist.\n\
  \        // for each element in the array, compare it to the last element of the\n\
  \        // arraylist, and replace it if the element is greater.\n        // The\
  \ arraylist is now sorted, so the last k elements are the greatest\n        // k\
  \ elements in the array.\n        ArrayList<Integer> result = new ArrayList<>();\n\
  \        if (arr.size() == 0) {\n            return result;\n        }\n       \
  \ for (int i = 0; i < k; i++) {\n            result.add(arr.get(i));\n        }\n\
  \        Collections.sort(result);\n        for (int i = k; i < arr.size(); i++)\
  \ {\n            int end = result.size() - 1;\n            if (arr.get(i) > result.get(end))\
  \ {\n                result.remove(end);\n                result.add(arr.get(i));\n\
  \                Collections.sort(result);\n            }\n        }\n        return\
  \ result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            int max = Integer.MIN_VALUE;\n            int\
  \ maxIndex = -1;\n            for (int j = 0; j < arr.size(); j++) {\n         \
  \       if (arr.get(j) > max) {\n                    max = arr.get(j);\n       \
  \             maxIndex = j;\n                }\n            }\n            if (maxIndex\
  \ != -1) {\n                result.add(max);\n                arr.remove(maxIndex);\n\
  \            }\n        }\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        // use a\
  \ heap of size k\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k);\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (pq.size() < k)\
  \ {\n                pq.add(arr.get(i));\n            } else {\n               \
  \ if (pq.peek() < arr.get(i)) {\n                    pq.poll();\n              \
  \      pq.add(arr.get(i));\n                }\n            }\n        }\n      \
  \  result.addAll(pq);\n        Collections.sort(result, Collections.reverseOrder());\n\
  \        return result;"
- "        // Use a min heap of size k to store the k largest elements\n        ArrayList<Integer>\
  \ max = new ArrayList<>();\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            if (heap.size() ==\
  \ k) {\n                int min = heap.peek();\n                if (arr.get(i) >\
  \ min) {\n                    heap.poll();\n                    heap.add(arr.get(i));\n\
  \                }\n            } else {\n                heap.add(arr.get(i));\n\
  \            }\n        }\n        while (!heap.isEmpty()) {\n            max.add(heap.poll());\n\
  \        }\n        return max;"
- "        ArrayList<Integer> list = new ArrayList<>();\n        ArrayList<Integer>\
  \ result = new ArrayList<>();\n        int len = arr.size();\n        int i = 0;\n\
  \        int index = 0;\n        while (i < k) {\n            index = maximumIndex(arr,\
  \ 0, len - 1);\n            list.add(arr.get(index));\n            arr.remove(index);\n\
  \            i++;\n        }\n        return list;"
- "        // Solution:\n        // Time Complexity: O(n*log(n))\n        // Space\
  \ Complexity: O(1)\n        // Sort the array.\n        // Return the first k elements.\n\
  \        Collections.sort(arr);\n        Collections.reverse(arr);\n        return\
  \ new ArrayList<Integer>(arr.subList(0, k));"
- "        ArrayList<Integer> maxArray = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ maxHeap = new PriorityQueue<>(k, Collections.reverseOrder());\n        for (int\
  \ i = 0; i < arr.size(); i++) {\n            maxHeap.add(arr.get(i));\n        \
  \    if (maxHeap.size() > k) {\n                maxHeap.poll();\n            }\n\
  \        }\n        maxArray.addAll(maxHeap);\n        return maxArray;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
  \ i = 0; i < k; i++) {\n            int max = Collections.max(arr);\n          \
  \  result.add(max);\n            arr.remove(new Integer(max));\n        }\n    \
  \    return result;"
- '        return null;'
- "        ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 0;\
  \ i < k; i++) {\n            result.add(arr.get(i));\n        }\n        for (int\
  \ i = k; i < arr.size(); i++) {\n            int minIndex = -1;\n            int\
  \ min = Integer.MAX_VALUE;\n            for (int j = 0; j < k; j++) {\n        \
  \        if (result.get(j) < min) {\n                    min = result.get(j);\n\
  \                    minIndex = j;\n                }\n            }\n         \
  \   if (arr.get(i) > min) {\n                result.set(minIndex, arr.get(i));\n\
  \            }\n        }\n        return result;"
- "        int n = arr.size();\n        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k,\
  \ new Comparator<Integer>() {\n            public int compare(Integer a, Integer\
  \ b) {\n                return -a.compareTo(b);\n            }\n        });\n  \
  \      for (int i = 0; i < n; i++) {\n            heap.add(arr.get(i));\n      \
  \      if (heap.size() > k) heap.poll();\n        }\n        ArrayList<Integer>\
  \ ret = new ArrayList<Integer>();\n        while (!heap.isEmpty()) ret.add(heap.poll());\n\
  \        return ret;"
- "        // Return a sorted list of length k with the maximum k numbers in arr.\n\
  \        // There will be k maximum numbers in arr, not necessarily distinct.\n\
  \        // Therefore, the maximum k numbers in arr will be the k last numbers in\
  \ the sorted array.\n        // Method:\n        // Sort the array in descending\
  \ order.\n        // Return the sublist arr.subList(arr.size() - k, arr.size()).\n\
  \        // Time complexity is O(n log n) due to sorting.\n        // Space complexity\
  \ is O(n) due to the array size.\n        Collections.sort(arr, Collections.reverseOrder());\n\
  \        return new ArrayList<Integer>(arr.subList(arr.size() - k, arr.size()));"
- "        // Skip the elements which are smaller than the last element of the list.\n\
  \        // This reduces the time complexity.\n        while (arr.size() > k &&\
  \ arr.get(k - 1) < arr.get(k))\n            arr.remove(k);\n        int n = arr.size();\n\
  \        // Sort the remaining n - k elements.\n        for (int i = 0; i < n -\
  \ k; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j <\
  \ n - k + 1; j++)\n                if (arr.get(j) < arr.get(minIndex))\n       \
  \             minIndex = j;\n            int temp = arr.get(i);\n            arr.set(i,\
  \ arr.get(minIndex));\n            arr.set(minIndex, temp);\n        }\n       \
  \ // Remove elements from the end of the list.\n        for (int i = 0; i < n -\
  \ k; i++)\n            arr.remove(arr.size() - 1);\n        return arr;"
- "        ArrayList<Integer> result = new ArrayList<Integer>();\n        PriorityQueue<Integer>\
  \ q = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public\
  \ int compare(Integer a, Integer b) {\n                return b - a;\n         \
  \   }\n        });\n        for (int i : arr) q.add(i);\n        for (int i = 0;\
  \ i < k; i++) result.add(q.poll());\n        return result;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        Collections.sort(arr);\n\
  \        for (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n            result.add(arr.get(i));\n\
  \        }\n        return result;"
- "        // Given a list of numbers and a positive integer k, return the k numbers\
  \ with the \n        // largest values.\n        assert k <= arr.size();\n     \
  \   // Convert list to a heap in O(N) time complexity.\n        PriorityQueue<Integer>\
  \ heap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {\n           \
  \ @Override\n            public int compare(Integer x, Integer y) {\n          \
  \      return y - x;\n            }\n        });\n        heap.addAll(arr);\n  \
  \      // Remove the smallest k-1 values from the heap in O(log N) time complexity.\n\
  \        for (int i = 0; i < k - 1; i++)\n            heap.poll();\n        // Sort\
  \ the remaining k numbers in O(k log k) time complexity.\n        ArrayList<Integer>\
  \ max = new ArrayList<Integer>(heap);\n        Collections.sort(max);\n        return\
  \ max;"
- "        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n\
  \        for (int n : arr) {\n            pq.add(n);\n        }\n        int len\
  \ = pq.size();\n        ArrayList<Integer> ret = new ArrayList<>(len);\n       \
  \ for (int i = 0; i < k; i++) {\n            ret.add(pq.poll());\n        }\n  \
  \      return ret;"
- "        // Your code here.\n        return new ArrayList<Integer>();"
- "        int max = Integer.MIN_VALUE;\n        HashMap<Integer, Integer> map = new\
  \ HashMap<>();\n        for (int i = 0; i < arr.size(); i++) {\n            int\
  \ v = arr.get(i);\n            map.put(v, map.getOrDefault(v, 0) + 1);\n       \
  \     max = Math.max(max, v);\n        }\n        ArrayList<Integer> res = new ArrayList<>();\n\
  \        for (int i = 0; i < k; i++) {\n            int v = max;\n            res.add(v);\n\
  \            int c = map.get(v);\n            if (c == 1) map.remove(v);\n     \
  \       else map.put(v, c - 1);\n            int idx = v - 1;\n            while\
  \ (map.containsKey(idx)) {\n                max = idx;\n                idx--;\n\
  \            }\n        }\n        return res;"
- "        ArrayList<Integer> output = new ArrayList<Integer>();\n        if (arr.size()\
  \ == 0) {\n            return output;\n        }\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public\
  \ int compare(Integer x, Integer y) {\n                return y - x;\n         \
  \   }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n           \
  \ pq.add(arr.get(i));\n        }\n        for (int i = 0; i < k; i++) {\n      \
  \      output.add(pq.poll());\n        }\n        return output;"
- "        ArrayList<Integer> result = new ArrayList<>();\n        return result;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (arr.size()\
  \ < k) return res;\n        if (arr.size() == k) return arr;\n        int maxIdx\
  \ = 0;\n        int max = arr.get(0);\n        for (int i = 1; i < arr.size(); i++)\
  \ {\n            if (arr.get(i) > max) {\n                max = arr.get(i);\n  \
  \              maxIdx = i;\n            }\n        }\n        if (k > 0) {\n   \
  \         res.add(max);\n            arr.remove(maxIdx);\n            res.addAll(maximum(arr,\
  \ k - 1));\n        }\n        return res;"
- "        if (arr.size() == 0) {\n            return new ArrayList<Integer>();\n\
  \        }\n        if (arr.size() == 1) {\n            ArrayList<Integer> out =\
  \ new ArrayList<Integer>();\n            out.add(arr.get(0));\n            return\
  \ out;\n        }\n        if (arr.size() == k) {\n            return arr;\n   \
  \     }\n        ArrayList<Integer> maxes = new ArrayList<Integer>();\n        for\
  \ (int i = 0; i < k; i++) {\n            maxes.add(arr.get(i));\n        }\n   \
  \     for (int i = k; i < arr.size(); i++) {\n            Integer m = Collections.min(maxes);\n\
  \            if (arr.get(i) > m) {\n                maxes.remove(m);\n         \
  \       maxes.add(arr.get(i));\n            }\n        }\n        Collections.sort(maxes);\n\
  \        Collections.reverse(maxes);\n        return maxes;"
- "        // Find the max and pop it off\n        PriorityQueue<Integer> heap = new\
  \ PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int i = 0; i\
  \ < arr.size(); i++) {\n            heap.add(arr.get(i));\n        }\n        ArrayList<Integer>\
  \ result = new ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n  \
  \          result.add(heap.poll());\n        }\n        return result;"
- "        ArrayList<Integer> ret = new ArrayList<>();\n        if (arr.size() < k)\n\
  \            return ret;\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n\
  \        for (int i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n\
  \            if (pq.size() > k)\n                pq.poll();\n        }\n       \
  \ ret.addAll(pq);\n        return ret;"
- "        ArrayList<Integer> max = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < k; i++) {\n            Integer maximum = null;\n            for (Integer\
  \ j : arr) {\n                if (maximum == null || j > maximum) {\n          \
  \          maximum = j;\n                }\n            }\n            max.add(maximum);\n\
  \            arr.remove(maximum);\n        }\n        return max;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        int i, j;\n\
  \        for (i = 0; i < k; i++) {\n            int idx = i;\n            for (j\
  \ = i + 1; j < arr.size(); j++) {\n                if (arr.get(j) > arr.get(idx))\
  \ {\n                    idx = j;\n                }\n            }\n          \
  \  int tmp = arr.get(i);\n            arr.set(i, arr.get(idx));\n            arr.set(idx,\
  \ tmp);\n            res.add(arr.get(i));\n        }\n        return res;"
- "        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i =\
  \ 0; i < arr.size(); i++) {\n            map.put(arr.get(i), i);\n        }\n  \
  \      Integer[] arr2 = new Integer[k];\n        int i = 0;\n        for (Map.Entry<Integer,\
  \ Integer> entry : map.entrySet()) {\n            if (i == k) {\n              \
  \  break;\n            }\n            arr2[i] = entry.getKey();\n            i++;\n\
  \        }\n        ArrayList<Integer> arr3 = new ArrayList<>(Arrays.asList(arr2));\n\
  \        Collections.reverse(arr3);\n        return arr3;"
- "        ArrayList<Integer> ans = new ArrayList<>();\n        Iterator<Integer>\
  \ it = arr.iterator();\n        while (k > 0) {\n            Integer max = Integer.MIN_VALUE;\n\
  \            while (it.hasNext()) {\n                Integer i = it.next();\n  \
  \              if (i > max) {\n                    max = i;\n                }\n\
  \            }\n            ans.add(max);\n            it = arr.iterator();\n  \
  \          k--;\n        }\n        return ans;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        for (int i\
  \ = 0; i < k; i++) {\n            Integer max = new Integer(Integer.MIN_VALUE);\n\
  \            for (int j = 0; j < arr.size(); j++) {\n                if (arr.get(j)\
  \ > max) {\n                    max = arr.get(j);\n                }\n         \
  \   }\n            res.add(max);\n            arr.remove(max);\n        }\n    \
  \    return res;"
- "        // Insert your solution below\n        return null;"
- "        // find min\n        int min = arr.get(0);\n        for (int i = 1; i <\
  \ arr.size(); i++) {\n            if (arr.get(i) < min) {\n                min =\
  \ arr.get(i);\n            }\n        }\n        // subtract\n        for (int i\
  \ = 0; i < arr.size(); i++) {\n            arr.set(i, arr.get(i) - min);\n     \
  \   }\n        ArrayList<Integer> res = new ArrayList<>();\n        // find max\n\
  \        for (int i = 0; i < k; i++) {\n            int max = 0;\n            int\
  \ index = 0;\n            for (int j = 0; j < arr.size(); j++) {\n             \
  \   if (arr.get(j) > max) {\n                    max = arr.get(j);\n           \
  \         index = j;\n                }\n            }\n            res.add(max\
  \ + min);\n            arr.set(index, -1);\n        }\n        return res;"
- "        ArrayList<Integer> res = new ArrayList<>();\n        PriorityQueue<Integer>\
  \ pq = new PriorityQueue<>();\n        for (int i = 0; i < arr.size(); i++) {\n\
  \            pq.add(arr.get(i));\n            if (pq.size() > k) {\n           \
  \     pq.poll();\n            }\n        }\n        while (pq.size() > 0) {\n  \
  \          res.add(pq.poll());\n        }\n        return res;"
- "        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = 0; i\
  \ < k; i++) {\n            int idx = 0;\n            for (int j = 1; j < arr.size();\
  \ j++) {\n                if (arr.get(j) > arr.get(idx)) {\n                   \
  \ idx = j;\n                }\n            }\n            ans.add(arr.get(idx));\n\
  \            arr.remove(idx);\n        }\n        return ans;"
- "        ArrayList<Integer> res = new ArrayList<Integer>();\n        int[] arr2\
  \ = new int[arr.size()];\n        for (int i = 0; i < arr.size(); i++) {\n     \
  \       arr2[i] = arr.get(i);\n        }\n        Arrays.sort(arr2);\n        for\
  \ (int i = arr2.length - 1; i >= arr2.length - k; i--) {\n            res.add(arr2[i]);\n\
  \        }\n        return res;"
language: java
name: HumanEval_120_maximum
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Given an array arr of integers and a positive integer k,\
  \ return a sorted list \n    // of length k with the maximum k numbers in arr.\n\
  \    // Example 1:\n    // Input: arr = [-3, -4, 5], k = 3\n    // Output: [-4,\
  \ -3, 5]\n    // Example 2:\n    // Input: arr = [4, -4, 4], k = 2\n    // Output:\
  \ [4, 4]\n    // Example 3:\n    // Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n\
  \    // Output: [2]\n    // Note:\n    // 1. The length of the array will be in\
  \ the range of [1, 1000].\n    // 2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    public static ArrayList<Integer>\
  \ maximum(ArrayList<Integer> arr, int k) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)-3,\
  \ (int)-4, (int)5))), (3)).equals((new ArrayList<Integer>(Arrays.asList((int)-4,\
  \ (int)-3, (int)5)))));\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)4,\
  \ (int)-4, (int)4))), (2)).equals((new ArrayList<Integer>(Arrays.asList((int)4,\
  \ (int)4)))));\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)-3,\
  \ (int)2, (int)1, (int)2, (int)-1, (int)-2, (int)1))), (1)).equals((new ArrayList<Integer>(Arrays.asList((int)2)))));\n\
  \    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)123, (int)-123, (int)20,\
  \ (int)0, (int)1, (int)2, (int)-3))), (3)).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
  \ (int)20, (int)123)))));\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)-123,\
  \ (int)20, (int)0, (int)1, (int)2, (int)-3))), (4)).equals((new ArrayList<Integer>(Arrays.asList((int)0,\
  \ (int)1, (int)2, (int)20)))));\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)5,\
  \ (int)15, (int)0, (int)3, (int)-13, (int)-8, (int)0))), (7)).equals((new ArrayList<Integer>(Arrays.asList((int)-13,\
  \ (int)-8, (int)0, (int)0, (int)3, (int)5, (int)15)))));\n    assert(maximum((new\
  \ ArrayList<Integer>(Arrays.asList((int)-1, (int)0, (int)2, (int)5, (int)3, (int)-10))),\
  \ (2)).equals((new ArrayList<Integer>(Arrays.asList((int)3, (int)5)))));\n    assert(maximum((new\
  \ ArrayList<Integer>(Arrays.asList((int)1, (int)0, (int)5, (int)-7))), (1)).equals((new\
  \ ArrayList<Integer>(Arrays.asList((int)5)))));\n    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)4,\
  \ (int)-4))), (2)).equals((new ArrayList<Integer>(Arrays.asList((int)-4, (int)4)))));\n\
  \    assert(maximum((new ArrayList<Integer>(Arrays.asList((int)-10, (int)10))),\
  \ (2)).equals((new ArrayList<Integer>(Arrays.asList((int)-10, (int)10)))));\n  \
  \  assert(maximum((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
  \ (int)-23, (int)243, (int)-400, (int)0))), (0)).equals((new ArrayList<Integer>(Arrays.asList()))));\n\
  \    }\n\n}\n"
