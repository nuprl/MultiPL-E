language: swift
name: HumanEval_143_words_in_sentence
results:
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ if prime > result.characters.count {\n            result = result + String(prime)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi67cjufb.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpi67cjufb.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpi67cjufb.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpi67cjufb.swift:21:27: error: 'characters'\
    \ is unavailable: Please use String directly\n        if prime > result.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfxgwyug.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpqfxgwyug.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpqfxgwyug.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result: String = \"\
    \"\n    for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n\
    \            result += \" \" + word\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj5vxovyx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for letter in sentence {\n        if primes[primeIndex] == 0 {\n  \
    \          primeIndex++\n        }\n        if primes[primeIndex] == 1 {\n   \
    \         primeIndex++\n        }\n        if letter == \" \" {\n            primeIndex++\n\
    \        }\n        if letter == \",\" {\n            primeIndex++\n        }\n\
    \        if letter == \".\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"?\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"!\" {\n            primeIndex++\n        }\n        if letter == \"-\" {\n\
    \            primeIndex++\n        }\n        if letter == \"_\" {\n         \
    \   primeIndex++\n        }\n        if letter == \":\" {\n            primeIndex++\n\
    \        }\n        if letter == \"\\\"\" {\n            primeIndex++\n      \
    \  }\n        if letter == \"'\" {\n            primeIndex++\n        }\n    \
    \    if letter == \"(\" {\n            primeIndex++\n        }\n        if letter\
    \ == \")\" {\n            primeIndex++\n        }\n        if letter == \"[\"\
    \ {\n            primeIndex++\n        }\n        if letter == \"]\" {\n     \
    \       primeIndex++\n        }\n        if letter == \"{\" {\n            primeIndex++\n\
    \        }\n        if letter == \"}\" {\n            primeIndex++\n        }\n\
    \        if letter == \"%\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"+\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"*\" {\n            primeIndex++\n        }\n        if letter == \"/\" {\n\
    \            primeIndex++\n        }\n        if letter == \"^\" {\n         \
    \   primeIndex++\n        }\n        if letter == \"|\" {\n            primeIndex++\n\
    \        }\n        if letter == \"~\" {\n            primeIndex++\n        }\n\
    \        if letter == \"`\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"!\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"=\" { // \"=\" is also a prime number\n            primeIndex++\n        }\n\
    \        if letter == \"<\" {\n            primeIndex++\n        }\n        if\
    \ letter == \">\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"{\" {\n            primeIndex++\n        }\n        if letter == \"}\" {\n\
    \            primeIndex++\n        }\n        if letter == \"[\" {\n         \
    \   primeIndex++\n        }\n        if letter == \"]\" {\n            primeIndex++\n\
    \        }\n        if letter == \"(\" {\n            primeIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3hmirbz.swift:142:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmpc3hmirbz.swift:16:28: note: to\
    \ match this opening '{'\n    for letter in sentence {\n                     \
    \      ^\n/tmp/tmpc3hmirbz.swift:142:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmpc3hmirbz.swift:12:52: note: to\
    \ match this opening '{'\nfunc words_in_sentence(sentence: String) -> String {\n\
    \                                                   ^\n/tmp/tmpc3hmirbz.swift:18:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmpc3hmirbz.swift:21:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmpc3hmirbz.swift:24:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmpc3hmirbz.swift:27:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            primeIndex++\n                 \
    \     ^~\n/tmp/tmpc3hmirbz.swift:30:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpc3hmirbz.swift:33:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmpc3hmirbz.swift:36:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmpc3hmirbz.swift:39:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmpc3hmirbz.swift:42:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            primeIndex++\n                 \
    \     ^~\n/tmp/tmpc3hmirbz.swift:45:23: error: cannot find operator '++' in scope;\
    \ did you mean '+"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"\"\n    }\n    var result = \"\"\n  \
    \  var primes = [1]\n    for letter in sentence.unicodeScalars {\n        if let\
    \ index = Int(letter) {\n            if primes.contains(index) {\n           \
    \     primes.append(index + 1)\n            }\n        }\n    }\n    for prime\
    \ in primes {\n        if prime > Int(sentence.length) {\n            break\n\
    \        }\n        let index = Int(sentence[Int(sentence.length - prime)])\n\
    \        if index != 0 {\n            result += String(index)\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyzcxkx2m.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyzcxkx2m.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char == \" \" {\n            primeIndex++\n\
    \        }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                result += char\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4l9_1r4a.swift:18:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmp4l9_1r4a.swift:23:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n   \
    \         result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv4hiz0m5.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    let words = sentence.components(separatedBy:\
    \ \" \")\n    var resultString = \"\"\n    \n    for word in words {\n       \
    \ let length = word.characters.count\n        \n        if isPrime(length) ==\
    \ true {\n            resultString += word\n        }\n    }\n    \n    return\
    \ resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpdeg4h4bu.swift:15:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n   \
    \         result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv4hiz0m5.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n  \
    \          newString += \" \" + word\n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpe9kqrg64.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"No words\"\n    }\n    guard let words\
    \ = sentence.components(separatedBy: \" \") else {\n        return \"No words\"\
    \n    }\n    var result = \"\"\n    for word in words {\n        guard let word\
    \ = word.trimmingCharacters(in: .whitespaces) else {\n            continue\n \
    \       }\n        guard let number = Int(word) else {\n            continue\n\
    \        }\n        if number == 1 {\n            result += word\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpx79tobtq.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx79tobtq.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n/tmp/tmpx79tobtq.swift:21:55: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n        guard let word = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence {\n \
    \       if letter == \" \" {\n            result += letter\n        } else {\n\
    \            result += String(letter)\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpmu2opr1n.swift:16:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence {\n        if primes.contains(char.unicodeScalars.count) {\n   \
    \         primes.append(char.unicodeScalars.count)\n        }\n    }\n    for\
    \ prime in primes {\n        if prime > 1 {\n            for char in sentence\
    \ {\n                if char.unicodeScalars.count == prime {\n               \
    \     result += char\n                }\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpd37h88my.swift:24:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                    result += char\n   \
    \                           ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n  \
    \          newString += \" \" + word\n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpe9kqrg64.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    var\
    \ primeCount = 0\n    for letter in sentence {\n        if letter == \" \" {\n\
    \            primes = primes[0..<primeIndex]\n            primeIndex = 0\n   \
    \         primeCount = 0\n        } else {\n            primes[primeIndex] = primes[primeIndex]\
    \ + 1\n            if primes[primeIndex] == 2 {\n                primeIndex +=\
    \ 1\n                primeCount += 1\n            }\n        }\n    }\n    for\
    \ prime in primes {\n        if prime > 1 {\n            if primeCount > 1 {\n\
    \                result += String(prime)\n                result += \" \"\n  \
    \              primeCount -= 1\n            } else {\n                result +=\
    \ String(prime)\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqxjtr5kk.swift:22:28: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            primes = primes[0..<primeIndex]\n             \
    \        ~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp37dgcsfc.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return wordsInSentence(sentence, \"\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp83jv0qt_.swift:13:12: error: cannot find 'wordsInSentence' in scope\n\
    \    return wordsInSentence(sentence, \"\")\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpekhpmh45.swift:13:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfxgwyug.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpqfxgwyug.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpqfxgwyug.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    for\
    \ char in sentence {\n        if char == \" \" {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if primeIndex == len(primes) {\n                result += char\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpn00i1lt6.swift:21:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpn00i1lt6.swift:25:30:\
    \ error: cannot find 'len' in scope\n            if primeIndex == len(primes)\
    \ {\n                             ^~~\n/tmp/tmpn00i1lt6.swift:26:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result += char\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"No words\"\n    }\n    var result = \"\
    \"\n    for word in sentence.components(separatedBy: \" \") {\n        if isPrime(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9rqg_tx0.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9rqg_tx0.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp37dgcsfc.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    var\
    \ currentPrime = 1\n    for char in sentence {\n        if char == \" \" {\n \
    \           primes[primeIndex] = currentPrime\n            primeIndex++\n    \
    \        currentPrime = 1\n        } else {\n            currentPrime = currentPrime\
    \ * primes[primeIndex]\n        }\n    }\n    for prime in primes {\n        if\
    \ prime > 100 {\n            break\n        }\n        if prime == 1 {\n     \
    \       result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpo3ztk_74.swift:23:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpo3ztk_74.swift:34:23:\
    \ error: cannot find 'char' in scope\n            result += char\n           \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char == \" \" {\n            primeIndex++\n\
    \        }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if primeIndex == len(primes) {\n                result += char\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnpb3qrpf.swift:18:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpnpb3qrpf.swift:22:30:\
    \ error: cannot find 'len' in scope\n            if primeIndex == len(primes)\
    \ {\n                             ^~~\n/tmp/tmpnpb3qrpf.swift:23:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result += char\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  var primes = [Int]()\n    for letter in sentence {\n        if primes.contains(Int(letter))\
    \ {\n            result += String(letter)\n        } else {\n            primes.append(Int(letter))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ujsug3e.swift:17:28: error: no exact matches in call to initializer\
    \ \n        if primes.contains(Int(letter)) {\n                           ^\n\
    Swift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n/tmp/tmp_ujsug3e.swift:20:27: error:\
    \ no exact matches in call to initializer \n            primes.append(Int(letter))\n\
    \                          ^\nSwift.Int:7:12: note: candidate expects value of\
    \ type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value of type\
    \ 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float80)\n       \
    \    ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    p"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for char in sentence.characters {\n        if isPrimeNumber(char) {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5te65zh1.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp5te65zh1.swift:16:12: error: cannot find 'isPrimeNumber' in scope\n  \
    \      if isPrimeNumber(char) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    for letter in sentence.characters\
    \ {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        if prime > 1 {\n       \
    \     for letter in sentence.characters {\n                if prime == letter\
    \ {\n                    result += String(letter)\n                }\n       \
    \     }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpw3dg6j7w.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpw3dg6j7w.swift:19:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpw3dg6j7w.swift:20:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpw3dg6j7w.swift:25:36: error: 'characters'\
    \ is unavailable: Please use String directly\n            for letter in sentence.characters\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw3dg6j7w.swift:26:26: error: binary operator '==' cannot\
    \ be applied to operands of type 'Int' and 'Character'\n                if prime\
    \ == letter {\n                   ~~~~~ ^  ~~~~~~\n/tmp/tmpw3dg6j7w.swift:26:26:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n                if prime == letter {\n \
    \                        ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    for\
    \ letter in sentence.characters {\n        if primes[primeIndex] == 0 {\n    \
    \        primeIndex++\n        }\n        if primes[primeIndex] == 1 {\n     \
    \       primeIndex++\n        }\n        if primes[primeIndex] == 2 {\n      \
    \      primeIndex++\n        }\n        if primes[primeIndex] == 3 {\n       \
    \     primeIndex++\n        }\n        if primes[primeIndex] == 4 {\n        \
    \    primeIndex++\n        }\n        if primes[primeIndex] == 5 {\n         \
    \   primeIndex++\n        }\n        if primes[primeIndex] == 6 {\n          \
    \  primeIndex++\n        }\n        if primes[primeIndex] == 7 {\n           \
    \ primeIndex++\n        }\n        if primes[primeIndex] == 8 {\n            primeIndex++\n\
    \        }\n        if primes[primeIndex] == 9 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 10 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 11 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 12 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 13 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 14 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 15 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 16 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 17 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 18 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 19 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 20 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 21 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 22 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 23 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 24 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 25 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 26 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 27 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 28 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex] == 29 {\n            primeIndex++\n \
    \       }\n        if primes[primeIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpdt0a6ngb.swift:111:1: error: expected ']' in expression list\n\
    }\n^\n/tmp/tmpdt0a6ngb.swift:110:18: note: to match this opening '['\n       \
    \ if primes[primeIndex\n                 ^\n/tmp/tmpdt0a6ngb.swift:132:55: error:\
    \ expected '}' at end of brace statement\nassert(words_in_sentence(sentence: \"\
    here is\") == \"is\")\n                                                      ^\n\
    /tmp/tmpdt0a6ngb.swift:12:52: note: to match this opening '{'\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n                                                   ^\n\
    /tmp/tmpdt0a6ngb.swift:19:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    for letter in sentence.characters {\n                        \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdt0a6ngb.swift:21:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmpdt0a6ngb.swift:24:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmpdt0a6ngb.swift:27:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmpdt0a6ngb.swift:30:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            primeIndex++\n                 \
    \     ^~\n/tmp/tmpdt0a6ngb.swift:33:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpdt0a6ngb.swift:36:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmpdt0a6ngb.swift:39:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmpdt0a6ngb.swift:42:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmpdt0a6ngb.swift:45:23: error: cannot find operator"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence, \"\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3263qk4.swift:13:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.lowercased(), let words\
    \ = sentence.components(separatedBy: \" \") else {\n        return \"No words\"\
    \n    }\n    var result = \"\"\n    for word in words {\n        if let number\
    \ = Int(word) {\n            if number > 1 {\n                result += String(number)\n\
    \            } else {\n                result += word\n            }\n       \
    \ } else {\n            result += word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpbii17tov.swift:13:70: error: value of type 'String' has no member\
    \ 'components'\n    guard let sentence = sentence.lowercased(), let words = sentence.components(separatedBy:\
    \ \" \") else {\n                                                            ~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpbii17tov.swift:13:11: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    guard let sentence = sentence.lowercased(),\
    \ let words = sentence.components(separatedBy: \" \") else {\n          ^    \
    \          ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp37dgcsfc.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"\"\n    }\n    var result = \"\"\n  \
    \  var primes = [1]\n    var primeIndex = 0\n    var currentWord = \"\"\n    for\
    \ char in sentence {\n        if char.isLetter {\n            currentWord = String(char)\n\
    \            primeIndex += 1\n            if primeIndex == primes.count {\n  \
    \              primes.append(1)\n                primeIndex = 0\n            }\n\
    \        } else {\n            if currentWord.isEmpty {\n                result\
    \ += currentWord\n            } else {\n                result += currentWord\
    \ + \" \"\n                currentWord = \"\"\n            }\n        }\n    }\n\
    \    if currentWord.isEmpty {\n        result += currentWord\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpicsiwrjr.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpicsiwrjr.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"\"\n    }\n    let words = sentence.components(separatedBy:\
    \ \" \")\n    var result = \"\"\n    for word in words {\n        if isPrime(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpp6kte41p.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp6kte41p.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result: String = \"\
    \"\n    for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n\
    \            result += \" \" + word\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp17x4u7yr.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    var\
    \ currentPrime = 1\n    for char in sentence {\n        if char == \" \" {\n \
    \           primes[primeIndex] = currentPrime\n            primeIndex++\n    \
    \        currentPrime++\n        } else {\n            currentPrime = primes[primeIndex]\n\
    \        }\n    }\n    for prime in primes {\n        if prime > 100 {\n     \
    \       return \"\"\n        }\n        if prime == 1 {\n            result +=\
    \ char\n        } else {\n            result += char + \" \"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqplcxi2.swift:23:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpuqplcxi2.swift:24:25:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  currentPrime++\n                        ^~\n/tmp/tmpuqplcxi2.swift:34:23: error:\
    \ cannot find 'char' in scope\n            result += char\n                  \
    \    ^~~~\n/tmp/tmpuqplcxi2.swift:36:23: error: cannot find 'char' in scope\n\
    \            result += char + \" \"\n                      ^~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfxgwyug.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpqfxgwyug.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpqfxgwyug.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence, \"\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3263qk4.swift:13:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    var currentPrime = 1\n    for letter in sentence {\n        if primes[primeIndex]\
    \ == 1 {\n            primeIndex++\n            currentPrime++\n        }\n  \
    \      if letter == \" \" {\n            primes[primeIndex] = 1\n            primeIndex++\n\
    \            currentPrime++\n        }\n    }\n    for letter in sentence {\n\
    \        if letter == \" \" {\n            primes[primeIndex] = 1\n          \
    \  primeIndex++\n            currentPrime++\n        }\n    }\n    for prime in\
    \ primes {\n        if prime == 1 {\n            result += String(letter)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8h81ni6_.swift:19:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmp8h81ni6_.swift:20:25:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  currentPrime++\n                        ^~\n/tmp/tmp8h81ni6_.swift:24:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmp8h81ni6_.swift:25:25: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            currentPrime++\n          \
    \              ^~\n/tmp/tmp8h81ni6_.swift:31:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            primeIndex++\n                 \
    \     ^~\n/tmp/tmp8h81ni6_.swift:32:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            currentPrime++\n                        ^~\n\
    /tmp/tmp8h81ni6_.swift:37:30: error: cannot find 'letter' in scope\n         \
    \   result += String(letter)\n                             ^~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence {\n \
    \       if letter == \" \" {\n            result += letter\n        }\n    }\n\
    \    var primes = [1]\n    for letter in result {\n        if primes.contains(letter)\
    \ {\n            primes.append(letter)\n        }\n    }\n    for prime in primes\
    \ {\n        result = result.replacingOccurrences(of: String(prime), with: \"\"\
    )\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzupuoaox.swift:16:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpzupuoaox.swift:21:28: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Int'\n        if primes.contains(letter)\
    \ {\n                           ^\n/tmp/tmpzupuoaox.swift:22:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        \
    \    primes.append(letter)\n                          ^\n/tmp/tmpzupuoaox.swift:26:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result = result.replacingOccurrences(of: String(prime), with: \"\")\n      \
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for char in sentence {\n        if char.unicodeScalars.isPrime() {\n      \
    \      result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp89ul5gyb.swift:16:32: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'isPrime'\n        if char.unicodeScalars.isPrime()\
    \ {\n           ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp89ul5gyb.swift:17:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for char in sentence {\n        if char == \" \" {\n            result += char\n\
    \        } else {\n            result += char\n        }\n    }\n    for char\
    \ in result {\n        if char.isPrime() {\n            result += char\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bg0bt7t.swift:17:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n/tmp/tmp9bg0bt7t.swift:19:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += char\n\
    \                      ^\n/tmp/tmp9bg0bt7t.swift:23:17: error: value of type 'Character'\
    \ has no member 'isPrime'\n        if char.isPrime() {\n           ~~~~ ^~~~~~~\n\
    /tmp/tmp9bg0bt7t.swift:24:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for letter in sentence.characters {\n        if primes[primeIndex]\
    \ == 0 {\n            primeIndex++\n        }\n        if primes[primeIndex] ==\
    \ 1 {\n            primeIndex++\n        }\n        if letter == \" \" {\n   \
    \         primeIndex++\n        }\n        primes[primeIndex] = primes[primeIndex]\
    \ + 1\n    }\n    for prime in primes {\n        if prime > 1 {\n            for\
    \ letter in sentence.characters {\n                if prime == 1 {\n         \
    \           result = result + String(letter)\n                } else {\n     \
    \               result = result + String(letter) + \" \"\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp36crv_g7.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp36crv_g7.swift:18:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmp36crv_g7.swift:21:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmp36crv_g7.swift:24:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmp36crv_g7.swift:30:36: error: 'characters' is\
    \ unavailable: Please use String directly\n            for letter in sentence.characters\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        for letter in sentence {\n\
    \            if prime == letter {\n                result += letter\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphszxrp1s.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmphszxrp1s.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmphszxrp1s.swift:22:22: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Character'\n         \
    \   if prime == letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmphszxrp1s.swift:22:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n            if prime == letter {\n     \
    \                ^\n/tmp/tmphszxrp1s.swift:23:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += letter\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp37dgcsfc.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        for letter in sentence {\n\
    \            if prime == letter {\n                result += letter\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphszxrp1s.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmphszxrp1s.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmphszxrp1s.swift:22:22: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Character'\n         \
    \   if prime == letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmphszxrp1s.swift:22:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n            if prime == letter {\n     \
    \                ^\n/tmp/tmphszxrp1s.swift:23:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += letter\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence, \"\", \"\"\
    , \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqez9s1lx.swift:13:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence, \"\", \"\", \"\")\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().wordsInSentence(sentence)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpklgvuhsg.swift:13:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().wordsInSentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence {\n        if primes.contains(char.unicodeScalars.count) {\n   \
    \         primes.append(char.unicodeScalars.count)\n        } else {\n       \
    \     result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1xv_ew3e.swift:19:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    for char in sentence.characters {\n        if isPrime(Int(char)) {\n    \
    \        newString += String(char)\n        }\n    }\n    return newString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8jqzx7ty.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp8jqzx7ty.swift:16:12: error: cannot find 'isPrime' in scope\n        if\
    \ isPrime(Int(char)) {\n           ^~~~~~~\n/tmp/tmp8jqzx7ty.swift:16:20: error:\
    \ no exact matches in call to initializer \n        if isPrime(Int(char)) {\n\
    \                   ^\n/tmp/tmp8jqzx7ty.swift:16:20: note: found candidate with\
    \ type '(Float16) -> Int'\n        if isPrime(Int(char)) {\n                 \
    \  ^\n/tmp/tmp8jqzx7ty.swift:16:20: note: found candidate with type '(Float) ->\
    \ Int'\n        if isPrime(Int(char)) {\n                   ^\n/tmp/tmp8jqzx7ty.swift:16:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(char))\
    \ {\n                   ^\n/tmp/tmp8jqzx7ty.swift:16:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(char)) {\n            \
    \       ^\n/tmp/tmp8jqzx7ty.swift:16:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(char)) {\n                   ^\n/tmp/tmp8jqzx7ty.swift:16:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(char))\
    \ {\n                   ^\n/tmp/tmp8jqzx7ty.swift:16:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(char)) {\n            \
    \       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence.characters\
    \ {\n        if isPrime(Int(letter)) {\n            result += String(letter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfxwi4r7n.swift:14:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfxwi4r7n.swift:15:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(Int(letter)) {\n           ^~~~~~~\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ error: no exact matches in call to initializer \n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(Float16) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate with type '(Float)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for word\
    \ in sentence.split(\" \") {\n        if primes.contains(word.characters.count)\
    \ {\n            result += \" \" + word\n            primes.append(word.characters.count)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpq9v3xlc0.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"No words\"\n    }\n    var result = \"\
    \"\n    var primes = [1]\n    var primeIndex = 0\n    for letter in sentence {\n\
    \        if letter.isLetter {\n            if primeIndex == primes.count {\n \
    \               primes.append(1)\n                primeIndex += 1\n          \
    \  }\n            primes[primeIndex] += 1\n        }\n    }\n    for prime in\
    \ primes {\n        if prime > 1 {\n            result += String(repeating: \"\
    \ \", count: prime - 1)\n        }\n        result += String(repeating: \"#\"\
    , count: prime)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmplo7i2e4l.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplo7i2e4l.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence {\n        if primes.contains(char.unicodeScalars.count) {\n   \
    \         primes.append(1)\n        } else {\n            primes.append(primes.last!\
    \ + 1)\n        }\n    }\n    for char in sentence {\n        if primes.contains(char.unicodeScalars.count)\
    \ {\n            result += String(char)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmppby22sj4/tmppby22sj4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab96b243c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab96af3ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab96af3a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab96af397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppby22sj4                        0x000055f0057908b7 <unavailable> + 6327

    5    libc.so.6                          0x00002ab96b42f460 __libc_start_main +
    245

    6    tmppby22sj4                        0x000055f0057904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence, \"\")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfsk6iu1z.swift:13:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"\"\n    }\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else {\n        return \"\"\n    }\n    var result = \"\"\n    for word\
    \ in words {\n        guard let number = Int(word) else {\n            continue\n\
    \        }\n        if number == 1 {\n            result += word\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppo87h9df.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmppo87h9df.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ if prime > 1 {\n            for letter in sentence.characters {\n          \
    \      if prime == letters.distance(letters, letter) {\n                    result\
    \ += String(letter)\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps7b19z2b.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmps7b19z2b.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmps7b19z2b.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmps7b19z2b.swift:22:36: error: 'characters'\
    \ is unavailable: Please use String directly\n            for letter in sentence.characters\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmps7b19z2b.swift:23:29: error: cannot find 'letters'\
    \ in scope\n                if prime == letters.distance(letters, letter) {\n\
    \                            ^~~~~~~\n/tmp/tmps7b19z2b.swift:23:46: error: cannot\
    \ find 'letters' in scope\n                if prime == letters.distance(letters,\
    \ letter) {\n                                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(Int(letter)) {\n      \
    \      primes.append(primes.last! + 1)\n        }\n    }\n    for prime in primes\
    \ {\n        if prime > result.characters.count {\n            result = result\
    \ + String(repeating: \" \", count: prime - result.characters.count)\n       \
    \ }\n        result = result + String(repeating: String(repeating: \" \", count:\
    \ prime - result.characters.count), count: result.characters.count)\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfupr34kf.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfupr34kf.swift:16:28: error: no exact matches in call to initializer\
    \ \n        if primes.contains(Int(letter)) {\n                           ^\n\
    Swift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n/tmp/tmpfupr34kf.swift:21:27: error:\
    \ 'characters' is unavailable: Please use String directly\n        if prime >\
    \ result.characters.count {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfupr34kf.swift:22:76: error: 'characters'\
    \ is unavailable: Please use String directly\n            result = result + String(repeating:\
    \ \" \", count: prime - result.characters.count)\n                           \
    \                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               "
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for char in sentence {\n        if char.isLetter() {\n            result +=\
    \ char\n        }\n    }\n    for char in result {\n        if char.isLetter()\
    \ {\n            if result.contains(char) == false {\n                result +=\
    \ char\n            }\n        }\n    }\n    for char in result {\n        if\
    \ char.isLetter() {\n            if result.contains(char) == false {\n       \
    \         result += char\n            }\n        }\n    }\n    for char in result\
    \ {\n        if char.isLetter() {\n            if result.contains(char) == false\
    \ {\n                result += char\n            }\n        }\n    }\n    for\
    \ char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                result += char\n            }\n        }\n    }\n\
    \    for char in result {\n        if char.isLetter() {\n            if result.contains(char)\
    \ == false {\n                \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6gq7us10.swift:157:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmp6gq7us10.swift:133:28: note:\
    \ to match this opening '{'\n        if char.isLetter() {\n                  \
    \         ^\n/tmp/tmp6gq7us10.swift:157:55: error: expected '}' at end of brace\
    \ statement\nassert(words_in_sentence(sentence: \"here is\") == \"is\")\n    \
    \                                                  ^\n/tmp/tmp6gq7us10.swift:132:24:\
    \ note: to match this opening '{'\n    for char in result {\n                \
    \       ^\n/tmp/tmp6gq7us10.swift:157:55: error: expected '}' at end of brace\
    \ statement\nassert(words_in_sentence(sentence: \"here is\") == \"is\")\n    \
    \                                                  ^\n/tmp/tmp6gq7us10.swift:12:52:\
    \ note: to match this opening '{'\nfunc words_in_sentence(sentence: String) ->\
    \ String {\n                                                   ^\n/tmp/tmp6gq7us10.swift:16:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp6gq7us10.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmp6gq7us10.swift:21:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp6gq7us10.swift:23:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp6gq7us10.swift:28:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp6gq7us10.swift:30:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp6gq7us10.swift:35:17:\
    \ error: cannot call value of non-function type 'Bool'"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n   \
    \         result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv4hiz0m5.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence, \"\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3263qk4.swift:13:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char == \" \" {\n            primeIndex++\n\
    \        }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if primeIndex == len(primes) {\n                result += char\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnpb3qrpf.swift:18:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmpnpb3qrpf.swift:22:30:\
    \ error: cannot find 'len' in scope\n            if primeIndex == len(primes)\
    \ {\n                             ^~~\n/tmp/tmpnpb3qrpf.swift:23:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result += char\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for char in sentence {\n        if char == \" \" {\n            result += char\n\
    \        }\n    }\n    for char in result {\n        if char == \"a\" || char\
    \ == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" || char == \"A\"\
    \ || char == \"E\" || char == \"I\" || char == \"O\" || char == \"U\" {\n    \
    \        continue\n        }\n        if char == \"b\" || char == \"c\" || char\
    \ == \"d\" || char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\"\
    \ || char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char\
    \ == \"p\" || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\"\
    \ || char == \"v\" || char == \"w\" || char == \"x\" || char == \"y\" || char\
    \ == \"z\" {\n            continue\n        }\n        if char == \"0\" {\n  \
    \          continue\n        }\n        if char == \"1\" {\n            continue\n\
    \        }\n        if char == \"2\" {\n            continue\n        }\n    \
    \    if char == \"3\" {\n            continue\n        }\n        if char == \"\
    4\" {\n            continue\n        }\n        if char == \"5\" {\n         \
    \   continue\n        }\n        if char == \"6\" {\n            continue\n  \
    \      }\n        if char == \"7\" {\n            continue\n        }\n      \
    \  if char == \"8\" {\n            continue\n        }\n        if char == \"\
    9\" {\n            continue\n        }\n        if char == \"!\" {\n         \
    \   continue\n        }\n        if char == \"?\" {\n            continue\n  \
    \      }\n        if char == \".\" {\n            continue\n        }\n      \
    \  if char == \",\" {\n            continue\n        }\n        if char == \"\
    -\" {\n            continue\n        }\n        if char == \"_\" {\n         \
    \   continue\n        }\n        if char == \"/\" {\n            continue\n  \
    \      }\n        if char == \"(\" {\n            continue\n        }\n      \
    \  if char == \")\" {\n            continue\n        }\n        if char == \"\
    {\" {\n            continue\n        }\n        if char == \"}\" {\n         \
    \   continue\n        }\n        if char == \"[\" {\n            continue\n  \
    \      }\n        if char == \"]\" {\n            continue\n        }\n      \
    \  if char == \"{\" {\n            continue\n        }\n        if char == \"\
    }\" {\n            continue\n        }\n        if char == \"|\" {\n         \
    \   continue\n        }\n        if char == \"\\\\\" {\n            continue\n\
    \        }\n        if char == \"^\" {\n            continue\n        }\n    \
    \    if char == \"~\" {\n            continue\n        }\n        if char == \"\
    `\" {\n            continue\n        }\n        if char == \"-\" {\n         \
    \   continue\n        }\n        if char == \"_\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_iswfxhg.swift:120:20: error: unterminated string literal\n   \
    \     if char == \"_\n                   ^\n/tmp/tmp_iswfxhg.swift:142:55: error:\
    \ expected '}' at end of brace statement\nassert(words_in_sentence(sentence: \"\
    here is\") == \"is\")\n                                                      ^\n\
    /tmp/tmp_iswfxhg.swift:12:52: note: to match this opening '{'\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n                                                   ^\n\
    /tmp/tmp_iswfxhg.swift:17:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n/tmp/tmp_iswfxhg.swift:124:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for word\
    \ in sentence.split(\" \") {\n        if primes.contains(word.characters.count)\
    \ {\n            primes.append(word.characters.count)\n            result += \"\
    \ \" + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnhafyfxq.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n \
    \           newString += \" \" + word\n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqog9fgqe.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var resultString = \"\"\
    \n    for character in sentence {\n        if character == \" \" {\n         \
    \   resultString += character\n        }\n    }\n    var primeNumbers = \"\"\n\
    \    for character in resultString {\n        if character == \" \" {\n      \
    \      primeNumbers += character\n        }\n    }\n    for character in primeNumbers\
    \ {\n        if Int(character) == Int(character) {\n            resultString +=\
    \ character\n        }\n    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7rgwkcnk.swift:17:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            resultString += character\n\
    \                            ^\n/tmp/tmp7rgwkcnk.swift:23:29: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            primeNumbers\
    \ += character\n                            ^\n/tmp/tmp7rgwkcnk.swift:27:30: error:\
    \ no exact matches in call to initializer \n        if Int(character) == Int(character)\
    \ {\n                             ^\n/tmp/tmp7rgwkcnk.swift:27:30: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n       \
    \ if Int(character) == Int(character) {\n                             ^\n/tmp/tmp7rgwkcnk.swift:27:30:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        if Int(character) == Int(character) {\n                             ^\n\
    /tmp/tmp7rgwkcnk.swift:27:30: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n        if Int(character) == Int(character)\
    \ {\n                             ^\n/tmp/tmp7rgwkcnk.swift:27:30: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'Character')\n       \
    \ if Int(character) == Int(character) {\n                             ^\n/tmp/tmp7rgwkcnk.swift:27:30:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n        if Int(character) == Int(character) {\n              \
    \               ^\n/tmp/tmp7rgwkcnk.swift:27:30: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n        if Int(character)\
    \ == Int(character) {\n                             ^\n/tmp/tmp7rgwkcnk.swift:27:30:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \        if Int(character) == Int(character) {\n                             ^\n\
    /tmp/tmp7rgwkcnk.swift:27:12: error: no exact matches in call to initializer \n\
    \        if Int(character) == Int(character) {\n           ^\n/tmp/tmp7rgwkcnk.swift:27:12:\
    \ note: candidate expects val"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    var resultString\
    \ = \"\"\n    \n    for word in sentence.split(\" \") {\n        if isPrimeNumber(word)\
    \ {\n            resultString += \" \" + word\n        }\n    }\n    \n    return\
    \ resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp175xvd5x.swift:17:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for word\
    \ in sentence.split(\" \") {\n        if primes.contains(word.characters.count)\
    \ {\n            result += \" \" + word\n            primes.append(word.characters.count)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpq9v3xlc0.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence, \"\")\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp08amlqax.swift:13:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp37dgcsfc.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpy6sy8e8h/tmpy6sy8e8h.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5581ddfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5581ad6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5581ad6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5581ad57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy6sy8e8h                        0x0000562714078307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5581fcb460 __libc_start_main +
    245

    6    tmpy6sy8e8h                        0x0000562714077f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().wordsInSentence(sentence)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpklgvuhsg.swift:13:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().wordsInSentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    var result = \"\"\
    \n    \n    for word in sentence.split(\" \") {\n        if isPrime(Int(word))\
    \ {\n            result += \" \" + word\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ywbdhwd.swift:17:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence.characters {\n        if primes.contains(char.unicodeScalars.count)\
    \ {\n            primes.append(char.unicodeScalars.count)\n        }\n    }\n\
    \    for prime in primes {\n        result = result + String(sentence[sentence.startIndex..<sentence.startIndex.advancedBy(prime)])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpp9e6nd_u.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpp9e6nd_u.swift:21:85: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        result = result + String(sentence[sentence.startIndex..<sentence.startIndex.advancedBy(prime)])\n\
    \                                                                ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence {\n \
    \       if isPrime(Int(letter)) {\n            result += letter\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpp55kopxg.swift:15:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(Int(letter)) {\n           ^~~~~~~\n/tmp/tmpp55kopxg.swift:15:20:\
    \ error: no exact matches in call to initializer \n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpp55kopxg.swift:15:20: note: found candidate\
    \ with type '(Float16) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpp55kopxg.swift:15:20: note: found candidate with type '(Float)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpp55kopxg.swift:15:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpp55kopxg.swift:15:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpp55kopxg.swift:15:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpp55kopxg.swift:15:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpp55kopxg.swift:15:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpp55kopxg.swift:16:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result: String = \"\
    \"\n    for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n\
    \            result += \" \" + word\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj5vxovyx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    for letter in sentence.characters\
    \ {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        result = result + String(prime)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpc9mnm5cz.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpc9mnm5cz.swift:19:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpc9mnm5cz.swift:20:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if let sentence = sentence.lowercased() {\n       \
    \ var result = \"\"\n        var primes = [1]\n        for letter in sentence\
    \ {\n            if let index = Int(letter) {\n                primes[index] =\
    \ primes[index] + 1\n            }\n        }\n        for prime in primes {\n\
    \            if prime > 1 {\n                for index in 0..<prime {\n      \
    \              result = result + String(index)\n                }\n          \
    \  }\n        }\n        return result\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfa89b1r2.swift:17:32: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            if let index = Int(letter) {\n\
    \                               ^\n/tmp/tmpfa89b1r2.swift:13:8: error: initializer\
    \ for conditional binding must have Optional type, not 'String'\n    if let sentence\
    \ = sentence.lowercased() {\n       ^              ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char == \" \" {\n            primes[primeIndex]\
    \ = primes[primeIndex] + 1\n        }\n        if primes[primeIndex] == 0 {\n\
    \            primeIndex = primeIndex + 1\n        }\n    }\n    for prime in primes\
    \ {\n        result = result + String(prime)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp38fshhyn/tmp38fshhyn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37c2172c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37c1e69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37c1e69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37c1e687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp38fshhyn                        0x000055ca8a2488e7 <unavailable> + 6375

    5    libc.so.6                          0x00002b37c235e460 __libc_start_main +
    245

    6    tmp38fshhyn                        0x000055ca8a248529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result: String = \"\
    \"\n    var primeNumber: Int = 0\n    for character in sentence {\n        if\
    \ character == \" \" {\n            primeNumber++\n        }\n    }\n    for character\
    \ in sentence {\n        if character == \" \" {\n            if primeNumber ==\
    \ 0 {\n                result += character\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3z7uzqx9.swift:18:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeNumber++\n                       ^~\n\
    /tmp/tmp3z7uzqx9.swift:24:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result += character\n  \
    \                        ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n   \
    \         result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv4hiz0m5.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for letter in sentence.characters {\n        if primes[primeIndex]\
    \ == 0 {\n            primeIndex++\n        }\n        if primes[primeIndex] ==\
    \ 1 {\n            primeIndex++\n        }\n        if letter == \" \" {\n   \
    \         primeIndex++\n        }\n        if letter == \",\" {\n            primeIndex++\n\
    \        }\n        if letter == \".\" {\n            primeIndex++\n        }\n\
    \        if letter == \"?\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"!\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"-\" {\n            primeIndex++\n        }\n        if letter == \"_\" {\n\
    \            primeIndex++\n        }\n        if letter == \"/\" {\n         \
    \   primeIndex++\n        }\n        if letter == \"\\\\\" {\n            primeIndex++\n\
    \        }\n        if letter == \"@\" {\n            primeIndex++\n        }\n\
    \        if letter == \"$\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"%\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"^\" {\n            primeIndex++\n        }\n        if letter == \"&\" {\n\
    \            primeIndex++\n        }\n        if letter == \"*\" {\n         \
    \   primeIndex++\n        }\n        if letter == \"(\" {\n            primeIndex++\n\
    \        }\n        if letter == \")\" {\n            primeIndex++\n        }\n\
    \        if letter == \"{\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"}\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"[\" {\n            primeIndex++\n        }\n        if letter == \"]\" {\n\
    \            primeIndex++\n        }\n        if letter == \"<\" {\n         \
    \   primeIndex++\n        }\n        if letter == \">\" {\n            primeIndex++\n\
    \        }\n        if letter == \"|\" {\n            primeIndex++\n        }\n\
    \        if letter == \"=\" { // this one should be last\n            primeIndex++\n\
    \        }\n        if letter == \"~\" {\n            primeIndex++\n        }\n\
    \        if letter == \"`\" {\n            primeIndex++\n        }\n        if\
    \ letter == \"'\" {\n            primeIndex++\n        }\n        if letter ==\
    \ \"%\" {\n            primeIndex++\n        }\n        if letter == \"+\" {\n\
    \            primeIndex++\n        }\n        if letter == \"-\" {\n         \
    \   primeIndex++\n        }\n        if letter == \"_\" {\n            primeIndex++\n\
    \        }\n        if letter == \"/\" {\n            primeIndex++\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmputc8bj_3.swift:142:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmputc8bj_3.swift:16:39: note: to\
    \ match this opening '{'\n    for letter in sentence.characters {\n          \
    \                            ^\n/tmp/tmputc8bj_3.swift:142:55: error: expected\
    \ '}' at end of brace statement\nassert(words_in_sentence(sentence: \"here is\"\
    ) == \"is\")\n                                                      ^\n/tmp/tmputc8bj_3.swift:12:52:\
    \ note: to match this opening '{'\nfunc words_in_sentence(sentence: String) ->\
    \ String {\n                                                   ^\n/tmp/tmputc8bj_3.swift:16:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in sentence.characters {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmputc8bj_3.swift:18:23: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n   \
    \                   ^~\n/tmp/tmputc8bj_3.swift:21:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmputc8bj_3.swift:24:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            primeIndex++\n                 \
    \     ^~\n/tmp/tmputc8bj_3.swift:27:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmputc8bj_3.swift:30:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  primeIndex++\n                      ^~\n/tmp/tmputc8bj_3.swift:33:23: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            primeIndex++\n\
    \                      ^~\n/tmp/tmputc8bj_3.swift:36:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            primeIndex++\n            \
    \          ^~\n/tmp/tmputc8bj_3.swift:39:23: error: cannot find operat"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n  \
    \          newString += word + \" \" \n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprszhch7j.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char == \" \" {\n            primeIndex++\n\
    \        }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                result += char\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4l9_1r4a.swift:18:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmp4l9_1r4a.swift:23:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    var result = \"\"\
    \n    \n    for word in sentence.split(\" \") {\n        if isPrimeNumber(word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp99zqqq29.swift:17:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"0\"\n    }\n    var result = \"0\"\n\
    \    for letter in sentence.unicodeScalars {\n        if let index = Int(letter)\
    \ {\n            if index > 0 {\n                let isPrime = index == 2 || index\
    \ == 3 || index == 5 || index == 7 || index == 11 || index == 13\n           \
    \     if isPrime {\n                    result += String(index)\n            \
    \    }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpeljxy5up.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeljxy5up.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n    \
    \        result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bhdi4vx.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ if prime > result.characters.count {\n            result = result + String(prime)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi67cjufb.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpi67cjufb.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpi67cjufb.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpi67cjufb.swift:21:27: error: 'characters'\
    \ is unavailable: Please use String directly\n        if prime > result.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    for char in sentence.characters\
    \ {\n        if primes.contains(char.unicodeScalars.count) {\n            primes.append(1)\n\
    \        } else {\n            primes.append(0)\n        }\n    }\n    for char\
    \ in sentence.characters {\n        if primes.contains(char.unicodeScalars.count)\
    \ {\n            result += String(char)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqn29qxyy.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpqn29qxyy.swift:25:26: error: 'characters' is unavailable: Please use String\
    \ directly\n    for char in sentence.characters {\n                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence.characters\
    \ {\n        if isPrime(Int(letter)) {\n            result += String(letter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfxwi4r7n.swift:14:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfxwi4r7n.swift:15:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(Int(letter)) {\n           ^~~~~~~\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ error: no exact matches in call to initializer \n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(Float16) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate with type '(Float)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpfxwi4r7n.swift:15:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    for\
    \ letter in sentence {\n        if primes[primeIndex] == 1 {\n            primeIndex++\n\
    \        }\n        if primeIndex == len(primes) {\n            primeIndex = 0\n\
    \            primes.append(1)\n        }\n        if letter == \" \" {\n     \
    \       primes[primeIndex] = 0\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprpehwklu.swift:21:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            primeIndex++\n                      ^~\n/tmp/tmprpehwklu.swift:23:26:\
    \ error: cannot find 'len' in scope\n        if primeIndex == len(primes) {\n\
    \                         ^~~\n/tmp/tmprpehwklu.swift:29:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"[\"\n \
    \   for word in sentence.split(\" \") {\n        if isPrime(Int(word)) {\n   \
    \         result += word + \" \"\n        }\n    }\n    result += \"]\"\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8n0xdip3.swift:15:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var primes = [1]\n    var primeIndex = 0\n    for\
    \ char in sentence {\n        if char == \" \" {\n            primeIndex = 0\n\
    \        }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex]\
    \ = 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                primeIndex++\n            }\n \
    \       }\n    }\n    for prime in primes {\n        if prime == 1 {\n       \
    \     for char in sentence {\n                if char == \" \" {\n           \
    \         primeIndex = 0\n                }\n                if prime == 1 {\n\
    \                    if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                        primeIndex++\n        \
    \            }\n                }\n            }\n        }\n    }\n    for char\
    \ in sentence {\n        if char == \" \" {\n            primeIndex = 0\n    \
    \    }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex] =\
    \ 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n                primeIndex++\n            }\n    \
    \    }\n    }\n    for prime in primes {\n        if prime == 1 {\n          \
    \  for char in sentence {\n                if char == \" \" {\n              \
    \      primeIndex = 0\n                }\n                if prime == 1 {\n  \
    \                  if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                        primeIndex++\n        \
    \            }\n                }\n            }\n        }\n    }\n    for char\
    \ in sentence {\n        if char == \" \" {\n            primeIndex = 0\n    \
    \    }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex] =\
    \ 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n                primeIndex++\n            }\n    \
    \    }\n    }\n    for prime in primes {\n        if prime == 1 {\n          \
    \  for char in sentence {\n                if char == \" \" {\n              \
    \      primeIndex = 0\n                }\n                if prime == 1 {\n  \
    \                  if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n                        primeIndex++\n        \
    \            }\n                }\n            }\n        }\n    }\n    for char\
    \ in sentence {\n        if char == \" \" {\n            primeIndex = 0\n    \
    \    }\n        if primes[primeIndex] == 0 {\n            primes[primeIndex] =\
    \ 1\n            if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n                primeIndex++\n            }\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpdyir0oek.swift:125:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmpdyir0oek.swift:94:26: note: to\
    \ match this opening '{'\n    for char in sentence {\n                       \
    \  ^\n/tmp/tmpdyir0oek.swift:125:55: error: expected '}' at end of brace statement\n\
    assert(words_in_sentence(sentence: \"here is\") == \"is\")\n                 \
    \                                     ^\n/tmp/tmpdyir0oek.swift:12:52: note: to\
    \ match this opening '{'\nfunc words_in_sentence(sentence: String) -> String {\n\
    \                                                   ^\n/tmp/tmpdyir0oek.swift:26:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      primeIndex++\n                          ^~\n/tmp/tmpdyir0oek.swift:38:35:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \              primeIndex++\n                                  ^~\n/tmp/tmpdyir0oek.swift:51:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      primeIndex++\n                          ^~\n/tmp/tmpdyir0oek.swift:63:35:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \              primeIndex++\n                                  ^~\n/tmp/tmpdyir0oek.swift:76:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      primeIndex++\n                          ^~\n/tmp/tmpdyir0oek.swift:88:35:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \              primeIndex++\n                                  ^~\n/tmp/tmpdyir0oek.swift:101:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      primeIndex++\n                          ^~\n/tmp/tmpdyir0oek.swift:107:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpe63i18m2/tmpe63i18m2.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ca422bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ca3f22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ca3f22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ca3f217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe63i18m2                        0x000055c9f4eb3307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5ca4417460 __libc_start_main +
    245

    6    tmpe63i18m2                        0x000055c9f4eb2f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ for letter in sentence.characters {\n            if prime == letter {\n    \
    \            result += String(letter)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp53wgz3eg.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp53wgz3eg.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmp53wgz3eg.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmp53wgz3eg.swift:21:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        for letter in sentence.characters\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp53wgz3eg.swift:22:22: error: binary operator '==' cannot\
    \ be applied to operands of type 'Int' and 'Character'\n            if prime ==\
    \ letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmp53wgz3eg.swift:22:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (Int, Int)\n            if prime == letter {\n                 \
    \    ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence {\n        if primes.contains(char.unicodeScalars.count) {\n   \
    \         primes.append(char.unicodeScalars.count)\n        }\n    }\n    for\
    \ prime in primes {\n        if prime > 1 {\n            for char in sentence\
    \ {\n                if char.unicodeScalars.count == prime {\n               \
    \     result += char\n                }\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpd37h88my.swift:24:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                    result += char\n   \
    \                           ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence {\n \
    \       if letter == \" \" {\n            result += letter\n        } else {\n\
    \            result += letter + \" \"\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpywcpykg5.swift:16:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpywcpykg5.swift:18:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result += letter\
    \ + \" \"\n                      ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n        return \"No words\"\n    }\n    var result = \"\
    \"\n    var primes = [1]\n    for letter in sentence.characters {\n        if\
    \ primes.contains(letter) {\n            primes.append(letter)\n        }\n  \
    \  }\n    for prime in primes {\n        if prime > result.characters.count {\n\
    \            result = result + String(repeating: String(repeating: \" \", count:\
    \ prime - result.characters.count), count: result.characters.count + 1)\n    \
    \    }\n        result = result + String(repeating: String(repeating: \" \", count:\
    \ prime - result.characters.count), count: result.characters.count + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxwuecw7.swift:13:35: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgxwuecw7.swift:13:59: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    guard let sentence = sentence.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \    ~^~~~~~~~~~~\n/tmp/tmpgxwuecw7.swift:24:27: error: 'characters' is unavailable:\
    \ Please use String directly\n        if prime > result.characters.count {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgxwuecw7.swift:25:94: error: 'characters' is unavailable:\
    \ Please use String directly\n            result = result + String(repeating:\
    \ String(repeating: \" \", count: prime - result.characters.count), count: result.characters.count\
    \ + 1)\n                                                                     \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgxwuecw7.swift:25:127: error: 'characters' is unavailable:\
    \ Please use String directly\n            result = result + String(repeating:\
    \ String(repeating: \" \", count: prime - result.characters.count), count: result.characters.count\
    \ + 1)\n                                                                     \
    \                                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgxwuecw7.swift:27:90: error: 'characters'\
    \ is unavailable: Please use String directly\n        result = result + String(repeating:\
    \ String(repeating: \" \", count: prime - result.characters.count), count: result.characters.count\
    \ + 1)\n                                                   "
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        for letter in sentence {\n\
    \            if prime == letter {\n                result += letter\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphszxrp1s.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmphszxrp1s.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmphszxrp1s.swift:22:22: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Character'\n         \
    \   if prime == letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmphszxrp1s.swift:22:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n            if prime == letter {\n     \
    \                ^\n/tmp/tmphszxrp1s.swift:23:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += letter\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for letter in sentence {\n \
    \       if isPrime(letter) {\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgyez8qzy.swift:15:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(letter) {\n           ^~~~~~~\n/tmp/tmpgyez8qzy.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ for letter in sentence.characters {\n            if prime == letter {\n    \
    \            result += String(letter)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp53wgz3eg.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp53wgz3eg.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmp53wgz3eg.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmp53wgz3eg.swift:21:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        for letter in sentence.characters\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp53wgz3eg.swift:22:22: error: binary operator '==' cannot\
    \ be applied to operands of type 'Int' and 'Character'\n            if prime ==\
    \ letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmp53wgz3eg.swift:22:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (Int, Int)\n            if prime == letter {\n                 \
    \    ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpb0a69ma7/tmpb0a69ma7.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99bf195c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99bee8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99bee8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99bee8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0a69ma7                        0x000056123cdde307 <unavailable> + 4871

    5    libc.so.6                          0x00002b99bf381460 __libc_start_main +
    245

    6    tmpb0a69ma7                        0x000056123cdddf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpekhpmh45.swift:13:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(Int(word)) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn2dllf2.swift:14:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Example 2:\n/// Constraints:\n/// * 1\
    \ <= len(sentence) <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence {\n        if primes.contains(letter) {\n            primes.append(letter)\n\
    \        }\n    }\n    for prime in primes {\n        for letter in sentence {\n\
    \            if prime == letter {\n                result += letter\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphszxrp1s.swift:16:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmphszxrp1s.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmphszxrp1s.swift:22:22: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Character'\n         \
    \   if prime == letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmphszxrp1s.swift:22:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n            if prime == letter {\n     \
    \                ^\n/tmp/tmphszxrp1s.swift:23:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += letter\n                          ^\n"
  stdout: ''
  timestamp: 1659978975
