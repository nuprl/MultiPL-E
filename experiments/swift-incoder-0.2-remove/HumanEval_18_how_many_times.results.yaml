language: swift
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var last = 0\n    for index in string.indices(in:\
    \ string) {\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n            count += 1\n        } else {\n            if count > 0 {\n  \
    \              count -= 1\n            }\n            last = index\n        }\n\
    \    }\n    return count + last\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmparf19qsj.swift:6:25: error: cannot call value of non-function type\
    \ 'DefaultIndices<String>'\n    for index in string.indices(in: string) {\n  \
    \                      ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first?.value {\n          \
    \  count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: Exception
  stderr: 'tmppj8jledw/tmppj8jledw.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30c3d6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30c3a64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30c3a64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30c3a637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppj8jledw                        0x0000560e5234d734 <unavailable> + 5940

    5    libc.so.6                          0x00002b30c3f59460 __libc_start_main +
    245

    6    tmppj8jledw                        0x0000560e5234d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \       } else {\n            count += endIndex - startIndex\n            startIndex\
    \ = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpiwnpqro7.swift:8:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpiwnpqro7.swift:8:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpiwnpqro7.swift:8:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += 1\n       \
    \     if char == substring.characters[1] {\n                count += 1\n     \
    \           if char == substring.characters[2] {\n                    count +=\
    \ 1\n                }\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm0ufr2rz.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpm0ufr2rz.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpm0ufr2rz.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm0ufr2rz.swift:8:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if char == substring.characters[1] {\n                       ^~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0ufr2rz.swift:8:34:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if char == substring.characters[1] {\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm0ufr2rz.swift:10:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if char == substring.characters[2]\
    \ {\n                           ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptsb9o44u.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptsb9o44u.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmptsb9o44u.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var lastIndex = string.startIndex\n\
    \    while lastIndex != string.endIndex {\n        if string.substring(lastIndex,\
    \ string.endIndex) == substring {\n            count += 1\n        }\n       \
    \ lastIndex = string.index(lastIndex, offsetBy: 1)\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpex8jmbbh.swift:7:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(lastIndex, string.endIndex) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n        } else if string[i] == substring[k] && k < substring.characters.count\
    \ {\n            i += 1\n            k += 1\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdyhjffyn.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdyhjffyn.swift:7:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpdyhjffyn.swift:9:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdyhjffyn.swift:9:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpdyhjffyn.swift:13:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[k] && k < substring.characters.count\
    \ {\n                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpdyhjffyn.swift:13:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[k] && k < substring.characters.count\
    \ {\n                               ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Charact"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.characters.count\n\
    \    while start < end {\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n        if index == nil {\n            break\n \
    \       }\n        count += 1\n        start = index! + 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdquc0yho.swift:6:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpdquc0yho.swift:8:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpdquc0yho.swift:8:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmpdquc0yho.swift:8:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var lastIndex = string.startIndex\n\
    \    while lastIndex < string.endIndex {\n        let range = string.range(of:\
    \ substring, options: .caseInsensitive)\n        if range.lowerBound != lastIndex\
    \ { // If substring is not found at current position\n            count += 1\n\
    \        }\n        lastIndex = range.upperBound\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpej28_8ul.swift:7:28: error: value of type 'String' has no member\
    \ 'range'\n        let range = string.range(of: substring, options: .caseInsensitive)\n\
    \                    ~~~~~~ ^~~~~\n/tmp/tmpej28_8ul.swift:7:59: error: cannot\
    \ infer contextual base in reference to member 'caseInsensitive'\n        let\
    \ range = string.range(of: substring, options: .caseInsensitive)\n           \
    \                                              ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        } else if\
    \ string.hasPrefix(char) {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphdgj9kzw.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphdgj9kzw.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmphdgj9kzw.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n/tmp/tmphdgj9kzw.swift:8:36: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        } else if string.hasPrefix(char) {\n                                \
    \   ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    while\
    \ i < string.count {\n        if string[i] == substring {\n            count +=\
    \ 1\n            i += 1\n            j = i\n            while i < string.count\
    \ && string[i] == substring {\n                i += 1\n            }\n       \
    \     j = i\n        } else {\n            if j > 0 {\n                count +=\
    \ j - i\n            }\n            i = 0\n            j = i\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphft5sdw_.swift:8:18: error: no exact matches in call to subscript\
    \ \n        if string[i] == substring {\n                 ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmphft5sdw_.swift:12:46: error: cannot convert value of\
    \ type 'Int' to expected argument type 'Range<String.Index>'\n            while\
    \ i < string.count && string[i] == substring {\n                             \
    \                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n            if char\
    \ == substring.last {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4tth8jj.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = string.index(substring, startIndex) + 1\n        } else\
    \ {\n            count = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq0jotsvl.swift:8:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpq0jotsvl.swift:8:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpq0jotsvl.swift:8:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpq0jotsvl.swift:11:33: error: no exact matches in call to instance method\
    \ 'index'\n            startIndex = string.index(substring, startIndex) + 1\n\
    \                                ^\n/tmp/tmpq0jotsvl.swift:11:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n/tmp/tmpq0jotsvl.swift:11:33: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpq0jotsvl.swift:11:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpq0jotsvl.swift:11:33:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            startIndex = string.index(substring, startIndex) + 1\n  \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \n    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppx9zrh1u.swift:9:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    while i < string.count\
    \ {\n        if string.substring(i, i+substring.length) == substring {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprkev6oxi.swift:7:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(i, i+substring.length) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmprkev6oxi.swift:7:44: error: value of\
    \ type 'String' has no member 'length'\n        if string.substring(i, i+substring.length)\
    \ == substring {\n                                 ~~~~~~~~~ ^~~~~~\n/tmp/tmprkev6oxi.swift:9:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += 1\n       \
    \     if char == substring.characters[1] {\n                count += 1\n     \
    \           if char == substring.characters[2] {\n                    count +=\
    \ 1\n                }\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm0ufr2rz.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpm0ufr2rz.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpm0ufr2rz.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm0ufr2rz.swift:8:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if char == substring.characters[1] {\n                       ^~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0ufr2rz.swift:8:34:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if char == substring.characters[1] {\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm0ufr2rz.swift:10:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if char == substring.characters[2]\
    \ {\n                           ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.characters.count\n\
    \    while start < end {\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        let substringIndex = string.index(index, offsetBy:\
    \ substring.characters.count)\n        if substringIndex < index {\n         \
    \   count += 1\n            start = substringIndex + 1\n        } else {\n   \
    \         start = index + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmxidkq9p.swift:6:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmxidkq9p.swift:9:70:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ substringIndex = string.index(index, offsetBy: substring.characters.count)\n\
    \                                                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmxidkq9p.swift:12:21:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            start = substringIndex + 1\n                    ^\n/tmp/tmpmxidkq9p.swift:14:21:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            start = index + 1\n                    ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    while i < string.count\
    \ {\n        if string.substring(i, i + substring.length) == substring {\n   \
    \         count += 1\n            i += substring.length\n        } else {\n  \
    \          i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_wjo7siz.swift:7:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(i, i + substring.length) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp_wjo7siz.swift:7:46: error: value of\
    \ type 'String' has no member 'length'\n        if string.substring(i, i + substring.length)\
    \ == substring {\n                                   ~~~~~~~~~ ^~~~~~\n/tmp/tmp_wjo7siz.swift:9:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\n\
    \                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n            count += 2\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmparqepkcg.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n/tmp/tmparqepkcg.swift:8:26:\
    \ error: instance method 'contains' requires the types 'Unicode.Scalar' and 'String.Element'\
    \ (aka 'Character') be equivalent\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n                         ^\n_StringProcessing.Collection:3:17: note: where\
    \ 'Self.Element' = 'Unicode.Scalar', 'C.Element' = 'String.Element' (aka 'Character')\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if substring.unicodeScalars.contains(c) {\n            count += 1\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: Exception
  stderr: 'tmpnc72k486/tmpnc72k486.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc38eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc35e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc35e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc35e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc72k486                        0x00005614ca717724 <unavailable> + 5924

    5    libc.so.6                          0x00002b9cc3ada460 __libc_start_main +
    245

    6    tmpnc72k486                        0x00005614ca717199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += 1\n       \
    \ }\n        if char == substring.characters[len(substring.characters)-1] {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj452aqky.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpj452aqky.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpj452aqky.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpj452aqky.swift:9:41: error: cannot find 'len' in scope\n\
    \        if char == substring.characters[len(substring.characters)-1] {\n    \
    \                                    ^~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var index = string.startIndex\n   \
    \ while index != string.endIndex {\n        index = string.index(substring, startIndex:\
    \ index + 1)\n        if index != string.endIndex {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvctigddj.swift:7:53: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        index = string.index(substring, startIndex:\
    \ index + 1)\n                                                    ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ error: no exact matches in call to instance method 'index'\n        index =\
    \ string.index(substring, startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n/tmp/tmpvctigddj.swift:7:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        index = string.index(substring,\
    \ startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n        }\n    \
    \    if char == substring.last {\n            count += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpak8l_dtx.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        } else if\
    \ string.hasPrefix(char) {\n            count += how_many_times(string.substring(char),\
    \ substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjeovxgat.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjeovxgat.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpjeovxgat.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n/tmp/tmpjeovxgat.swift:8:36: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        } else if string.hasPrefix(char) {\n                                \
    \   ^\n/tmp/tmpjeovxgat.swift:9:36: error: missing argument labels 'string:substring:'\
    \ in call\n            count += how_many_times(string.substring(char), substring)\n\
    \                                   ^\n                                    string:\
    \                 substring: \n/tmp/tmpjeovxgat.swift:9:44: error: value of type\
    \ 'String' has no member 'substring'\n            count += how_many_times(string.substring(char),\
    \ substring)\n                                    ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var index = string.startIndex\n   \
    \ while index != string.endIndex {\n        index = string.index(substring, startIndex:\
    \ index + 1)\n        if index != string.endIndex {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvctigddj.swift:7:53: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        index = string.index(substring, startIndex:\
    \ index + 1)\n                                                    ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ error: no exact matches in call to instance method 'index'\n        index =\
    \ string.index(substring, startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n/tmp/tmpvctigddj.swift:7:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        index = string.index(substring,\
    \ startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var last = 0\n    for index in string.indices(of:\
    \ substring) {\n        guard let start = string.index(index, offsetBy: 0) else\
    \ {\n            return count\n        }\n        guard let end = string.index(index,\
    \ offsetBy: substring.length) else {\n            return count\n        }\n  \
    \      if start < last {\n            count += 1\n        }\n        last = end\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr7fk9w9i.swift:6:25: error: cannot call value of non-function type\
    \ 'DefaultIndices<String>'\n    for index in string.indices(of: substring) {\n\
    \                        ^\n/tmp/tmpr7fk9w9i.swift:10:65: error: value of type\
    \ 'String' has no member 'length'\n        guard let end = string.index(index,\
    \ offsetBy: substring.length) else {\n                                       \
    \               ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var last = 0\n    for index in 0..<string.characters.count\
    \ {\n        let start = string.index(string.startIndex, offsetBy: index)\n  \
    \      let end = string.index(start, offsetBy: substring.characters.count)\n \
    \       if string.substring(with: start..<end) == substring {\n            count\
    \ += 1\n            last = index\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpp1pezpl6.swift:6:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpp1pezpl6.swift:8:59: error: 'characters' is unavailable: Please use\
    \ String directly\n        let end = string.index(start, offsetBy: substring.characters.count)\n\
    \                                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpp1pezpl6.swift:9:19: error: value of\
    \ type 'String' has no member 'substring'\n        if string.substring(with: start..<end)\
    \ == substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n        }\n    \
    \    if char == substring.last {\n            count += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpak8l_dtx.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    while i < j {\n        if string.characters.contains(substring) {\n     \
    \       count += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplzxnnq01.swift:6:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmplzxnnq01.swift:8:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters.contains(substring)\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplzxnnq01.swift:6:9: warning: variable 'j' was never mutated; consider\
    \ changing to 'let' constant\n    var j = string.characters.count\n    ~~~ ^\n\
    \    let\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \n    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\
    \ + substring.count\n        count += 1\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpox97usud.swift:9:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var index = string.startIndex\n   \
    \ while index != string.endIndex {\n        if string.substring(index, string.endIndex)\
    \ == substring {\n            count += 1\n        }\n        index = string.index(index,\
    \ offsetBy: 1)\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp217phdut.swift:7:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.endIndex) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyaeeulmh.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n/tmp/tmpyaeeulmh.swift:8:26:\
    \ error: instance method 'contains' requires the types 'Unicode.Scalar' and 'String.Element'\
    \ (aka 'Character') be equivalent\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n                         ^\n_StringProcessing.Collection:3:17: note: where\
    \ 'Self.Element' = 'Unicode.Scalar', 'C.Element' = 'String.Element' (aka 'Character')\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var index = string.startIndex\n   \
    \ while index != string.endIndex {\n        index = string.index(substring, startIndex:\
    \ index + 1)\n        if index != string.endIndex {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvctigddj.swift:7:53: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        index = string.index(substring, startIndex:\
    \ index + 1)\n                                                    ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ error: no exact matches in call to instance method 'index'\n        index =\
    \ string.index(substring, startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n/tmp/tmpvctigddj.swift:7:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        index = string.index(substring,\
    \ startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring {\n            count +=\
    \ 1\n            i += substring.length - 1\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp57j_5ohm.swift:8:18: error: no exact matches in call to subscript\
    \ \n        if string[i] == substring {\n                 ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmp57j_5ohm.swift:10:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring.characters.first {\n            count += 1\n\
    \        }\n        if char == substring.characters.last {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3axrafkj.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9qk7pqn.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvktbgaw1.swift:6:23: error: type '((Unicode.Scalar) throws -> Bool)\
    \ throws -> Unicode.Scalar?' cannot conform to 'BinaryInteger'\n        if char.value\
    \ == substring.unicodeScalars.first {\n                      ^\n/tmp/tmpvktbgaw1.swift:6:23:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if char.value == substring.unicodeScalars.first {\n     \
    \                 ^\n/tmp/tmpvktbgaw1.swift:6:23: note: required by operator function\
    \ '==' where 'Other' = '((Unicode.Scalar) throws -> Bool) throws -> Unicode.Scalar?'\n\
    \        if char.value == substring.unicodeScalars.first {\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += 1\n       \
    \     if char == substring.characters[1] {\n                count += 1\n     \
    \       }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp015i27an.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp015i27an.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp015i27an.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp015i27an.swift:8:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if char == substring.characters[1] {\n                       ^~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp015i27an.swift:8:34:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if char == substring.characters[1] {\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first?.value {\n          \
    \  count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: Exception
  stderr: 'tmppj8jledw/tmppj8jledw.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30c3d6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30c3a64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30c3a64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30c3a637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppj8jledw                        0x0000560e5234d734 <unavailable> + 5940

    5    libc.so.6                          0x00002b30c3f59460 __libc_start_main +
    245

    6    tmppj8jledw                        0x0000560e5234d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        } else {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0894diho.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0894diho.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0894diho.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0894diho.swift:7:36: error: missing argument labels\
    \ 'string:substring:' in call\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                   ^\n                         \
    \           string:                                                          \
    \                         substring: \n/tmp/tmp0894diho.swift:7:44: error: value\
    \ of type 'String' has no member 'substringWithRange'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0894diho.swift:7:88: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                                               \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0894diho.swift:9:36: error: missing\
    \ argument labels 'str"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reverse()\
    \ {\n        if char == substring.characters.first {\n            count += 1\n\
    \        }\n        if char == substring.characters.last {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3axrafkj.swift:5:35: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in string.characters.reverse() {\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var index = string.startIndex\n   \
    \ while index != string.endIndex {\n        index = string.index(substring, startIndex:\
    \ index + 1)\n        if index != string.endIndex {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvctigddj.swift:7:53: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        index = string.index(substring, startIndex:\
    \ index + 1)\n                                                    ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ error: no exact matches in call to instance method 'index'\n        index =\
    \ string.index(substring, startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n/tmp/tmpvctigddj.swift:7:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        index = string.index(substring,\
    \ startIndex: index + 1)\n                       ^\n/tmp/tmpvctigddj.swift:7:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        index = string.index(substring, startIndex: index + 1)\n     \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += substring.length\n\
    \        }\n        if char == substring.last {\n            count += substring.length\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp18f0p869.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp18f0p869.swift:7:32:\
    \ error: value of type 'String' has no member 'length'\n            count += substring.length\n\
    \                     ~~~~~~~~~ ^~~~~~\n/tmp/tmp18f0p869.swift:10:32: error: value\
    \ of type 'String' has no member 'length'\n            count += substring.length\n\
    \                     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptsb9o44u.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptsb9o44u.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmptsb9o44u.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let middle = start + (end - start) / 2\n   \
    \     if string.index(of: substring, range: NSRange(location: middle, length:\
    \ substring.length)) != nil {\n            count += 1\n        }\n        start\
    \ = middle\n        end = middle\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd8q1a3dd.swift:9:47: error: cannot find 'NSRange' in scope\n  \
    \      if string.index(of: substring, range: NSRange(location: middle, length:\
    \ substring.length)) != nil {\n                                              ^~~~~~~\n\
    /tmp/tmpd8q1a3dd.swift:9:47: error: extra argument 'range' in call\n        if\
    \ string.index(of: substring, range: NSRange(location: middle, length: substring.length))\
    \ != nil {\n                       ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd8q1a3dd.swift:9:29: error: cannot convert value of type 'String' to expected\
    \ argument type 'String.Element' (aka 'Character')\n        if string.index(of:\
    \ substring, range: NSRange(location: middle, length: substring.length)) != nil\
    \ {\n                            ^\n/tmp/tmpd8q1a3dd.swift:9:91: error: value\
    \ of type 'String' has no member 'length'\n        if string.index(of: substring,\
    \ range: NSRange(location: middle, length: substring.length)) != nil {\n     \
    \                                                                           ~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        } else if\
    \ string.hasPrefix(char) {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphdgj9kzw.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphdgj9kzw.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmphdgj9kzw.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n/tmp/tmphdgj9kzw.swift:8:36: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        } else if string.hasPrefix(char) {\n                                \
    \   ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring {\n            count +=\
    \ 1\n            i += substring.length - 1\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp57j_5ohm.swift:8:18: error: no exact matches in call to subscript\
    \ \n        if string[i] == substring {\n                 ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmp57j_5ohm.swift:10:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n            if char\
    \ == substring.last {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4tth8jj.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first?.value {\n          \
    \  count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: Exception
  stderr: 'tmppj8jledw/tmppj8jledw.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30c3d6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30c3a64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30c3a64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30c3a637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppj8jledw                        0x0000560e5234d734 <unavailable> + 5940

    5    libc.so.6                          0x00002b30c3f59460 __libc_start_main +
    245

    6    tmppj8jledw                        0x0000560e5234d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var startIndex = string.startIndex\n\
    \    var endIndex = string.endIndex\n    while startIndex < endIndex {\n     \
    \   let range = Range(startIndex, endIndex)\n        if string.range(of: substring,\
    \ options: .caseInsensitive) != nil {\n            count += 1\n        }\n   \
    \     startIndex = range.lowerBound\n        endIndex = range.upperBound\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi6oamt48.swift:8:26: error: initializer expects a single parameter\
    \ of type '(lower: Bound, upper: Bound)' [with Bound = String.Index]\n       \
    \ let range = Range(startIndex, endIndex)\n                         ^~~~~~~~~~~~~~~~~~~~~~\n\
    \                          (                   )\n/tmp/tmpi6oamt48.swift:9:19:\
    \ error: value of type 'String' has no member 'range'\n        if string.range(of:\
    \ substring, options: .caseInsensitive) != nil {\n           ~~~~~~ ^~~~~\n/tmp/tmpi6oamt48.swift:9:50:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \        if string.range(of: substring, options: .caseInsensitive) != nil {\n\
    \                                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first?.value {\n          \
    \  count += 1\n            if char.value == substring.unicodeScalars.last?.value\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: Exception
  stderr: 'tmpfa1mqu3u/tmpfa1mqu3u.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a4f1ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a4eec3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a4eec3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a4eec27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfa1mqu3u                        0x000055b2939626e2 <unavailable> + 5858

    5    libc.so.6                          0x00002b9a4f3b8460 __libc_start_main +
    245

    6    tmpfa1mqu3u                        0x000055b293962259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            return count\n        }\n        if let\
    \ index = index {\n            start = index\n        } else {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8xomt1gt.swift:8:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        } else if\
    \ char == substring.reversed() {\n            count -= 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv9o8crk0.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv9o8crk0.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpv9o8crk0.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n/tmp/tmpv9o8crk0.swift:8:24: error: binary operator '==' cannot\
    \ be applied to operands of type 'String.Element' (aka 'Character') and '[String.Element]'\
    \ (aka 'Array<Character>')\n        } else if char == substring.reversed() {\n\
    \                  ~~~~ ^  ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv9o8crk0.swift:8:24:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character)\n        } else if char == substring.reversed() {\n \
    \                      ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        } else {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0894diho.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0894diho.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0894diho.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0894diho.swift:7:36: error: missing argument labels\
    \ 'string:substring:' in call\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                   ^\n                         \
    \           string:                                                          \
    \                         substring: \n/tmp/tmp0894diho.swift:7:44: error: value\
    \ of type 'String' has no member 'substringWithRange'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0894diho.swift:7:88: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                                               \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0894diho.swift:9:36: error: missing\
    \ argument labels 'str"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvktbgaw1.swift:6:23: error: type '((Unicode.Scalar) throws -> Bool)\
    \ throws -> Unicode.Scalar?' cannot conform to 'BinaryInteger'\n        if char.value\
    \ == substring.unicodeScalars.first {\n                      ^\n/tmp/tmpvktbgaw1.swift:6:23:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if char.value == substring.unicodeScalars.first {\n     \
    \                 ^\n/tmp/tmpvktbgaw1.swift:6:23: note: required by operator function\
    \ '==' where 'Other' = '((Unicode.Scalar) throws -> Bool) throws -> Unicode.Scalar?'\n\
    \        if char.value == substring.unicodeScalars.first {\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n        } else {\n            count += how_many_times(string.substringWithRange(NSMakeRange(char,\
    \ 1)), substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4460nd8.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpb4460nd8.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpb4460nd8.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb4460nd8.swift:7:63: error: cannot find 'NSMakeRange'\
    \ in scope\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                                       \
    \       ^~~~~~~~~~~\n/tmp/tmpb4460nd8.swift:7:36: error: missing argument labels\
    \ 'string:substring:' in call\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                   ^\n                 \
    \                   string:                                          substring:\
    \ \n/tmp/tmpb4460nd8.swift:7:44: error: value of type 'String' has no member 'substringWithRange'\n\
    \            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb4460nd8.swift:9:63: error: cannot find 'NSMakeRange' in scope\n     \
    \       count += how_many_times(string.substringWithRange(NSMakeRange(char, 1)),\
    \ substring)\n                                                              ^~~~~~~~~~~\n\
    /tmp/tmpb4460nd8.swift:9:36: err"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n        } else {\n            count += how_many_times(string.substringWithRange(NSMakeRange(char,\
    \ 1)), substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4460nd8.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpb4460nd8.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpb4460nd8.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb4460nd8.swift:7:63: error: cannot find 'NSMakeRange'\
    \ in scope\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                                       \
    \       ^~~~~~~~~~~\n/tmp/tmpb4460nd8.swift:7:36: error: missing argument labels\
    \ 'string:substring:' in call\n            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                   ^\n                 \
    \                   string:                                          substring:\
    \ \n/tmp/tmpb4460nd8.swift:7:44: error: value of type 'String' has no member 'substringWithRange'\n\
    \            count += how_many_times(string.substringWithRange(NSMakeRange(0,\
    \ char)), substring)\n                                    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb4460nd8.swift:9:63: error: cannot find 'NSMakeRange' in scope\n     \
    \       count += how_many_times(string.substringWithRange(NSMakeRange(char, 1)),\
    \ substring)\n                                                              ^~~~~~~~~~~\n\
    /tmp/tmpb4460nd8.swift:9:36: err"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptsb9o44u.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptsb9o44u.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmptsb9o44u.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters.reversed()\
    \ {\n        if char == substring {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptsb9o44u.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptsb9o44u.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmptsb9o44u.swift:6:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \       } else {\n            count += 1\n            startIndex = endIndex +\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqb5zsp90.swift:8:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpqb5zsp90.swift:8:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpqb5zsp90.swift:8:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \       } else {\n            count += endIndex - startIndex\n        }\n    \
    \    startIndex = endIndex + 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw6r77q5g.swift:8:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpw6r77q5g.swift:8:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpw6r77q5g.swift:8:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvktbgaw1.swift:6:23: error: type '((Unicode.Scalar) throws -> Bool)\
    \ throws -> Unicode.Scalar?' cannot conform to 'BinaryInteger'\n        if char.value\
    \ == substring.unicodeScalars.first {\n                      ^\n/tmp/tmpvktbgaw1.swift:6:23:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if char.value == substring.unicodeScalars.first {\n     \
    \                 ^\n/tmp/tmpvktbgaw1.swift:6:23: note: required by operator function\
    \ '==' where 'Other' = '((Unicode.Scalar) throws -> Bool) throws -> Unicode.Scalar?'\n\
    \        if char.value == substring.unicodeScalars.first {\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n            if char\
    \ == substring.last {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4tth8jj.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n            if char\
    \ == substring.last {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4tth8jj.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char.value == substring.unicodeScalars.first {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvktbgaw1.swift:6:23: error: type '((Unicode.Scalar) throws -> Bool)\
    \ throws -> Unicode.Scalar?' cannot conform to 'BinaryInteger'\n        if char.value\
    \ == substring.unicodeScalars.first {\n                      ^\n/tmp/tmpvktbgaw1.swift:6:23:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if char.value == substring.unicodeScalars.first {\n     \
    \                 ^\n/tmp/tmpvktbgaw1.swift:6:23: note: required by operator function\
    \ '==' where 'Other' = '((Unicode.Scalar) throws -> Bool) throws -> Unicode.Scalar?'\n\
    \        if char.value == substring.unicodeScalars.first {\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if substring.unicodeScalars.contains(c) {\n            count += 1\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: Exception
  stderr: 'tmpnc72k486/tmpnc72k486.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc38eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc35e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc35e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc35e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc72k486                        0x00005614ca717724 <unavailable> + 5924

    5    libc.so.6                          0x00002b9cc3ada460 __libc_start_main +
    245

    6    tmpnc72k486                        0x00005614ca717199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        } else {\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0894diho.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0894diho.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0894diho.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0894diho.swift:7:36: error: missing argument labels\
    \ 'string:substring:' in call\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                   ^\n                         \
    \           string:                                                          \
    \                         substring: \n/tmp/tmp0894diho.swift:7:44: error: value\
    \ of type 'String' has no member 'substringWithRange'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0894diho.swift:7:88: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n            count += how_many_times(string.substringWithRange(string[string.startIndex.advancedBy(count)..<string.endIndex]),\
    \ substring)\n                                                               \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0894diho.swift:9:36: error: missing\
    \ argument labels 'str"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for c in string.unicodeScalars {\n\
    \        if c == substring {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpfulg0c.swift:6:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            return count\n        }\n        start\
    \ = index!.advanced(by: substring.count)\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp36a3qvd7.swift:8:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.characters[0] {\n            count += 1\n       \
    \ }\n        if char == substring.characters[substring.characters.count - 1] {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph75btwbs.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmph75btwbs.swift:6:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if char == substring.characters[0] {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmph75btwbs.swift:6:30: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == substring.characters[0]\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph75btwbs.swift:9:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ char == substring.characters[substring.characters.count - 1] {\n           \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph75btwbs.swift:9:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        if char\
    \ == substring.characters[substring.characters.count - 1] {\n                \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmph75btwbs.swift:9:51: error: 'characters' is unavailable: Please use\
    \ String directly\n        if char == substring.characters[substring.characters.count\
    \ - 1] {\n                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Stri"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.unicodeScalars {\n\
    \        if char == substring {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc1gwlndr.swift:6:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    while\
    \ i < string.count {\n        j = string.index(substring, i)\n        if j ==\
    \ nil {\n            break\n        }\n        count = count + 1\n        i =\
    \ j!.advanced(by: 1)\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp11ua1vj5.swift:8:20: error: no exact matches in call to instance\
    \ method 'index'\n        j = string.index(substring, i)\n                   ^\n\
    /tmp/tmp11ua1vj5.swift:8:20: note: found candidate with type '(String.Index, Int)\
    \ -> String.Index'\n        j = string.index(substring, i)\n                 \
    \  ^\n/tmp/tmp11ua1vj5.swift:8:20: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        j = string.index(substring, i)\n            ~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp11ua1vj5.swift:9:14: warning: comparing non-optional value of type 'Int'\
    \ to 'nil' always returns false\n        if j == nil {\n           ~ ^  ~~~\n\
    /tmp/tmp11ua1vj5.swift:13:14: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n        i = j!.advanced(by: 1)\n            ~^\n             \n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring.first {\n            count += 1\n            if char\
    \ == substring.last {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb4tth8jj.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string {\n        if char\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqf_9go6q.swift:6:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpqf_9go6q.swift:6:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = string.startIndex\n   \
    \ var end = string.endIndex\n    while start < end {\n        start = string.index(start,\
    \ offsetBy: substring.startIndex, limitedBy: end) ?? end\n        end = string.index(end,\
    \ offsetBy: substring.endIndex, limitedBy: start) ?? start\n        if start <\
    \ end {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0bah9799.swift:8:17: error: instance method 'index(_:offsetBy:limitedBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n        start = string.index(start,\
    \ offsetBy: substring.startIndex, limitedBy: end) ?? end\n                ^\n\
    Swift.Collection:7:17: note: where 'T' = 'String.Index'\n    public func index<T>(_\
    \ i: Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Self.Index? where\
    \ T : BinaryInteger\n                ^\n/tmp/tmp0bah9799.swift:9:15: error: instance\
    \ method 'index(_:offsetBy:limitedBy:)' requires that 'String.Index' conform to\
    \ 'BinaryInteger'\n        end = string.index(end, offsetBy: substring.endIndex,\
    \ limitedBy: start) ?? start\n              ^\nSwift.Collection:7:17: note: where\
    \ 'T' = 'String.Index'\n    public func index<T>(_ i: Self.Index, offsetBy n:\
    \ T, limitedBy limit: Self.Index) -> Self.Index? where T : BinaryInteger\n   \
    \             ^\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \n    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppx9zrh1u.swift:9:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n    var count = 0\n    for char in string.characters {\n \
    \       if char == substring {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpph0s2s0t.swift:5:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpph0s2s0t.swift:6:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpph0s2s0t.swift:6:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009276
