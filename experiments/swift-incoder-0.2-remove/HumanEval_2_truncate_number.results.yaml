language: swift
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number).rounded(.towardZero)\n   \
    \ return integerPart * pow(10, Double(log10(Double(number))) + 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpycr1d222.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpycr1d222.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmpycr1d222.swift:8:46: error: cannot infer contextual base in\
    \ reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n/tmp/tmpycr1d222.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                         ^~~\n/tmp/tmpycr1d222.swift:9:41: error: cannot\
    \ find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ (number as NSNumber).doubleValue\n    let decimalPart = number - intPart\n \
    \   return intPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp19pwn82n.swift:7:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmp19pwn82n.swift:7:40: error: value of type 'Double' has\
    \ no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\n\
    \                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp19pwn82n.swift:9:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return intPart + decimalPart\n           ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicwg650y.swift:7:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ Int(number)\n    let decimalPart = number - intPart\n    return intPart + decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_yckfr2x.swift:8:30: error: binary operator '-' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n    let decimalPart = number - intPart\n\
    \                      ~~~~~~ ^ ~~~~~~~\n/tmp/tmp_yckfr2x.swift:8:30: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let decimalPart = number - intPart\n                       \
    \      ^\n/tmp/tmp_yckfr2x.swift:9:20: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n    return intPart + decimalPart\n  \
    \         ~~~~~~~~^~~~~~~~~~~~~\n           Double(              )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        integerPart\
    \ = -integerPart\n    }\n    if integerPart < 10 {\n        decimalPart = decimalPart\
    \ / 10\n    }\n    return decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpkfi7rrpj/tmpkfi7rrpj.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d4f07bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d4ed72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d4ed72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d4ed717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfi7rrpj                        0x000055e764c451c5 <unavailable> + 4549

    5    libc.so.6                          0x00002b4d4f267460 __libc_start_main +
    245

    6    tmpkfi7rrpj                        0x000055e764c44e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = number - fraction\n    return whole < 0 ? whole\
    \ + 1 : whole\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpc5te78ug.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    let whole = Int(number)\n\
    \    let decimal = number - Double(whole)\n    return whole + decimal\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmls47h8h.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpmls47h8h.swift:12:12:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \    return whole + decimal\n           ^\n           Double( )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        integerPart\
    \ = -integerPart\n        decimalPart = -decimalPart\n    }\n    let decimalPartIndex\
    \ = Double(integerPart).truncatingRemainder(dividingBy: 1)\n    guard decimalPartIndex\
    \ != 0 else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 1) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 2) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 3) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 4) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 5) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 6) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 7) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 8) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 9) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 10) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 11) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 12) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 13) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 14) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 15) else { return number }\n    guard decimalPartIndex < Double(integerPart).truncatingRemainder(dividingBy:\
    \ 16) else { return number }\n    guard decimalPartIndex < Double(integerPart).trun\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpd4v1m99i.swift:31:54: error: expected 'else' after 'guard' condition\n\
    \    guard decimalPartIndex < Double(integerPart).trun\n                     \
    \                                ^\n/tmp/tmpd4v1m99i.swift:31:50: error: value\
    \ of type 'Double' has no member 'trun'\n    guard decimalPartIndex < Double(integerPart).trun\n\
    \                             ~~~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuoqouqln.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpuoqouqln.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpuoqouqln.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ (number as NSNumber).doubleValue\n    let decimalPart = number - intPart\n \
    \   return intPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp19pwn82n.swift:7:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmp19pwn82n.swift:7:40: error: value of type 'Double' has\
    \ no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\n\
    \                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp19pwn82n.swift:9:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return intPart + decimalPart\n           ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number).rounded(.towardZero)\n   \
    \ return integerPart * pow(10, Double(log10(Double(number))) + 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpycr1d222.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpycr1d222.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmpycr1d222.swift:8:46: error: cannot infer contextual base in\
    \ reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n/tmp/tmpycr1d222.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                         ^~~\n/tmp/tmpycr1d222.swift:9:41: error: cannot\
    \ find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number) - 1\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcexch7z0.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpcexch7z0.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number) - 1\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    var decimalPart = number\n\
    \    var integerPart = Double(trunc(number))\n    var decimalsLeft = Double(trunc(log10(number)))\n\
    \    if decimalsLeft > 0 {\n        decimalPart = Double(trunc(number * pow(10.0,\
    \ Double(decimalsLeft))))\n    }\n    return decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpo49_8msa.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpo49_8msa.swift:11:30:\
    \ error: cannot find 'trunc' in scope\n    var integerPart = Double(trunc(number))\n\
    \                             ^~~~~\n/tmp/tmpo49_8msa.swift:12:31: error: cannot\
    \ find 'trunc' in scope\n    var decimalsLeft = Double(trunc(log10(number)))\n\
    \                              ^~~~~\n/tmp/tmpo49_8msa.swift:12:37: error: cannot\
    \ find 'log10' in scope\n    var decimalsLeft = Double(trunc(log10(number)))\n\
    \                                    ^~~~~\n/tmp/tmpo49_8msa.swift:14:30: error:\
    \ cannot find 'trunc' in scope\n        decimalPart = Double(trunc(number * pow(10.0,\
    \ Double(decimalsLeft))))\n                             ^~~~~\n/tmp/tmpo49_8msa.swift:14:45:\
    \ error: cannot find 'pow' in scope\n        decimalPart = Double(trunc(number\
    \ * pow(10.0, Double(decimalsLeft))))\n                                      \
    \      ^~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_helper(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpto6dp4f5.swift:7:30: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimal) = truncate_number_helper(number)\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(abs(number))) + 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphfvb81pk.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphfvb81pk.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmphfvb81pk.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(abs(number)))\
    \ + 1)\n                         ^~~\n/tmp/tmphfvb81pk.swift:9:41: error: cannot\
    \ find 'log10' in scope\n    return integerPart * pow(10, Double(log10(abs(number)))\
    \ + 1)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_helper(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpto6dp4f5.swift:7:30: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimal) = truncate_number_helper(number)\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var result =\
    \ number\n    let decimalPart = number % 1\n    if decimalPart > 0 {\n       \
    \ result = result - decimalPart\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpncwp6rp9.swift:8:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuoqouqln.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpuoqouqln.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpuoqouqln.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicwg650y.swift:7:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ (number as NSNumber).doubleValue\n    let decimalPart = (number - intPart).truncatingRemainder(dividingBy:\
    \ 1)\n    return intPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp91olqb_r.swift:7:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmp91olqb_r.swift:7:40: error: value of type 'Double' has\
    \ no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\n\
    \                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp91olqb_r.swift:9:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return intPart + decimalPart\n           ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    let\
    \ integerPart = Double(truncatingIfNeeded: decimalPart)\n    return integerPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjkrppe60.swift:11:23: error: no exact matches in call to initializer\
    \ \n    let integerPart = Double(truncatingIfNeeded: decimalPart)\n          \
    \            ^\nSwift.Double:11:23: note: incorrect labels for candidate (have:\
    \ '(truncatingIfNeeded:)', expected: '(_:)')\n    @inlinable public init(_ other:\
    \ Double)\n                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect\
    \ labels for candidate (have: '(truncatingIfNeeded:)', expected: '(_:)')\n   \
    \ @inlinable public init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_with_precision(number, precision: Double(10))\n \
    \   return Double(integer) + Double(decimal)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp3r1wj00z.swift:7:30: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    let (integer, decimal) = truncate_number_with_precision(number,\
    \ precision: Double(10))\n                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var result: Double\
    \ = number\n    let decimalPart = Double(truncatingBitPattern: number - floor(number))\n\
    \    if decimalPart < 1 {\n        result = floor(number) + decimalPart\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp34q1q3a6.swift:8:61: error: cannot find 'floor' in scope\n    let\
    \ decimalPart = Double(truncatingBitPattern: number - floor(number))\n       \
    \                                                     ^~~~~\n/tmp/tmp34q1q3a6.swift:8:23:\
    \ error: no exact matches in call to initializer \n    let decimalPart = Double(truncatingBitPattern:\
    \ number - floor(number))\n                      ^\n/tmp/tmp34q1q3a6.swift:8:23:\
    \ note: found candidate with type '(Double) -> Double'\n    let decimalPart =\
    \ Double(truncatingBitPattern: number - floor(number))\n                     \
    \ ^\n/tmp/tmp34q1q3a6.swift:10:18: error: cannot find 'floor' in scope\n     \
    \   result = floor(number) + decimalPart\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = Int(number)\n    return whole + fraction\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphkjvzrwh.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphkjvzrwh.swift:9:12: error: cannot convert value of type\
    \ 'Int' to expected argument type 'Double'\n    return whole + fraction\n    \
    \       ^\n           Double( )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_helper(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpto6dp4f5.swift:7:30: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimal) = truncate_number_helper(number)\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        decimalPart\
    \ = -number\n        integerPart = -integerPart\n    }\n    return Double(integerPart)\
    \ / Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpdf24vg3z/tmpdf24vg3z.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeee9506c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeee91fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeee91fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeee91fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdf24vg3z                        0x0000561d4ed7a215 <unavailable> + 4629

    5    libc.so.6                          0x00002aeee96f2460 __libc_start_main +
    245

    6    tmpdf24vg3z                        0x0000561d4ed79eb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    if number == 0.0 {\n\
    \        return 0.0\n    }\n    if number < 1.0 {\n        return number\n   \
    \ }\n    var decimalPart = number\n    var integerPart = floor(number)\n    if\
    \ integerPart == number {\n        return number\n    }\n    if integerPart <\
    \ 1.0 {\n        return truncate_number(integerPart * 10 + 0.5)\n    }\n    decimalPart\
    \ = truncate_number(decimalPart / 10.0)\n    if decimalPart < 1.0 {\n        return\
    \ truncate_number(integerPart + decimalPart)\n    }\n    return truncate_number(integerPart\
    \ + 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpe1a4v9di.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpe1a4v9di.swift:17:23:\
    \ error: cannot find 'floor' in scope\n    var integerPart = floor(number)\n \
    \                     ^~~~~\n/tmp/tmpe1a4v9di.swift:22:32: error: missing argument\
    \ label 'number:' in call\n        return truncate_number(integerPart * 10 + 0.5)\n\
    \                               ^\n                               number: \n/tmp/tmpe1a4v9di.swift:24:35:\
    \ error: missing argument label 'number:' in call\n    decimalPart = truncate_number(decimalPart\
    \ / 10.0)\n                                  ^\n                             \
    \     number: \n/tmp/tmpe1a4v9di.swift:26:32: error: missing argument label 'number:'\
    \ in call\n        return truncate_number(integerPart + decimalPart)\n       \
    \                        ^\n                               number: \n/tmp/tmpe1a4v9di.swift:28:28:\
    \ error: missing argument label 'number:' in call\n    return truncate_number(integerPart\
    \ + 0.5)\n                           ^\n                           number: \n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(Int64(number))\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6poflhbj.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var result =\
    \ number\n    var decimals = Double(truncate_double(number))\n    if decimals\
    \ < 1 {\n        result = truncate_double(number) / decimals\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpd0zgj0px.swift:8:27: error: cannot find 'truncate_double' in scope\n\
    \    var decimals = Double(truncate_double(number))\n                        \
    \  ^~~~~~~~~~~~~~~\n/tmp/tmpd0zgj0px.swift:10:18: error: cannot find 'truncate_double'\
    \ in scope\n        result = truncate_double(number) / decimals\n            \
    \     ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_decimal(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph34aydu7.swift:7:30: error: cannot find 'truncate_number_decimal'\
    \ in scope\n    let (integer, decimal) = truncate_number_decimal(number)\n   \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuoqouqln.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpuoqouqln.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpuoqouqln.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ (number as NSNumber).doubleValue\n    let decimalPart = (number - intPart).truncatingRemainder(dividingBy:\
    \ 1)\n    return intPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp91olqb_r.swift:7:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmp91olqb_r.swift:7:40: error: value of type 'Double' has\
    \ no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\n\
    \                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp91olqb_r.swift:9:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return intPart + decimalPart\n           ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicwg650y.swift:7:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_decimal(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph34aydu7.swift:7:30: error: cannot find 'truncate_number_decimal'\
    \ in scope\n    let (integer, decimal) = truncate_number_decimal(number)\n   \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpud1kc2_f.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpud1kc2_f.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicwg650y.swift:7:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = Double(truncatingBitPattern: number % 1)\n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmzq391td.swift:7:23: error: no exact matches in call to initializer\
    \ \n    let decimalPart = Double(truncatingBitPattern: number % 1)\n         \
    \             ^\nSwift.Double:11:23: note: incorrect labels for candidate (have:\
    \ '(truncatingBitPattern:)', expected: '(_:)')\n    @inlinable public init(_ other:\
    \ Double)\n                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect\
    \ labels for candidate (have: '(truncatingBitPattern:)', expected: '(_:)')\n \
    \   @inlinable public init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n\
    \                      ^\n/tmp/tmpmzq391td.swift:8:23: error: no exact matches\
    \ in call to initializer \n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n                      ^\n/tmp/tmpmzq391td.swift:8:23:\
    \ note: found candidate with type '(Double) -> Double'\n    let integerPart =\
    \ Double(truncatingBitPattern: number - decimalPart)\n                      ^\n\
    /tmp/tmpmzq391td.swift:9:24: error: cannot convert return expression of type 'String'\
    \ to return type 'Double'\n    return integerPart + decimalPart\n           ~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let result =\
    \ Double(truncatingBitPattern: number)\n    return result / 10\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdzjg1m8x.swift:7:18: error: no exact matches in call to initializer\
    \ \n    let result = Double(truncatingBitPattern: number)\n                 ^\n\
    Swift.Double:11:23: note: incorrect labels for candidate (have: '(truncatingBitPattern:)',\
    \ expected: '(_:)')\n    @inlinable public init(_ other: Double)\n           \
    \           ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect labels for candidate\
    \ (have: '(truncatingBitPattern:)', expected: '(_:)')\n    @inlinable public init<Source>(_\
    \ value: Source) where Source : BinaryFloatingPoint\n                      ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var result =\
    \ number\n    if number < 0 {\n        result = -number\n    }\n    return Double(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpyg7x_a0w/tmpyg7x_a0w.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b949904cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9498d43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9498d43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9498d427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyg7x_a0w                        0x000055b1ef5ff215 <unavailable> + 4629

    5    libc.so.6                          0x00002b9499238460 __libc_start_main +
    245

    6    tmpyg7x_a0w                        0x000055b1ef5feeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart:\
    \ Double = 0\n    var integerPart: Double = 0\n    var remainder: Double = 0\n\
    \    if number < 0 {\n        number = -number\n    }\n    if number == 0 {\n\
    \        return number\n    }\n    if number < 10 {\n        return number\n \
    \   }\n    if number < 100 {\n        integerPart = number\n    }\n    if number\
    \ < 1000 {\n        decimalPart = number / 10\n        integerPart = number -\
    \ decimalPart * 10\n    }\n    if number < 10000 {\n        decimalPart = number\
    \ / 100\n        integerPart = number - decimalPart * 100\n    }\n    if number\
    \ < 100000 {\n        decimalPart = number / 1000\n        integerPart = number\
    \ - decimalPart * 1000\n    }\n    if number < 1000000 {\n        decimalPart\
    \ = number / 10000\n        integerPart = number - decimalPart * 10000\n    }\n\
    \    if number < 10000000 {\n        decimalPart = number / 100000\n        integerPart\
    \ = number - decimalPart * 100000\n    }\n    if number < 100000000 {\n      \
    \  decimalPart = number / 1000000\n        integerPart = number - decimalPart\
    \ * 1000000\n    }\n    if number < 1000000000 {\n        decimalPart = number\
    \ / 10000000\n        integerPart = number - decimalPart * 10000000\n    }\n \
    \   if number < 10000000000 {\n        decimalPart = number / 100000000\n    \
    \    integerPart = number - decimalPart * 100000000\n    }\n    if number < 100000000000\
    \ {\n        decimalPart = number / 1000000000\n        integerPart = number -\
    \ decimalPart * 1000000000\n    }\n    if number < 1000000000000 {\n        decimalPart\
    \ = number / 10000000000\n        integerPart = number - decimalPart * 10000000000\n\
    \    }\n    if number < 10000000000000 {\n        decimalPart = number / 100000000000\n\
    \        integerPart = number - decimalPart * 100000000000\n    }\n    if number\
    \ < 100000000000000 {\n        decimalPart = number / 1000000000000\n        integerPart\
    \ = number - decimalPart * 1000000000000\n    }\n    if number < 1000000000000000\
    \ {\n        decimalPart = number / 10000000000000\n        integerPart = number\
    \ - decimalPart * 10000000000000\n    }\n    if number < 10000000000000000 {\n\
    \        decimalPart = number / 100000000000000\n        integerPart = number\
    \ - decimalPart * 100000000000000\n    }\n    if number < 100000000000000000 {\n\
    \        decimalPart = number / 1000000000000000\n        integerPart = number\
    \ - decimalPart * 100\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzzr27lzf.swift:98:46: error: expected '}' at end of brace statement\n\
    assert(truncate_number(number: 123.0) == 0.0)\n                              \
    \               ^\n/tmp/tmpzzr27lzf.swift:6:48: note: to match this opening '{'\n\
    func truncate_number(number: Double) -> Double {\n                           \
    \                    ^\n/tmp/tmpzzr27lzf.swift:11:9: error: cannot assign to value:\
    \ 'number' is a 'let' constant\n        number = -number\n        ^~~~~~\n/tmp/tmpzzr27lzf.swift:84:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    var decimalPart = number\n\
    \    var integerPart = number\n    var decimalsCount = 0\n    while decimalPart\
    \ > 1.0 {\n        decimalPart /= 10.0\n        decimalsCount += 1\n    }\n  \
    \  if decimalsCount > 0 {\n        integerPart *= 10\n        integerPart /= decimalsCount\n\
    \    }\n    return integerPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdhmm01p_.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpdhmm01p_.swift:19:24:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        integerPart /= decimalsCount\n                       ^\n            \
    \           Double(      )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_with_precision(number, precision: Double(10))\n \
    \   return Double(integer) + Double(decimal)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp3r1wj00z.swift:7:30: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    let (integer, decimal) = truncate_number_with_precision(number,\
    \ precision: Double(10))\n                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number).rounded(.towardZero)\n   \
    \ return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwj90_sqy.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpwj90_sqy.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmpwj90_sqy.swift:8:46: error: cannot infer contextual base in\
    \ reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let result =\
    \ Double(truncatingBitPattern: number)\n    return result / Double(10).pow(Double(Double.bitWidth))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpeel3uyd8.swift:7:18: error: no exact matches in call to initializer\
    \ \n    let result = Double(truncatingBitPattern: number)\n                 ^\n\
    Swift.Double:11:23: note: incorrect labels for candidate (have: '(truncatingBitPattern:)',\
    \ expected: '(_:)')\n    @inlinable public init(_ other: Double)\n           \
    \           ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect labels for candidate\
    \ (have: '(truncatingBitPattern:)', expected: '(_:)')\n    @inlinable public init<Source>(_\
    \ value: Source) where Source : BinaryFloatingPoint\n                      ^\n\
    /tmp/tmpeel3uyd8.swift:8:32: error: value of type 'Double' has no member 'pow'\n\
    \    return result / Double(10).pow(Double(Double.bitWidth))\n               \
    \     ~~~~~~~~~~ ^~~\n/tmp/tmpeel3uyd8.swift:8:50: error: type 'Double' has no\
    \ member 'bitWidth'\n    return result / Double(10).pow(Double(Double.bitWidth))\n\
    \                                          ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(floor(number))\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjmso5uur.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpjmso5uur.swift:8:30: error: cannot find 'floor' in scope\n\
    \    let integerPart = Double(floor(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(number).truncatingRemainder(dividingBy: 1)\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbyfoioc9.swift:7:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(abs(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpk4xzynu6.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpk4xzynu6.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpk4xzynu6.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(abs(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpk4xzynu6.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(abs(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        decimalPart\
    \ = -number\n        integerPart = -integerPart\n    }\n    return Double(integerPart)\
    \ / Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpdf24vg3z/tmpdf24vg3z.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeee9506c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeee91fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeee91fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeee91fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdf24vg3z                        0x0000561d4ed7a215 <unavailable> + 4629

    5    libc.so.6                          0x00002aeee96f2460 __libc_start_main +
    245

    6    tmpdf24vg3z                        0x0000561d4ed79eb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number).rounded(.towardZero)\n   \
    \ return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwj90_sqy.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpwj90_sqy.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number).rounded(.towardZero)\n                  \
    \    ^~~~~\n/tmp/tmpwj90_sqy.swift:8:46: error: cannot infer contextual base in\
    \ reference to member 'towardZero'\n    let integerPart = floor(number).rounded(.towardZero)\n\
    \                                            ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(floor(number))\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjmso5uur.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpjmso5uur.swift:8:30: error: cannot find 'floor' in scope\n\
    \    let integerPart = Double(floor(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_helper(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpto6dp4f5.swift:7:30: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimal) = truncate_number_helper(number)\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        integerPart\
    \ = -integerPart\n    }\n    if integerPart < 10 {\n        decimalPart *= 10\n\
    \    }\n    if integerPart < 100 {\n        decimalPart /= 10\n    }\n    if integerPart\
    \ < 1000 {\n        decimalPart /= 100\n    }\n    if integerPart < 10000 {\n\
    \        decimalPart /= 1000\n    }\n    if integerPart < 100000 {\n        decimalPart\
    \ /= 10000\n    }\n    if integerPart < 1000000 {\n        decimalPart /= 100000\n\
    \    }\n    if integerPart < 10000000 {\n        decimalPart /= 1000000\n    }\n\
    \    if integerPart < 100000000 {\n        decimalPart /= 10000000\n    }\n  \
    \  if integerPart < 1000000000 {\n        decimalPart /= 100000000\n    }\n  \
    \  if integerPart < 10000000000 {\n        decimalPart /= 1000000000\n    }\n\
    \    if integerPart < 100000000000 {\n        decimalPart /= 10000000000\n   \
    \ }\n    if integerPart < 1000000000000 {\n        decimalPart /= 100000000000\n\
    \    }\n    if integerPart < 10000000000000 {\n        decimalPart /= 1000000000000\n\
    \    }\n    if integerPart < 100000000000000 {\n        decimalPart /= 10000000000000\n\
    \    }\n    if integerPart < 1000000000000000 {\n        decimalPart /= 100000000000000\n\
    \    }\n    if integerPart < 10000000000000000 {\n        decimalPart /= 1000000000000000\n\
    \    }\n    if integerPart < 100000000000000000 {\n        decimalPart /= 10000000000000000\n\
    \    }\n    if integerPart < 1000000000000000000 {\n        decimalPart /= 100000000000000000\n\
    \    }\n    if integerPart < 10000000000000000000 {\n        decimalPart /= 1000000000000000000\n\
    \    }\n    if integerPart < 100000000000000000000 {\n        decimalPart /= 10000000000000000000\n\
    \    }\n    if integerPart < 1000000000000000000000 {\n        decimalPart /=\
    \ 100000000000000000000\n    }\n    if integerPart < 10000000000000000000000 {\n\
    \        decimalPart /= 1000000000000000000000\n    }\n    if integerPart < 100000000000000000000000\
    \ {\n        decimalPart /= 10000000000000000000000\n    }\n    if integerPart\
    \ < 1000000000000000000000000 {\n        decimalPart /= 100000000000000000000000\n\
    \    }\n    if integerPart < 10000000000000000000000000 {\n        decimalPart\
    \ /= 1000000000000000000000000\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6tlgb8vt.swift:85:24: warning: '1000000000000000000000000' is not\
    \ exactly representable as 'Double'; it becomes '999999999999999983222784'\n \
    \       decimalPart /= 1000000000000000000000000\n                       ^\n/tmp/tmp6tlgb8vt.swift:84:22:\
    \ warning: '10000000000000000000000000' is not exactly representable as 'Double';\
    \ it becomes '10000000000000000905969664'\n    if integerPart < 10000000000000000000000000\
    \ {\n                     ^\n/tmp/tmp6tlgb8vt.swift:82:24: warning: '100000000000000000000000'\
    \ is not exactly representable as 'Double'; it becomes '99999999999999991611392'\n\
    \        decimalPart /= 100000000000000000000000\n                       ^\n/tmp/tmp6tlgb8vt.swift:81:22:\
    \ warning: '1000000000000000000000000' is not exactly representable as 'Double';\
    \ it becomes '999999999999999983222784'\n    if integerPart < 1000000000000000000000000\
    \ {\n                     ^\n/tmp/tmp6tlgb8vt.swift:78:22: warning: '100000000000000000000000'\
    \ is not exactly representable as 'Double'; it becomes '99999999999999991611392'\n\
    \    if integerPart < 100000000000000000000000 {\n                     ^\n/tmp/tmp6tlgb8vt.swift:87:1:\
    \ error: missing return in global function expected to return 'Double'\n}\n^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let wholeNumber = number - fraction\n    return wholeNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpfgu8wkcg.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    var decimalPart = number\n\
    \    var integerPart = number\n    var decimalsCount = 0\n    while decimalPart\
    \ > 1.0 {\n        decimalPart /= 10\n        decimalsCount += 1\n    }\n    if\
    \ decimalsCount > 0 {\n        integerPart *= 10\n        integerPart /= decimalsCount\n\
    \    }\n    return integerPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpafqbctbd.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpafqbctbd.swift:19:24:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        integerPart /= decimalsCount\n                       ^\n            \
    \           Double(      )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number))) + 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpgoe1n_c8.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpgoe1n_c8.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpgoe1n_c8.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                         ^~~\n/tmp/tmpgoe1n_c8.swift:9:41: error: cannot\
    \ find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number)))\
    \ + 1)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicwg650y.swift:7:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = truncate_number_helper(number)\n    return Double(integer) + Double(decimal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpto6dp4f5.swift:7:30: error: cannot find 'truncate_number_helper'\
    \ in scope\n    let (integer, decimal) = truncate_number_helper(number)\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var result =\
    \ number\n    if number < 0 {\n        result = -number\n    }\n    let decimalPart\
    \ = Double(Int64(number * pow(10.0, Double(ceil(log10(number)))))) / pow(10.0,\
    \ Double(ceil(log10(number))))\n    return result - decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph4ed5awd.swift:11:45: error: cannot find 'pow' in scope\n    let\
    \ decimalPart = Double(Int64(number * pow(10.0, Double(ceil(log10(number))))))\
    \ / pow(10.0, Double(ceil(log10(number))))\n                                 \
    \           ^~~\n/tmp/tmph4ed5awd.swift:11:62: error: cannot find 'ceil' in scope\n\
    \    let decimalPart = Double(Int64(number * pow(10.0, Double(ceil(log10(number))))))\
    \ / pow(10.0, Double(ceil(log10(number))))\n                                 \
    \                            ^~~~\n/tmp/tmph4ed5awd.swift:11:67: error: cannot\
    \ find 'log10' in scope\n    let decimalPart = Double(Int64(number * pow(10.0,\
    \ Double(ceil(log10(number)))))) / pow(10.0, Double(ceil(log10(number))))\n  \
    \                                                                ^~~~~\n/tmp/tmph4ed5awd.swift:11:88:\
    \ error: cannot find 'pow' in scope\n    let decimalPart = Double(Int64(number\
    \ * pow(10.0, Double(ceil(log10(number)))))) / pow(10.0, Double(ceil(log10(number))))\n\
    \                                                                            \
    \           ^~~\n/tmp/tmph4ed5awd.swift:11:105: error: cannot find 'ceil' in scope\n\
    \    let decimalPart = Double(Int64(number * pow(10.0, Double(ceil(log10(number))))))\
    \ / pow(10.0, Double(ceil(log10(number))))\n                                 \
    \                                                                       ^~~~\n\
    /tmp/tmph4ed5awd.swift:11:110: error: cannot find 'log10' in scope\n    let decimalPart\
    \ = Double(Int64(number * pow(10.0, Double(ceil(log10(number)))))) / pow(10.0,\
    \ Double(ceil(log10(number))))\n                                             \
    \                                                                ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + Double(decimal)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpfefrxkbu.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpfefrxkbu.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpfefrxkbu.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(trunc(Double(decimalPart)))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxn46i_r3.swift:11:19: error: cannot find 'trunc' in scope\n   \
    \ return Double(trunc(Double(decimalPart)))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart *\
    \ pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmskubfo4.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpmskubfo4.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpmskubfo4.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmpmskubfo4.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = Double(truncatingBitPattern: number % 1)\n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmzq391td.swift:7:23: error: no exact matches in call to initializer\
    \ \n    let decimalPart = Double(truncatingBitPattern: number % 1)\n         \
    \             ^\nSwift.Double:11:23: note: incorrect labels for candidate (have:\
    \ '(truncatingBitPattern:)', expected: '(_:)')\n    @inlinable public init(_ other:\
    \ Double)\n                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect\
    \ labels for candidate (have: '(truncatingBitPattern:)', expected: '(_:)')\n \
    \   @inlinable public init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n\
    \                      ^\n/tmp/tmpmzq391td.swift:8:23: error: no exact matches\
    \ in call to initializer \n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n                      ^\n/tmp/tmpmzq391td.swift:8:23:\
    \ note: found candidate with type '(Double) -> Double'\n    let integerPart =\
    \ Double(truncatingBitPattern: number - decimalPart)\n                      ^\n\
    /tmp/tmpmzq391td.swift:9:24: error: cannot convert return expression of type 'String'\
    \ to return type 'Double'\n    return integerPart + decimalPart\n           ~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let result =\
    \ Double(trunc(number))\n    if number < 0 {\n        return -result\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpe3_sjh_k.swift:7:25: error: cannot find 'trunc' in scope\n    let\
    \ result = Double(trunc(number))\n                        ^~~~~\n/tmp/tmpe3_sjh_k.swift:9:16:\
    \ error: cannot convert return expression of type 'Float16' to return type 'Double'\n\
    \        return -result\n               ^~~~~~~\n               Double()\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuoqouqln.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpuoqouqln.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpuoqouqln.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = Double(number).truncatingRemainder(dividingBy: 1)\n    return Double(number)\
    \ - decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpu1l5l244/tmpu1l5l244.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b643b08bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b643ad82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b643ad82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b643ad817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu1l5l244                        0x000055cdae8822f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b643b277460 __libc_start_main +
    245

    6    tmpu1l5l244                        0x000055cdae881f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ Int(number)\n    let decimalPart = number - intPart\n    return intPart + decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_yckfr2x.swift:8:30: error: binary operator '-' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n    let decimalPart = number - intPart\n\
    \                      ~~~~~~ ^ ~~~~~~~\n/tmp/tmp_yckfr2x.swift:8:30: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let decimalPart = number - intPart\n                       \
    \      ^\n/tmp/tmp_yckfr2x.swift:9:20: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n    return intPart + decimalPart\n  \
    \         ~~~~~~~~^~~~~~~~~~~~~\n           Double(              )\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_upknbwy.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp_upknbwy.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n/tmp/tmp_upknbwy.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmp_upknbwy.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(truncating: number).rounded(.towardZero)\n\
    \    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1hw7zv3o.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp1hw7zv3o.swift:8:23: error: no exact matches in call to\
    \ initializer \n    let integerPart = Double(truncating: number).rounded(.towardZero)\n\
    \                      ^\nSwift.Double:11:23: note: incorrect labels for candidate\
    \ (have: '(truncating:)', expected: '(_:)')\n    @inlinable public init(_ other:\
    \ Double)\n                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect\
    \ labels for candidate (have: '(truncating:)', expected: '(_:)')\n    @inlinable\
    \ public init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n  \
    \                    ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * pow(10, Double(log10(Double(number)))) + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_upknbwy.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp_upknbwy.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n/tmp/tmp_upknbwy.swift:9:26:\
    \ error: cannot find 'pow' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                         ^~~\n/tmp/tmp_upknbwy.swift:9:41: error:\
    \ cannot find 'log10' in scope\n    return integerPart * pow(10, Double(log10(Double(number))))\
    \ + decimalPart\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    var decimalsRemaining = 0\n    while\
    \ decimalsRemaining < Double.maxFiniteNumberOfDigits {\n        decimalPart *=\
    \ 10\n        integerPart /= 10\n        decimalsRemaining += 1\n    }\n    return\
    \ Double(integerPart) + Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu_ch9xy3.swift:10:38: error: type 'Double' has no member 'maxFiniteNumberOfDigits'\n\
    \    while decimalsRemaining < Double.maxFiniteNumberOfDigits {\n            \
    \                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number / 1)\n    return integerPart\
    \ * 1 + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpu117ml3u.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpu117ml3u.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number / 1)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpooasx2p0/tmpooasx2p0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4b978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a4b66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a4b66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a4b66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooasx2p0                        0x000055eceed84255 <unavailable> + 4693

    5    libc.so.6                          0x00002b7a4bb64460 __libc_start_main +
    245

    6    tmpooasx2p0                        0x000055eceed83ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        decimalPart\
    \ = -number\n        integerPart = -integerPart\n    }\n    if decimalPart < 10\
    \ {\n        return number\n    }\n    if decimalPart < 100 {\n        return\
    \ integerPart + decimalPart / 10\n    }\n    if decimalPart < 1000 {\n       \
    \ return integerPart + decimalPart / 100\n    }\n    return integerPart + decimalPart\
    \ / 1000\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpqd7ph02s/tmpqd7ph02s.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b488f3cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b488f0c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b488f0c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b488f0c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqd7ph02s                        0x0000562039e821c5 <unavailable> + 4549

    5    libc.so.6                          0x00002b488f5ba460 __libc_start_main +
    245

    6    tmpqd7ph02s                        0x0000562039e81e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    if number < 0\
    \ {\n        return -truncate_number(-number)\n    }\n    if number == 0 {\n \
    \       return 0.0\n    }\n    let exponent = Double(log10(number))\n    let decimalPart\
    \ = number / pow(10.0, Double(exponent))\n    return truncate_number(decimalPart)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp22y3n1md.swift:8:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmp22y3n1md.swift:13:27:\
    \ error: cannot find 'log10' in scope\n    let exponent = Double(log10(number))\n\
    \                          ^~~~~\n/tmp/tmp22y3n1md.swift:14:32: error: cannot\
    \ find 'pow' in scope\n    let decimalPart = number / pow(10.0, Double(exponent))\n\
    \                               ^~~\n/tmp/tmp22y3n1md.swift:15:28: error: missing\
    \ argument label 'number:' in call\n    return truncate_number(decimalPart)\n\
    \                           ^\n                           number: \n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(number).truncatingRemainder(dividingBy: 1)\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbyfoioc9.swift:7:45: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n                             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number - decimalPart)\n    return\
    \ integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphc4zsuxi.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmphc4zsuxi.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number - decimalPart)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let (integer,\
    \ decimal) = Double(truncatingBitPattern: number).decompose()\n    return Double(integer)\
    \ + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuoqouqln.swift:7:30: error: no exact matches in call to initializer\
    \ \n    let (integer, decimal) = Double(truncatingBitPattern: number).decompose()\n\
    \                             ^\n/tmp/tmpuoqouqln.swift:7:30: note: found candidate\
    \ with type '(Double) -> Double'\n    let (integer, decimal) = Double(truncatingBitPattern:\
    \ number).decompose()\n                             ^\n/tmp/tmpuoqouqln.swift:7:67:\
    \ error: value of type 'Double' has no member 'decompose'\n    let (integer, decimal)\
    \ = Double(truncatingBitPattern: number).decompose()\n                       \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = Double(truncatingBitPattern: number % 1)\n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmzq391td.swift:7:23: error: no exact matches in call to initializer\
    \ \n    let decimalPart = Double(truncatingBitPattern: number % 1)\n         \
    \             ^\nSwift.Double:11:23: note: incorrect labels for candidate (have:\
    \ '(truncatingBitPattern:)', expected: '(_:)')\n    @inlinable public init(_ other:\
    \ Double)\n                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect\
    \ labels for candidate (have: '(truncatingBitPattern:)', expected: '(_:)')\n \
    \   @inlinable public init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n\
    \                      ^\n/tmp/tmpmzq391td.swift:8:23: error: no exact matches\
    \ in call to initializer \n    let integerPart = Double(truncatingBitPattern:\
    \ number - decimalPart)\n                      ^\n/tmp/tmpmzq391td.swift:8:23:\
    \ note: found candidate with type '(Double) -> Double'\n    let integerPart =\
    \ Double(truncatingBitPattern: number - decimalPart)\n                      ^\n\
    /tmp/tmpmzq391td.swift:9:24: error: cannot convert return expression of type 'String'\
    \ to return type 'Double'\n    return integerPart + decimalPart\n           ~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(floor(number))\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjmso5uur.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpjmso5uur.swift:8:30: error: cannot find 'floor' in scope\n\
    \    let integerPart = Double(floor(number))\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let whole = floor(number)\n    return whole + fraction\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbob0jpg0.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpbob0jpg0.swift:8:17: error: cannot find 'floor' in scope\n\
    \    let whole = floor(number)\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = Double(Int(number))\n    return integerPart\
    \ + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp2c_tlm_1.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpud1kc2_f.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpud1kc2_f.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart:\
    \ Double = 0\n    var integerPart: Double = 0\n    var remainder: Double = 0\n\
    \    \n    if number < 0 {\n        number *= -1\n    }\n    \n    if number <\
    \ 10 {\n        integerPart = number\n    } else if number < 100 {\n        integerPart\
    \ = number / 10\n        decimalPart = number % 10\n    } else if number < 1000\
    \ {\n        integerPart = number / 100\n        decimalPart = number % 100\n\
    \    } else if number < 10000 {\n        integerPart = number / 1000\n       \
    \ decimalPart = number % 1000\n    } else if number < 100000 {\n        integerPart\
    \ = number / 10000\n        decimalPart = number % 10000\n    } else if number\
    \ < 1000000 {\n        integerPart = number / 100000\n        decimalPart = number\
    \ % 100000\n    } else if number < 10000000 {\n        integerPart = number /\
    \ 1000000\n        decimalPart = number % 1000000\n    } else if number < 100000000\
    \ {\n        integerPart = number / 10000000\n        decimalPart = number % 10000000\n\
    \    } else if number < 1000000000 {\n        integerPart = number / 100000000\n\
    \        decimalPart = number % 100000000\n    } else if number < 10000000000\
    \ {\n        integerPart = number / 1000000000\n        decimalPart = number %\
    \ 1000000000\n    } else if number < 100000000000 {\n        integerPart = number\
    \ / 10000000000\n        decimalPart = number % 10000000000\n    } else if number\
    \ < 1000000000000 {\n        integerPart = number / 100000000000\n        decimalPart\
    \ = number % 100000000000\n    } else if number < 10000000000000 {\n        integerPart\
    \ = number / 1000000000000\n        decimalPart = number % 1000000000000\n   \
    \ } else if number < 100000000000000 {\n        integerPart = number / 10000000000000\n\
    \        decimalPart = number % 10000000000000\n    } else if number < 1000000000000000\
    \ {\n        integerPart = number / 100000000000000\n        decimalPart = number\
    \ % 100000000000000\n    } else if number < 10000000000000000 {\n        integerPart\
    \ = number / 1000000000000000\n        decimalPart = number % 1000000000000000\n\
    \    } else if number < 100000000000000000 {\n        integerPart = number / 10000000000000000\n\
    \        decimalPart = number % 10000000000000000\n    } else if number < 1000000000000000000\
    \ {\n        integerPart = number / 100000000000000000\n        decimalPart =\
    \ number % 100000000000000000\n    } else {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpo_hxckei.swift:87:46: error: expected '}' at end of brace statement\n\
    assert(truncate_number(number: 123.0) == 0.0)\n                              \
    \               ^\n/tmp/tmpo_hxckei.swift:6:48: note: to match this opening '{'\n\
    func truncate_number(number: Double) -> Double {\n                           \
    \                    ^\n/tmp/tmpo_hxckei.swift:12:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number *= -1\n\
    \        ~~~~~~ ^\n/tmp/tmpo_hxckei.swift:19:30: error: '%' is unavailable: For\
    \ floating point numbers use truncatingRemainder instead\n        decimalPart\
    \ = number % 10\n                             ^\nSwift.%:2:13: note: '%' has been\
    \ explicitly marked unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where\
    \ T : BinaryFloatingPoint\n            ^\n/tmp/tmpo_hxckei.swift:22:30: error:\
    \ '%' is unavailable: For floating point numbers use truncatingRemainder instead\n\
    \        decimalPart = number % 100\n                             ^\nSwift.%:2:13:\
    \ note: '%' has been explicitly marked unavailable here\npublic func % <T>(lhs:\
    \ T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n/tmp/tmpo_hxckei.swift:25:30:\
    \ error: '%' is unavailable: For floating point numbers use truncatingRemainder\
    \ instead\n        decimalPart = number % 1000\n                             ^\n\
    Swift.%:2:13: note: '%' has been explicitly marked unavailable here\npublic func\
    \ % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n/tmp/tmpo_hxckei.swift:28:30:\
    \ error: '%' is unavailable: For floating point numbers use truncatingRemainder\
    \ instead\n        decimalPart = number % 10000\n                            \
    \ ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable here\npublic\
    \ func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n\
    /tmp/tmpo_hxckei.swift:31:30: error: '%' is unavailable: For floating point numbers\
    \ use truncatingRemainder instead\n        decimalPart = number % 100000\n   \
    \                          ^\nSwift.%:2:13: note: '%' has been explicitly marked "
  stdout: ''
  timestamp: 1660029144
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    if number < 0 {\n        decimalPart = -number\n    }\n    return\
    \ Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpgb1n0gy4/tmpgb1n0gy4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71590b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7158db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7158db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7158daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb1n0gy4                        0x000055b89c7cf215 <unavailable> + 4629

    5    libc.so.6                          0x00002b71592a5460 __libc_start_main +
    245

    6    tmpgb1n0gy4                        0x000055b89c7ceeb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let fraction\
    \ = number % 1\n    return number - fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmpf_bj37.swift:7:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    var decimalPart\
    \ = number\n    var integerPart = number\n    if number < 0 {\n        decimalPart\
    \ = -number\n        integerPart = -integerPart\n    }\n    return Double(integerPart)\
    \ / Double(10) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp8hll2f72/tmp8hll2f72.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afae5ea8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae5b9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afae5b9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afae5b9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hll2f72                        0x000055af5dc68215 <unavailable> + 4629

    5    libc.so.6                          0x00002afae6094460 __libc_start_main +
    245

    6    tmp8hll2f72                        0x000055af5dc67eb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let decimalPart\
    \ = number % 1\n    let integerPart = floor(number)\n    return integerPart +\
    \ decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp4h6dej7.swift:7:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpp4h6dej7.swift:8:23: error: cannot find 'floor' in scope\n\
    \    let integerPart = floor(number)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029143
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfunc truncate_number(number: Double) -> Double {\n    let intPart =\
    \ (number as NSNumber).doubleValue\n    let decimalPart = number - intPart\n \
    \   return intPart + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp19pwn82n.swift:7:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmp19pwn82n.swift:7:40: error: value of type 'Double' has\
    \ no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\n\
    \                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp19pwn82n.swift:9:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return intPart + decimalPart\n           ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029143
