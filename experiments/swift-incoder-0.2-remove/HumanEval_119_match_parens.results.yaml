language: swift
name: HumanEval_119_match_parens
results:
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"No\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpdzqky750/tmpdzqky750.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b456be84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b456bb7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b456bb7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b456bb7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdzqky750                        0x000055fe6e5cc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b456c070460 __libc_start_main +
    245

    6    tmpdzqky750                        0x000055fe6e5cc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"No\"\
    \n            }\n        } else {\n            if stack.count > 0 {\n        \
    \        if stack.last == s {\n                    stack.removeLast()\n      \
    \          } else {\n                    result = \"No\"\n                }\n\
    \            } else {\n                result = \"Yes\"\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpl6m61b_0/tmpl6m61b_0.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af996749c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af996440b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af996440988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af99643f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl6m61b_0                        0x00005586d32e9856 <unavailable> + 6230

    5    libc.so.6                          0x00002af996935460 __libc_start_main +
    245

    6    tmpl6m61b_0                        0x00005586d32e9439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"No\"\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyry771f5/tmpyry771f5.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af98d093c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af98cd8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af98cd8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af98cd897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyry771f5                        0x0000557713d277f6 <unavailable> + 6134

    5    libc.so.6                          0x00002af98d27f460 __libc_start_main +
    245

    6    tmpyry771f5                        0x0000557713d273d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var result = \"No\"\n    for str in lst {\n     \
    \   if str == \"(\" || str == \")\" {\n            result = \"Yes\"\n        \
    \    break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpm_j8s4iz/tmpm_j8s4iz.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab529aeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5297e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5297e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5297e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm_j8s4iz                        0x0000564764a5c780 <unavailable> + 6016

    5    libc.so.6                          0x00002ab529cd6460 __libc_start_main +
    245

    6    tmpm_j8s4iz                        0x0000564764a5c1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpft3suqgh/tmpft3suqgh.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b2c7dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b2c4d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b2c4d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b2c4d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpft3suqgh                        0x0000563980d74aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b6b2c9c8460 __libc_start_main +
    245

    6    tmpft3suqgh                        0x0000563980d743d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var result = \"No\"\n    var stack = Stack()\n  \
    \  for str in lst {\n        if str == \"(\" {\n            stack.push(str)\n\
    \        } else if str == \")\" {\n            if stack.top() == \"(\" {\n   \
    \             stack.pop()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            result =\
    \ \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptvuyfuym.swift:13:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0tg7pdul/tmp0tg7pdul.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0b7cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0b79c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0b79c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0b79c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tg7pdul                        0x0000562966dbc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab0b7ebe460 __libc_start_main +
    245

    6    tmp0tg7pdul                        0x0000562966dbc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() != 0 {\n                return \"No\"\n            }\n         \
    \   res += s\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\
    \n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnupsiin.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s.contains(\"(\") {\n            stack.push(s)\n        } else {\n      \
    \      if stack.count > 0 {\n                if stack.peek().contains(\"(\") {\n\
    \                    stack.pop()\n                } else {\n                 \
    \   return \"No\"\n                }\n            } else {\n                return\
    \ \"No\"\n            }\n        }\n    }\n    if stack.count > 0 {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3kwxezf.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.isEmpty {\n          \
    \      result = \"Yes\"\n                break\n            } else {\n       \
    \         stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgr3z7m_7/tmpgr3z7m_7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d331fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d32ef2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d32ef2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d32ef17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgr3z7m_7                        0x000056536bf91960 <unavailable> + 6496

    5    libc.so.6                          0x00002b0d333e7460 __libc_start_main +
    245

    6    tmpgr3z7m_7                        0x000056536bf913d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n            if stack.isEmpty\
    \ {\n                res = res + s\n            } else {\n                res\
    \ = res + s + stack.removeLast()\n            }\n        } else {\n          \
    \  res = res + s\n        }\n    }\n    if stack.isEmpty {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmplkzk_f9y/tmplkzk_f9y.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c7f956c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c7f64db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c7f64d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c7f64c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkzk_f9y                        0x0000560cbed3a846 <unavailable> + 6214

    5    libc.so.6                          0x00002b2c7fb42460 __libc_start_main +
    245

    6    tmplkzk_f9y                        0x0000560cbed3a429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack.last\
    \ == s {\n                    stack.removeLast()\n                } else {\n \
    \                   result = \"No\"\n                    break\n             \
    \   }\n            } else {\n                result = \"Yes\"\n              \
    \  break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmps1q3akin/tmps1q3akin.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a5c3aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a5c0a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a5c0a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a5c0a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps1q3akin                        0x0000559ba929a9c6 <unavailable> + 6598

    5    libc.so.6                          0x00002b6a5c59a460 __libc_start_main +
    245

    6    tmps1q3akin                        0x0000559ba929a5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.len() == 0 {\n                return \"No\"\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpahr87gx1.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else if s ==\
    \ \"}\" {\n            if stack.isEmpty {\n                result = \"No\"\n \
    \           } else {\n                stack.removeLast()\n            }\n    \
    \    } else if s == \"(\" {\n            if stack.isEmpty {\n                result\
    \ = \"No\"\n            } else {\n                stack.removeLast()\n       \
    \     }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp27bqvxsx/tmp27bqvxsx.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b7a997c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b7a68eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b7a68e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b7a68d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp27bqvxsx                        0x00005630e49357f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b2b7ab83460 __libc_start_main +
    245

    6    tmp27bqvxsx                        0x00005630e49353d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n        } else {\n  \
    \          if stack.isEmpty {\n                res = s\n            } else {\n\
    \                res = res + s\n            }\n        }\n    }\n    return \"\
    Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6fofjn8v/tmp6fofjn8v.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af14a07fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af149d76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af149d76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af149d757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6fofjn8v                        0x0000564d4177c846 <unavailable> + 6214

    5    libc.so.6                          0x00002af14a26b460 __libc_start_main +
    245

    6    tmp6fofjn8v                        0x0000564d4177c429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var result = \"No\"\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpo_pdtf2a/tmpo_pdtf2a.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cea74cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cea443b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cea443988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cea4427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo_pdtf2a                        0x000056247ad137f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b1cea938460 __libc_start_main +
    245

    6    tmpo_pdtf2a                        0x000056247ad133d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmplw57p26t/tmplw57p26t.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c3adcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c3aac2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c3aac2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c3aac17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplw57p26t                        0x00005627a4caeaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b9c3afb7460 __libc_start_main +
    245

    6    tmplw57p26t                        0x00005627a4cae3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n            }\n        } else {\n            if stack.last == \"(\" {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"No\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1d0zc25x/tmp1d0zc25x.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7cad75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7caa6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7caa6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7caa6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1d0zc25x                        0x000055ab0148a960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba7caf61460 __libc_start_main +
    245

    6    tmp1d0zc25x                        0x000055ab0148a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack[stack.count-1]\
    \ == \"(\" {\n                stack[stack.count-1] += s\n            } else {\n\
    \                stack[stack.count-1] = s\n            }\n        } else {\n \
    \           if stack.count > 0 {\n                if stack[stack.count-1] == \"\
    (\" {\n                    stack[stack.count-1] += s\n                } else {\n\
    \                    stack[stack.count-1] = s\n                }\n           \
    \ } else {\n                result = \"Yes\"\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abf58678c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf5836f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abf5836f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abf5836f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abf5836ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abf5816efc3 <unavailable> + 188355

    6    tmp5tlmljaq                        0x0000557c69780b6a <unavailable> + 11114

    7    tmp5tlmljaq                        0x0000557c6977f6f5 <unavailable> + 5877

    8    libc.so.6                          0x00002abf58864460 __libc_start_main +
    245

    9    tmp5tlmljaq                        0x0000557c6977f399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.pop()\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            if stack.peek()\
    \ == \"(\" {\n                stack.pop()\n            } else {\n            \
    \    stack.pop()\n                stack.pop()\n                res = res + s\n\
    \            }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_iqj9jwv.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.count > 0 {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_l889pa6/tmp_l889pa6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad967d9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad967a95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad967a95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad967a947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_l889pa6                        0x00005608aec81960 <unavailable> + 6496

    5    libc.so.6                          0x00002ad967f8a460 __libc_start_main +
    245

    6    tmp_l889pa6                        0x00005608aec813d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(\"(\")\n        } else if s == \")\"\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.pop()\n        } else {\n            if stack.count <\
    \ 1 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.count > 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpuf8m5sb6.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() != 0 {\n                return \"No\"\n            }\n         \
    \   res += s\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\
    \n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnupsiin.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ guard lst[0] == \"(\" && lst[lst.count - 1] == \")\" else { return \"No\" }\n\
    \    var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n   \
    \     if s == \"(\" {\n            stack.append(s)\n        } else if s == \"\
    )\" {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                result = \"No\"\n                break\n\
    \            }\n        } else {\n            if stack.count > 0 {\n         \
    \       if stack.last == s {\n                    stack.removeLast()\n       \
    \         } else {\n                    result = \"No\"\n                    break\n\
    \                }\n            } else {\n                result = \"Yes\"\n \
    \               break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjo__gpgw/tmpjo__gpgw.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca9a13dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca99e34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca99e34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca99e337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjo__gpgw                        0x0000557dfaa6f8a6 <unavailable> + 6310

    5    libc.so.6                          0x00002aca9a329460 __libc_start_main +
    245

    6    tmpjo__gpgw                        0x0000557dfaa6f489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmprizwon.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpmprizwon.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    No\"\n                break\n            }\n            stack.removeLast()\n \
    \           stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpa0xj0js6/tmpa0xj0js6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade80779c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade80470b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade80470988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade8046f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0xj0js6                        0x0000559754fe07f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ade80965460 __libc_start_main +
    245

    6    tmpa0xj0js6                        0x0000559754fe03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.pop()\n        } else if stack.isEmpty {\n\
    \            return \"Yes\"\n        }\n    }\n    if stack.isEmpty {\n      \
    \  return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp1zwwu7.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Set<String>()\n    for s in lst {\n \
    \       if s.contains(\"(\") {\n            stack.add(\"(\")\n        }\n    \
    \    if s.contains(\")\") {\n            stack.add(\")\")\n        }\n    }\n\
    \    if stack.count == 0 {\n        return \"No\"\n    }\n    if stack.count ==\
    \ 1 {\n        return \"Yes\"\n    }\n    var res = \"\"\n    for s in lst {\n\
    \        if s.contains(\"(\") {\n            if stack.contains(\"(\") {\n    \
    \            res += \"(\"\n                stack.remove(\"(\")\n            }\
    \ else {\n                res += \"(\"\n                stack.add(\"(\")\n   \
    \         }\n        }\n        if s.contains(\")\") {\n            if stack.contains(\"\
    )\") {\n                res += \")\"\n                stack.remove(\")\")\n  \
    \          } else {\n                res += \")\"\n                stack.add(\"\
    )\")\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbf27e28i.swift:15:19: error: value of type 'Set<String>' has no\
    \ member 'add'\n            stack.add(\"(\")\n            ~~~~~ ^~~\n/tmp/tmpbf27e28i.swift:18:19:\
    \ error: value of type 'Set<String>' has no member 'add'\n            stack.add(\"\
    )\")\n            ~~~~~ ^~~\n/tmp/tmpbf27e28i.swift:35:23: error: value of type\
    \ 'Set<String>' has no member 'add'\n                stack.add(\"(\")\n      \
    \          ~~~~~ ^~~\n/tmp/tmpbf27e28i.swift:44:23: error: value of type 'Set<String>'\
    \ has no member 'add'\n                stack.add(\")\")\n                ~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n            }\n        } else {\n            if stack.last == \"(\" {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"No\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8kw0bjwt/tmp8kw0bjwt.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3bd4b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3bd1b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3bd1b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3bd1af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8kw0bjwt                        0x000055ba8a81a7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ac3bd6a5460 __libc_start_main +
    245

    6    tmp8kw0bjwt                        0x000055ba8a81a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                res += \"No\"\n                return res\n\
    \            }\n        } else {\n            if stack.count > 0 {\n         \
    \       stack.removeLast()\n            } else {\n                res += \"No\"\
    \n                return res\n            }\n        }\n    }\n    if stack.count\
    \ == 0 {\n        res += \"Yes\"\n        return res\n    }\n    res += \"No\"\
    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp96l03065/tmp96l03065.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53a8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53786b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f53786988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f537857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp96l03065                        0x0000563b3f104846 <unavailable> + 6214

    5    libc.so.6                          0x00002b0f53c7b460 __libc_start_main +
    245

    6    tmp96l03065                        0x0000563b3f104429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.isEmpty {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        } else {\n            if stack.isEmpty {\n \
    \               return \"Yes\"\n            }\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpwa3gb7lr.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n            if stack.last\
    \ == \"(\" {\n                stack.removeLast()\n            }\n        } else\
    \ {\n            if stack.last == \"(\" {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    if stack.last == \"(\" {\n        stack.removeLast()\n\
    \    }\n    if stack.last == \")\" {\n        stack.removeLast()\n    }\n    if\
    \ stack.last == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpvh9y6czt/tmpvh9y6czt.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af55e601c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af55e2f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af55e2f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af55e2f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvh9y6czt                        0x000055ab51a57856 <unavailable> + 6230

    5    libc.so.6                          0x00002af55e7ed460 __libc_start_main +
    245

    6    tmpvh9y6czt                        0x000055ab51a57439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var result = \"No\"\n    for str in lst {\n     \
    \   if str == \"(\" || str == \")\" {\n            if result == \"No\" {\n   \
    \             result = \"Yes\"\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpudss9g4y/tmpudss9g4y.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac19a46ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac19a161b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac19a161988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac19a1607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpudss9g4y                        0x0000561f6989c780 <unavailable> + 6016

    5    libc.so.6                          0x00002ac19a656460 __libc_start_main +
    245

    6    tmpudss9g4y                        0x0000561f6989c1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() == 0 {\n                return \"No\"\n            }\n         \
    \   if stack.top() == \"(\" {\n                stack.pop()\n            } else\
    \ {\n                stack.pop()\n                stack.pop()\n              \
    \  res = s + res\n            }\n        }\n    }\n    if stack.len() == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpabs23l1h.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.isEmpty {\n          \
    \      result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpq0mjach8/tmpq0mjach8.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93c6612c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93c6309b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93c6309988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93c63087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq0mjach8                        0x000055958ea9b7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b93c67fe460 __libc_start_main +
    245

    6    tmpq0mjach8                        0x000055958ea9b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.isEmpty {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        } else {\n            if !stack.isEmpty {\n\
    \                return \"No\"\n            }\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpi5bwffpb.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Set<String>()\n    var res = \"\"\n \
    \   for s in lst {\n        if s.contains(\"(\") {\n            stack.add(\"(\"\
    )\n        }\n        if s.contains(\")\") {\n            stack.add(\")\")\n \
    \       }\n    }\n    for s in lst {\n        if s.contains(\"(\") {\n       \
    \     if stack.contains(\"(\") {\n                stack.remove(\"(\")\n      \
    \      } else {\n                res += \"(\"\n            }\n        }\n    \
    \    if s.contains(\")\") {\n            if stack.contains(\")\") {\n        \
    \        stack.remove(\")\")\n            } else {\n                res += \"\
    )\"\n            }\n        }\n    }\n    if stack.count == 0 {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpgtlb5rs1.swift:16:19: error: value of type 'Set<String>' has no\
    \ member 'add'\n            stack.add(\"(\")\n            ~~~~~ ^~~\n/tmp/tmpgtlb5rs1.swift:19:19:\
    \ error: value of type 'Set<String>' has no member 'add'\n            stack.add(\"\
    )\")\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmprizwon.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpmprizwon.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                result =\
    \ \"No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy5u8_2i.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                result =\
    \ \"No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy5u8_2i.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpv5a6f6dy/tmpv5a6f6dy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af139d85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af139a7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af139a7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af139a7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv5a6f6dy                        0x0000558b78ab99c6 <unavailable> + 6598

    5    libc.so.6                          0x00002af139f71460 __libc_start_main +
    245

    6    tmpv5a6f6dy                        0x0000558b78ab95a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpv5a6f6dy/tmpv5a6f6dy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af139d85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af139a7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af139a7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af139a7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv5a6f6dy                        0x0000558b78ab99c6 <unavailable> + 6598

    5    libc.so.6                          0x00002af139f71460 __libc_start_main +
    245

    6    tmpv5a6f6dy                        0x0000558b78ab95a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.len() == 0 {\n                return \"No\"\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpahr87gx1.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    No\"\n                break\n            }\n            stack.removeLast()\n \
    \           stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpa0xj0js6/tmpa0xj0js6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade80779c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade80470b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade80470988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade8046f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0xj0js6                        0x0000559754fe07f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ade80965460 __libc_start_main +
    245

    6    tmpa0xj0js6                        0x0000559754fe03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmplw57p26t/tmplw57p26t.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c3adcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c3aac2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c3aac2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c3aac17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplw57p26t                        0x00005627a4caeaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b9c3afb7460 __libc_start_main +
    245

    6    tmplw57p26t                        0x00005627a4cae3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                res += s\n            }\n        } else\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \              res += s\n            } else {\n                res += s\n    \
    \        }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjtg7o2j5/tmpjtg7o2j5.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4821edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac481ee4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac481ee4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac481ee37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjtg7o2j5                        0x000055f5c8f92846 <unavailable> + 6214

    5    libc.so.6                          0x00002ac4823d9460 __libc_start_main +
    245

    6    tmpjtg7o2j5                        0x000055f5c8f92429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    \n    var stack = [String]()\n    var result = \"\
    No\"\n    \n    for str in lst {\n        \n        if str == \"(\" {\n      \
    \      stack.append(str)\n        }\n        \n        if str == \")\" {\n   \
    \         \n            if stack.count > 0 {\n                \n             \
    \   let lastStr = stack.removeLast()\n                \n                if lastStr\
    \ == \"(\" {\n                    stack.append(str)\n                } else {\n\
    \                    result = \"Yes\"\n                    break\n           \
    \     }\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4khdu2vg/tmp4khdu2vg.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac57d472c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac57d169b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac57d169988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac57d1687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4khdu2vg                        0x0000555a3bdd77f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ac57d65e460 __libc_start_main +
    245

    6    tmp4khdu2vg                        0x0000555a3bdd73d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Set<String>()\n    var res = \"\"\n \
    \   for s in lst {\n        if s.contains(\"(\") {\n            stack.add(\"(\"\
    )\n        }\n        if s.contains(\")\") {\n            stack.add(\")\")\n \
    \       }\n    }\n    if stack.count == 0 {\n        return \"No\"\n    }\n  \
    \  for s in lst {\n        if stack.contains(s) {\n            res += s\n    \
    \    }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpod7pw_yx.swift:16:19: error: value of type 'Set<String>' has no\
    \ member 'add'\n            stack.add(\"(\")\n            ~~~~~ ^~~\n/tmp/tmpod7pw_yx.swift:19:19:\
    \ error: value of type 'Set<String>' has no member 'add'\n            stack.add(\"\
    )\")\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9sk9fumq/tmp9sk9fumq.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b581766ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5817365b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5817365988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58173647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9sk9fumq                        0x000055ce00494ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b581785a460 __libc_start_main +
    245

    6    tmp9sk9fumq                        0x000055ce00494559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_hgqziav/tmp_hgqziav.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ff5fb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ff5ca8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ff5ca8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ff5ca77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hgqziav                        0x000055f1dde417f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b4ff619d460 __libc_start_main +
    245

    6    tmp_hgqziav                        0x000055f1dde413d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9e_k6dx.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpn9e_k6dx.swift:16:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpn9e_k6dx.swift:17:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpn9e_k6dx.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_hgqziav/tmp_hgqziav.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ff5fb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ff5ca8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ff5ca8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ff5ca77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hgqziav                        0x000055f1dde417f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b4ff619d460 __libc_start_main +
    245

    6    tmp_hgqziav                        0x000055f1dde413d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n     \
    \       stack.push(s)\n        } else if s == \"}\" || s == \"]\" {\n        \
    \    if stack.top() == \"{\" {\n                stack.pop()\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.top() == \"{\" {\n                stack.pop()\n            } else\
    \ {\n                stack.pop()\n            }\n        }\n    }\n    if stack.top()\
    \ == \"{\" {\n        result = \"Yes\"\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpgyn6fz9o.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        } else {\n            if stack.last\
    \ == \"(\" {\n                stack.removeLast()\n            } else {\n     \
    \           result = \"No\"\n                break\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpl3euon5m/tmpl3euon5m.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c1f7ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c1f4e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c1f4e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c1f4e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl3euon5m                        0x00005644a82c47f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b3c1f9d7460 __libc_start_main +
    245

    6    tmpl3euon5m                        0x00005644a82c43d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"No\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmprqt53q78/tmprqt53q78.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1583630c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1583327b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1583327988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15833267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprqt53q78                        0x0000564b62ae7976 <unavailable> + 6518

    5    libc.so.6                          0x00002b158381c460 __libc_start_main +
    245

    6    tmprqt53q78                        0x0000564b62ae7559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.isEmpty {\n          \
    \      result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpq0mjach8/tmpq0mjach8.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93c6612c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93c6309b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93c6309988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93c63087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq0mjach8                        0x000055958ea9b7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b93c67fe460 __libc_start_main +
    245

    6    tmpq0mjach8                        0x000055958ea9b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        } else {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp2ty2oe_p/tmp2ty2oe_p.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bb96a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bb9398b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bb9398988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bb93977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2ty2oe_p                        0x0000557637d5f7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9bb988d460 __libc_start_main +
    245

    6    tmp2ty2oe_p                        0x0000557637d5f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    \n    var stack = [String]()\n    var result = \"\
    No\"\n    \n    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            stack.removeLast()\n          \
    \  if stack.count == 0 {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7989f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7986ec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba7986ec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba7986ec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba7986ebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ba7987edc1d <unavailable> + 2489373

    6    tmpry4rf8g7                        0x000055a18ba12b8a <unavailable> + 11146

    7    tmpry4rf8g7                        0x000055a18ba11735 <unavailable> + 5941

    8    libc.so.6                          0x00002ba798be1460 __libc_start_main +
    245

    9    tmpry4rf8g7                        0x000055a18ba113d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for str in lst {\n        if str == \"(\" {\n            stack.push(str)\n\
    \        } else if str == \")\" {\n            if stack.len() == 0 {\n       \
    \         result = \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4o8ks5p.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.contains(s) {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjjgubt76/tmpjjgubt76.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9171cfdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91719f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91719f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91719f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjgubt76                        0x00005571315a0a00 <unavailable> + 6656

    5    libc.so.6                          0x00002b9171ee9460 __libc_start_main +
    245

    6    tmpjjgubt76                        0x00005571315a0479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n            } else {\n\
    \                stack.pop()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjl6tvd55.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpjl6tvd55.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n  \
    \      } else if s.contains(\")\") {\n            if stack.count > 0 {\n     \
    \           stack.removeLast()\n            } else {\n                res += \"\
    No\"\n                return res\n            }\n        } else {\n          \
    \  res += \"No\"\n            return res\n        }\n    }\n    if stack.count\
    \ > 0 {\n        res += \"No\"\n        return res\n    }\n    res += \"Yes\"\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprmeas7zm/tmprmeas7zm.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c2c63fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c2c336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c2c336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c2c3357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmeas7zm                        0x00005642a9fe4e46 <unavailable> + 7750

    5    libc.so.6                          0x00002b6c2c82b460 __libc_start_main +
    245

    6    tmprmeas7zm                        0x00005642a9fe45a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpeupjlf1r/tmpeupjlf1r.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adffdaf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adffd7e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adffd7e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adffd7e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeupjlf1r                        0x0000564cfbbb57f6 <unavailable> + 6134

    5    libc.so.6                          0x00002adffdcde460 __libc_start_main +
    245

    6    tmpeupjlf1r                        0x0000564cfbbb53d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Set<String>()\n    var result = \"No\"\
    \n    for s in lst {\n        if s.contains(\"(\") {\n            stack.add(\"\
    (\")\n        }\n        if s.contains(\")\") {\n            stack.add(\")\")\n\
    \        }\n    }\n    if stack.count == 0 {\n        result = \"Yes\"\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp78oa62pr.swift:16:19: error: value of type 'Set<String>' has no\
    \ member 'add'\n            stack.add(\"(\")\n            ~~~~~ ^~~\n/tmp/tmp78oa62pr.swift:19:19:\
    \ error: value of type 'Set<String>' has no member 'add'\n            stack.add(\"\
    )\")\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n             \
    \   stack.append(s)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpql7ktsc6.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpql7ktsc6.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.count > 0 {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_l889pa6/tmp_l889pa6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad967d9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad967a95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad967a95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad967a947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_l889pa6                        0x00005608aec81960 <unavailable> + 6496

    5    libc.so.6                          0x00002ad967f8a460 __libc_start_main +
    245

    6    tmp_l889pa6                        0x00005608aec813d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.top() == \"(\" {\n                stack.pop()\n\
    \            } else {\n                res += \"No\"\n                return res\n\
    \            }\n        } else {\n            res += \"No\"\n            return\
    \ res\n        }\n    }\n    if stack.top() == \"(\" {\n        res += \"Yes\"\
    \n    } else {\n        res += \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4xzi_kl.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.top() == \"(\" {\n           \
    \     stack.pop()\n            } else {\n                result = \"No\"\n   \
    \             break\n            }\n        } else {\n            result = \"\
    No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpsnu8db03.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n            } else {\n                stack.pop()\n       \
    \     }\n        } else {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n            } else {\n                stack.pop()\n       \
    \     }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp0iwp0akh.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9e_k6dx.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpn9e_k6dx.swift:16:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpn9e_k6dx.swift:17:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpn9e_k6dx.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() != 0 {\n                return \"No\"\n            }\n         \
    \   res += s\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\
    \n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnupsiin.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s.contains(\"(\") {\n            stack.push(s)\n        } else {\n      \
    \      if stack.top() == \"(\" {\n                stack.pop()\n            } else\
    \ {\n                return \"No\"\n            }\n        }\n    }\n    if stack.top()\
    \ == \"(\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxpj8p5ay.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.top() == \"(\" {\n                stack.pop()\n\
    \            } else {\n                res += \"No\"\n                return res\n\
    \            }\n        } else {\n            res += \"No\"\n            return\
    \ res\n        }\n    }\n    if stack.top() == \"(\" {\n        res += \"Yes\"\
    \n    } else {\n        res += \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4xzi_kl.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpqtu3bcy4/tmpqtu3bcy4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b538646cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5386163b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5386163988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53861627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqtu3bcy4                        0x00005619f6ba97f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b5386658460 __libc_start_main +
    245

    6    tmpqtu3bcy4                        0x00005619f6ba93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    No\"\n                break\n            }\n            stack.removeLast()\n \
    \           stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpa0xj0js6/tmpa0xj0js6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade80779c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade80470b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade80470988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade8046f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0xj0js6                        0x0000559754fe07f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ade80965460 __libc_start_main +
    245

    6    tmpa0xj0js6                        0x0000559754fe03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0tg7pdul/tmp0tg7pdul.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0b7cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0b79c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0b79c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0b79c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tg7pdul                        0x0000562966dbc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab0b7ebe460 __libc_start_main +
    245

    6    tmp0tg7pdul                        0x0000562966dbc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpeupjlf1r/tmpeupjlf1r.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adffdaf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adffd7e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adffd7e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adffd7e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeupjlf1r                        0x0000564cfbbb57f6 <unavailable> + 6134

    5    libc.so.6                          0x00002adffdcde460 __libc_start_main +
    245

    6    tmpeupjlf1r                        0x0000564cfbbb53d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        } else {\n            if stack.last\
    \ == \")\" {\n                stack.removeLast()\n            } else {\n     \
    \           result = \"No\"\n                break\n            }\n        }\n\
    \    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy5ny3i_e/tmpy5ny3i_e.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0118773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b011846ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b011846a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01184697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy5ny3i_e                        0x000055bc6e756960 <unavailable> + 6496

    5    libc.so.6                          0x00002b011895f460 __libc_start_main +
    245

    6    tmpy5ny3i_e                        0x000055bc6e7563d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    \n    var stack = Stack()\n    var result = \"No\"\
    \n    \n    for elem in lst {\n        if elem == \"(\" {\n            stack.push(elem)\n\
    \        } else if elem == \")\" {\n            if stack.top() == \"(\" {\n  \
    \              stack.pop()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp01dsjeho.swift:13:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0tg7pdul/tmp0tg7pdul.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0b7cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0b79c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0b79c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0b79c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tg7pdul                        0x0000562966dbc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab0b7ebe460 __libc_start_main +
    245

    6    tmp0tg7pdul                        0x0000562966dbc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        } else {\n            if stack.last\
    \ == \"(\" {\n                stack.removeLast()\n            } else {\n     \
    \           result = \"No\"\n                break\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpl3euon5m/tmpl3euon5m.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c1f7ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c1f4e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c1f4e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c1f4e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl3euon5m                        0x00005644a82c47f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b3c1f9d7460 __libc_start_main +
    245

    6    tmpl3euon5m                        0x00005644a82c43d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                if stack.last ==\
    \ s {\n                    stack.removeLast()\n                } else {\n    \
    \                result = \"No\"\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmppkfsdxxw/tmppkfsdxxw.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aedeb183c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aedeae7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aedeae7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aedeae797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppkfsdxxw                        0x000055af66f40856 <unavailable> + 6230

    5    libc.so.6                          0x00002aedeb36f460 __libc_start_main +
    245

    6    tmppkfsdxxw                        0x000055af66f40439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n     \
    \       stack.push(s)\n        } else if s == \"}\" || s == \"]\" {\n        \
    \    if stack.len() == 0 {\n                result = \"No\"\n                break\n\
    \            }\n            stack.pop()\n        } else if stack.len() != 0 {\n\
    \            result = \"No\"\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq7ehwhbl.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"Yes\"\n                break\n            } else {\n            \
    \    stack.pop()\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpylj67bul.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.last == \"(\" || stack.last == \"{\" || stack.last == \"[\"\
    \ {\n                stack.removeLast()\n            } else {\n              \
    \  result = \"No\"\n                break\n            }\n        } else {\n \
    \           if stack.last == \"(\" || stack.last == \"{\" || stack.last == \"\
    [\" {\n                stack.removeLast()\n            } else {\n            \
    \    result = \"No\"\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp20dk6ad9/tmp20dk6ad9.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c2c227c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c2bf1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c2bf1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c2bf1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp20dk6ad9                        0x000055db325677f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9c2c413460 __libc_start_main +
    245

    6    tmp20dk6ad9                        0x000055db325673d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.len() == 0 {\n                return \"No\"\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpahr87gx1.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n            }\
    \ else {\n                stack.removeLast()\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpeik6ft9y/tmpeik6ft9y.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb03db9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb03ab0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb03ab0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb03aaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeik6ft9y                        0x00005613b4059960 <unavailable> + 6496

    5    libc.so.6                          0x00002adb03fa5460 __libc_start_main +
    245

    6    tmpeik6ft9y                        0x00005613b40593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n            }\n        } else {\n            if stack.last == \"(\" {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"No\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1d0zc25x/tmp1d0zc25x.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7cad75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7caa6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7caa6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7caa6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1d0zc25x                        0x000055ab0148a960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba7caf61460 __libc_start_main +
    245

    6    tmp1d0zc25x                        0x000055ab0148a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() == 0 {\n                return \"No\"\n            }\n         \
    \   if stack.top() == \"(\" {\n                stack.pop()\n            } else\
    \ {\n                stack.pop()\n                stack.pop()\n            }\n\
    \        }\n    }\n    if stack.len() == 0 {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpr8808ptf.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    \n    var str = \"\"\n    var stack = Stack()\n \
    \   \n    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n\
    \        } else if s == \")\" {\n            if stack.len() == 0 {\n         \
    \       return \"No\"\n            }\n            str = str + stack.pop()\n  \
    \      } else {\n            str = str + s\n        }\n    }\n    \n    if stack.len()\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpkz9vrod8.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" || str == \")\" {\n           \
    \ if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack.removeLast()\n        } else {\n           \
    \ stack.append(str)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7fdur_at/tmp7fdur_at.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b911a235c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9119f2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9119f2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9119f2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7fdur_at                        0x000055560611f7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b911a421460 __libc_start_main +
    245

    6    tmp7fdur_at                        0x000055560611f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                if stack[stack.count-1] !=\
    \ s {\n                    result = \"No\"\n                    break\n      \
    \          }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmps6z7s4zx.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s.contains(\"(\") {\n            stack.push(s)\n        } else if s.contains(\"\
    )\") {\n            if stack.count > 0 {\n                stack.pop()\n      \
    \      } else {\n                return \"No\"\n            }\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    if stack.count == 0 {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyl3kxant.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() != 0 {\n                return \"No\"\n            }\n         \
    \   res += s\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\
    \n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnupsiin.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.isEmpty {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        } else {\n            if stack.isEmpty {\n \
    \               return \"Yes\"\n            }\n        }\n    }\n    return \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9x0rajxl.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmplw57p26t/tmplw57p26t.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c3adcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c3aac2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c3aac2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c3aac17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplw57p26t                        0x00005627a4caeaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b9c3afb7460 __libc_start_main +
    245

    6    tmplw57p26t                        0x00005627a4cae3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack[stack.count-1]\
    \ == \"(\" {\n                stack[stack.count-1] += s\n            } else {\n\
    \                stack.append(s)\n            }\n        } else {\n          \
    \  if stack.count > 0 {\n                if stack[stack.count-1] == \"(\" {\n\
    \                    stack[stack.count-1] += s\n                } else {\n   \
    \                 stack.pop()\n                }\n            } else {\n     \
    \           result = \"Yes\"\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpoejbon5b.swift:26:27: error: value of type '[String]' has no member\
    \ 'pop'\n                    stack.pop()\n                    ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s.contains(\"(\") {\n            stack.push(s)\n    \
    \    } else {\n            if stack.count > 0 {\n                if stack.peek().contains(\"\
    (\") {\n                    res += stack.peek()\n                    stack.pop()\n\
    \                } else {\n                    return \"No\"\n               \
    \ }\n            } else {\n                return \"No\"\n            }\n    \
    \    }\n    }\n    if stack.count > 0 {\n        return \"No\"\n    } else {\n\
    \        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpidlri_cv.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var result = \"No\"\n    for i in lst {\n       \
    \ if i == \")\" {\n            if result == \"No\" {\n                result =\
    \ \"Yes\"\n            }\n        } else {\n            if result == \"Yes\" {\n\
    \                result = \"No\"\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6kwm7xg0/tmp6kwm7xg0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a24062c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a23d59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a23d59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a23d587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6kwm7xg0                        0x000055b7eb7b8780 <unavailable> + 6016

    5    libc.so.6                          0x00002b6a2424e460 __libc_start_main +
    245

    6    tmp6kwm7xg0                        0x000055b7eb7b81f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.len() == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        } else {\n            if\
    \ stack.len() != 0 {\n                return \"No\"\n            }\n         \
    \   res += s\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\
    \n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnupsiin.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0tg7pdul/tmp0tg7pdul.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0b7cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0b79c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0b79c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0b79c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tg7pdul                        0x0000562966dbc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab0b7ebe460 __libc_start_main +
    245

    6    tmp0tg7pdul                        0x0000562966dbc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp67hetj70.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n        } else {\n  \
    \          if stack.isEmpty {\n                return \"No\"\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7w7sfg9t/tmp7w7sfg9t.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74abf34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74abc2bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74abc2b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74abc2a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7w7sfg9t                        0x0000556e959c07f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b74ac120460 __libc_start_main +
    245

    6    tmp7w7sfg9t                        0x0000556e959c03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                result =\
    \ \"No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy5u8_2i.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                if stack.last !=\
    \ s {\n                    result = \"No\"\n                } else {\n       \
    \             stack.removeLast()\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6lklqrqe/tmp6lklqrqe.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe25e11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe25b08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe25b08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe25b077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6lklqrqe                        0x0000557f1d9b4856 <unavailable> + 6230

    5    libc.so.6                          0x00002afe25ffd460 __libc_start_main +
    245

    6    tmp6lklqrqe                        0x0000557f1d9b4439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == \"(\" && s == \"(\" {\n                    stack.pop()\n           \
    \     } else if stack[stack.count - 1] == \")\" && s == \")\" {\n            \
    \        stack.pop()\n                } else {\n                    result = \"\
    No\"\n                    break\n                }\n            } else {\n   \
    \             result = \"Yes\"\n                break\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp34ern7zj.swift:20:27: error: value of type '[String]' has no member\
    \ 'pop'\n                    stack.pop()\n                    ~~~~~ ^~~\n/tmp/tmp34ern7zj.swift:22:27:\
    \ error: value of type '[String]' has no member 'pop'\n                    stack.pop()\n\
    \                    ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.top() == \"(\" {\n                stack.pop()\n\
    \            } else {\n                res += \"No\"\n                return res\n\
    \            }\n        } else {\n            res += \"No\"\n            return\
    \ res\n        }\n    }\n    if stack.top() == \"(\" {\n        res += \"Yes\"\
    \n    } else {\n        res += \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4xzi_kl.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.len() == 0 {\n                return \"No\"\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpahr87gx1.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmprizwon.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpmprizwon.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                result =\
    \ \"No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy5u8_2i.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" {\n            stack.append(str)\n\
    \        } else if str == \")\" {\n            if stack.isEmpty {\n          \
    \      result = \"Yes\"\n                break\n            } else {\n       \
    \         stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgr3z7m_7/tmpgr3z7m_7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d331fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d32ef2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d32ef2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d32ef17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgr3z7m_7                        0x000056536bf91960 <unavailable> + 6496

    5    libc.so.6                          0x00002b0d333e7460 __libc_start_main +
    245

    6    tmpgr3z7m_7                        0x000056536bf913d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for str in lst {\n        if str == \"(\" || str == \")\" {\n           \
    \ if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack.removeLast()\n        } else {\n           \
    \ stack.append(str)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7fdur_at/tmp7fdur_at.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b911a235c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9119f2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9119f2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9119f2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7fdur_at                        0x000055560611f7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b911a421460 __libc_start_main +
    245

    6    tmp7fdur_at                        0x000055560611f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9sk9fumq/tmp9sk9fumq.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b581766ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5817365b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5817365988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58173647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9sk9fumq                        0x000055ce00494ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b581785a460 __libc_start_main +
    245

    6    tmp9sk9fumq                        0x000055ce00494559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if s.contains(\"\
    )\") {\n                    stack.removeLast()\n                } else {\n   \
    \                 result = \"Yes\"\n                    break\n              \
    \  }\n            } else {\n                result = \"Yes\"\n               \
    \ break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0x40rs9h/tmp0x40rs9h.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7433e6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7433b65b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7433b65988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7433b647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0x40rs9h                        0x000055c4192b6976 <unavailable> + 6518

    5    libc.so.6                          0x00002b743405a460 __libc_start_main +
    245

    6    tmp0x40rs9h                        0x000055c4192b6559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else {\n        return \"No\"\
    \n    }\n    guard lst[0] != \"(\" && lst[0] != \")\" && lst[1] != \"(\" && lst[1]\
    \ != \")\" else {\n        return \"No\"\n    }\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for str in lst {\n        if str == \"(\" {\n  \
    \          stack.append(str)\n        } else if str == \")\" {\n            if\
    \ stack.count > 0 {\n                stack.removeLast()\n            } else {\n\
    \                result = \"Yes\"\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpk67xyblu/tmpk67xyblu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8c6a5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8c6753b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8c6753988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8c67527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk67xyblu                        0x000055697e801846 <unavailable> + 6214

    5    libc.so.6                          0x00002ba8c6c48460 __libc_start_main +
    245

    6    tmpk67xyblu                        0x000055697e801429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpchul_lxk/tmpchul_lxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba17fdeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba17fae1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba17fae1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba17fae07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchul_lxk                        0x00005635d1dd8960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba17ffd6460 __libc_start_main +
    245

    6    tmpchul_lxk                        0x00005635d1dd83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9e_k6dx.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpn9e_k6dx.swift:16:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpn9e_k6dx.swift:17:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpn9e_k6dx.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmprizwon.swift:21:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpmprizwon.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n            if stack.isEmpty\
    \ {\n                res = res[..<res.count-1]\n            }\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.removeLast()\n            if stack.isEmpty {\n      \
    \          res = res[..<res.count-1]\n            }\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqhgg_5hs.swift:23:27: error: cannot convert value of type 'PartialRangeUpTo<Int>'\
    \ to expected argument type 'Int'\n                res = res[..<res.count-1]\n\
    \                          ^\n/tmp/tmpqhgg_5hs.swift:23:26: error: cannot assign\
    \ value of type 'Character' to type 'String'\n                res = res[..<res.count-1]\n\
    \                      ~~~^~~~~~~~~~~~~~~~\n/tmp/tmpqhgg_5hs.swift:31:27: error:\
    \ cannot convert value of type 'PartialRangeUpTo<Int>' to expected argument type\
    \ 'Int'\n                res = res[..<res.count-1]\n                         \
    \ ^\n/tmp/tmpqhgg_5hs.swift:31:26: error: cannot assign value of type 'Character'\
    \ to type 'String'\n                res = res[..<res.count-1]\n              \
    \        ~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.last == \"(\" || stack.last == \"{\" || stack.last == \"[\"\
    \ {\n                stack.pop()\n            } else {\n                result\
    \ = \"No\"\n                break\n            }\n        } else {\n         \
    \   result = \"No\"\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7smkvcku.swift:19:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n            if stack.isEmpty\
    \ {\n                res += \"(\" + s\n            } else {\n                res\
    \ += \"(\" + stack[stack.count - 1] + \")\"\n            }\n        } else {\n\
    \            if stack.isEmpty {\n                res += s\n            } else\
    \ {\n                res += stack[stack.count - 1] + s\n            }\n      \
    \  }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpirf2hmzo/tmpirf2hmzo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b831473bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8314432b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8314432988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83144317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirf2hmzo                        0x000055ac89e6b946 <unavailable> + 6470

    5    libc.so.6                          0x00002b8314927460 __libc_start_main +
    245

    6    tmpirf2hmzo                        0x000055ac89e6b529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpec_o3pw7/tmpec_o3pw7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6394242c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6393f39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6393f39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6393f387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpec_o3pw7                        0x000055890641d960 <unavailable> + 6496

    5    libc.so.6                          0x00002b639442e460 __libc_start_main +
    245

    6    tmpec_o3pw7                        0x000055890641d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"No\"\
    \n            }\n        } else {\n            if stack.count > 0 {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9nbn0slg/tmp9nbn0slg.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb99348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb9903fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb9903f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb9903e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9nbn0slg                        0x0000555cc7e7b7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002afb99534460 __libc_start_main +
    245

    6    tmp9nbn0slg                        0x0000555cc7e7b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0tg7pdul/tmp0tg7pdul.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0b7cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0b79c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0b79c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0b79c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tg7pdul                        0x0000562966dbc7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab0b7ebe460 __libc_start_main +
    245

    6    tmp0tg7pdul                        0x0000562966dbc3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k3h1vee.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptounupcz/tmptounupcz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b793127fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7930f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7930f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7930f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptounupcz                        0x0000565009c02960 <unavailable> + 6496

    5    libc.so.6                          0x00002b793146b460 __libc_start_main +
    245

    6    tmptounupcz                        0x0000565009c023d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            if\
    \ stack.last == \")\" {\n                stack.removeLast()\n            } else\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpqvac7tpf/tmpqvac7tpf.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad134372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad134069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad134069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1340687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvac7tpf                        0x000055b55a96b7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ad13455e460 __libc_start_main +
    245

    6    tmpqvac7tpf                        0x000055b55a96b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979640
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpje5dyaax/tmpje5dyaax.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fbecc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fbe9b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fbe9b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fbe9b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpje5dyaax                        0x0000555d2ca597f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9fbeeae460 __libc_start_main +
    245

    6    tmpje5dyaax                        0x0000555d2ca593d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979639
