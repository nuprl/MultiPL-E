language: swift
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = String()\n    var longestPalindromeLength = String()\n    var longestPalindromePrefix\
    \ = String()\n    var longestPalindromeSuffix = String()\n    var longestPalindromePrefixLength\
    \ = String()\n    var longestPalindromeSuffixLength = String()\n    var longestPalindromePostfix\
    \ = String()\n    var longestPalindromePostfixLength = String()\n    var longestPalindromePostfixReversed\
    \ = String()\n    var longestPalindromePostfixReversedLength = String()\n    var\
    \ longestPalindromePostfixReversedReversed = String()\n    var longestPalindromePostfixReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversed = String()\n\
    \    var longestPalindromePostfixReversedReversedReversedLength = String()\n \
    \   var longestPalindromePostfixReversedReversedReversedReversedReversed = String()\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7h39mz0t.swift:28:9: error: invalid redeclaration of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:26:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:29:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:27:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:32:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:30:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:33:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:31:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromePostfix"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = \"\"\n    for character in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            if\
    \ longestPalindromeLength > 0 {\n                longestPalindrome = longestPalindromePrefix\
    \ + longestPalindromeSuffix\n                longestPalindromeLength = 0\n   \
    \         }\n            longestPalindromePrefix = character\n            longestPalindromeSuffix\
    \ = character\n        }\n    }\n    if longestPalindromeLength > 0 {\n      \
    \  longestPalindrome = longestPalindromePrefix + longestPalindromeSuffix\n   \
    \ }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprg7l6c57.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprg7l6c57.swift:19:39:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  longestPalindromePrefix = character\n                                     \
    \ ^~~~~~~~~\n/tmp/tmprg7l6c57.swift:20:39: error: cannot assign value of type\
    \ 'Character' to type 'String'\n            longestPalindromeSuffix = character\n\
    \                                      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfReversedString\
    \ = 0\n    var longestPalindromeEndIndexOfReversedString = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeEndIndexOfReversedStringOfReversedString = 0\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbu6zg_ob.swift:17:9: error: invalid redeclaration of 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:18:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:19:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:20:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpbu6zg_ob.swift:21:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPa"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = String()\n    var longestPalindromeLength = String()\n    var longestPalindromePrefix\
    \ = String()\n    var longestPalindromeSuffix = String()\n    var longestPalindromePostfix\
    \ = String()\n    var longestPalindromePostfixLength = String()\n    var longestPalindromePostfixPrefix\
    \ = String()\n    var longestPalindromePostfixSuffix = String()\n    var longestPalindromePostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixLength = String()\n    var\
    \ longestPalindromePostfixPostfixPrefix = String()\n    var longestPalindromePostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixLength = String()\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixSuffix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPrefix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixSuffix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpekv3hrla.swift:34:9: error: invalid redeclaration of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:30:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:35:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:31:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:36:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:32:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\n   \
    \ var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:33:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:38:9: error: type annotation missing\
    \ in pattern\n    var longestP\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reverse = \"\"\n    var longest = \"\"\n    for\
    \ c in string {\n        if c != \" \" {\n            longest = longest + c\n\
    \        }\n    }\n    for c in string {\n        if c != \" \" {\n          \
    \  reverse = reverse + c\n        }\n    }\n    if longest == reverse {\n    \
    \    return string\n    }\n    var palindrome = longest\n    for c in reverse.reverse()\
    \ {\n        palindrome = palindrome + c\n    }\n    return palindrome\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk3eytrg_.swift:11:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            longest = longest + c\n    \
    \                            ^\n/tmp/tmpk3eytrg_.swift:16:33: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            reverse\
    \ = reverse + c\n                                ^\n/tmp/tmpk3eytrg_.swift:23:22:\
    \ error: value of type 'String' has no member 'reverse'\n    for c in reverse.reverse()\
    \ {\n             ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for character in string {\n\
    \        if character == \" \" {\n            continue\n        }\n        let\
    \ reversedCharacter = String((stringToReturn.characters.reversed()))\n       \
    \ if character == reversedCharacter[0] {\n            longestPalindrome = longestPalindrome\
    \ + character\n            longestPalindromeLength = longestPalindromeLength +\
    \ 1\n        } else {\n            longestPalindrome = longestPalindrome + reversedCharacter[0]\n\
    \            longestPalindromeLength = longestPalindromeLength + 1\n        }\n\
    \    }\n    if longestPalindromeLength > 1 {\n        stringToReturn = stringToReturn\
    \ + longestPalindrome\n    }\n    return stringToReturn\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpt5whsi_a.swift:14:56: error: 'characters' is unavailable: Please\
    \ use String directly\n        let reversedCharacter = String((stringToReturn.characters.reversed()))\n\
    \                                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpt5whsi_a.swift:15:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if character == reversedCharacter[0] {\n                        ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt5whsi_a.swift:16:53:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindrome = longestPalindrome + character\n             \
    \                                       ^\n/tmp/tmpt5whsi_a.swift:19:70: error:\
    \ no exact matches in call to subscript \n            longestPalindrome = longestPalindrome\
    \ + reversedCharacter[0]\n                                                   \
    \                  ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.reversed()\n    let prefixLength\
    \ = string.characters.count - reversed.characters.count\n    let postfix = string.characters.suffix(prefixLength)\n\
    \    return postfix.append(reversed).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpzq01f3mz.swift:8:59: error: value of type 'ReversedCollection<String>'\
    \ has no member 'characters'\n    let prefixLength = string.characters.count -\
    \ reversed.characters.count\n                                                \
    \ ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n\n    while stringToPalindrome.characters.count\
    \ > 0 {\n        let longestPalindromePrefix = stringToPalindrome.characters.prefix(longestPalindromePrefixLength)\n\
    \        let longestPalindromeSuffix = stringToPalindrome.characters.suffix(longestPalindromeSuffixLength)\n\
    \        let longestPalindromePrefixReverse = stringToPalindrome.characters.reversed().prefix(longestPalindromePrefixLength)\n\
    \        let longestPalindromeSuffixReverse = stringToPalindrome.characters.reversed().suffix(longestPalindromeSuffixLength)\n\
    \n        if longestPalindromePrefix == longestPalindromePrefixReverse {\n   \
    \         longestPalindromePrefixString += longestPalindromePrefix\n         \
    \   longestPalindromePrefixLength += 1\n        } else {\n            longestPalindromePrefixString\
    \ += longestPalindromePrefixReverse\n            longestPalindromePrefixLength\
    \ -= 1\n        }\n\n        if longestPalindromeSuffix == longestPalindromeSuffixReverse\
    \ {\n            longestPalindromeSuffixString += longestPalindromeSuffix\n  \
    \          longestPalindromeSuffixLength += 1\n        } else {\n            longestPalindromeSuffixString\
    \ += longestPalindromeSuffixReverse\n            longestPalindromeSuffixLength\
    \ -= 1\n        }\n\n        if longestPalindromePrefixLength > longestPalindromeSuffixLength\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ -= 1\n        }\n\n        if longestPalindromeLength > 0 {\n            stringToPalindrome\
    \ = stringToPalindrome.characters.suffix(longestPalindromeLength)\n        } else\
    \ {\n            break\n        }\n    }\n\n    return longestPalindromePrefixString\
    \ + stringToPalindrome + longestPalindromeSuffixString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnsvw826k.swift:17:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    while stringToPalindrome.characters.count > 0 {\n \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnsvw826k.swift:18:58: error: 'characters' is unavailable:\
    \ Please use String directly\n        let longestPalindromePrefix = stringToPalindrome.characters.prefix(longestPalindromePrefixLength)\n\
    \                                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpnsvw826k.swift:19:58: error: 'characters'\
    \ is unavailable: Please use String directly\n        let longestPalindromeSuffix\
    \ = stringToPalindrome.characters.suffix(longestPalindromeSuffixLength)\n    \
    \                                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpnsvw826k.swift:20:65: error: 'characters'\
    \ is unavailable: Please use String directly\n        let longestPalindromePrefixReverse\
    \ = stringToPalindrome.characters.reversed().prefix(longestPalindromePrefixLength)\n\
    \                                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpnsvw826k.swift:21:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ longestPalindromeSuffixReverse = stringToPalindrome.characters.reversed().suffix(longestPalindromeSuffixLength)\n\
    \                                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpnsvw826k.swift:23:39:\
    \ error: cannot convert value of type 'Slice<ReversedCollection<String>>' to "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for letter in string {\n        if letter == \" \" {\n            result\
    \ += letter\n            continue\n        }\n        longestPalindrome += letter\n\
    \    }\n    for letter in longestPalindrome {\n        if letter == \" \" {\n\
    \            result += letter\n            continue\n        }\n        result\
    \ += letter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpznko1axb.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpznko1axb.swift:14:30: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        longestPalindrome\
    \ += letter\n                             ^\n/tmp/tmpznko1axb.swift:18:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpznko1axb.swift:21:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += letter\n                  ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = String()\n    var longestPalindromeLength = String()\n    var longestPalindromePrefix\
    \ = String()\n    var longestPalindromeSuffix = String()\n    var longestPalindromePostfix\
    \ = String()\n    var longestPalindromePostfixLength = String()\n    var longestPalindromePostfixPrefix\
    \ = String()\n    var longestPalindromePostfixSuffix = String()\n    var longestPalindromePostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixLength = String()\n    var\
    \ longestPalindromePostfixPostfixPrefix = String()\n    var longestPalindromePostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixLength = String()\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixSuffix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPrefix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixSuffix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpekv3hrla.swift:34:9: error: invalid redeclaration of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:30:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:35:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:31:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:36:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:32:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\n   \
    \ var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:33:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:38:9: error: type annotation missing\
    \ in pattern\n    var longestP\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLen = 0\n    for _ in 0..<string.characters.count\
    \ {\n        let reversed = string.reversed()\n        let prefix = reversed.prefix(string)\n\
    \        let suffix = reversed.suffix(string)\n        if longestPalindromeLen\
    \ < prefix.characters.count {\n            longestPalindrome = prefix\n      \
    \      longestPalindromeLen = prefix.characters.count\n        }\n        if longestPalindromeLen\
    \ < suffix.characters.count {\n            longestPalindrome = suffix\n      \
    \      longestPalindromeLen = suffix.characters.count\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpx3jvet6y.swift:10:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx3jvet6y.swift:12:38: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        let prefix = reversed.prefix(string)\n\
    \                                     ^\n/tmp/tmpx3jvet6y.swift:13:38: error:\
    \ cannot convert value of type 'String' to expected argument type 'Int'\n    \
    \    let suffix = reversed.suffix(string)\n                                  \
    \   ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverse = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseSuffixLength = 0\n    var longestPalindromeSuffixStringReverseSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverse = \"\
    \"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseReverse = \"\
    \"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp1gt5mjwd.swift:23:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:22:9: note: 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:24:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:22:9: note: 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:25:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:22:9: note: 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:26:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:22:9: note: 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp1gt5mjwd.swift:27:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseSuffixStringReverseSuffixStringReverse'\n\
    \    var longestPalindromeS"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < len(longestPalindrome) {\n     \
    \           longestPalindrome = result\n                longestPalindromeLength\
    \ = len(longestPalindrome)\n            }\n            result = \"\"\n       \
    \ }\n    }\n    if longestPalindromeLength < len(longestPalindrome) {\n      \
    \  longestPalindrome = result\n        longestPalindromeLength = len(longestPalindrome)\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq4skzfd7.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpq4skzfd7.swift:14:42: error: cannot find 'len' in\
    \ scope\n            if longestPalindromeLength < len(longestPalindrome) {\n \
    \                                        ^~~\n/tmp/tmpq4skzfd7.swift:16:43: error:\
    \ cannot find 'len' in scope\n                longestPalindromeLength = len(longestPalindrome)\n\
    \                                          ^~~\n/tmp/tmpq4skzfd7.swift:21:34:\
    \ error: cannot find 'len' in scope\n    if longestPalindromeLength < len(longestPalindrome)\
    \ {\n                                 ^~~\n/tmp/tmpq4skzfd7.swift:23:35: error:\
    \ cannot find 'len' in scope\n        longestPalindromeLength = len(longestPalindrome)\n\
    \                                  ^~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixReverse = \"\"\n    var longestPalindromeSuffixReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n    var longestPalindromeSuffixReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseIndex = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmlb_hktx.swift:52:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpmlb_hktx.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpmlb_hktx.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpmlb_hktx.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpmlb_hktx.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpmlb_hktx.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpmlb_hktx.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpmlb_hktx.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpyph3zu8z.swift:16:9: error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:18:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexBeforeReverse'\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:14:9:\
    \ note: 'longestPalindromeStartIndexBeforeReverse' previously declared here\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexBeforeReverse'\n \
    \   var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:15:9:\
    \ note: 'longestPalindromeEndIndexBeforeReverse' previously declared here\n  \
    \  var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:20:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpyph3zu8z.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexB"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpux2j1qwz.swift:15:9: error: invalid redeclaration of 'longestPalindromeSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:14:9:\
    \ note: 'longestPalindromeSuffixSuffixLength' previously declared here\n    var\
    \ longestPalindromeSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:16:9:\
    \ note: 'longestPalindromeSuffixSuffixSuffixLength' previously declared here\n\
    \    var longestPalindromeSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:18:9:\
    \ note: 'longestPalindromeSuffixSuffixSuffixSuffixLength' previously declared\
    \ here\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n\
    /tmp/tmpux2j1qwz.swift:20:9: error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:18:9:\
    \ note: 'longestPalindromeSuffixSuffixSuffixSuffixLength' previously declared\
    \ here\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n\
    /tmp/tmpux2j1qwz.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:18:9:\
    \ note: 'longestPalindromeSuffixSuffixSuffixSuffixLength' previously declared\
    \ here\n    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n\
    /tmp/tmpux2j1qwz.swift:22:9: error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixSuffixLength'\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n        ^\n/tmp/tmpux2j1qwz.swift:18:9:\
    \ note: 'longestPalindromeSuffixSuffixSuffixSuffixLength' previously declared\
    \ here\n    var longestPalindrom"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverse = \"\"\n    var longestPalindromePrefixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverse = \"\"\n    var\
    \ longestPalindromePrefixReverseReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverseReverse = \"\"\n  \
    \  var longestPalindromeSuffixReverseReverseReverseReverse = \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseLength = 0\n    var\
    \ longestPalindromePrefixReverseReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseLength =\
    \ 0\n    var longestPalindromeSuffixReverseReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseLength = 0\n    var\
    \ longestPalindromePrefixReverseReverseReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseReverseLength = 0\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseReverse = \"\
    \"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse = \"\"\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseLength = 0\n\
    \    var longestPalindromeSuffixReverseReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromePrefixReverseReverse\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpje7h2vnh.swift:29:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseReverseLength = 0\n        ^\n/tmp/tmpje7h2vnh.swift:25:9:\
    \ note: 'longestPalindromeSuffixReverseReverseReverseLength' previously declared\
    \ here\n    var longestPalindromeSuffixReverseReverseReverseLength = 0\n     \
    \   ^\n/tmp/tmpje7h2vnh.swift:30:9: error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverseReverse = \"\"\n        ^\n\
    /tmp/tmpje7h2vnh.swift:26:9: note: 'longestPalindromePrefixReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpje7h2vnh.swift:31:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixReverseReverseReverseReverse'\n    var longestPalindromeSuffixReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpje7h2vnh.swift:27:9: note: 'longestPalindromeSuffixReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpje7h2vnh.swift:32:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixReverseReverseReverseReverseLength'\n    var longestPalindromePrefixReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpje7h2vnh.swift:28:9: note: 'longestPalindromePrefixReverseReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromePrefixReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpje7h2vnh.swift:33:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixReverseReverseReverseLength'\n    var longestPalindromeSuffixReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpje7h2vnh.swift:25:9: note: 'longestPalindromeSuffixReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpje7h2vnh.swift:37:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixReverseReverseReverseLength'\n    var longestPalindromeSuff"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n  \
    \  for index in 0..<string.characters.count {\n        let character = string.characters[index]\n\
    \        let reversedCharacter = reverseString(character)\n        if character\
    \ == reversedCharacter {\n            result += character\n        } else {\n\
    \            if longestPalindromeLength < index {\n                longestPalindrome\
    \ = result\n                longestPalindromeLength = index\n                longestPalindromeIndex\
    \ = index\n            }\n            result = \"\"\n        }\n    }\n    if\
    \ longestPalindromeLength < string.characters.count {\n        longestPalindrome\
    \ = result\n        longestPalindromeLength = string.characters.count\n      \
    \  longestPalindromeIndex = string.characters.count\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph22ths2l.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmph22ths2l.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph22ths2l.swift:12:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph22ths2l.swift:13:33:\
    \ error: cannot find 'reverseString' in scope\n        let reversedCharacter =\
    \ reverseString(character)\n                                ^~~~~~~~~~~~~\n/tmp/tmph22ths2l.swift:15:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n/tmp/tmph22ths2l.swift:25:41:\
    \ error: 'characters' is unavailable: Please use String directly\n    if longestPalindromeLength\
    \ < string.characters.count {\n                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph22ths2l.swift:27:42:\
    \ error: 'characters' is unavailable: Please use String directly\n        longestPalindromeLength\
    \ = string.characters.count\n                                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph22ths2l.swift:28:41:\
    \ error: 'cha"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n\n    for _ in 0..<string.characters.count\
    \ {\n        let index = string.index(string.startIndex, offsetBy: 1)\n      \
    \  let prefix = string[index...string.index(index, offsetBy: -1)]\n        let\
    \ suffix = string[string.index(index, offsetBy: -1)...string.endIndex]\n\n   \
    \     if isPalindrome(prefix) {\n            longestPalindrome = prefix\n    \
    \        longestPalindromeLength = prefix.characters.count\n            longestPalindromePrefix\
    \ = prefix\n            longestPalindromePrefixLength = prefix.characters.count\n\
    \            longestPalindromeSuffix = suffix\n            longestPalindromeSuffixLength\
    \ = suffix.characters.count\n            longestPalindromePrefixReverse = reverseString(prefix)\n\
    \            longestPalindromeSuffixReverse = reverseString(suffix)\n        }\n\
    \    }\n\n    if longestPalindromeLength > longestPalindromePrefixLength {\n \
    \       string = longestPalindromePrefixReverse\n    } else {\n        string\
    \ = longestPalindromeSuffixReverse\n    }\n\n    return string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf754ht2w.swift:17:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpf754ht2w.swift:22:12: error: cannot find 'isPalindrome' in scope\n\
    \        if isPalindrome(prefix) {\n           ^~~~~~~~~~~~\n/tmp/tmpf754ht2w.swift:23:33:\
    \ error: cannot assign value of type 'String.SubSequence' (aka 'Substring') to\
    \ type 'String'\n            longestPalindrome = prefix\n                    \
    \            ^~~~~~\n                                String( )\n/tmp/tmpf754ht2w.swift:24:46:\
    \ error: 'characters' is unavailable: Please use Substring directly\n        \
    \    longestPalindromeLength = prefix.characters.count\n                     \
    \                        ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmpf754ht2w.swift:25:39: error: cannot assign value of\
    \ type 'String.SubSequence' (aka 'Substring') to type 'String'\n            longestPalindromePrefix\
    \ = prefix\n                                      ^~~~~~\n                   \
    \                   String( )\n/tmp/tmpf754ht2w.swift:26:52: error: 'characters'\
    \ is unavailable: Please use Substring directly\n            longestPalindromePrefixLength\
    \ = prefix.characters.count\n                                                \
    \   ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n/tmp/tmpf754ht2w.swift:27:39:\
    \ error: cannot assign value of type 'String.SubSequence' (aka 'Substring') to\
    \ type 'String'\n            longestPalindromeSuffix = suffix\n              \
    \                        ^~~~~~\n                                      String(\
    \ )\n/tmp/tmpf754ht2w.swift:28:52: error: 'characters' is unavailable: Please\
    \ use Substring directly\n            longestPalindromeSuffixLength = suffix.char"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    for _ in 0..<string.count\
    \ {\n        let index = string.index(longestPalindrome)\n        let substring\
    \ = string[index...].lowercased\n        let reversedSubstring = reversedString.lowercased\n\
    \        if substring == reversedSubstring {\n            longestPalindromeLength\
    \ += 1\n        } else {\n            if longestPalindromeLength > longestPalindrome.count\
    \ {\n                longestPalindrome = string\n                longestPalindromeLength\
    \ = longestPalindrome.count\n            }\n            reversedString = reversedString.dropLast()\n\
    \        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6_wk2srw.swift:11:28: error: no exact matches in call to instance\
    \ method 'index'\n        let index = string.index(longestPalindrome)\n      \
    \                     ^\n/tmp/tmp6_wk2srw.swift:11:28: note: candidate expects\
    \ value of type 'String.Index' for parameter #1 (got '@lvalue String')\n     \
    \   let index = string.index(longestPalindrome)\n                           ^\n\
    /tmp/tmp6_wk2srw.swift:11:28: note: candidate expects value of type 'String.Index'\
    \ for parameter #1 (got '@lvalue String')\n        let index = string.index(longestPalindrome)\n\
    \                           ^\n/tmp/tmp6_wk2srw.swift:11:28: note: candidate expects\
    \ value of type '(String.Element) throws -> Bool' (aka '(Character) throws ->\
    \ Bool') for parameter #1 (got '@lvalue String')\n        let index = string.index(longestPalindrome)\n\
    \                           ^\n/tmp/tmp6_wk2srw.swift:11:28: note: candidate expects\
    \ value of type 'String.Element' (aka 'Character') for parameter #1 (got '@lvalue\
    \ String')\n        let index = string.index(longestPalindrome)\n            \
    \               ^\n/tmp/tmp6_wk2srw.swift:12:31: error: no exact matches in call\
    \ to subscript \n        let substring = string[index...].lowercased\n       \
    \                       ^\n/tmp/tmp6_wk2srw.swift:12:31: note: found candidate\
    \ with type '(String.Index) -> Character'\n        let substring = string[index...].lowercased\n\
    \                              ^\n/tmp/tmp6_wk2srw.swift:12:31: note: found candidate\
    \ with type '(Range<String.Index>) -> Substring'\n        let substring = string[index...].lowercased\n\
    \                              ^\n/tmp/tmp6_wk2srw.swift:12:31: note: found candidate\
    \ with type '(()) -> String.SubSequence' (aka '(()) -> Substring')\n        let\
    \ substring = string[index...].lowercased\n                              ^\n/tmp/tmp6_wk2srw.swift:12:31:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> String.SubSequence'\
    \ (aka '((UnboundedRange_) -> ()) -> Substring')\n        let substring = string[index...].lowercased\n\
    \                              ^\n/tmp/tmp6_wk2srw.swift:21"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n\n    for _ in 0..<string.characters.count\
    \ {\n        let currentChar = string.characters[string.startIndex]\n        let\
    \ currentCharIsPalindrome = currentChar == string.reverse(currentChar)\n\n   \
    \     if currentCharIsPalindrome {\n            longestPalindrome = string\n \
    \           longestPalindromeLength = string.characters.count\n            longestPalindromePrefix\
    \ = string\n            longestPalindromePrefixLength = string.characters.count\n\
    \            longestPalindromeSuffix = string\n            longestPalindromeSuffixLength\
    \ = string.characters.count\n            longestPalindromePrefixReverse = string\n\
    \            longestPalindromeSuffixReverse = string\n        } else {\n     \
    \       if longestPalindromeLength > longestPalindromePrefixLength {\n       \
    \         longestPalindrome = string\n                longestPalindromeLength\
    \ = string.characters.count\n                longestPalindromePrefix = string\n\
    \                longestPalindromePrefixLength = string.characters.count\n   \
    \             longestPalindromeSuffix = string\n                longestPalindromeSuffixLength\
    \ = string.characters.count\n                longestPalindromePrefixReverse =\
    \ string\n                longestPalindromeSuffixReverse = string\n          \
    \  }\n\n            if longestPalindromeLength > longestPalindromeSuffixLength\
    \ {\n                longestPalindrome = string\n                longestPalindromeLength\
    \ = string.characters.count\n                longestPalindromePrefix = string\n\
    \                longestPalindromePrefixLength = string.characters.count\n   \
    \             longestPalindromeSuffix = string\n                longestPalindromeSuffixLength\
    \ = string.characters.count\n                longestPalindromePrefixReverse =\
    \ string\n                longestPalindromeSuffixReverse = string\n          \
    \  }\n\n            if longestPalindromeLength > longestPalindromePrefixLength\
    \ && longestPalindromeLength > longestPalindromeSuffixLength {\n             \
    \   longestPalindrome = string\n                longestPalindromeLength = string.characters.count\n\
    \                longestPalindromePrefix = string\n                longestPalindromePrefixLength\
    \ = string.characters.count\n                longestPalindromeSuffix = string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpgw6s2ugm.swift:78:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmpgw6s2ugm.swift:30:16: note:\
    \ to match this opening '{'\n        } else {\n               ^\n/tmp/tmpgw6s2ugm.swift:78:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmpgw6s2ugm.swift:17:42: note: to match this opening '{'\n\
    \    for _ in 0..<string.characters.count {\n                                \
    \         ^\n/tmp/tmpgw6s2ugm.swift:78:56: error: expected '}' at end of brace\
    \ statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n   \
    \                                                    ^\n/tmp/tmpgw6s2ugm.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmpgw6s2ugm.swift:17:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    for _ in\
    \ 0..<string.characters.count {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgw6s2ugm.swift:18:34: error: 'characters'\
    \ is unavailable: Please use String directly\n        let currentChar = string.characters[string.startIndex]\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgw6s2ugm.swift:19:61: error: value of type 'String'\
    \ has no member 'reverse'\n        let currentCharIsPalindrome = currentChar ==\
    \ string.reverse(currentChar)\n                                              \
    \       ~~~~~~ ^~~~~~~\n/tmp/tmpgw6s2ugm.swift:23:46: error: 'characters' is unavailable:\
    \ Please use String directly\n            longestPalindromeLength = string.characters.count\n\
    \                                             ^~~~~~~~~~\nSwift.S"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for index in 0..<string.characters.count\
    \ {\n        let char = string.characters[index]\n        if char == char.lowercased().reversed().first\
    \ {\n            reversedString.append(char)\n            if reversedString.characters.count\
    \ > longestPalindromeLength {\n                longestPalindrome = reversedString\n\
    \                longestPalindromeLength = reversedString.characters.count\n \
    \           }\n        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpolfwro15.swift:10:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpolfwro15.swift:11:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = string.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpolfwro15.swift:11:27:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = string.characters[index]\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpolfwro15.swift:14:31: error: 'characters'\
    \ is unavailable: Please use String directly\n            if reversedString.characters.count\
    \ > longestPalindromeLength {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpolfwro15.swift:16:58: error: 'characters'\
    \ is unavailable: Please use String directly\n                longestPalindromeLength\
    \ = reversedString.characters.count\n                                        \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < character.count {\n            \
    \    longestPalindrome = character\n                longestPalindromeLength =\
    \ character.count\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ > 0 {\n        result += longestPalindrome.repeat(longestPalindromeLength)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp34u60e15.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmp34u60e15.swift:14:52: error: value of type 'Character'\
    \ has no member 'count'\n            if longestPalindromeLength < character.count\
    \ {\n                                         ~~~~~~~~~ ^~~~~\n/tmp/tmp34u60e15.swift:15:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = character\n                                    ^~~~~~~~~\n\
    /tmp/tmp34u60e15.swift:16:53: error: value of type 'Character' has no member 'count'\n\
    \                longestPalindromeLength = character.count\n                 \
    \                         ~~~~~~~~~ ^~~~~\n/tmp/tmp34u60e15.swift:21:37: error:\
    \ value of type 'String' has no member 'repeat'\n        result += longestPalindrome.repeat(longestPalindromeLength)\n\
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix = 0\n\
    \    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixPrefix = \"\"\n    var longestPalindromeSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixIndex = 0\n    var longestPalindromeSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixPrefix = \"\"\n    var longestPalindromeSuffixSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixIndex = 0\n    var longestPalindromeSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixPrefix = \"\"\n    var longestPalindromeSuffixSuffixSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixIndex = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixPrefix = \"\"\n    var\
    \ longestPalindromeSuffixSuffixSuffixSuffixSuffix = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixLength = 0\n   \
    \ var longestPalindromeSuffixSuffixSuffixSuffixSuffixPrefix = \"\"\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex = 0\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n   \
    \ var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix = \"\"\n   \
    \ var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix = 0\n    var\
    \ longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix = \"\
    \"\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix\
    \ = \"\"\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphruz53c4.swift:37:9: error: invalid redeclaration of 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex'\n\
    \    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex = 0\n    \
    \    ^\n/tmp/tmphruz53c4.swift:33:9: note: 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex'\
    \ previously declared here\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixIndex\
    \ = 0\n        ^\n/tmp/tmphruz53c4.swift:38:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength'\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength\
    \ = 0\n        ^\n/tmp/tmphruz53c4.swift:34:9: note: 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength'\
    \ previously declared here\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength\
    \ = 0\n        ^\n/tmp/tmphruz53c4.swift:39:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix'\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix\
    \ = \"\"\n        ^\n/tmp/tmphruz53c4.swift:35:9: note: 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix'\
    \ previously declared here\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix\
    \ = \"\"\n        ^\n/tmp/tmphruz53c4.swift:44:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix'\n   \
    \ var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = 0\n\
    \        ^\n/tmp/tmphruz53c4.swift:40:9: note: 'longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix'\
    \ previously declared here\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix\
    \ = 0\n        ^\n/tmp/tmphruz53c4.swift:46:9: error: type annotation missing\
    \ in pattern\n    var longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = stringToPalindrome.characters.count\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix = \"\"\
    \n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n\n    for _ in 0..<stringToPalindrome.characters.count {\n        let currentChar\
    \ = stringToPalindrome.characters[longestPalindromeLength]\n        let currentCharIndex\
    \ = longestPalindromeLength - 1\n\n        if currentChar == currentCharIndex\
    \ {\n            longestPalindromeLength -= 1\n            longestPalindromePrefix\
    \ = stringToPalindrome.substringToIndex(longestPalindromeLength)\n           \
    \ longestPalindromeSuffixLength = longestPalindromeLength\n        } else {\n\
    \            longestPalindromeLength -= 1\n            longestPalindromeSuffix\
    \ = stringToPalindrome.substringToIndex(longestPalindromeLength)\n           \
    \ longestPalindromePrefixLength = longestPalindromeLength\n        }\n    }\n\n\
    \    if longestPalindromeLength > 0 {\n        let longestPalindromePrefix = stringToPalindrome.substringToIndex(longestPalindromeLength)\n\
    \        let longestPalindromeSuffix = stringToPalindrome.substringFromIndex(longestPalindromeLength)\n\
    \        let longestPalindromePrefixLength = longestPalindromeLength\n       \
    \ let longestPalindromeSuffixLength = longestPalindromeLength\n        stringToPalindrome\
    \ = stringToPalindrome.stringByReplacingOccurrencesOfString(longestPalindromePrefix,\
    \ withString: longestPalindromeSuffix)\n    }\n\n    return stringToPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp__c358aq.swift:9:54: error: 'characters' is unavailable: Please\
    \ use String directly\n    var longestPalindromeLength = stringToPalindrome.characters.count\n\
    \                                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp__c358aq.swift:15:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    for _ in 0..<stringToPalindrome.characters.count\
    \ {\n                                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp__c358aq.swift:16:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let currentChar = stringToPalindrome.characters[longestPalindromeLength]\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp__c358aq.swift:16:46:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = stringToPalindrome.characters[longestPalindromeLength]\n     \
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp__c358aq.swift:19:24: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'Int'\n        if\
    \ currentChar == currentCharIndex {\n           ~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~\n\
    /tmp/tmp__c358aq.swift:19:24: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (Int, Int)\n        if currentChar\
    \ == currentCharIndex {\n                       ^\n/tmp/tmp__c358aq.swift:21:58:\
    \ error: value of type 'String' has no member 'substringToIndex'\n           \
    \ longestPalindromePrefix = stringToPalindrome."
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = \"\"\n    var stringPrefix = \"\
    \"\n    var stringSuffix = \"\"\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = \"\"\n\n    for character in string {\n        stringPrefix = stringPrefix\
    \ + character\n        stringSuffix = stringSuffix + character\n    }\n\n    longestPalindromeLength\
    \ = stringSuffix.count\n    longestPalindromePrefix = stringPrefix\n    longestPalindromeSuffix\
    \ = stringSuffix\n\n    for character in string {\n        if character == stringSuffix.first\
    \ {\n            longestPalindromeLength = longestPalindromeLength - 1\n     \
    \       longestPalindromeSuffix = stringSuffix.suffix(string: longestPalindromeSuffix)\n\
    \        }\n        if character == stringPrefix.first {\n            longestPalindromeLength\
    \ = longestPalindromeLength - 1\n            longestPalindromePrefix = stringPrefix.prefix(string:\
    \ longestPalindromePrefix)\n        }\n    }\n\n    if longestPalindromeLength\
    \ > 0 {\n        stringToReturn = stringToReturn + stringPrefix.prefix(string:\
    \ longestPalindromePrefix) + stringSuffix.suffix(string: longestPalindromeSuffix)\n\
    \    }\n\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfka90isc.swift:16:39: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        stringPrefix = stringPrefix + character\n\
    \                                      ^\n/tmp/tmpfka90isc.swift:17:39: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        stringSuffix = stringSuffix + character\n                           \
    \           ^\n/tmp/tmpfka90isc.swift:27:52: error: no exact matches in call to\
    \ instance method 'suffix'\n            longestPalindromeSuffix = stringSuffix.suffix(string:\
    \ longestPalindromeSuffix)\n                                                 \
    \  ^\n/tmp/tmpfka90isc.swift:27:52: note: found candidate with type '(Int) ->\
    \ [String.Element]' (aka '(Int) -> Array<Character>')\n            longestPalindromeSuffix\
    \ = stringSuffix.suffix(string: longestPalindromeSuffix)\n                   \
    \                                ^\n/tmp/tmpfka90isc.swift:27:52: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \            longestPalindromeSuffix = stringSuffix.suffix(string: longestPalindromeSuffix)\n\
    \                                                   ^\n/tmp/tmpfka90isc.swift:27:52:\
    \ error: no 'suffix' candidates produce the expected contextual result type 'String'\n\
    \            longestPalindromeSuffix = stringSuffix.suffix(string: longestPalindromeSuffix)\n\
    \                                                   ^\nSwift.Sequence:3:40: note:\
    \ 'suffix' produces '[String.Element]' (aka 'Array<Character>'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func suffix(_\
    \ maxLength: Int) -> [Self.Element]\n                                       ^\n\
    Swift.Collection:8:40: note: 'suffix' produces 'String.SubSequence' (aka 'Substring'),\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func suffix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\nSwift.BidirectionalCollection:3:40: note: 'suffix' produces\
    \ 'String.SubSequence' (aka 'Substring'), n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindrome = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpooutr3qj.swift:23:9: error: type annotation missing in pattern\n\
    \    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength = 0\n \
    \   var longestPalindromeSuffixStringReverseStringReverse = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength = 0\n \
    \   var longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverseIndex = 0\n  \
    \  var longestPalindromeSuffixStringReverseStringReverseStringReverseLength =\
    \ 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprttutc9p.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n        ^\n\
    /tmp/tmprttutc9p.swift:18:9: note: 'longestPalindromeSuffixStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:22:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseLength'\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:19:9: note: 'longestPalindromeSuffixStringReverseStringReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:27:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverseIndex = 0\n  \
    \      ^\n/tmp/tmprttutc9p.swift:24:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:28:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseLength'\n   \
    \ var longestPalindromeSuffixStringReverseStringReverseStringReverseLength = 0\n\
    \        ^\n/tmp/tmprttutc9p.swift:25:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:33:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmprttutc9p.swift:30:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex'\
    \ previously decl"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    for _ in 0..<string.characters.count {\n        let index = string.index(string.startIndex,\
    \ offsetBy: 1)\n        let char = string[index]\n        let reversedChar = String(string[..<index])\n\
    \        if char == reversedChar {\n            palindrome = palindrome.replacingOccurrences(of:\
    \ char, with: reversedChar)\n            longestPalindromeLength = palindrome.characters.count\n\
    \            longestPalindromePrefixLength = index\n        }\n    }\n    if longestPalindromeLength\
    \ > longestPalindromePrefixLength {\n        palindrome = palindrome.replacingOccurrences(of:\
    \ longestPalindrome[longestPalindromePrefixLength..<longestPalindrome.characters.count],\
    \ with: longestPalindrome[longestPalindromePrefixLength..<longestPalindrome.characters.count].reversed())\n\
    \    }\n    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmputouvtkj.swift:11:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmputouvtkj.swift:15:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == reversedChar\
    \ {\n           ~~~~ ^  ~~~~~~~~~~~~\n/tmp/tmputouvtkj.swift:15:17: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == reversedChar {\n                ^\n/tmp/tmputouvtkj.swift:16:37:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     palindrome = palindrome.replacingOccurrences(of: char, with: reversedChar)\n\
    \                         ~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmputouvtkj.swift:17:50:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ longestPalindromeLength = palindrome.characters.count\n                    \
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmputouvtkj.swift:18:45: error: cannot assign value of\
    \ type 'String.Index' to type 'Int'\n            longestPalindromePrefixLength\
    \ = index\n                                            ^~~~~\n/tmp/tmputouvtkj.swift:22:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ palindrome = palindrome.replacingOccurrences(of: longestPalindrome[longestPalindromePrefixLength..<longestPalindrome.characters.count],\
    \ with: longestPalindrome[longestPalindromePrefixLength..<longestPalindrome.characters.count].reversed())\n\
    \                     ~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringIndex in 0..<string.count\
    \ {\n        let stringPrefix = string.prefix(stringIndex)\n        let stringSuffix\
    \ = string.suffix(stringIndex)\n        let stringToCheck = stringPrefix + stringSuffix\n\
    \        let stringToCheckReversed = stringToCheck.reversed()\n        if stringToCheck\
    \ == stringToCheckReversed {\n            if stringToCheck.count > longestPalindromeLength\
    \ {\n                longestPalindrome = stringToCheck\n                longestPalindromeLength\
    \ = stringToCheck.count\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ > 0 {\n        stringToReturn = stringToReturn + longestPalindrome\n    }\n\
    \    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpw78q390s.swift:15:29: error: cannot convert value of type 'ReversedCollection<String.SubSequence>'\
    \ (aka 'ReversedCollection<Substring>') to expected argument type 'String.SubSequence'\
    \ (aka 'Substring')\n        if stringToCheck == stringToCheckReversed {\n   \
    \                         ^\n/tmp/tmpw78q390s.swift:17:37: error: cannot assign\
    \ value of type 'String.SubSequence' (aka 'Substring') to type 'String'\n    \
    \            longestPalindrome = stringToCheck\n                             \
    \       ^~~~~~~~~~~~~\n                                    String(      )\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpilw0tntk.swift:16:9: error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:18:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexBeforeReverse'\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:14:9:\
    \ note: 'longestPalindromeStartIndexBeforeReverse' previously declared here\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexBeforeReverse'\n \
    \   var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:15:9:\
    \ note: 'longestPalindromeEndIndexBeforeReverse' previously declared here\n  \
    \  var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:20:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpilw0tntk.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexB"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for index in 0..<string.count\
    \ {\n        let character = string[index]\n        let reversedCharacter = reversedString[index]\n\
    \        if character == reversedCharacter {\n            longestPalindromeLength\
    \ += 1\n        } else {\n            if longestPalindromeLength > longestPalindrome.characters.count\
    \ {\n                longestPalindrome = String(string[longestPalindromeLength..<string.count])\n\
    \                longestPalindromeLength = longestPalindrome.characters.count\n\
    \            }\n        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvcbke0zp.swift:11:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string[index]\n                        ^~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpvcbke0zp.swift:12:33: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        let reversedCharacter = reversedString[index]\n          \
    \                      ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvcbke0zp.swift:16:60: error: 'characters'\
    \ is unavailable: Please use String directly\n            if longestPalindromeLength\
    \ > longestPalindrome.characters.count {\n                                   \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvcbke0zp.swift:17:44: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \                longestPalindrome = String(string[longestPalindromeLength..<string.count])\n\
    \                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpvcbke0zp.swift:18:61: error: 'characters'\
    \ is unavailable: Please use String directly\n                longestPalindromeLength\
    \ = longestPalindrome.characters.count\n                                     \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvcbke0zp.swift:7:9: warning: v"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for character in string {\n        if character == character {\n       \
    \     result += character\n        } else {\n            longestPalindrome +=\
    \ character\n        }\n    }\n    for character in string {\n        if character\
    \ == character {\n            result += character\n        } else {\n        \
    \    result += longestPalindrome\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpn0wgcxyo.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpn0wgcxyo.swift:13:34: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            longestPalindrome\
    \ += character\n                                 ^\n/tmp/tmpn0wgcxyo.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixReverse = \"\"\n\n    for stringToPalindrome.characters.count\
    \ > 0 {\n        let characterToPalindrome = stringToPalindrome.characters.first!\n\
    \        let characterToPalindromeLength = stringToPalindrome.characters.count\n\
    \        let characterToPalindromePrefix = stringToPalindrome[longestPalindromeIndex..<longestPalindromeIndex+longestPalindromeLength]\n\
    \        let characterToPalindromeSuffix = stringToPalindrome[longestPalindromeSuffixIndex..<longestPalindromeSuffixIndex+longestPalindromeSuffixLength]\n\
    \        let characterToPalindromeSuffixReverse = stringToPalindrome[longestPalindromeSuffixIndex..<longestPalindromeSuffixIndex+longestPalindromeSuffixLength].reversed()\n\
    \n        if characterToPalindromeLength > longestPalindromeLength {\n       \
    \     longestPalindrome = stringToPalindrome\n            longestPalindromeLength\
    \ = characterToPalindromeLength\n            longestPalindromeIndex = longestPalindromeIndex\
    \ + 1\n            longestPalindromePrefix = characterToPalindromePrefix\n   \
    \         longestPalindromeSuffix = characterToPalindromeSuffix\n            longestPalindromeSuffixIndex\
    \ = longestPalindromeSuffixIndex + 1\n            longestPalindromeSuffixLength\
    \ = characterToPalindromeSuffixLength\n            longestPalindromeSuffixReverse\
    \ = characterToPalindromeSuffixReverse\n        }\n        if characterToPalindromeLength\
    \ == longestPalindromeLength {\n            if characterToPalindromePrefix ==\
    \ longestPalindromePrefix {\n                if characterToPalindromeSuffix ==\
    \ longestPalindromeSuffix {\n                    if characterToPalindromeSuffixReverse\
    \ == longestPalindromeSuffixReverse {\n                        stringToPalindrome\
    \ = stringToPalindrome[longestPalindromeSuffixIndex..<longestPalindromeSuffixIndex+longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpwf2rspdt.swift:17:27: error: expected 'in' after for-each pattern\n\
    \    for stringToPalindrome.characters.count > 0 {\n                         \
    \ ^\n/tmp/tmpwf2rspdt.swift:39:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpwf2rspdt.swift:38:64: note: to match this opening '['\n           \
    \             stringToPalindrome = stringToPalindrome[longestPalindromeSuffixIndex..<longestPalindromeSuffixIndex+longest\n\
    \                                                               ^\n/tmp/tmpwf2rspdt.swift:58:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmpwf2rspdt.swift:36:75: note: to match this opening '{'\n\
    \                if characterToPalindromeSuffix == longestPalindromeSuffix {\n\
    \                                                                          ^\n\
    /tmp/tmpwf2rspdt.swift:58:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmpwf2rspdt.swift:35:71: note:\
    \ to match this opening '{'\n            if characterToPalindromePrefix == longestPalindromePrefix\
    \ {\n                                                                      ^\n\
    /tmp/tmpwf2rspdt.swift:58:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmpwf2rspdt.swift:34:67: note:\
    \ to match this opening '{'\n        if characterToPalindromeLength == longestPalindromeLength\
    \ {\n                                                                  ^\n/tmp/tmpwf2rspdt.swift:58:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmpwf2rspdt.swift:17:49: note: to match this opening '{'\n\
    \    for stringToPalindrome.characters.count > 0 {\n                         \
    \                       ^\n/tmp/tmpwf2rspdt.swift:58:56:"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var longestPalindrome =\
    \ \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromePrefixStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromePrefixStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverse = \"\"\n \
    \   var longestPalindromePrefixStringReverseStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseStringReverseString = \"\"\n\
    \    var longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverseLength = 0\n \
    \   var longestPalindromeSuffixStringReverseStringReverseStringReverseLength =\
    \ 0\n    var longestPalindromePrefixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverse\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp05m53hci.swift:33:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:31:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:34:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:32:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:35:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:36:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmp05m53hci.swift:39:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longe"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n\n    for stringIndex in 0..<string.characters.count {\n        let\
    \ stringCharacter = string.characters[stringIndex]\n        let stringCharacterIsPalindrome\
    \ = stringCharacter == string.reversed()\n\n        if stringCharacterIsPalindrome\
    \ {\n            if longestPalindromeLength < stringCharacterLength {\n      \
    \          longestPalindrome = string\n                longestPalindromeLength\
    \ = stringCharacterLength\n                longestPalindromeIndex = stringIndex\n\
    \                longestPalindromePrefixIndex = longestPalindromeIndex\n     \
    \           longestPalindromeSuffixIndex = longestPalindromeIndex\n          \
    \      longestPalindromeSuffixLength = stringCharacterLength\n               \
    \ longestPalindromeSuffixString = string\n            }\n        } else {\n  \
    \          if longestPalindromeLength > stringCharacterLength {\n            \
    \    longestPalindrome = string\n                longestPalindromeLength = stringCharacterLength\n\
    \                longestPalindromeIndex = stringIndex\n                longestPalindromePrefixIndex\
    \ = longestPalindromeIndex\n                longestPalindromeSuffixIndex = longestPalindromeIndex\n\
    \                longestPalindromeSuffixLength = stringCharacterLength\n     \
    \           longestPalindromeSuffixString = string\n            }\n        }\n\
    \    }\n\n    if longestPalindromeLength > stringCharacterLength {\n        longestPalindrome\
    \ = string\n        longestPalindromeLength = stringCharacterLength\n        longestPalindromeIndex\
    \ = stringIndex\n        longestPalindromePrefixIndex = longestPalindromeIndex\n\
    \        longestPalindromeSuffixIndex = longestPalindromeIndex\n        longestPalindromeSuffixLength\
    \ = stringCharacterLength\n        longestPalindromeSuffixString = string\n  \
    \  }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpahsy7wqt.swift:16:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringIndex in 0..<string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpahsy7wqt.swift:17:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ stringCharacter = string.characters[stringIndex]\n                         \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpahsy7wqt.swift:17:38: error: 'characters'\
    \ is unavailable: Please use String directly\n        let stringCharacter = string.characters[stringIndex]\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpahsy7wqt.swift:18:59: error: binary operator '==' cannot\
    \ be applied to operands of type 'Character' and '[String.Element]' (aka 'Array<Character>')\n\
    \        let stringCharacterIsPalindrome = stringCharacter == string.reversed()\n\
    \                                          ~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpahsy7wqt.swift:18:59: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character)\n        let stringCharacterIsPalindrome\
    \ = stringCharacter == string.reversed()\n                                   \
    \                       ^\n/tmp/tmpahsy7wqt.swift:21:42: error: cannot find 'stringCharacterLength'\
    \ in scope\n            if longestPalindromeLength < stringCharacterLength {\n\
    \                                         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpahsy7wqt.swift:23:43:\
    \ error: cannot find 'stringCharacterLength' in scope\n                longestPalindromeLength\
    \ = stringCharacterLength\n                                          ^~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversedString = string.reversed()\n    let longestPalindrome\
    \ = reversedString.prefix(string)\n    return longestPalindrome + string\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmptf0kzzw_.swift:8:51: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    let longestPalindrome = reversedString.prefix(string)\n\
    \                                                  ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n\n    for character in string {\n\
    \        if character == character[character.startIndex] {\n            reversedString\
    \ += character\n        } else {\n            if longestPalindromeLength < character.startIndex\
    \ {\n                longestPalindrome = reversedString\n                longestPalindromeLength\
    \ = character.startIndex\n            }\n            reversedString = \"\"\n \
    \       }\n    }\n\n    if longestPalindromeLength < string.endIndex {\n     \
    \   longestPalindrome = reversedString\n        longestPalindromeLength = string.endIndex\n\
    \    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp281u3rf6.swift:12:34: error: value of type 'Character' has no subscripts\n\
    \        if character == character[character.startIndex] {\n                 \
    \       ~~~~~~~~~^\n/tmp/tmp281u3rf6.swift:12:45: error: value of type 'Character'\
    \ has no member 'startIndex'\n        if character == character[character.startIndex]\
    \ {\n                                  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp281u3rf6.swift:13:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reversedString += character\n                              ^\n/tmp/tmp281u3rf6.swift:15:52:\
    \ error: value of type 'Character' has no member 'startIndex'\n            if\
    \ longestPalindromeLength < character.startIndex {\n                         \
    \                ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp281u3rf6.swift:17:53: error: value\
    \ of type 'Character' has no member 'startIndex'\n                longestPalindromeLength\
    \ = character.startIndex\n                                          ~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp281u3rf6.swift:23:32: error: operator function '<' requires\
    \ that 'String.Index' conform to 'BinaryInteger'\n    if longestPalindromeLength\
    \ < string.endIndex {\n                               ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmp281u3rf6.swift:25:42: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        longestPalindromeLength = string.endIndex\n         \
    \                         ~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < len(result) - 1 {\n            \
    \    longestPalindrome = result\n                longestPalindromeLength = len(result)\n\
    \            }\n            result = \"\"\n        }\n    }\n    if longestPalindromeLength\
    \ < len(result) - 1 {\n        longestPalindrome = result\n        longestPalindromeLength\
    \ = len(result)\n    }\n    if longestPalindromeLength > 0 {\n        result +=\
    \ string[longestPalindromeLength..]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2wq2vmfc.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmp2wq2vmfc.swift:14:42: error: cannot find 'len' in\
    \ scope\n            if longestPalindromeLength < len(result) - 1 {\n        \
    \                                 ^~~\n/tmp/tmp2wq2vmfc.swift:16:43: error: cannot\
    \ find 'len' in scope\n                longestPalindromeLength = len(result)\n\
    \                                          ^~~\n/tmp/tmp2wq2vmfc.swift:21:34:\
    \ error: cannot find 'len' in scope\n    if longestPalindromeLength < len(result)\
    \ - 1 {\n                                 ^~~\n/tmp/tmp2wq2vmfc.swift:23:35: error:\
    \ cannot find 'len' in scope\n        longestPalindromeLength = len(result)\n\
    \                                  ^~~\n/tmp/tmp2wq2vmfc.swift:26:49: error: cannot\
    \ find operator '..' in scope; did you mean '...'?\n        result += string[longestPalindromeLength..]\n\
    \                                                ^~\n                        \
    \                        ...\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < character.count {\n            \
    \    longestPalindrome = character\n                longestPalindromeLength =\
    \ character.count\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ == 0 {\n        return \"\"\n    }\n    if longestPalindromeLength > 0 {\n \
    \       result += longestPalindrome.reversed()\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe_0rtk8f.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpe_0rtk8f.swift:14:52: error: value of type 'Character'\
    \ has no member 'count'\n            if longestPalindromeLength < character.count\
    \ {\n                                         ~~~~~~~~~ ^~~~~\n/tmp/tmpe_0rtk8f.swift:15:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = character\n                                    ^~~~~~~~~\n\
    /tmp/tmpe_0rtk8f.swift:16:53: error: value of type 'Character' has no member 'count'\n\
    \                longestPalindromeLength = character.count\n                 \
    \                         ~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < character.count {\n            \
    \    longestPalindrome = character\n                longestPalindromeLength =\
    \ character.count\n            }\n        }\n    }\n    for character in string\
    \ {\n        if character == character {\n            result += character\n  \
    \      } else {\n            if longestPalindromeLength < character.count {\n\
    \                longestPalindrome = character\n                longestPalindromeLength\
    \ = character.count\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ == 0 {\n        return \"\"\n    }\n    if longestPalindromeLength < result.count\
    \ {\n        result = result.replacingOccurrences(of: longestPalindrome, with:\
    \ \"\")\n    }\n    if longestPalindromeLength > result.count {\n        result\
    \ = longestPalindrome\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpafo8pj_v.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpafo8pj_v.swift:14:52: error: value of type 'Character'\
    \ has no member 'count'\n            if longestPalindromeLength < character.count\
    \ {\n                                         ~~~~~~~~~ ^~~~~\n/tmp/tmpafo8pj_v.swift:15:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = character\n                                    ^~~~~~~~~\n\
    /tmp/tmpafo8pj_v.swift:16:53: error: value of type 'Character' has no member 'count'\n\
    \                longestPalindromeLength = character.count\n                 \
    \                         ~~~~~~~~~ ^~~~~\n/tmp/tmpafo8pj_v.swift:22:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n/tmp/tmpafo8pj_v.swift:24:52:\
    \ error: value of type 'Character' has no member 'count'\n            if longestPalindromeLength\
    \ < character.count {\n                                         ~~~~~~~~~ ^~~~~\n\
    /tmp/tmpafo8pj_v.swift:25:37: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                longestPalindrome = character\n             \
    \                       ^~~~~~~~~\n/tmp/tmpafo8pj_v.swift:26:53: error: value\
    \ of type 'Character' has no member 'count'\n                longestPalindromeLength\
    \ = character.count\n                                          ~~~~~~~~~ ^~~~~\n\
    /tmp/tmpafo8pj_v.swift:34:25: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result = result.replacingOccurrences(of: longestPalindrome, with: \"\"\
    )\n                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringToCheck in string.characters\
    \ {\n        let reversedString = stringToCheck.reversed()\n        if stringToCheck\
    \ == reversedString {\n            longestPalindrome = stringToCheck\n       \
    \     longestPalindromeLength = stringToCheck.characters.count\n        }\n  \
    \  }\n    for stringToCheck in string.characters.reverse() {\n        let reversedString\
    \ = stringToCheck.reversed()\n        if stringToCheck == reversedString {\n \
    \           longestPalindrome = stringToCheck\n            longestPalindromeLength\
    \ = stringToCheck.characters.count\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjkimuvn2.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpjkimuvn2.swift:11:44: error: value of type 'Character'\
    \ has no member 'reversed'\n        let reversedString = stringToCheck.reversed()\n\
    \                             ~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpjkimuvn2.swift:13:33:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  longestPalindrome = stringToCheck\n                                ^~~~~~~~~~~~~\n\
    /tmp/tmpjkimuvn2.swift:14:53: error: value of type 'Character' has no member 'characters'\n\
    \            longestPalindromeLength = stringToCheck.characters.count\n      \
    \                                ~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpjkimuvn2.swift:17:44:\
    \ error: value of type 'String' has no member 'reverse'\n    for stringToCheck\
    \ in string.characters.reverse() {\n                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversedString = string.reversed()\n    let longestPalindrome\
    \ = longestPalindromeFrom(string, reversedString)\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp25egjxxd.swift:8:29: error: cannot find 'longestPalindromeFrom'\
    \ in scope\n    let longestPalindrome = longestPalindromeFrom(string, reversedString)\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for character in reversedString\
    \ {\n        if character == character {\n            longestPalindromeLength\
    \ += 1\n            if longestPalindromeLength > longestPalindrome.length {\n\
    \                longestPalindrome = reversedString\n            }\n        }\
    \ else {\n            longestPalindromeLength = 0\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmphtn5ws7g.swift:13:60: error: value of type 'String' has no member\
    \ 'length'\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = string\n\
    \    var longestPalindromeLength = longestPalindrome.characters.count\n    var\
    \ longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix = \"\"\n   \
    \ var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseLength = longestPalindromePrefixReverse.characters.count\n\
    \    var longestPalindromeSuffixReverseLength = longestPalindromeSuffixReverse.characters.count\n\
    \    var longestPalindromePrefixReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = longestPalindromePrefixReverseReverse.characters.count\n\
    \    var longestPalindromeSuffixReverseReverseLength = longestPalindromeSuffixReverseReverse.characters.count\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseLength = longestPalindromePrefixReverseReverseReverse.characters.count\n\
    \    var longestPalindromeSuffixReverseReverseReverseLength = longestPalindromeSuffixReverseReverseReverse.characters.count\n\
    \    var longestPalindromePrefixReverseReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseLength =\
    \ longestPalindromePrefixReverseReverseReverseReverseReverse.characters.count\n\
    \    var longestPalindromeSuffixReverseReverseReverseReverseLength = longestPalindromeSuffixReverseReverseReverseReverse.characters.count\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverse = \"\"\n \
    \   var longestPalindromeSuffixReverseReverseReverseReverseReverse = \"\"\n  \
    \  var longestPalindromePrefixReverseReverseReverseReverseReverseLength = longestPalindromePrefixReverseReverseReverseReverseReverseReverse.characters.count\n\
    \    var longestPalindromeSuffixReverseReverseReverseReverseReverseLength = longestPalindromeSuffixReverseReverseReverseReverseReverseReverse.characters.count\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpu9z1bukp.swift:39:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpu9z1bukp.swift:9:53: error: 'characters' is unavailable: Please use\
    \ String directly\n    var longestPalindromeLength = longestPalindrome.characters.count\n\
    \                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu9z1bukp.swift:16:79: error: 'characters'\
    \ is unavailable: Please use String directly\n    var longestPalindromePrefixReverseLength\
    \ = longestPalindromePrefixReverse.characters.count\n                        \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu9z1bukp.swift:17:79: error: 'characters'\
    \ is unavailable: Please use String directly\n    var longestPalindromeSuffixReverseLength\
    \ = longestPalindromeSuffixReverse.characters.count\n                        \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu9z1bukp.swift:20:93: error: 'characters'\
    \ is unavailable: Please use String directly\n    var longestPalindromePrefixReverseReverseLength\
    \ = longestPalindromePrefixReverseReverse.characters.count\n                 \
    \                                                                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu9z1bukp.swift:21:93:\
    \ error: 'characters' is unavailable: Please use String directly\n    var longestPalindromeSuffixReverseReverseLength\
    \ = longestPalindromeSuffixReverseReverse.characters.count\n                 \
    \                                                                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public v"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        } else {\n     \
    \       result += char.lowercased()\n        }\n        if result.characters.count\
    \ > longestPalindromeLength {\n            longestPalindrome = result\n      \
    \      longestPalindromeLength = result.characters.count\n        }\n    }\n \
    \   if longestPalindromeLength == 0 {\n        return \"\"\n    }\n    var reversedString\
    \ = String()\n    for char in longestPalindrome {\n        reversedString += char\n\
    \    }\n    reversedString = reversedString.reversed()\n    return reversedString\
    \ + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvkkk450j.swift:11:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == char.lowercased()\
    \ {\n           ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpvkkk450j.swift:11:17: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if char == char.lowercased() {\n     \
    \           ^\n/tmp/tmpvkkk450j.swift:12:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += char\n\
    \                      ^\n/tmp/tmpvkkk450j.swift:16:19: error: 'characters' is\
    \ unavailable: Please use String directly\n        if result.characters.count\
    \ > longestPalindromeLength {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvkkk450j.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n            longestPalindromeLength\
    \ = result.characters.count\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvkkk450j.swift:26:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        reversedString += char\n                          ^\n/tmp/tmpvkkk450j.swift:28:37:\
    \ error: no 'reversed' candidates produce the expected contextual result type\
    \ 'String'\n    reversedString = reversedString.reversed()\n                 \
    \                   ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedC"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixString = \"\"\n    var longestPalindromeSuffixString\
    \ = \"\"\n\n    for character in string {\n        let characterString = String(character)\n\
    \        let characterStringLength = characterString.length\n        let characterStringPrefix\
    \ = String(characterString[characterStringLength - longestPalindromeSuffixLength..<characterStringLength])\n\
    \        let characterStringSuffix = String(characterString[characterStringLength..<characterStringLength\
    \ - longestPalindromeSuffixLength])\n        let characterStringPrefixLength =\
    \ characterStringPrefix.length\n        let characterStringSuffixLength = characterStringSuffix.length\n\
    \n        if characterStringLength > longestPalindromeLength {\n            longestPalindrome\
    \ = characterString\n            longestPalindromeLength = characterStringLength\n\
    \            longestPalindromePrefixLength = characterStringPrefixLength\n   \
    \         longestPalindromeSuffixLength = characterStringSuffixLength\n      \
    \      longestPalindromePrefixString = characterStringPrefix\n            longestPalindromeSuffixString\
    \ = characterStringSuffix\n        }\n    }\n\n    let longestPalindromePrefix\
    \ = String(longestPalindrome[longestPalindromePrefixLength..<longestPalindromeLength])\n\
    \    let longestPalindromeSuffix = String(longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ - longestPalindromeSuffixLength])\n    let longestPalindromePrefixLength = longestPalindromePrefix.length\n\
    \    let longestPalindromeSuffixLength = longestPalindromeSuffix.length\n\n  \
    \  return longestPalindromePrefix + String(reversedString: longestPalindromeSuffix)\
    \ + longestPalindromeSuffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp_12ov9gf.swift:16:53: error: value of type 'String' has no member\
    \ 'length'\n        let characterStringLength = characterString.length\n     \
    \                               ~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp_12ov9gf.swift:32:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let longestPalindromePrefix =\
    \ String(longestPalindrome[longestPalindromePrefixLength..<longestPalindromeLength])\n\
    \                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_12ov9gf.swift:33:42: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let longestPalindromeSuffix = String(longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ - longestPalindromeSuffixLength])\n                                        \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_12ov9gf.swift:34:65: error: value\
    \ of type 'String' has no member 'length'\n    let longestPalindromePrefixLength\
    \ = longestPalindromePrefix.length\n                                        ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp_12ov9gf.swift:35:65: error: value of type 'String' has no member\
    \ 'length'\n    let longestPalindromeSuffixLength = longestPalindromeSuffix.length\n\
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp_12ov9gf.swift:37:38:\
    \ error: no exact matches in call to initializer \n    return longestPalindromePrefix\
    \ + String(reversedString: longestPalindromeSuffix) + longestPalindromeSuffix\n\
    \    "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength == 0 {\n                longestPalindrome\
    \ = character\n                longestPalindromeLength = character.characters.count\n\
    \            } else {\n                if longestPalindromeLength < character.characters.count\
    \ {\n                    longestPalindrome = character\n                    longestPalindromeLength\
    \ = character.characters.count\n                }\n            }\n        }\n\
    \    }\n    if longestPalindromeLength > 0 {\n        let reversedString = reverseString(string:\
    \ longestPalindrome)\n        result = reversedString + result\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpqxb9ck2v.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpqxb9ck2v.swift:15:37: error: cannot assign value of\
    \ type 'Character' to type 'String'\n                longestPalindrome = character\n\
    \                                    ^~~~~~~~~\n/tmp/tmpqxb9ck2v.swift:16:53:\
    \ error: value of type 'Character' has no member 'characters'\n              \
    \  longestPalindromeLength = character.characters.count\n                    \
    \                      ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqxb9ck2v.swift:18:56: error:\
    \ value of type 'Character' has no member 'characters'\n                if longestPalindromeLength\
    \ < character.characters.count {\n                                           \
    \  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqxb9ck2v.swift:19:41: error: cannot assign value\
    \ of type 'Character' to type 'String'\n                    longestPalindrome\
    \ = character\n                                        ^~~~~~~~~\n/tmp/tmpqxb9ck2v.swift:20:57:\
    \ error: value of type 'Character' has no member 'characters'\n              \
    \      longestPalindromeLength = character.characters.count\n                \
    \                              ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqxb9ck2v.swift:26:30:\
    \ error: cannot find 'reverseString' in scope\n        let reversedString = reverseString(string:\
    \ longestPalindrome)\n                             ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    for _ in 0..<string.count {\n        let reversedSubstringReversed\
    \ = reversedString.reversed()\n        let substringReversed = reversedSubstringReversed[reversedSubstringReversed.startIndex..<reversedSubstringReversed.endIndex]\n\
    \        if substringReversed == string {\n            longestPalindrome = longestPalindrome.replacingOccurrences(of:\
    \ substringReversed, with: reversedString)\n            break\n        }\n   \
    \     reversedString = reversedString.replacingOccurrences(of: substringReversed,\
    \ with: reversedString.reversed())\n    }\n    return longestPalindrome\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpm7ywql6g.swift:12:12: error: cannot convert value of type 'Slice<ReversedCollection<String>>'\
    \ to expected argument type 'String'\n        if substringReversed == string {\n\
    \           ^\n/tmp/tmpm7ywql6g.swift:13:51: error: value of type 'String' has\
    \ no member 'replacingOccurrences'\n            longestPalindrome = longestPalindrome.replacingOccurrences(of:\
    \ substringReversed, with: reversedString)\n                                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm7ywql6g.swift:16:41: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n        reversedString = reversedString.replacingOccurrences(of:\
    \ substringReversed, with: reversedString.reversed())\n                      \
    \   ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = stringToPalindrome\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseReverseReverse = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverse = \"\
    \"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpiljn4xk0.swift:24:9: error: invalid redeclaration of 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverseReverse = \"\
    \"\n        ^\n/tmp/tmpiljn4xk0.swift:22:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpiljn4xk0.swift:25:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromeSuffixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \      ^\n/tmp/tmpiljn4xk0.swift:23:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpiljn4xk0.swift:26:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromePrefixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \      ^\n/tmp/tmpiljn4xk0.swift:22:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpiljn4xk0.swift:27:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromeSuffixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \      ^\n/tmp/tmpiljn4xk0.swift:23:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpiljn4xk0.swift:32:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpiljn4xk0.swift:30:9: note: 'longestPalindromePrefixStringReverseReverseR"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixReversed: String = \"\"\n    var longestPalindromeSuffixReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedLength = 0\n    var longestPalindromeSuffixReversedLength\
    \ = 0\n    var longestPalindromePrefixReversedReversed: String = \"\"\n    var\
    \ longestPalindromeSuffixReversedReversed: String = \"\"\n    var longestPalindromePrefixReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedLength = 0\n    var longestPalindromePrefixReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversed: String\
    \ = \"\"\n    var longestPalindromePrefixReversedReversedReversedLength = 0\n\
    \    var longestPalindromeSuffixReversedReversedReversedLength = 0\n    var longestPalindromePrefixReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedLength =\
    \ 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedLength =\
    \ 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpk2ojl4a8.swift:31:9: error: invalid redeclaration of 'longestPalindromePrefixReversedReversedReversedReversedLength'\n\
    \    var longestPalindromePrefixReversedReversedReversedReversedLength = 0\n \
    \       ^\n/tmp/tmpk2ojl4a8.swift:27:9: note: 'longestPalindromePrefixReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromePrefixReversedReversedReversedReversedLength\
    \ = 0\n        ^\n/tmp/tmpk2ojl4a8.swift:32:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixReversedReversedReversedReversedLength'\n    var longestPalindromeSuffixReversedReversedReversedReversedLength\
    \ = 0\n        ^\n/tmp/tmpk2ojl4a8.swift:28:9: note: 'longestPalindromeSuffixReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromeSuffixReversedReversedReversedReversedLength\
    \ = 0\n        ^\n/tmp/tmpk2ojl4a8.swift:37:9: error: invalid redeclaration of\
    \ 'longestPalindromePrefixReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromePrefixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n        ^\n/tmp/tmpk2ojl4a8.swift:33:9: note: 'longestPalindromePrefixReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n        ^\n/tmp/tmpk2ojl4a8.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromeSuffixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n        ^\n/tmp/tmpk2ojl4a8.swift:34:9: note: 'longestPalindromeSuffixReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n        ^\n/tmp/tmpk2ojl4a8.swift:39:9: error: type annotation\
    \ missing in pattern\n    var longestPalindromePrefixReversed\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix:\
    \ String = \"\"\n    var longestPalindromeSuffix: String = \"\"\n    var longestPalindromePostfix:\
    \ String = \"\"\n\n    for character in stringToReturn {\n        if character\
    \ == \" \" {\n            longestPalindromeLength += 1\n        }\n    }\n\n \
    \   for character in stringToReturn {\n        if character == \" \" {\n     \
    \       longestPalindromeLength += 1\n        }\n        if character == stringToReturn.last\
    \ {\n            longestPalindromeLength += 1\n        }\n    }\n\n    for character\
    \ in stringToReturn {\n        if character == \" \" {\n            longestPalindromeLength\
    \ += 1\n        }\n        if character == stringToReturn.last {\n           \
    \ longestPalindromeLength += 1\n        }\n        if character == stringToReturn.first\
    \ {\n            longestPalindromeLength += 1\n        }\n    }\n\n    for character\
    \ in stringToReturn {\n        if character == \" \" {\n            longestPalindromeLength\
    \ += 1\n        }\n        if character == stringToReturn.last {\n           \
    \ longestPalindromeLength += 1\n        }\n        if character == stringToReturn.first\
    \ {\n            longestPalindromeLength += 1\n        }\n        if character\
    \ == stringToReturn.first {\n            longestPalindromeLength += 1\n      \
    \  }\n    }\n\n    for character in stringToReturn {\n        if character ==\
    \ \" \" {\n            longestPalindromeLength += 1\n        }\n        if character\
    \ == stringToReturn.last {\n            longestPalindromeLength += 1\n       \
    \ }\n        if character == stringToReturn.first {\n            longestPalindromeLength\
    \ += 1\n        }\n        if character == stringToReturn.first {\n          \
    \  longestPalindromeLength += 1\n        }\n        if character == stringToReturn.first\
    \ {\n            longestPalindromeLength += 1\n        }\n    }\n\n    for character\
    \ in stringToReturn {\n        if character == \" \" {\n            longestPalindromeLength\
    \ += 1\n        }\n        if character == stringToReturn.last {\n           \
    \ longestPalindromeLength += 1\n        }\n        if character == stringToReturn.first\
    \ {\n            longestPalindromeLength += 1\n        }\n        if character\
    \ == stringToReturn.first {\n            longestPalindromeLength += 1\n      \
    \  }\n        if character == stringToReturn.first {\n            longestPalin\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpzkg00tgf.swift:108:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmpzkg00tgf.swift:74:37: note:\
    \ to match this opening '{'\n    for character in stringToReturn {\n         \
    \                           ^\n/tmp/tmpzkg00tgf.swift:108:56: error: expected\
    \ '}' at end of brace statement\nassert(make_palindrome(string: \"jerry\") ==\
    \ \"jerryrrej\")\n                                                       ^\n/tmp/tmpzkg00tgf.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmpzkg00tgf.swift:88:13:\
    \ error: cannot find 'longestPalin' in scope\n            longestPalin\n     \
    \       ^~~~~~~~~~~~\n/tmp/tmpzkg00tgf.swift:92:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let stringLength = string.characters.count\n    let\
    \ longestPalindromeLength = stringLength / 2\n    let longestPalindrome = string[longestPalindromeLength..<stringLength]\n\
    \    let longestPalindromeReversed = longestPalindrome.reversed()\n    let longestPalindromeSuffixReversed\
    \ = longestPalindromeReversed.suffix(stringLength)\n    let longestPalindromeSuffixReversedString\
    \ = String(longestPalindromeSuffixReversed)\n    let longestPalindromeSuffixReversedStringLength\
    \ = longestPalindromeSuffixReversedString.characters.count\n    let longestPalindromeSuffixReversedStringReversed\
    \ = longestPalindromeSuffixReversedString.reversed()\n    let longestPalindromeSuffixReversedStringReversedString\
    \ = String(longestPalindromeSuffixReversedStringReversed)\n    let longestPalindromeSuffixReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedString.characters.count\n   \
    \ let longestPalindromeSuffixReversedStringReversedStringReversedString = longestPalindromeSuffixReversedStringReversedString.reversed()\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedString.characters.count\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringReversedString\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedString.reversed()\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedStringReversedString.characters.count\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedString.characters.count\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedStringReversedString.characters.count\n\
    \    let longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedStringReversedStringReversedStringReversedStringReversedString.characters.count\n\
    \    let longestPalindromeSuffixReversedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9s1xsodu.swift:7:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9s1xsodu.swift:9:29: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    let longestPalindrome = string[longestPalindromeLength..<stringLength]\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp9s1xsodu.swift:13:93: error: 'characters'\
    \ is unavailable: Please use String directly\n    let longestPalindromeSuffixReversedStringLength\
    \ = longestPalindromeSuffixReversedString.characters.count\n                 \
    \                                                                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9s1xsodu.swift:16:121:\
    \ error: 'characters' is unavailable: Please use String directly\n    let longestPalindromeSuffixReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedString.characters.count\n   \
    \                                                                            \
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp9s1xsodu.swift:18:149: error: value of\
    \ type 'ReversedCollection<String>' has no member 'characters'\n    let longestPalindromeSuffixReversedStringReversedStringReversedStringLength\
    \ = longestPalindromeSuffixReversedStringReversedStringReversedString.characters.count\n\
    \                                                    "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    for stringIndex in 0..<string.characters.count\
    \ {\n        let stringCharacter = string.characters[stringIndex]\n        if\
    \ stringCharacter == stringToReturn.characters.last! {\n            longestPalindromeLength\
    \ += 1\n            if longestPalindromeLength > longestPalindromeEndIndex {\n\
    \                longestPalindromeEndIndex = stringIndex\n            }\n    \
    \    } else {\n            if longestPalindromeLength > longestPalindromeStartIndex\
    \ {\n                longestPalindromeStartIndex = stringIndex\n            }\n\
    \            longestPalindromeLength = 0\n        }\n    }\n    if longestPalindromeLength\
    \ > longestPalindromeEndIndex {\n        longestPalindromeLength -= longestPalindromeEndIndex\n\
    \        longestPalindromeEndIndex = longestPalindromeStartIndex\n    }\n    if\
    \ longestPalindromeLength > 0 {\n        longestPalindrome = String(string.characters.suffix(from:\
    \ longestPalindromeStartIndex..<longestPalindromeEndIndex))\n    }\n    return\
    \ longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp8sj1ty_e.swift:12:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringIndex in 0..<string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8sj1ty_e.swift:13:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ stringCharacter = string.characters[stringIndex]\n                         \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8sj1ty_e.swift:13:38: error: 'characters'\
    \ is unavailable: Please use String directly\n        let stringCharacter = string.characters[stringIndex]\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8sj1ty_e.swift:14:46: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringCharacter == stringToReturn.characters.last!\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8sj1ty_e.swift:31:94: error: cannot convert\
    \ value of type 'Range<Int>' to expected argument type 'String.Index'\n      \
    \  longestPalindrome = String(string.characters.suffix(from: longestPalindromeStartIndex..<longestPalindromeEndIndex))\n\
    \                                                                            \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    for stringToCheck in string.characters {\n        if stringToCheck\
    \ == stringToReturn.characters.last {\n            longestPalindromeLength +=\
    \ 1\n        } else {\n            longestPalindromeLength = 0\n        }\n  \
    \      if longestPalindromeLength > stringToReturn.characters.count {\n      \
    \      stringToReturn = stringToReturn + stringToCheck\n        }\n    }\n   \
    \ return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp738m1n13.swift:9:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp738m1n13.swift:10:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp738m1n13.swift:15:53: error: 'characters'\
    \ is unavailable: Please use String directly\n        if longestPalindromeLength\
    \ > stringToReturn.characters.count {\n                                      \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp738m1n13.swift:16:47: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stringToReturn = stringToReturn\
    \ + stringToCheck\n                                              ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeSuffixStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromeSuffixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverse = \"\"\n    var longestPalindromeSuffixStringReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnfi4508l.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseReverseIndex = 0\n        ^\n/tmp/tmpnfi4508l.swift:19:9:\
    \ note: 'longestPalindromeSuffixStringReverseReverseIndex' previously declared\
    \ here\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n       \
    \ ^\n/tmp/tmpnfi4508l.swift:22:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseIndexLength'\n\
    \    var longestPalindromeSuffixStringReverseReverseIndexLength = 0\n        ^\n\
    /tmp/tmpnfi4508l.swift:20:9: note: 'longestPalindromeSuffixStringReverseReverseIndexLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:23:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndex'\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:19:9: note: 'longestPalindromeSuffixStringReverseReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:24:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndexLength'\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:20:9: note: 'longestPalindromeSuffixStringReverseReverseIndexLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:25:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndex'\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:19:9: note: 'longestPalindromeSuffixStringReverseReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpnfi4508l.swift:26:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndexLength'\n    var longestPalindromeSuffixStringReverseReverseIndexL"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    for index in 0..<string.characters.count {\n        let character =\
    \ string.characters[index]\n        let reversedCharacter = reverseString(character)\n\
    \        if character == reversedCharacter {\n            reversedString += character\n\
    \            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindromeIndex {\n                longestPalindrome = reversedString\n\
    \                longestPalindromeIndex = longestPalindromeLength\n          \
    \  }\n        } else {\n            reversedString += character\n        }\n \
    \   }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2m2gd3qu.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2m2gd3qu.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2m2gd3qu.swift:12:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2m2gd3qu.swift:13:33:\
    \ error: cannot find 'reverseString' in scope\n        let reversedCharacter =\
    \ reverseString(character)\n                                ^~~~~~~~~~~~~\n/tmp/tmp2m2gd3qu.swift:15:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reversedString += character\n                              ^\n/tmp/tmp2m2gd3qu.swift:22:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reversedString += character\n                              ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.last {\n          \
    \  longestPalindrome = stringToCheck\n            longestPalindromeLength = stringToCheck.characters.count\n\
    \        }\n    }\n    if longestPalindromeLength > 0 {\n        let longestPalindromePrefix\
    \ = stringToReturn.characters.prefix(longestPalindromeLength)\n        let longestPalindromeSuffix\
    \ = stringToReturn.characters.suffix(longestPalindromeLength)\n        let reverseOfLongestPalindromePrefix\
    \ = longestPalindromePrefix.reversed()\n        let reverseOfLongestPalindromeSuffix\
    \ = longestPalindromeSuffix.reversed()\n        stringToReturn = stringToReturn\
    \ + reverseOfLongestPalindromePrefix + reverseOfLongestPalindromeSuffix\n    }\n\
    \    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpi2s1o8hv.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpi2s1o8hv.swift:11:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpi2s1o8hv.swift:12:33: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            longestPalindrome =\
    \ stringToCheck\n                                ^~~~~~~~~~~~~\n/tmp/tmpi2s1o8hv.swift:13:53:\
    \ error: value of type 'Character' has no member 'characters'\n            longestPalindromeLength\
    \ = stringToCheck.characters.count\n                                      ~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpi2s1o8hv.swift:17:54: error: 'characters' is unavailable:\
    \ Please use String directly\n        let longestPalindromePrefix = stringToReturn.characters.prefix(longestPalindromeLength)\n\
    \                                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpi2s1o8hv.swift:18:54: error: 'characters'\
    \ is unavailable: Please use String directly\n        let longestPalindromeSuffix\
    \ = stringToReturn.characters.suffix(longestPalindromeLength)\n              \
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \    let reversedString = reverseString(string: string)\n    return longestPalindrome\
    \ + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc7kt4gr.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string:\
    \ string)\n                            ^\n/tmp/tmpdc7kt4gr.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \        ^\n/tmp/tmpdc7kt4gr.swift:8:26: error: cannot find 'reverseString' in\
    \ scope\n    let reversedString = reverseString(string: string)\n            \
    \             ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfix\
    \ = \"\"\n    var longestPalindromePostfixLength = 0\n\n    for character in string\
    \ {\n        if character == \" \" {\n            stringToReturn += character\n\
    \        } else {\n            if longestPalindromeLength == 0 {\n           \
    \     longestPalindrome = character\n                longestPalindromeLength =\
    \ character.characters.count\n                longestPalindromePrefix = string\n\
    \                longestPalindromeSuffix = string\n                longestPalindromePostfix\
    \ = string\n                longestPalindromePostfixLength = longestPalindromeLength\n\
    \            } else {\n                if longestPalindromeLength < character.characters.count\
    \ {\n                    longestPalindrome = character\n                    longestPalindromeLength\
    \ = character.characters.count\n                    longestPalindromePrefix =\
    \ string\n                    longestPalindromeSuffix = string\n             \
    \       longestPalindromePostfix = string\n                    longestPalindromePostfixLength\
    \ = longestPalindromeLength\n                }\n            }\n        }\n   \
    \ }\n\n    if longestPalindromeLength == 0 {\n        return string\n    }\n\n\
    \    if longestPalindromeLength > longestPalindromePostfixLength {\n        longestPalindromePostfix\
    \ = string.reverse()\n    }\n\n    stringToReturn += longestPalindrome\n    stringToReturn\
    \ += longestPalindromePrefix\n    stringToReturn += longestPalindromeSuffix\n\
    \    stringToReturn += longestPalindromePostfix\n    stringToReturn += longestPalindromePostfix\n\
    \    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp0x09dr9_.swift:17:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stringToReturn += character\n\
    \                              ^\n/tmp/tmp0x09dr9_.swift:20:37: error: cannot\
    \ assign value of type 'Character' to type 'String'\n                longestPalindrome\
    \ = character\n                                    ^~~~~~~~~\n/tmp/tmp0x09dr9_.swift:21:53:\
    \ error: value of type 'Character' has no member 'characters'\n              \
    \  longestPalindromeLength = character.characters.count\n                    \
    \                      ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0x09dr9_.swift:27:56: error:\
    \ value of type 'Character' has no member 'characters'\n                if longestPalindromeLength\
    \ < character.characters.count {\n                                           \
    \  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0x09dr9_.swift:28:41: error: cannot assign value\
    \ of type 'Character' to type 'String'\n                    longestPalindrome\
    \ = character\n                                        ^~~~~~~~~\n/tmp/tmp0x09dr9_.swift:29:57:\
    \ error: value of type 'Character' has no member 'characters'\n              \
    \      longestPalindromeLength = character.characters.count\n                \
    \                              ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0x09dr9_.swift:44:43:\
    \ error: value of type 'String' has no member 'reverse'\n        longestPalindromePostfix\
    \ = string.reverse()\n                                   ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeString\
    \ = \"\"\n    var longestPalindromeStringLength = 0\n    var longestPalindromeStringPrefixLength\
    \ = 0\n    var longestPalindromeStringSuffixLength = 0\n    var longestPalindromeStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringSuffixString = \"\"\n    var longestPalindromeStringString\
    \ = \"\"\n    var longestPalindromeStringStringLength = 0\n    var longestPalindromeStringStringPrefixLength\
    \ = 0\n    var longestPalindromeStringStringSuffixLength = 0\n    var longestPalindromeStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringSuffixString = \"\"\n    var longestPalindromeStringStringString\
    \ = \"\"\n    var longestPalindromeStringStringStringLength = 0\n    var longestPalindromeStringStringStringPrefixLength\
    \ = 0\n    var longestPalindromeStringStringStringSuffixLength = 0\n    var longestPalindromeStringStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringStringSuffixString = \"\"\n   \
    \ var longestPalindromeStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringPrefixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringSuffixLength = 0\n    var longestPalindromeStringStringStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringStringStringSuffixString = \"\"\
    \n    var longestPalindromeStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringStringPrefixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringSuffixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringStringStringPrefixString = \"\"\
    \n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp3tlecfh9.swift:49:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp3tlecfh9.swift:46:9: error: invalid redeclaration of 'longestPalindromeStringStringStringStringStringPrefixLength'\n\
    \    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n   \
    \     ^\n/tmp/tmp3tlecfh9.swift:40:9: note: 'longestPalindromeStringStringStringStringStringPrefixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringPrefixLength\
    \ = 0\n        ^\n/tmp/tmp3tlecfh9.swift:47:9: error: invalid redeclaration of\
    \ 'longestPalindromeStringStringStringStringStringSuffixLength'\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n/tmp/tmp3tlecfh9.swift:41:9: note: 'longestPalindromeStringStringStringStringStringSuffixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < len(longestPalindrome) {\n     \
    \           longestPalindrome = result\n                longestPalindromeLength\
    \ = len(longestPalindrome)\n            }\n            result = \"\"\n       \
    \ }\n    }\n    if longestPalindromeLength < len(longestPalindrome) {\n      \
    \  longestPalindrome = result\n        longestPalindromeLength = len(longestPalindrome)\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq4skzfd7.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpq4skzfd7.swift:14:42: error: cannot find 'len' in\
    \ scope\n            if longestPalindromeLength < len(longestPalindrome) {\n \
    \                                        ^~~\n/tmp/tmpq4skzfd7.swift:16:43: error:\
    \ cannot find 'len' in scope\n                longestPalindromeLength = len(longestPalindrome)\n\
    \                                          ^~~\n/tmp/tmpq4skzfd7.swift:21:34:\
    \ error: cannot find 'len' in scope\n    if longestPalindromeLength < len(longestPalindrome)\
    \ {\n                                 ^~~\n/tmp/tmpq4skzfd7.swift:23:35: error:\
    \ cannot find 'len' in scope\n        longestPalindromeLength = len(longestPalindrome)\n\
    \                                  ^~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.reversed()\n    let longestPalindrome\
    \ = string.prefix(longestPalindrome(string))\n    return longestPalindrome + reverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpu4n3p2yw.swift:8:43: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = string.prefix(longestPalindrome(string))\n\
    \                                          ^\n/tmp/tmpu4n3p2yw.swift:8:9: note:\
    \ 'longestPalindrome' declared here\n    let longestPalindrome = string.prefix(longestPalindrome(string))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfixLength\
    \ = 0\n    var longestPalindromePostfix = \"\"\n\n    for stringToPalindrome.hasPrefix(stringToPalindrome)\
    \ {\n        let stringPrefix = stringToPalindrome.prefix(stringToPalindrome.startIndex)\n\
    \        let stringSuffix = stringToPalindrome.suffix(stringToPalindrome.startIndex)\n\
    \        let stringToPalindromePrefix = stringPrefix.reversed()\n        let stringToPalindromeSuffix\
    \ = stringSuffix.reversed()\n\n        if stringToPalindromePrefix.isPalindrome\
    \ {\n            longestPalindromePrefix = stringPrefix\n            longestPalindromePostfixLength\
    \ = stringToPalindromePrefix.count\n            longestPalindromePostfix = stringToPalindromePrefix\n\
    \            longestPalindromeLength += stringToPalindromePrefix.count\n     \
    \   } else if stringToPalindromeSuffix.isPalindrome {\n            longestPalindromeSuffix\
    \ = stringSuffix\n            longestPalindromePostfixLength = stringToPalindromeSuffix.count\n\
    \            longestPalindromePostfix = stringToPalindromeSuffix\n           \
    \ longestPalindromeLength += stringToPalindromeSuffix.count\n        } else {\n\
    \            longestPalindromeLength += stringToPalindrome.count\n        }\n\
    \    }\n\n    if longestPalindromeLength > longestPalindromePostfixLength {\n\
    \        longestPalindrome = longestPalindromePrefix + longestPalindromeSuffix.reversed()\n\
    \    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp14uh1vm_.swift:15:27: error: expected 'in' after for-each pattern\n\
    \    for stringToPalindrome.hasPrefix(stringToPalindrome) {\n                \
    \          ^\n/tmp/tmp14uh1vm_.swift:15:28: error: type 'Sequence' has no member\
    \ 'hasPrefix'\n    for stringToPalindrome.hasPrefix(stringToPalindrome) {\n  \
    \                        ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfixLength\
    \ = 0\n    var longestPalindromePostfix = \"\"\n    var longestPalindromePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReverseLength = 0\n    var longestPalindromePostfixReversePrefix\
    \ = \"\"\n    var longestPalindromePostfixReverseSuffix = \"\"\n    var longestPalindromePostfixReversePostfix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixLength = 0\n    var longestPalindromePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReverseLength = 0\n  \
    \  var longestPalindromePostfixReversePostfixReversePrefix = \"\"\n    var longestPalindromePostfixReversePostfixReverseSuffix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfix = \"\"\n\
    \    var longestPalindromePostfixReversePostfixReversePostfixLength = 0\n    var\
    \ longestPalindromePostfixReversePostfixReversePostfixReverse = \"\"\n    var\
    \ longestPalindromePostfixReversePostfixReversePostfixReverseLength = 0\n    var\
    \ longestPalindromePostfixReversePostfixReversePostfixReversePrefix = \"\"\n \
    \   var longestPalindromePostfixReversePostfixReversePostfixReverseSuffix = \"\
    \"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverseLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReversePrefix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverseSuffix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReversePostfix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnlyyo_1n.swift:39:9: error: type annotation missing in pattern\n\
    \    var longestPalindrome\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptj26qn3y.swift:14:9: error: invalid redeclaration of 'longestPalindromeSuffixIndex'\n\
    \    var longestPalindromeSuffixIndex = 0\n        ^\n/tmp/tmptj26qn3y.swift:12:9:\
    \ note: 'longestPalindromeSuffixIndex' previously declared here\n    var longestPalindromeSuffixIndex\
    \ = 0\n        ^\n/tmp/tmptj26qn3y.swift:15:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixLength'\n    var longestPalindromeSuffixLength = 0\n\
    \        ^\n/tmp/tmptj26qn3y.swift:13:9: note: 'longestPalindromeSuffixLength'\
    \ previously declared here\n    var longestPalindromeSuffixLength = 0\n      \
    \  ^\n/tmp/tmptj26qn3y.swift:16:9: error: invalid redeclaration of 'longestPalindromeSuffixIndex'\n\
    \    var longestPalindromeSuffixIndex = 0\n        ^\n/tmp/tmptj26qn3y.swift:12:9:\
    \ note: 'longestPalindromeSuffixIndex' previously declared here\n    var longestPalindromeSuffixIndex\
    \ = 0\n        ^\n/tmp/tmptj26qn3y.swift:17:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixLength'\n    var longestPalindromeSuffixLength = 0\n\
    \        ^\n/tmp/tmptj26qn3y.swift:13:9: note: 'longestPalindromeSuffixLength'\
    \ previously declared here\n    var longestPalindromeSuffixLength = 0\n      \
    \  ^\n/tmp/tmptj26qn3y.swift:18:9: error: invalid redeclaration of 'longestPalindromeSuffixIndex'\n\
    \    var longestPalindromeSuffixIndex = 0\n        ^\n/tmp/tmptj26qn3y.swift:12:9:\
    \ note: 'longestPalindromeSuffixIndex' previously declared here\n    var longestPalindromeSuffixIndex\
    \ = 0\n        ^\n/tmp/tmptj26qn3y.swift:19:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixLength'\n    var longestPalindromeSuffixLength = 0\n\
    \        ^\n/tmp/tmptj26qn3y.swift:13:9: note: 'longestPalindromeSuffixLength'\
    \ previously declared here\n    var longestPalindromeSuffixLength = 0\n      \
    \  ^\n/tmp/tmptj26qn3y.swift:20:9: error: invalid redeclaration of 'longestPalindromeSuffixIndex'\n\
    \    var longestPalindromeSuffixIndex = 0\n        ^\n/tmp/tmptj26qn3y.swift:12:9:\
    \ note: 'longestPalindromeSuffixIndex' previously declared here\n    var longestPalindromeSuffixIndex\
    \ = 0\n        ^\n/tmp/tmptj26qn3y.swift:21:9: error: inval"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    for character in string\
    \ {\n        if character == longestPalindrome[longestPalindromeLength] {\n  \
    \          longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n        if longestPalindromeLength > longestPalindromePrefix.characters.count\
    \ {\n            longestPalindromePrefix = String(character)\n        }\n    }\n\
    \    for character in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n        if longestPalindromeLength > longestPalindromePrefix.characters.count\
    \ {\n            longestPalindromePrefix = String(character)\n        }\n    }\n\
    \    longestPalindromeLength -= 1\n    longestPalindrome = longestPalindromePrefix\
    \ + String(reverse(string[longestPalindromeLength..<string.characters.count]))\n\
    \    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0rp5b4g.swift:11:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpp0rp5b4g.swift:16:62:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestPalindromeLength\
    \ > longestPalindromePrefix.characters.count {\n                             \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp0rp5b4g.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ character == longestPalindrome[longestPalindromeLength] {\n                \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpp0rp5b4g.swift:26:62: error:\
    \ 'characters' is unavailable: Please use String directly\n        if longestPalindromeLength\
    \ > longestPalindromePrefix.characters.count {\n                             \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp0rp5b4g.swift:31:58: error: cannot find 'reverse'\
    \ in scope\n    longestPalindrome = longestPalindromePrefix + String(reverse(string[longestPalindromeLength..<string.characters.count]))\n\
    \                                                         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    for character in string {\n        reversedString = reversedString\
    \ + String(character)\n        if character == string[string.index(before: reversedString)]\
    \ {\n            longestPalindrome = longestPalindrome + String(character)\n \
    \       }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7a070a95.swift:11:53: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        if character == string[string.index(before:\
    \ reversedString)] {\n                                                    ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    for _ in 0..<string.count {\n        let reversedSubstring = reversedString.substringFromIndex(longestPalindrome.endIndex)\n\
    \        if longestPalindrome.hasPrefix(reversedSubstring) {\n            longestPalindrome\
    \ = longestPalindrome.appending(reversedSubstring)\n        } else {\n       \
    \     longestPalindrome = longestPalindrome.appending(reversedString)\n      \
    \      break\n        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbeb1x0d6.swift:10:48: error: value of type 'String' has no member\
    \ 'substringFromIndex'\n        let reversedSubstring = reversedString.substringFromIndex(longestPalindrome.endIndex)\n\
    \                                ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpbeb1x0d6.swift:12:51:\
    \ error: value of type 'String' has no member 'appending'\n            longestPalindrome\
    \ = longestPalindrome.appending(reversedSubstring)\n                         \
    \       ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpbeb1x0d6.swift:14:51: error: value\
    \ of type 'String' has no member 'appending'\n            longestPalindrome =\
    \ longestPalindrome.appending(reversedString)\n                              \
    \  ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = String()\n    var longestPalindromeLength = String()\n    var longestPalindromePrefix\
    \ = String()\n    var longestPalindromeSuffix = String()\n    var longestPalindromePrefixLength\
    \ = String()\n    var longestPalindromeSuffixLength = String()\n    var longestPalindromePostfix\
    \ = String()\n    var longestPalindromePostfixLength = String()\n    var longestPalindromePostfixReversed\
    \ = String()\n    var longestPalindromePostfixReversedLength = String()\n    var\
    \ longestPalindromePostfixReversedReversed = String()\n    var longestPalindromePostfixReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversed = String()\n\
    \    var longestPalindromePostfixReversedReversedReversedLength = String()\n \
    \   var longestPalindromePostfixReversedReversedReversedReversedReversed = String()\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7h39mz0t.swift:28:9: error: invalid redeclaration of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:26:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:29:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:27:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:32:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:30:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed'\
    \ previously declared here\n    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:33:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength'\n\
    \    var longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength\
    \ = String()\n        ^\n/tmp/tmp7h39mz0t.swift:31:9: note: 'longestPalindromePostfixReversedReversedReversedReversedReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromePostfix"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix:\
    \ String = \"\"\n    var longestPalindromeSuffix: String = \"\"\n\n    for character\
    \ in string {\n        if character == character {\n            palindrome = palindrome[1...].appending(character)\n\
    \        } else {\n            longestPalindromeLength = palindrome.count\n  \
    \          longestPalindromePrefix = palindrome[longestPalindromeLength...].appending(character)\n\
    \            longestPalindromeSuffix = palindrome[longestPalindromeLength...].appending(character)\n\
    \            palindrome = palindrome[longestPalindromeLength...].appending(character)\n\
    \        }\n    }\n\n    if longestPalindromeLength > longestPalindromePrefix.count\
    \ {\n        longestPalindrome = longestPalindromePrefix\n    }\n\n    if longestPalindromeLength\
    \ > longestPalindromeSuffix.count {\n        longestPalindrome = longestPalindromeSuffix\n\
    \    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0r4nlb84.swift:15:43: error: value of type 'String' has no member\
    \ 'appending'\n            palindrome = palindrome[1...].appending(character)\n\
    \                         ~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp0r4nlb84.swift:18:78:\
    \ error: value of type 'String' has no member 'appending'\n            longestPalindromePrefix\
    \ = palindrome[longestPalindromeLength...].appending(character)\n            \
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp0r4nlb84.swift:19:78: error: value of type 'String' has no member 'appending'\n\
    \            longestPalindromeSuffix = palindrome[longestPalindromeLength...].appending(character)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~\n/tmp/tmp0r4nlb84.swift:20:65: error: value of type 'String' has no\
    \ member 'appending'\n            palindrome = palindrome[longestPalindromeLength...].appending(character)\n\
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            longestPalindromeLength += 1\n    \
    \        if longestPalindromeLength > longestPalindrome.length {\n           \
    \     longestPalindrome = string\n            }\n        } else {\n          \
    \  if longestPalindromeLength > longestPalindrome.length {\n                longestPalindrome\
    \ = string\n            }\n            longestPalindromeLength = 0\n        }\n\
    \    }\n    for character in string {\n        if character == character {\n \
    \           longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = string\n \
    \           }\n        } else {\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                longestPalindrome = string\n            }\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n    for character in string {\n        if character ==\
    \ character {\n            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = string\n \
    \           }\n        } else {\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                longestPalindrome = string\n            }\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n    for character in string {\n        if character ==\
    \ character {\n            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = string\n \
    \           }\n        } else {\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                longestPalindrome = string\n            }\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n    for character in string {\n        if character ==\
    \ character {\n            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = string\n \
    \           }\n        } else {\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                longestPalindrome = string\n            }\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n    for character in string {\n        if character ==\
    \ character {\n            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalin\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp261xhbqy.swift:99:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmp261xhbqy.swift:76:35: note:\
    \ to match this opening '{'\n        if character == character {\n           \
    \                       ^\n/tmp/tmp261xhbqy.swift:99:56: error: expected '}' at\
    \ end of brace statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )\n                                                       ^\n/tmp/tmp261xhbqy.swift:75:29:\
    \ note: to match this opening '{'\n    for character in string {\n           \
    \                 ^\n/tmp/tmp261xhbqy.swift:99:56: error: expected '}' at end\
    \ of brace statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )\n                                                       ^\n/tmp/tmp261xhbqy.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmp261xhbqy.swift:13:60:\
    \ error: value of type 'String' has no member 'length'\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp261xhbqy.swift:17:60: error: value of type 'String' has no member\
    \ 'length'\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp261xhbqy.swift:26:60:\
    \ error: value of type 'String' has no member 'length'\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp261xhbqy.swift:30:60: error: value of type 'String' has no member\
    \ 'length'\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp261xhbqy.swift:39:60:\
    \ error: value of type 'String' has no member 'length'\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                                         ~~~~~~"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = \"\"\n    for index in 0..<string.characters.count {\n        let char = string.characters[index]\n\
    \        let reversedChar = reversedString.characters[index]\n        if char\
    \ == reversedChar {\n            longestPalindrome = longestPalindrome + char\n\
    \        } else {\n            longestPalindrome = longestPalindrome + reversedChar\n\
    \        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp57mtzxz4.swift:9:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp57mtzxz4.swift:10:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = string.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp57mtzxz4.swift:10:27:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = string.characters[index]\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp57mtzxz4.swift:11:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let reversedChar = reversedString.characters[index]\n               \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp57mtzxz4.swift:11:43: error: 'characters'\
    \ is unavailable: Please use String directly\n        let reversedChar = reversedString.characters[index]\n\
    \                                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp57mtzxz4.swift:13:53: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            longestPalindrome\
    \ = longestPalindrome + char\n                                               \
    \     ^\n/tmp/tmp57mtzxz4.swift:15:53: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Strin"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix = \"\
    -\"\n    var longestPalindromePostfix = \"-\"\n    var longestPalindromePostfixLength\
    \ = 0\n    var longestPalindromePostfixIndex = 0\n    var longestPalindromePostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixSuffix = \"-\"\n    var longestPalindromePostfixPostfix\
    \ = \"-\"\n    var longestPalindromePostfixPostfixLength = 0\n    var longestPalindromePostfixPostfixIndex\
    \ = 0\n    var longestPalindromePostfixPostfixPrefix = \"\"\n    var longestPalindromePostfixPostfixSuffix\
    \ = \"-\"\n    var longestPalindromePostfixPostfixPostfix = \"-\"\n    var longestPalindromePostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixIndex = 0\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixSuffix = \"-\"\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfix = \"-\"\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixIndex = 0\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfixPrefix = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixSuffix\
    \ = \"-\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfix = \"-\"\
    \n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength = 0\n   \
    \ var longestPalindromePostfixPostfixPostfixPostfixPostfixIndex = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix =\
    \ \"-\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix =\
    \ \"-\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixIndex\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmixl7_fy.swift:41:9: error: type annotation missing in pattern\n\
    \    var longestPalindromePostfixPostfixPostfixPostfix\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp4o8xmeaj.swift:59:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp4o8xmeaj.swift:12:9: error: invalid redeclaration of 'longestPalindromeStartIndex'\n\
    \    var longestPalindromeStartIndex = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:10:9:\
    \ note: 'longestPalindromeStartIndex' previously declared here\n    var longestPalindromeStartIndex\
    \ = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:13:9: error: invalid redeclaration of\
    \ 'longestPalindromeEndIndex'\n    var longestPalindromeEndIndex = 0\n       \
    \ ^\n/tmp/tmp4o8xmeaj.swift:11:9: note: 'longestPalindromeEndIndex' previously\
    \ declared here\n    var longestPalindromeEndIndex = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:14:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndex'\n    var longestPalindromeStartIndex\
    \ = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:10:9: note: 'longestPalindromeStartIndex'\
    \ previously declared here\n    var longestPalindromeStartIndex = 0\n        ^\n\
    /tmp/tmp4o8xmeaj.swift:15:9: error: invalid redeclaration of 'longestPalindromeEndIndex'\n\
    \    var longestPalindromeEndIndex = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:11:9:\
    \ note: 'longestPalindromeEndIndex' previously declared here\n    var longestPalindromeEndIndex\
    \ = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:16:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndex'\n    var longestPalindromeStartIndex = 0\n   \
    \     ^\n/tmp/tmp4o8xmeaj.swift:10:9: note: 'longestPalindromeStartIndex' previously\
    \ declared here\n    var longestPalindromeStartIndex = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndex'\n    var longestPalindromeEndIndex\
    \ = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:11:9: note: 'longestPalindromeEndIndex'\
    \ previously declared here\n    var longestPalindromeEndIndex = 0\n        ^\n\
    /tmp/tmp4o8xmeaj.swift:18:9: error: invalid redeclaration of 'longestPalindromeStartIndex'\n\
    \    var longestPalindromeStartIndex = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:10:9:\
    \ note: 'longestPalindromeStartIndex' previously declared here\n    var longestPalindromeStartIndex\
    \ = 0\n        ^\n/tmp/tmp4o8xmeaj.swift:19:9: error"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseString\
    \ = \"\"\n    var longestPalindromeSuffixReverseString = \"\"\n    var longestPalindromeSuffixReverseStringLength\
    \ = 0\n    var longestPalindromePrefixReverseString = \"\"\n    var longestPalindromePrefixReverseStringLength\
    \ = 0\n    var longestPalindromePrefixReverseStringReverse = \"\"\n    var longestPalindromePrefixReverseStringReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseStringReverseReverse = \"\"\n   \
    \ var longestPalindromePrefixReverseStringReverseReverseLength = 0\n    var longestPalindromePrefixReverseStringReverseReverseString\
    \ = \"\"\n    var longestPalindromeSuffixReverseString = \"\"\n    var longestPalindromeSuffixReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixReverseStringReverse = \"\"\n    var longestPalindromeSuffixReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseStringReverseReverse = \"\"\n   \
    \ var longestPalindromeSuffixReverseStringReverseReverseLength = 0\n    var longestPalindromeSuffixReverseStringReverseReverseString\
    \ = \"\"\n    var longestPalindromePrefixReverseString = \"\"\n    var longestPalindromePrefixReverseStringLength\
    \ = 0\n    var longestPalindromePrefixReverseStringReverse = \"\"\n    var longestPalindromePrefixReverseStringReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseStringReverseReverse = \"\"\n   \
    \ var longestPalindromePrefixReverseStringReverseReverseLength = 0\n    var longestPalindromePrefixReverseStringReverseReverseString\
    \ = \"\"\n    var longestPalindromeSuffixReverseString = \"\"\n    var longestPalindromeSuffixReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixReverseStringReverse = \"\"\n    var longestPalindromeSuffixReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseStringReverseReverse = \"\"\n   \
    \ var longestPalindromeSuffixReverseStringReverseReverseLength = 0\n    var longestPalindromeSuffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpx6wxjcwp.swift:30:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseString'\n\
    \    var longestPalindromeSuffixReverseString = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:21:9:\
    \ note: 'longestPalindromeSuffixReverseString' previously declared here\n    var\
    \ longestPalindromeSuffixReverseString = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:31:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseStringLength'\n\
    \    var longestPalindromeSuffixReverseStringLength = 0\n        ^\n/tmp/tmpx6wxjcwp.swift:22:9:\
    \ note: 'longestPalindromeSuffixReverseStringLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseStringLength = 0\n        ^\n/tmp/tmpx6wxjcwp.swift:37:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseString'\n   \
    \ var longestPalindromePrefixReverseString = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:23:9:\
    \ note: 'longestPalindromePrefixReverseString' previously declared here\n    var\
    \ longestPalindromePrefixReverseString = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:38:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseStringLength'\n\
    \    var longestPalindromePrefixReverseStringLength = 0\n        ^\n/tmp/tmpx6wxjcwp.swift:24:9:\
    \ note: 'longestPalindromePrefixReverseStringLength' previously declared here\n\
    \    var longestPalindromePrefixReverseStringLength = 0\n        ^\n/tmp/tmpx6wxjcwp.swift:39:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseStringReverse'\n\
    \    var longestPalindromePrefixReverseStringReverse = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:25:9:\
    \ note: 'longestPalindromePrefixReverseStringReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseStringReverse = \"\"\n        ^\n/tmp/tmpx6wxjcwp.swift:40:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseStringReverseLength'\n\
    \    var longestPalindromePrefixReverseStringReverseLength = 0\n        ^\n/tmp/tmpx6wxjcwp.swift:26:9:\
    \ note: 'longestPalindromePrefixReverseStringReverseLength' previously declared\
    \ here\n    var longestPalindromePrefixReverseStringReverseLength = 0\n      \
    \  ^\n/tmp/tmpx6wx"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedLongestPalindrome = reverseString(longestPalindrome)\n    return\
    \ reversedLongestPalindrome + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0qik1bo0.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmp0qik1bo0.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmp0qik1bo0.swift:8:37: error: cannot find 'reverseString' in scope\n\
    \    let reversedLongestPalindrome = reverseString(longestPalindrome)\n      \
    \                              ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string)\n    return reversedString + longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5yj9iusf.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmp5yj9iusf.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmp5yj9iusf.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string)\n                         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.last {\n          \
    \  longestPalindrome = stringToReturn\n            longestPalindromeLength = stringToCheck.count\n\
    \        }\n        if stringToCheck == stringToReturn.characters.first {\n  \
    \          longestPalindrome = stringToReturn\n            longestPalindromeLength\
    \ = stringToCheck.count\n        }\n        if stringToCheck == stringToReturn.characters.first\
    \ && stringToCheck == stringToReturn.characters.last {\n            longestPalindrome\
    \ = stringToReturn\n            longestPalindromeLength = stringToCheck.count\n\
    \        }\n    }\n    if longestPalindromeLength > longestPalindromeLength {\n\
    \        stringToReturn = stringToReturn + stringToReturn.characters.reversed()\n\
    \    }\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpkzv9lkyu.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpkzv9lkyu.swift:11:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkzv9lkyu.swift:13:53: error: value of\
    \ type 'Character' has no member 'count'\n            longestPalindromeLength\
    \ = stringToCheck.count\n                                      ~~~~~~~~~~~~~ ^~~~~\n\
    /tmp/tmpkzv9lkyu.swift:15:44: error: 'characters' is unavailable: Please use String\
    \ directly\n        if stringToCheck == stringToReturn.characters.first {\n  \
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpkzv9lkyu.swift:17:53: error: value of type\
    \ 'Character' has no member 'count'\n            longestPalindromeLength = stringToCheck.count\n\
    \                                      ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpkzv9lkyu.swift:19:44:\
    \ error: 'characters' is unavailable: Please use String directly\n        if stringToCheck\
    \ == stringToReturn.characters.first && stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkzv9lkyu.swift:19:96: error: 'characters'\
    \ is unavailable: Please use String directly\n        if stringToCheck == stringToReturn.characters.first\
    \ && stringToCheck == stringToReturn.characters.last {\n                     \
    \                                                 "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var longestPalindrome =\
    \ \"\"\n    var longestPalindromeLength = 0\n    for letter in string {\n    \
    \    if letter == letter.reverse() {\n            palindrome += letter\n     \
    \       longestPalindromeLength += 1\n            if longestPalindromeLength >\
    \ longestPalindrome {\n                longestPalindrome = longestPalindromeLength\n\
    \                longestPalindrome = letter\n            }\n        } else {\n\
    \            palindrome += letter\n        }\n    }\n    return palindrome\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprl8f307h.swift:11:29: error: value of type 'Character' has no member\
    \ 'reverse'\n        if letter == letter.reverse() {\n                     ~~~~~~\
    \ ^~~~~~~\n/tmp/tmprl8f307h.swift:12:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            palindrome += letter\n     \
    \                     ^\n/tmp/tmprl8f307h.swift:14:40: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'String'\n            if\
    \ longestPalindromeLength > longestPalindrome {\n               ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~\n/tmp/tmprl8f307h.swift:14:40: note: overloads for '>' exist\
    \ with these partially matching parameter lists: (Int, Int)\n            if longestPalindromeLength\
    \ > longestPalindrome {\n                                       ^\n/tmp/tmprl8f307h.swift:15:37:\
    \ error: cannot assign value of type 'Int' to type 'String'\n                longestPalindrome\
    \ = longestPalindromeLength\n                                    ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprl8f307h.swift:16:37: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                longestPalindrome = letter\n                \
    \                    ^~~~~~\n/tmp/tmprl8f307h.swift:19:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            palindrome\
    \ += letter\n                          ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = String()\n\
    \    var longestPalindromeLength = 0\n    var longestPalindromePrefix = String()\n\
    \    var longestPalindromeSuffixReversed = String()\n    var longestPalindromeSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedPrefix = String()\n    var longestPalindromeSuffixReversedSuffixReversed\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedLength = 0\n\
    \    var longestPalindromeSuffixReversedSuffixReversedPrefix = String()\n    var\
    \ longestPalindromeSuffixReversedSuffixReversedSuffixReversed = String()\n   \
    \ var longestPalindromeSuffixReversedSuffixReversedSuffixReversedLength = 0\n\
    \    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedPrefix = String()\n\
    \    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversed\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedPrefix\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversed\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedPrefix\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversed\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedPrefix\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversed\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedPrefix\
    \ = String()\n    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvxt9_pt3.swift:32:9: error: type annotation missing in pattern\n\
    \    var longestPalindromeSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReversedSuffixReverse\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    for character in string {\n        if character == character {\n  \
    \          longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = string\n \
    \           }\n        } else {\n            longestPalindromeLength = 0\n   \
    \     }\n    }\n    var reversedString = \"\"\n    for character in longestPalindrome\
    \ {\n        reversedString += character\n    }\n    reversedString = reversedString[longestPalindromeLength..<longestPalindromeLength\
    \ + longestPalindromeLength]\n    return reversedString + longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8aufun58.swift:12:60: error: value of type 'String' has no member\
    \ 'length'\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp8aufun58.swift:21:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        reversedString += character\n                          ^\n/tmp/tmp8aufun58.swift:23:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    reversedString = reversedString[longestPalindromeLength..<longestPalindromeLength\
    \ + longestPalindromeLength]\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjhud85lw.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpjhud85lw.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpjhud85lw.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    for stringToReturn.characters.count\
    \ > 0 {\n        var currentLongestPalindrome = stringToReturn\n        var currentLongestPalindromeLength\
    \ = 0\n        for stringToReturn.characters.count > 0 {\n            if stringToReturn.characters.count\
    \ > longestPalindromeLength {\n                currentLongestPalindromeLength\
    \ = stringToReturn.characters.count\n                currentLongestPalindrome\
    \ = stringToReturn\n            }\n            if stringToReturn.characters.count\
    \ == 0 {\n                break\n            }\n            stringToReturn = stringToReturn.characters.reversed()\n\
    \        }\n        if currentLongestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = currentLongestPalindrome\n            longestPalindromeLength\
    \ = currentLongestPalindromeLength\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqv7143by.swift:10:23: error: expected 'in' after for-each pattern\n\
    \    for stringToReturn.characters.count > 0 {\n                      ^\n/tmp/tmpqv7143by.swift:13:27:\
    \ error: expected 'in' after for-each pattern\n        for stringToReturn.characters.count\
    \ > 0 {\n                          ^\n/tmp/tmpqv7143by.swift:10:24: error: type\
    \ 'Int' has no member 'characters'\n    for stringToReturn.characters.count >\
    \ 0 {\n                      ~^~~~~~~~~~\n/tmp/tmpqv7143by.swift:10:41: error:\
    \ for-in loop requires 'Bool' to conform to 'Sequence'\n    for stringToReturn.characters.count\
    \ > 0 {\n                      ~~~~~~~~~~~~~~~~~~^~~\n/tmp/tmpqv7143by.swift:13:28:\
    \ error: type 'Int' has no member 'characters'\n        for stringToReturn.characters.count\
    \ > 0 {\n                          ~^~~~~~~~~~\n/tmp/tmpqv7143by.swift:13:45:\
    \ error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for stringToReturn.characters.count\
    \ > 0 {\n                          ~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for index in 0..<string.characters.count\
    \ {\n        let character = string.characters[index]\n        if character ==\
    \ \" \" {\n            continue\n        }\n        let reversedCharacter = String(string.characters.reverse())[index]\n\
    \        if character == reversedCharacter {\n            if longestPalindromeLength\
    \ < index {\n                longestPalindrome = stringToReturn\n            \
    \    longestPalindromeLength = index\n            }\n        } else {\n      \
    \      if longestPalindromeLength > index {\n                stringToReturn =\
    \ longestPalindrome\n                longestPalindrome = stringToReturn\n    \
    \            longestPalindromeLength = index\n            }\n        }\n    }\n\
    \    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpcknswkoi.swift:10:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcknswkoi.swift:11:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcknswkoi.swift:11:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcknswkoi.swift:15:58:\
    \ error: value of type 'String' has no member 'reverse'\n        let reversedCharacter\
    \ = String(string.characters.reverse())[index]\n                             \
    \          ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeSuffixStringLength\
    \ = 0\n    var longestPalindromeSuffixStringIndex = 0\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringIndex = 0\n    var\
    \ longestPalindromeSuffixStringReverseStringLength = 0\n    var longestPalindromeSuffixStringReverseStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n  \
    \  var longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringIndex =\
    \ 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmph753lwx3.swift:19:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmph753lwx3.swift:17:9:\
    \ note: 'longestPalindromeSuffixStringReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmph753lwx3.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringIndex = 0\n        ^\n/tmp/tmph753lwx3.swift:21:9:\
    \ note: 'longestPalindromeSuffixStringReverseStringIndex' previously declared\
    \ here\n    var longestPalindromeSuffixStringReverseStringIndex = 0\n        ^\n\
    /tmp/tmph753lwx3.swift:27:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n        ^\n\
    /tmp/tmph753lwx3.swift:25:9: note: 'longestPalindromeSuffixStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmph753lwx3.swift:31:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringIndex'\n    var longestPalindromeSuffixStringReverseStringReverseStringIndex\
    \ = 0\n        ^\n/tmp/tmph753lwx3.swift:29:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringIndex\
    \ = 0\n        ^\n/tmp/tmph753lwx3.swift:35:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverseIndex = 0\n  \
    \      ^\n/tmp/tmph753lwx3.swift:33:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmph753lwx3.swift:39:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringRev"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromeStartIndex = 0\n    var longestPalindromeEndIndex\
    \ = 0\n    var longestPalindromeStartIndexInReverse = 0\n    var longestPalindromeEndIndexInReverse\
    \ = 0\n\n    for index in 0..<string.characters.count {\n        let currentChar\
    \ = string.characters[index]\n        let currentCharIsPalindrome = currentChar\
    \ == string.reverse(currentChar)\n        if currentCharIsPalindrome {\n     \
    \       if longestPalindromeLength < index {\n                longestPalindrome\
    \ = string\n                longestPalindromeLength = index\n                longestPalindromeStartIndex\
    \ = index\n                longestPalindromeEndIndex = index\n               \
    \ longestPalindromeStartIndexInReverse = index\n                longestPalindromeEndIndexInReverse\
    \ = index\n            }\n        } else {\n            if longestPalindromeLength\
    \ > index {\n                longestPalindrome = string\n                longestPalindromeLength\
    \ = index\n                longestPalindromeStartIndex = index\n             \
    \   longestPalindromeEndIndex = index\n                longestPalindromeStartIndexInReverse\
    \ = index\n                longestPalindromeEndIndexInReverse = index\n      \
    \      }\n        }\n    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpurib2fyk.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpurib2fyk.swift:15:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let currentChar\
    \ = string.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpurib2fyk.swift:15:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = string.characters[index]\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpurib2fyk.swift:16:61:\
    \ error: value of type 'String' has no member 'reverse'\n        let currentCharIsPalindrome\
    \ = currentChar == string.reverse(currentChar)\n                             \
    \                        ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var stringPrefix = \"\"\n\
    \    var stringSuffix = \"\"\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixString = \"\"\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeString = \"\"\n    var longestPalindromeStringLength\
    \ = 0\n    var longestPalindromeStringPrefixLength = 0\n    var longestPalindromeStringSuffixLength\
    \ = 0\n    var longestPalindromeStringPrefixString = \"\"\n    var longestPalindromeStringSuffixString\
    \ = \"\"\n    var longestPalindromeStringString = \"\"\n    var longestPalindromeStringStringLength\
    \ = 0\n    var longestPalindromeStringStringPrefixLength = 0\n    var longestPalindromeStringStringSuffixLength\
    \ = 0\n    var longestPalindromeStringStringPrefixString = \"\"\n    var longestPalindromeStringStringSuffixString\
    \ = \"\"\n    var longestPalindromeStringStringString = \"\"\n    var longestPalindromeStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringPrefixLength = 0\n    var longestPalindromeStringStringStringSuffixLength\
    \ = 0\n    var longestPalindromeStringStringStringPrefixString = \"\"\n    var\
    \ longestPalindromeStringStringStringSuffixString = \"\"\n    var longestPalindromeStringStringStringString\
    \ = \"\"\n    var longestPalindromeStringStringStringStringLength = 0\n    var\
    \ longestPalindromeStringStringStringStringPrefixLength = 0\n    var longestPalindromeStringStringStringStringSuffixLength\
    \ = 0\n    var longestPalindromeStringStringStringStringPrefixString = \"\"\n\
    \    var longestPalindromeStringStringStringStringSuffixString = \"\"\n    var\
    \ longestPalindromeStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringStringPrefixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringSuffixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpn8iw3yd3.swift:47:9: error: invalid redeclaration of 'longestPalindromeStringStringStringStringStringLength'\n\
    \    var longestPalindromeStringStringStringStringStringLength = 0\n        ^\n\
    /tmp/tmpn8iw3yd3.swift:41:9: note: 'longestPalindromeStringStringStringStringStringLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringLength\
    \ = 0\n        ^\n/tmp/tmpn8iw3yd3.swift:48:9: error: invalid redeclaration of\
    \ 'longestPalindromeStringStringStringStringStringPrefixLength'\n    var longestPalindromeStringStringStringStringStringPrefixLength\
    \ = 0\n        ^\n/tmp/tmpn8iw3yd3.swift:42:9: note: 'longestPalindromeStringStringStringStringStringPrefixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringPrefixLength\
    \ = 0\n        ^\n/tmp/tmpn8iw3yd3.swift:49:9: error: invalid redeclaration of\
    \ 'longestPalindromeStringStringStringStringStringSuffixLength'\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n/tmp/tmpn8iw3yd3.swift:43:9: note: 'longestPalindromeStringStringStringStringStringSuffixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n/tmp/tmpn8iw3yd3.swift:50:9: error: type annotation missing\
    \ in pattern\n    var longestP\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n\n    for _ in 0..<string.count\
    \ {\n        let index = string.index(string.startIndex, offsetBy: 1)\n      \
    \  let char = string[index]\n        if char == string[index.reversed().first!]\
    \ {\n            longestPalindrome = string\n            longestPalindromeLength\
    \ = string.count\n            longestPalindromePrefix = string\n            longestPalindromePrefixLength\
    \ = string.count\n            longestPalindromeSuffix = string\n            longestPalindromeSuffixLength\
    \ = string.count\n            longestPalindromeSuffixReverse = string\n      \
    \      longestPalindromePrefixReverse = string\n            longestPalindromePrefixReverseLength\
    \ = string.count\n            longestPalindromeSuffixReverseLength = string.count\n\
    \        } else {\n            if longestPalindromeLength > longestPalindromePrefixLength\
    \ {\n                longestPalindromePrefix = string\n                longestPalindromePrefixLength\
    \ = string.count\n            }\n            if longestPalindromeLength > longestPalindromeSuffixLength\
    \ {\n                longestPalindromeSuffix = string\n                longestPalindromeSuffixLength\
    \ = string.count\n            }\n            if longestPalindromeLength > longestPalindromeSuffixReverseLength\
    \ {\n                longestPalindromeSuffixReverse = string\n               \
    \ longestPalindromeSuffixReverseLength = string.count\n            }\n       \
    \     if longestPalindromeLength > longestPalindromePrefixReverseLength {\n  \
    \              longestPalindromePrefixReverse = string\n                longestPalindromePrefixReverseLength\
    \ = string.count\n            }\n        }\n        string = string[index..<string.endIndex]\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphvjhjlsq.swift:22:33: error: value of type 'String.Index' has no\
    \ member 'reversed'\n        if char == string[index.reversed().first!] {\n  \
    \                        ~~~~~ ^~~~~~~~\n/tmp/tmphvjhjlsq.swift:51:24: error:\
    \ cannot assign value of type 'Substring' to type 'String'\n        string = string[index..<string.endIndex]\n\
    \                 ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n                 String(  \
    \                      )\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix:\
    \ String = \"\"\n    var longestPalindromeSuffix: String = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversed: String = \"\"\n    var\
    \ longestPalindromePrefixReversedLength = 0\n    var longestPalindromeSuffixReversedLength\
    \ = 0\n    var longestPalindromePrefixReversedReversed: String = \"\"\n    var\
    \ longestPalindromeSuffixReversedReversed: String = \"\"\n    var longestPalindromePrefixReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedLength = 0\n    var longestPalindromePrefixReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversed: String\
    \ = \"\"\n    var longestPalindromePrefixReversedReversedReversedLength = 0\n\
    \    var longestPalindromeSuffixReversedReversedReversedLength = 0\n    var longestPalindromePrefixReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedLength =\
    \ 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedLength\
    \ = 0\n    var longestPalindromePrefixReversedReversedReversedReversedReversedReversedReversed:\
    \ String = \"\"\n    var longestPalindromeSuffixReversedReversedReversedReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpy8jyuu89.swift:37:9: error: invalid redeclaration of 'longestPalindromeSuffixReversedReversedReversedReversedReversedLength'\n\
    \    var longestPalindromeSuffixReversedReversedReversedReversedReversedLength\
    \ = 0\n        ^\n/tmp/tmpy8jyuu89.swift:33:9: note: 'longestPalindromeSuffixReversedReversedReversedReversedReversedLength'\
    \ previously declared here\n    var longestPalindromeSuffixReversedReversedReversedReversedReversedLength\
    \ = 0\n        ^\n/tmp/tmpy8jyuu89.swift:39:9: error: type annotation missing\
    \ in pattern\n    var longestPalindromeSuffixReversedReversedReversedReverse\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = string.length\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfix\
    \ = \"\"\n    var longestPalindromePostfixLength = 0\n    var longestPalindromePostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixSuffix = \"\"\n\n    for _ in 0..<string.length\
    \ {\n        let currentChar = string[string.startIndex]\n        let currentCharLength\
    \ = string.length\n\n        if currentChar == currentChar.reversed() {\n    \
    \        longestPalindromeLength -= 1\n            longestPalindromePostfixLength\
    \ += 1\n            longestPalindromePostfixSuffix += currentChar\n          \
    \  longestPalindromePostfixPrefix += string[string.startIndex..<string.startIndex+longestPalindromePostfixLength]\n\
    \            longestPalindromePostfixLength += 1\n            longestPalindromePostfixSuffix\
    \ += currentChar\n        } else {\n            longestPalindromeLength += 1\n\
    \            longestPalindromePostfixLength += 1\n            longestPalindromePostfixSuffix\
    \ += currentChar\n            longestPalindromePostfixPrefix += string[string.startIndex..<string.startIndex+longestPalindromePostfixLength]\n\
    \        }\n\n        if longestPalindromeLength > longestPalindromePostfixLength\
    \ {\n            longestPalindrome = longestPalindromePostfixPrefix\n        \
    \    longestPalindromeLength = longestPalindromePostfixLength\n            longestPalindromePrefix\
    \ = longestPalindromePostfixPrefix\n            longestPalindromeSuffix = longestPalindromePostfixSuffix\n\
    \            longestPalindromePostfix = longestPalindromePostfixSuffix\n     \
    \       longestPalindromePostfixPrefix = longestPalindromePostfixSuffix\n    \
    \        longestPalindromePostfixLength = 0\n            longestPalindromePostfixSuffix\
    \ = \"\"\n        }\n    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmcmo4idg.swift:9:42: error: value of type 'String' has no member\
    \ 'length'\n    var longestPalindromeLength = string.length\n                \
    \                  ~~~~~~ ^~~~~~\n/tmp/tmpmcmo4idg.swift:17:25: error: value of\
    \ type 'String' has no member 'length'\n    for _ in 0..<string.length {\n   \
    \              ~~~~~~ ^~~~~~\n/tmp/tmpmcmo4idg.swift:19:40: error: value of type\
    \ 'String' has no member 'length'\n        let currentCharLength = string.length\n\
    \                                ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(longestPalindrome)\n    return longestPalindrome\
    \ + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhbe1vgq.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpvhbe1vgq.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpvhbe1vgq.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(longestPalindrome)\n                 \
    \        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n\n    for _ in 0..<string.characters.count {\n        let currentChar\
    \ = string.characters[string.startIndex]\n        let currentCharLength = string.characters.count\n\
    \n        if currentCharLength > longestPalindromeLength {\n            longestPalindrome\
    \ = string\n            longestPalindromeLength = currentCharLength\n        \
    \    longestPalindromePrefix = \"\"\n            longestPalindromeSuffixLength\
    \ = 0\n            longestPalindromeSuffixReverse = \"\"\n        }\n\n      \
    \  if currentCharLength == longestPalindromeLength {\n            longestPalindromeSuffix\
    \ += currentChar\n            longestPalindromeSuffixLength += 1\n        }\n\n\
    \        if currentCharLength > longestPalindromeSuffixLength {\n            longestPalindromeSuffix\
    \ = string\n            longestPalindromeSuffixLength = currentCharLength\n  \
    \          longestPalindromePrefix = \"\"\n            longestPalindromePrefixLength\
    \ = 0\n            longestPalindromeSuffixReverse = \"\"\n        }\n\n      \
    \  if currentCharLength == longestPalindromeSuffixLength {\n            longestPalindromeSuffix\
    \ += currentChar\n            longestPalindromeSuffixReverse += currentChar\n\
    \            longestPalindromeSuffixLength += 1\n        }\n\n        if currentCharLength\
    \ > longestPalindromePrefixLength {\n            longestPalindromePrefix = string\n\
    \            longestPalindromePrefixLength = currentCharLength\n        }\n\n\
    \        if currentCharLength == longestPalindromePrefixLength {\n           \
    \ longestPalindromePrefix += currentChar\n            longestPalindromePrefixLength\
    \ += 1\n        }\n\n        if currentCharLength > longestPalindromeSuffixLength\
    \ && currentCharLength == longestPalindromePrefixLength {\n            longestPalindrome\
    \ = string\n            longestPalindromeLength = currentCharLength\n        \
    \    longestPalindromePrefix = \"\"\n            longestPalindromeSuffixLength\
    \ = 0\n            longestPalindromeSuffixReverse = \"\"\n        }\n    }\n\n\
    \    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpn4jbb1qi.swift:16:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpn4jbb1qi.swift:17:34: error: 'characters' is unavailable: Please\
    \ use String directly\n        let currentChar = string.characters[string.startIndex]\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn4jbb1qi.swift:18:40: error: 'characters' is unavailable:\
    \ Please use String directly\n        let currentCharLength = string.characters.count\n\
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn4jbb1qi.swift:29:40: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            longestPalindromeSuffix\
    \ += currentChar\n                                       ^\n/tmp/tmpn4jbb1qi.swift:42:40:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindromeSuffix += currentChar\n                        \
    \               ^\n/tmp/tmpn4jbb1qi.swift:43:47: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            longestPalindromeSuffixReverse\
    \ += currentChar\n                                              ^\n/tmp/tmpn4jbb1qi.swift:53:40:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindromePrefix += currentChar\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePostfixLength\
    \ = 0\n    var longestPalindromePostfix = \"\"\n    var longestPalindromePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReverseLength = 0\n    var longestPalindromePostfixReverseString\
    \ = \"\"\n    var longestPalindromePostfixReverseStringLength = 0\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longestPalindromePostfixReverseStringLength\
    \ = 0\n    var longestPalindromePostfixReverseString = \"\"\n    var longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3jfg_xfw.swift:18:9: error: invalid redeclaration of 'longestPalindromePostfixReverseStringLength'\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:17:9:\
    \ note: 'longestPalindromePostfixReverseStringLength' previously declared here\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromePostfixReverseString'\n  \
    \  var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:16:9:\
    \ note: 'longestPalindromePostfixReverseString' previously declared here\n   \
    \ var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:20:9:\
    \ error: invalid redeclaration of 'longestPalindromePostfixReverseStringLength'\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:17:9:\
    \ note: 'longestPalindromePostfixReverseStringLength' previously declared here\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromePostfixReverseString'\n  \
    \  var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:16:9:\
    \ note: 'longestPalindromePostfixReverseString' previously declared here\n   \
    \ var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromePostfixReverseStringLength'\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:17:9:\
    \ note: 'longestPalindromePostfixReverseStringLength' previously declared here\n\
    \    var longestPalindromePostfixReverseStringLength = 0\n        ^\n/tmp/tmp3jfg_xfw.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromePostfixReverseString'\n  \
    \  var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:16:9:\
    \ note: 'longestPalindromePostfixReverseString' previously declared here\n   \
    \ var longestPalindromePostfixReverseString = \"\"\n        ^\n/tmp/tmp3jfg_xfw.swift:24:9:\
    \ error: invalid "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindrome = 0\n    var longestPalindromeStartIndexOfLongestPalindromeLength\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeLength = 0\n    var\
    \ longestPalindromeStartIndexOfLongestPalindromeStartIndex = 0\n    var longestPalindromeEndIndexOfLongestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeEndIndex = 0\n  \
    \  var longestPalindromeEndIndexOfLongestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeLength\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindromeLength\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeEndIndex\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindromeEndIndex\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindromeEndIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeStartIndexOfLongestPalindromeLength\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpi8xt1sfl.swift:31:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpi8xt1sfl.swift:7:9: warning: initialization of variable 'string'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var string = string\n    ~~~~^~~~~~\n    _\n/tmp/tmpi8xt1sfl.swift:8:9: warning:\
    \ initialization of variable 'longestPalindrome' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var longestPalindrome = \"\"\n  \
    \  ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpi8xt1sfl.swift:9:9: warning: initialization\
    \ of variable 'longestPalindromeLength' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var longestPalindromeLength = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpi8xt1sfl.swift:10:9: warning: initialization of variable 'longestPalindromeStartIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeStartIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpi8xt1sfl.swift:11:9: warning: initialization of variable 'longestPalindromeEndIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeEndIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpi8xt1sfl.swift:12:9: warning: initialization of variable 'longestPalindromeStartIndexOfLongestPalindrome'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeStartIndexOfLongestPalindrome = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpi8xt1sfl.swift:13:9: warning: initialization of variable 'longestPalindromeEndIndexOfLongestPalindrome'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeEndIndexOfLongestPalindrome = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpi8xt1sfl.swift:14:9: warning: initialization of variable 'longestPalindromeStartIndexOfLongestPalindromeLength'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeStartInde"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    for character in string {\n        if character == character[character.startIndex]\
    \ {\n            reversedString += character\n        } else {\n            if\
    \ longestPalindrome == \"\" {\n                longestPalindrome = reversedString\n\
    \            } else {\n                reversedString = longestPalindrome\n  \
    \              longestPalindrome = reversedString\n            }\n        }\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqcomtz6r.swift:10:34: error: value of type 'Character' has no subscripts\n\
    \        if character == character[character.startIndex] {\n                 \
    \       ~~~~~~~~~^\n/tmp/tmpqcomtz6r.swift:10:45: error: value of type 'Character'\
    \ has no member 'startIndex'\n        if character == character[character.startIndex]\
    \ {\n                                  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqcomtz6r.swift:11:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            reversedString += character\n                              ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    for character in string {\n        reversedString = reversedString\
    \ + String(character)\n        if longestPalindrome == \"\" {\n            longestPalindrome\
    \ = reversedString\n        } else {\n            if longestPalindrome == reversedString\
    \ {\n                longestPalindrome = longestPalindrome + String(character)\n\
    \            }\n        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'tmpcc8xoi4t/tmpcc8xoi4t.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b480fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b4506b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b4506988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b45057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc8xoi4t                        0x000055e864834672 <unavailable> + 5746

    5    libc.so.6                          0x00002b89b49fb460 __libc_start_main +
    245

    6    tmpcc8xoi4t                        0x000055e8648340a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for character in string {\n        if character == character {\n       \
    \     result += character\n        } else {\n            longestPalindrome +=\
    \ character\n        }\n    }\n    for character in longestPalindrome {\n    \
    \    if character == character {\n            result += character\n        } else\
    \ {\n            result += character + character\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdyb_mjlc.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpdyb_mjlc.swift:13:34: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            longestPalindrome\
    \ += character\n                                 ^\n/tmp/tmpdyb_mjlc.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n/tmp/tmpdyb_mjlc.swift:20:20:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String' and\
    \ '_'\n            result += character + character\n            ~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    for stringIndex in 0..<string.count\
    \ {\n        let stringPrefix = string.prefix(stringIndex)\n        let stringSuffix\
    \ = string.suffix(stringIndex)\n        let stringReversed = stringSuffix.reversed()\n\
    \        let stringPalindrome = stringPrefix + stringReversed\n        let stringPalindromeLength\
    \ = stringPalindrome.count\n        if stringPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindromeLength = stringPalindromeLength\n          \
    \  longestPalindrome = stringPalindrome\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0xfth_3f.swift:18:33: error: cannot assign value of type 'String.SubSequence'\
    \ (aka 'Substring') to type 'String'\n            longestPalindrome = stringPalindrome\n\
    \                                ^~~~~~~~~~~~~~~~\n                          \
    \      String(         )\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for character in string {\n\
    \        if character == character {\n            reversedString += character\n\
    \        }\n        if character == reversedString[reversedString.length-1] {\n\
    \            longestPalindrome = reversedString\n            longestPalindromeLength\
    \ = reversedString.length\n        }\n    }\n    return longestPalindrome + reversedString[longestPalindromeLength...reversedString.length]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfzi6osr3.swift:12:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            reversedString += character\n\
    \                              ^\n/tmp/tmpfzi6osr3.swift:14:55: error: value of\
    \ type 'String' has no member 'length'\n        if character == reversedString[reversedString.length-1]\
    \ {\n                                       ~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpfzi6osr3.swift:16:54:\
    \ error: value of type 'String' has no member 'length'\n            longestPalindromeLength\
    \ = reversedString.length\n                                      ~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpfzi6osr3.swift:19:88: error: value of type 'String' has no member\
    \ 'length'\n    return longestPalindrome + reversedString[longestPalindromeLength...reversedString.length]\n\
    \                                                                        ~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var longestPalindrome =\
    \ \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex =\
    \ 0\n    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixStart = 0\n    var longestPalindromeSuffixEnd\
    \ = 0\n    var longestPalindromeSuffixLengthStart = 0\n    var longestPalindromeSuffixLengthEnd\
    \ = 0\n    var longestPalindromeSuffixStartIndex = 0\n    var longestPalindromeSuffixEndIndex\
    \ = 0\n    var longestPalindromeSuffixStartIndexEnd = 0\n    var longestPalindromeSuffixEndIndexEnd\
    \ = 0\n    var longestPalindromeSuffixStartIndexEndIndex = 0\n    var longestPalindromeSuffixEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixStartIndexEndIndexEnd = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd\
    \ = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n    var\
    \ longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndexEndIndexEnd\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplvzycp9g.swift:26:9: error: invalid redeclaration of 'longestPalindromeSuffixEndIndexEndIndexEnd'\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:24:9:\
    \ note: 'longestPalindromeSuffixEndIndexEndIndexEnd' previously declared here\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:27:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStartIndexEndIndexEndIndex'\n\
    \    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n        ^\n/tmp/tmplvzycp9g.swift:25:9:\
    \ note: 'longestPalindromeSuffixStartIndexEndIndexEndIndex' previously declared\
    \ here\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n      \
    \  ^\n/tmp/tmplvzycp9g.swift:28:9: error: invalid redeclaration of 'longestPalindromeSuffixEndIndexEndIndexEnd'\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:24:9:\
    \ note: 'longestPalindromeSuffixEndIndexEndIndexEnd' previously declared here\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:29:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStartIndexEndIndexEndIndex'\n\
    \    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n        ^\n/tmp/tmplvzycp9g.swift:25:9:\
    \ note: 'longestPalindromeSuffixStartIndexEndIndexEndIndex' previously declared\
    \ here\n    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n      \
    \  ^\n/tmp/tmplvzycp9g.swift:30:9: error: invalid redeclaration of 'longestPalindromeSuffixEndIndexEndIndexEnd'\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:24:9:\
    \ note: 'longestPalindromeSuffixEndIndexEndIndexEnd' previously declared here\n\
    \    var longestPalindromeSuffixEndIndexEndIndexEnd = 0\n        ^\n/tmp/tmplvzycp9g.swift:31:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStartIndexEndIndexEndIndex'\n\
    \    var longestPalindromeSuffixStartIndexEndIndexEndIndex = 0\n        ^\n/tmp/tmplvzycp9g.swift:25:9:\
    \ note: 'longestPalindromeSuffixStartIndexEndIndexEndIndex' previously decl"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n    for char in string {\n        if char == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            if\
    \ longestPalindromeLength > 0 {\n                longestPalindromeLength = 0\n\
    \                longestPalindromePrefix = String(longestPalindromePrefix) + String(char)\n\
    \            }\n            if longestPalindromeLength == 0 {\n              \
    \  longestPalindromeSuffix = String(char) + String(longestPalindromeSuffix)\n\
    \            }\n        }\n    }\n    if longestPalindromeLength > 0 {\n     \
    \   longestPalindrome = String(longestPalindromePrefix) + String(longestPalindromeSuffix)\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp92jjqb_a.swift:12:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if char ==\
    \ longestPalindrome[longestPalindromeLength] {\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let maxLength: Int = string.characters.count\n    let\
    \ maxIndex = string.characters.index(maxLength, offsetBy: -1)\n    let maxPalindrome\
    \ = string.substring(to: maxIndex)\n    let maxPalindromeReversed = maxPalindrome.reversed()\n\
    \    return maxPalindromeReversed + maxPalindrome\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3iukmgit.swift:7:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLength: Int = string.characters.count\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3iukmgit.swift:8:44: error: cannot convert value of\
    \ type 'Int' to expected argument type 'String.Index'\n    let maxIndex = string.characters.index(maxLength,\
    \ offsetBy: -1)\n                                           ^\n/tmp/tmp3iukmgit.swift:9:32:\
    \ error: value of type 'String' has no member 'substring'\n    let maxPalindrome\
    \ = string.substring(to: maxIndex)\n                        ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reverse = \"\"\n    var longestPalindrome = \"\"\
    \n    for character in string {\n        if character == character {\n       \
    \     reverse = reverse + character\n        }\n        if character == reverse[reverse.startIndex]\
    \ {\n            longestPalindrome = longestPalindrome + character\n        }\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5m4xxjyn.swift:11:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            reverse = reverse + character\n\
    \                                ^\n/tmp/tmp5m4xxjyn.swift:14:53: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       longestPalindrome = longestPalindrome + character\n                  \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength =\
    \ 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromePrefixStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromePrefixStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverse = \"\"\n \
    \   var longestPalindromePrefixStringReverseStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseStringReverseString = \"\"\n\
    \    var longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverseLength = 0\n \
    \   var longestPalindromeSuffixStringReverseStringReverseStringReverseLength =\
    \ 0\n    var longestPalindromePrefixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ohqbhej.swift:34:9: error: invalid redeclaration of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:32:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:35:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:33:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:36:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:39:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:37:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmp2ohqbhej.swift:40:9: error: invalid "
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseIndex = 0\n    var longestPalindromeSuffixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpc3njtc5i.swift:52:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpc3njtc5i.swift:20:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:18:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpc3njtc5i.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpc3njtc5i.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:18:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpc3njtc5i.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpc3njtc5i.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseIndex'\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:18:9:\
    \ note: 'longestPalindromeSuffixReverseReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseIndex = 0\n        ^\n/tmp/tmpc3njtc5i.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpc3njtc5i.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        }\n  \
    \      if character == character {\n            longestPalindromeLength += 1\n\
    \            if longestPalindromeLength > longestPalindrome {\n              \
    \  longestPalindrome = longestPalindromeLength\n                longestPalindrome\
    \ = character\n            }\n        }\n    }\n    result += longestPalindrome\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4s6y90f.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpi4s6y90f.swift:16:40: error: binary operator '>' cannot\
    \ be applied to operands of type 'Int' and 'String'\n            if longestPalindromeLength\
    \ > longestPalindrome {\n               ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpi4s6y90f.swift:16:40: note: overloads for '>' exist with these partially\
    \ matching parameter lists: (Int, Int)\n            if longestPalindromeLength\
    \ > longestPalindrome {\n                                       ^\n/tmp/tmpi4s6y90f.swift:17:37:\
    \ error: cannot assign value of type 'Int' to type 'String'\n                longestPalindrome\
    \ = longestPalindromeLength\n                                    ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpi4s6y90f.swift:18:37: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                longestPalindrome = character\n             \
    \                       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfReversedString\
    \ = 0\n    var longestPalindromeEndIndexOfReversedString = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeEndIndexOfReversedStringOfReversedString = 0\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n    var longestPalindromeStartIndexOfReversed\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpec_smssc.swift:17:9: error: invalid redeclaration of 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:18:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:19:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:20:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:16:9: note: 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\
    \ previously declared here\n    var longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString\
    \ = 0\n        ^\n/tmp/tmpec_smssc.swift:21:9: error: invalid redeclaration of\
    \ 'longestPalindromeStartIndexOfReversedStringOfReversedStringOfReversedString'\n\
    \    var longestPa"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var longestPalindrome =\
    \ \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex\
    \ = 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n    var longestPalindromeEndIndexBeforeReverse = 0\n    var longestPalindromeStartIndexAfterReverse\
    \ = 0\n    var longestPalindromeEndIndexAfterReverse = 0\n    var longestPalindromeStartIndexBeforeReverse\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpma1ie4yd.swift:16:9: error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:18:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexBeforeReverse'\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:14:9:\
    \ note: 'longestPalindromeStartIndexBeforeReverse' previously declared here\n\
    \    var longestPalindromeStartIndexBeforeReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexBeforeReverse'\n \
    \   var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:15:9:\
    \ note: 'longestPalindromeEndIndexBeforeReverse' previously declared here\n  \
    \  var longestPalindromeEndIndexBeforeReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:20:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexAfterReverse'\n\
    \    var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:12:9:\
    \ note: 'longestPalindromeStartIndexAfterReverse' previously declared here\n \
    \   var longestPalindromeStartIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexAfterReverse'\n  \
    \  var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:13:9:\
    \ note: 'longestPalindromeEndIndexAfterReverse' previously declared here\n   \
    \ var longestPalindromeEndIndexAfterReverse = 0\n        ^\n/tmp/tmpma1ie4yd.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexB"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n    return\
    \ longestPalindrome + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3ubqomwk.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string:\
    \ string)\n                            ^\n/tmp/tmp3ubqomwk.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \        ^\n/tmp/tmp3ubqomwk.swift:8:26: error: cannot find 'reverseString' in\
    \ scope\n    let reversedString = reverseString(string: longestPalindrome)\n \
    \                        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = \"\"\n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseLength = 0\n    var longestPalindromeSuffixReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjugusu44.swift:22:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpjugusu44.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpjugusu44.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpjugusu44.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpjugusu44.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:20:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpjugusu44.swift:27:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpjugusu44.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePre"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for character in string {\n        if character == character {\n       \
    \     result += character\n        } else {\n            if longestPalindrome\
    \ == \"\" {\n                longestPalindrome = character\n            } else\
    \ {\n                longestPalindrome += character\n            }\n        }\n\
    \    }\n    for character in longestPalindrome {\n        if character == character\
    \ {\n            result += character\n        } else {\n            result +=\
    \ character + character\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6m43k505.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmp6m43k505.swift:14:37: error: cannot assign value of\
    \ type 'Character' to type 'String'\n                longestPalindrome = character\n\
    \                                    ^~~~~~~~~\n/tmp/tmp6m43k505.swift:16:38:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                longestPalindrome += character\n                            \
    \         ^\n/tmp/tmp6m43k505.swift:22:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += character\n\
    \                      ^\n/tmp/tmp6m43k505.swift:24:20: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String' and '_'\n            result\
    \ += character + character\n            ~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n    for character in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindromePrefix = string[longestPalindromeLength..<longestPalindromeLength]\n\
    \            longestPalindromeSuffix = string[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \        }\n    }\n    return longestPalindromePrefix + longestPalindromeSuffix\
    \ + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmrzhazag.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmrzhazag.swift:18:39:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            longestPalindromePrefix\
    \ = string[longestPalindromeLength..<longestPalindromeLength]\n              \
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpmrzhazag.swift:19:97: error: cannot\
    \ assign value of type 'ReversedCollection<String>' to type 'String'\n       \
    \     longestPalindromeSuffix = string[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpmrzhazag.swift:22:133: error: cannot convert value of type 'ReversedCollection<String>'\
    \ to expected argument type 'String'\n    return longestPalindromePrefix + longestPalindromeSuffix\
    \ + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \                                                                            \
    \                                                        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = \"\"\n    var longestPalindrome\
    \ = \"\"\n    for character in string {\n        reversedString = reversedString\
    \ + String(character)\n        if longestPalindrome == \"\" {\n            longestPalindrome\
    \ = reversedString\n        } else {\n            if longestPalindrome == reversedString\
    \ {\n                longestPalindrome = longestPalindrome + String(character)\n\
    \            } else {\n                longestPalindrome = longestPalindrome +\
    \ String(character) + reversedString\n            }\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: Exception
  stderr: 'tmpt6ywq1fr/tmpt6ywq1fr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ab3aecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ab37e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ab37e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ab37e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6ywq1fr                        0x000055704e82c672 <unavailable> + 5746

    5    libc.so.6                          0x00002b0ab3cd8460 __libc_start_main +
    245

    6    tmpt6ywq1fr                        0x000055704e82c0a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength =\
    \ 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseReverseReverse = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverse = \"\
    \"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmps3dmnzef.swift:26:9: error: invalid redeclaration of 'longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:24:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:27:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:25:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:32:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:30:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:33:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:31:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmps3dmnzef.swift:38:9: error: invalid "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = string\n\
    \    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\n\
    \    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfix = \"\
    \"\n    var longestPalindromePostfixLength = 0\n    var longestPalindromePostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixSuffix = \"\"\n    var longestPalindromePostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixLength = 0\n    var longestPalindromePostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixSuffix = \"\"\n    var longestPalindromePostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixLength = 0\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixSuffix = \"\"\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfix = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPrefix = \"\"\n  \
    \  var longestPalindromePostfixPostfixPostfixPostfixSuffix = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength =\
    \ 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix = \"\"\
    \n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix = \"\"\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix = \"\"\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength = 0\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPrefix = \"\
    \"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixSuffix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestPalin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpwyw73f4x.swift:39:9: error: type annotation missing in pattern\n\
    \    var longestPalin\n        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        } else {\n     \
    \       if longestPalindromeLength < char.count {\n                longestPalindrome\
    \ = char\n                longestPalindromeLength = char.count\n            }\n\
    \        }\n    }\n    if longestPalindromeLength > 0 {\n        let reversedString\
    \ = reverseString(string: longestPalindrome)\n        result = reversedString\
    \ + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxjbawvh0.swift:11:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == char.lowercased()\
    \ {\n           ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpxjbawvh0.swift:11:17: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if char == char.lowercased() {\n     \
    \           ^\n/tmp/tmpxjbawvh0.swift:12:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += char\n\
    \                      ^\n/tmp/tmpxjbawvh0.swift:14:47: error: value of type 'Character'\
    \ has no member 'count'\n            if longestPalindromeLength < char.count {\n\
    \                                         ~~~~ ^~~~~\n/tmp/tmpxjbawvh0.swift:15:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = char\n                                    ^~~~\n/tmp/tmpxjbawvh0.swift:16:48:\
    \ error: value of type 'Character' has no member 'count'\n                longestPalindromeLength\
    \ = char.count\n                                          ~~~~ ^~~~~\n/tmp/tmpxjbawvh0.swift:21:30:\
    \ error: cannot find 'reverseString' in scope\n        let reversedString = reverseString(string:\
    \ longestPalindrome)\n                             ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    for _ in 0..<string.count {\n        let reversedString = reverseString(string)\n\
    \        if longestPalindromeLength < reversedString.count {\n            longestPalindrome\
    \ = reversedString\n            longestPalindromeLength = reversedString.count\n\
    \        }\n        string = string.dropLast()\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoim_0k2n.swift:10:30: error: cannot find 'reverseString' in scope\n\
    \        let reversedString = reverseString(string)\n                        \
    \     ^~~~~~~~~~~~~\n/tmp/tmpoim_0k2n.swift:15:9: error: cannot assign to value:\
    \ 'string' is a 'let' constant\n        string = string.dropLast()\n        ^~~~~~\n\
    /tmp/tmpoim_0k2n.swift:15:25: error: no 'dropLast' candidates produce the expected\
    \ contextual result type 'String'\n        string = string.dropLast()\n      \
    \                  ^\nSwift.Sequence:5:40: note: 'dropLast' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func dropLast(_ k: Int = 1) -> [Self.Element]\n\
    \                                       ^\nSwift.Collection:4:40: note: 'dropLast'\
    \ produces 'String.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func dropLast(_ k: Int\
    \ = 1) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindromeLength\
    \ = 0\n    for c in string {\n        if isPalindrome(c) {\n            longestPalindromeLength\
    \ += 1\n        } else {\n            if longestPalindromeLength > 0 {\n     \
    \           result += string[longestPalindromeLength..<longestPalindromeLength+longestPalindromeLength].reversed()\n\
    \            }\n            longestPalindromeLength = 0\n            result +=\
    \ c\n        }\n    }\n    if longestPalindromeLength > 0 {\n        result +=\
    \ string[longestPalindromeLength..<longestPalindromeLength+longestPalindromeLength].reversed()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpouifd2ki.swift:10:12: error: cannot find 'isPalindrome' in scope\n\
    \        if isPalindrome(c) {\n           ^~~~~~~~~~~~\n/tmp/tmpouifd2ki.swift:14:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n                result += string[longestPalindromeLength..<longestPalindromeLength+longestPalindromeLength].reversed()\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpouifd2ki.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += c\n                      ^\n/tmp/tmpouifd2ki.swift:21:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        result += string[longestPalindromeLength..<longestPalindromeLength+longestPalindromeLength].reversed()\n\
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmswx9mzq.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string:\
    \ string)\n                            ^\n/tmp/tmpmswx9mzq.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string: string)\n\
    \        ^\n/tmp/tmpmswx9mzq.swift:8:26: error: cannot find 'reverseString' in\
    \ scope\n    let reversedString = reverseString(string: longestPalindrome)\n \
    \                        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for character in string {\n        if character == character {\n       \
    \     result += character\n        } else {\n            longestPalindrome +=\
    \ character\n        }\n    }\n    for character in string {\n        if character\
    \ == character {\n            result += character\n        } else {\n        \
    \    result += longestPalindrome\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpn0wgcxyo.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpn0wgcxyo.swift:13:34: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            longestPalindrome\
    \ += character\n                                 ^\n/tmp/tmpn0wgcxyo.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    for _ in 0..<string.count {\n        let reversedSubstring = reversedString.substringFromIndex(string.reversed().startIndex)\n\
    \        if reversedSubstring == longestPalindrome {\n            longestPalindrome\
    \ = longestPalindrome.replacingOccurrences(of: reversedSubstring, with: reversedSubstring.reversed())\n\
    \        } else {\n            longestPalindrome = longestPalindrome.replacingOccurrences(of:\
    \ reversedSubstring, with: reversedSubstring)\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpby5wxnhv.swift:10:48: error: value of type 'String' has no member\
    \ 'substringFromIndex'\n        let reversedSubstring = reversedString.substringFromIndex(string.reversed().startIndex)\n\
    \                                ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpby5wxnhv.swift:12:51:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     longestPalindrome = longestPalindrome.replacingOccurrences(of: reversedSubstring,\
    \ with: reversedSubstring.reversed())\n                                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpby5wxnhv.swift:14:51: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n            longestPalindrome = longestPalindrome.replacingOccurrences(of:\
    \ reversedSubstring, with: reversedSubstring)\n                              \
    \  ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n\n    for stringToReturn.count\
    \ > 0 {\n        let stringToReturn = stringToReturn.substringToIndex(advance(stringToReturn.startIndex,\
    \ 1))\n        let stringToReturnReverse = stringToReturn.reversed()\n       \
    \ let stringToReturnPrefixReverse = stringToReturnReverse.substringToIndex(advance(stringToReturnReverse.startIndex,\
    \ 1))\n        let stringToReturnSuffixReverse = stringToReturnReverse.substringFromIndex(advance(stringToReturnReverse.startIndex,\
    \ 1))\n        let stringToReturnPrefix = stringToReturn.substringToIndex(advance(stringToReturn.startIndex,\
    \ 1))\n        let stringToReturnSuffix = stringToReturn.substringFromIndex(advance(stringToReturn.startIndex,\
    \ 1))\n\n        if stringToReturn.characters.count == stringToReturnReverse.characters.count\
    \ {\n            if stringToReturn.characters.count == stringToReturnPrefixReverse.characters.count\
    \ {\n                if stringToReturn.characters.count == stringToReturnSuffixReverse.characters.count\
    \ {\n                    if stringToReturn.characters.count == stringToReturnPrefix.characters.count\
    \ {\n                        if stringToReturn.characters.count == stringToReturnSuffix.characters.count\
    \ {\n                            if stringToReturn.characters.count == stringToReturn.characters.count\
    \ {\n                                longestPalindrome = stringToReturn\n    \
    \                            longestPalindromeLength = stringToReturn.characters.count\n\
    \                                longestPalindromePrefix = stringToReturnPrefix\n\
    \                                longestPalindromePrefixLength = stringToReturnPrefixReverse.characters.count\n\
    \                                longestPalindromeSuffix = stringToReturnSuffix\n\
    \                                longestPalindromeSuffixLength = stringToReturnSuffixReverse.characters.count\n\
    \                                longestPalindromePrefixReverse = stringToReturnPrefixReverse\n\
    \                                longestPalindromeSuffixReverse = stringToReturnSuffixReverse\n\
    \                                longestPalindromePrefixReverseLength = stringToReturnPrefixReverse.characters.count\n\
    \                                longestPalindromeSuffixReverseLength = stringToReturnSuffixReverse.characters.count\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n\n    if longestPalindro\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpthj6duuw.swift:19:23: error: expected 'in' after for-each pattern\n\
    \    for stringToReturn.count > 0 {\n                      ^\n/tmp/tmpthj6duuw.swift:51:23:\
    \ error: expected '{' after 'if' condition\n    if longestPalindro\n         \
    \             ^\n/tmp/tmpthj6duuw.swift:19:24: error: type 'Int' has no member\
    \ 'count'\n    for stringToReturn.count > 0 {\n                      ~^~~~~\n\
    /tmp/tmpthj6duuw.swift:19:30: error: for-in loop requires 'Bool' to conform to\
    \ 'Sequence'\n    for stringToReturn.count > 0 {\n                      ~~~~~~~^~~\n\
    /tmp/tmpthj6duuw.swift:51:8: error: cannot find 'longestPalindro' in scope\n \
    \   if longestPalindro\n       ^~~~~~~~~~~~~~~\n/tmp/tmpthj6duuw.swift:20:62:\
    \ error: cannot find 'advance' in scope\n        let stringToReturn = stringToReturn.substringToIndex(advance(stringToReturn.startIndex,\
    \ 1))\n                                                             ^~~~~~~\n\
    /tmp/tmpthj6duuw.swift:22:82: error: cannot find 'advance' in scope\n        let\
    \ stringToReturnPrefixReverse = stringToReturnReverse.substringToIndex(advance(stringToReturnReverse.startIndex,\
    \ 1))\n                                                                      \
    \           ^~~~~~~\n/tmp/tmpthj6duuw.swift:23:84: error: cannot find 'advance'\
    \ in scope\n        let stringToReturnSuffixReverse = stringToReturnReverse.substringFromIndex(advance(stringToReturnReverse.startIndex,\
    \ 1))\n                                                                      \
    \             ^~~~~~~\n/tmp/tmpthj6duuw.swift:24:68: error: cannot find 'advance'\
    \ in scope\n        let stringToReturnPrefix = stringToReturn.substringToIndex(advance(stringToReturn.startIndex,\
    \ 1))\n                                                                   ^~~~~~~\n\
    /tmp/tmpthj6duuw.swift:25:70: error: cannot find 'advance' in scope\n        let\
    \ stringToReturnSuffix = stringToReturn.substringFromIndex(advance(stringToReturn.startIndex,\
    \ 1))\n                                                                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.first {\n         \
    \   longestPalindromeLength += 1\n            if longestPalindromeLength > longestPalindrome.characters.count\
    \ {\n                longestPalindrome = stringToReturn\n                longestPalindromeLength\
    \ = longestPalindrome.characters.count\n            }\n        }\n    }\n    longestPalindrome\
    \ = longestPalindrome.replacingOccurrences(of: longestPalindrome.characters.first!,\
    \ with: \"\")\n    longestPalindrome = longestPalindrome.replacingOccurrences(of:\
    \ longestPalindrome.characters.last!, with: \"\")\n    stringToReturn = stringToReturn.replacingOccurrences(of:\
    \ longestPalindrome, with: stringToReturn.characters.first!)\n    stringToReturn\
    \ = stringToReturn.replacingOccurrences(of: longestPalindrome.characters.last!,\
    \ with: stringToReturn.characters.last!)\n    return stringToReturn\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5xdgzrd4.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5xdgzrd4.swift:11:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.first\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5xdgzrd4.swift:13:60: error: 'characters'\
    \ is unavailable: Please use String directly\n            if longestPalindromeLength\
    \ > longestPalindrome.characters.count {\n                                   \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5xdgzrd4.swift:15:61: error: 'characters' is unavailable:\
    \ Please use String directly\n                longestPalindromeLength = longestPalindrome.characters.count\n\
    \                                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5xdgzrd4.swift:19:43: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n    longestPalindrome =\
    \ longestPalindrome.replacingOccurrences(of: longestPalindrome.characters.first!,\
    \ with: \"\")\n                        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5xdgzrd4.swift:20:43: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \    longestPalindrome = longestPalindrome.replacingOccurrences(of: longestPalindrome.characters.last!,\
    \ with: \"\")\n                        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5xdgzrd4.swift:21:37: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \    stringToReturn ="
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        }\n    }\n    for\
    \ char in string {\n        if char == char.lowercased() {\n            result\
    \ += char\n        }\n    }\n    for char in string {\n        if char == char.lowercased()\
    \ {\n            result += char\n        }\n    }\n    for char in string {\n\
    \        if char == char.lowercased() {\n            result += char\n        }\n\
    \    }\n    for char in string {\n        if char == char.lowercased() {\n   \
    \         result += char\n        }\n    }\n    for char in string {\n       \
    \ if char == char.lowercased() {\n            result += char\n        }\n    }\n\
    \    for char in string {\n        if char == char.lowercased() {\n          \
    \  result += char\n        }\n    }\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        }\n    }\n    for\
    \ char in string {\n        if char == char.lowercased() {\n            result\
    \ += char\n        }\n    }\n    for char in string {\n        if char == char.lowercased()\
    \ {\n            result += char\n        }\n    }\n    for char in string {\n\
    \        if char == char.lowercased() {\n            result += char\n        }\n\
    \    }\n    for char in string {\n        if char == char.lowercased() {\n   \
    \         result += char\n        }\n    }\n    for char in string {\n       \
    \ if char == char.lowercased() {\n            result += char\n        }\n    }\n\
    \    for char in string {\n        if char == char.lowercased() {\n          \
    \  result += char\n        }\n    }\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        }\n    }\n    for\
    \ char in string {\n        if char == char.lowercased() {\n            result\
    \ += char\n        }\n    }\n    for char in string {\n        if char == char.lowercased()\
    \ {\n            result += char\n        }\n    }\n    for char in string {\n\
    \        if char == char.lowercased() {\n            result += char\n        }\n\
    \    }\n    for char in string {\n        if char == char.lowercased() {\n   \
    \         result += char\n        }\n    }\n    for char in string {\n       \
    \ if char == char.lowercased() {\n            result += char\n        }\n    }\n\
    \    for char in string {\n        if char == char.lowercased() {\n          \
    \  result += char\n        }\n    }\n    for char in string {\n        if char\
    \ == char.lowercased() {\n            result += char\n        }\n    }\n    for\
    \ char in string {\n        if char\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqay9wg67.swift:121:16: error: expected '{' after 'if' condition\n\
    \        if char\n               ^\n/tmp/tmpqay9wg67.swift:141:56: error: expected\
    \ '}' at end of brace statement\nassert(make_palindrome(string: \"jerry\") ==\
    \ \"jerryrrej\")\n                                                       ^\n/tmp/tmpqay9wg67.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmpqay9wg67.swift:11:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == char.lowercased() {\n           ~~~~ ^  ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqay9wg67.swift:11:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == char.lowercased() {\n                ^\n/tmp/tmpqay9wg67.swift:12:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmpqay9wg67.swift:16:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == char.lowercased() {\n           ~~~~ ^  ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqay9wg67.swift:16:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == char.lowercased() {\n                ^\n/tmp/tmpqay9wg67.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmpqay9wg67.swift:21:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == char.lowercased() {\n           ~~~~ ^  ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqay9wg67.swift:21:17: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if char == char.lowercased() {\n                ^\n/tmp/tmpqay9wg67.swift:22:23:\
    \ error: cannot convert value"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.reversed()\n    var result = \"\
    \"\n    for char in string.characters {\n        if char == reverse {\n      \
    \      result += char\n        } else {\n            result += String(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprl7r1as4.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmprl7r1as4.swift:10:20:\
    \ error: cannot convert value of type 'ReversedCollection<String>' to expected\
    \ argument type 'Character'\n        if char == reverse {\n                  \
    \ ^\n/tmp/tmprl7r1as4.swift:11:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    var longestPalindromeIndex = 0\n\
    \    for index in 0..<string.characters.count {\n        let currentChar = string.characters[index]\n\
    \        let currentCharIsPalindrome = currentChar == stringToReturn[longestPalindromeIndex]\n\
    \        if currentCharIsPalindrome {\n            if longestPalindromeLength\
    \ < index {\n                longestPalindromeLength = index\n               \
    \ longestPalindrome = stringToReturn\n                longestPalindromeIndex =\
    \ index\n            }\n        } else {\n            if longestPalindromeLength\
    \ > index {\n                stringToReturn = stringToReturn.substring(to: longestPalindromeIndex)\n\
    \                stringToReturn = stringToReturn + stringToReturn.substring(from:\
    \ longestPalindromeLength)\n                longestPalindromeLength = 0\n    \
    \            longestPalindrome = \"\"\n                longestPalindromeIndex\
    \ = 0\n            }\n        }\n    }\n    return stringToReturn\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpno6fzgw2.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpno6fzgw2.swift:12:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let currentChar\
    \ = string.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpno6fzgw2.swift:12:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = string.characters[index]\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpno6fzgw2.swift:13:54:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let currentCharIsPalindrome = currentChar\
    \ == stringToReturn[longestPalindromeIndex]\n                                \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpno6fzgw2.swift:22:49:\
    \ error: value of type 'String' has no member 'substring'\n                stringToReturn\
    \ = stringToReturn.substring(to: longestPalindromeIndex)\n                   \
    \              ~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpno6fzgw2.swift:23:66: error:\
    \ value of type 'String' has no member 'substring'\n                stringToReturn\
    \ = stringToReturn + stringToReturn.substring(from: longestPalindromeLength)\n\
    \                                                  ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n\n    for stringIndex\
    \ in 0..<string.characters.count {\n        let stringCharacter = string.characters[stringIndex]\n\
    \        if stringCharacter == stringToReturn.characters.last! {\n           \
    \ longestPalindromeSuffixIndex += 1\n            longestPalindromeSuffixLength\
    \ += 1\n            if longestPalindromeSuffixIndex == longestPalindromeLength\
    \ {\n                longestPalindromeSuffixString = stringToReturn.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeSuffixLength))\n                longestPalindromeSuffixStringReverse\
    \ = stringToReturn.substringWithRange(NSMakeRange(longestPalindromeSuffixIndex,\
    \ longestPalindromeSuffixLength))\n            }\n        } else {\n         \
    \   longestPalindromeIndex += 1\n            longestPalindromeLength += 1\n  \
    \          if longestPalindromeIndex == longestPalindromeLength {\n          \
    \      longestPalindrome = stringToReturn.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeLength))\n            }\n        }\n    }\n\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpgklclaox.swift:17:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringIndex in 0..<string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgklclaox.swift:18:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ stringCharacter = string.characters[stringIndex]\n                         \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgklclaox.swift:18:38: error: 'characters'\
    \ is unavailable: Please use String directly\n        let stringCharacter = string.characters[stringIndex]\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgklclaox.swift:19:46: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringCharacter == stringToReturn.characters.last!\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgklclaox.swift:23:83: error: cannot find\
    \ 'NSMakeRange' in scope\n                longestPalindromeSuffixString = stringToReturn.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeSuffixLength))\n                                          \
    \                                        ^~~~~~~~~~~\n/tmp/tmpgklclaox.swift:23:64:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \       longestPalindromeSuffixString = stringToReturn.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeSuffixLength))\n                                          \
    \      ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpgkl"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    for letter in string {\n        if letter == \" \" {\n            result\
    \ += letter\n            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: 1)] {\n            result += letter\n            continue\n      \
    \  }\n        if letter == string[string.index(letter, offsetBy: -1)] {\n    \
    \        result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -2)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -3)] {\n            result += letter\n            continue\n     \
    \   }\n        if letter == string[string.index(letter, offsetBy: -4)] {\n   \
    \         result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -5)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -6)] {\n            result += letter\n            continue\n     \
    \   }\n        if letter == string[string.index(letter, offsetBy: -7)] {\n   \
    \         result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -8)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -9)] {\n            result += letter\n            continue\n     \
    \   }\n        if letter == string[string.index(letter, offsetBy: -10)] {\n  \
    \          result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -11)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -12)] {\n            result += letter\n            continue\n    \
    \    }\n        if letter == string[string.index(letter, offsetBy: -13)] {\n \
    \           result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -14)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -15)] {\n            result += letter\n            continue\n    \
    \    }\n        if letter == string[string.index(letter, offsetBy: -16)] {\n \
    \           result += letter\n            continue\n        }\n        if letter\
    \ == string[string.index(letter, offsetBy: -17)] {\n            result += letter\n\
    \            continue\n        }\n        if letter == string[string.index(letter,\
    \ offsetBy: -18)] {\n            result += letter\n            continue\n    \
    \    }\n        if letter == string[string.index(letter, offsetBy: -19)] {\n \
    \           result += letter\n            continue\n        }\n        if \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjvx47byd.swift:94:11: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpjvx47byd.swift:114:56: error:\
    \ expected '}' at end of brace statement\nassert(make_palindrome(string: \"jerry\"\
    ) == \"jerryrrej\")\n                                                       ^\n\
    /tmp/tmpjvx47byd.swift:6:48: note: to match this opening '{'\nfunc make_palindrome(string:\
    \ String) -> String {\n                                               ^\n/tmp/tmpjvx47byd.swift:11:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpjvx47byd.swift:14:42:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if letter == string[string.index(letter, offsetBy: 1)] {\n          \
    \                               ^\n/tmp/tmpjvx47byd.swift:15:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += letter\n                      ^\n/tmp/tmpjvx47byd.swift:18:42:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if letter == string[string.index(letter, offsetBy: -1)] {\n         \
    \                                ^\n/tmp/tmpjvx47byd.swift:19:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += letter\n                      ^\n/tmp/tmpjvx47byd.swift:22:42:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if letter == string[string.index(letter, offsetBy: -2)] {\n         \
    \                                ^\n/tmp/tmpjvx47byd.swift:23:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += letter\n                      ^\n/tmp/tmpjvx47byd.swift:26:42:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if letter == string[string.index(letter, offsetBy: -3)] {\n         \
    \                                ^\n/tmp/tmpjvx4"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromeReverse\
    \ = \"\"\n    var longestPalindromeReverseLength = 0\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverse = \"\"\n    var longestPalindromeReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpwcty9s7v.swift:22:9: error: invalid redeclaration of 'longestPalindromePrefixReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:19:9:\
    \ note: 'longestPalindromePrefixReverseReverse' previously declared here\n   \
    \ var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseLength'\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseLength' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverse'\n  \
    \  var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:19:9:\
    \ note: 'longestPalindromePrefixReverseReverse' previously declared here\n   \
    \ var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseLength'\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseLength' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverse'\n  \
    \  var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:19:9:\
    \ note: 'longestPalindromePrefixReverseReverse' previously declared here\n   \
    \ var longestPalindromePrefixReverseReverse = \"\"\n        ^\n/tmp/tmpwcty9s7v.swift:27:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseLength'\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:21:9:\
    \ note: 'longestPalindromePrefixReverseReverseLength' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseLength = 0\n        ^\n/tmp/tmpwcty9s7v.swift:28:9:\
    \ error: invalid "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringLength = 0\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseLength = 0\n    var\
    \ longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n    var longestPalindro\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpr2ef_lp9.swift:22:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseReverseIndex = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:20:9:\
    \ note: 'longestPalindromeSuffixStringReverseReverseIndex' previously declared\
    \ here\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n       \
    \ ^\n/tmp/tmpr2ef_lp9.swift:23:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseIndexLength'\n\
    \    var longestPalindromeSuffixStringReverseReverseIndexLength = 0\n        ^\n\
    /tmp/tmpr2ef_lp9.swift:21:9: note: 'longestPalindromeSuffixStringReverseReverseIndexLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:24:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndex'\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:20:9: note: 'longestPalindromeSuffixStringReverseReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:25:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndexLength'\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:21:9: note: 'longestPalindromeSuffixStringReverseReverseIndexLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndexLength\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:26:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndex'\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:20:9: note: 'longestPalindromeSuffixStringReverseReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseIndex\
    \ = 0\n        ^\n/tmp/tmpr2ef_lp9.swift:27:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseIndexLength'\n    var longestPalindromeSuffixStringReverseReverseIndexL"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverse = \"\"\n    var longestPalindromePrefixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindro\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmplpztp4o0.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:22:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmplpztp4o0.swift:20:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmplpztp4o0.swift:23:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmplpztp4o0.swift:20:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmplpztp4o0.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:19:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmplpztp4o0.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmplpztp4o0.swift:20:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePre"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(longestPalindrome)\n    return longestPalindrome\
    \ + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhbe1vgq.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpvhbe1vgq.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpvhbe1vgq.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(longestPalindrome)\n                 \
    \        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    for character in string {\n        if character == character {\n  \
    \          longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome {\n                longestPalindrome = String(character)\n\
    \            }\n        } else {\n            longestPalindromeLength = 0\n  \
    \      }\n    }\n    var reversedString = \"\"\n    for character in string {\n\
    \        reversedString += String(character)\n    }\n    reversedString = reversedString[longestPalindromeLength..<reversedString.count]\n\
    \    return longestPalindrome + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe5kp0jjk.swift:12:40: error: binary operator '>' cannot be applied\
    \ to operands of type 'Int' and 'String'\n            if longestPalindromeLength\
    \ > longestPalindrome {\n               ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpe5kp0jjk.swift:12:40: note: overloads for '>' exist with these partially\
    \ matching parameter lists: (Int, Int)\n            if longestPalindromeLength\
    \ > longestPalindrome {\n                                       ^\n/tmp/tmpe5kp0jjk.swift:23:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    reversedString = reversedString[longestPalindromeLength..<reversedString.count]\n\
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.last {\n          \
    \  longestPalindrome = stringToReturn\n            longestPalindromeLength = stringToReturn.characters.count\n\
    \            longestPalindromePrefixLength = stringToReturn.characters.prefix(longestPalindromeLength).count\n\
    \            longestPalindromeSuffixLength = stringToReturn.characters.suffix(longestPalindromeLength).count\n\
    \            break\n        }\n    }\n\n    if longestPalindromeLength == 0 {\n\
    \        return \"\"\n    }\n\n    var reversedString = stringToReturn.characters.suffix(longestPalindromeLength).reversed()\n\
    \    reversedString.append(stringToReturn.characters.prefix(longestPalindromePrefixLength))\n\
    \    reversedString.append(longestPalindrome)\n\n    return reversedString.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprofpfzk5.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprofpfzk5.swift:14:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprofpfzk5.swift:16:54: error: 'characters'\
    \ is unavailable: Please use String directly\n            longestPalindromeLength\
    \ = stringToReturn.characters.count\n                                        \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmprofpfzk5.swift:17:60: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestPalindromePrefixLength = stringToReturn.characters.prefix(longestPalindromeLength).count\n\
    \                                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprofpfzk5.swift:18:60: error: 'characters'\
    \ is unavailable: Please use String directly\n            longestPalindromeSuffixLength\
    \ = stringToReturn.characters.suffix(longestPalindromeLength).count\n        \
    \                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprofpfzk5.swift:27:41: error: 'characters'\
    \ is unavailable: Please use String directly\n    var reversedString = stringToReturn.characters.suffix(longestPalindromeLength).reversed()\n\
    \                                        ^~~~~~~~~~\nSwift.String"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringToCheck in string.characters\
    \ {\n        let reversedString = stringToCheck.reversed()\n        if stringToReturn.characters.contains(reversedString)\
    \ {\n            longestPalindrome = stringToCheck\n            longestPalindromeLength\
    \ = stringToCheck.characters.count\n        }\n    }\n    if longestPalindromeLength\
    \ > 0 {\n        stringToReturn = stringToReturn + String(stringToReturn.characters.dropLast(longestPalindromeLength))\n\
    \    }\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpo004nbgl.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpo004nbgl.swift:11:44: error: value of type 'Character'\
    \ has no member 'reversed'\n        let reversedString = stringToCheck.reversed()\n\
    \                             ~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpo004nbgl.swift:13:33:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  longestPalindrome = stringToCheck\n                                ^~~~~~~~~~~~~\n\
    /tmp/tmpo004nbgl.swift:14:53: error: value of type 'Character' has no member 'characters'\n\
    \            longestPalindromeLength = stringToCheck.characters.count\n      \
    \                                ~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpo004nbgl.swift:18:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        stringToReturn\
    \ = stringToReturn + String(stringToReturn.characters.dropLast(longestPalindromeLength))\n\
    \                                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = stringToReturn\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix:\
    \ String = \"\"\n    var longestPalindromeSuffix: String = \"\"\n\n    for _ in\
    \ 0..<string.count {\n        let currentChar = stringToReturn.characters.last!\n\
    \        let currentCharIndex = stringToReturn.index(stringToReturn.startIndex,\
    \ offsetBy: -1)\n        let currentCharReverseIndex = stringToReturn.index(stringToReturn.startIndex,\
    \ offsetBy: -1)\n        let currentCharReverse = stringToReturn[currentCharReverseIndex]\n\
    \n        if currentChar == currentCharReverse {\n            stringToReturn =\
    \ stringToReturn.substring(to: stringToReturn.index(stringToReturn.startIndex,\
    \ offsetBy: -1))\n        } else {\n            if longestPalindromeLength ==\
    \ 0 {\n                longestPalindrome = stringToReturn\n                longestPalindromeLength\
    \ = stringToReturn.characters.count\n                longestPalindromePrefix =\
    \ stringToReturn.prefix(from: longestPalindromeLength)\n                longestPalindromeSuffix\
    \ = stringToReturn.suffix(from: longestPalindromeLength)\n            } else {\n\
    \                let currentLongestPalindromeLength = stringToReturn.characters.count\n\
    \                let currentLongestPalindromePrefix = stringToReturn.prefix(from:\
    \ currentLongestPalindromeLength)\n                let currentLongestPalindromeSuffix\
    \ = stringToReturn.suffix(from: currentLongestPalindromeLength)\n\n          \
    \      if currentLongestPalindromeLength > longestPalindromeLength {\n       \
    \             longestPalindrome = stringToReturn\n                    longestPalindromeLength\
    \ = currentLongestPalindromeLength\n                    longestPalindromePrefix\
    \ = currentLongestPalindromePrefix\n                    longestPalindromeSuffix\
    \ = currentLongestPalindromeSuffix\n                }\n            }\n       \
    \ }\n    }\n\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpsezjsmiy.swift:14:42: error: 'characters' is unavailable: Please\
    \ use String directly\n        let currentChar = stringToReturn.characters.last!\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpsezjsmiy.swift:20:45: error: value of type\
    \ 'String' has no member 'substring'\n            stringToReturn = stringToReturn.substring(to:\
    \ stringToReturn.index(stringToReturn.startIndex, offsetBy: -1))\n           \
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpsezjsmiy.swift:24:58: error:\
    \ 'characters' is unavailable: Please use String directly\n                longestPalindromeLength\
    \ = stringToReturn.characters.count\n                                        \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpsezjsmiy.swift:25:58: error: no exact matches in call to instance\
    \ method 'prefix'\n                longestPalindromePrefix = stringToReturn.prefix(from:\
    \ longestPalindromeLength)\n                                                 \
    \        ^\n/tmp/tmpsezjsmiy.swift:25:58: note: found candidate with type '(Int)\
    \ -> PrefixSequence<String>'\n                longestPalindromePrefix = stringToReturn.prefix(from:\
    \ longestPalindromeLength)\n                                                 \
    \        ^\n/tmp/tmpsezjsmiy.swift:25:58: note: found candidate with type '(Int)\
    \ -> String.SubSequence' (aka '(Int) -> Substring')\n                longestPalindromePrefix\
    \ = stringToReturn.prefix(from: longestPalindromeLength)\n                   \
    \                                      ^\n/tmp/tmpsezjsmiy.swift:25:58: error:\
    \ no 'prefix' candidates produce the expected contextual result type 'String'\n\
    \                longestPalindromePrefix = stringToReturn.prefix(from: longestPalindromeLength)\n\
    \                                                         ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequenc"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReverse = \"\"\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix\
    \ = \"\"\n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePostfix\
    \ = \"\"\n    var longestPalindromePostfixLength = 0\n    var longestPalindromePostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixSuffix = \"\"\n    var longestPalindromePostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixLength = 0\n    var longestPalindromePostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixSuffix = \"\"\n    var longestPalindromePostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixLength = 0\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixSuffix = \"\"\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfix = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPrefix = \"\"\n  \
    \  var longestPalindromePostfixPostfixPostfixPostfixSuffix = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength =\
    \ 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix = \"\"\
    \n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix = \"\"\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix = \"\"\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength = 0\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPrefix = \"\
    \"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixSuffix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfix\
    \ = \"\"\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = 0\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfixPrefix\
    \ = \"\"\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpj7tz03l1.swift:39:9: error: type annotation missing in pattern\n\
    \    var longestP\n        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversedString = string.reversed()\n    let longestPalindrome\
    \ = reversedString.prefix(string.reversed())\n    return longestPalindrome + string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxqxdfmn7.swift:8:44: error: no exact matches in call to instance\
    \ method 'prefix'\n    let longestPalindrome = reversedString.prefix(string.reversed())\n\
    \                                           ^\nSwift.Collection:6:40: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var reversedString = string\n\
    \    var longestPalindrome = string\n    var longestPalindromeLength = longestPalindrome.length\n\
    \    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix = \"\"\
    \n    var longestPalindromePrefixLength = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromePrefixReverse = \"\"\n    var longestPalindromeSuffixReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseLength = 0\n    var longestPalindromeSuffixReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseLength = 0\n    var longestPalindromeSuffixReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverse = \"\"\n    var longestPalindromeSuffixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixReverseReverseReverseLength = 0\n   \
    \ var longestPalindromeSuffixReverseReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverse = \"\"\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseLength = 0\n    var\
    \ longestPalindromeSuffixReverseReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseReverseLength = 0\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseReverse = \"\
    \"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse = \"\"\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseLength = 0\n\
    \    var longestPalindromeSuffixReverseReverseReverseReverseLength = 0\n    var\
    \ longestPalindromePrefixReverseReverseReverseReverseReverseReverse = \"\"\n \
    \   var longestPalindromeSuffixReverseReverseReverseReverseReverse = \"\"\n  \
    \  var longestPalindromePrefixReverseReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixReverseReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse =\
    \ \"\"\n    var longestPalindromePrefixReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseReverseReverseLength = 0\n\
    \    var longestPalindromePrefixReverseReverseReverseReverseReverseReverse = \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\"\
    ) == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpqsijw6lb.swift:10:53: error: value of type 'String' has no member\
    \ 'length'\n    var longestPalindromeLength = longestPalindrome.length\n     \
    \                             ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpqsijw6lb.swift:30:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseReverseLength = 0\n        ^\n/tmp/tmpqsijw6lb.swift:26:9:\
    \ note: 'longestPalindromeSuffixReverseReverseReverseLength' previously declared\
    \ here\n    var longestPalindromeSuffixReverseReverseReverseLength = 0\n     \
    \   ^\n/tmp/tmpqsijw6lb.swift:36:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseReverseReverseReverse'\n\
    \    var longestPalindromeSuffixReverseReverseReverseReverseReverse = \"\"\n \
    \       ^\n/tmp/tmpqsijw6lb.swift:32:9: note: 'longestPalindromeSuffixReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmpqsijw6lb.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixReverseReverseReverseReverseReverseLength'\n    var\
    \ longestPalindromePrefixReverseReverseReverseReverseReverseLength = 0\n     \
    \   ^\n/tmp/tmpqsijw6lb.swift:33:9: note: 'longestPalindromePrefixReverseReverseReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromePrefixReverseReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpqsijw6lb.swift:38:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixReverseReverseReverseReverseLength'\n    var longestPalindromeSuffixReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpqsijw6lb.swift:34:9: note: 'longestPalindromeSuffixReverseReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmpqsijw6lb.swift:39:9: error: invalid redeclaration of\
    \ 'longestPalindromePrefixReverseReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromePrefixReverseReverseReverseReverseReverseReverse = \"\"\n \
    \       ^\n/tmp/tmpqsijw6lb.sw"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringLength = 0\n    var longestPalindromeSuffixStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromeSuffixStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseLength = 0\n\
    \    var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringIndex =\
    \ 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringIndex\
    \ = 0\n    var longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp1p1aijgh.swift:20:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmp1p1aijgh.swift:17:9:\
    \ note: 'longestPalindromeSuffixStringReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmp1p1aijgh.swift:35:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex =\
    \ 0\n        ^\n/tmp/tmp1p1aijgh.swift:32:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmp1p1aijgh.swift:36:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\n   \
    \ var longestPalindromeSuffixStringReverseStringReverseStringReverseString = \"\
    \"\n        ^\n/tmp/tmp1p1aijgh.swift:33:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmp1p1aijgh.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n        ^\n/tmp/tmp1p1aijgh.swift:34:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n        ^\n/tmp/tmp1p1aijgh.swift:40:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n        ^\n/tmp/tmp1p1aijgh.swift:34:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength'\
    \ previou"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverse = \"\"\n    var longestPalindromePrefixReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseLength = 0\n    var longestPalindromePrefixReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverse = \"\"\n    var longestPalindromePrefixReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestPalindromePrefixReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixReverseReverseLength = 0\n    var longestP\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpiqzzgv51.swift:23:9: error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:21:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:24:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpiqzzgv51.swift:22:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpiqzzgv51.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:21:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpiqzzgv51.swift:22:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpiqzzgv51.swift:27:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixReverseReverseLength'\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:21:9:\
    \ note: 'longestPalindromeSuffixReverseReverseLength' previously declared here\n\
    \    var longestPalindromeSuffixReverseReverseLength = 0\n        ^\n/tmp/tmpiqzzgv51.swift:28:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixReverseReverseReverse'\n\
    \    var longestPalindromePrefixReverseReverseReverse = \"\"\n        ^\n/tmp/tmpiqzzgv51.swift:22:9:\
    \ note: 'longestPalindromePrefixReverseReverseReverse' previously declared here\n\
    \    var longestPalindromePre"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringLength\
    \ = 0\n    var longestPalindromeSuffixStringLength = 0\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromePrefixStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseReverseLength = 0\n    var longestPalindromeSuffixStringReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseReverseReverse = \"\"\n   \
    \ var longestPalindromeSuffixStringReverseReverseReverse = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseReverseLength = 0\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverse = \"\"\n  \
    \  var longestPalindromeSuffixStringReverseReverseReverseReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseReverseReverseReverseLength = 0\n    var\
    \ longestPalindromeSuffixStringReverseReverseReverseReverseLength = 0\n    var\
    \ longestPalindromePrefixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \  var longestPalindromeSuffixStringReverseReverseReverseReverseReverse = \"\"\
    \n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseReverseReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n    var longestPalindro\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmplafxr9jc.swift:35:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseReverseReverseLength'\n\
    \    var longestPalindromeSuffixStringReverseReverseReverseReverseLength = 0\n\
    \        ^\n/tmp/tmplafxr9jc.swift:31:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmplafxr9jc.swift:36:9: error: invalid redeclaration of\
    \ 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromePrefixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \      ^\n/tmp/tmplafxr9jc.swift:32:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmplafxr9jc.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\n    var\
    \ longestPalindromeSuffixStringReverseReverseReverseReverseReverse = \"\"\n  \
    \      ^\n/tmp/tmplafxr9jc.swift:33:9: note: 'longestPalindromeSuffixStringReverseReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseReverseReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmplafxr9jc.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseReverseReverseReverseReverseLength'\n\
    \    var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmplafxr9jc.swift:34:9: note: 'longestPalindromePrefixStringReverseReverseReverseReverseReverseLength'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmplafxr9jc.swift:42:9: error: invalid redeclaration of\
    \ 'longestPalindromePrefixStringReverseReverseReverseReverseReverseLength'\n \
    \   var longestPalindromePrefixStringReverseReverseReverseReverseReverseLength\
    \ = 0\n        ^\n/tmp/tmplafxr9jc.swift:34:9: note: 'longestPalindromePrefixStringReverseReverseRe"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    for index in 0..<string.characters.count {\n        let char = string.characters[index]\n\
    \        let reversedChar = String(string.characters.reverse())[index]\n     \
    \   if char == reversedChar {\n            palindrome = palindrome.replacingOccurrences(of:\
    \ char, with: reversedChar)\n            longestPalindrome = palindrome\n    \
    \        longestPalindromeLength = index\n            longestPalindromeIndex =\
    \ index\n        }\n    }\n    if longestPalindromeLength > longestPalindromeIndex\
    \ {\n        palindrome = palindrome.replacingOccurrences(of: longestPalindrome,\
    \ with: longestPalindrome[longestPalindromeLength..<longestPalindromeIndex])\n\
    \    }\n    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp2cbma6jw.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2cbma6jw.swift:12:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = string.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2cbma6jw.swift:12:27:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = string.characters[index]\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2cbma6jw.swift:13:53: error: value of\
    \ type 'String' has no member 'reverse'\n        let reversedChar = String(string.characters.reverse())[index]\n\
    \                                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp2cbma6jw.swift:15:37:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     palindrome = palindrome.replacingOccurrences(of: char, with: reversedChar)\n\
    \                         ~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2cbma6jw.swift:22:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ palindrome = palindrome.replacingOccurrences(of: longestPalindrome, with: longestPalindrome[longestPalindromeLength..<longestPalindromeIndex])\n\
    \                     ~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixChar\
    \ = \"\"\n    var longestPalindromePrefixChar = \"\"\n    var longestPalindromeSuffixCharIndex\
    \ = 0\n    var longestPalindromePrefixCharIndex = 0\n    var longestPalindromeSuffixCharCount\
    \ = 1\n    var longestPalindromePrefixCharCount = 1\n    var longestPalindromeSuffixCharCountIndex\
    \ = 0\n    var longestPalindromePrefixCharCountIndex = 0\n    var longestPalindromeSuffixCharCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCount = 0\n    var longestPalindromeSuffixCharCountCountIndex\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var longestPalindromeSuffixCharCountCountCount\
    \ = 0\n    var longestPalindromePrefixCharCountCountIndex = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbl2cyfdw.swift:50:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpbl2cyfdw.swift:27:9: error: invalid redeclaration of 'longestPalindromePrefixCharCountCountIndex'\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:25:9:\
    \ note: 'longestPalindromePrefixCharCountCountIndex' previously declared here\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:28:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixCharCountCountCount'\n\
    \    var longestPalindromeSuffixCharCountCountCount = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:26:9:\
    \ note: 'longestPalindromeSuffixCharCountCountCount' previously declared here\n\
    \    var longestPalindromeSuffixCharCountCountCount = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:29:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixCharCountCountIndex'\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:25:9:\
    \ note: 'longestPalindromePrefixCharCountCountIndex' previously declared here\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:30:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixCharCountCountCount'\n\
    \    var longestPalindromeSuffixCharCountCountCount = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:26:9:\
    \ note: 'longestPalindromeSuffixCharCountCountCount' previously declared here\n\
    \    var longestPalindromeSuffixCharCountCountCount = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:31:9:\
    \ error: invalid redeclaration of 'longestPalindromePrefixCharCountCountIndex'\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:25:9:\
    \ note: 'longestPalindromePrefixCharCountCountIndex' previously declared here\n\
    \    var longestPalindromePrefixCharCountCountIndex = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:32:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixCharCountCountCount'\n\
    \    var longestPalindromeSuffixCharCountCountCount = 0\n        ^\n/tmp/tmpbl2cyfdw.swift:26:9:\
    \ note: 'longestPalindromeSuffixCharCountCountCount' previously declared h"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromeStart = 0\n  \
    \  var longestPalindromeEnd = 0\n    var longestPalindromePaddedStart = 0\n  \
    \  var longestPalindromePaddedEnd = 0\n    var longestPalindromePaddedLength =\
    \ 0\n    var longestPalindromePaddedStartIndex = 0\n    var longestPalindromePaddedEndIndex\
    \ = 0\n    var longestPalindromePaddedLengthIndex = 0\n    var longestPalindromePaddedStartIndex2\
    \ = 0\n    var longestPalindromePaddedEndIndex2 = 0\n    var longestPalindromePaddedLengthIndex2\
    \ = 0\n    var longestPalindromePaddedStartIndex3 = 0\n    var longestPalindromePaddedEndIndex3\
    \ = 0\n    var longestPalindromePaddedLengthIndex3 = 0\n    var longestPalindromePaddedStartIndex4\
    \ = 0\n    var longestPalindromePaddedEndIndex4 = 0\n    var longestPalindromePaddedLengthIndex4\
    \ = 0\n    var longestPalindromePaddedStartIndex5 = 0\n    var longestPalindromePaddedEndIndex5\
    \ = 0\n    var longestPalindromePaddedLengthIndex5 = 0\n    var longestPalindromePaddedStartIndex6\
    \ = 0\n    var longestPalindromePaddedEndIndex6 = 0\n    var longestPalindromePaddedLengthIndex6\
    \ = 0\n    var longestPalindromePaddedStartIndex7 = 0\n    var longestPalindromePaddedEndIndex7\
    \ = 0\n    var longestPalindromePaddedLengthIndex7 = 0\n    var longestPalindromePaddedStartIndex8\
    \ = 0\n    var longestPalindromePaddedEndIndex8 = 0\n    var longestPalindromePaddedLengthIndex8\
    \ = 0\n    var longestPalindromePaddedStartIndex9 = 0\n    var longestPalindromePaddedEndIndex9\
    \ = 0\n    var longestPalindromePaddedLengthIndex9 = 0\n    var longestPalindromePaddedStartIndex10\
    \ = 0\n    var longestPalindromePaddedEndIndex10 = 0\n    var longestPalindromePaddedLengthIndex10\
    \ = 0\n    var longestPalindromePaddedStartIndex11 = 0\n    var longestPalindromePaddedEndIndex11\
    \ = 0\n    var longestPalindromePaddedLengthIndex11 = 0\n    var longestPalindromePaddedStartIndex12\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpelxnvadi.swift:49:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpelxnvadi.swift:7:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpelxnvadi.swift:8:9: warning:\
    \ initialization of variable 'longestPalindrome' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var longestPalindrome = \"\"\n  \
    \  ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:9:9: warning: initialization\
    \ of variable 'longestPalindromeLength' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var longestPalindromeLength = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpelxnvadi.swift:10:9: warning: initialization of variable 'longestPalindromeStart'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeStart = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:11:9:\
    \ warning: initialization of variable 'longestPalindromeEnd' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var longestPalindromeEnd\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:12:9: warning:\
    \ initialization of variable 'longestPalindromePaddedStart' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var longestPalindromePaddedStart\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:13:9:\
    \ warning: initialization of variable 'longestPalindromePaddedEnd' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var longestPalindromePaddedEnd\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:14:9:\
    \ warning: initialization of variable 'longestPalindromePaddedLength' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var longestPalindromePaddedLength\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpelxnvadi.swift:15:9:\
    \ warning: initialization of variable 'longestPalindromePaddedStartIndex' was\
    \ never us"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n  \
    \  for index in 0..<string.characters.count {\n        let character = string.characters[index]\n\
    \        let reversedCharacter = string.characters.reversed().first(where: { $0\
    \ == character })!\n        if character == reversedCharacter {\n            result\
    \ += character\n            longestPalindrome = result\n            longestPalindromeLength\
    \ = result.characters.count\n            longestPalindromeIndex = index\n    \
    \    }\n    }\n    if longestPalindromeLength > 0 {\n        result = result +\
    \ String(string.characters.reversed().prefix(longestPalindromeLength))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp96569if5.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp96569if5.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp96569if5.swift:12:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp96569if5.swift:13:40:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ reversedCharacter = string.characters.reversed().first(where: { $0 == character\
    \ })!\n                                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp96569if5.swift:15:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += character\n                      ^\n/tmp/tmp96569if5.swift:17:46: error:\
    \ 'characters' is unavailable: Please use String directly\n            longestPalindromeLength\
    \ = result.characters.count\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp96569if5.swift:22:41:\
    \ error: 'characters' is unavailable: Please use String directly\n        result\
    \ = result + String(string.characters.reversed().prefix(longestPalin"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    for character in string {\n     \
    \   if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < len(longestPalindrome) {\n     \
    \           longestPalindromeLength = len(longestPalindrome)\n               \
    \ longestPalindrome = character\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ < len(longestPalindrome) {\n        result += longestPalindrome\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp0djf6oda.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmp0djf6oda.swift:14:42: error: cannot find 'len' in\
    \ scope\n            if longestPalindromeLength < len(longestPalindrome) {\n \
    \                                        ^~~\n/tmp/tmp0djf6oda.swift:15:43: error:\
    \ cannot find 'len' in scope\n                longestPalindromeLength = len(longestPalindrome)\n\
    \                                          ^~~\n/tmp/tmp0djf6oda.swift:16:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = character\n                                    ^~~~~~~~~\n\
    /tmp/tmp0djf6oda.swift:20:34: error: cannot find 'len' in scope\n    if longestPalindromeLength\
    \ < len(longestPalindrome) {\n                                 ^~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversed = \"\"\n    var longestPalindrome = \"\
    \"\n    for character in string {\n        reversed = reversed.appending(character)\n\
    \        if character == string[string.index(before: reversed)] {\n          \
    \  longestPalindrome = reversed\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpczj5ihky.swift:10:29: error: value of type 'String' has no member\
    \ 'appending'\n        reversed = reversed.appending(character)\n            \
    \       ~~~~~~~~ ^~~~~~~~~\n/tmp/tmpczj5ihky.swift:11:53: error: cannot convert\
    \ value of type 'String' to expected argument type 'String.Index'\n        if\
    \ character == string[string.index(before: reversed)] {\n                    \
    \                                ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexInReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverse = 0\n    var longestPalindromeStartIndexInReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var longestPalindromeStartIndexInReverseReverseReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpp75e959u.swift:46:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpp75e959u.swift:18:9: error: invalid redeclaration of 'longestPalindromeStartIndexInReverseReverseReverse'\n\
    \    var longestPalindromeStartIndexInReverseReverseReverse = 0\n        ^\n/tmp/tmpp75e959u.swift:16:9:\
    \ note: 'longestPalindromeStartIndexInReverseReverseReverse' previously declared\
    \ here\n    var longestPalindromeStartIndexInReverseReverseReverse = 0\n     \
    \   ^\n/tmp/tmpp75e959u.swift:19:9: error: invalid redeclaration of 'longestPalindromeEndIndexInReverseReverseReverse'\n\
    \    var longestPalindromeEndIndexInReverseReverseReverse = 0\n        ^\n/tmp/tmpp75e959u.swift:17:9:\
    \ note: 'longestPalindromeEndIndexInReverseReverseReverse' previously declared\
    \ here\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n       \
    \ ^\n/tmp/tmpp75e959u.swift:20:9: error: invalid redeclaration of 'longestPalindromeStartIndexInReverseReverseReverse'\n\
    \    var longestPalindromeStartIndexInReverseReverseReverse = 0\n        ^\n/tmp/tmpp75e959u.swift:16:9:\
    \ note: 'longestPalindromeStartIndexInReverseReverseReverse' previously declared\
    \ here\n    var longestPalindromeStartIndexInReverseReverseReverse = 0\n     \
    \   ^\n/tmp/tmpp75e959u.swift:21:9: error: invalid redeclaration of 'longestPalindromeEndIndexInReverseReverseReverse'\n\
    \    var longestPalindromeEndIndexInReverseReverseReverse = 0\n        ^\n/tmp/tmpp75e959u.swift:17:9:\
    \ note: 'longestPalindromeEndIndexInReverseReverseReverse' previously declared\
    \ here\n    var longestPalindromeEndIndexInReverseReverseReverse = 0\n       \
    \ ^\n/tmp/tmpp75e959u.swift:22:9: error: invalid redeclaration of 'longestPalindromeStartIndexInReverseReverseReverse'\n\
    \    var longestPalindromeStartIndexInReverseReverseReverse = 0\n        ^\n/tmp/tmpp75e959u.swift:16:9:\
    \ note: 'longestPalindromeStartIndexInReverseReverseReverse' previously declared\
    \ here\n    var longestPalindromeStartIndexInReverseReverseReverse = 0\n     \
    \   ^\n/tmp/tmpp75e959u.swift:23:9: error: invalid redeclaration of 'longestPalindromeEndIndexInReverseReverseReverse'\n\
    \    var longestP"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversedString = string\n    var longestPalindrome\
    \ = string\n    var longestPalindromeLength = 0\n    for _ in 0..<string.characters.count\
    \ {\n        let index = string.index(string.startIndex, offsetBy: longestPalindromeLength)\n\
    \        let char = string.substring(with: index).first!\n        let reversedChar\
    \ = reversedString.substring(with: reversedString.index(before: reversedString.endIndex).reversed())\n\
    \        if char == reversedChar {\n            longestPalindromeLength += 1\n\
    \        } else {\n            longestPalindromeLength = 0\n        }\n      \
    \  if longestPalindromeLength > longestPalindrome.characters.count {\n       \
    \     longestPalindrome = string\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpa6k78red.swift:10:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpa6k78red.swift:12:27: error: value of type 'String' has no member\
    \ 'substring'\n        let char = string.substring(with: index).first!\n     \
    \              ~~~~~~ ^~~~~~~~~\n/tmp/tmpa6k78red.swift:13:43: error: value of\
    \ type 'String' has no member 'substring'\n        let reversedChar = reversedString.substring(with:\
    \ reversedString.index(before: reversedString.endIndex).reversed())\n        \
    \                   ~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpa6k78red.swift:13:113: error:\
    \ value of type 'String.Index' has no member 'reversed'\n        let reversedChar\
    \ = reversedString.substring(with: reversedString.index(before: reversedString.endIndex).reversed())\n\
    \                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpa6k78red.swift:19:56: error: 'characters' is unavailable:\
    \ Please use String directly\n        if longestPalindromeLength > longestPalindrome.characters.count\
    \ {\n                                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = string\n    var longestPalindromeSuffix:\
    \ String = string\n\n    for _ in 0..<string.count {\n        let currentChar\
    \ = string[string.startIndex]\n        let currentCharLength = string.distance(from:\
    \ string.startIndex, to: string.endIndex) - 1\n\n        if currentCharLength\
    \ > longestPalindromeLength {\n            longestPalindrome = string\n      \
    \      longestPalindromeLength = currentCharLength\n            longestPalindromePrefix\
    \ = string\n            longestPalindromeSuffix = string\n        }\n\n      \
    \  if currentCharLength == longestPalindromeLength {\n            longestPalindromeSuffix\
    \ += currentChar\n        }\n\n        if currentCharLength < longestPalindromeLength\
    \ {\n            longestPalindromePrefix = string\n            longestPalindromeSuffix\
    \ = string\n        }\n    }\n\n    return longestPalindromePrefix + longestPalindromeSuffix\
    \ + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpp10vlq2g.swift:24:40: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            longestPalindromeSuffix += currentChar\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix = \"\"\n    var longestPalindromeSuffix\
    \ = \"\"\n    for letter in string {\n        if letter == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            if\
    \ longestPalindromeLength > 0 {\n                longestPalindrome = longestPalindromePrefix\
    \ + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \                longestPalindromePrefix = \"\"\n                longestPalindromeSuffix\
    \ = \"\"\n                longestPalindromeLength = 0\n            }\n       \
    \     longestPalindrome = longestPalindromePrefix + letter\n            longestPalindromeLength\
    \ += 1\n        }\n    }\n    if longestPalindromeLength > 0 {\n        longestPalindrome\
    \ = longestPalindromePrefix + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplqy5idbg.swift:12:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if letter\
    \ == longestPalindrome[longestPalindromeLength] {\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplqy5idbg.swift:16:63:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n                longestPalindrome\
    \ = longestPalindromePrefix + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmplqy5idbg.swift:21:59: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       longestPalindrome = longestPalindromePrefix + letter\n               \
    \                                           ^\n/tmp/tmplqy5idbg.swift:26:55: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        longestPalindrome = longestPalindromePrefix\
    \ + longestPalindrome[longestPalindromeLength..<longestPalindromeLength].reversed()\n\
    \                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.reversed()\n    let prefix = string.prefix(string.reversed())\n\
    \    return prefix + reverse\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpycs1xx2b.swift:8:25: error: no exact matches in call to instance\
    \ method 'prefix'\n    let prefix = string.prefix(string.reversed())\n       \
    \                 ^\nSwift.Sequence:7:40: note: candidate expects value of type\
    \ 'Int' for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let maxLen = string.characters.count\n    let longestPalindrome\
    \ = make_palindrome_helper(string: string, maxLen: maxLen)\n    let reversedLongestPalindrome\
    \ = reverseString(longestPalindrome)\n    return reversedLongestPalindrome + longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7c4rvqpk.swift:7:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLen = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7c4rvqpk.swift:8:29: error: cannot find 'make_palindrome_helper' in scope\n\
    \    let longestPalindrome = make_palindrome_helper(string: string, maxLen: maxLen)\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7c4rvqpk.swift:9:37:\
    \ error: cannot find 'reverseString' in scope\n    let reversedLongestPalindrome\
    \ = reverseString(longestPalindrome)\n                                    ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringIndex in 0..<string.count\
    \ {\n        let stringToCheck = string[stringIndex]\n        let stringToCheckLength\
    \ = stringToCheck.characters.count\n        if stringToCheckLength > longestPalindromeLength\
    \ {\n            longestPalindrome = stringToCheck\n            longestPalindromeLength\
    \ = stringToCheckLength\n        }\n    }\n    let reversedString = stringToReturn.replacingOccurrences(of:\
    \ longestPalindrome, with: longestPalindrome.reversed())\n    return reversedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxvbs5j9v.swift:11:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let stringToCheck\
    \ = string[stringIndex]\n                            ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxvbs5j9v.swift:12:49:\
    \ error: value of type 'Character' has no member 'characters'\n        let stringToCheckLength\
    \ = stringToCheck.characters.count\n                                  ~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpxvbs5j9v.swift:14:33: error: cannot assign value of type\
    \ 'Character' to type 'String'\n            longestPalindrome = stringToCheck\n\
    \                                ^~~~~~~~~~~~~\n/tmp/tmpxvbs5j9v.swift:18:41:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    let\
    \ reversedString = stringToReturn.replacingOccurrences(of: longestPalindrome,\
    \ with: longestPalindrome.reversed())\n                         ~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reverse = \"\"\n    var longest = \"\"\n    for\
    \ char in string {\n        reverse = reverse.chars(using: String.Encoding.utf8).reversed().joined()\n\
    \        if char == reverse {\n            longest = char + reverse\n        }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpigq7csvz.swift:10:27: error: value of type 'String' has no member\
    \ 'chars'\n        reverse = reverse.chars(using: String.Encoding.utf8).reversed().joined()\n\
    \                  ~~~~~~~ ^~~~~\n/tmp/tmpigq7csvz.swift:10:47: error: type 'String'\
    \ has no member 'Encoding'\n        reverse = reverse.chars(using: String.Encoding.utf8).reversed().joined()\n\
    \                                       ~~~~~~ ^~~~~~~~\n/tmp/tmpigq7csvz.swift:11:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == reverse {\n           ~~~~ ^  ~~~~~~~\n/tmp/tmpigq7csvz.swift:11:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == reverse {\n   \
    \             ^\n/tmp/tmpigq7csvz.swift:12:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            longest = char\
    \ + reverse\n                      ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            if longestPalindromeLength < character.count {\n            \
    \    longestPalindrome = character\n                longestPalindromeLength =\
    \ character.count\n            }\n        }\n    }\n    for character in string\
    \ {\n        if character == character {\n            result += character\n  \
    \      } else {\n            if longestPalindromeLength < character.count {\n\
    \                longestPalindrome = character\n                longestPalindromeLength\
    \ = character.count\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ > 0 {\n        result = result + longestPalindrome.repeat(longestPalindromeLength)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpbbea5kih.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpbbea5kih.swift:14:52: error: value of type 'Character'\
    \ has no member 'count'\n            if longestPalindromeLength < character.count\
    \ {\n                                         ~~~~~~~~~ ^~~~~\n/tmp/tmpbbea5kih.swift:15:37:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      longestPalindrome = character\n                                    ^~~~~~~~~\n\
    /tmp/tmpbbea5kih.swift:16:53: error: value of type 'Character' has no member 'count'\n\
    \                longestPalindromeLength = character.count\n                 \
    \                         ~~~~~~~~~ ^~~~~\n/tmp/tmpbbea5kih.swift:22:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n/tmp/tmpbbea5kih.swift:24:52:\
    \ error: value of type 'Character' has no member 'count'\n            if longestPalindromeLength\
    \ < character.count {\n                                         ~~~~~~~~~ ^~~~~\n\
    /tmp/tmpbbea5kih.swift:25:37: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                longestPalindrome = character\n             \
    \                       ^~~~~~~~~\n/tmp/tmpbbea5kih.swift:26:53: error: value\
    \ of type 'Character' has no member 'count'\n                longestPalindromeLength\
    \ = character.count\n                                          ~~~~~~~~~ ^~~~~\n\
    /tmp/tmpbbea5kih.swift:31:45: error: value of type 'String' has no member 'repeat'\n\
    \        result = result + longestPalindrome.repeat(longestPalindromeLength)\n\
    \                          ~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    for stringIndex in 0..<string.count {\n        let stringChar = string[stringIndex]\n\
    \        let stringCharIsPalindrome = stringChar == string.reversed()\n      \
    \  if stringCharIsPalindrome {\n            if longestPalindromeLength < stringChar.count\
    \ {\n                longestPalindrome = stringToReturn\n                longestPalindromeLength\
    \ = stringChar.count\n                longestPalindromeIndex = stringIndex\n \
    \           }\n        }\n        stringToReturn = stringToReturn + stringChar\n\
    \    }\n    return stringToReturn[longestPalindromeIndex..<longestPalindromeIndex+longestPalindromeLength]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2au9pjkp.swift:12:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let stringChar\
    \ = string[stringIndex]\n                         ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2au9pjkp.swift:13:49:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and '[String.Element]' (aka 'Array<Character>')\n        let stringCharIsPalindrome\
    \ = stringChar == string.reversed()\n                                     ~~~~~~~~~~\
    \ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmp2au9pjkp.swift:13:49: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Character, Character)\n\
    \        let stringCharIsPalindrome = stringChar == string.reversed()\n      \
    \                                          ^\n/tmp/tmp2au9pjkp.swift:15:53: error:\
    \ value of type 'Character' has no member 'count'\n            if longestPalindromeLength\
    \ < stringChar.count {\n                                         ~~~~~~~~~~ ^~~~~\n\
    /tmp/tmp2au9pjkp.swift:17:54: error: value of type 'Character' has no member 'count'\n\
    \                longestPalindromeLength = stringChar.count\n                \
    \                          ~~~~~~~~~~ ^~~~~\n/tmp/tmp2au9pjkp.swift:21:43: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        stringToReturn = stringToReturn + stringChar\n                      \
    \                    ^\n/tmp/tmp2au9pjkp.swift:23:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    return stringToReturn[longestPalindromeIndex..<longestPalindromeIndex+longestPalindromeLength]\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        }\n  \
    \      if character == string[string.index(before: character)] {\n           \
    \ result += string[string.index(before: character)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 0)] {\n            result +=\
    \ string[string.index(before: character, after: 0)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 1)] {\n            result +=\
    \ string[string.index(before: character, after: 1)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 2)] {\n            result +=\
    \ string[string.index(before: character, after: 2)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 3)] {\n            result +=\
    \ string[string.index(before: character, after: 3)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 4)] {\n            result +=\
    \ string[string.index(before: character, after: 4)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 5)] {\n            result +=\
    \ string[string.index(before: character, after: 5)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 6)] {\n            result +=\
    \ string[string.index(before: character, after: 6)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 7)] {\n            result +=\
    \ string[string.index(before: character, after: 7)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 8)] {\n            result +=\
    \ string[string.index(before: character, after: 8)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 9)] {\n            result +=\
    \ string[string.index(before: character, after: 9)]\n        }\n        if character\
    \ == string[string.index(before: character, after: 10)] {\n            result\
    \ += string[string.index(before: character, after: 10)]\n        }\n        if\
    \ character == string[string.index(before: character, after: 11)] {\n        \
    \    result += string[string.index(before: character, after: 11)]\n        }\n\
    \        if character == string[string.index(before: character, after: 12)] {\n\
    \            result += string[string.index(before: character, after: 12)]\n  \
    \      }\n        if character == string[string.index(before: character, after:\
    \ 13)] {\n            result += string[string.\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpcje3pp07.swift:57:36: error: expected member name following '.'\n\
    \            result += string[string.\n                                   ^\n\
    /tmp/tmpcje3pp07.swift:58:1: error: expected ']' in expression list\n}\n^\n/tmp/tmpcje3pp07.swift:57:29:\
    \ note: to match this opening '['\n            result += string[string.\n    \
    \                        ^\n/tmp/tmpcje3pp07.swift:77:56: error: expected '}'\
    \ at end of brace statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )\n                                                       ^\n/tmp/tmpcje3pp07.swift:10:29:\
    \ note: to match this opening '{'\n    for character in string {\n           \
    \                 ^\n/tmp/tmpcje3pp07.swift:77:56: error: expected '}' at end\
    \ of brace statement\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )\n                                                       ^\n/tmp/tmpcje3pp07.swift:6:48:\
    \ note: to match this opening '{'\nfunc make_palindrome(string: String) -> String\
    \ {\n                                               ^\n/tmp/tmpcje3pp07.swift:12:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += character\n                      ^\n/tmp/tmpcje3pp07.swift:14:53:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        if character == string[string.index(before: character)] {\n         \
    \                                           ^\n/tmp/tmpcje3pp07.swift:15:29: error:\
    \ subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \            result += string[string.index(before: character)]\n             \
    \               ^\nSwift.Collection:2:23: note: where 'R' = 'String.Index'\n \
    \   @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\n/tmp/tmpcje3pp07.swift:15:51:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \            result += string[string.index(before: character)]\n             \
    \                             "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.last {\n          \
    \  longestPalindrome = stringToReturn\n            longestPalindromeLength = stringToCheck\n\
    \        } else {\n            var stringToCheckReversed = stringToCheck.reversed()\n\
    \            if stringToCheck == stringToCheckReversed {\n                stringToReturn\
    \ = stringToReturn + stringToCheck\n                longestPalindrome = stringToReturn\n\
    \                longestPalindromeLength = stringToCheck\n            }\n    \
    \    }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9x31ggy4.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9x31ggy4.swift:11:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9x31ggy4.swift:13:39: error: cannot assign\
    \ value of type 'Character' to type 'Int'\n            longestPalindromeLength\
    \ = stringToCheck\n                                      ^~~~~~~~~~~~~\n/tmp/tmp9x31ggy4.swift:15:55:\
    \ error: value of type 'Character' has no member 'reversed'\n            var stringToCheckReversed\
    \ = stringToCheck.reversed()\n                                        ~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmp9x31ggy4.swift:17:51: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                stringToReturn\
    \ = stringToReturn + stringToCheck\n                                         \
    \         ^\n/tmp/tmp9x31ggy4.swift:19:43: error: cannot assign value of type\
    \ 'Character' to type 'Int'\n                longestPalindromeLength = stringToCheck\n\
    \                                          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex = 0\n\
    \    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexInString\
    \ = 0\n    var longestPalindromeEndIndexInString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n    var longestPalindromeStartIndexInReversedString\
    \ = 0\n    var longestPalindromeEndIndexInReversedString = 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp61yl1jif.swift:16:9: error: invalid redeclaration of 'longestPalindromeStartIndexInReversedString'\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:14:9:\
    \ note: 'longestPalindromeStartIndexInReversedString' previously declared here\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:17:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexInReversedString'\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:15:9:\
    \ note: 'longestPalindromeEndIndexInReversedString' previously declared here\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:18:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexInReversedString'\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:14:9:\
    \ note: 'longestPalindromeStartIndexInReversedString' previously declared here\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:19:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexInReversedString'\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:15:9:\
    \ note: 'longestPalindromeEndIndexInReversedString' previously declared here\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:20:9:\
    \ error: invalid redeclaration of 'longestPalindromeStartIndexInReversedString'\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:14:9:\
    \ note: 'longestPalindromeStartIndexInReversedString' previously declared here\n\
    \    var longestPalindromeStartIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:21:9:\
    \ error: invalid redeclaration of 'longestPalindromeEndIndexInReversedString'\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/tmp/tmp61yl1jif.swift:15:9:\
    \ note: 'longestPalindromeEndIndexInReversedString' previously declared here\n\
    \    var longestPalindromeEndIndexInReversedString = 0\n        ^\n/t"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n\n    for character in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n\n    for character in string {\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n            longestPalindromePrefix\
    \ = longestPalindromePrefix + character\n        } else {\n            longestPalindromeSuffix\
    \ = longestPalindromeSuffix + character\n        }\n    }\n\n    return longestPalindromePrefix\
    \ + longestPalindromeSuffix + longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ + longestPalindromePrefix.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbvcjqcq3.swift:13:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbvcjqcq3.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbvcjqcq3.swift:22:65:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindromePrefix = longestPalindromePrefix + character\n \
    \                                                               ^\n/tmp/tmpbvcjqcq3.swift:24:65:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindromeSuffix = longestPalindromeSuffix + character\n \
    \                                                               ^\n/tmp/tmpbvcjqcq3.swift:28:64:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    return longestPalindromePrefix\
    \ + longestPalindromeSuffix + longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ + longestPalindromePrefix.count]\n                                         \
    \                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    for stringToCheck in string.characters\
    \ {\n        if stringToCheck == stringToReturn.characters.last {\n          \
    \  longestPalindromeLength += 1\n            longestPalindrome = stringToReturn\n\
    \        } else {\n            if longestPalindromeLength > longestPalindrome.characters.last\
    \ {\n                longestPalindromeLength += 1\n                longestPalindrome\
    \ = stringToReturn\n            }\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpffauxa6_.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpffauxa6_.swift:11:44: error: 'characters' is unavailable:\
    \ Please use String directly\n        if stringToCheck == stringToReturn.characters.last\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpffauxa6_.swift:15:40: error: type '((String.Element)\
    \ throws -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool)\
    \ throws -> Optional<Character>') cannot conform to 'BinaryInteger'\n        \
    \    if longestPalindromeLength > longestPalindrome.characters.last {\n      \
    \                                 ^\n/tmp/tmpffauxa6_.swift:15:40: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \            if longestPalindromeLength > longestPalindrome.characters.last {\n\
    \                                       ^\n/tmp/tmpffauxa6_.swift:15:40: note:\
    \ required by operator function '>' where 'Other' = '((String.Element) throws\
    \ -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool) throws\
    \ -> Optional<Character>')\n            if longestPalindromeLength > longestPalindrome.characters.last\
    \ {\n                                       ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n    for character in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindromePrefix = string\n            longestPalindromeSuffix\
    \ = string\n        }\n    }\n    for character in string {\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n            longestPalindromeLength\
    \ += 1\n        } else {\n            longestPalindromeLength = 0\n        }\n\
    \        if longestPalindromeLength > longestPalindromeLength {\n            longestPalindromePrefix\
    \ = string\n            longestPalindromeSuffix = string\n        }\n    }\n \
    \   return longestPalindromePrefix + longestPalindromeSuffix + longestPalindrome[longestPalindromeLength]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp78wei8rc.swift:12:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp78wei8rc.swift:23:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp78wei8rc.swift:33:81:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \    return longestPalindromePrefix + longestPalindromeSuffix + longestPalindrome[longestPalindromeLength]\n\
    \                                                                            \
    \    ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    for character in string {\n\
    \        if character == character[longestPalindromeLength] {\n            longestPalindromeLength\
    \ += 1\n        } else {\n            if longestPalindromeLength > 0 {\n     \
    \           stringToReturn = stringToReturn + String(character[longestPalindromeLength\
    \ - 1])\n            }\n            longestPalindrome = String(character)\n  \
    \          longestPalindromeLength = 1\n        }\n    }\n    if longestPalindromeLength\
    \ > 0 {\n        stringToReturn = stringToReturn + String(character[longestPalindromeLength\
    \ - 1])\n    }\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp14gezrk9.swift:11:34: error: value of type 'Character' has no subscripts\n\
    \        if character == character[longestPalindromeLength] {\n              \
    \          ~~~~~~~~~^\n/tmp/tmp14gezrk9.swift:15:67: error: value of type 'Character'\
    \ has no subscripts\n                stringToReturn = stringToReturn + String(character[longestPalindromeLength\
    \ - 1])\n                                                         ~~~~~~~~~^\n\
    /tmp/tmp14gezrk9.swift:22:50: error: cannot find 'character' in scope\n      \
    \  stringToReturn = stringToReturn + String(character[longestPalindromeLength\
    \ - 1])\n                                                 ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = longestPalindrome.characters.count\n    var longestPalindromePrefix = \"\"\
    \n    var longestPalindromeSuffix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    for character in string\
    \ {\n        if character == longestPalindrome[longestPalindromeLength] {\n  \
    \          longestPalindromeLength += 1\n        } else {\n            if longestPalindromeLength\
    \ > longestPalindromePrefixLength {\n                longestPalindromePrefix =\
    \ String(longestPalindromePrefix)\n                longestPalindromePrefixLength\
    \ = longestPalindromeLength\n            }\n            longestPalindrome = String(longestPalindrome)\n\
    \            longestPalindromeLength = longestPalindrome.characters.count\n  \
    \          longestPalindrome = String(longestPalindrome)\n            longestPalindromeLength\
    \ = 0\n            longestPalindromePrefix = String(character)\n            longestPalindromePrefixLength\
    \ = 1\n        }\n    }\n    if longestPalindromeLength > longestPalindromeSuffixLength\
    \ {\n        longestPalindromeSuffix = String(longestPalindromeSuffix)\n     \
    \   longestPalindromeSuffixLength = longestPalindromeLength\n    }\n    return\
    \ longestPalindromePrefix + String(longestPalindrome[longestPalindromePrefixLength..<longestPalindromeSuffixLength])\
    \ + longestPalindromeSuffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpxxnggb04.swift:8:53: error: 'characters' is unavailable: Please\
    \ use String directly\n    var longestPalindromeLength = longestPalindrome.characters.count\n\
    \                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxxnggb04.swift:14:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if character == longestPalindrome[longestPalindromeLength] {\n      \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxxnggb04.swift:22:57:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ longestPalindromeLength = longestPalindrome.characters.count\n             \
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpxxnggb04.swift:33:45: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    return longestPalindromePrefix + String(longestPalindrome[longestPalindromePrefixLength..<longestPalindromeSuffixLength])\
    \ + longestPalindromeSuffix\n                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToPalindrome = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringLength = 0\n    var longestPalindromeSuffixStringIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromeSuffixStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseLength = 0\n\
    \    var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringIndex =\
    \ 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverse =\
    \ \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringLength\
    \ = 0\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0ux7g7q.swift:20:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmpc0ux7g7q.swift:17:9:\
    \ note: 'longestPalindromeSuffixStringReverseIndex' previously declared here\n\
    \    var longestPalindromeSuffixStringReverseIndex = 0\n        ^\n/tmp/tmpc0ux7g7q.swift:35:9:\
    \ error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex =\
    \ 0\n        ^\n/tmp/tmpc0ux7g7q.swift:32:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmpc0ux7g7q.swift:41:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmpc0ux7g7q.swift:38:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmpc0ux7g7q.swift:42:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpc0ux7g7q.swift:39:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpc0ux7g7q.swift:43:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringLength'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringLength\
    \ = 0\n        ^\n/tmp/tmpc0ux7g7q."
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            result += character\n        } else\
    \ {\n            longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.length {\n                longestPalindrome = result\n \
    \           }\n            result = \"\"\n        }\n    }\n    if longestPalindromeLength\
    \ > longestPalindrome.length {\n        longestPalindrome = result\n    }\n  \
    \  return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpljyblhyc.swift:12:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpljyblhyc.swift:15:60: error: value of type 'String'\
    \ has no member 'length'\n            if longestPalindromeLength > longestPalindrome.length\
    \ {\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpljyblhyc.swift:21:52:\
    \ error: value of type 'String' has no member 'length'\n    if longestPalindromeLength\
    \ > longestPalindrome.length {\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePostfixLength\
    \ = 0\n    var longestPalindromePostfix = \"\"\n    var longestPalindromePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReverseLength = 0\n    var longestPalindromePostfixReversePrefix\
    \ = \"\"\n    var longestPalindromePostfixReverseSuffixLength = 0\n    var longestPalindromePostfixReverseSuffix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfix = \"\"\n    var longestPalindromePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReverse = \"\"\n    var longestPalindromePostfixReversePostfixReverseLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePrefix = \"\"\n  \
    \  var longestPalindromePostfixReversePostfixReverseSuffixLength = 0\n    var\
    \ longestPalindromePostfixReversePostfixReverseSuffix = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixLength =\
    \ 0\n    var longestPalindromePostfixReversePostfixReversePostfixReverse = \"\"\
    \n    var longestPalindromePostfixReversePostfixReversePostfixReverseLength =\
    \ 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePrefix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReverseSuffixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReverseSuffix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfix\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpyb3pmcoe.swift:36:9: error: invalid redeclaration of 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength'\n\
    \    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n        ^\n/tmp/tmpyb3pmcoe.swift:34:9: note: 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength'\
    \ previously declared here\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n        ^\n/tmp/tmpyb3pmcoe.swift:37:9: error: invalid redeclaration of\
    \ 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse'\n\
    \    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n        ^\n/tmp/tmpyb3pmcoe.swift:35:9: note: 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse'\
    \ previously declared here\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n        ^\n/tmp/tmpyb3pmcoe.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength'\n\
    \    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n        ^\n/tmp/tmpyb3pmcoe.swift:34:9: note: 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength'\
    \ previously declared here\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixLength\
    \ = 0\n        ^\n/tmp/tmpyb3pmcoe.swift:39:9: error: invalid redeclaration of\
    \ 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse'\n\
    \    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n        ^\n/tmp/tmpyb3pmcoe.swift:35:9: note: 'longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse'\
    \ previously declared here\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfixReverse\
    \ = \"\"\n        ^\n/tmp/tmpyb3pmcoe.swift:40:9: error: type annotation missing\
    \ in pattern\n    var longestPalindromePostfixReversePostfixReversePostfixReversePostfix\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromePrefixStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromePrefixStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromePrefixStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseString = \"\"\n    var longestPalindromePrefixStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverse = \"\"\n \
    \   var longestPalindromePrefixStringReverseStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromePrefixStringReverseStringReverseString = \"\"\n\
    \    var longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseStringReverse = \"\"\n    var\
    \ longestPalindromePrefixStringReverseStringReverseStringReverseLength = 0\n \
    \   var longestPalindromeSuffixStringReverseStringReverseStringReverseLength =\
    \ 0\n    var longestPalindromePrefixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpi9yk502_.swift:33:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:31:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:34:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:32:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:35:9: note: 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:38:9: error: invalid redeclaration\
    \ of 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString'\n\
    \    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:36:9: note: 'longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString'\
    \ previously declared here\n    var longestPalindromePrefixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n        ^\n/tmp/tmpi9yk502_.swift:39:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse'\n\
    \    var longe"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringIndex = 0\n    var longestPalindromeSuffixStringLength\
    \ = 0\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromeSuffixStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseIndex = 0\n    var\
    \ longestPalindromeSuffixStringReverseReverseLength = 0\n    var longestPalindromeSuffixStringReverseReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringIndex = 0\n\
    \    var longestPalindromeSuffixStringReverseReverseStringLength = 0\n    var\
    \ longestPalindromeSuffixStringReverseReverseStringReverse = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseReverseReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8c_bpklv.swift:37:9: error: invalid redeclaration of 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength'\n\
    \    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:34:9: note: 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:38:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse'\n\
    \    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmp8c_bpklv.swift:35:9: note: 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseReverse\
    \ = \"\"\n        ^\n/tmp/tmp8c_bpklv.swift:40:9: error: invalid redeclaration\
    \ of 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength'\n\
    \    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:34:9: note: 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:42:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex'\n\
    \    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:39:9: note: 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex'\
    \ previously declared here\n    var longestPalindromeSuffixStringReverseReverseStringReverseStringReverseIndex\
    \ = 0\n        ^\n/tmp/tmp8c_bpklv.swift:43:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStringReverseReverseStringReverseStringReverseLength'\n\
    \    var longest"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversedString = string.reversed()\n    let longestPalindrome\
    \ = longestPalindromeFrom(string: reversedString)\n    let longestPalindromeWithPrefix\
    \ = longestPalindromeWithPrefix(string: reversedString, prefix: string)\n    return\
    \ longestPalindromeWithPrefix + longestPalindrome\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6esqqzs1.swift:8:29: error: cannot find 'longestPalindromeFrom'\
    \ in scope\n    let longestPalindrome = longestPalindromeFrom(string: reversedString)\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6esqqzs1.swift:9:39:\
    \ error: use of local variable 'longestPalindromeWithPrefix' before its declaration\n\
    \    let longestPalindromeWithPrefix = longestPalindromeWithPrefix(string: reversedString,\
    \ prefix: string)\n                                      ^\n/tmp/tmp6esqqzs1.swift:9:9:\
    \ note: 'longestPalindromeWithPrefix' declared here\n    let longestPalindromeWithPrefix\
    \ = longestPalindromeWithPrefix(string: reversedString, prefix: string)\n    \
    \    ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromeStart = 0\n    for start in 0..<string.count {\n\
    \        let end = string.index(start, offsetBy: longestPalindromeLength, limitedBy:\
    \ string.endIndex) ?? string.endIndex\n        let substring = string[start..<end]\n\
    \        let reversedSubstring = substring.reversed()\n        if substring ==\
    \ reversedSubstring {\n            longestPalindromeLength += 1\n            if\
    \ longestPalindromeLength > longestPalindromeStart {\n                longestPalindromeStart\
    \ = longestPalindromeLength\n                longestPalindrome = substring\n \
    \           }\n        } else {\n            longestPalindromeLength = 0\n   \
    \         longestPalindromeStart = 0\n        }\n    }\n    return longestPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7i_atsl_.swift:11:32: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let end = string.index(start,\
    \ offsetBy: longestPalindromeLength, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedLongestPalindrome = reverseString(longestPalindrome)\n    return\
    \ reversedLongestPalindrome + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0qik1bo0.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmp0qik1bo0.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmp0qik1bo0.swift:8:37: error: cannot find 'reverseString' in scope\n\
    \    let reversedLongestPalindrome = reverseString(longestPalindrome)\n      \
    \                              ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindromePrefix: String = \"\"\n    var longestPalindromeSuffix:\
    \ String = \"\"\n    var longestPalindromeSuffixLength = 0\n\n    for character\
    \ in string {\n        if character == longestPalindrome[longestPalindromeLength]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n        if longestPalindromeLength > longestPalindromeSuffixLength\
    \ {\n            longestPalindromePrefix = String(longestPalindrome[longestPalindromeLength\
    \ - longestPalindromeSuffixLength..<longestPalindromeLength])\n            longestPalindromeSuffix\
    \ = String(longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ - longestPalindromeSuffixLength])\n            longestPalindromeSuffixLength\
    \ = longestPalindromeLength\n        }\n    }\n\n    return longestPalindromePrefix\
    \ + longestPalindromeSuffix[longestPalindromeSuffixLength..<longestPalindromeSuffixLength\
    \ + longestPalindromeLength]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpxr2cb0ct.swift:14:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == longestPalindrome[longestPalindromeLength] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxr2cb0ct.swift:20:46:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            longestPalindromePrefix\
    \ = String(longestPalindrome[longestPalindromeLength - longestPalindromeSuffixLength..<longestPalindromeLength])\n\
    \                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpxr2cb0ct.swift:21:46: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n            longestPalindromeSuffix = String(longestPalindrome[longestPalindromeLength..<longestPalindromeLength\
    \ - longestPalindromeSuffixLength])\n                                        \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpxr2cb0ct.swift:26:38: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    return longestPalindromePrefix + longestPalindromeSuffix[longestPalindromeSuffixLength..<longestPalindromeSuffixLength\
    \ + longestPalindromeLength]\n                                     ^~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexInReverse\
    \ = 0\n    var longestPalindromeEndIndexInReverse = 0\n    var longestPalindromeStartIndexInReverseString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseString = \"\"\n    var longestPalindromeStartIndexInReverseStringLength\
    \ = 0\n    var longestPalindromeEndIndexInReverseStringLength = 0\n    var longestPalindromeStartIndexInReverseStringLengthString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseStringLengthString = \"\"\n\
    \    var longestPalindromeStartIndexInReverseStringLengthStringLength = 0\n  \
    \  var longestPalindromeEndIndexInReverseStringLengthStringLength = 0\n    var\
    \ longestPalindromeStartIndexInReverseStringLengthStringLengthString = \"\"\n\
    \    var longestPalindromeEndIndexInReverseStringLengthStringLengthString = \"\
    \"\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLength\
    \ = 0\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n    var longestPalindromeEndIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthStringLength\
    \ = \"\"\n    var longestPalin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpf2z5h4ns.swift:36:9: error: invalid redeclaration of 'longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString'\n\
    \    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n        ^\n/tmp/tmpf2z5h4ns.swift:34:9: note: 'longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString'\
    \ previously declared here\n    var longestPalindromeStartIndexInReverseStringLengthStringLengthStringLengthStringLengthStringLengthString\
    \ = \"\"\n        ^\n/tmp/tmpf2z5h4ns.swift:38:9: error: type annotation missing\
    \ in pattern\n    var longestPalin\n        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromePrefixString\
    \ = \"\"\n    var longestPalindromeSuffixString = \"\"\n    var longestPalindromeString\
    \ = \"\"\n    var longestPalindromeStringLength = 0\n    var longestPalindromeStringPrefixLength\
    \ = 0\n    var longestPalindromeStringSuffixLength = 0\n    var longestPalindromeStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringSuffixString = \"\"\n    var longestPalindromeStringString\
    \ = \"\"\n    var longestPalindromeStringStringLength = 0\n    var longestPalindromeStringStringPrefixLength\
    \ = 0\n    var longestPalindromeStringStringSuffixLength = 0\n    var longestPalindromeStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringSuffixString = \"\"\n    var longestPalindromeStringStringString\
    \ = \"\"\n    var longestPalindromeStringStringStringLength = 0\n    var longestPalindromeStringStringStringPrefixLength\
    \ = 0\n    var longestPalindromeStringStringStringSuffixLength = 0\n    var longestPalindromeStringStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringStringSuffixString = \"\"\n   \
    \ var longestPalindromeStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringPrefixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringSuffixLength = 0\n    var longestPalindromeStringStringStringStringPrefixString\
    \ = \"\"\n    var longestPalindromeStringStringStringStringSuffixString = \"\"\
    \n    var longestPalindromeStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringStringPrefixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringSuffixString = \"\"\n   \
    \ var longestPalindromeStringStringStringStringStringString = \"\"\n    var longestPalindromeStringStringStringStringStringStringLength\
    \ = 0\n    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n\
    \    var longestPalindromeStringStringStringStringStringSuffixLength = 0\n   \
    \ var longestPalindromeStringStringStringStringStringStringPrefixString = \"\"\
    \n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp3tlecfh9.swift:49:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp3tlecfh9.swift:46:9: error: invalid redeclaration of 'longestPalindromeStringStringStringStringStringPrefixLength'\n\
    \    var longestPalindromeStringStringStringStringStringPrefixLength = 0\n   \
    \     ^\n/tmp/tmp3tlecfh9.swift:40:9: note: 'longestPalindromeStringStringStringStringStringPrefixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringPrefixLength\
    \ = 0\n        ^\n/tmp/tmp3tlecfh9.swift:47:9: error: invalid redeclaration of\
    \ 'longestPalindromeStringStringStringStringStringSuffixLength'\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n/tmp/tmp3tlecfh9.swift:41:9: note: 'longestPalindromeStringStringStringStringStringSuffixLength'\
    \ previously declared here\n    var longestPalindromeStringStringStringStringStringSuffixLength\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindromeLength\
    \ = 0\n    var longestPalindrome = \"\"\n    for stringToCheck in string.characters\
    \ {\n        let reversedString = stringToCheck.reversed()\n        if stringToCheck\
    \ == reversedString {\n            longestPalindromeLength += 1\n            longestPalindrome\
    \ += stringToCheck\n        }\n    }\n    if longestPalindromeLength > 0 {\n \
    \       stringToReturn += longestPalindrome\n    }\n    return stringToReturn\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq5oz2d7o.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for stringToCheck in string.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpq5oz2d7o.swift:11:44: error: value of type 'Character'\
    \ has no member 'reversed'\n        let reversedString = stringToCheck.reversed()\n\
    \                             ~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpq5oz2d7o.swift:14:34:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            longestPalindrome += stringToCheck\n                            \
    \     ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n  \
    \  var longestPalindromePrefixIndex = 0\n    for index in 0..<string.characters.count\
    \ {\n        let character = string.characters[index]\n        let reversedCharacter\
    \ = reversedString(character)\n        if character == reversedCharacter {\n \
    \           result += character\n            longestPalindrome = result\n    \
    \        longestPalindromeLength = longestPalindrome.characters.count\n      \
    \      longestPalindromeIndex = index\n            longestPalindromePrefixIndex\
    \ = longestPalindromeIndex\n        } else {\n            if longestPalindromeLength\
    \ > longestPalindromeIndex {\n                result += string[longestPalindromePrefixIndex..<longestPalindromeIndex]\n\
    \                longestPalindrome = result\n                longestPalindromeLength\
    \ = longestPalindrome.characters.count\n                longestPalindromeIndex\
    \ = index\n                longestPalindromePrefixIndex = longestPalindromeIndex\n\
    \            }\n        }\n    }\n    if longestPalindromeLength > longestPalindromeIndex\
    \ {\n        result += string[longestPalindromePrefixIndex..<longestPalindromeIndex]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpf38qjmm_.swift:12:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpf38qjmm_.swift:13:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpf38qjmm_.swift:13:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpf38qjmm_.swift:14:33:\
    \ error: cannot find 'reversedString' in scope\n        let reversedCharacter\
    \ = reversedString(character)\n                                ^~~~~~~~~~~~~~\n\
    /tmp/tmpf38qjmm_.swift:16:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpf38qjmm_.swift:18:57: error: 'characters' is unavailable:\
    \ Please use String directly\n            longestPalindromeLength = longestPalindrome.characters.count\n\
    \                                                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpf38qjmm_.swift:23:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n                result += string[longestPalindromePrefixIndex..<longestPalindromeIndex]\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let maxLength: Int = string.characters.count\n    let\
    \ maxLengthOfLongestPalindrome = maxLength\n    var reversedString = \"\"\n  \
    \  var longestPalindrome = \"\"\n    var longestPalindromeLength = 0\n    for\
    \ index in 0..<maxLength {\n        let character = string.characters[index]\n\
    \        let reversedCharacter = reverseString(character)\n        if character\
    \ == reversedCharacter {\n            longestPalindromeLength += 1\n         \
    \   if longestPalindromeLength > maxLengthOfLongestPalindrome {\n            \
    \    maxLengthOfLongestPalindrome = longestPalindromeLength\n                longestPalindrome\
    \ = character\n            }\n        } else {\n            longestPalindromeLength\
    \ = 0\n        }\n    }\n    reversedString = reverseString(longestPalindrome)\n\
    \    return reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpstkd0zpz.swift:7:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLength: Int = string.characters.count\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpstkd0zpz.swift:13:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ character = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpstkd0zpz.swift:13:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpstkd0zpz.swift:14:33:\
    \ error: cannot find 'reverseString' in scope\n        let reversedCharacter =\
    \ reverseString(character)\n                                ^~~~~~~~~~~~~\n/tmp/tmpstkd0zpz.swift:18:17:\
    \ error: cannot assign to value: 'maxLengthOfLongestPalindrome' is a 'let' constant\n\
    \                maxLengthOfLongestPalindrome = longestPalindromeLength\n    \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpstkd0zpz.swift:8:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let maxLengthOfLongestPalindrome = maxLength\n\
    \    ^~~\n    var\n/tmp/tmpstkd0zpz.swift:19:37: error: cannot assign value of\
    \ type 'Character' to type 'String'\n                longestPalindrome = character\n\
    \                                    ^~~~~~~~~\n/tmp/tmpstkd0zpz.swift:25:22:\
    \ error: cannot find 'reverseString' in scope\n    reversedString = reverseString(longestPalindrome)\n\
    \                     ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = string\n    var longestPalindrome\
    \ = String()\n    var longestPalindromeLength = String()\n    var longestPalindromePrefix\
    \ = String()\n    var longestPalindromeSuffix = String()\n    var longestPalindromePostfix\
    \ = String()\n    var longestPalindromePostfixLength = String()\n    var longestPalindromePostfixPrefix\
    \ = String()\n    var longestPalindromePostfixSuffix = String()\n    var longestPalindromePostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixLength = String()\n    var\
    \ longestPalindromePostfixPostfixPrefix = String()\n    var longestPalindromePostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixLength = String()\n    var longestPalindromePostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixSuffix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPrefix = String()\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixSuffix = String()\n    var\
    \ longestPalindromePostfixPostfixPostfixPostfixPostfix = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n    var longestP\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpekv3hrla.swift:34:9: error: invalid redeclaration of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\n\
    \    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:30:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPrefix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:35:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:31:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixSuffix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:36:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:32:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfix\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:37:9: error: invalid redeclaration\
    \ of 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\n   \
    \ var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength = String()\n\
    \        ^\n/tmp/tmpekv3hrla.swift:33:9: note: 'longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength'\
    \ previously declared here\n    var longestPalindromePostfixPostfixPostfixPostfixPostfixPostfixLength\
    \ = String()\n        ^\n/tmp/tmpekv3hrla.swift:38:9: error: type annotation missing\
    \ in pattern\n    var longestP\n        ^\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedLongestPalindrome = reversedLongestPalindrome(longestPalindrome)\n\
    \    let reversedLongestPalindromeWithPrefix = reversedLongestPalindromeWithPrefix(longestPalindrome,\
    \ reversedLongestPalindrome)\n    return reversedLongestPalindromeWithPrefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkdbtivpn.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpkdbtivpn.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpkdbtivpn.swift:8:37: error: use of local variable 'reversedLongestPalindrome'\
    \ before its declaration\n    let reversedLongestPalindrome = reversedLongestPalindrome(longestPalindrome)\n\
    \                                    ^\n/tmp/tmpkdbtivpn.swift:8:9: note: 'reversedLongestPalindrome'\
    \ declared here\n    let reversedLongestPalindrome = reversedLongestPalindrome(longestPalindrome)\n\
    \        ^\n/tmp/tmpkdbtivpn.swift:9:47: error: use of local variable 'reversedLongestPalindromeWithPrefix'\
    \ before its declaration\n    let reversedLongestPalindromeWithPrefix = reversedLongestPalindromeWithPrefix(longestPalindrome,\
    \ reversedLongestPalindrome)\n                                              ^\n\
    /tmp/tmpkdbtivpn.swift:9:9: note: 'reversedLongestPalindromeWithPrefix' declared\
    \ here\n    let reversedLongestPalindromeWithPrefix = reversedLongestPalindromeWithPrefix(longestPalindrome,\
    \ reversedLongestPalindrome)\n        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoapii2i1.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpoapii2i1.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpoapii2i1.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string, longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let reversedString = string.reversed()\n    let longestPalindrome\
    \ = longestPalindromeFrom(string, reversedString)\n    return longestPalindrome\
    \ + reversedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpo3enbfkn.swift:8:29: error: cannot find 'longestPalindromeFrom'\
    \ in scope\n    let longestPalindrome = longestPalindromeFrom(string, reversedString)\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var reversed = \"\"\n    var longestPalindrome = \"\
    \"\n    for character in string {\n        reversed = reversed.appending(character)\n\
    \        if longestPalindrome == \"\" {\n            longestPalindrome = reversed\n\
    \        } else {\n            if longestPalindrome == reversed {\n          \
    \      longestPalindrome = longestPalindrome\n            } else {\n         \
    \       longestPalindrome = longestPalindrome.appending(reversed)\n          \
    \  }\n        }\n    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp1ftzreiu.swift:10:29: error: value of type 'String' has no member\
    \ 'appending'\n        reversed = reversed.appending(character)\n            \
    \       ~~~~~~~~ ^~~~~~~~~\n/tmp/tmp1ftzreiu.swift:15:35: error: assigning a variable\
    \ to itself\n                longestPalindrome = longestPalindrome\n         \
    \       ~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~\n/tmp/tmp1ftzreiu.swift:17:55: error:\
    \ value of type 'String' has no member 'appending'\n                longestPalindrome\
    \ = longestPalindrome.appending(reversed)\n                                  \
    \  ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var result = \"\"\n    var longestPalindrome = \"\"\
    \n    var longestPalindromeLength = 0\n    for character in string {\n       \
    \ if character == character {\n            longestPalindromeLength += 1\n    \
    \        if longestPalindromeLength > longestPalindrome.count {\n            \
    \    longestPalindrome = String(character)\n            }\n        } else {\n\
    \            if longestPalindromeLength > longestPalindrome.count {\n        \
    \        longestPalindrome = String(character)\n            }\n        }\n   \
    \ }\n    for character in string {\n        if character == character {\n    \
    \        longestPalindromeLength += 1\n            if longestPalindromeLength\
    \ > longestPalindrome.count {\n                longestPalindrome = String(character)\n\
    \            }\n        } else {\n            if longestPalindromeLength > longestPalindrome.count\
    \ {\n                longestPalindrome = String(character)\n            }\n  \
    \      }\n    }\n    if longestPalindromeLength == 0 {\n        return string\n\
    \    }\n    if longestPalindromeLength == 1 {\n        return string\n    }\n\
    \    if longestPalindromeLength == 2 {\n        return string + String(character)\n\
    \    }\n    if longestPalindromeLength > 2 {\n        for character in string\
    \ {\n            if character == character {\n                longestPalindromeLength\
    \ += 1\n                if longestPalindromeLength > longestPalindrome.count {\n\
    \                    longestPalindrome = String(character)\n                }\n\
    \            } else {\n                if longestPalindromeLength > longestPalindrome.count\
    \ {\n                    longestPalindrome = String(character)\n             \
    \   }\n            }\n        }\n    }\n    if longestPalindromeLength > 2 {\n\
    \        for character in string {\n            if character == character {\n\
    \                longestPalindromeLength += 1\n                if longestPalindromeLength\
    \ > longestPalindrome.count {\n                    longestPalindrome = String(character)\n\
    \                }\n            } else {\n                if longestPalindromeLength\
    \ > longestPalindrome.count {\n                    longestPalindrome = String(character)\n\
    \                }\n            }\n        }\n    }\n    if longestPalindromeLength\
    \ > 2 {\n        for character in string {\n            if character == character\
    \ {\n                longestPalindromeLength += 1\n                if longestPalindromeLength\
    \ > longestPalindrome.count {\n                    longestPalindrome = String(character)\n\
    \                }\n            } else {\n                if longestPalindromeLength\
    \ > longestPalindrome.count {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp4v7t9dbo.swift:100:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmp4v7t9dbo.swift:78:20: note:\
    \ to match this opening '{'\n            } else {\n                   ^\n/tmp/tmp4v7t9dbo.swift:100:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmp4v7t9dbo.swift:72:33: note: to match this opening '{'\n\
    \        for character in string {\n                                ^\n/tmp/tmp4v7t9dbo.swift:100:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmp4v7t9dbo.swift:71:36: note: to match this opening '{'\n\
    \    if longestPalindromeLength > 2 {\n                                   ^\n\
    /tmp/tmp4v7t9dbo.swift:100:56: error: expected '}' at end of brace statement\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")\n                \
    \                                       ^\n/tmp/tmp4v7t9dbo.swift:6:48: note:\
    \ to match this opening '{'\nfunc make_palindrome(string: String) -> String {\n\
    \                                               ^\n/tmp/tmp4v7t9dbo.swift:41:32:\
    \ error: cannot find 'character' in scope\n        return string + String(character)\n\
    \                               ^~~~~~~~~\n/tmp/tmp4v7t9dbo.swift:84:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var longestPalindrome = \"\"\n    var longestPalindromeLength\
    \ = 0\n    for character in string {\n        if character == character[character.startIndex]\
    \ {\n            longestPalindromeLength += 1\n        } else {\n            if\
    \ longestPalindromeLength > longestPalindromeLength {\n                longestPalindrome\
    \ = string\n                longestPalindromeLength = longestPalindromeLength\n\
    \            }\n        }\n    }\n    if longestPalindromeLength > longestPalindromeLength\
    \ {\n        longestPalindrome = string\n        longestPalindromeLength = longestPalindromeLength\n\
    \    }\n    return longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4awyh6rj.swift:10:34: error: value of type 'Character' has no subscripts\n\
    \        if character == character[character.startIndex] {\n                 \
    \       ~~~~~~~~~^\n/tmp/tmp4awyh6rj.swift:10:45: error: value of type 'Character'\
    \ has no member 'startIndex'\n        if character == character[character.startIndex]\
    \ {\n                                  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4awyh6rj.swift:15:41:\
    \ error: assigning a variable to itself\n                longestPalindromeLength\
    \ = longestPalindromeLength\n                ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4awyh6rj.swift:21:33: error: assigning a variable to itself\n        longestPalindromeLength\
    \ = longestPalindromeLength\n        ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var stringToReturn = \"\"\n    var stringToReverse\
    \ = \"\"\n    var longestPalindrome = \"\"\n    var longestPalindromeLength =\
    \ 0\n    var longestPalindromeIndex = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixStartIndex\
    \ = 0\n    var longestPalindromeSuffixEndIndex = 0\n    var longestPalindromeSuffixString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverse = \"\"\n    var longestPalindromeSuffixStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseLength = 0\n    var longestPalindromeSuffixStringReverseStartIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseEndIndex = 0\n    var longestPalindromeSuffixStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverse = \"\"\n \
    \   var longestPalindromeSuffixStringReverseStringReverseIndex = 0\n    var longestPalindromeSuffixStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStartIndex = 0\n\
    \    var longestPalindromeSuffixStringReverseStringReverseEndIndex = 0\n    var\
    \ longestPalindromeSuffixStringReverseStringReverseString = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStartIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseEndIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStartIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseEndIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseString\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverse\
    \ = \"\"\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseIndex\
    \ = 0\n    var longestPalindromeSuffixStringReverseStringReverseStringReverseStringReverseStringReverseLength\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp18_r827o.swift:7:9: warning: initialization of variable 'stringToReturn'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var stringToReturn = \"\"\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp18_r827o.swift:8:9:\
    \ warning: initialization of variable 'stringToReverse' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var stringToReverse = \"\
    \"\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp18_r827o.swift:9:9: warning: initialization\
    \ of variable 'longestPalindrome' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var longestPalindrome = \"\"\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp18_r827o.swift:10:9: warning: initialization of variable 'longestPalindromeLength'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeLength = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp18_r827o.swift:11:9: warning: initialization of variable 'longestPalindromeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longestPalindromeIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp18_r827o.swift:12:9:\
    \ warning: initialization of variable 'longestPalindromeSuffixIndex' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var longestPalindromeSuffixIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp18_r827o.swift:13:9:\
    \ warning: initialization of variable 'longestPalindromeSuffixLength' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var longestPalindromeSuffixLength\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp18_r827o.swift:14:9:\
    \ warning: initialization of variable 'longestPalindromeSuffixStartIndex' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ longestPalindromeSuffixStartIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp18_r827o.swift:15:9: warning: initialization of variable 'longestPalindromeSuffixEndIndex'\
    \ was never used; consider replacing with assignment to "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    let longestPalindrome = longestPalindrome(string)\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n    return\
    \ reversedString + longestPalindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjhud85lw.swift:7:29: error: use of local variable 'longestPalindrome'\
    \ before its declaration\n    let longestPalindrome = longestPalindrome(string)\n\
    \                            ^\n/tmp/tmpjhud85lw.swift:7:9: note: 'longestPalindrome'\
    \ declared here\n    let longestPalindrome = longestPalindrome(string)\n     \
    \   ^\n/tmp/tmpjhud85lw.swift:8:26: error: cannot find 'reverseString' in scope\n\
    \    let reversedString = reverseString(string: longestPalindrome)\n         \
    \                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeStartIndex =\
    \ 0\n    var longestPalindromeEndIndex = 0\n    var longestPalindromeStartIndexOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindrome = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeStartIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindrome\
    \ = 0\n    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpm0gehe88.swift:23:9: error: type annotation missing in pattern\n\
    \    var longestPalindromeEndIndexOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongestPalindromeOfLongest\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var palindrome = \"\"\n    var longestPalindrome =\
    \ \"\"\n    var longestPalindromeLength = 0\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromeSuffixLength = 0\n    var longestPalindromeSuffixIndex\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    var longestPalindromeSuffixChar\
    \ = \"\"\n    var longestPalindromePrefixChar = \"\"\n    var longestPalindromeString\
    \ = \"\"\n    var longestPalindromeStringLength = 0\n    var longestPalindromeStringIndex\
    \ = 0\n    var longestPalindromeStringChar = \"\"\n    var longestPalindromeStringReverse\
    \ = \"\"\n    var longestPalindromeStringReverseIndex = 0\n    var longestPalindromeStringReverseChar\
    \ = \"\"\n    var longestPalindromeStringReverseLength = 0\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindromeStringReverseChar = \"\"\n    var longestPalindromeStringReverseIndex\
    \ = 0\n    var longestPalindro\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpbu_e62bh.swift:24:9: error: invalid redeclaration of 'longestPalindromeStringReverseIndex'\n\
    \    var longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:21:9:\
    \ note: 'longestPalindromeStringReverseIndex' previously declared here\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:25:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseChar'\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:22:9:\
    \ note: 'longestPalindromeStringReverseChar' previously declared here\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:26:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseIndex'\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:21:9:\
    \ note: 'longestPalindromeStringReverseIndex' previously declared here\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:27:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseChar'\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:22:9:\
    \ note: 'longestPalindromeStringReverseChar' previously declared here\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:28:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseIndex'\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:21:9:\
    \ note: 'longestPalindromeStringReverseIndex' previously declared here\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.swift:29:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseChar'\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:22:9:\
    \ note: 'longestPalindromeStringReverseChar' previously declared here\n    var\
    \ longestPalindromeStringReverseChar = \"\"\n        ^\n/tmp/tmpbu_e62bh.swift:30:9:\
    \ error: invalid redeclaration of 'longestPalindromeStringReverseIndex'\n    var\
    \ longestPalindromeStringReverseIndex = 0\n        ^\n/tmp/tmpbu_e62bh.sw"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromeSuffixIndex = 0\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixStartIndex = 0\n    var longestPalindromeSuffixEndIndex\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverse = 0\n    var longestPalindromeSuffixEndIndexReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverse = 0\n    var longestPalindromeSuffixEndIndexReverseReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n  \
    \  var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var\
    \ longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n  \
    \  var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var\
    \ longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n  \
    \  var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var\
    \ longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n  \
    \  var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var\
    \ longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n  \
    \  var longestPalindromeSuffixEndIndexReverseReverseReverse = 0\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpgroxoilc.swift:21:9: error: invalid redeclaration of 'longestPalindromeSuffixStartIndexReverseReverseReverse'\n\
    \    var longestPalindromeSuffixStartIndexReverseReverseReverse = 0\n        ^\n\
    /tmp/tmpgroxoilc.swift:19:9: note: 'longestPalindromeSuffixStartIndexReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:22:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixEndIndexReverseReverseReverse'\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:20:9: note: 'longestPalindromeSuffixEndIndexReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:23:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStartIndexReverseReverseReverse'\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:19:9: note: 'longestPalindromeSuffixStartIndexReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:24:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixEndIndexReverseReverseReverse'\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:20:9: note: 'longestPalindromeSuffixEndIndexReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixEndIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:25:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixStartIndexReverseReverseReverse'\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:19:9: note: 'longestPalindromeSuffixStartIndexReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeSuffixStartIndexReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmpgroxoilc.swift:26:9: error: invalid redeclaration of\
    \ 'longestPalindromeSuffixEndIndexReverseReverseReverse'\n   "
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromeIndexStart = 0\n    var longestPalindromeIndexEnd =\
    \ 0\n    var longestPalindromeIndexStartReverse = 0\n    var longestPalindromeIndexEndReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n \
    \   var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n   \
    \ var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n \
    \   var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n   \
    \ var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n \
    \   var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n   \
    \ var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n \
    \   var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n   \
    \ var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n \
    \   var longestPalindromeIndexEndReverseReverseReverseReverse = 0\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n    var longestPalindromeIndexEndReverseReverseReverseReverse\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphmuc0p4i.swift:21:9: error: invalid redeclaration of 'longestPalindromeIndexStartReverseReverseReverseReverse'\n\
    \    var longestPalindromeIndexStartReverseReverseReverseReverse = 0\n       \
    \ ^\n/tmp/tmphmuc0p4i.swift:19:9: note: 'longestPalindromeIndexStartReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:22:9: error: invalid redeclaration of\
    \ 'longestPalindromeIndexEndReverseReverseReverseReverse'\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:20:9: note: 'longestPalindromeIndexEndReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:23:9: error: invalid redeclaration of\
    \ 'longestPalindromeIndexStartReverseReverseReverseReverse'\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:19:9: note: 'longestPalindromeIndexStartReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:24:9: error: invalid redeclaration of\
    \ 'longestPalindromeIndexEndReverseReverseReverseReverse'\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:20:9: note: 'longestPalindromeIndexEndReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeIndexEndReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:25:9: error: invalid redeclaration of\
    \ 'longestPalindromeIndexStartReverseReverseReverseReverse'\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:19:9: note: 'longestPalindromeIndexStartReverseReverseReverseReverse'\
    \ previously declared here\n    var longestPalindromeIndexStartReverseReverseReverseReverse\
    \ = 0\n        ^\n/tmp/tmphmuc0p4i.swift:26:9: error: invalid redeclaration of\
    \ 'longestPalindromeIndexEndReverseRever"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(string:\
    \ String) -> String {\n    var string = string\n    var longestPalindrome = \"\
    \"\n    var longestPalindromeLength = 0\n    var longestPalindromeIndex = 0\n\
    \    var longestPalindromeSuffix = \"\"\n    var longestPalindromeSuffixLength\
    \ = 0\n    var longestPalindromeSuffixIndex = 0\n    for index in 0..<string.characters.count\
    \ {\n        let character = string.characters[index]\n        if character ==\
    \ \"-\" {\n            longestPalindromeLength += 1\n            longestPalindromeIndex\
    \ += 1\n            longestPalindromeSuffix = string.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeLength))\n            longestPalindromeSuffixLength = len(longestPalindromeSuffix)\n\
    \            longestPalindromeSuffixIndex = longestPalindromeIndex\n        }\
    \ else {\n            longestPalindromeLength += 1\n            longestPalindromeIndex\
    \ += 1\n        }\n    }\n    if longestPalindromeLength > longestPalindromeSuffixLength\
    \ {\n        longestPalindromeLength = len(longestPalindromeSuffix)\n        longestPalindromeSuffixIndex\
    \ = longestPalindromeIndex\n    }\n    if longestPalindromeLength == 0 {\n   \
    \     return \"\"\n    }\n    if longestPalindromeLength == 1 {\n        return\
    \ string\n    }\n    var longestPalindromePrefix = \"\"\n    var longestPalindromePrefixLength\
    \ = 0\n    var longestPalindromePrefixIndex = 0\n    for index in 0..<longestPalindromeLength\
    \ {\n        let character = string.characters[index]\n        if character ==\
    \ \"-\" {\n            longestPalindromePrefixLength += 1\n            longestPalindromePrefixIndex\
    \ += 1\n            longestPalindromePrefix = string.substringWithRange(NSMakeRange(longestPalindromePrefixIndex,\
    \ longestPalindromePrefixLength))\n        } else {\n            longestPalindromePrefixLength\
    \ += 1\n        }\n    }\n    if longestPalindromePrefixLength > longestPalindromeSuffixLength\
    \ {\n        longestPalindromePrefixLength = len(longestPalindromeSuffix)\n  \
    \  }\n    if longestPalindromePrefixLength == 0 {\n        return string\n   \
    \ }\n    if longestPalindromePrefixLength == 1 {\n        return string\n    }\n\
    \    var longestPalindromeSuffixReversed = \"\"\n    var longestPalindromeSuffixReversedLength\
    \ = 0\n    var longestPalindromeSuffixReversedIndex = 0\n    for index in 0..<longestPalindromeSuffixLength\
    \ {\n        let character = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpu0l3wigy.swift:63:24: error: expected initial value after '='\n\
    \        let character = \n                       ^\n/tmp/tmpu0l3wigy.swift:83:56:\
    \ error: expected '}' at end of brace statement\nassert(make_palindrome(string:\
    \ \"jerry\") == \"jerryrrej\")\n                                             \
    \          ^\n/tmp/tmpu0l3wigy.swift:6:48: note: to match this opening '{'\nfunc\
    \ make_palindrome(string: String) -> String {\n                              \
    \                 ^\n/tmp/tmpu0l3wigy.swift:14:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in 0..<string.characters.count {\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpu0l3wigy.swift:15:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ character = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu0l3wigy.swift:15:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu0l3wigy.swift:19:65:\
    \ error: cannot find 'NSMakeRange' in scope\n            longestPalindromeSuffix\
    \ = string.substringWithRange(NSMakeRange(longestPalindromeIndex, longestPalindromeLength))\n\
    \                                                                ^~~~~~~~~~~\n\
    /tmp/tmpu0l3wigy.swift:19:46: error: value of type 'String' has no member 'substringWithRange'\n\
    \            longestPalindromeSuffix = string.substringWithRange(NSMakeRange(longestPalindromeIndex,\
    \ longestPalindromeLength))\n                                      ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu0l3wigy.swift"
  stdout: ''
  timestamp: 1660014778
