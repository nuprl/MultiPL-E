language: swift
name: HumanEval_115_max_fill
results:
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col > max {\n\
    \                max = col\n            }\n        }\n    }\n    var count = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == max {\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpa2i_pct1/tmpa2i_pct1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99704e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99701dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99701dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99701db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa2i_pct1                        0x000056406d940717 <unavailable> + 5911

    5    libc.so.6                          0x00002b99706d1460 __libc_start_main +
    245

    6    tmpa2i_pct1                        0x000056406d9400d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for _ in 0..<grid.count {\n        var buckets = [Int](capacity)\n\
    \        for _ in 0..<capacity {\n            buckets[_] = 0\n        }\n    \
    \    for _ in 0..<grid[_].count {\n            buckets[grid[_][_]] += 1\n    \
    \    }\n        for _ in 0..<capacity {\n            if buckets[_] > max {\n \
    \               max = buckets[_]\n                maxCount = _\n            }\n\
    \        }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0iuwbugo.swift:21:29: error: missing argument label 'arrayLiteral:'\
    \ in call\n        var buckets = [Int](capacity)\n                           \
    \ ^\n                            arrayLiteral: \n/tmp/tmp0iuwbugo.swift:23:21:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            buckets[_] = 0\n                    ^\n/tmp/tmp0iuwbugo.swift:25:27:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        for _ in 0..<grid[_].count {\n                          ^\n/tmp/tmp0iuwbugo.swift:29:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            if buckets[_] > max {\n                       ^\n/tmp/tmp0iuwbugo.swift:30:31:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                max = buckets[_]\n                              ^\n/tmp/tmp0iuwbugo.swift:31:28:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                maxCount = _\n                           ^\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited2 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited3 = [Bool](capacity)\n    \n    // init visited wells\n    var visited4\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited5 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited6 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited7 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited8 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited9 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited10 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited11 = [Bool](capacity)\n    \n    // init visited wells\n    var visited12\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited13 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited14 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited15 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited16 = [Bool](capacity)\n    \n    // init\
    \ visited wells\n    var visited17 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited18 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited19 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited20 = [Bool](capacity)\n    \n    // init visited wells\n    var visited21\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited22 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited23 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited24 = [Bool](capacity)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps28hem61.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmps28hem61.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmps28hem61.swift:29:19:\
    \ error: no exact matches in call to initializer \n    var visited = [Bool](capacity)\n\
    \                  ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmps28hem61.swift:29:19: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited =\
    \ [Bool](capacity)\n                  ^\n/tmp/tmps28hem61.swift:29:19: note: candidate\
    \ expects value of type 'any Decoder' for parameter #1 (got 'Int')\n    var visited\
    \ = [Bool](capacity)\n                  ^\n/tmp/tmps28hem61.swift:32:20: error:\
    \ no exact matches in call to initializer \n    var visited2 = [Bool](capacity)\n\
    \                   ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmps28hem61.swift:32:20: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited2\
    \ = [Bool](capacit"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var count\
    \ = 0\n    var max = 0\n    \n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += 1\n                if count\
    \ > max {\n                    max = count\n                }\n              \
    \  count = 0\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprrffe4gh/tmprrffe4gh.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b924adf5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b924aaecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b924aaec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b924aaeb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprrffe4gh                        0x000055bea3ca3546 <unavailable> + 5446

    5    libc.so.6                          0x00002b924afe1460 __libc_start_main +
    245

    6    tmprrffe4gh                        0x000055bea3ca30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                max += capacity\n            \
    \    count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyhg3nyl9/tmpyhg3nyl9.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b206adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b203a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b203a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b203a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyhg3nyl9                        0x000055a7cfd30717 <unavailable> + 5911

    5    libc.so.6                          0x00002b3b20899460 __libc_start_main +
    245

    6    tmpyhg3nyl9                        0x000055a7cfd300d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var index = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                max += 1\n            }\n    \
    \    }\n    }\n    \n    for row in grid {\n        for col in row {\n       \
    \     if col == 0 {\n                grid[index][col] = 1\n                max\
    \ += max_fill(grid, capacity)\n                grid[index][col] = 0\n        \
    \    }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj7dd4f5r.swift:33:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[index][col] = 1\n                ~~~~\
    \       ^\n/tmp/tmpj7dd4f5r.swift:34:32: error: missing argument labels 'grid:capacity:'\
    \ in call\n                max += max_fill(grid, capacity)\n                 \
    \              ^\n                                grid: capacity: \n/tmp/tmpj7dd4f5r.swift:35:28:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \         grid[index][col] = 0\n                ~~~~       ^\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket count\n    var bucketCount = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    //\
    \ init bucket min sum\n    var bucketMinSum = 0\n    \n    // init bucket min\
    \ max value\n    var bucketMinMax = 0\n    \n    // init bucket min min value\n\
    \    var bucketMinMin = 0\n    \n    // init bucket min min index\n    var bucketMinMinIndex\
    \ = 0\n    \n    // init bucket min min sum\n    var bucketMinMinSum = 0\n   \
    \ \n    // init bucket min min max value\n    var bucketMinMinMax = 0\n    \n\
    \    // init bucket min min min value\n    var bucketMinMinMin = 0\n    \n   \
    \ // init bucket min min min index\n    var bucketMinMinMinIndex = 0\n    \n \
    \   // init bucket min min min sum\n    var bucketMinMinMinSum = 0\n    \n   \
    \ // init bucket min min min max value\n    var bucketMinMinMinMax = 0\n    \n\
    \    // init bucket min min min min value\n    var bucketMinMinMinMin = 0\n  \
    \  \n    // init bucket min min min min index\n    var bucketMinMinMinMinIndex\
    \ = 0\n    \n    // init bucket min min min min sum\n    var bucketMinMinMinMinSum\
    \ = 0\n    \n    // init bucket min min min min max value\n    var bucketMinMinMinMinMax\
    \ = 0\n    \n    // init bucket min min min min min value\n    var bucketMinMinMinMinMin\
    \ = 0\n    \n    // init bucket min min min min min index\n    var bucketMinMinMinMinMinIndex\
    \ = 0\n    \n    // init bucket min min min min min sum\n    var bucketMinMinMinMinMinSum\
    \ = 0\n    \n    // init bucket min min min min min max value\n    var bucketMinMinMinMinMinMax\
    \ = 0\n    \n    // init bucket min min min min min min value\n    var bucketMinMinMinMinMinMin\
    \ = 0\n    \n    // init bucket min min min min min min index\n    var bucketMinMinMinMinMinMinIndex\
    \ = 0\n    \n    // init bucket min min min min min min sum\n    var bucketMinMinMinMinMinMinSum\
    \ = 0\n    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpoy_6kqc8.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpoy_6kqc8.swift:38:32: error: cannot\
    \ call value of non-function type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                               ^  ~~\n                                  \n/tmp/tmpoy_6kqc8.swift:38:28:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMin = grid[0][0].min()\n                    ~~~~~~~^~~\n             \
    \       Int\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket min value\n   \
    \ var bucketMinValue = grid[0][0]\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgflv28de.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgflv28de.swift:44:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:47:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:68:9: erro"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var index = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     \n                let bucket = capacity / grid[row][col]\n             \
    \   \n                for _ in 0..<bucket {\n                    grid[row][col]\
    \ = 0\n                    \n                    if index == 0 {\n           \
    \             max++\n                    }\n                    \n           \
    \         index++\n                }\n            }\n        }\n    }\n    \n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxjks4hwj.swift:29:30: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row][col] = 0\n              \
    \      ~~~~     ^\n/tmp/tmpxjks4hwj.swift:32:28: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                        max++\n            \
    \               ^~\n/tmp/tmpxjks4hwj.swift:35:26: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                    index++\n         \
    \                ^~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init visited map\n    var visited = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited2 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited3 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited4 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited5 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited6 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited7 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited8 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited9 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited10 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited11 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited12 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited13 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited14 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited15 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited16 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited17 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited18 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited19 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited20 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited21 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited22 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited23 = make(map[int]bool,\
    \ capacity)\n    \n    // init visited map\n    var visited24 = make(map[\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa1b6wfby.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpa1b6wfby.swift:26:32: error: expected ',' separator\n   \
    \ var visited = make(map[int]bool, capacity)\n                               ^\n\
    \                               ,\n/tmp/tmpa1b6wfby.swift:29:33: error: expected\
    \ ',' separator\n    var visited2 = make(map[int]bool, capacity)\n           \
    \                     ^\n                                ,\n/tmp/tmpa1b6wfby.swift:32:33:\
    \ error: expected ',' separator\n    var visited3 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:35:33:\
    \ error: expected ',' separator\n    var visited4 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:38:33:\
    \ error: expected ',' separator\n    var visited5 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:41:33:\
    \ error: expected ',' separator\n    var visited6 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:44:33:\
    \ error: expected ',' separator\n    var visited7 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:47:33:\
    \ error: expected ',' separator\n    var visited8 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:50:33:\
    \ error: expected ',' separator\n    var visited9 = make(map[int]bool, capacity)\n\
    \                                ^\n                                ,\n/tmp/tmpa1b6wfby.swift:53:34:\
    \ error: expected ',' separator\n    var visited10 = make(map[int]bool, capacity)\n\
    \                                 ^\n                                 ,\n/tmp/tmpa1b6wfby.swift:56:34:\
    \ error: expected ',' separator\n    var visited11 = make(map[int]bool, capacity)\n\
    \                   "
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr2gth4wc/tmpr2gth4wc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83438e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83435d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83435d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83435d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2gth4wc                        0x00005635b128b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8343acd460 __libc_start_main +
    245

    6    tmpr2gth4wc                        0x00005635b128b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max value\n    var bucketMax = 0\n    \n    // init bucket min value\n    var\
    \ bucketMin = grid[0][0].min()\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = grid[0][0].min()\n    \n    // init bucket\
    \ max value\n    var bucketMaxValue = grid[0][0].min()\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = grid[0][0].min()\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0].min()\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = grid[0][0].min()\n   \
    \ \n    // init bucket max value\n    var bucketMaxValue = grid[0][0].min()\n\
    \    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    //\
    \ init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = grid[0][0].min()\n    \n    // init bucket\
    \ max value\n    var bucketMaxValue = grid[0][0].min()\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = grid[0][0].min()\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0].min()\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = grid[0][0].min()\n   \
    \ \n    // init bucket max value\n    var bucketMaxValue = grid[0][0].min()\n\
    \    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    //\
    \ init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = grid[0][0].min()\n    \n    // \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpl79y19m7.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpl79y19m7.swift:35:28: error: static\
    \ member 'min' cannot be used on instance of type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                    ~~~~~~~^~~\n                    Int\n/tmp/tmpl79y19m7.swift:35:32:\
    \ error: cannot call value of non-function type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                               ^  ~~\n                                  \n/tmp/tmpl79y19m7.swift:47:33:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMinValue = grid[0][0].min()\n                         ~~~~~~~^~~\n   \
    \                      Int\n/tmp/tmpl79y19m7.swift:47:37: error: cannot call value\
    \ of non-function type 'Int'\n    var bucketMinValue = grid[0][0].min()\n    \
    \                                ^  ~~\n                                     \
    \  \n/tmp/tmpl79y19m7.swift:50:33: error: static member 'min' cannot be used on\
    \ instance of type 'Int'\n    var bucketMaxValue = grid[0][0].min()\n        \
    \                 ~~~~~~~^~~\n                         Int\n/tmp/tmpl79y19m7.swift:50:37:\
    \ error: cannot call value of non-function type 'Int'\n    var bucketMaxValue\
    \ = grid[0][0].min()\n                                    ^  ~~\n            \
    \                           \n/tmp/tmpl79y19m7.swift:53:9: error: invalid redeclaration\
    \ of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpl79y19m7.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpl79y19m7.swift:56:9: error: invalid redeclaration of 'bucketMaxIndex'\n\
    \    var bucketMaxIndex = 0\n        ^\n/tmp/tmpl79y19m7.swift:44:9: note: 'bucketMaxIndex'\
    \ previously declared here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpl79y19m7.swift:59:33:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMinValue = grid[0][0].min()\n                         ~~~~~~~^~~\n   \
    \                      Int"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr2gth4wc/tmpr2gth4wc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83438e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83435d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83435d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83435d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2gth4wc                        0x00005635b128b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8343acd460 __libc_start_main +
    245

    6    tmpr2gth4wc                        0x00005635b128b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    var max = 0\n    var count = 0\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                count += 1\n                if count > max {\n        \
    \            max = count\n                }\n            }\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbadb3e1l/tmpbadb3e1l.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f70176c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6fe6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f6fe6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f6fe6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbadb3e1l                        0x000055a7ee0ce827 <unavailable> + 6183

    5    libc.so.6                          0x00002b8f70362460 __libc_start_main +
    245

    6    tmpbadb3e1l                        0x000055a7ee0ce1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var index = 0\n    for row in grid {\n        for col in row {\n        \
    \    if col == 1 {\n                max += 1\n            }\n        }\n    }\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max -= 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsyu0lxc5/tmpsyu0lxc5.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab67882fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab678526b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab678526988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6785257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsyu0lxc5                        0x000056428db74546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab678a1b460 __libc_start_main +
    245

    6    tmpsyu0lxc5                        0x000056428db740d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid length\n\
    \    var gridLength = grid.count\n    \n    // init bucket length\n    var bucketLength\
    \ = buckets.count\n    \n    // init bucket capacity\n    var bucketCapacity =\
    \ buckets.capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpaepsh4vd.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpaepsh4vd.swift:41:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpaepsh4vd.swift:44:9: error: invalid redeclaration of 'gridIndex'\n\
    \    var gridIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:29:9: note: 'gridIndex'\
    \ previously declared here\n    var gridIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:47:9:\
    \ error: invalid redeclaration of 'gridLength'\n    var gridLength = grid.count\n\
    \        ^\n/tmp/tmpaepsh4vd.swift:32:9: note: 'gridLength' previously declared\
    \ here\n    var gridLength = grid.count\n        ^\n/tmp/tmpaepsh4vd.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpaepsh4vd.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:59:9: error:\
    \ invalid redeclaration of 'gridIndex'\n    var gridIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:29:9:\
    \ note: 'gridIndex' previously declared here\n    var gridIndex = 0\n        ^\n\
    /tmp/tmpaepsh4vd.swift:62:9: error: invalid redeclaration of 'gridLength'\n  \
    \  var gridLength = grid.count\n        ^\n/tmp/tmpaepsh4vd.swift:32:9: note:\
    \ 'gridLength' previously declared here\n    var gridLength = grid.count\n   \
    \     ^\n/tmp/tmpaepsh4vd.swift:71:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:74:9:\
    \ error: invalid redeclaration of 'gridIndex'\n    var gridIndex = 0\n       \
    \ ^\n/tmp/tmpaepsh4vd.swift:29:9: note: 'gridIndex' previously declared here\n\
    \    var gridIndex = 0\n        ^\n/tmp/tmpaepsh4vd.swift:77:9: error: invalid\
    \ redeclaration of 'gridLength'\n    var gridLength = grid.count\n        ^\n\
    /tmp/tmpa"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket length\n    var bucketLength = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsu7lf0hc.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpsu7lf0hc.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpsu7lf0hc.swift:38:9: error: invalid redeclaration of 'bucketLength'\n\
    \    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:29:9: note: 'bucketLength'\
    \ previously declared here\n    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:41:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmpsu7lf0hc.swift:32:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:44:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpsu7lf0hc.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:47:9: error: invalid\
    \ redeclaration of 'bucketLength'\n    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:29:9:\
    \ note: 'bucketLength' previously declared here\n    var bucketLength = 0\n  \
    \      ^\n/tmp/tmpsu7lf0hc.swift:50:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:32:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:53:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpsu7lf0hc.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:56:9: error:\
    \ invalid redeclaration of 'bucketLength'\n    var bucketLength = 0\n        ^\n\
    /tmp/tmpsu7lf0hc.swift:29:9: note: 'bucketLength' previously declared here\n \
    \   var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:59:9: error: invalid\
    \ redeclaration of 'bucketCapacity'\n    var bucketC"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgbry1d1q.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgbry1d1q.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:38:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:41:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:44:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpgbry1d1q.swift:47:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:56:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:59:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var index = 0\n    for row in grid {\n        for col in row {\n        \
    \    if col == 0 {\n                max += 1\n            }\n        }\n    }\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += capacity - col\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpo__iyfpd/tmpo__iyfpd.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab52d6d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52d3c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52d3c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52d3c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo__iyfpd                        0x0000562128253546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab52d8be460 __libc_start_main +
    245

    6    tmpo__iyfpd                        0x00005621282530d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            \n            let bucket = grid[i][j]\n          \
    \  \n            if bucket == 0 {\n                \n                let buckets\
    \ = grid[i].count\n                \n                for _ in 0..<buckets {\n\
    \                    \n                    let bucket = grid[i][j]\n         \
    \           \n                    if bucket == 0 {\n                        \n\
    \                        let buckets = grid[i].count\n                       \
    \ \n                        for _ in 0..<buckets {\n                         \
    \   \n                            let bucket = grid[i][j]\n                  \
    \          \n                            if bucket == 0 {\n                  \
    \              \n                                let buckets = grid[i].count\n\
    \                                \n                                for _ in 0..<buckets\
    \ {\n                                    \n                                  \
    \  let bucket = grid[i][j]\n                                    \n           \
    \                         if bucket == 0 {\n                                 \
    \       \n                                        let buckets = grid[i].count\n\
    \                                        \n                                  \
    \      for _ in 0..<buckets {\n                                            \n\
    \                                            let bucket = grid[i][j]\n       \
    \                                     \n                                     \
    \       if bucket == 0 {\n                                                \n \
    \                                               let buckets = grid[i].count\n\
    \                                                \n                          \
    \                      for _ in 0..<buckets {\n                              \
    \                      \n                                                    let\
    \ bucket = grid[i][j]\n                                                    \n\
    \                                                    if bucket == 0 {\n      \
    \                                                  \n                        \
    \                                let buckets = grid[i].count\n               \
    \                                         \n                                 \
    \                       for _ in 0..<buckets {\n                             \
    \                               \n                                           \
    \                 let bucket = grid[i][j]\n                                  \
    \                          \n                                                \
    \            if bucket == 0 {\n                                              \
    \                  \n                                                        \
    \        let buckets = grid[i].count\n                                       \
    \                         \n                                                 \
    \               for _ in 0..<buckets {\n                                     \
    \                               \n                                           \
    \                         let bucket = grid[i][j]\n                          \
    \                                          \n                                \
    \                                    if bucket == 0 {\n                      \
    \                                                  \n                        \
    \                                                let buckets = grid[i].count\n\
    \                                                                        \n  \
    \                                                                      for _ in\
    \ 0..<buckets {\n                                                            \
    \                \n                                                          \
    \                  let bucket = grid[i][j]\n                                 \
    \                                           \n                               \
    \                                             if bucket == 0 {\n             \
    \                                                                   \n       \
    \                                                                         let\
    \ buckets = grid[i].count\n                                                  \
    \                              \n                                            \
    \                                    for _ in 0..<buckets {\n                \
    \                                                                    \n      \
    \                                                                            \
    \  let bucket = grid[i][j]\n                                                 \
    \                                   \n                                       \
    \                                             if bucket == 0 {\n             \
    \                                                                           \n\
    \                                                                            \
    \            let buckets = grid[i].count\n                                   \
    \                                                     \n                     \
    \                                                                   for _ in 0..<buckets\
    \ {\n                                                                        \
    \                    \n                                                      \
    \                                      let bucket = grid[i][j]\n             \
    \                                                                            \
    \   \n                                                                       \
    \                     if bucket == 0 {\n                                     \
    \                                                           \n               \
    \                                                                            \
    \     let buckets = grid[i].count\n                                          \
    \                                                      \n                    \
    \                                                                            for\
    \ _ in 0..<buckets {\n                                                       \
    \                                             \n                             \
    \                                                                       let bucket\
    \ = grid[i][j]\n                                                             \
    \                                       \n                                   \
    \                                                                 if bucket ==\
    \ 0 {\n                                                                      \
    \                                  \n                                        \
    \                                                                let buckets =\
    \ grid[i].count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppenv4fde.swift:138:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmppenv4fde.swift:112:118:\
    \ note: to match this opening '{'\n                                          \
    \                                                      for _ in 0..<buckets {\n\
    \                                                                            \
    \                                         ^\n/tmp/tmppenv4fde.swift:138:71: error:\
    \ expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)\n                                        \
    \                              ^\n/tmp/tmppenv4fde.swift:108:108: note: to match\
    \ this opening '{'\n                                                         \
    \                                   if bucket == 0 {\n                       \
    \                                                                            \
    \        ^\n/tmp/tmppenv4fde.swift:138:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmppenv4fde.swift:104:110: note: to match this opening '{'\n      \
    \                                                                            \
    \      for _ in 0..<buckets {\n                                              \
    \                                                               ^\n/tmp/tmppenv4fde.swift:138:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmppenv4fde.swift:100:100: note:\
    \ to match this opening '{'\n                                                \
    \                                    if bucket == 0 {\n                      \
    \                                                                            \
    \ ^\n/tmp/tmppenv4fde.swift:138:71: e"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        for col in row {\n     \
    \       if col == 0 {\n                max += 1\n                maxCount += 1\n\
    \            }\n        }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmph3r9he6y/tmph3r9he6y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba41af31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba41ac28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba41ac28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba41ac277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph3r9he6y                        0x000055ce98c06717 <unavailable> + 5911

    5    libc.so.6                          0x00002ba41b11d460 __libc_start_main +
    245

    6    tmph3r9he6y                        0x000055ce98c060d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmphb9756m9.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmphb9756m9.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmphb9756m9.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmphb9756m9.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmphb9756m9.swift:35:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmphb9756m9.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmphb9756m9.swift:38:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmphb9756m9.swift:29:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmphb9756m9.swift:41:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmphb9756m9.swift:32:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmphb9756m9.swift:44:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmphb9756m9.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmphb9756m9.swift:47:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmphb9756m9.swift:29:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmphb9756m9.swift:50:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmphb9756m9.swift:32:9:\
    \ note: 'bucketSum' previously declared here\n    var bucket"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpedqoviwr.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpedqoviwr.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpedqoviwr.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpedqoviwr.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpedqoviwr.swift:38:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpedqoviwr.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpedqoviwr.swift:41:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpedqoviwr.swift:29:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpedqoviwr.swift:44:9: error: invalid redeclaration of 'bucketLength'\n\
    \    var bucketLength = 0\n        ^\n/tmp/tmpedqoviwr.swift:32:9: note: 'bucketLength'\
    \ previously declared here\n    var bucketLength = 0\n        ^\n/tmp/tmpedqoviwr.swift:47:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmpedqoviwr.swift:35:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpedqoviwr.swift:50:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpedqoviwr.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpedqoviwr.swift:53:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpedqoviwr.swift:29:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for row in 0..<n {\n        for\
    \ col in 0..<n {\n            if grid[row][col] == 1 {\n                max +=\
    \ capacity\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnj6ho25w/tmpnj6ho25w.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23afd3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23afa35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23afa35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23afa347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnj6ho25w                        0x00005593da8a5606 <unavailable> + 5638

    5    libc.so.6                          0x00002b23aff2a460 __libc_start_main +
    245

    6    tmpnj6ho25w                        0x00005593da8a5199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         \n                let newCount = grid[row][col] * capacity\n       \
    \         \n                if newCount > max {\n                    max = newCount\n\
    \                    maxCount = 1\n                } else {\n                \
    \    maxCount += 1\n                }\n                \n            }\n     \
    \   }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpucj58avs/tmpucj58avs.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acdc3a2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdc3725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acdc3725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acdc37247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpucj58avs                        0x000055f0c115f827 <unavailable> + 6183

    5    libc.so.6                          0x00002acdc3c1a460 __libc_start_main +
    245

    6    tmpucj58avs                        0x000055f0c115f1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result and buckets\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n    // init\
    \ bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket min sum\n\
    \    var bucketMinSum = 0\n    \n    // init bucket min max\n    var bucketMinMax\
    \ = 0\n    \n    // init bucket min min index\n    var bucketMinMinIndex = 0\n\
    \    \n    // init bucket min min sum\n    var bucketMinMinSum = 0\n    \n   \
    \ // init bucket min min max\n    var bucketMinMinMax = 0\n    \n    // init bucket\
    \ min min min index\n    var bucketMinMinMinIndex = 0\n    \n    // init bucket\
    \ min min min sum\n    var bucketMinMinMinSum = 0\n    \n    // init bucket min\
    \ min min max\n    var bucketMinMinMinMax = 0\n    \n    // init bucket min min\
    \ min min index\n    var bucketMinMinMinMinIndex = 0\n    \n    // init bucket\
    \ min min min min sum\n    var bucketMinMinMinMinSum = 0\n    \n    // init bucket\
    \ min min min min max\n    var bucketMinMinMinMinMax = 0\n    \n    // init bucket\
    \ min min min min min index\n    var bucketMinMinMinMinMinIndex = 0\n    \n  \
    \  // init bucket min min min min min sum\n    var bucketMinMinMinMinMinSum =\
    \ 0\n    \n    // init bucket min min min min min max\n    var bucketMinMinMinMinMinMax\
    \ = 0\n    \n    // init bucket min min min min min min index\n    var bucketMinMinMinMinMinMinIndex\
    \ = 0\n    \n    // init bucket min min min min min min sum\n    var bucketMinMinMinMinMinMinSum\
    \ = 0\n    \n    // init bucket min min min min min min max\n    var bucketMinMinMinMinMinMinMax\
    \ = 0\n    \n    // init bucket min min min min min min min index\n    var bucketMinMinMinMinMinMinMinIndex\
    \ = 0\n    \n    // init bucket min min min min min min min sum\n    var bucketMinMinMinMinMinMinMinMinSum\
    \ = 0\n    \n    // init bucket min min min min min min max\n    var bucketMinMinMinMinMinMinMinMax\
    \ = 0\n    \n    // init bucket min min min min min min min min index\n    var\
    \ bucketMinMinMinMinMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1htvxdck.swift:21:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp1htvxdck.swift:99:9: error: type\
    \ annotation missing in pattern\n    var bucketMinMinMinMinMin\n        ^\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if grid[i][j] == 1 {\n                max += capacity\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp16mplbom/tmp16mplbom.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c7391ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c73611b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c73611988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c736107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16mplbom                        0x00005628df8f3606 <unavailable> + 5638

    5    libc.so.6                          0x00002b0c73b06460 __libc_start_main +
    245

    6    tmp16mplbom                        0x00005628df8f3199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init stack\n    var stack = makeStack(capacity)\n\
    \    \n    // init buckets\n    var buckets = makeBuckets(capacity)\n    \n  \
    \  // init visited\n    var visited = makeBool(capacity)\n    \n    // init index\n\
    \    var index = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n  \
    \  \n    // init index\n    var index = 0\n    \n    // init bucket\n    var bucket\
    \ = buckets[0]\n    \n    // init index\n    var index = 0\n    \n    // init\
    \ bucket\n    var bucket = buckets[0]\n    \n    // init index\n    var index\
    \ = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n\
    \    \n    // init index\n    var index = 0\n    \n    // init bucket\n    var\
    \ bucket = buckets[0]\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init bucket\n    var bucket = buckets[0]\n    \n    // init index\n    var index\
    \ = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n\
    \    \n    // init index\n    var index = 0\n    \n    // init bucket\n    var\
    \ bucket = buckets[0]\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init bucket\n    var bucket = buckets[0]\n    \n    // init index\n    var index\
    \ = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n\
    \    \n    // init index\n    var index = 0\n    \n    // init bucket\n    var\
    \ bucket = buckets[0]\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init bucket\n    var bucket = buckets[0]\n    \n    // init index\n    var index\
    \ = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n\
    \    \n    // init index\n    var index = 0\n    \n    // init bucket\n    var\
    \ bucket = buckets[0]\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init bucket\n    var bucket = buckets[0]\n    \n    // init index\n    var index\
    \ = 0\n    \n    // init bucket\n    var bucket = buckets[0]\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init bucket\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpx4bvsc4a.swift:23:17: error: cannot find 'makeStack' in scope\n\
    \    var stack = makeStack(capacity)\n                ^~~~~~~~~\n/tmp/tmpx4bvsc4a.swift:26:19:\
    \ error: cannot find 'makeBuckets' in scope\n    var buckets = makeBuckets(capacity)\n\
    \                  ^~~~~~~~~~~\n/tmp/tmpx4bvsc4a.swift:29:19: error: cannot find\
    \ 'makeBool' in scope\n    var visited = makeBool(capacity)\n                \
    \  ^~~~~~~~\n/tmp/tmpx4bvsc4a.swift:38:9: error: invalid redeclaration of 'index'\n\
    \    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9: note: 'index' previously\
    \ declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:44:9: error:\
    \ invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:50:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:56:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:62:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:68:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:74:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:80:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:32:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmpx4bvsc4a.swift:86:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                count += max_fill(grid: &row,\
    \ capacity: capacity)\n            }\n        }\n    }\n    \n    if count > max\
    \ {\n        max = count\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps3894tn8.swift:25:41: error: '&' used with non-inout argument of\
    \ type '[[Int]]'\n                count += max_fill(grid: &row, capacity: capacity)\n\
    \                                        ^~~~\n                              \
    \          \n/tmp/tmps3894tn8.swift:25:41: error: cannot convert value of type\
    \ '[Int]' to expected argument type '[[Int]]'\n                count += max_fill(grid:\
    \ &row, capacity: capacity)\n                                        ^\n/tmp/tmps3894tn8.swift:25:41:\
    \ note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected\
    \ to be equal\n                count += max_fill(grid: &row, capacity: capacity)\n\
    \                                        ^\n/tmp/tmps3894tn8.swift:25:41: error:\
    \ cannot pass immutable value as inout argument: 'row' is a 'let' constant\n \
    \               count += max_fill(grid: &row, capacity: capacity)\n          \
    \                              ^~~~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max value\n    var bucketMax = 0\n    \n    // init bucket min value\n    var\
    \ bucketMin = grid[0][0].min()\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var\
    \ bucketMax = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = grid[0][0].min()\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n\
    \    // init bucket max value\n    var bucketMax = 0\n    \n    // init bucket\
    \ min value\n    var bucketMin = grid[0][0].min()\n    \n    // init bucket count\n\
    \    var bucketCount = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max value\n    var bucketMax = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = grid[0][0].min()\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max value\n    var bucketMax = 0\n    \n    // init bucket min value\n    var\
    \ bucketMin = grid[0][0].min()\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var\
    \ bucketMax = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpclv8v334.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpclv8v334.swift:35:32: error: cannot\
    \ call value of non-function type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                               ^  ~~\n                                  \n/tmp/tmpclv8v334.swift:35:28:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMin = grid[0][0].min()\n                    ~~~~~~~^~~\n             \
    \       Int\n/tmp/tmpclv8v334.swift:41:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpclv8v334.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpclv8v334.swift:44:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpclv8v334.swift:29:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpclv8v334.swift:47:9: error: invalid\
    \ redeclaration of 'bucketMax'\n    var bucketMax = 0\n        ^\n/tmp/tmpclv8v334.swift:32:9:\
    \ note: 'bucketMax' previously declared here\n    var bucketMax = 0\n        ^\n\
    /tmp/tmpclv8v334.swift:50:28: error: static member 'min' cannot be used on instance\
    \ of type 'Int'\n    var bucketMin = grid[0][0].min()\n                    ~~~~~~~^~~\n\
    \                    Int\n/tmp/tmpclv8v334.swift:50:32: error: cannot call value\
    \ of non-function type 'Int'\n    var bucketMin = grid[0][0].min()\n         \
    \                      ^  ~~\n                                  \n/tmp/tmpclv8v334.swift:53:9:\
    \ error: invalid redeclaration of 'bucketCount'\n    var bucketCount = 0\n   \
    \     ^\n/tmp/tmpclv8v334.swift:38:9: note: 'bucketCount' previously declared\
    \ here\n    var bucketCount = 0\n        ^\n/tmp/tmpclv8v334.swift:56:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpclv8v334.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpclv8v334.swift:59:9: error"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpf5rsai2m.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpf5rsai2m.swift:41:9: error: invalid\
    \ redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity = 0\n      \
    \  ^\n/tmp/tmpf5rsai2m.swift:35:9: note: 'bucketMinCapacity' previously declared\
    \ here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:44:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:38:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:47:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:35:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:38:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:53:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:35:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:56:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:38:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:35:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmpf5rsai2m.swift:62:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmpf5rsai2m.swift:38:9: note: 'bucketMaxCapacity' pr"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var count =\
    \ 0\n        for val in row {\n            if val == 1 {\n                count\
    \ += 1\n            }\n        }\n        if count > max {\n            max =\
    \ count\n            maxCount = 1\n        } else {\n            maxCount *= count\n\
    \        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpdjls_vm0/tmpdjls_vm0.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b85e8922c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85e8619b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b85e8619988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85e86187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdjls_vm0                        0x0000556d1f9a7546 <unavailable> + 5446

    5    libc.so.6                          0x00002b85e8b0e460 __libc_start_main +
    245

    6    tmpdjls_vm0                        0x0000556d1f9a70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.count\
    \ == 0 {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n\
    \    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 0 {\n                grid[i][j] = capacity\n    \
    \            max += capacity\n                maxIndex = (i, j)\n            }\n\
    \        }\n    }\n    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 0 {\n                grid[i][j] = 0\n      \
    \          max -= 1\n                maxIndex = (i, j)\n            }\n      \
    \  }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj3v6t4r5.swift:28:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = capacity\n               \
    \ ~~~~   ^\n/tmp/tmpj3v6t4r5.swift:30:28: error: cannot assign value of type '(Int,\
    \ Int)' to type 'Int'\n                maxIndex = (i, j)\n                   \
    \        ^~~~~~\n/tmp/tmpj3v6t4r5.swift:38:24: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[i][j] = 0\n               \
    \ ~~~~   ^\n/tmp/tmpj3v6t4r5.swift:40:28: error: cannot assign value of type '(Int,\
    \ Int)' to type 'Int'\n                maxIndex = (i, j)\n                   \
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init wells\n    var wells = make([][]int, grid.length)\n\
    \    \n    // init wells index\n    var wellsIndex = 0\n    \n    // init buckets\
    \ index\n    var bucketsIndex = 0\n    \n    // init grid index\n    var gridIndex\
    \ = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n   \
    \ \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n  \
    \  var grid = make([][]int, grid.length)\n    \n    // init grid index\n    var\
    \ gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \    var grid = make([][]int, grid.length)\n    \n    // init grid index\n   \
    \ var gridIndex = 0\n    \n    // init grid\n    var grid = make([][]int, grid.length)\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init grid\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphlgzcqcj.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmphlgzcqcj.swift:26:26: error: expected ',' separator\n   \
    \ var wells = make([][]int, grid.length)\n                         ^\n       \
    \                  ,\n/tmp/tmphlgzcqcj.swift:38:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:44:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:50:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:56:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:62:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:68:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:74:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:80:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:86:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:92:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:98:25: error: expected ',' separator\n\
    \    var grid = make([][]int, grid.length)\n                        ^\n      \
    \                  ,\n/tmp/tmphlgzcqcj.swift:104:25: error:"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket min value\n   \
    \ var bucketMinValue = grid[0][0]\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgflv28de.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgflv28de.swift:44:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:47:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:68:9: erro"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        for col in row {\n     \
    \       if col == 0 {\n                max += 1\n                maxCount += 1\n\
    \            }\n        }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmph3r9he6y/tmph3r9he6y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba41af31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba41ac28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba41ac28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba41ac277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph3r9he6y                        0x000055ce98c06717 <unavailable> + 5911

    5    libc.so.6                          0x00002ba41b11d460 __libc_start_main +
    245

    6    tmph3r9he6y                        0x000055ce98c060d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var count\
    \ = 0\n    \n    for row in grid {\n        var max = 0\n        for cell in row\
    \ {\n            if cell > max {\n                max = cell\n            }\n\
    \        }\n        \n        for cell in row {\n            if cell > max {\n\
    \                cell = max\n            }\n        }\n        \n        count\
    \ += max == 0 ? 0 : max\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdogxny_v.swift:31:17: error: cannot assign to value: 'cell' is\
    \ a 'let' constant\n                cell = max\n                ^~~~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                result += 1\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpoe12wf93/tmpoe12wf93.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af46dfa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af46dc9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af46dc9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af46dc997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoe12wf93                        0x000055909e738717 <unavailable> + 5911

    5    libc.so.6                          0x00002af46e18f460 __libc_start_main +
    245

    6    tmpoe12wf93                        0x000055909e7380d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n \
    \   \n    // init bucket min value\n    var bucketMin = IntMax\n    \n    // init\
    \ bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMaxIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMaxIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMaxIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMaxIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMaxIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMaxIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk_6c0itp.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpk_6c0itp.swift:41:21: error: cannot\
    \ find 'IntMax' in scope\n    var bucketMin = IntMax\n                    ^~~~~~\n\
    /tmp/tmpk_6c0itp.swift:50:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:44:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:53:9:\
    \ error: invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n\
    \        ^\n/tmp/tmpk_6c0itp.swift:47:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:47:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:47:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:68:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpk_6c0itp.swift:71:9: error:\
    \ invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n    \
    \    ^\n/tmp/tmpk_6c0itp.swift:47:"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty()\
    \ {\n        return 0\n    }\n    var max = 0\n    var maxIndex = 0\n    var index\
    \ = 0\n    var row = 0\n    var col = 0\n    for row in 0..<grid.count {\n   \
    \     for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n\
    \                grid[row][col] = 0\n                max = max(max, index - capacity)\n\
    \                maxIndex = max(maxIndex, index)\n                index++\n  \
    \          }\n        }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk6451up8.swift:18:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpk6451up8.swift:29:26: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[row][col] = 0\n           \
    \     ~~~~     ^\n/tmp/tmpk6451up8.swift:30:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, index - capacity)\n             \
    \         ^\n/tmp/tmpk6451up8.swift:31:28: error: cannot call value of non-function\
    \ type 'Int'\n                maxIndex = max(maxIndex, index)\n              \
    \             ^\n/tmp/tmpk6451up8.swift:32:22: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                index++\n                  \
    \   ^~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init grid\n    var gridCopy = make([][]int, capacity)\n\
    \    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n        gridCopy\
    \ = append(gridCopy, make([]int, capacity))\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n    }\n    \n    // init gridCopy\n    for i := 0; i < capacity; i++ {\n\
    \        gridCopy[i] = append(gridCopy[i], 0)\n    }\n    \n    // init gridCopy\n\
    \    for i := 0; i < capacity; i++ {\n        gridCopy[i] = append(gridCopy[i],\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
    \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1,\
    \ 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_4hk3slc.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp_4hk3slc.swift:26:29: error: expected ',' separator\n   \
    \ var gridCopy = make([][]int, capacity)\n                            ^\n    \
    \                        ,\n/tmp/tmp_4hk3slc.swift:29:12: error: expected type\n\
    \    for i := 0; i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmp_4hk3slc.swift:29:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmp_4hk3slc.swift:29:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp_4hk3slc.swift:30:44:\
    \ error: expected ',' separator\n        gridCopy = append(gridCopy, make([]int,\
    \ capacity))\n                                           ^\n                 \
    \                          ,\n/tmp/tmp_4hk3slc.swift:34:12: error: expected type\n\
    \    for i := 0; i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmp_4hk3slc.swift:34:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmp_4hk3slc.swift:34:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp_4hk3slc.swift:39:12:\
    \ error: expected type\n    for i := 0; i < capacity; i++ {\n           ^\n  \
    \          <#type#>\n/tmp/tmp_4hk3slc.swift:39:12: error: expected 'in' after\
    \ for-each pattern\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp_4hk3slc.swift:39:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < capacity;\
    \ i++ {\n           ^\n/tmp/tmp_4hk3slc.swift:44:12: error: expected type\n  \
    \  for i := 0; i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmp_4hk3slc.swift:44:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmp_4hk3slc.swift:44:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init well count\n    var wellCount = 0\n    \n    //\
    \ init bucket count\n    var bucketCount = 0\n    \n    // init well count\n \
    \   var wellCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n\
    \    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket count\n    var bucketCount = 0\n    \n    // init bucket count\n    var\
    \ bucketCount = 0\n    \n    // init bucket count\n    var bucketCount = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_6eskudm.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp_6eskudm.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp_6eskudm.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp_6eskudm.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp_6eskudm.swift:32:9:\
    \ error: invalid redeclaration of 'wellCount'\n    var wellCount = 0\n       \
    \ ^\n/tmp/tmp_6eskudm.swift:26:9: note: 'wellCount' previously declared here\n\
    \    var wellCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:35:9: error: invalid\
    \ redeclaration of 'bucketCount'\n    var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:29:9:\
    \ note: 'bucketCount' previously declared here\n    var bucketCount = 0\n    \
    \    ^\n/tmp/tmp_6eskudm.swift:38:9: error: invalid redeclaration of 'bucketCount'\n\
    \    var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:29:9: note: 'bucketCount'\
    \ previously declared here\n    var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:41:9:\
    \ error: invalid redeclaration of 'bucketCount'\n    var bucketCount = 0\n   \
    \     ^\n/tmp/tmp_6eskudm.swift:29:9: note: 'bucketCount' previously declared\
    \ here\n    var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:44:9: error:\
    \ invalid redeclaration of 'bucketCount'\n    var bucketCount = 0\n        ^\n\
    /tmp/tmp_6eskudm.swift:29:9: note: 'bucketCount' previously declared here\n  \
    \  var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:47:9: error: invalid\
    \ redeclaration of 'bucketCount'\n    var bucketCount = 0\n        ^\n/tmp/tmp_6eskudm.swift:29:9:\
    \ note: 'bucketCount' previously declared here\n    var bucketCount = 0\n    \
    \    "
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var\
    \ bucketMax = 0\n    \n    // init bucket min value\n    var bucketMin = IntMax\n\
    \    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    //\
    \ init bucket min value\n    var bucketMinValue = IntMax\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = IntMax\n    \n    // init bucket min value\n\
    \    var bucketMinValue = IntMax\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = IntMax\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = IntMax\n    \n    // init bucket min index\n    var bucketMinIndex = IntMax\n\
    \    \n    // init bucket min value\n    var bucketMinValue = IntMax\n    \n \
    \   // init bucket min index\n    var bucketMinIndex = IntMax\n    \n    // init\
    \ bucket min value\n    var bucketMinValue = IntMax\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = IntMax\n    \n    // init bucket min value\n\
    \    var bucketMinValue = IntMax\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = IntMax\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = IntMax\n    \n    // init bucket min index\n    var bucketMinIndex = IntMax\n\
    \    \n    // init bucket min value\n    var bucketMinValue = IntMax\n    \n \
    \   // init bucket min index\n    var bucketMinIndex = IntMax\n    \n    // init\
    \ bucket min value\n    var bucketMinValue = IntMax\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = IntMax\n    \n    // init bucket min value\n\
    \    var bucketMinValue = IntMax\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = IntMax\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = IntMax\n    \n    // init bucket min index\n    var bucketMinIndex = IntMax\n\
    \    \n    // init bucket min value\n    var bucketMinValue = IntMax\n    \n \
    \   // init bucket min index\n    var bucketMinIndex = IntMax\n    \n    // init\
    \ bucket min value\n    var bucketMinValue = IntMax\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = IntMax\n    \n    // init bucket min value\n\
    \    var bucketMinValue = IntMax\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpau9zs66z.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpau9zs66z.swift:38:21: error: cannot\
    \ find 'IntMax' in scope\n    var bucketMin = IntMax\n                    ^~~~~~\n\
    /tmp/tmpau9zs66z.swift:44:26: error: cannot find 'IntMax' in scope\n    var bucketMinValue\
    \ = IntMax\n                         ^~~~~~\n/tmp/tmpau9zs66z.swift:47:26: error:\
    \ cannot find 'IntMax' in scope\n    var bucketMinIndex = IntMax\n           \
    \              ^~~~~~\n/tmp/tmpau9zs66z.swift:50:26: error: cannot find 'IntMax'\
    \ in scope\n    var bucketMinValue = IntMax\n                         ^~~~~~\n\
    /tmp/tmpau9zs66z.swift:53:26: error: cannot find 'IntMax' in scope\n    var bucketMinIndex\
    \ = IntMax\n                         ^~~~~~\n/tmp/tmpau9zs66z.swift:56:26: error:\
    \ cannot find 'IntMax' in scope\n    var bucketMinValue = IntMax\n           \
    \              ^~~~~~\n/tmp/tmpau9zs66z.swift:59:26: error: cannot find 'IntMax'\
    \ in scope\n    var bucketMinIndex = IntMax\n                         ^~~~~~\n\
    /tmp/tmpau9zs66z.swift:62:26: error: cannot find 'IntMax' in scope\n    var bucketMinValue\
    \ = IntMax\n                         ^~~~~~\n/tmp/tmpau9zs66z.swift:65:26: error:\
    \ cannot find 'IntMax' in scope\n    var bucketMinIndex = IntMax\n           \
    \              ^~~~~~\n/tmp/tmpau9zs66z.swift:68:26: error: cannot find 'IntMax'\
    \ in scope\n    var bucketMinValue = IntMax\n                         ^~~~~~\n\
    /tmp/tmpau9zs66z.swift:71:26: error: cannot find 'IntMax' in scope\n    var bucketMinIndex\
    \ = IntMax\n                         ^~~~~~\n/tmp/tmpau9zs66z.swift:74:26: error:\
    \ cannot find 'IntMax' in scope\n    var bucketMinValue = IntMax\n           \
    \              ^~~~~~\n/tmp/tmpau9zs66z.swift:77:26: error: cannot find 'IntMax'\
    \ in scope\n    var bucketMinIndex = IntMax\n                         ^~~~~~\n\
    /tmp/tmpau9zs66z.swift:80:26: error: cannot find 'IntMax' in scope\n    var bucketMinValue\
    \ = IntMax\n                         ^~~~~~\n/tmp/tmpau9zs66z.swift:83:26: error:\
    \ cann"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max = 0\n    for row in grid {\n        for col in row {\n    \
    \        if col == 0 {\n                max += 1\n            }\n        }\n \
    \   }\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                result += max - capacity\n            }\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxlw7tzi1/tmpxlw7tzi1.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e8b4d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e8b1c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e8b1c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e8b1c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxlw7tzi1                        0x000055805fc18546 <unavailable> + 5446

    5    libc.so.6                          0x00002b8e8b6be460 __libc_start_main +
    245

    6    tmpxlw7tzi1                        0x000055805fc180d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket length\n    var bucketLength = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsu7lf0hc.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpsu7lf0hc.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpsu7lf0hc.swift:38:9: error: invalid redeclaration of 'bucketLength'\n\
    \    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:29:9: note: 'bucketLength'\
    \ previously declared here\n    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:41:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmpsu7lf0hc.swift:32:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:44:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpsu7lf0hc.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:47:9: error: invalid\
    \ redeclaration of 'bucketLength'\n    var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:29:9:\
    \ note: 'bucketLength' previously declared here\n    var bucketLength = 0\n  \
    \      ^\n/tmp/tmpsu7lf0hc.swift:50:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:32:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:53:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpsu7lf0hc.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:56:9: error:\
    \ invalid redeclaration of 'bucketLength'\n    var bucketLength = 0\n        ^\n\
    /tmp/tmpsu7lf0hc.swift:29:9: note: 'bucketLength' previously declared here\n \
    \   var bucketLength = 0\n        ^\n/tmp/tmpsu7lf0hc.swift:59:9: error: invalid\
    \ redeclaration of 'bucketCapacity'\n    var bucketC"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        for col in row {\n     \
    \       if col > 0 {\n                max += col\n                maxCount++\n\
    \            }\n        }\n    }\n    if maxCount > capacity {\n        return\
    \ -1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpga4ugfwe.swift:24:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                maxCount++\n                        ^~\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init well count\n    var wellCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket max index\n    var\
    \ bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpt_oi5oh0.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpt_oi5oh0.swift:53:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:47:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpt_oi5oh0.swift:56:9: error: invalid redeclaration of 'bucketMinValue'\n\
    \    var bucketMinValue = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:50:9: note: 'bucketMinValue'\
    \ previously declared here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpt_oi5oh0.swift:47:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpt_oi5oh0.swift:50:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpt_oi5oh0.swift:47:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:68:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpt_oi5oh0.swift:50:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:71:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpt_oi5oh0.swift:47:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:74:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpt_oi5oh0.swift:50:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpt_oi5oh0.swift:77:9: erro"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init index\n\
    \    var index = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max\n    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n \
    \   // init bucket min\n    var bucketMin = 0\n    \n    // init bucket count\n\
    \    var bucketCount = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max\n    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n \
    \   // init bucket min\n    var bucketMin = 0\n    \n    // init bucket count\n\
    \    var bucketCount = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max\n    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n \
    \   // init bucket min\n    var bucketMin = 0\n    \n    // init bucket count\n\
    \    var bucketCount = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max\n    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n \
    \   // init \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmph4baecpj.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmph4baecpj.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmph4baecpj.swift:47:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmph4baecpj.swift:32:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmph4baecpj.swift:50:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmph4baecpj.swift:35:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmph4baecpj.swift:53:9: error: invalid redeclaration of 'bucketMax'\n   \
    \ var bucketMax = 0\n        ^\n/tmp/tmph4baecpj.swift:38:9: note: 'bucketMax'\
    \ previously declared here\n    var bucketMax = 0\n        ^\n/tmp/tmph4baecpj.swift:56:9:\
    \ error: invalid redeclaration of 'bucketMin'\n    var bucketMin = 0\n       \
    \ ^\n/tmp/tmph4baecpj.swift:41:9: note: 'bucketMin' previously declared here\n\
    \    var bucketMin = 0\n        ^\n/tmp/tmph4baecpj.swift:59:9: error: invalid\
    \ redeclaration of 'bucketCount'\n    var bucketCount = 0\n        ^\n/tmp/tmph4baecpj.swift:44:9:\
    \ note: 'bucketCount' previously declared here\n    var bucketCount = 0\n    \
    \    ^\n/tmp/tmph4baecpj.swift:62:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmph4baecpj.swift:32:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmph4baecpj.swift:65:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmph4baecpj.swift:35:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmph4baecpj.swift:68:9: error: invalid\
    \ redeclaration of 'bucketMax'\n    var bucketMax = 0\n        ^\n/tmp/tmph4baecpj.swift:38:9:\
    \ note: 'bucketMax' previously declared here\n    var bucketMax = 0\n  "
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init grid length\n    var gridLength = grid.count\n    \n    //\
    \ init bucket length\n    var bucketLength = buckets.count\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = buckets.capacity\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_r49g4ju.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp_r49g4ju.swift:38:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmp_r49g4ju.swift:41:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:44:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:47:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:50:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmp_r49g4ju.swift:53:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:59:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmp_r49g4ju.swift:26:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swift:62:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmp_r49g4ju.swi"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                \n                let newCount = grid[row][col] + 1\n \
    \               \n                if newCount > max {\n                    max\
    \ = newCount\n                    maxCount = 1\n                    maxIndex =\
    \ row\n                } else {\n                    maxCount += 1\n         \
    \       }\n            }\n        }\n    }\n    \n    return maxCount\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp682ly6r8/tmp682ly6r8.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ea5481c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ea5178b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ea5178988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ea51777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp682ly6r8                        0x00005639f812c827 <unavailable> + 6183

    5    libc.so.6                          0x00002b7ea566d460 __libc_start_main +
    245

    6    tmp682ly6r8                        0x00005639f812c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqf4r26_8/tmpqf4r26_8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae092ef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae092be8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae092be8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae092be77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqf4r26_8                        0x0000557950b10717 <unavailable> + 5911

    5    libc.so.6                          0x00002ae0930dd460 __libc_start_main +
    245

    6    tmpqf4r26_8                        0x0000557950b100d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr2gth4wc/tmpr2gth4wc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83438e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83435d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83435d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83435d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2gth4wc                        0x00005635b128b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8343acd460 __libc_start_main +
    245

    6    tmpr2gth4wc                        0x00005635b128b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](grid.count)\n    \n    // init\
    \ buckets index\n    var bucketsIndex = 0\n    \n    // init wells index\n   \
    \ var wellsIndex = 0\n    \n    // init max wells index\n    var maxWellsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var maxBucketsIndex = 0\n    \n    // init max\
    \ wells index\n    var maxBucketsIndex = 0\n    \n    // init max wells index\n\
    \    var maxBucketsIndex = 0\n    \n    // init max wells index\n    var maxBucketsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var maxBucketsIndex = 0\n    \n    // init max\
    \ wells index\n    var maxBucketsIndex = 0\n    \n    // init max wells index\n\
    \    var maxBucketsIndex = 0\n    \n    // init max wells index\n    var maxBucketsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var maxBucketsIndex = 0\n    \n    // init max\
    \ wells index\n    var maxBucketsIndex = 0\n    \n    // init max wells index\n\
    \    var maxBucketsIndex = 0\n    \n    // init max wells index\n    var maxBucketsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var maxBucketsIndex = 0\n    \n    // init max\
    \ wells index\n    var maxBucketsIndex = 0\n    \n    // init max wells index\n\
    \    var maxBucketsIndex = 0\n    \n    // init max wells index\n    var maxBucketsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var maxBucketsIndex = 0\n    \n    // init max\
    \ wells index\n    var maxBucketsIndex = 0\n    \n    // init max wells index\n\
    \    var maxBucketsIndex = 0\n    \n    // init max wells index\n    var maxBucketsIndex\
    \ = 0\n    \n    // init max wells index\n    var maxBucketsIndex = 0\n    \n\
    \    // init max wells index\n    var max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp64mcuapg.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp64mcuapg.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](grid.count)\n\
    \                      ^\n                      arrayLiteral: \n/tmp/tmp64mcuapg.swift:41:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:44:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:47:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:50:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:53:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:56:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:59:9:\
    \ error: invalid redeclaration of 'maxBucketsIndex'\n    var maxBucketsIndex =\
    \ 0\n        ^\n/tmp/tmp64mcuapg.swift:38:9: note: 'maxBucketsIndex' previously\
    \ declared here\n    var maxBucketsIndex = 0\n        ^\n/tmp/tmp64mcuapg.swift:62:9:\
    \ error: invalid redeclarati"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr2gth4wc/tmpr2gth4wc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83438e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83435d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83435d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83435d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2gth4wc                        0x00005635b128b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8343acd460 __libc_start_main +
    245

    6    tmpr2gth4wc                        0x00005635b128b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        for col in row {\n     \
    \       if col == 0 {\n                max += 1\n            }\n            if\
    \ col > 0 {\n                maxCount = max(maxCount, maxCount(grid, col, capacity))\n\
    \            }\n        }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6ce_cede.swift:26:28: error: cannot call value of non-function\
    \ type 'Int'\n                maxCount = max(maxCount, maxCount(grid, col, capacity))\n\
    \                           ^\n/tmp/tmp6ce_cede.swift:26:42: error: cannot call\
    \ value of non-function type 'Int'\n                maxCount = max(maxCount, maxCount(grid,\
    \ col, capacity))\n                                         ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgbry1d1q.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgbry1d1q.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:38:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:41:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:44:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpgbry1d1q.swift:47:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:56:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:59:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        var maxCount = 0\n        \n        for _ in 0..<n {\n            \n\
    \            let bucket = grid[Int(arc4random_uniform(UInt32(n)))]\n         \
    \   \n            if bucket == 1 {\n                \n                maxCount\
    \ = maxCount + 1\n                \n                if maxCount > max {\n    \
    \                max = maxCount\n                }\n            }\n        }\n\
    \    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj_u7xjva.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))]\n \
    \                                 ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     \n                let newCapacity = capacity - grid[row][col]\n        \
    \        \n                if newCapacity > max {\n                    max = newCapacity\n\
    \                    count = 0\n                }\n                \n        \
    \        grid[row][col] = 0\n                \n                count += 1\n  \
    \          }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp420if74x.swift:33:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init stack\n    var stack = [Int]()\n\
    \    \n    // init stack\n    var stack2 = [Int]()\n    \n    // init visited\n\
    \    var visited = [Bool]()\n    \n    // init visited\n    var visited2 = [Bool]()\n\
    \    \n    // init visited\n    var visited3 = [Bool]()\n    \n    // init visited\n\
    \    var visited4 = [Bool]()\n    \n    // init visited\n    var visited5 = [Bool]()\n\
    \    \n    // init visited\n    var visited6 = [Bool]()\n    \n    // init visited\n\
    \    var visited7 = [Bool]()\n    \n    // init visited\n    var visited8 = [Bool]()\n\
    \    \n    // init visited\n    var visited9 = [Bool]()\n    \n    // init visited\n\
    \    var visited10 = [Bool]()\n    \n    // init visited\n    var visited11 =\
    \ [Bool]()\n    \n    // init visited\n    var visited12 = [Bool]()\n    \n  \
    \  // init visited\n    var visited13 = [Bool]()\n    \n    // init visited\n\
    \    var visited14 = [Bool]()\n    \n    // init visited\n    var visited15 =\
    \ [Bool]()\n    \n    // init visited\n    var visited16 = [Bool]()\n    \n  \
    \  // init visited\n    var visited17 = [Bool]()\n    \n    // init visited\n\
    \    var visited18 = [Bool]()\n    \n    // init visited\n    var visited19 =\
    \ [Bool]()\n    \n    // init visited\n    var visited20 = [Bool]()\n    \n  \
    \  // init visited\n    var visited21 = [Bool]()\n    \n    // init visited\n\
    \    var visited22 = [Bool]()\n    \n    // init visited\n    var visited23 =\
    \ [Bool]()\n    \n    // init visited\n    var visited24 = [Bool]()\n    \n  \
    \  // init visited\n    var visited25 = [Bool]()\n    \n    // init visited\n\
    \    var visited26 = [Bool]()\n    \n    // init visited\n    var visited27 =\
    \ [Bool]()\n    \n    // init visited\n    var visited28 = [Bool]()\n    \n  \
    \  // init visited\n    var visited29 = [Bool]()\n    \n    // init visited\n\
    \    var visited30 = [Bool]()\n    \n    // init visite\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpn270minz.swift:20:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmpn270minz.swift:23:9: warning:\
    \ initialization of variable 'stack' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var stack = [Int]()\n    ~~~~^~~~~\n    _\n/tmp/tmpn270minz.swift:26:9:\
    \ warning: initialization of variable 'stack2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var stack2 = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpn270minz.swift:29:9: warning: initialization of variable 'visited'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var visited = [Bool]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpn270minz.swift:32:9:\
    \ warning: initialization of variable 'visited2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var visited2 = [Bool]()\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpn270minz.swift:35:9: warning: initialization of variable 'visited3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var visited3 = [Bool]()\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpn270minz.swift:38:9:\
    \ warning: initialization of variable 'visited4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var visited4 = [Bool]()\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpn270minz.swift:41:9: warning: initialization of variable 'visited5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var visited5 = [Bool]()\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpn270minz.swift:44:9:\
    \ warning: initialization of variable 'visited6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var visited6 = [Bool]()\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpn270minz.swift:47:9: warning: initialization of variable 'visited7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var visited7 = [Bool]()\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpn270minz.swift:50:9:\
    \ warning: initialization of variable 'visited8' was n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init empty buckets\n    var emptyBuckets = [Int](capacity)\n   \
    \ \n    // init empty wells\n    var emptyWells = [Int](capacity)\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n    \n    // init empty buckets\n    var emptyBucketsCount\
    \ = 0\n    \n    // init empty wells\n    var emptyWellsCount = 0\n    \n    //\
    \ init empty buckets\n    var emptyBucketsCount = 0\n    \n    // init empty wells\n\
    \    var emptyWellsCount = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpea9t7l9o.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpea9t7l9o.swift:26:30: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var emptyBuckets = [Int](capacity)\n\
    \                             ^\n                             arrayLiteral: \n\
    /tmp/tmpea9t7l9o.swift:29:28: error: missing argument label 'arrayLiteral:' in\
    \ call\n    var emptyWells = [Int](capacity)\n                           ^\n \
    \                          arrayLiteral: \n/tmp/tmpea9t7l9o.swift:38:9: error:\
    \ invalid redeclaration of 'emptyBucketsCount'\n    var emptyBucketsCount = 0\n\
    \        ^\n/tmp/tmpea9t7l9o.swift:32:9: note: 'emptyBucketsCount' previously\
    \ declared here\n    var emptyBucketsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:41:9:\
    \ error: invalid redeclaration of 'emptyWellsCount'\n    var emptyWellsCount =\
    \ 0\n        ^\n/tmp/tmpea9t7l9o.swift:35:9: note: 'emptyWellsCount' previously\
    \ declared here\n    var emptyWellsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:44:9:\
    \ error: invalid redeclaration of 'emptyBucketsCount'\n    var emptyBucketsCount\
    \ = 0\n        ^\n/tmp/tmpea9t7l9o.swift:32:9: note: 'emptyBucketsCount' previously\
    \ declared here\n    var emptyBucketsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:47:9:\
    \ error: invalid redeclaration of 'emptyWellsCount'\n    var emptyWellsCount =\
    \ 0\n        ^\n/tmp/tmpea9t7l9o.swift:35:9: note: 'emptyWellsCount' previously\
    \ declared here\n    var emptyWellsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:50:9:\
    \ error: invalid redeclaration of 'emptyBucketsCount'\n    var emptyBucketsCount\
    \ = 0\n        ^\n/tmp/tmpea9t7l9o.swift:32:9: note: 'emptyBucketsCount' previously\
    \ declared here\n    var emptyBucketsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:53:9:\
    \ error: invalid redeclaration of 'emptyWellsCount'\n    var emptyWellsCount =\
    \ 0\n        ^\n/tmp/tmpea9t7l9o.swift:35:9: note: 'emptyWellsCount' previously\
    \ declared here\n    var emptyWellsCount = 0\n        ^\n/tmp/tmpea9t7l9o.swift:56:9:\
    \ error: invalid redeclara"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](grid.count)\n    \n    // init\
    \ well count\n    var wellCount = 0\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = 0\n    \n    //\
    \ init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2wqdghqw.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp2wqdghqw.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](grid.count)\n\
    \                      ^\n                      arrayLiteral: \n/tmp/tmp2wqdghqw.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmp2wqdghqw.swift:41:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmp2wqdghqw.swift:53:9: error: invalid\
    \ redeclaration of 'bucketMin'\n    var bucketMin = 0\n        ^\n/tmp/tmp2wqdghqw.swift:47:9:\
    \ note: 'bucketMin' previously declared here\n    var bucketMin = 0\n        ^\n\
    /tmp/tmp2wqdghqw.swift:56:9: error: invalid redeclaration of 'bucketMax'\n   \
    \ var bucketMax = 0\n        ^\n/tmp/tmp2wqdghqw.swift:44:9: note: 'bucketMax'\
    \ previously declared here\n    var bucketMax = 0\n        ^\n/tmp/tmp2wqdghqw.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMin'\n    var bucketMin = 0\n       \
    \ ^\n/tmp/tmp2wqdghqw.swift:47:9: note: 'bucketMin' previously declared here\n\
    \    var bucketMin = 0\n        ^\n/tmp/tmp2wqdghqw.swift:62:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp2wqdghqw.swift:41:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp2wqdghqw.swift:65:9: error: invalid redeclaration of 'bucketMin'\n   \
    \ var bucketMin = 0\n        ^\n/tmp/tmp2wqdghqw.swift:47:9: note: 'bucketMin'\
    \ previously declared here\n    var bucketMin = 0\n        ^\n/tmp/tmp2wqdghqw.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMax'\n    var bucketMax = 0\n       \
    \ ^\n/tmp/tmp2wqdghqw.swift:44:9: note: 'bucketMax' previously declared here\n\
    \    var bucketMax = 0\n        ^\n/tmp/tmp2wqdghqw.swift:71:9: error: invalid\
    \ redeclaration of 'bucketMin'\n    var bucketMin = 0\n        ^\n/tmp/tmp2wqdghqw.swift:47:9:\
    \ note: 'bucketMin' previously declared here\n    var bucketMin = 0\n        ^\n\
    /tmp/tmp2wqdgh"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppjft4drp.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmppjft4drp.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:38:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:41:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:56:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:59:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.count\
    \ == 0 {\n        return 0\n    }\n    var max = 0\n    var maxIndex = 0\n   \
    \ var maxVal = grid[0][0]\n    for i := 0; i < grid.count; i++ {\n        for\
    \ j := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] > maxVal {\n\
    \                maxVal = grid[i][j]\n                maxIndex = i\n         \
    \   }\n        }\n    }\n    for i := 0; i < grid.count; i++ {\n        for j\
    \ := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] == maxVal {\n \
    \               grid[maxIndex][j] = 0\n            }\n        }\n    }\n    for\
    \ i := 0; i < grid.count; i++ {\n        for j := 0; j < grid[0][i].count; j++\
    \ {\n            if grid[i][j] == maxVal {\n                grid[i][j] = 0\n \
    \           }\n        }\n    }\n    for i := 0; i < grid.count; i++ {\n     \
    \   for j := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] == maxVal\
    \ {\n                grid[i][j] = 0\n            }\n        }\n    }\n    for\
    \ i := 0; i < grid.count; i++ {\n        for j := 0; j < grid[0][i].count; j++\
    \ {\n            if grid[i][j] == maxVal {\n                grid[i][j] = 0\n \
    \           }\n        }\n    }\n    for i := 0; i < grid.count; i++ {\n     \
    \   for j := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] == maxVal\
    \ {\n                grid[i][j] = 0\n            }\n        }\n    }\n    for\
    \ i := 0; i < grid.count; i++ {\n        for j := 0; j < grid[0][i].count; j++\
    \ {\n            if grid[i][j] == maxVal {\n                grid[i][j] = 0\n \
    \           }\n        }\n    }\n    for i := 0; i < grid.count; i++ {\n     \
    \   for j := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] == maxVal\
    \ {\n                grid[i][j] = 0\n            }\n        }\n    }\n    for\
    \ i := 0; i < grid.count; i++ {\n        for j := 0; j < grid[0][i].count; j++\
    \ {\n            if grid[i][j] == maxVal {\n                grid[i][j] = 0\n \
    \           }\n        }\n    }\n    for i := 0; i < grid.count; i++ {\n     \
    \   for j := 0; j < grid[0][i].count; j++ {\n            if grid[i][j] == maxVal\
    \ {\n                grid[i][j] = 0\n            }\n        }\n    }\n    for\
    \ i := 0; i < grid.count; i++ {\n        for j := 0; j < grid[0][i].count; j++\
    \ {\n            if grid[i][j] == maxVal {\n                grid[i][j] = 0\n \
    \           }\n        }\n    }\n    for i \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjew6k_bs.swift:24:12: error: expected type\n    for i := 0; i <\
    \ grid.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpjew6k_bs.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < grid.count;\
    \ i++ {\n           ^\n/tmp/tmpjew6k_bs.swift:24:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < grid.count; i++ {\n      \
    \     ^\n/tmp/tmpjew6k_bs.swift:25:16: error: expected type\n        for j :=\
    \ 0; j < grid[0][i].count; j++ {\n               ^\n                <#type#>\n\
    /tmp/tmpjew6k_bs.swift:25:16: error: expected 'in' after for-each pattern\n  \
    \      for j := 0; j < grid[0][i].count; j++ {\n               ^\n/tmp/tmpjew6k_bs.swift:25:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < grid[0][i].count; j++ {\n               ^\n/tmp/tmpjew6k_bs.swift:32:12: error:\
    \ expected type\n    for i := 0; i < grid.count; i++ {\n           ^\n       \
    \     <#type#>\n/tmp/tmpjew6k_bs.swift:32:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < grid.count; i++ {\n           ^\n/tmp/tmpjew6k_bs.swift:32:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < grid.count;\
    \ i++ {\n           ^\n/tmp/tmpjew6k_bs.swift:33:16: error: expected type\n  \
    \      for j := 0; j < grid[0][i].count; j++ {\n               ^\n           \
    \     <#type#>\n/tmp/tmpjew6k_bs.swift:33:16: error: expected 'in' after for-each\
    \ pattern\n        for j := 0; j < grid[0][i].count; j++ {\n               ^\n\
    /tmp/tmpjew6k_bs.swift:33:16: error: expected Sequence expression for for-each\
    \ loop\n        for j := 0; j < grid[0][i].count; j++ {\n               ^\n/tmp/tmpjew6k_bs.swift:39:12:\
    \ error: expected type\n    for i := 0; i < grid.count; i++ {\n           ^\n\
    \            <#type#>\n/tmp/tmpjew6k_bs.swift:39:12: error: expected 'in' after\
    \ for-each pattern\n    for i := 0; i < grid.count; i++ {\n           ^\n/tmp/tmpjew6k_bs.swift:39:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < grid.count;\
    \ i++ {\n           ^\n/tmp/tmpjew6k_bs.swift:40:16: error: expe"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > max {\n\
    \                max = count\n            }\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpks35kqds/tmpks35kqds.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0401351c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0401048b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0401048988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04010477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpks35kqds                        0x000055a74639b546 <unavailable> + 5446

    5    libc.so.6                          0x00002b040153d460 __libc_start_main +
    245

    6    tmpks35kqds                        0x000055a74639b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var count =\
    \ 0\n        for cell in row {\n            if cell == 1 {\n                count\
    \ += 1\n            }\n        }\n        if count > max {\n            max =\
    \ count\n            maxCount = 1\n        } else {\n            maxCount *= count\n\
    \        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpvbobuxbf/tmpvbobuxbf.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7748dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7745d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7745d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7745d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvbobuxbf                        0x00005572980f8546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae774acb460 __libc_start_main +
    245

    6    tmpvbobuxbf                        0x00005572980f80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for _ in 0..<grid.count {\n        for _ in\
    \ 0..<grid[0].count {\n            if grid[count][_] == 1 {\n                grid[count][_]\
    \ = 0\n                count += grid[count][_]\n                max += grid[count][_]\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnhs0w7dl.swift:24:28: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[count][_] == 1 {\n  \
    \                         ^\n/tmp/tmpnhs0w7dl.swift:25:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n                grid[count][_]\
    \ = 0\n                            ^\n/tmp/tmpnhs0w7dl.swift:26:38: error: '_'\
    \ can only appear in a pattern or on the left side of an assignment\n        \
    \        count += grid[count][_]\n                                     ^\n/tmp/tmpnhs0w7dl.swift:27:36:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                max += grid[count][_]\n                                   ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result and buckets\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    \n    // init first bucket\n    buckets[0] = 0\n    \n    // init first row\n\
    \    for row in grid {\n        // init first column\n        for column in row\
    \ {\n            // init first bucket\n            buckets[column] = 0\n     \
    \   }\n    }\n    \n    // init first row\n    for row in grid {\n        // init\
    \ first column\n        for column in row {\n            // find max bucket index\n\
    \            let maxIndex = buckets.startIndex.maxIndex {\n                index,\
    \ value in\n                return value == buckets[index]\n            }\n  \
    \          \n            // update result\n            result += maxIndex - column\n\
    \            \n            // update buckets\n            buckets[maxIndex] =\
    \ 0\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmplg8rx4v8.swift:21:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init visited\n    var visited = make([]bool, capacity)\n\
    \    \n    // init visited\n    var visited2 = make([]bool, capacity)\n    \n\
    \    // init visited\n    var visited3 = make([]bool, capacity)\n    \n    //\
    \ init visited\n    var visited4 = make([]bool, capacity)\n    \n    // init visited\n\
    \    var visited5 = make([]bool, capacity)\n    \n    // init visited\n    var\
    \ visited6 = make([]bool, capacity)\n    \n    // init visited\n    var visited7\
    \ = make([]bool, capacity)\n    \n    // init visited\n    var visited8 = make([]bool,\
    \ capacity)\n    \n    // init visited\n    var visited9 = make([]bool, capacity)\n\
    \    \n    // init visited\n    var visited10 = make([]bool, capacity)\n    \n\
    \    // init visited\n    var visited11 = make([]bool, capacity)\n    \n    //\
    \ init visited\n    var visited12 = make([]bool, capacity)\n    \n    // init\
    \ visited\n    var visited13 = make([]bool, capacity)\n    \n    // init visited\n\
    \    var visited14 = make([]bool, capacity)\n    \n    // init visited\n    var\
    \ visited15 = make([]bool, capacity)\n    \n    // init visited\n    var visited16\
    \ = make([]bool, capacity)\n    \n    // init visited\n    var visited17 = make([]bool,\
    \ capacity)\n    \n    // init visited\n    var visited18 = make([]bool, capacity)\n\
    \    \n    // init visited\n    var visited19 = make([]bool, capacity)\n    \n\
    \    // init visited\n    var visited20 = make([]bool, capacity)\n    \n    //\
    \ init visited\n    var visited21 = make([]bool, capacity)\n    \n    // init\
    \ visited\n    var visited22 = make([]bool, capacity)\n    \n    // init visited\n\
    \    var visited23 = make([]bool, capacity)\n    \n    // init visited\n    var\
    \ visited24 = make([]bool, capacity)\n    \n    // init visited\n    var visited25\
    \ = make([]bool, capacity)\n    \n    // init visited\n    var visited26 = make([]bool,\
    \ capacity)\n    \n    // init visite\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd9cscgcl.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpd9cscgcl.swift:26:26: error: expected ',' separator\n   \
    \ var visited = make([]bool, capacity)\n                         ^\n         \
    \                ,\n/tmp/tmpd9cscgcl.swift:29:27: error: expected ',' separator\n\
    \    var visited2 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:32:27: error: expected ',' separator\n\
    \    var visited3 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:35:27: error: expected ',' separator\n\
    \    var visited4 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:38:27: error: expected ',' separator\n\
    \    var visited5 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:41:27: error: expected ',' separator\n\
    \    var visited6 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:44:27: error: expected ',' separator\n\
    \    var visited7 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:47:27: error: expected ',' separator\n\
    \    var visited8 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:50:27: error: expected ',' separator\n\
    \    var visited9 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpd9cscgcl.swift:53:28: error: expected ',' separator\n\
    \    var visited10 = make([]bool, capacity)\n                           ^\n  \
    \                         ,\n/tmp/tmpd9cscgcl.swift:56:28: error: expected ','\
    \ separator\n    var visited11 = make([]bool, capacity)\n                    \
    \       ^\n                           ,\n/tmp/tmpd9cscgcl.swift:59:28: error:\
    \ expected ',' separator\n    var visited12 = make([]bool, capacity)\n       \
    \                    ^\n               "
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                max += capacity\n            \
    \    count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyhg3nyl9/tmpyhg3nyl9.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b206adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b203a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b203a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b203a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyhg3nyl9                        0x000055a7cfd30717 <unavailable> + 5911

    5    libc.so.6                          0x00002b3b20899460 __libc_start_main +
    245

    6    tmpyhg3nyl9                        0x000055a7cfd300d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                count += max_fill(grid: &row,\
    \ capacity: capacity)\n            }\n        }\n    }\n    \n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp89psx687.swift:25:41: error: '&' used with non-inout argument of\
    \ type '[[Int]]'\n                count += max_fill(grid: &row, capacity: capacity)\n\
    \                                        ^~~~\n                              \
    \          \n/tmp/tmp89psx687.swift:25:41: error: cannot convert value of type\
    \ '[Int]' to expected argument type '[[Int]]'\n                count += max_fill(grid:\
    \ &row, capacity: capacity)\n                                        ^\n/tmp/tmp89psx687.swift:25:41:\
    \ note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected\
    \ to be equal\n                count += max_fill(grid: &row, capacity: capacity)\n\
    \                                        ^\n/tmp/tmp89psx687.swift:25:41: error:\
    \ cannot pass immutable value as inout argument: 'row' is a 'let' constant\n \
    \               count += max_fill(grid: &row, capacity: capacity)\n          \
    \                              ^~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppjft4drp.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmppjft4drp.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:38:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:41:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:56:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:59:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        var maxCount = 0\n        \n        for _ in 0..<n {\n            \n\
    \            let bucket = grid[Int(arc4random_uniform(UInt32(n)))]\n         \
    \   \n            if bucket == 1 {\n                \n                maxCount\
    \ += 1\n                \n                if maxCount > max {\n              \
    \      max = maxCount\n                }\n            }\n        }\n    }\n  \
    \  \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9onfwh84.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))]\n \
    \                                 ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init bucket max index\n    var\
    \ bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0].max()\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = grid[0][0].min()\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpicdvz9k7.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpicdvz9k7.swift:38:37: error: cannot\
    \ call value of non-function type 'Int'\n    var bucketMaxValue = grid[0][0].max()\n\
    \                                    ^  ~~\n                                 \
    \      \n/tmp/tmpicdvz9k7.swift:38:33: error: static member 'max' cannot be used\
    \ on instance of type 'Int'\n    var bucketMaxValue = grid[0][0].max()\n     \
    \                    ~~~~~~~^~~\n                         Int\n/tmp/tmpicdvz9k7.swift:41:33:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMinValue = grid[0][0].min()\n                         ~~~~~~~^~~\n   \
    \                      Int\n/tmp/tmpicdvz9k7.swift:41:37: error: cannot call value\
    \ of non-function type 'Int'\n    var bucketMinValue = grid[0][0].min()\n    \
    \                                ^  ~~\n                                     \
    \  \n/tmp/tmpicdvz9k7.swift:47:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpicdvz9k7.swift:44:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpicdvz9k7.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpicdvz9k7.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpicdvz9k7.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpicdvz9k7.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpicdvz9k7.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpicdvz9k7.swift:44:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpicdvz9k7.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpicdv"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppjft4drp.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmppjft4drp.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:38:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:41:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:56:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:59:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var count = 0\n    for row in grid {\n        for col in row {\n        \
    \    if col == 0 {\n                count += 1\n            } else {\n       \
    \         count = 0\n            }\n            if count > max {\n           \
    \     max = count\n            }\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwbeq3wgq/tmpwbeq3wgq.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a6b36cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a6b063b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a6b063988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a6b0627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbeq3wgq                        0x000055cef9c3e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6a6b558460 __libc_start_main +
    245

    6    tmpwbeq3wgq                        0x000055cef9c3e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        var maxCount = 0\n        \n        for _ in 0..<n {\n            \n\
    \            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \            \n            if bucket == 1 {\n                \n              \
    \  maxCount += 1\n                \n                if maxCount > max {\n    \
    \                max = maxCount\n                }\n            }\n        }\n\
    \    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_dlh7ot5.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmp_dlh7ot5.swift:29:71:\
    \ error: cannot find 'arc4random_uniform' in scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                                                      ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.count\
    \ == 0 {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n\
    \    \n    for index in 0..<grid.count {\n        if grid[index][0] > max {\n\
    \            max = grid[index][0]\n            maxIndex = index\n        }\n \
    \   }\n    \n    var current = 0\n    var currentIndex = 0\n    \n    for index\
    \ in 0..<grid.count {\n        if grid[index][0] > current {\n            current\
    \ = grid[index][0]\n            currentIndex = index\n        }\n    }\n    \n\
    \    var next = 0\n    var nextIndex = 0\n    \n    for index in 0..<grid.count\
    \ {\n        if grid[index][0] > next {\n            next = grid[index][0]\n \
    \           nextIndex = index\n        }\n    }\n    \n    var currentIndex2 =\
    \ 0\n    var nextIndex2 = 0\n    \n    for index in 0..<grid.count {\n       \
    \ if grid[index][0] > current {\n            current = grid[index][0]\n      \
    \      currentIndex2 = index\n        }\n        if grid[index][0] > next {\n\
    \            next = grid[index][0]\n            nextIndex2 = index\n        }\n\
    \    }\n    \n    var currentIndex3 = 0\n    var nextIndex3 = 0\n    \n    for\
    \ index in 0..<grid.count {\n        if grid[index][0] > current {\n         \
    \   current = grid[index][0]\n            currentIndex3 = index\n        }\n \
    \       if grid[index][0] > next {\n            next = grid[index][0]\n      \
    \      nextIndex3 = index\n        }\n    }\n    \n    var currentIndex4 = 0\n\
    \    var nextIndex4 = 0\n    \n    for index in 0..<grid.count {\n        if grid[index][0]\
    \ > current {\n            current = grid[index][0]\n            currentIndex4\
    \ = index\n        }\n        if grid[index][0] > next {\n            next = grid[index][0]\n\
    \            nextIndex4 = index\n        }\n    }\n    \n    var currentIndex5\
    \ = 0\n    var nextIndex5 = 0\n    \n    for index in 0..<grid.count {\n     \
    \   if grid[index][0] > current {\n            current = grid[index][0]\n    \
    \        currentIndex5 = index\n        }\n        if grid[index][0] > next {\n\
    \            next = grid[index][0]\n            nextIndex5 = index\n        }\n\
    \    }\n    \n    var currentIndex6 = 0\n    var nextIndex6 = 0\n    \n    for\
    \ index in 0..<grid.count {\n        if grid[index][0] > current {\n         \
    \   current = grid[index][0]\n            currentIndex6 = index\n        }\n \
    \       if grid[index][0] > next {\n            next = grid[index][0]\n      \
    \      nextIndex6 = index\n        }\n    }\n    \n    var currentIndex7 = 0\n\
    \    var nextIndex7 = 0\n    \n    for index in 0..\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8zwd3672.swift:125:21: error: expected '{' to start the body of\
    \ for-each loop\n    for index in 0..\n                    ^\n/tmp/tmp8zwd3672.swift:125:19:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for index\
    \ in 0..\n                  ^~\n                  ...\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpac1o9u7o/tmpac1o9u7o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8964d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8961c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8961c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8961c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpac1o9u7o                        0x000055c7c70df717 <unavailable> + 5911

    5    libc.so.6                          0x00002af8966be460 __libc_start_main +
    245

    6    tmpac1o9u7o                        0x000055c7c70df0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        let maxBucket = capacity\n        \n        for _ in 0..<n {\n      \
    \      \n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \            \n            if bucket > maxBucket {\n                maxBucket\
    \ = bucket\n            }\n        }\n        \n        max += maxBucket\n   \
    \ }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9fwyaro9.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmp9fwyaro9.swift:29:71:\
    \ error: cannot find 'arc4random_uniform' in scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                                                      ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9fwyaro9.swift:32:17: error: cannot assign to value: 'maxBucket' is a\
    \ 'let' constant\n                maxBucket = bucket\n                ^~~~~~~~~\n\
    /tmp/tmp9fwyaro9.swift:25:9: note: change 'let' to 'var' to make it mutable\n\
    \        let maxBucket = capacity\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        var count = 0\n        for\
    \ _ in row {\n            count += 1\n            if count > max {\n         \
    \       max = count\n                maxCount = 1\n            } else {\n    \
    \            maxCount *= count\n            }\n        }\n    }\n    return maxCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn0fbekqa/tmpn0fbekqa.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b809b27ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b809af71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b809af71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b809af707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn0fbekqa                        0x0000563419dac546 <unavailable> + 5446

    5    libc.so.6                          0x00002b809b466460 __libc_start_main +
    245

    6    tmpn0fbekqa                        0x0000563419dac0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7z9z6hry.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp7z9z6hry.swift:44:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmp7z9z6hry.swift:47:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmp7z9z6hry.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp7z9z6hry.swift:68:9: erro"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket max index\n    var\
    \ bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnbr7gsf2.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpnbr7gsf2.swift:47:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpnbr7gsf2.swift:50:9: error: invalid redeclaration of 'bucketMinValue'\n\
    \    var bucketMinValue = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:44:9: note: 'bucketMinValue'\
    \ previously declared here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:53:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpnbr7gsf2.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpnbr7gsf2.swift:44:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpnbr7gsf2.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpnbr7gsf2.swift:44:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpnbr7gsf2.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:68:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpnbr7gsf2.swift:44:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpnbr7gsf2.swift:71:9: erro"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     grid[row][col] = 0\n                \n                if grid[row][col]\
    \ == 1 {\n                    count += 1\n                    \n             \
    \       if count > max {\n                        max = count\n              \
    \      }\n                }\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp30z8ngol.swift:25:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpykjd86ta.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpykjd86ta.swift:32:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpykjd86ta.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpykjd86ta.swift:35:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:29:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:38:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpykjd86ta.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpykjd86ta.swift:41:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:29:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpykjd86ta.swift:44:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpykjd86ta.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpykjd86ta.swift:47:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpykjd86ta.swift:29:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:50:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpykjd86ta.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpykjd86ta.swift:53:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:29:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpykjd86ta.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpykjd86ta.swift:26:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init well capacity\n    var wellCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr12jil5x.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpr12jil5x.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmpr12jil5x.swift:41:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpr12jil5x.swift:29:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpr12jil5x.swift:44:9: error:\
    \ invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpr12jil5x.swift:32:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmpr12jil5x.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpr12jil5x.swift:35:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpr12jil5x.swift:50:9:\
    \ error: invalid redeclaration of 'wellCapacity'\n    var wellCapacity = 0\n \
    \       ^\n/tmp/tmpr12jil5x.swift:38:9: note: 'wellCapacity' previously declared\
    \ here\n    var wellCapacity = 0\n        ^\n/tmp/tmpr12jil5x.swift:53:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpr12jil5x.swift:29:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpr12jil5x.swift:56:9: error: invalid\
    \ redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpr12jil5x.swift:32:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmpr12jil5x.swift:59:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpr12jil5x.swift:35:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpr12jil5x.swift:62:9:\
    \ error: invalid redeclaration of 'wellCapacity'\n    var wellCapacity = 0\n \
    \       ^\n/tmp/tmpr12jil5x.swift:38:9: note: 'wellCapaci"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmppjft4drp.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmppjft4drp.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:38:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:41:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmppjft4drp.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmppjft4drp.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmppjft4drp.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmppjft4drp.swift:56:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:29:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmppjft4drp.swift:59:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited2 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited3 = [Bool](capacity)\n    \n    // init visited wells\n    var visited4\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited5 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited6 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited7 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited8 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited9 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited10 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited11 = [Bool](capacity)\n    \n    // init visited wells\n    var visited12\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited13 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited14 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited15 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited16 = [Bool](capacity)\n    \n    // init\
    \ visited wells\n    var visited17 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited18 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited19 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited20 = [Bool](capacity)\n    \n    // init visited wells\n    var visited21\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited22 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited23 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited24 = [Bool](capacity)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps28hem61.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmps28hem61.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmps28hem61.swift:29:19:\
    \ error: no exact matches in call to initializer \n    var visited = [Bool](capacity)\n\
    \                  ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmps28hem61.swift:29:19: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited =\
    \ [Bool](capacity)\n                  ^\n/tmp/tmps28hem61.swift:29:19: note: candidate\
    \ expects value of type 'any Decoder' for parameter #1 (got 'Int')\n    var visited\
    \ = [Bool](capacity)\n                  ^\n/tmp/tmps28hem61.swift:32:20: error:\
    \ no exact matches in call to initializer \n    var visited2 = [Bool](capacity)\n\
    \                   ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmps28hem61.swift:32:20: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited2\
    \ = [Bool](capacit"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var max = 0\n    for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count\
    \ {\n            if grid[Int(_)][Int(_)] != 0 {\n                max += capacity\n\
    \            }\n        }\n        if max > result {\n            result = max\n\
    \        }\n        max = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvt7_ktwt.swift:22:25: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[Int(_)][Int(_)] != 0\
    \ {\n                        ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init grid\n    var gridCopy = grid\n    \n    // init buckets\n\
    \    for _ in 0..<capacity {\n        buckets.append(0)\n    }\n    \n    // init\
    \ grid\n    for row in 0..<gridCopy.count {\n        for col in 0..<gridCopy[row].count\
    \ {\n            if gridCopy[row][col] == 1 {\n                buckets[gridCopy[row][col]-1]\
    \ += 1\n            }\n        }\n    }\n    \n    // init result\n    for _ in\
    \ 0..<capacity {\n        result += buckets[_]\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6atiuie7.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp6atiuie7.swift:44:27: error: '_'\
    \ can only appear in a pattern or on the left side of an assignment\n        result\
    \ += buckets[_]\n                          ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        var max = 0\n        \n        for _ in 0..<n {\n            \n     \
    \       let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \            \n            if bucket == 1 {\n                \n              \
    \  max += 1\n                \n            }\n            \n        }\n      \
    \  \n        if max > max {\n            max = max\n        }\n        \n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqxv7w8n4.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpqxv7w8n4.swift:29:71:\
    \ error: cannot find 'arc4random_uniform' in scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                                                      ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqxv7w8n4.swift:40:17: error: assigning a variable to itself\n        \
    \    max = max\n            ~~~ ^ ~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         \n                let bucket = capacity / grid[row][col]\n         \
    \       \n                if bucket > max {\n                    max = bucket\n\
    \                    maxCount = 1\n                } else {\n                \
    \    maxCount += 1\n                }\n            }\n        }\n    }\n    \n\
    \    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwo6i6qel/tmpwo6i6qel.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca4883bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca48532b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca48532988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca485317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwo6i6qel                        0x0000555e8c1a2827 <unavailable> + 6183

    5    libc.so.6                          0x00002aca48a27460 __libc_start_main +
    245

    6    tmpwo6i6qel                        0x0000555e8c1a21e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket min value\n   \
    \ var bucketMinValue = grid[0][0]\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgflv28de.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgflv28de.swift:44:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:47:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:56:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpgflv28de.swift:41:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpgflv28de.swift:68:9: erro"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for _ in 0..<grid.count {\n        var max\
    \ = 0\n        var count = 0\n        for _ in 0..<grid[0].count {\n         \
    \   if grid[count][_] > max {\n                max = grid[count][_]\n        \
    \    }\n            count += 1\n        }\n        \n        if max > capacity\
    \ {\n            count = 0\n            for _ in 0..<grid[0].count {\n       \
    \         grid[count][_] = 0\n                count += 1\n            }\n    \
    \    }\n        \n        max += 1\n        count -= 1\n    }\n    \n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpngnj_nln.swift:26:28: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[count][_] > max {\n \
    \                          ^\n/tmp/tmpngnj_nln.swift:27:35: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n                max\
    \ = grid[count][_]\n                                  ^\n/tmp/tmpngnj_nln.swift:35:29:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[count][_] = 0\n                            ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty()\
    \ {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n  \
    \  var maxValue = 0\n    \n    for row in grid {\n        for col in row {\n \
    \           if col > maxValue {\n                maxValue = col\n            \
    \    maxIndex = row.startIndex\n            }\n        }\n    }\n    \n    for\
    \ row in grid {\n        for col in row {\n            if col == maxValue {\n\
    \                grid[maxIndex][row.startIndex] = 0\n            }\n        }\n\
    \    }\n    \n    for row in grid {\n        for col in row {\n            if\
    \ col > maxValue {\n                grid[maxIndex][row.startIndex] = 0\n     \
    \       }\n        }\n    }\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col > maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col > maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col > maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col > maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col > maxValue {\n                grid[maxIndex][row.startIndex]\
    \ = 0\n            }\n        }\n    }\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == maxValue {\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp56t5js2w.swift:153:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmp56t5js2w.swift:132:24:\
    \ note: to match this opening '{'\n        for col in row {\n                \
    \       ^\n/tmp/tmp56t5js2w.swift:153:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmp56t5js2w.swift:131:21: note: to match this opening '{'\n    for\
    \ row in grid {\n                    ^\n/tmp/tmp56t5js2w.swift:153:71: error:\
    \ expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)\n                                        \
    \                              ^\n/tmp/tmp56t5js2w.swift:17:52: note: to match\
    \ this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n   \
    \                                                ^\n/tmp/tmp56t5js2w.swift:18:13:\
    \ error: cannot call value of non-function type 'Bool'\n    if grid.isEmpty()\
    \ {\n            ^      ~~\n                   \n/tmp/tmp56t5js2w.swift:38:31:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \         grid[maxIndex][row.startIndex] = 0\n                ~~~~          ^\n\
    /tmp/tmp56t5js2w.swift:46:31: error: cannot assign through subscript: 'grid' is\
    \ a 'let' constant\n                grid[maxIndex][row.startIndex] = 0\n     \
    \           ~~~~          ^\n/tmp/tmp56t5js2w.swift:54:31: error: cannot assign\
    \ through subscript: 'grid' is a 'let' constant\n                grid[maxIndex][row.startIndex]\
    \ = 0\n                ~~~~          ^\n/tmp/tmp56t5js2w.swift:62:31: error: cannot\
    \ assign through subscript: 'grid' is a 'let' constant\n                grid[maxIndex][row.startIndex]\
    \ = 0\n                ~~~~          ^\n/tmp/tmp56t5js2w.swift:70:31: error: cannot\
    \ assign through subscript: 'grid' is a 'let' constant\n                grid[maxIndex][row"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                result += max_fill(grid: &row, capacity: capacity)\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppqyxnrm1.swift:22:42: error: '&' used with non-inout argument of\
    \ type '[[Int]]'\n                result += max_fill(grid: &row, capacity: capacity)\n\
    \                                         ^~~~\n                             \
    \            \n/tmp/tmppqyxnrm1.swift:22:42: error: cannot convert value of type\
    \ '[Int]' to expected argument type '[[Int]]'\n                result += max_fill(grid:\
    \ &row, capacity: capacity)\n                                         ^\n/tmp/tmppqyxnrm1.swift:22:42:\
    \ note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected\
    \ to be equal\n                result += max_fill(grid: &row, capacity: capacity)\n\
    \                                         ^\n/tmp/tmppqyxnrm1.swift:22:42: error:\
    \ cannot pass immutable value as inout argument: 'row' is a 'let' constant\n \
    \               result += max_fill(grid: &row, capacity: capacity)\n         \
    \                                ^~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init well map\n    var wellMap = Dictionary<Int, Int>()\n    \n\
    \    // init bucket count\n    var bucketCount = 0\n    \n    // init well count\n\
    \    var wellCount = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init well index\n    var wellIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init well index\n\
    \    var wellIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ well index\n    var wellIndex = 0\n    \n    // init bucket capacity\n    var\
    \ bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init well index\n    var wellIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init well index\n\
    \    var wellIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ well index\n    var wellIndex = 0\n    \n    // init bucket capacity\n    var\
    \ bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init well index\n    var wellIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsspc5ntc.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpsspc5ntc.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:35:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpsspc5ntc.swift:47:9: error: invalid redeclaration of 'wellIndex'\n\
    \    var wellIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:38:9: note: 'wellIndex'\
    \ previously declared here\n    var wellIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:50:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmpsspc5ntc.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsspc5ntc.swift:53:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpsspc5ntc.swift:35:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:56:9: error: invalid\
    \ redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:38:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmpsspc5ntc.swift:59:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpsspc5ntc.swift:41:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpsspc5ntc.swift:62:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpsspc5ntc.swift:35:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:65:9: error:\
    \ invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpsspc5ntc.swift:38:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmpsspc5ntc.swift:68:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpsspc5n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty\
    \ {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n  \
    \  \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n\
    \            if grid[row][col] == 1 {\n                max += capacity\n     \
    \           maxIndex = row * grid[row].count + col\n            }\n        }\n\
    \    }\n    \n    return maxIndex - max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpz5d94dmh/tmpz5d94dmh.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e423c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e420bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e420bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e420bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5d94dmh                        0x000055f4e62016f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b0e425b1460 __libc_start_main +
    245

    6    tmpz5d94dmh                        0x000055f4e6201289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited2 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited3 = [Int](capacity)\n    \n    // init visited wells\n    var visited4\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited5 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited6 = [Int](capacity)\n    \n \
    \   // init visited wells\n    var visited7 = [Int](capacity)\n    \n    // init\
    \ visited wells\n    var visited8 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited9 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited10 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited11 = [Int](capacity)\n    \n    // init visited wells\n    var visited12\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited13 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited14 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited15 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited16 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited17 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited18 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited19 = [Int](capacity)\n    \n    // init visited wells\n    var visited20\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited21 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited22 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited23 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited24 = [Int](capacity)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsh6euin8.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpsh6euin8.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmpsh6euin8.swift:29:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpsh6euin8.swift:32:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited2 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:35:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited3 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:38:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited4 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:41:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited5 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:44:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited6 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:47:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited7 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:50:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited8 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:53:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited9 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8."
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        let maxBucket = max\n        \n        for _ in 0..<n {\n           \
    \ \n            let bucket = grid[maxBucket][_]\n            \n            if\
    \ bucket == 1 {\n                \n                maxBucket += 1\n          \
    \      \n                if maxBucket == n {\n                    \n         \
    \           maxBucket -= 1\n                    \n                    break\n\
    \                }\n            }\n            \n            if bucket == 0 {\n\
    \                \n                maxBucket -= 1\n                \n        \
    \        if maxBucket == 0 {\n                    \n                    break\n\
    \                }\n            }\n        }\n        \n        max += 1\n   \
    \ }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsr9njkqc.swift:29:42: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            let bucket = grid[maxBucket][_]\n\
    \                                         ^\n/tmp/tmpsr9njkqc.swift:33:27: error:\
    \ left side of mutating operator isn't mutable: 'maxBucket' is a 'let' constant\n\
    \                maxBucket += 1\n                ~~~~~~~~~ ^\n/tmp/tmpsr9njkqc.swift:25:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let maxBucket = max\n\
    \        ^~~\n        var\n/tmp/tmpsr9njkqc.swift:37:31: error: left side of mutating\
    \ operator isn't mutable: 'maxBucket' is a 'let' constant\n                  \
    \  maxBucket -= 1\n                    ~~~~~~~~~ ^\n/tmp/tmpsr9njkqc.swift:25:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let maxBucket = max\n\
    \        ^~~\n        var\n/tmp/tmpsr9njkqc.swift:45:27: error: left side of mutating\
    \ operator isn't mutable: 'maxBucket' is a 'let' constant\n                maxBucket\
    \ -= 1\n                ~~~~~~~~~ ^\n/tmp/tmpsr9njkqc.swift:25:9: note: change\
    \ 'let' to 'var' to make it mutable\n        let maxBucket = max\n        ^~~\n\
    \        var\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let rowCount\
    \ = grid.count\n    let colCount = grid[0].count\n    \n    var max = 0\n    \n\
    \    for row in 0..<rowCount {\n        for col in 0..<colCount {\n          \
    \  \n            let bucket = grid[row][col]\n            \n            if bucket\
    \ == 0 {\n                \n                let newBucket = bucket - 1\n     \
    \           \n                if newBucket > max {\n                    max =\
    \ newBucket\n                }\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprsfi0hlj/tmprsfi0hlj.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4826634c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b482632bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b482632b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b482632a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprsfi0hlj                        0x0000561c09044656 <unavailable> + 5718

    5    libc.so.6                          0x00002b4826820460 __libc_start_main +
    245

    6    tmprsfi0hlj                        0x0000561c090441e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](grid.count)\n    \n    // init\
    \ index\n    var index = 0\n    \n    // init index\n    var index2 = 0\n    \n\
    \    // init index\n    var index3 = 0\n    \n    // init index\n    var index4\
    \ = 0\n    \n    // init index\n    var index5 = 0\n    \n    // init index\n\
    \    var index6 = 0\n    \n    // init index\n    var index7 = 0\n    \n    //\
    \ init index\n    var index8 = 0\n    \n    // init index\n    var index9 = 0\n\
    \    \n    // init index\n    var index10 = 0\n    \n    // init index\n    var\
    \ index11 = 0\n    \n    // init index\n    var index12 = 0\n    \n    // init\
    \ index\n    var index13 = 0\n    \n    // init index\n    var index14 = 0\n \
    \   \n    // init index\n    var index15 = 0\n    \n    // init index\n    var\
    \ index16 = 0\n    \n    // init index\n    var index17 = 0\n    \n    // init\
    \ index\n    var index18 = 0\n    \n    // init index\n    var index19 = 0\n \
    \   \n    // init index\n    var index20 = 0\n    \n    // init index\n    var\
    \ index21 = 0\n    \n    // init index\n    var index22 = 0\n    \n    // init\
    \ index\n    var index23 = 0\n    \n    // init index\n    var index24 = 0\n \
    \   \n    // init index\n    var index25 = 0\n    \n    // init index\n    var\
    \ index26 = 0\n    \n    // init index\n    var index27 = 0\n    \n    // init\
    \ index\n    var index28 = 0\n    \n    // init index\n    var index29 = 0\n \
    \   \n    // init index\n    var index30 = 0\n    \n    // init index\n    var\
    \ index31 = 0\n    \n    // init index\n    var index32 = 0\n    \n    // init\
    \ index\n    var index33 = 0\n    \n    // init index\n    var index34 = 0\n \
    \   \n    // init index\n    var index35 = 0\n    \n    // init index\n    var\
    \ index36 = 0\n    \n    // init index\n    var index37 = 0\n    \n    // init\
    \ index\n    var index38 = 0\n    \n    // init index\n    var index39 = 0\n \
    \   \n    // init index\n    var index40 = 0\n    \n    // init index\n    var\
    \ index41 = 0\n    \n    // init index\n    var index42 = 0\n    \n    // init\
    \ index\n    var index43 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzmqgfy6q.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpzmqgfy6q.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](grid.count)\n\
    \                      ^\n                      arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket size\n    var bucketSize = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var\
    \ bucketMaxCapacity = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n\
    \    // init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ max capacity\n    var bucketMaxCapacity = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5ff4qh9m.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp5ff4qh9m.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp5ff4qh9m.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp5ff4qh9m.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp5ff4qh9m.swift:38:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:35:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:41:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:35:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:44:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:35:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:47:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:35:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:35:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp5ff4qh9m.swift:53:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    va"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited = [Int](capacity)\n    \n    //\
    \ init visited map\n    var visited2 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited3 = [Int](capacity)\n    \n    // init visited map\n   \
    \ var visited4 = [Int](capacity)\n    \n    // init visited map\n    var visited5\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited6 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited7 = [Int](capacity)\n    \n   \
    \ // init visited map\n    var visited8 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited9 = [Int](capacity)\n    \n    // init visited map\n   \
    \ var visited10 = [Int](capacity)\n    \n    // init visited map\n    var visited11\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited12 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited13 = [Int](capacity)\n    \n  \
    \  // init visited map\n    var visited14 = [Int](capacity)\n    \n    // init\
    \ visited map\n    var visited15 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited16 = [Int](capacity)\n    \n    // init visited map\n  \
    \  var visited17 = [Int](capacity)\n    \n    // init visited map\n    var visited18\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited19 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited20 = [Int](capacity)\n    \n  \
    \  // init visited map\n    var visited21 = [Int](capacity)\n    \n    // init\
    \ visited map\n    var visited22 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited23 = [Int](capacity)\n    \n    // init visited map\n  \
    \  var visited24 = [Int](capacity)\n    \n    // init visited map\n    var visited25\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited26 = [Int](capacity)\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcv34l__e.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpcv34l__e.swift:26:25: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpcv34l__e.swift:29:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited2 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:32:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited3 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:35:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited4 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:38:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited5 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:41:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited6 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:44:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited7 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:47:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited8 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:50:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited9 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:53:27:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited10 = [Int](capacity)\n\
    \                          ^\n                          arrayLiteral: \n/tmp/"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init index\n\
    \    var index = 0\n    \n    // init bucket\n    var bucket = 0\n    \n    //\
    \ init well\n    var well = 0\n    \n    // init flag\n    var flag = false\n\
    \    \n    // init index\n    var index = 0\n    \n    // init flag\n    var flag\
    \ = false\n    \n    // init index\n    var index = 0\n    \n    // init flag\n\
    \    var flag = false\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init flag\n    var flag = false\n    \n    // init index\n    var index = 0\n\
    \    \n    // init flag\n    var flag = false\n    \n    // init index\n    var\
    \ index = 0\n    \n    // init flag\n    var flag = false\n    \n    // init index\n\
    \    var index = 0\n    \n    // init flag\n    var flag = false\n    \n    //\
    \ init index\n    var index = 0\n    \n    // init flag\n    var flag = false\n\
    \    \n    // init index\n    var index = 0\n    \n    // init flag\n    var flag\
    \ = false\n    \n    // init index\n    var index = 0\n    \n    // init flag\n\
    \    var flag = false\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init flag\n    var flag = false\n    \n    // init index\n    var index = 0\n\
    \    \n    // init flag\n    var flag = false\n    \n    // init index\n    var\
    \ index = 0\n    \n    // init flag\n    var flag = false\n    \n    // init index\n\
    \    var index = 0\n    \n    // init flag\n    var flag = false\n    \n    //\
    \ init index\n    var index = 0\n    \n    // init flag\n    var flag = false\n\
    \    \n    // init index\n    var index = 0\n    \n    // init flag\n    var flag\
    \ = false\n    \n    // init index\n    var index = 0\n    \n    // init flag\n\
    \    var flag = false\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init flag\n    var flag = false\n    \n    // init index\n    var index = 0\n\
    \    \n    // init flag\n    var flag = false\n    \n    // init index\n    var\
    \ index = 0\n    \n    // init flag\n    var flag = false\n    \n    // init index\n\
    \    var index = 0\n    \n    // init flag\n    var flag = false\n    \n    //\
    \ init index\n    var index = 0\n    \n    // init flag\n    var flag = false\n\
    \    \n    // init index\n    var index = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_wc748fd.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp_wc748fd.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmp_wc748fd.swift:41:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:29:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:44:9:\
    \ error: invalid redeclaration of 'flag'\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:38:9:\
    \ note: 'flag' previously declared here\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:47:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:29:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:50:9:\
    \ error: invalid redeclaration of 'flag'\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:38:9:\
    \ note: 'flag' previously declared here\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:53:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:29:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:56:9:\
    \ error: invalid redeclaration of 'flag'\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:38:9:\
    \ note: 'flag' previously declared here\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:59:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:29:9:\
    \ note: 'index' previously declared here\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:62:9:\
    \ error: invalid redeclaration of 'flag'\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:38:9:\
    \ note: 'flag' previously declared here\n    var flag = false\n        ^\n/tmp/tmp_wc748fd.swift:65:9:\
    \ error: invalid redeclaration of 'index'\n    var index = 0\n        ^\n/tmp/tmp_wc748fd.swift:29:9:\
    \ no"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        for bucket in row {\n            if bucket\
    \ > capacity {\n                result += capacity - bucket\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpacgyqq5y/tmpacgyqq5y.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0d7b8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0d7882b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0d7882988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0d78817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpacgyqq5y                        0x0000560445796546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab0d7d77460 __libc_start_main +
    245

    6    tmpacgyqq5y                        0x00005604457960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        var maxCount = 0\n        \n        for _ in 0..<n {\n            \n\
    \            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \            \n            if bucket == 0 {\n                \n              \
    \  maxCount++\n                \n                if maxCount > max {\n       \
    \             max = maxCount\n                }\n            }\n        }\n  \
    \  }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk49i6piw.swift:29:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpk49i6piw.swift:29:71:\
    \ error: cannot find 'arc4random_uniform' in scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                                                      ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk49i6piw.swift:33:25: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n                maxCount++\n                        ^~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result and buckets\n    var result = 0\n    var buckets = make([][]int, capacity)\n\
    \    \n    // init buckets\n    for i := 0; i < capacity; i++ {\n        buckets[i]\
    \ = make([]int, capacity)\n    }\n    \n    // init grid\n    for i := 0; i <\
    \ len(grid); i++ {\n        for j := 0; j < len(grid[0]); j++ {\n            if\
    \ grid[i][j] == 1 {\n                buckets[grid[i][j]-1][j] = 0\n          \
    \  }\n        }\n    }\n    \n    // fill buckets\n    for i := 0; i < capacity;\
    \ i++ {\n        for j := 0; j < capacity; j++ {\n            if buckets[i][j]\
    \ == 0 {\n                buckets[i][j] = i\n                result += j\n   \
    \         }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6q24gmyf.swift:21:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp6q24gmyf.swift:24:12: error: expected type\n    for i :=\
    \ 0; i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmp6q24gmyf.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmp6q24gmyf.swift:24:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp6q24gmyf.swift:25:29:\
    \ error: expected ',' separator\n        buckets[i] = make([]int, capacity)\n\
    \                            ^\n                            ,\n/tmp/tmp6q24gmyf.swift:29:12:\
    \ error: expected type\n    for i := 0; i < len(grid); i++ {\n           ^\n \
    \           <#type#>\n/tmp/tmp6q24gmyf.swift:29:12: error: expected 'in' after\
    \ for-each pattern\n    for i := 0; i < len(grid); i++ {\n           ^\n/tmp/tmp6q24gmyf.swift:29:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(grid);\
    \ i++ {\n           ^\n/tmp/tmp6q24gmyf.swift:30:16: error: expected type\n  \
    \      for j := 0; j < len(grid[0]); j++ {\n               ^\n               \
    \ <#type#>\n/tmp/tmp6q24gmyf.swift:30:16: error: expected 'in' after for-each\
    \ pattern\n        for j := 0; j < len(grid[0]); j++ {\n               ^\n/tmp/tmp6q24gmyf.swift:30:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < len(grid[0]); j++ {\n               ^\n/tmp/tmp6q24gmyf.swift:38:12: error:\
    \ expected type\n    for i := 0; i < capacity; i++ {\n           ^\n         \
    \   <#type#>\n/tmp/tmp6q24gmyf.swift:38:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmp6q24gmyf.swift:38:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < capacity;\
    \ i++ {\n           ^\n/tmp/tmp6q24gmyf.swift:39:16: error: expected type\n  \
    \      for j := 0; j < capacity; j++ {\n               ^\n                <#type#>\n\
    /tmp/tmp6q24gmyf.swift:39:16: error: expe"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var count = 0\n    for row in grid {\n        for col in row {\n        \
    \    if col == 0 {\n                count += 1\n            } else {\n       \
    \         count = 0\n            }\n            if count > max {\n           \
    \     max = count\n            }\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwbeq3wgq/tmpwbeq3wgq.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a6b36cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a6b063b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a6b063988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a6b0627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbeq3wgq                        0x000055cef9c3e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6a6b558460 __libc_start_main +
    245

    6    tmpwbeq3wgq                        0x000055cef9c3e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let rowCount\
    \ = grid.count\n    let colCount = grid[0].count\n    \n    var max = 0\n    \n\
    \    for i in 0..<rowCount {\n        for j in 0..<colCount {\n            if\
    \ grid[i][j] == 1 {\n                \n                let bucket = grid[i][j]\n\
    \                \n                for k in 0..<capacity {\n                 \
    \   \n                    grid[i][j] = bucket\n                    \n        \
    \            if bucket == 0 {\n                        \n                    \
    \    grid[i][j] = 1\n                        \n                        if grid[i][j]\
    \ == 1 {\n                            \n                            grid[i][j]\
    \ = 0\n                            \n                            max += 1\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp57y5a_w3.swift:32:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[i][j] = bucket\n             \
    \       ~~~~   ^\n/tmp/tmp57y5a_w3.swift:36:32: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                        grid[i][j] = 1\n       \
    \                 ~~~~   ^\n/tmp/tmp57y5a_w3.swift:40:36: error: cannot assign\
    \ through subscript: 'grid' is a 'let' constant\n                            grid[i][j]\
    \ = 0\n                            ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpac1o9u7o/tmpac1o9u7o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8964d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8961c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8961c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8961c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpac1o9u7o                        0x000055c7c70df717 <unavailable> + 5911

    5    libc.so.6                          0x00002af8966be460 __libc_start_main +
    245

    6    tmpac1o9u7o                        0x000055c7c70df0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if grid[i][j] == 1 {\n                max += capacity\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp16mplbom/tmp16mplbom.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c7391ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c73611b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c73611988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c736107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16mplbom                        0x00005628df8f3606 <unavailable> + 5638

    5    libc.so.6                          0x00002b0c73b06460 __libc_start_main +
    245

    6    tmp16mplbom                        0x00005628df8f3199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var\
    \ bucketMinCapacity = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    // init\
    \ bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min sum\n\
    \    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n    //\
    \ init bucket max sum\n    var bucketMaxSum = 0\n    \n    // init bucket min\
    \ sum\n    var bucketMinSum = 0\n    \n    // init bucket max sum\n    var bucketMaxSum\
    \ = 0\n    \n    // init bucket min sum\n    var bucketMinSum = 0\n    \n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps2hs4fl8.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmps2hs4fl8.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmps2hs4fl8.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmps2hs4fl8.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmps2hs4fl8.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMinSum'\n    var bucketMinSum = 0\n \
    \       ^\n/tmp/tmps2hs4fl8.swift:44:9: note: 'bucketMinSum' previously declared\
    \ here\n    var bucketMinSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:53:9: error:\
    \ invalid redeclaration of 'bucketMaxSum'\n    var bucketMaxSum = 0\n        ^\n\
    /tmp/tmps2hs4fl8.swift:47:9: note: 'bucketMaxSum' previously declared here\n \
    \   var bucketMaxSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:56:9: error: invalid\
    \ redeclaration of 'bucketMinSum'\n    var bucketMinSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:44:9:\
    \ note: 'bucketMinSum' previously declared here\n    var bucketMinSum = 0\n  \
    \      ^\n/tmp/tmps2hs4fl8.swift:59:9: error: invalid redeclaration of 'bucketMaxSum'\n\
    \    var bucketMaxSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:47:9: note: 'bucketMaxSum'\
    \ previously declared here\n    var bucketMaxSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:62:9:\
    \ error: invalid redeclaration of 'bucketMinSum'\n    var bucketMinSum = 0\n \
    \       ^\n/tmp/tmps2hs4fl8.swift:44:9: note: 'bucketMinSum' previously declared\
    \ here\n    var bucketMinSum = 0\n        ^\n/tmp/tmps2hs4fl8.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMaxSum'\n    var bucketMaxSum = 0\n        ^\n\
    /tmp/tmps2hs4fl8.swift:47:9: note: 'bucketMaxSum' previously declared here\n "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init grid\n    var grid2 = make([][]int, capacity)\n\
    \    \n    // init visited\n    var visited = make([]bool, capacity)\n    \n \
    \   // init visited grid\n    var visited2 = make([]bool, capacity)\n    \n  \
    \  // init visited grid\n    var visited3 = make([]bool, capacity)\n    \n   \
    \ // init visited grid\n    var visited4 = make([]bool, capacity)\n    \n    //\
    \ init visited grid\n    var visited5 = make([]bool, capacity)\n    \n    // init\
    \ visited grid\n    var visited6 = make([]bool, capacity)\n    \n    // init visited\
    \ grid\n    var visited7 = make([]bool, capacity)\n    \n    // init visited grid\n\
    \    var visited8 = make([]bool, capacity)\n    \n    // init visited grid\n \
    \   var visited9 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited10 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited11 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited12 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited13 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited14 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited15 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited16 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited17 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited18 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited19 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited20 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited21 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited22 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited23 = make([]bool, capacity)\n    \n    // init visited grid\n  \
    \  var visited24 = make([]bool, capacity)\n    \n    // \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpi9ylx5lf.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpi9ylx5lf.swift:26:26: error: expected ',' separator\n   \
    \ var grid2 = make([][]int, capacity)\n                         ^\n          \
    \               ,\n/tmp/tmpi9ylx5lf.swift:29:26: error: expected ',' separator\n\
    \    var visited = make([]bool, capacity)\n                         ^\n      \
    \                   ,\n/tmp/tmpi9ylx5lf.swift:32:27: error: expected ',' separator\n\
    \    var visited2 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:35:27: error: expected ',' separator\n\
    \    var visited3 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:38:27: error: expected ',' separator\n\
    \    var visited4 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:41:27: error: expected ',' separator\n\
    \    var visited5 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:44:27: error: expected ',' separator\n\
    \    var visited6 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:47:27: error: expected ',' separator\n\
    \    var visited7 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:50:27: error: expected ',' separator\n\
    \    var visited8 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:53:27: error: expected ',' separator\n\
    \    var visited9 = make([]bool, capacity)\n                          ^\n    \
    \                      ,\n/tmp/tmpi9ylx5lf.swift:56:28: error: expected ',' separator\n\
    \    var visited10 = make([]bool, capacity)\n                           ^\n  \
    \                         ,\n/tmp/tmpi9ylx5lf.swift:59:28: error: expected ','\
    \ separator\n    var visited11 = make([]bool, capacity)\n                    \
    \       ^\n                      "
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        if row[0] == 0 {\n            continue\n\
    \        }\n        \n        var max = 0\n        for j in 0..<row[0] {\n   \
    \         if row[j] > max {\n                max = row[j]\n            }\n   \
    \     }\n        \n        for j in 0..<row[0] {\n            if row[j] == max\
    \ {\n                row[j] = 0\n            } else {\n                row[j]\
    \ = 1\n            }\n        }\n        \n        if max > capacity {\n     \
    \       result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpg_qmdj07.swift:33:20: error: cannot assign through subscript: 'row'\
    \ is a 'let' constant\n                row[j] = 0\n                ~~~^\n/tmp/tmpg_qmdj07.swift:35:20:\
    \ error: cannot assign through subscript: 'row' is a 'let' constant\n        \
    \        row[j] = 1\n                ~~~^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.count\
    \ == 0 {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                max += capacity\n \
    \               maxIndex = row\n            }\n        }\n    }\n    \n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8amskbey/tmp8amskbey.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac67d2eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac67cfe1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac67cfe1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac67cfe07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8amskbey                        0x0000560aeecdf656 <unavailable> + 5718

    5    libc.so.6                          0x00002ac67d4d6460 __libc_start_main +
    245

    6    tmp8amskbey                        0x0000560aeecdf1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var bucket =\
    \ [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n \
    \   \n    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n \
    \   \n    // init bucket min value\n    var bucketMin = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket min value\n    var bucketMin\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = 0\n    \n    // init \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpax9f51k_.swift:23:24: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var bucket = [Int](capacity)\n                       ^\n      \
    \                 arrayLiteral: \n/tmp/tmpax9f51k_.swift:44:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpax9f51k_.swift:35:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpax9f51k_.swift:47:9: error: invalid redeclaration of 'bucketMin'\n   \
    \ var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:41:9: note: 'bucketMin'\
    \ previously declared here\n    var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:50:9:\
    \ error: invalid redeclaration of 'bucketMax'\n    var bucketMax = 0\n       \
    \ ^\n/tmp/tmpax9f51k_.swift:38:9: note: 'bucketMax' previously declared here\n\
    \    var bucketMax = 0\n        ^\n/tmp/tmpax9f51k_.swift:53:9: error: invalid\
    \ redeclaration of 'bucketMin'\n    var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:41:9:\
    \ note: 'bucketMin' previously declared here\n    var bucketMin = 0\n        ^\n\
    /tmp/tmpax9f51k_.swift:56:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpax9f51k_.swift:35:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpax9f51k_.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMin'\n    var bucketMin = 0\n       \
    \ ^\n/tmp/tmpax9f51k_.swift:41:9: note: 'bucketMin' previously declared here\n\
    \    var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:62:9: error: invalid\
    \ redeclaration of 'bucketMax'\n    var bucketMax = 0\n        ^\n/tmp/tmpax9f51k_.swift:38:9:\
    \ note: 'bucketMax' previously declared here\n    var bucketMax = 0\n        ^\n\
    /tmp/tmpax9f51k_.swift:65:9: error: invalid redeclaration of 'bucketMin'\n   \
    \ var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:41:9: note: 'bucketMin'\
    \ previously declared here\n    var bucketMin = 0\n        ^\n/tmp/tmpax9f51k_.swift:68:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpax9f51k_.swift:35:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum ="
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for _ in 0..<grid.count {\n        var maxCount = 0\n        for _ in 0..<grid[0].count\
    \ {\n            if grid[maxCount][_] == 1 {\n                maxCount += 1\n\
    \            }\n        }\n        if maxCount > max {\n            max = maxCount\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkpf6hnch.swift:22:31: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[maxCount][_] == 1 {\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid[0].count\n    \n    // init bucket length\n    var bucketLength = buckets.count\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = buckets.last!\n \
    \   \n    // init bucket index\n    var bucketIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp928ry5iq.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp928ry5iq.swift:41:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmp928ry5iq.swift:44:9: error: invalid redeclaration of 'gridIndex'\n\
    \    var gridIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:29:9: note: 'gridIndex'\
    \ previously declared here\n    var gridIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:47:9:\
    \ error: invalid redeclaration of 'gridLength'\n    var gridLength = grid[0].count\n\
    \        ^\n/tmp/tmp928ry5iq.swift:32:9: note: 'gridLength' previously declared\
    \ here\n    var gridLength = grid[0].count\n        ^\n/tmp/tmp928ry5iq.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp928ry5iq.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:59:9: error:\
    \ invalid redeclaration of 'gridIndex'\n    var gridIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:29:9:\
    \ note: 'gridIndex' previously declared here\n    var gridIndex = 0\n        ^\n\
    /tmp/tmp928ry5iq.swift:62:9: error: invalid redeclaration of 'gridLength'\n  \
    \  var gridLength = grid[0].count\n        ^\n/tmp/tmp928ry5iq.swift:32:9: note:\
    \ 'gridLength' previously declared here\n    var gridLength = grid[0].count\n\
    \        ^\n/tmp/tmp928ry5iq.swift:71:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:74:9:\
    \ error: invalid redeclaration of 'gridIndex'\n    var gridIndex = 0\n       \
    \ ^\n/tmp/tmp928ry5iq.swift:29:9: note: 'gridIndex' previously declared here\n\
    \    var gridIndex = 0\n        ^\n/tmp/tmp928ry5iq.swift:77:9: error: invalid\
    \ redeclaration of 'gridLength'\n    var gridLength = grid[0].count\n    "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxIndex = 0\n    \n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                maxCount\
    \ = 0\n                maxIndex = 0\n                \n                for index\
    \ in 0..<capacity {\n                    if grid[row][index] == 1 {\n        \
    \                maxCount += 1\n                        if maxCount > max {\n\
    \                            max = maxCount\n                            maxIndex\
    \ = index\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdsjj_ruo.swift:30:29: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                    if grid[row][index] ==\
    \ 1 {\n                            ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    var row = 0\n    var col = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                \n                let newCapacity = capacity\
    \ - grid[row][col]\n                \n                if newCapacity > max {\n\
    \                    max = newCapacity\n                    count = 0\n      \
    \          }\n                \n                grid[row][col] = 0\n         \
    \       \n                count += newCapacity - capacity\n                \n\
    \                if count == 0 {\n                    max = 0\n              \
    \  }\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvkgzrrb2.swift:35:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if grid[i][j] == 1 {\n                max += capacity\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp16mplbom/tmp16mplbom.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c7391ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c73611b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c73611988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c736107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16mplbom                        0x00005628df8f3606 <unavailable> + 5638

    5    libc.so.6                          0x00002b0c73b06460 __libc_start_main +
    245

    6    tmp16mplbom                        0x00005628df8f3199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for _, row := range grid\
    \ {\n        for _, bucket := range row {\n            buckets[bucket] = append(buckets[bucket],\
    \ 0)\n        }\n    }\n    for i := 0; i < capacity; i++ {\n        buckets =\
    \ append(buckets, make([]int, capacity))\n    }\n    for _, row := range grid\
    \ {\n        for _, bucket := range row {\n            buckets[bucket] = append(buckets[bucket],\
    \ 1)\n        }\n    }\n    for i := 0; i < capacity; i++ {\n        for _, bucket\
    \ := range buckets[i] {\n            if buckets[i] > 0 {\n                buckets[i]\
    \ -= 1\n                result += buckets[i]\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplrbz08fm.swift:19:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmplrbz08fm.swift:20:10: error: expected 'in' after for-each\
    \ pattern\n    for _, row := range grid {\n         ^\n/tmp/tmplrbz08fm.swift:20:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, row := range\
    \ grid {\n         ^\n/tmp/tmplrbz08fm.swift:21:14: error: expected 'in' after\
    \ for-each pattern\n        for _, bucket := range row {\n             ^\n/tmp/tmplrbz08fm.swift:21:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, bucket\
    \ := range row {\n             ^\n/tmp/tmplrbz08fm.swift:25:12: error: expected\
    \ type\n    for i := 0; i < capacity; i++ {\n           ^\n            <#type#>\n\
    /tmp/tmplrbz08fm.swift:25:12: error: expected 'in' after for-each pattern\n  \
    \  for i := 0; i < capacity; i++ {\n           ^\n/tmp/tmplrbz08fm.swift:25:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < capacity;\
    \ i++ {\n           ^\n/tmp/tmplrbz08fm.swift:26:42: error: expected ',' separator\n\
    \        buckets = append(buckets, make([]int, capacity))\n                  \
    \                       ^\n                                         ,\n/tmp/tmplrbz08fm.swift:28:10:\
    \ error: expected 'in' after for-each pattern\n    for _, row := range grid {\n\
    \         ^\n/tmp/tmplrbz08fm.swift:28:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, row := range grid {\n         ^\n/tmp/tmplrbz08fm.swift:29:14:\
    \ error: expected 'in' after for-each pattern\n        for _, bucket := range\
    \ row {\n             ^\n/tmp/tmplrbz08fm.swift:29:14: error: expected Sequence\
    \ expression for for-each loop\n        for _, bucket := range row {\n       \
    \      ^\n/tmp/tmplrbz08fm.swift:33:12: error: expected type\n    for i := 0;\
    \ i < capacity; i++ {\n           ^\n            <#type#>\n/tmp/tmplrbz08fm.swift:33:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < capacity; i++\
    \ {\n           ^\n/tmp/tmplrbz08fm.swift:33:12: error: expected Sequence e"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for _ in 0..<n {\n        \n\
    \        let buckets = (0..<capacity).map { _ in 0 }\n        \n        for j\
    \ in 0..<grid[0][0].count {\n            \n            for i in 0..<n {\n    \
    \            \n                let bucket = buckets[grid[i][j]]\n            \
    \    \n                if bucket > 0 {\n                    \n               \
    \     buckets[bucket] = bucket - 1\n                    \n                   \
    \ if bucket > max {\n                        max = bucket\n                  \
    \  }\n                }\n            }\n        }\n    }\n    \n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6bp0n0c2.swift:27:33: error: value of type 'Int' has no member\
    \ 'count'\n        for j in 0..<grid[0][0].count {\n                     ~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var result\
    \ = 0\n    for row in grid {\n        if row[0] == 0 {\n            continue\n\
    \        }\n        result += row[0]\n        for col in 1..<row.count {\n   \
    \         if row[col] == 0 {\n                continue\n            }\n      \
    \      result += row[col]\n            if result > capacity {\n              \
    \  break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp66a304f0/tmp66a304f0.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b336b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b333adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b333ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b333ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp66a304f0                        0x0000556e16c6d776 <unavailable> + 6006

    5    libc.so.6                          0x00002b0b338a2460 __libc_start_main +
    245

    6    tmp66a304f0                        0x0000556e16c6d309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgbry1d1q.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpgbry1d1q.swift:35:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:38:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:41:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:44:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpgbry1d1q.swift:47:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:50:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:53:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpgbry1d1q.swift:26:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpgbry1d1q.swift:56:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:32:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpgbry1d1q.swift:59:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpgbry1d1q.swift:26:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += 1\n            }\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr2gth4wc/tmpr2gth4wc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83438e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83435d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83435d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83435d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2gth4wc                        0x00005635b128b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b8343acd460 __libc_start_main +
    245

    6    tmpr2gth4wc                        0x00005635b128b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket length\n    var bucketLength\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket length\n\
    \    var bucketLength = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket length\n    var bucketLength = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    //\
    \ init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp85j163dk.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp85j163dk.swift:23:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp85j163dk.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp85j163dk.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp85j163dk.swift:35:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp85j163dk.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp85j163dk.swift:38:9: error:\
    \ invalid redeclaration of 'bucketLength'\n    var bucketLength = 0\n        ^\n\
    /tmp/tmp85j163dk.swift:29:9: note: 'bucketLength' previously declared here\n \
    \   var bucketLength = 0\n        ^\n/tmp/tmp85j163dk.swift:41:9: error: invalid\
    \ redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n        ^\n/tmp/tmp85j163dk.swift:32:9:\
    \ note: 'bucketCapacity' previously declared here\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmp85j163dk.swift:44:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp85j163dk.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp85j163dk.swift:47:9:\
    \ error: invalid redeclaration of 'bucketLength'\n    var bucketLength = 0\n \
    \       ^\n/tmp/tmp85j163dk.swift:29:9: note: 'bucketLength' previously declared\
    \ here\n    var bucketLength = 0\n        ^\n/tmp/tmp85j163dk.swift:50:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmp85j163dk.swift:32:9: note: 'bucketCapacity' previously declared "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init max value\n    var max = 0\n    \n    // init max index\n \
    \   var maxIndex = 0\n    \n    // init index\n    var index = 0\n    \n    //\
    \ init max bucket index\n    var maxBucketIndex = 0\n    \n    // init max bucket\
    \ value\n    var maxBucketValue = 0\n    \n    // init max bucket index\n    var\
    \ maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex\
    \ = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex = 0\n \
    \   \n    // init max bucket index\n    var maxBucketValueIndex = 0\n    \n  \
    \  // init max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init\
    \ max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket\
    \ index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n\
    \    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var\
    \ maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex\
    \ = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex = 0\n \
    \   \n    // init max bucket index\n    var maxBucketValueIndex = 0\n    \n  \
    \  // init max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init\
    \ max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket\
    \ index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n\
    \    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var\
    \ maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex\
    \ = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex = 0\n \
    \   \n    // init max bucket index\n    var maxBucketValueIndex = 0\n    \n  \
    \  // init max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init\
    \ max bucket index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket\
    \ index\n    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n\
    \    var maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var\
    \ maxBucketValueIndex = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex\
    \ = 0\n    \n    // init max bucket index\n    var maxBucketValueIndex = 0\n \
    \   \n    // init max bucket index\n    var maxBucketValueIndex = 0\n    \n  \
    \  // init max \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvjqva_c0.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpvjqva_c0.swift:44:9: error: invalid\
    \ redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex = 0\n  \
    \      ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:47:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:50:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:53:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:56:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:59:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:62:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n        ^\n/tmp/tmpvjqva_c0.swift:41:9: note: 'maxBucketValueIndex' previously\
    \ declared here\n    var maxBucketValueIndex = 0\n        ^\n/tmp/tmpvjqva_c0.swift:65:9:\
    \ error: invalid redeclaration of 'maxBucketValueIndex'\n    var maxBucketValueIndex\
    \ = 0\n       "
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col > max {\n\
    \                max = col\n            }\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9i8yzqxi/tmp9i8yzqxi.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af96f618c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af96f30fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af96f30f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af96f30e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9i8yzqxi                        0x000056502ce0d546 <unavailable> + 5446

    5    libc.so.6                          0x00002af96f804460 __libc_start_main +
    245

    6    tmp9i8yzqxi                        0x000056502ce0d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init well count\n    var wellCount = 0\n    \n    // init bucket\
    \ count\n    var bucketCount = 0\n    \n    // init grid count\n    var gridCount\
    \ = 0\n    \n    // init grid length\n    var gridLength = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n    var gridWidth = 0\n    \n    // init grid height\n    var gridHeight\
    \ = 0\n    \n    // init grid width\n    var gridWidth = 0\n    \n    // init\
    \ grid height\n    var gridHeight = 0\n    \n    // init grid width\n    var gridWidth\
    \ = 0\n    \n    // init grid height\n    var gridHeight = 0\n    \n    // init\
    \ grid width\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp75uyzb6r.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp75uyzb6r.swift:44:9: error: invalid\
    \ redeclaration of 'gridWidth'\n    var gridWidth = 0\n        ^\n/tmp/tmp75uyzb6r.swift:38:9:\
    \ note: 'gridWidth' previously declared here\n    var gridWidth = 0\n        ^\n\
    /tmp/tmp75uyzb6r.swift:47:9: error: invalid redeclaration of 'gridHeight'\n  \
    \  var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:41:9: note: 'gridHeight'\
    \ previously declared here\n    var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:50:9:\
    \ error: invalid redeclaration of 'gridWidth'\n    var gridWidth = 0\n       \
    \ ^\n/tmp/tmp75uyzb6r.swift:38:9: note: 'gridWidth' previously declared here\n\
    \    var gridWidth = 0\n        ^\n/tmp/tmp75uyzb6r.swift:53:9: error: invalid\
    \ redeclaration of 'gridHeight'\n    var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:41:9:\
    \ note: 'gridHeight' previously declared here\n    var gridHeight = 0\n      \
    \  ^\n/tmp/tmp75uyzb6r.swift:56:9: error: invalid redeclaration of 'gridWidth'\n\
    \    var gridWidth = 0\n        ^\n/tmp/tmp75uyzb6r.swift:38:9: note: 'gridWidth'\
    \ previously declared here\n    var gridWidth = 0\n        ^\n/tmp/tmp75uyzb6r.swift:59:9:\
    \ error: invalid redeclaration of 'gridHeight'\n    var gridHeight = 0\n     \
    \   ^\n/tmp/tmp75uyzb6r.swift:41:9: note: 'gridHeight' previously declared here\n\
    \    var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:62:9: error: invalid\
    \ redeclaration of 'gridWidth'\n    var gridWidth = 0\n        ^\n/tmp/tmp75uyzb6r.swift:38:9:\
    \ note: 'gridWidth' previously declared here\n    var gridWidth = 0\n        ^\n\
    /tmp/tmp75uyzb6r.swift:65:9: error: invalid redeclaration of 'gridHeight'\n  \
    \  var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:41:9: note: 'gridHeight'\
    \ previously declared here\n    var gridHeight = 0\n        ^\n/tmp/tmp75uyzb6r.swift:68:9:\
    \ error: invalid redeclaration of 'gridWidth'\n    var gridWidth = 0\n       \
    \ ^\n/tmp/tmp75uyzb6r.swift:38:9: note: 'gridWidth' previously declared here\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        var maxRow = row[0]\n        for col in row {\n\
    \            if col > maxRow {\n                maxRow = col\n            }\n\
    \        }\n        max += maxRow\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1kon48nx/tmp1kon48nx.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace7110cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace70e03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace70e03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace70e027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1kon48nx                        0x0000564e4c170596 <unavailable> + 5526

    5    libc.so.6                          0x00002ace712f8460 __libc_start_main +
    245

    6    tmp1kon48nx                        0x0000564e4c170129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = make([][]int,\
    \ capacity)\n    \n    // init wells\n    var wells = make([][]int, capacity)\n\
    \    \n    // init buckets\n    var bucketsCount = capacity\n    \n    // init\
    \ wells\n    var wellsCount = capacity\n    \n    // init buckets\n    var bucketsCount2\
    \ = capacity\n    \n    // init wells\n    var wellsCount2 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount3 = capacity\n    \n    // init wells\n\
    \    var wellsCount3 = capacity\n    \n    // init buckets\n    var bucketsCount4\
    \ = capacity\n    \n    // init wells\n    var wellsCount4 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount5 = capacity\n    \n    // init wells\n\
    \    var wellsCount5 = capacity\n    \n    // init buckets\n    var bucketsCount6\
    \ = capacity\n    \n    // init wells\n    var wellsCount6 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount7 = capacity\n    \n    // init wells\n\
    \    var wellsCount7 = capacity\n    \n    // init buckets\n    var bucketsCount8\
    \ = capacity\n    \n    // init wells\n    var wellsCount8 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount9 = capacity\n    \n    // init wells\n\
    \    var wellsCount9 = capacity\n    \n    // init buckets\n    var bucketsCount10\
    \ = capacity\n    \n    // init wells\n    var wellsCount10 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount11 = capacity\n    \n    // init wells\n\
    \    var wellsCount11 = capacity\n    \n    // init buckets\n    var bucketsCount12\
    \ = capacity\n    \n    // init wells\n    var wellsCount12 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount13 = capacity\n    \n    // init wells\n\
    \    var wellsCount13 = capacity\n    \n    // init buckets\n    var bucketsCount14\
    \ = capacity\n    \n    // init wells\n    var wellsCount14 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount15 = capacity\n    \n    // init wells\n\
    \    var wellsCount15 = capacity\n    \n    // init buckets\n    var bucketsCount16\
    \ = capacity\n    \n    // init wells\n    var wellsCount16 = capacity\n    \n\
    \    // init buckets\n    var bucketsCount17\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmplzzl331f.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmplzzl331f.swift:26:26: error: expected ',' separator\n   \
    \ var wells = make([][]int, capacity)\n                         ^\n          \
    \               ,\n/tmp/tmplzzl331f.swift:23:19: error: cannot find 'make' in\
    \ scope\n    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmplzzl331f.swift:23:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmplzzl331f.swift:23:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmplzzl331f.swift:26:17:\
    \ error: cannot find 'make' in scope\n    var wells = make([][]int, capacity)\n\
    \                ^~~~\n/tmp/tmplzzl331f.swift:26:26: error: cannot find 'int'\
    \ in scope\n    var wells = make([][]int, capacity)\n                        \
    \ ^~~\n/tmp/tmplzzl331f.swift:26:25: error: missing argument for parameter #1\
    \ in call\n    var wells = make([][]int, capacity)\n                        ^\n\
    \                        <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared\
    \ here\n    @inlinable public subscript(index: Int) -> Element { get set }\n \
    \                     ^\n/tmp/tmplzzl331f.swift:125:9: error: type annotation\
    \ missing in pattern\n    var bucketsCount17\n        ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        \n\
    \        let row = grid[i]\n        \n        for j in 0..<row.count {\n     \
    \       \n            let bucket = row[j]\n            \n            if bucket\
    \ > max {\n                \n                max = bucket\n            }\n   \
    \     }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp3s9xnp3j/tmp3s9xnp3j.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b416933ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4169031b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4169031988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41690307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3s9xnp3j                        0x00005607c6141656 <unavailable> + 5718

    5    libc.so.6                          0x00002b4169526460 __libc_start_main +
    245

    6    tmp3s9xnp3j                        0x00005607c61411e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init visited\n\
    \    var visited = [Int](capacity)\n    \n    // init visited count\n    var visitedCount\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket index\n    var wellIndex =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex2 = 0\n    \n    // init\
    \ bucket index\n    var wellIndex2 = 0\n    \n    // init bucket index\n    var\
    \ bucketIndex3 = 0\n    \n    // init bucket index\n    var wellIndex3 = 0\n \
    \   \n    // init bucket index\n    var bucketIndex4 = 0\n    \n    // init bucket\
    \ index\n    var wellIndex4 = 0\n    \n    // init bucket index\n    var bucketIndex5\
    \ = 0\n    \n    // init bucket index\n    var wellIndex5 = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex6 = 0\n    \n    // init bucket index\n   \
    \ var wellIndex6 = 0\n    \n    // init bucket index\n    var bucketIndex7 = 0\n\
    \    \n    // init bucket index\n    var wellIndex7 = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex8 = 0\n    \n    // init bucket index\n    var wellIndex8\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex9 = 0\n    \n    //\
    \ init bucket index\n    var wellIndex9 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex10 = 0\n    \n    // init bucket index\n    var wellIndex10\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex11 = 0\n    \n    //\
    \ init bucket index\n    var wellIndex11 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex12 = 0\n    \n    // init bucket index\n    var wellIndex12\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex13 = 0\n    \n    //\
    \ init bucket index\n    var wellIndex13 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex14 = 0\n    \n    // init bucket index\n    var wellIndex14\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex15 = 0\n    \n    //\
    \ init bucket index\n    var wellIndex15 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex16 = 0\n    \n    // init bucket index\n    var wellIndex16\
    \ = 0\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3zrwe2gl.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp3zrwe2gl.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmp3zrwe2gl.swift:29:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpac1o9u7o/tmpac1o9u7o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8964d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8961c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8961c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8961c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpac1o9u7o                        0x000055c7c70df717 <unavailable> + 5911

    5    libc.so.6                          0x00002af8966be460 __libc_start_main +
    245

    6    tmpac1o9u7o                        0x000055c7c70df0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var count\
    \ = 0\n    \n    for row in grid {\n        for col in row {\n            if col\
    \ == 0 {\n                count += 1\n            }\n        }\n    }\n    \n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr5q40tpv/tmpr5q40tpv.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacff9eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacff6e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacff6e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacff6e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5q40tpv                        0x000055d9010ac717 <unavailable> + 5911

    5    libc.so.6                          0x00002aacffbda460 __libc_start_main +
    245

    6    tmpr5q40tpv                        0x000055d9010ac0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for row in 0..<n {\n        for\
    \ col in 0..<n {\n            if grid[row][col] == 1 {\n                max +=\
    \ capacity\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnj6ho25w/tmpnj6ho25w.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23afd3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23afa35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23afa35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23afa347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnj6ho25w                        0x00005593da8a5606 <unavailable> + 5638

    5    libc.so.6                          0x00002b23aff2a460 __libc_start_main +
    245

    6    tmpnj6ho25w                        0x00005593da8a5199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ max value\n    var bucketMax = 0\n    \n    // init bucket min value\n    var\
    \ bucketMin = grid[0][0].min()\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max value\n    var bucketMax = 0\n    \n    // init bucket min value\n\
    \    var bucketMin = grid[0][0].min()\n    \n    // init bucket index\n    var\
    \ bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n\
    \    // init bucket max value\n    var bucketMax = 0\n    \n    // init bucket\
    \ min value\n    var bucketMin = grid[0][0].min()\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket max value\n    var bucketMax = 0\n    \n    // init\
    \ bucket min value\n    var bucketMin = grid[0][0].min()\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n    \n    //\
    \ init bucket min value\n    var bucketMin = grid[0][0].min()\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax = 0\n \
    \   \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n   \
    \ \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max value\n    var bucketMax\
    \ = 0\n    \n    // init bucket min value\n    var bucketMin = grid[0][0].min()\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcohraik6.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpcohraik6.swift:35:32: error: cannot\
    \ call value of non-function type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                               ^  ~~\n                                  \n/tmp/tmpcohraik6.swift:35:28:\
    \ error: static member 'min' cannot be used on instance of type 'Int'\n    var\
    \ bucketMin = grid[0][0].min()\n                    ~~~~~~~^~~\n             \
    \       Int\n/tmp/tmpcohraik6.swift:38:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpcohraik6.swift:26:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpcohraik6.swift:41:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpcohraik6.swift:29:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpcohraik6.swift:44:9: error: invalid\
    \ redeclaration of 'bucketMax'\n    var bucketMax = 0\n        ^\n/tmp/tmpcohraik6.swift:32:9:\
    \ note: 'bucketMax' previously declared here\n    var bucketMax = 0\n        ^\n\
    /tmp/tmpcohraik6.swift:47:32: error: cannot call value of non-function type 'Int'\n\
    \    var bucketMin = grid[0][0].min()\n                               ^  ~~\n\
    \                                  \n/tmp/tmpcohraik6.swift:47:28: error: static\
    \ member 'min' cannot be used on instance of type 'Int'\n    var bucketMin = grid[0][0].min()\n\
    \                    ~~~~~~~^~~\n                    Int\n/tmp/tmpcohraik6.swift:50:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpcohraik6.swift:26:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpcohraik6.swift:53:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpcohraik6.swift:29:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpcohraik6.swift:56:9: error: invali"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for _ in 0..<grid.count {\n        for _ in\
    \ 0..<grid[0].count {\n            if grid[0][_] > 0 {\n                grid[0][_]\
    \ -= capacity\n                max += capacity\n                count += 1\n \
    \           }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphkhzhnpa.swift:24:24: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[0][_] > 0 {\n       \
    \                ^\n/tmp/tmphkhzhnpa.swift:25:25: error: '_' can only appear in\
    \ a pattern or on the left side of an assignment\n                grid[0][_] -=\
    \ capacity\n                        ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    if grid.count\
    \ == 0 {\n        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n\
    \    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                grid[i][j] = 0\n           \
    \     \n                if max < capacity {\n                    max = capacity\n\
    \                    maxIndex = i\n                }\n                \n     \
    \           for k in 0..<grid[i].count {\n                    if grid[i][k] ==\
    \ 1 {\n                        grid[i][k] = 0\n                    }\n       \
    \         }\n            }\n        }\n    }\n    \n    return maxIndex\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvunwd2uw.swift:28:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n/tmp/tmpvunwd2uw.swift:37:32: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[i][k] = 0\n              \
    \          ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init bucket array\n    var buckets\
    \ = make([][]int, capacity)\n    \n    // init bucket count\n    var count = 0\n\
    \    \n    // init bucket index\n    var i = 0\n    \n    // init bucket length\n\
    \    var j = 0\n    \n    // init bucket capacity\n    var k = 0\n    \n    //\
    \ init bucket capacity\n    var l = 0\n    \n    // init bucket capacity\n   \
    \ var m = 0\n    \n    // init bucket capacity\n    var n = 0\n    \n    // init\
    \ bucket capacity\n    var o = 0\n    \n    // init bucket capacity\n    var p\
    \ = 0\n    \n    // init bucket capacity\n    var q = 0\n    \n    // init bucket\
    \ capacity\n    var r = 0\n    \n    // init bucket capacity\n    var s = 0\n\
    \    \n    // init bucket capacity\n    var t = 0\n    \n    // init bucket capacity\n\
    \    var u = 0\n    \n    // init bucket capacity\n    var v = 0\n    \n    //\
    \ init bucket capacity\n    var w = 0\n    \n    // init bucket capacity\n   \
    \ var x = 0\n    \n    // init bucket capacity\n    var y = 0\n    \n    // init\
    \ bucket capacity\n    var z = 0\n    \n    // init bucket capacity\n    var aa\
    \ = 0\n    \n    // init bucket capacity\n    var ab = 0\n    \n    // init bucket\
    \ capacity\n    var ac = 0\n    \n    // init bucket capacity\n    var ad = 0\n\
    \    \n    // init bucket capacity\n    var ae = 0\n    \n    // init bucket capacity\n\
    \    var af = 0\n    \n    // init bucket capacity\n    var ag = 0\n    \n   \
    \ // init bucket capacity\n    var ah = 0\n    \n    // init bucket capacity\n\
    \    var ai = 0\n    \n    // init bucket capacity\n    var aj = 0\n    \n   \
    \ // init bucket capacity\n    var ak = 0\n    \n    // init bucket capacity\n\
    \    var al = 0\n    \n    // init bucket capacity\n    var am = 0\n    \n   \
    \ // init bucket capacity\n    var an = 0\n    \n    // init bucket capacity\n\
    \    var ao = 0\n    \n    // init bucket capacity\n    var ap = 0\n    \n   \
    \ // init bucket capacity\n    var aq = 0\n    \n    // init bucket capacity\n\
    \    var ar = 0\n    \n    // init bucket capacity\n    var as = 0\n    \n   \
    \ // init bucket capacity\n    var at = 0\n    \n    // init bucket capacity\n\
    \    var au = 0\n    \n    // init bucket capacity\n    var av = 0\n    \n   \
    \ // init bucket capacity\n    var aw = 0\n    \n    // init bucket capacity\n\
    \    var ax = 0\n    \n    // init bucket capacity\n    var ay = 0\n    \n   \
    \ // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe1ltwndw.swift:23:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpe1ltwndw.swift:137:9: error: keyword 'as' cannot be used\
    \ as an identifier here\n    var as = 0\n        ^\n/tmp/tmpe1ltwndw.swift:137:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var as =\
    \ 0\n        ^~\n        `as`\n/tmp/tmpe1ltwndw.swift:23:19: error: cannot find\
    \ 'make' in scope\n    var buckets = make([][]int, capacity)\n               \
    \   ^~~~\n/tmp/tmpe1ltwndw.swift:23:28: error: cannot find 'int' in scope\n  \
    \  var buckets = make([][]int, capacity)\n                           ^~~\n/tmp/tmpe1ltwndw.swift:23:27:\
    \ error: missing argument for parameter #1 in call\n    var buckets = make([][]int,\
    \ capacity)\n                          ^\n                          <#Int#>\n\
    Swift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public\
    \ subscript(index: Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited = [Int](capacity)\n    \n    //\
    \ init visited map\n    var visited2 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited3 = [Int](capacity)\n    \n    // init visited map\n   \
    \ var visited4 = [Int](capacity)\n    \n    // init visited map\n    var visited5\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited6 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited7 = [Int](capacity)\n    \n   \
    \ // init visited map\n    var visited8 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited9 = [Int](capacity)\n    \n    // init visited map\n   \
    \ var visited10 = [Int](capacity)\n    \n    // init visited map\n    var visited11\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited12 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited13 = [Int](capacity)\n    \n  \
    \  // init visited map\n    var visited14 = [Int](capacity)\n    \n    // init\
    \ visited map\n    var visited15 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited16 = [Int](capacity)\n    \n    // init visited map\n  \
    \  var visited17 = [Int](capacity)\n    \n    // init visited map\n    var visited18\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited19 = [Int](capacity)\n\
    \    \n    // init visited map\n    var visited20 = [Int](capacity)\n    \n  \
    \  // init visited map\n    var visited21 = [Int](capacity)\n    \n    // init\
    \ visited map\n    var visited22 = [Int](capacity)\n    \n    // init visited\
    \ map\n    var visited23 = [Int](capacity)\n    \n    // init visited map\n  \
    \  var visited24 = [Int](capacity)\n    \n    // init visited map\n    var visited25\
    \ = [Int](capacity)\n    \n    // init visited map\n    var visited26 = [Int](capacity)\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcv34l__e.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpcv34l__e.swift:26:25: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpcv34l__e.swift:29:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited2 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:32:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited3 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:35:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited4 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:38:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited5 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:41:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited6 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:44:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited7 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:47:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited8 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:50:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited9 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpcv34l__e.swift:53:27:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited10 = [Int](capacity)\n\
    \                          ^\n                          arrayLiteral: \n/tmp/"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // write\
    \ your code here\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpoz5_ke49/tmpoz5_ke49.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56cf199c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56cee90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56cee90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56cee8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoz5_ke49                        0x00005617636f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b56cf385460 __libc_start_main +
    245

    6    tmpoz5_ke49                        0x00005617636f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init grid\
    \ index\n    var gridIndex = 0\n    \n    // init grid length\n    var gridLength\
    \ = grid.count\n    \n    // init grid capacity\n    var gridCapacity = grid[0][0].count\n\
    \    \n    // init grid width\n    var gridWidth = grid[0][0].count\n    \n  \
    \  // init grid height\n    var gridHeight = grid[0].count\n    \n    // init\
    \ grid width\n    var gridWidth = grid[0][0].count\n    \n    // init grid height\n\
    \    var gridHeight = grid[0].count\n    \n    // init grid width\n    var gridWidth\
    \ = grid[0][0].count\n    \n    // init grid height\n    var gridHeight = grid[0].count\n\
    \    \n    // init grid width\n    var gridWidth = grid[0][0].count\n    \n  \
    \  // init grid height\n    var gridHeight = grid[0].count\n    \n    // init\
    \ grid width\n    var gridWidth = grid[0][0].count\n    \n    // init grid height\n\
    \    var gridHeight = grid[0].count\n    \n    // init grid width\n    var gridWidth\
    \ = grid[0][0].count\n    \n    // init grid height\n    var gridHeight = grid[0].count\n\
    \    \n    // init grid width\n    var gridWidth = grid[0][0].count\n    \n  \
    \  // init grid height\n    var gridHeight = grid[0].count\n    \n    // init\
    \ grid width\n    var gridWidth = grid[0][0].count\n    \n    // init grid height\n\
    \    var gridHeight = grid[0].count\n    \n    // init grid width\n    var gridWidth\
    \ = grid[0][0].count\n    \n    // init grid height\n    var gridHeight = grid[0].count\n\
    \    \n    // init grid width\n    var gridWidth = grid[0][0].count\n    \n  \
    \  // init grid height\n    var gridHeight = grid[0].count\n    \n    // init\
    \ grid width\n    var gridWidth = grid[0][0].count\n    \n    // init grid height\n\
    \    var gridHeight = grid[0].count\n    \n    // init grid width\n    var gridWidth\
    \ = grid[0][0].count\n    \n    // init grid height\n    var gridHeight = grid[0].count\n\
    \    \n    // init grid width\n    var gridWidth = grid[0][0].count\n    \n  \
    \  // init grid height\n    var gridHeight = grid[0].count\n    \n    // init\
    \ grid width\n    var gridWidth = grid[0][0].count\n    \n    // init grid height\n\
    \    var gridHeight = grid[0].count\n    \n    // init grid width\n    var gridWidth\
    \ = grid[0][0].count\n    \n    // init grid height\n    var gridHeight = grid[0].\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpoju7pawb.swift:125:29: error: expected member name following '.'\n\
    \    var gridHeight = grid[0].\n                            ^\n/tmp/tmpoju7pawb.swift:23:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var buckets = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpoju7pawb.swift:35:35:\
    \ error: value of type 'Int' has no member 'count'\n    var gridCapacity = grid[0][0].count\n\
    \                       ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:38:32: error:\
    \ value of type 'Int' has no member 'count'\n    var gridWidth = grid[0][0].count\n\
    \                    ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:44:32: error: value\
    \ of type 'Int' has no member 'count'\n    var gridWidth = grid[0][0].count\n\
    \                    ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:47:9: error: invalid\
    \ redeclaration of 'gridHeight'\n    var gridHeight = grid[0].count\n        ^\n\
    /tmp/tmpoju7pawb.swift:41:9: note: 'gridHeight' previously declared here\n   \
    \ var gridHeight = grid[0].count\n        ^\n/tmp/tmpoju7pawb.swift:50:32: error:\
    \ value of type 'Int' has no member 'count'\n    var gridWidth = grid[0][0].count\n\
    \                    ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:53:9: error: invalid\
    \ redeclaration of 'gridHeight'\n    var gridHeight = grid[0].count\n        ^\n\
    /tmp/tmpoju7pawb.swift:41:9: note: 'gridHeight' previously declared here\n   \
    \ var gridHeight = grid[0].count\n        ^\n/tmp/tmpoju7pawb.swift:56:32: error:\
    \ value of type 'Int' has no member 'count'\n    var gridWidth = grid[0][0].count\n\
    \                    ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:59:9: error: invalid\
    \ redeclaration of 'gridHeight'\n    var gridHeight = grid[0].count\n        ^\n\
    /tmp/tmpoju7pawb.swift:41:9: note: 'gridHeight' previously declared here\n   \
    \ var gridHeight = grid[0].count\n        ^\n/tmp/tmpoju7pawb.swift:62:32: error:\
    \ value of type 'Int' has no member 'count'\n    var gridWidth = grid[0][0].count\n\
    \                    ~~~~~~~~~~ ^~~~~\n/tmp/tmpoju7pawb.swift:65:9: error: invalid\
    \ redeclaration of 'gridHeight'\n    var gridHeight = gr"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let n\
    \ = grid.count\n    \n    var max = 0\n    \n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if grid[i][j] == 1 {\n                max += 1\n \
    \               grid[i][j] = 0\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp49eszkrb.swift:27:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init wells\n    var wells = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited2 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited3 = [Int](capacity)\n    \n    // init visited wells\n    var visited4\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited5 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited6 = [Int](capacity)\n    \n \
    \   // init visited wells\n    var visited7 = [Int](capacity)\n    \n    // init\
    \ visited wells\n    var visited8 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited9 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited10 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited11 = [Int](capacity)\n    \n    // init visited wells\n    var visited12\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited13 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited14 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited15 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited16 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited17 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited18 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited19 = [Int](capacity)\n    \n    // init visited wells\n    var visited20\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited21 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited22 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited23 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited24 = [Int](capacity)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsh6euin8.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpsh6euin8.swift:26:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmpsh6euin8.swift:29:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpsh6euin8.swift:32:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited2 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:35:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited3 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:38:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited4 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:41:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited5 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:44:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited6 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:47:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited7 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:50:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited8 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8.swift:53:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited9 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmpsh6euin8."
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init well count\n    var wellCount = 0\n    \n    // init well length\n\
    \    var wellLength = 0\n    \n    // init bucket count\n    var bucketCount =\
    \ 0\n    \n    // init bucket length\n    var bucketLength = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min length\n    var bucketMinLength = 0\n    \n    //\
    \ init bucket max length\n    var bucketMaxLength = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket min length\n    var bucketMinLength\
    \ = 0\n    \n    // init bucket max length\n    var bucketMaxLength = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ min length\n    var bucketMinLength = 0\n    \n    // init bucket max length\n\
    \    var bucketMaxLength = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min length\n    var bucketMinLength = 0\n    \n    //\
    \ init bucket max length\n    var bucketMaxLength = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket min length\n    var bucketMinLength\
    \ = 0\n    \n    // init bucket max length\n    var bucketMaxLength = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket max capacity\n    var bucketMaxCapacity = 0\n    \n    // init bucket\
    \ min length\n    var bucketMinLength = 0\n    \n    // init bucket max length\n\
    \    var bucketMaxLength = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket max capacity\n    var bucketMaxCapacity = 0\n\
    \    \n    // init bucket min length\n    var bucketMinLength = 0\n    \n    //\
    \ init bucket max length\n    var bucketMaxLength = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket max capacity\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7vc2s936.swift:23:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp7vc2s936.swift:56:9: error: invalid\
    \ redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity = 0\n      \
    \  ^\n/tmp/tmp7vc2s936.swift:44:9: note: 'bucketMinCapacity' previously declared\
    \ here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmp7vc2s936.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp7vc2s936.swift:47:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp7vc2s936.swift:62:9:\
    \ error: invalid redeclaration of 'bucketMinLength'\n    var bucketMinLength =\
    \ 0\n        ^\n/tmp/tmp7vc2s936.swift:50:9: note: 'bucketMinLength' previously\
    \ declared here\n    var bucketMinLength = 0\n        ^\n/tmp/tmp7vc2s936.swift:65:9:\
    \ error: invalid redeclaration of 'bucketMaxLength'\n    var bucketMaxLength =\
    \ 0\n        ^\n/tmp/tmp7vc2s936.swift:53:9: note: 'bucketMaxLength' previously\
    \ declared here\n    var bucketMaxLength = 0\n        ^\n/tmp/tmp7vc2s936.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmp7vc2s936.swift:44:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmp7vc2s936.swift:71:9:\
    \ error: invalid redeclaration of 'bucketMaxCapacity'\n    var bucketMaxCapacity\
    \ = 0\n        ^\n/tmp/tmp7vc2s936.swift:47:9: note: 'bucketMaxCapacity' previously\
    \ declared here\n    var bucketMaxCapacity = 0\n        ^\n/tmp/tmp7vc2s936.swift:74:9:\
    \ error: invalid redeclaration of 'bucketMinLength'\n    var bucketMinLength =\
    \ 0\n        ^\n/tmp/tmp7vc2s936.swift:50:9: note: 'bucketMinLength' previously\
    \ declared here\n    var bucketMinLength = 0\n        ^\n/tmp/tmp7vc2s936.swift:77:9:\
    \ error: invalid redeclaration of 'bucketMaxLength'\n    var bucketMaxLength =\
    \ 0\n        ^\n/tmp/tmp7vc2s936.swift:53:9: note: 'bucketMaxLength' previously\
    \ declared here\n    var"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    let rowCount\
    \ = grid.count\n    let colCount = grid[0].count\n    \n    var maxCount = 0\n\
    \    \n    for row in 0..<rowCount {\n        for col in 0..<colCount {\n    \
    \        let bucket = grid[row][col]\n            \n            if bucket == 0\
    \ {\n                \n                let newCount = maxCount + (capacity - bucket)\n\
    \                \n                if newCount > maxCount {\n                \
    \    maxCount = newCount\n                }\n            }\n        }\n    }\n\
    \    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfuj2x94a/tmpfuj2x94a.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8f16b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8f13aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8f13ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8f13ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfuj2x94a                        0x000055ebb84ec827 <unavailable> + 6183

    5    libc.so.6                          0x00002ba8f18a3460 __libc_start_main +
    245

    6    tmpfuj2x94a                        0x000055ebb84ec1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    var maxCount = 0\n    for _ in 0..<grid.count {\n        var count = 0\n\
    \        for _ in 0..<grid[0].count {\n            if grid[count][_] == 1 {\n\
    \                grid[count][_] = 0\n                count += 1\n            \
    \    if count == capacity {\n                    maxCount += 1\n             \
    \       count = 0\n                }\n            }\n        }\n        if maxCount\
    \ > max {\n            max = maxCount\n        }\n        maxCount = 0\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk09c5agr.swift:23:28: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if grid[count][_] == 1 {\n  \
    \                         ^\n/tmp/tmpk09c5agr.swift:24:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n                grid[count][_]\
    \ = 0\n                            ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    \n    // init\
    \ result\n    var result = 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n\
    \    \n    // init buckets index\n    var bucketsIndex = 0\n    \n    // init\
    \ grid\n    var gridCopy = grid\n    \n    // init grid length\n    var gridLength\
    \ = gridCopy.count\n    \n    // init grid width\n    var gridWidth = gridCopy[0].count\n\
    \    \n    // init grid height\n    var gridHeight = gridCopy.count\n    \n  \
    \  // init grid width\n    var gridHeight = gridCopy[0].count\n    \n    // init\
    \ grid height\n    var gridWidth = gridCopy[0].count\n    \n    // init grid height\n\
    \    var gridHeight = gridCopy[0].count\n    \n    // init grid width\n    var\
    \ gridWidth = gridCopy[0].count\n    \n    // init grid height\n    var gridHeight\
    \ = gridCopy[0].count\n    \n    // init grid height\n    var gridWidth = gridCopy[0].count\n\
    \    \n    // init grid height\n    var gridHeight = gridCopy[0].count\n    \n\
    \    // init grid height\n    var gridWidth = gridCopy[0].count\n    \n    //\
    \ init grid height\n    var gridHeight = gridCopy[0].count\n    \n    // init\
    \ grid height\n    var gridWidth = gridCopy[0].count\n    \n    // init grid height\n\
    \    var gridHeight = gridCopy[0].count\n    \n    // init grid height\n    var\
    \ gridWidth = gridCopy[0].count\n    \n    // init grid height\n    var gridHeight\
    \ = gridCopy[0].count\n    \n    // init grid height\n    var gridWidth = gridCopy[0].count\n\
    \    \n    // init grid height\n    var gridHeight = gridCopy[0].count\n    \n\
    \    // init grid height\n    var gridWidth = gridCopy[0].count\n    \n    //\
    \ init grid height\n    var gridHeight = gridCopy[0].count\n    \n    // init\
    \ grid height\n    var gridWidth = gridCopy[0].count\n    \n    // init grid height\n\
    \    var gridHeight = gridCopy[0].count\n    \n    // init grid height\n    var\
    \ gridWidth = gridCopy[0].count\n    \n    // init grid height\n    var gridHeight\
    \ = gridCopy[0].count\n    \n    // init grid height\n    var gridWidth = gridCopy[0].count\n\
    \    \n    // init grid height\n    var gridHeight = gridCopy[0].count\n    \n\
    \    // init grid height\n    var gridWidth = gridCopy[0].count\n    \n    //\
    \ init grid height\n    var gridHeight = gridCopy[0].count\n    \n    // init\
    \ grid height\n    var gridWidth = gridCopy[0].count\n    \n    // init grid height\n\
    \    var gridHeight = gridCopy[0].count\n    \n    // init grid height\n    var\
    \ gridWidth = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3eoct0kt.swift:122:20: error: expected initial value after '='\n\
    \    var gridWidth = \n                   ^\n/tmp/tmp3eoct0kt.swift:23:25: error:\
    \ missing argument label 'arrayLiteral:' in call\n    var buckets = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmp3eoct0kt.swift:41:9:\
    \ error: invalid redeclaration of 'gridHeight'\n    var gridHeight = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:38:9: note: 'gridHeight' previously declared\
    \ here\n    var gridHeight = gridCopy.count\n        ^\n/tmp/tmp3eoct0kt.swift:44:9:\
    \ error: invalid redeclaration of 'gridWidth'\n    var gridWidth = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:35:9: note: 'gridWidth' previously declared\
    \ here\n    var gridWidth = gridCopy[0].count\n        ^\n/tmp/tmp3eoct0kt.swift:47:9:\
    \ error: invalid redeclaration of 'gridHeight'\n    var gridHeight = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:38:9: note: 'gridHeight' previously declared\
    \ here\n    var gridHeight = gridCopy.count\n        ^\n/tmp/tmp3eoct0kt.swift:50:9:\
    \ error: invalid redeclaration of 'gridWidth'\n    var gridWidth = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:35:9: note: 'gridWidth' previously declared\
    \ here\n    var gridWidth = gridCopy[0].count\n        ^\n/tmp/tmp3eoct0kt.swift:53:9:\
    \ error: invalid redeclaration of 'gridHeight'\n    var gridHeight = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:38:9: note: 'gridHeight' previously declared\
    \ here\n    var gridHeight = gridCopy.count\n        ^\n/tmp/tmp3eoct0kt.swift:56:9:\
    \ error: invalid redeclaration of 'gridWidth'\n    var gridWidth = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:35:9: note: 'gridWidth' previously declared\
    \ here\n    var gridWidth = gridCopy[0].count\n        ^\n/tmp/tmp3eoct0kt.swift:59:9:\
    \ error: invalid redeclaration of 'gridHeight'\n    var gridHeight = gridCopy[0].count\n\
    \        ^\n/tmp/tmp3eoct0kt.swift:38:9: note: 'gridHeight' previously declared\
    \ here\n    var gridHeight = gridCopy.count\n        ^\n/tmp/tmp3eoct0kt.swift:62:9:\
    \ error: invalid redeclaration of "
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var max = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                max += capacity\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpac1o9u7o/tmpac1o9u7o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8964d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8961c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8961c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8961c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpac1o9u7o                        0x000055c7c70df717 <unavailable> + 5911

    5    libc.so.6                          0x00002af8966be460 __libc_start_main +
    245

    6    tmpac1o9u7o                        0x000055c7c70df0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978719
