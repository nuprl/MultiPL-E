language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tx := n\n\ty := 1\n\tfor {\n\t\tif x == 1 {\n\
    \t\t\treturn y\n\t\t}\n\t\ty *= x\n\t\tx -= 1\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyxr6xzsj.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpyxr6xzsj.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpyxr6xzsj.swift:21:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpyxr6xzsj.swift:21:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpyxr6xzsj.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpyxr6xzsj.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpyxr6xzsj.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpyxr6xzsj.swift:19:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus.MaxValue():\n\
    \t\tpanic(\"modp: invalid parameters\")\n\tcase n == 0 || p == 0:\n\t\treturn\
    \ 0\n\tcase p == Modulus.MinValue():\n\t\treturn Modulus.MinValue()\n\tdefault:\n\
    \t\treturn Modulus.Mod2(n, p).IntValue()\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2v6dwjxx.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2v6dwjxx.swift:6:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: invalid parameters\")\n\
    \                ^~~~~\n/tmp/tmp2v6dwjxx.swift:10:10: error: cannot find 'Modulus'\
    \ in scope\n                return Modulus.MinValue()\n                      \
    \ ^~~~~~~\n/tmp/tmp2v6dwjxx.swift:12:10: error: cannot find 'Modulus' in scope\n\
    \                return Modulus.Mod2(n, p).IntValue()\n                      \
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p > p {\n\t\t\
    panic(\"modp called with p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif\
    \ n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n ==\
    \ 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n ==\
    \ 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n ==\
    \ 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p + 7\n\t}\n\tif n ==\
    \ 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p + 9\n\t}\n\tif n ==\
    \ 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn p + 11\n\t}\n\tif n\
    \ == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn p + 13\n\t}\n\t\
    if n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\
    \tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn p + 17\n\t\
    }\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn p + 19\n\
    \t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn p + 21\n\
    \t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn p + 23\n\
    \t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn p + 25\n\
    \t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn p + 27\n\
    \t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn p + 29\n\
    \t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn p + 31\n\
    \t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn p + 33\n\
    \t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn p + 35\n\
    \t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn p + 37\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_amzt1xw.swift:150:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_amzt1xw.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_amzt1xw.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp_amzt1xw.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp_amzt1xw.swift:11:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmp_amzt1xw.swift:132:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p - 1\
    \ {\n\t\treturn p - 1\n\t}\n\tif n == p - 1 {\n\t\treturn p\n\t}\n\tif n == p\
    \ - 2 {\n\t\treturn p - 1\n\t}\n\tif n == p - 2 {\n\t\treturn p\n\t}\n\tif n ==\
    \ p - 3 {\n\t\treturn p - 1\n\t}\n\tif n == p - 3 {\n\t\treturn p\n\t}\n\tif n\
    \ == p - 4 {\n\t\treturn p - 1\n\t}\n\tif n == p - 4 {\n\t\treturn p\n\t}\n\t\
    if n == p - 5 {\n\t\treturn p - 1\n\t}\n\tif n == p - 5 {\n\t\treturn p\n\t}\n\
    \tif n == p - 6 {\n\t\treturn p - 1\n\t}\n\tif n == p - 6 {\n\t\treturn p\n\t\
    }\n\tif n == p - 7 {\n\t\treturn p - 1\n\t}\n\tif n == p - 7 {\n\t\treturn p\n\
    \t}\n\tif n == p - 8 {\n\t\treturn p - 1\n\t}\n\tif n == p - 8 {\n\t\treturn p\n\
    \t}\n\tif n == p - 9 {\n\t\treturn p - 1\n\t}\n\tif n == p - 9 {\n\t\treturn p\n\
    \t}\n\tif n == p - 10 {\n\t\treturn p - 1\n\t}\n\tif n == p - 10 {\n\t\treturn\
    \ p\n\t}\n\tif n == p - 11 {\n\t\treturn p - 1\n\t}\n\tif n == p - 11 {\n\t\t\
    return p\n\t}\n\tif n == p - 12 {\n\t\treturn p - 1\n\t}\n\tif n == p - 12 {\n\
    \t\treturn p\n\t}\n\tif n == p - 13 {\n\t\treturn p - 1\n\t}\n\tif n == p - 13\
    \ {\n\t\treturn p\n\t}\n\tif n == p - 14 {\n\t\treturn p - 1\n\t}\n\tif n == p\
    \ - 14 {\n\t\treturn p\n\t}\n\tif n == p - 15 {\n\t\treturn p - 1\n\t}\n\tif n\
    \ == p - 15 {\n\t\treturn p\n\t}\n\tif n == p - 16 {\n\t\treturn p - 1\n\t}\n\t\
    if n == p - 16 {\n\t\treturn p\n\t}\n\tif n == p - 17 {\n\t\treturn p - 1\n\t\
    }\n\tif n == p - 17 {\n\t\treturn p\n\t}\n\tif n == p - 18 {\n\t\treturn p - 1\n\
    \t}\n\tif n == p - 18 {\n\t\treturn p\n\t}\n\tif n == p - 19 {\n\t\treturn p -\
    \ 1\n\t}\n\tif n == p - 19 {\n\t\treturn p\n\t}\n\tif n == p - 20 {\n\t\treturn\
    \ p - 1\n\t}\n\tif n == p - 20 {\n\t\treturn p\n\t}\n\tif n == p - 21 \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt68130r1.swift:142:16: error: expected '{' after 'if' condition\n\
    \        if n == p - 21 \n                      ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (pow(2, n) % p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg8ekix8e.swift:4:10: error: cannot find 'pow' in scope\n      \
    \  return (pow(2, n) % p)\n                ^~~\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p\
    \ > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p\
    \ > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p\
    \ > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p\
    \ > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p\
    \ > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyfwfwew1.swift:105:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpyfwfwew1.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpyfwfwew1.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpyfwfwew1.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpyfwfwew1.swift:17:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:23:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmpyfwfwew1.swift:26:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpyfwfwew1.swift:29:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:32:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:35:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmpyfwfwew1.swift:38:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpyfwfwew1.swift:41:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:44:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpyfwfwew1.swift:47:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmpyfwfwew1.sw"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbi1a2f7x.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) + p\n                   ^\n            \
    \        n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p > p {\n\t\t\
    panic(\"modp called with p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif\
    \ n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n ==\
    \ 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n ==\
    \ 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n ==\
    \ 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p + 7\n\t}\n\tif n ==\
    \ 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p + 9\n\t}\n\tif n ==\
    \ 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn p + 11\n\t}\n\tif n\
    \ == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn p + 13\n\t}\n\t\
    if n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\
    \tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn p + 17\n\t\
    }\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn p + 19\n\
    \t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn p + 21\n\
    \t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn p + 23\n\
    \t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn p + 25\n\
    \t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn p + 27\n\
    \t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn p + 29\n\
    \t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn p + 31\n\
    \t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn p + 33\n\
    \t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn p + 35\n\
    \t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn p + 37\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_amzt1xw.swift:150:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_amzt1xw.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_amzt1xw.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp_amzt1xw.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp_amzt1xw.swift:11:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmp_amzt1xw.swift:132:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus.MaxValue():\n\
    \t\tpanic(\"modp: invalid arguments\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p\
    \ == 1:\n\t\treturn 1\n\tcase p == 2:\n\t\treturn 2\n\tcase p == 3:\n\t\treturn\
    \ 3\n\tcase p == 4:\n\t\treturn 4\n\tcase p == 5:\n\t\treturn 5\n\tcase p == 6:\n\
    \t\treturn 6\n\tcase p == 7:\n\t\treturn 7\n\tcase p == 8:\n\t\treturn 8\n\tcase\
    \ p == 9:\n\t\treturn 9\n\tcase p == 10:\n\t\treturn 10\n\tcase p == 11:\n\t\t\
    return 11\n\tcase p == 12:\n\t\treturn 12\n\tcase p == 13:\n\t\treturn 13\n\t\
    case p == 14:\n\t\treturn 14\n\tcase p == 15:\n\t\treturn 15\n\tcase p == 16:\n\
    \t\treturn 16\n\tcase p == 17:\n\t\treturn 17\n\tcase p == 18:\n\t\treturn 18\n\
    \tcase p == 19:\n\t\treturn 19\n\tcase p == 20:\n\t\treturn 20\n\tcase p == 21:\n\
    \t\treturn 21\n\tcase p == 22:\n\t\treturn 22\n\tcase p == 23:\n\t\treturn 23\n\
    \tcase p == 24:\n\t\treturn 24\n\tcase p == 25:\n\t\treturn 25\n\tcase p == 26:\n\
    \t\treturn 26\n\tcase p == 27:\n\t\treturn 27\n\tcase p == 28:\n\t\treturn 28\n\
    \tcase p == 29:\n\t\treturn 29\n\tcase p == 30:\n\t\treturn 30\n\tcase p == 31:\n\
    \t\treturn 31\n\tcase p == 32:\n\t\treturn 32\n\tcase p == 33:\n\t\treturn 33\n\
    \tcase p == 34:\n\t\treturn 34\n\tcase p == 35:\n\t\treturn 35\n\tcase p == 36:\n\
    \t\treturn 36\n\tcase p == 37:\n\t\treturn 37\n\tcase p == 38:\n\t\treturn 38\n\
    \tcase p == 39:\n\t\treturn 39\n\tcase p == 40:\n\t\treturn 40\n\tcase p == 41:\n\
    \t\treturn 41\n\tcase p == 42:\n\t\treturn 42\n\tcase p == 43:\n\t\treturn 43\n\
    \tcase p == 44:\n\t\treturn 44\n\tcase p == 45:\n\t\treturn 45\n\tcase p == 46:\n\
    \t\treturn 46\n\tcase p == 47:\n\t\treturn 47\n\tcase p == 48:\n\t\treturn 48\n\
    \tcase p == 49:\n\t\treturn 49\n\tcase p == 50:\n\t\treturn 50\n\tcase p == 51:\n\
    \t\treturn 51\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkciwxrw6.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpkciwxrw6.swift:133:31: error: expected\
    \ '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n            \
    \                  ^\n/tmp/tmpkciwxrw6.swift:3:34: note: to match this opening\
    \ '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n\
    /tmp/tmpkciwxrw6.swift:6:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp: invalid arguments\")\n                ^~~~~\n/tmp/tmpkciwxrw6.swift:115:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tif n == p+2 {\n\t\treturn p+1\n\t}\n\
    \tif n == p+3 {\n\t\treturn p+2\n\t}\n\tif n == p+4 {\n\t\treturn p+3\n\t}\n\t\
    if n == p+5 {\n\t\treturn p+4\n\t}\n\tif n == p+6 {\n\t\treturn p+5\n\t}\n\tif\
    \ n == p+7 {\n\t\treturn p+6\n\t}\n\tif n == p+8 {\n\t\treturn p+7\n\t}\n\tif\
    \ n == p+9 {\n\t\treturn p+8\n\t}\n\tif n == p+10 {\n\t\treturn p+9\n\t}\n\tif\
    \ n == p+11 {\n\t\treturn p+10\n\t}\n\tif n == p+12 {\n\t\treturn p+11\n\t}\n\t\
    if n == p+13 {\n\t\treturn p+12\n\t}\n\tif n == p+14 {\n\t\treturn p+13\n\t}\n\
    \tif n == p+15 {\n\t\treturn p+14\n\t}\n\tif n == p+16 {\n\t\treturn p+15\n\t\
    }\n\tif n == p+17 {\n\t\treturn p+16\n\t}\n\tif n == p+18 {\n\t\treturn p+17\n\
    \t}\n\tif n == p+19 {\n\t\treturn p+18\n\t}\n\tif n == p+20 {\n\t\treturn p+19\n\
    \t}\n\tif n == p+21 {\n\t\treturn p+20\n\t}\n\tif n == p+22 {\n\t\treturn p+21\n\
    \t}\n\tif n == p+23 {\n\t\treturn p+22\n\t}\n\tif n == p+24 {\n\t\treturn p+23\n\
    \t}\n\tif n == p+25 {\n\t\treturn p+24\n\t}\n\tif n == p+26 {\n\t\treturn p+25\n\
    \t}\n\tif n == p+27 {\n\t\treturn p+26\n\t}\n\tif n == p+28 {\n\t\treturn p+27\n\
    \t}\n\tif n == p+29 {\n\t\treturn p+28\n\t}\n\tif n == p+30 {\n\t\treturn p+29\n\
    \t}\n\tif n == p+31 {\n\t\treturn p+30\n\t}\n\tif n == p+32 {\n\t\treturn p+31\n\
    \t}\n\tif n == p+33 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_l4ofoc5.swift:138:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_l4ofoc5.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_l4ofoc5.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp_l4ofoc5.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp_l4ofoc5.swift:120:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus:\n\t\tpanic(\"\
    modp: invalid arguments\")\n\tcase p == Modulus:\n\t\treturn n\n\tcase n == 0\
    \ && p == 1:\n\t\treturn 0\n\tcase n == 1 && p == 0:\n\t\treturn 1\n\tcase n >=\
    \ 0 && p >= 0 && p <= Modulus:\n\t\treturn modpow(n, p, Modulus)\n\tdefault:\n\
    \t\tpanic(\"modp: invalid arguments\")\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqvx41tz2.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpqvx41tz2.swift:6:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: invalid arguments\")\n\
    \                ^~~~~\n/tmp/tmpqvx41tz2.swift:14:10: error: cannot find 'modpow'\
    \ in scope\n                return modpow(n, p, Modulus)\n                   \
    \    ^~~~~~\n/tmp/tmpqvx41tz2.swift:14:23: error: cannot find 'Modulus' in scope\n\
    \                return modpow(n, p, Modulus)\n                              \
    \      ^~~~~~~\n/tmp/tmpqvx41tz2.swift:16:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid arguments\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\treturn modp(n - 1, p) * p\
    \ + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjdgqor4h.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpjdgqor4h.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n/tmp/tmpjdgqor4h.swift:16:13: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p) * p + p\n    \
    \               ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n <=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9mbqv599.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp9mbqv599.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmp9mbqv599.swift:10:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_pap3d7q.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp_pap3d7q.swift:19:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp_pap3d7q.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp_pap3d7q.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp_pap3d7q.swift:19:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmp_pap3d7q.swift:21:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmp_pap3d7q.swift:21:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmp_pap3d7q.swift:21:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tcase n >= p - 1:\n\t\treturn p - n\n\t}\n\tn -= p\n\tn %= p\n\tif\
    \ n == 0 {\n\t\treturn p\n\t}\n\treturn p + n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1alwc_wb.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp1alwc_wb.swift:12:4: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n        n\
    \ -= p\n        ~ ^\n/tmp/tmp1alwc_wb.swift:13:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\tdefault:\n\t\tlet r = n %\
    \ p\n\t\tif r == 0 {\n\t\t\treturn p\n\t\t}\n\t\treturn r\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi6tw_lm5.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpi6tw_lm5.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid input\")\n\tcase p == 0: // special case\n\t\treturn 0\n\tcase p ==\
    \ n:\n\t\treturn 1\n\tdefault:\n\t\tswitch {\n\t\tcase n % p == 0:\n\t\t\treturn\
    \ 0\n\t\tcase n % p == p:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn modp(n /\
    \ p, p)\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppek2edq_.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmppek2edq_.swift:12:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmppek2edq_.swift:6:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid input\")\n                ^~~~~\n/tmp/tmppek2edq_.swift:18:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n / p, p)\n                                   ^\n                     \
    \               n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn (p * n) % p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgplueqjw.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpgplueqjw.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n >> 1, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxz1t9s0x.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n >> 1, p) + p\n                   ^\n           \
    \         n:      p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn modp(n\
    \ - 1, p) * (p - 1) / 2\n\t}\n\treturn modp(n - 1, p) * (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsm_euvzs.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpsm_euvzs.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n/tmp/tmpsm_euvzs.swift:17:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) * (p -\
    \ 1) / 2\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpsm_euvzs.swift:19:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - 1, p) * (p - 1)\n                   ^\n             \
    \       n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq31f5u4d.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / p, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn7vlya69.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % p\n                   ^\n    \
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n-1)) ? (p ^ n) : p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprq6kg3gs.swift:4:12: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return (p & (n-1)) ? (p ^ n) : p\n        \
    \          ^\n               (           != 0)\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n == 0:\n\t\t\
    return 1\n\tcase p < 0:\n\t\treturn 0\n\tcase p == 0:\n\t\treturn 1\n\tcase p\
    \ == 1:\n\t\treturn n\n\tdefault:\n\t\tswitch {\n\t\tcase n >= p:\n\t\t\treturn\
    \ 1\n\t\tcase n <= -p:\n\t\t\treturn 0\n\t\tcase n <= p:\n\t\t\treturn modp(n\
    \ - p, p)\n\t\tcase n >= -p:\n\t\t\treturn modp(-n, p)\n\t\t}\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkmzcy3b7.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpkmzcy3b7.swift:16:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmpkmzcy3b7.swift:22:15: error: missing argument labels 'n:p:'\
    \ in call\n                        return modp(n - p, p)\n                   \
    \                ^\n                                    n:     p: \n/tmp/tmpkmzcy3b7.swift:24:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(-n, p)\n                                   ^\n                        \
    \            n:  p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p > p {\n\t\t\
    panic(\"modp called with p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif\
    \ n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplfmpu_v1.swift:186:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmplfmpu_v1.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmplfmpu_v1.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmplfmpu_v1.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmplfmpu_v1.swift:11:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmplfmpu_v1.swift:164:3:\
    \ error: non-void function should return a value\n                return \n  \
    \              ^\n/tmp/tmplfmpu_v1.swift:168:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tcase n >= p - 1:\n\t\treturn p - 1 + modp(n - p, p)\n\t}\n\treturn\
    \ modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsp486rqm.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsp486rqm.swift:10:22: error: missing\
    \ argument labels 'n:p:' in call\n                return p - 1 + modp(n - p, p)\n\
    \                                   ^\n                                    n:\
    \     p: \n/tmp/tmpsp486rqm.swift:12:13: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n - p, p)\n                   ^\n             \
    \       n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p < p {\n\t\tpanic(\"modp called with p < p\")\n\t}\n\tx := n\n\ty :=\
    \ p\n\tz := 1\n\tfor {\n\t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tif y == 0\
    \ {\n\t\t\treturn x\n\t\t}\n\t\tif x < y {\n\t\t\tx %= y\n\t\t} else {\n\t\t\t\
    y %= x\n\t\t}\n\t\tz *= y\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp10iz9ugb.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp10iz9ugb.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp10iz9ugb.swift:25:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp10iz9ugb.swift:25:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp10iz9ugb.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp10iz9ugb.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmp10iz9ugb.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < p\")\n                ^~~~~\n/tmp/tmp10iz9ugb.swift:22:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 1\n\tcase p == 1:\n\t\treturn n\n\tcase p == -1:\n\t\treturn -n\n\t}\n\tswitch\
    \ {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 1\n\tcase p == 1:\n\t\treturn n\n\tcase p == -1:\n\t\treturn\
    \ -n\n\t}\n\tswitch {\n\tcase n <= 1:\n\t\treturn modp(n - 1, p)\n\tcase p ==\
    \ -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n <= 2:\n\t\treturn modp(n\
    \ - 2, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n\
    \ <= 3:\n\t\treturn modp(n - 3, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\t\
    }\n\tswitch {\n\tcase n <= 4:\n\t\treturn modp(n - 4, p)\n\tcase p == -1:\n\t\t\
    return modp(-n, p)\n\t}\n\tswitch {\n\tcase n <= 5:\n\t\treturn modp(n - 5, p)\n\
    \tcase p == -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n <= 6:\n\t\t\
    return modp(n - 6, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch\
    \ {\n\tcase n <= 7:\n\t\treturn modp(n - 7, p)\n\tcase p == -1:\n\t\treturn modp(-n,\
    \ p)\n\t}\n\tswitch {\n\tcase n <= 8:\n\t\treturn modp(n - 8, p)\n\tcase p ==\
    \ -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n <= 9:\n\t\treturn modp(n\
    \ - 9, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n\
    \ <= 10:\n\t\treturn modp(n - 10, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\
    \t}\n\tswitch {\n\tcase n <= 11:\n\t\treturn modp(n - 11, p)\n\tcase p == -1:\n\
    \t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n <= 12:\n\t\treturn modp(n -\
    \ 12, p)\n\tcase p == -1:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n <=\
    \ 13:\n\t\treturn modp(n - 13, \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcqmnx4ld.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:16:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:28:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:34:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:40:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:46:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:52:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:58:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:64:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:70:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:76:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:82:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:88:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:94:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpcqmnx4ld.swift:100:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpcqmnx4ld.swift:103:1: error: expected expression in list of\
    \ expressions\n}\n^\n/tmp/tmpcqmnx4ld.swift:124:31: error: expected '}' at end\
    \ of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                       \
    \       ^\n/tmp/tmpcqmnx4ld.swift:3:34: note: to match this opening '{'\nfunc\
    \ modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpcqmnx"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p\
    \ == 2 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p+1 {\n\t\treturn 2\n\t}\n\tif n == p+2 {\n\t\treturn\
    \ 3\n\t}\n\tif n == p+3 {\n\t\treturn 4\n\t}\n\tif n == p+4 {\n\t\treturn 5\n\t\
    }\n\tif n == p+5 {\n\t\treturn 6\n\t}\n\tif n == p+6 {\n\t\treturn 7\n\t}\n\t\
    if n == p+7 {\n\t\treturn 8\n\t}\n\tif n == p+8 {\n\t\treturn 9\n\t}\n\tif n ==\
    \ p+9 {\n\t\treturn 10\n\t}\n\tif n == p+10 {\n\t\treturn 11\n\t}\n\tif n == p+11\
    \ {\n\t\treturn 12\n\t}\n\tif n == p+12 {\n\t\treturn 13\n\t}\n\tif n == p+13\
    \ {\n\t\treturn 14\n\t}\n\tif n == p+14 {\n\t\treturn 15\n\t}\n\tif n == p+15\
    \ {\n\t\treturn 16\n\t}\n\tif n == p+16 {\n\t\treturn 17\n\t}\n\tif n == p+17\
    \ {\n\t\treturn 18\n\t}\n\tif n == p+18 {\n\t\treturn 19\n\t}\n\tif n == p+19\
    \ {\n\t\treturn 20\n\t}\n\tif n == p+20 {\n\t\treturn 21\n\t}\n\tif n == p+21\
    \ {\n\t\treturn 22\n\t}\n\tif n == p+22 {\n\t\treturn 23\n\t}\n\tif n == p+23\
    \ {\n\t\treturn 24\n\t}\n\tif n == p+24 {\n\t\treturn 25\n\t}\n\tif n == p+25\
    \ {\n\t\treturn 26\n\t}\n\tif n == p+26 {\n\t\treturn 27\n\t}\n\tif n == p+27\
    \ {\n\t\treturn 28\n\t}\n\tif n == p+28 {\n\t\treturn 29\n\t}\n\tif n == p+29\
    \ {\n\t\treturn 30\n\t}\n\tif n == p+30 {\n\t\treturn 31\n\t}\n\tif n == p+31\
    \ {\n\t\treturn 32\n\t}\n\tif n == p+32 {\n\t\treturn 33\n\t}\n\tif n == p+33\
    \ {\n\t\treturn 34\n\t}\n\tif n == p+34 {\n\t\treturn 35\n\t}\n\tif n == p+35\
    \ {\n\t\treturn 36\n\t}\n\tif n == p+36 {\n\t\treturn 37\n\t}\n\tif n == p+37\
    \ {\n\t\treturn 38\n\t}\n\tif n == p+38\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpje23ngoa.swift:136:14: error: expected '{' after 'if' condition\n\
    \        if n == p+38\n                    ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n - 1)) | ((p ^ n) & -p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpl_52wd1a/tmpl_52wd1a.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07050a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0704d98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0704d98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0704d977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl_52wd1a                        0x000055e05ef661bd <unavailable> + 4541

    5    libc.so.6                          0x00002b070528d460 __libc_start_main +
    245

    6    tmpl_52wd1a                        0x000055e05ef65e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tn -= p - 1\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tx := 1\n\t\
    for ; n > 0; n-- {\n\t\tx = x * p + n\n\t}\n\treturn x\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxekfnsy1.swift:17:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := 1\n         ^\n         ;\n/tmp/tmpxekfnsy1.swift:17:4:\
    \ error: expected expression\n        x := 1\n          ^\n/tmp/tmpxekfnsy1.swift:18:2:\
    \ error: C-style for statement has been removed in Swift 3\n        for ; n >\
    \ 0; n-- {\n        ^   ~~~~~~~~~~~~\n/tmp/tmpxekfnsy1.swift:5:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative n\"\
    )\n                ^~~~~\n/tmp/tmpxekfnsy1.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpxekfnsy1.swift:13:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n -= p - 1\n        ~ ^\n/tmp/tmpxekfnsy1.swift:17:2:\
    \ error: cannot find 'x' in scope\n        x := 1\n        ^\n/tmp/tmpxekfnsy1.swift:21:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n >> 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5reaw8ik.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n >> 1, p) * p + p\n                   ^\n       \
    \             n:      p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\
    \t\tt = x\n\t\tx = y\n\t\ty = z\n\t\tz = t\n\t\tif x == y {\n\t\t\tbreak\n\t\t\
    }\n\t}\n\treturn z\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_5p8b9s0.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp_5p8b9s0.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp_5p8b9s0.swift:25:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp_5p8b9s0.swift:25:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp_5p8b9s0.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp_5p8b9s0.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmp_5p8b9s0.swift:22:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmp_5p8b9s0.swift:34:9:\
    \ error: cannot find 'z' in scope\n        return z\n               ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 2 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t\
    }\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\
    \tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\t\
    if n == 8 {\n\t\treturn p + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif\
    \ n == 10 {\n\t\treturn p + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\t\
    if n == 12 {\n\t\treturn p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\
    \tif n == 14 {\n\t\treturn p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t\
    }\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\
    \t}\n\tif n == 18 {\n\t\treturn p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\
    \t}\n\tif n == 20 {\n\t\treturn p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\
    \t}\n\tif n == 22 {\n\t\treturn p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == 24 {\n\t\treturn p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == 26 {\n\t\treturn p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\
    \t}\n\tif n == 28 {\n\t\treturn p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\
    \t}\n\tif n == 30 {\n\t\treturn p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\
    \t}\n\tif n == 32 {\n\t\treturn p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\
    \t}\n\tif n == 34 {\n\t\treturn p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\
    \t}\n\tif n == 36 {\n\t\treturn p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\
    \t}\n\tif n == 38 {\n\t\treturn p + 37\n\t}\n\tif n == 39 {\n\t\treturn p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph9mjxdv2.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmph9mjxdv2.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmph9mjxdv2.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmph9mjxdv2.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmph9mjxdv2.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\t\
    if n == p-1 {\n\t\treturn p-1\n\t}\n\tif n == p+2 {\n\t\treturn p-2\n\t}\n\tif\
    \ n == p-2 {\n\t\treturn p-2\n\t}\n\tif n == p+3 {\n\t\treturn p-3\n\t}\n\tif\
    \ n == p-3 {\n\t\treturn p-3\n\t}\n\tif n == p+4 {\n\t\treturn p-4\n\t}\n\tif\
    \ n == p-4 {\n\t\treturn p-4\n\t}\n\tif n == p+5 {\n\t\treturn p-5\n\t}\n\tif\
    \ n == p-5 {\n\t\treturn p-5\n\t}\n\tif n == p+6 {\n\t\treturn p-6\n\t}\n\tif\
    \ n == p-6 {\n\t\treturn p-6\n\t}\n\tif n == p+7 {\n\t\treturn p-7\n\t}\n\tif\
    \ n == p-7 {\n\t\treturn p-7\n\t}\n\tif n == p+8 {\n\t\treturn p-8\n\t}\n\tif\
    \ n == p-8 {\n\t\treturn p-8\n\t}\n\tif n == p+9 {\n\t\treturn p-9\n\t}\n\tif\
    \ n == p-9 {\n\t\treturn p-9\n\t}\n\tif n == p+10 {\n\t\treturn p-10\n\t}\n\t\
    if n == p-10 {\n\t\treturn p-10\n\t}\n\tif n == p+11 {\n\t\treturn p-11\n\t}\n\
    \tif n == p-11 {\n\t\treturn p-11\n\t}\n\tif n == p+12 {\n\t\treturn p-12\n\t\
    }\n\tif n == p-12 {\n\t\treturn p-12\n\t}\n\tif n == p+13 {\n\t\treturn p-13\n\
    \t}\n\tif n == p-13 {\n\t\treturn p-13\n\t}\n\tif n == p+14 {\n\t\treturn p-14\n\
    \t}\n\tif n == p-14 {\n\t\treturn p-14\n\t}\n\tif n == p+15 {\n\t\treturn p-15\n\
    \t}\n\tif n == p-15 {\n\t\treturn p-15\n\t}\n\tif n == p+16 {\n\t\treturn p-16\n\
    \t}\n\tif n == p-16 {\n\t\treturn p-16\n\t}\n\tif n == p+17 {\n\t\treturn p-17\n\
    \t}\n\tif n == p-17 {\n\t\treturn p-17\n\t}\n\tif n == p+18 {\n\t\treturn p-18\n\
    \t}\n\tif n == p-18 {\n\t\treturn p-18\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpblc1jcu7.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpblc1jcu7.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpblc1jcu7.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpblc1jcu7.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpblc1jcu7.swift:133:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tq := n / p\n\tr := n % p\n\
    \treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0in6nzsb.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp0in6nzsb.swift:16:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp0in6nzsb.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp0in6nzsb.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp0in6nzsb.swift:16:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmp0in6nzsb.swift:18:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmp0in6nzsb.swift:18:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmp0in6nzsb.swift:18:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\
    \t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tif y == 0 {\n\t\t\treturn z\n\t\t\
    }\n\t\tt = x%y\n\t\tx = y\n\t\ty = t\n\t\tz = z*y + x\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyn2p6j3l.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpyn2p6j3l.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpyn2p6j3l.swift:25:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpyn2p6j3l.swift:25:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpyn2p6j3l.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpyn2p6j3l.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpyn2p6j3l.swift:22:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n-1)) ? (p ^ n) : p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprq6kg3gs.swift:4:12: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return (p & (n-1)) ? (p ^ n) : p\n        \
    \          ^\n               (           != 0)\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p == 1 {\n\t\treturn 1\n\t}\n\tif p > 1 {\n\t\treturn modp(n / p, p)\n\
    \t}\n\treturn modp(n - 1, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7w6ndh_j.swift:14:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n / p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp7w6ndh_j.swift:16:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n    \
    \               ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p > p {\n\t\t\
    panic(\"modp called with p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif\
    \ n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tq := n / p\n\
    \tr := n % p\n\tif r == 0 {\n\t\treturn q\n\t}\n\treturn modp(q, p) * p + r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsnnr8w_j.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpsnnr8w_j.swift:22:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpsnnr8w_j.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpsnnr8w_j.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpsnnr8w_j.swift:11:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpsnnr8w_j.swift:22:2: error: cannot find 'q' in scope\n     \
    \   q := n / p\n        ^\n/tmp/tmpsnnr8w_j.swift:24:5: error: cannot find 'r'\
    \ in scope\n        if r == 0 {\n           ^\n/tmp/tmpsnnr8w_j.swift:25:10: error:\
    \ cannot find 'q' in scope\n                return q\n                       ^\n\
    /tmp/tmpsnnr8w_j.swift:27:14: error: cannot find 'q' in scope\n        return\
    \ modp(q, p) * p + r\n                    ^\n/tmp/tmpsnnr8w_j.swift:27:26: error:\
    \ cannot find 'r' in scope\n        return modp(q, p) * p + r\n              \
    \                  ^\n/tmp/tmpsnnr8w_j.swift:27:13: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(q, p) * p + r\n                   ^\n  \
    \                  n: p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tr := 1\n\tfor i := 0; i < p; i++ {\n\t\tr *= p\n\t}\n\treturn (r\
    \ % n) * n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnfuka_8h.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmpnfuka_8h.swift:22:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmpnfuka_8h.swift:23:9:\
    \ error: expected type\n        for i := 0; i < p; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpnfuka_8h.swift:23:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < p; i++ {\n               ^\n/tmp/tmpnfuka_8h.swift:23:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < p; i++ {\n               ^\n/tmp/tmpnfuka_8h.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpnfuka_8h.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpnfuka_8h.swift:17:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpnfuka_8h.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpnfuka_8h.swift:22:2: error: cannot\
    \ find 'r' in scope\n        r := 1\n        ^\n/tmp/tmpnfuka_8h.swift:26:10:\
    \ error: cannot find 'r' in scope\n        return (r % n) * n\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p - 1) & ((p - 1) ^ n)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpvj7pmdtu/tmpvj7pmdtu.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f7079ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f70495b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f70495988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f704947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvj7pmdtu                        0x000055f2ffd171bd <unavailable> + 4541

    5    libc.so.6                          0x00002b1f7098a460 __libc_start_main +
    245

    6    tmpvj7pmdtu                        0x000055f2ffd16e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\t\
    q := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplpgx1wmu.swift:25:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmplpgx1wmu.swift:25:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmplpgx1wmu.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmplpgx1wmu.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmplpgx1wmu.swift:25:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmplpgx1wmu.swift:27:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmplpgx1wmu.swift:27:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmplpgx1wmu.swift:27:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p must be >= 2\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p + 1\n\t\
    }\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\
    \tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p + 5\n\t}\n\t\
    if n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p + 7\n\t}\n\tif\
    \ n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p + 9\n\t}\n\tif\
    \ n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn p + 11\n\t}\n\t\
    if n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn p + 13\n\t}\n\
    \tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn p + 15\n\t\
    }\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn p + 17\n\
    \t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn p + 19\n\
    \t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn p + 21\n\
    \t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn p + 23\n\
    \t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn p + 25\n\
    \t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn p + 27\n\
    \t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn p + 29\n\
    \t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn p + 31\n\
    \t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn p + 33\n\
    \t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn p + 35\n\
    \t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn p + 37\n\
    \t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\t\treturn p + \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqdezzksf.swift:132:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpqdezzksf.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpqdezzksf.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpqdezzksf.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpqdezzksf.swift:8:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p must be >= 2\")\n                ^~~~~\n/tmp/tmpqdezzksf.swift:135:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tx := n\n\ty :=\
    \ p\n\tfor {\n\t\tx -= y\n\t\tif x < 0 {\n\t\t\tbreak\n\t\t}\n\t\ty *= 2\n\t}\n\
    \treturn x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpf1bm2eje.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpf1bm2eje.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpf1bm2eje.swift:24:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpf1bm2eje.swift:24:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpf1bm2eje.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpf1bm2eje.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpf1bm2eje.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpf1bm2eje.swift:22:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n/tmp/tmpf1bm2eje.swift:31:9: error:\
    \ cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif p > p\
    \ {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tx := n\n\ty := 1\n\tfor {\n\t\tx %= p\n\
    \t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t\ty = y * x\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfksibkwj.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpfksibkwj.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpfksibkwj.swift:24:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpfksibkwj.swift:24:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpfksibkwj.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpfksibkwj.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmpfksibkwj.swift:20:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpfksibkwj.swift:22:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n\
    \ == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n\
    \ == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n\
    \ == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p + 7\n\t}\n\tif n\
    \ == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p + 9\n\t}\n\tif n\
    \ == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn p + 11\n\t}\n\t\
    if n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn p + 13\n\t}\n\
    \tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn p + 15\n\t\
    }\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn p + 17\n\
    \t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn p + 19\n\
    \t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn p + 21\n\
    \t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn p + 23\n\
    \t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn p + 25\n\
    \t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn p + 27\n\
    \t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn p + 29\n\
    \t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn p + 31\n\
    \t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn p + 33\n\
    \t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn p + 35\n\
    \t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn p + 37\n\
    \t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\t\treturn p + 39\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpromloecx.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpromloecx.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpromloecx.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpromloecx.swift:8:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p < 2\")\n                ^~~~~\n/tmp/tmpromloecx.swift:135:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn p & (n - 1)\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmfatlvdj.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpmfatlvdj.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt0qcyg2o.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2\n                   ^\n    \
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\t\
    if n == p-1 {\n\t\treturn p-1\n\t}\n\tif n == p+2 {\n\t\treturn p-2\n\t}\n\tif\
    \ n == p-2 {\n\t\treturn p-3\n\t}\n\tif n == p-3 {\n\t\treturn p-4\n\t}\n\tif\
    \ n == p-4 {\n\t\treturn p-5\n\t}\n\tif n == p-5 {\n\t\treturn p-6\n\t}\n\tif\
    \ n == p-6 {\n\t\treturn p-7\n\t}\n\tif n == p-7 {\n\t\treturn p-8\n\t}\n\tif\
    \ n == p-8 {\n\t\treturn p-9\n\t}\n\tif n == p-9 {\n\t\treturn p-10\n\t}\n\tif\
    \ n == p-10 {\n\t\treturn p-11\n\t}\n\tif n == p-11 {\n\t\treturn p-12\n\t}\n\t\
    if n == p-12 {\n\t\treturn p-13\n\t}\n\tif n == p-13 {\n\t\treturn p-14\n\t}\n\
    \tif n == p-14 {\n\t\treturn p-15\n\t}\n\tif n == p-15 {\n\t\treturn p-16\n\t\
    }\n\tif n == p-16 {\n\t\treturn p-17\n\t}\n\tif n == p-17 {\n\t\treturn p-18\n\
    \t}\n\tif n == p-18 {\n\t\treturn p-19\n\t}\n\tif n == p-19 {\n\t\treturn p-20\n\
    \t}\n\tif n == p-20 {\n\t\treturn p-21\n\t}\n\tif n == p-21 {\n\t\treturn p-22\n\
    \t}\n\tif n == p-22 {\n\t\treturn p-23\n\t}\n\tif n == p-23  {\n\t\treturn p-24\n\
    \t}\n\tif n == p-24 {\n\t\treturn p-25\n\t}\n\tif n == p-25 {\n\t\treturn p-26\n\
    \t}\n\tif n == p-26 {\n\t\treturn p-27\n\t}\n\tif n == p-27 {\n\t\treturn p-28\n\
    \t}\n\tif n == p-28 {\n\t\treturn p-29\n\t}\n\tif n == p-29 {\n\t\treturn p-30\n\
    \t}\n\tif n == p-30 {\n\t\treturn p-31\n\t}\n\tif n == p-31 {\n\t\treturn p-32\n\
    \t}\n\tif n == p-32 {\n\t\treturn p-33\n\t}\n\tif n == p-33 {\n\t\treturn p-34\n\
    \t}\n\tif n == p-34 {\n\t\treturn p-35\n\t}\n\tif n == p-35 {\n\t\treturn p-36\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxdaary0l.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpxdaary0l.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 1:\n\t\treturn 0\n\tcase p == 1:\n\t\t\
    return n\n\tcase p == -1:\n\t\treturn -n\n\tcase p < 2:\n\t\treturn 0\n\tdefault:\n\
    \t\treturn (p * modp(n - 1, p)) % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcwl_b0u8.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcwl_b0u8.swift:14:19: error: missing\
    \ argument labels 'n:p:' in call\n                return (p * modp(n - 1, p))\
    \ % p\n                                ^\n                                 n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tq := n / p\n\t\
    r := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5zuoz3xi.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp5zuoz3xi.swift:22:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp5zuoz3xi.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp5zuoz3xi.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp5zuoz3xi.swift:20:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmp5zuoz3xi.swift:22:2: error: cannot find 'q' in scope\n     \
    \   q := n / p\n        ^\n/tmp/tmp5zuoz3xi.swift:24:14: error: cannot find 'q'\
    \ in scope\n        return modp(q, p) * p + r\n                    ^\n/tmp/tmp5zuoz3xi.swift:24:26:\
    \ error: cannot find 'r' in scope\n        return modp(q, p) * p + r\n       \
    \                         ^\n/tmp/tmp5zuoz3xi.swift:24:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) * p + r\n                 \
    \  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > n {\n\t\treturn 0\n\t}\n\tq :=\
    \ n / p\n\tr := n % p\n\tif r == 0 {\n\t\treturn q\n\t}\n\tif r == p {\n\t\treturn\
    \ q + 1\n\t}\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7yx64upq.swift:25:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp7yx64upq.swift:25:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp7yx64upq.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp7yx64upq.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp7yx64upq.swift:25:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmp7yx64upq.swift:27:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmp7yx64upq.swift:28:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmp7yx64upq.swift:30:5: error: cannot find 'r' in scope\n    \
    \    if r == p {\n           ^\n/tmp/tmp7yx64upq.swift:31:10: error: cannot find\
    \ 'q' in scope\n                return q + 1\n                       ^\n/tmp/tmp7yx64upq.swift:33:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y > z {\n\t\t\ty >>=\
    \ 1\n\t\t\tz <<= 1\n\t\t} else {\n\t\t\tz <<= 1\n\t\t\ty >>= 1\n\t\t}\n\t\tif\
    \ x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tx >>= 1\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpph1m4jfy.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpph1m4jfy.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpph1m4jfy.swift:25:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpph1m4jfy.swift:25:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpph1m4jfy.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpph1m4jfy.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpph1m4jfy.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpph1m4jfy.swift:20:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmpph1m4jfy.swift:22:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > 255:\n\t\tpanic(\"invalid\
    \ parameters\")\n\tcase n == 0 && p == 0:\n\t\treturn 0\n\tcase n >= p:\n\t\t\
    return p\n\tcase n <= 255:\n\t\treturn n % p\n\t}\n\treturn modp(n - 1, p) + p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpusr6s1qn.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpusr6s1qn.swift:6:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"invalid parameters\")\n     \
    \           ^~~~~\n/tmp/tmpusr6s1qn.swift:14:13: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - 1, p) + p\n                   ^\n  \
    \                  n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\
    \tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tr := 1\n\
    \tfor i := n - 1; i >= 0; i-- {\n\t\tr *= p\n\t\tr += n\n\t}\n\treturn r\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpydj3wmff.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmpydj3wmff.swift:19:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmpydj3wmff.swift:20:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmpydj3wmff.swift:20:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmpydj3wmff.swift:20:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmpydj3wmff.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpydj3wmff.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 2\")\n            \
    \    ^~~~~\n/tmp/tmpydj3wmff.swift:19:2: error: cannot find 'r' in scope\n   \
    \     r := 1\n        ^\n/tmp/tmpydj3wmff.swift:24:9: error: cannot find 'r' in\
    \ scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tx := n\n\ty :=\
    \ p\n\tfor {\n\t\tx -= y\n\t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t\ty *= 2\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu8xen3h2.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpu8xen3h2.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpu8xen3h2.swift:24:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpu8xen3h2.swift:24:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpu8xen3h2.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpu8xen3h2.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpu8xen3h2.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpu8xen3h2.swift:22:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0: panic(\"modp called with negative n\"\
    )\n\tcase p < 2: panic(\"modp called with p < 2\")\n\tcase p > n: panic(\"modp\
    \ called with p > n\")\n\tdefault: return (p - 1) % n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0v2u2__k.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp0v2u2__k.swift:5:14: error: cannot\
    \ find 'panic' in scope\n        case n < 0: panic(\"modp called with negative\
    \ n\")\n                    ^~~~~\n/tmp/tmp0v2u2__k.swift:6:14: error: cannot\
    \ find 'panic' in scope\n        case p < 2: panic(\"modp called with p < 2\"\
    )\n                    ^~~~~\n/tmp/tmp0v2u2__k.swift:7:14: error: cannot find\
    \ 'panic' in scope\n        case p > n: panic(\"modp called with p > n\")\n  \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tfor {\n\
    \t\tx -= y\n\t\tif x == 0 {\n\t\t\treturn x\n\t\t}\n\t\ty >>= 1\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpepe2pwc_.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpepe2pwc_.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpepe2pwc_.swift:18:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpepe2pwc_.swift:18:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpepe2pwc_.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpepe2pwc_.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpepe2pwc_.swift:16:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t\
    }\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\
    \tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\t\
    if n == 8 {\n\t\treturn p + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif\
    \ n == 10 {\n\t\treturn p + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\t\
    if n == 12 {\n\t\treturn p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\
    \tif n == 14 {\n\t\treturn p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t\
    }\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\
    \t}\n\tif n == 18 {\n\t\treturn p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\
    \t}\n\tif n == 20 {\n\t\treturn p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\
    \t}\n\tif n == 22 {\n\t\treturn p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == 24 {\n\t\treturn p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == 26 {\n\t\treturn p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\
    \t}\n\tif n == 28 {\n\t\treturn p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\
    \t}\n\tif n == 30 {\n\t\treturn p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\
    \t}\n\tif n == 32 {\n\t\treturn p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\
    \t}\n\tif n == 34 {\n\t\treturn p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\
    \t}\n\tif n == 36 {\n\t\treturn p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\
    \t}\n\tif n == 38 {\n\t\treturn p + 37\n\t}\n\tif n == 39 {\n\t\treturn p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdagmcn09.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdagmcn09.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpdagmcn09.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpdagmcn09.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpdagmcn09.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tt = x % y\n\t\tx = y\n\t\ty =\
    \ t\n\t\tif x == 1 {\n\t\t\treturn z\n\t\t}\n\t\tz = z * y\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp79d1jhv4.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp79d1jhv4.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp79d1jhv4.swift:22:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp79d1jhv4.swift:22:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp79d1jhv4.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp79d1jhv4.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmp79d1jhv4.swift:19:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 1:\n\t\treturn 0\n\tcase n < p:\n\t\t\
    return 1\n\tcase n == p:\n\t\treturn 0\n\tcase n == p - 1:\n\t\treturn 1\n\tdefault:\n\
    \t\treturn modp(n - 1, p) + modp(n + 1, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzgr27y71.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpzgr27y71.swift:14:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) + modp(n\
    \ + 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpzgr27y71.swift:14:31: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 1, p) + modp(n + 1, p)\n                    \
    \                        ^\n                                             n:  \
    \   p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (n & (-p)) + (n >> p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpuxpb0ia2/tmpuxpb0ia2.swift:21: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2857b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2854aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2854ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2854ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxpb0ia2                        0x0000562c17cda23d <unavailable> + 4669

    5    libc.so.6                          0x00002ac2859a3460 __libc_start_main +
    245

    6    tmpuxpb0ia2                        0x0000562c17cd9e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (n & (p - 1)) + p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp3o71wg_k/tmp3o71wg_k.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1ae2b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1adfaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1adfaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1adfa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3o71wg_k                        0x0000562a36a311bd <unavailable> + 4541

    5    libc.so.6                          0x00002ad1ae49f460 __libc_start_main +
    245

    6    tmp3o71wg_k                        0x0000562a36a30e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tx :=\
    \ n\n\tfor x != 0 {\n\t\tx >>= 1\n\t\tp >>= 1\n\t}\n\treturn p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9c4r1k7m.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp9c4r1k7m.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp9c4r1k7m.swift:17:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmp9c4r1k7m.swift:17:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmp9c4r1k7m.swift:16:2: error: cannot find 'x' in scope\n        x := n\n\
    \        ^\n/tmp/tmp9c4r1k7m.swift:17:8: error: '!=' is not a prefix unary operator\n\
    \        for x != 0 {\n              ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase n == p:\n\t\treturn 1\n\tcase n == 0 || p == 0:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\t}\n\tswitch {\n\tcase p == 1:\n\t\
    \treturn n\n\tcase n == p:\n\t\treturn 1\n\t}\n\tswitch {\n\tcase p < 2:\n\t\t\
    return 0\n\tcase p < n:\n\t\treturn modp(n - p, p)\n\tdefault:\n\t\tswitch {\n\
    \t\tcase p > n:\n\t\t\treturn 0\n\t\tcase p > 2:\n\t\t\treturn modp(n - p, p -\
    \ 2)\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdc0kmi6l.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpdc0kmi6l.swift:14:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpdc0kmi6l.swift:20:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpdc0kmi6l.swift:26:10: error: expected expression in 'switch'\
    \ statement\n                switch {\n                       ^\n/tmp/tmpdc0kmi6l.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: invalid arguments\"\
    )\n                ^~~~~\n/tmp/tmpdc0kmi6l.swift:24:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpdc0kmi6l.swift:30:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n - p, p - 2)\n                                   ^\n                 \
    \                   n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"invalid\
    \ argument\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 1\n\t\
    }\n\tswitch {\n\tcase n >= p && n >= 1:\n\t\treturn modp(n / p, p)\n\tcase n >=\
    \ p && n >= -1:\n\t\treturn modp((n - 1) / p, p)\n\tcase n >= -1 && n >= -p:\n\
    \t\treturn modp((n - 1) / p, p)\n\tcase n >= -p && n >= -(p + 1):\n\t\treturn\
    \ modp(n / p, p)\n\tcase n >= -(p + 1):\n\t\treturn modp((n - 1) / p, p)\n\t}\n\
    \tpanic(\"invalid argument\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp70xv13gd.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp70xv13gd.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp70xv13gd.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"invalid argument\"\
    )\n                ^~~~~\n/tmp/tmp70xv13gd.swift:14:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n / p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmp70xv13gd.swift:16:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((n\
    \ - 1) / p, p)\n                           ^\n                            n: \
    \          p: \n/tmp/tmp70xv13gd.swift:18:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp((n - 1) / p, p)\n                     \
    \      ^\n                            n:           p: \n/tmp/tmp70xv13gd.swift:20:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp70xv13gd.swift:22:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp((n - 1) / p, p)\n                           ^\n \
    \                           n:           p: \n/tmp/tmp70xv13gd.swift:24:2: error:\
    \ cannot find 'panic' in scope\n        panic(\"invalid argument\")\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tfor {\n\
    \t\tif y & 1 == 1 {\n\t\t\tx -= 1\n\t\t\ty >>= 1\n\t\t} else {\n\t\t\tx -= 1\n\
    \t\t\ty >>= 1\n\t\t\ty -= 1\n\t\t}\n\t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t\
    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcbs24o_s.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpcbs24o_s.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpcbs24o_s.swift:18:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpcbs24o_s.swift:18:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpcbs24o_s.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpcbs24o_s.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpcbs24o_s.swift:16:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p - 1) % n + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpm60l7wdl/tmpm60l7wdl.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b851551cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8515213b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8515213988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85152127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm60l7wdl                        0x0000555ac09c124d <unavailable> + 4685

    5    libc.so.6                          0x00002b8515708460 __libc_start_main +
    245

    6    tmpm60l7wdl                        0x0000555ac09c0ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ n <= p:\n\t\treturn n\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5cbuthtk.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp5cbuthtk.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp5cbuthtk.swift:10:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p < p {\n\t\treturn modp(n - 1, p) + 1\n\t}\n\tif p > p {\n\t\treturn\
    \ modp(n, p - 1)\n\t}\n\tq := modp(n - 1, p) - 1\n\tr := modp(n, p)\n\treturn\
    \ (r * q) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxdmqsyov.swift:25:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p) - 1\n         ^\n         ;\n\
    /tmp/tmpxdmqsyov.swift:25:4: error: expected expression\n        q := modp(n -\
    \ 1, p) - 1\n          ^\n/tmp/tmpxdmqsyov.swift:5:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with negative n\")\n         \
    \       ^~~~~\n/tmp/tmpxdmqsyov.swift:8:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpxdmqsyov.swift:20:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p) + 1\n                           ^\n                            n:  \
    \   p: \n/tmp/tmpxdmqsyov.swift:23:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n, p - 1)\n                           ^\n\
    \                            n: p: \n/tmp/tmpxdmqsyov.swift:25:2: error: cannot\
    \ find 'q' in scope\n        q := modp(n - 1, p) - 1\n        ^\n/tmp/tmpxdmqsyov.swift:27:10:\
    \ error: cannot find 'r' in scope\n        return (r * q) % p\n              \
    \  ^\n/tmp/tmpxdmqsyov.swift:27:14: error: cannot find 'q' in scope\n        return\
    \ (r * q) % p\n                    ^\n/tmp/tmpxdmqsyov.swift:27:12: error: cannot\
    \ convert value of type 'Duration' to expected argument type 'Int'\n        return\
    \ (r * q) % p\n                  ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tq := p\n\tfor {\n\t\tq /=\
    \ 2\n\t\tif q == 1 {\n\t\t\treturn n\n\t\t}\n\t\tif q > n {\n\t\t\tbreak\n\t\t\
    }\n\t}\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7mcpkfzf.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmp7mcpkfzf.swift:16:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmp7mcpkfzf.swift:17:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp7mcpkfzf.swift:17:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp7mcpkfzf.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp7mcpkfzf.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmp7mcpkfzf.swift:16:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n/tmp/tmp7mcpkfzf.swift:26:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcpj58h2t.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpcpj58h2t.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpcpj58h2t.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpcpj58h2t.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpcpj58h2t.swift:172:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tn -=\
    \ p - 1\n\treturn (p << n) | modp(n << 1, p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeh_hqg6u.swift:16:4: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n -= p - 1\n        ~ ^\n/tmp/tmpeh_hqg6u.swift:17:24:\
    \ error: missing argument labels 'n:p:' in call\n        return (p << n) | modp(n\
    \ << 1, p)\n                              ^\n                               n:\
    \      p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif\
    \ n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\
    \t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\
    \tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n ==\
    \ p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpob2qesxi.swift:164:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpob2qesxi.swift:5:3: error: cannot find 'panic' in scope\n      \
    \          panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpob2qesxi.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmpob2qesxi.swift:17:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpob2qesxi.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n-1)) ? (p^(n-1)) ^ n : p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpm4q31hsy.swift:4:12: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return (p & (n-1)) ? (p^(n-1)) ^ n : p\n  \
    \                ^\n               (           != 0)\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tq := p / 2\n\tr := p % 2\n\
    \tif r == 0 {\n\t\treturn modp(n - 1, q)\n\t}\n\treturn modp(n - 1, r) + q\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9jne0y7o.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / 2\n         ^\n         ;\n/tmp/tmp9jne0y7o.swift:16:4:\
    \ error: expected expression\n        q := p / 2\n          ^\n/tmp/tmp9jne0y7o.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp9jne0y7o.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp9jne0y7o.swift:16:2: error: cannot find 'q' in\
    \ scope\n        q := p / 2\n        ^\n/tmp/tmp9jne0y7o.swift:18:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmp9jne0y7o.swift:19:22:\
    \ error: cannot find 'q' in scope\n                return modp(n - 1, q)\n   \
    \                                ^\n/tmp/tmp9jne0y7o.swift:19:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, q)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp9jne0y7o.swift:21:21:\
    \ error: cannot find 'r' in scope\n        return modp(n - 1, r) + q\n       \
    \                    ^\n/tmp/tmp9jne0y7o.swift:21:26: error: cannot find 'q' in\
    \ scope\n        return modp(n - 1, r) + q\n                                ^\n\
    /tmp/tmp9jne0y7o.swift:21:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - 1, r) + q\n                   ^\n                   \
    \ n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 1:\n\t\treturn 0\n\tcase n == 1:\n\t\t\
    return p\n\tcase n == 2:\n\t\treturn p - 1\n\tcase n % 2 == 1:\n\t\treturn modp(n\
    \ / 2, p)\n\tdefault:\n\t\treturn modp(n / 2, p) + p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbsoa66wj.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpbsoa66wj.swift:12:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n / 2, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpbsoa66wj.swift:14:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / 2, p) + p\n                           ^\n                            n:  \
    \   p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase n == 0 || p == 0:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 1\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase\
    \ n < p:\n\t\treturn modp(n - p, p) + modp(p, n)\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo8z6eifh.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpo8z6eifh.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpo8z6eifh.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: invalid arguments\"\
    )\n                ^~~~~\n/tmp/tmpo8z6eifh.swift:14:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpo8z6eifh.swift:16:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p) + modp(p, n)\n                           ^\n                       \
    \     n:     p: \n/tmp/tmpo8z6eifh.swift:16:31: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n - p, p) + modp(p, n)\n       \
    \                                     ^\n                                    \
    \         n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative argument\")\n\t}\n\t\
    if p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n > p\
    \ {\n\t\tpanic(\"modp: n > p\")\n\t}\n\tr := 1\n\tfor i := n - 1; i >= 0; i--\
    \ {\n\t\tr *= p\n\t\tr += n\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnjlxi0yn.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmpnjlxi0yn.swift:22:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmpnjlxi0yn.swift:23:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmpnjlxi0yn.swift:23:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmpnjlxi0yn.swift:23:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmpnjlxi0yn.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ argument\")\n                ^~~~~\n/tmp/tmpnjlxi0yn.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 2\")\n            \
    \    ^~~~~\n/tmp/tmpnjlxi0yn.swift:20:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: n > p\")\n                ^~~~~\n/tmp/tmpnjlxi0yn.swift:22:2:\
    \ error: cannot find 'r' in scope\n        r := 1\n        ^\n/tmp/tmpnjlxi0yn.swift:27:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tx := n\n\ty := p\n\tfor {\n\t\tx -= y\n\t\t\
    if x == 0 {\n\t\t\treturn x\n\t\t}\n\t\ty >>= 1\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmjz4miub.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpmjz4miub.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpmjz4miub.swift:21:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpmjz4miub.swift:21:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpmjz4miub.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpmjz4miub.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpmjz4miub.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpmjz4miub.swift:19:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tq := p / 2\n\tr := p % 2\n\
    \tx := 1\n\tfor n > 0 {\n\t\tif n&1 != 0 {\n\t\t\tx = x * q\n\t\t}\n\t\tn = n\
    \ >> 1\n\t\tq = q * 2\n\t}\n\tif r == 1 {\n\t\treturn x\n\t}\n\treturn x * q\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9xp4y6cb.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / 2\n         ^\n         ;\n/tmp/tmp9xp4y6cb.swift:16:4:\
    \ error: expected expression\n        q := p / 2\n          ^\n/tmp/tmp9xp4y6cb.swift:19:8:\
    \ error: expected 'in' after for-each pattern\n        for n > 0 {\n         \
    \     ^\n/tmp/tmp9xp4y6cb.swift:19:8: error: unary operator cannot be separated\
    \ from its operand\n        for n > 0 {\n              ^~\n               \n/tmp/tmp9xp4y6cb.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp9xp4y6cb.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp9xp4y6cb.swift:16:2: error: cannot find 'q' in\
    \ scope\n        q := p / 2\n        ^\n/tmp/tmp9xp4y6cb.swift:19:8: error: '>'\
    \ is not a prefix unary operator\n        for n > 0 {\n              ^\n/tmp/tmp9xp4y6cb.swift:26:5:\
    \ error: cannot find 'r' in scope\n        if r == 1 {\n           ^\n/tmp/tmp9xp4y6cb.swift:27:10:\
    \ error: cannot find 'x' in scope\n                return x\n                \
    \       ^\n/tmp/tmp9xp4y6cb.swift:29:9: error: cannot find 'x' in scope\n    \
    \    return x * q\n               ^\n/tmp/tmp9xp4y6cb.swift:29:13: error: cannot\
    \ find 'q' in scope\n        return x * q\n                   ^\n/tmp/tmp9xp4y6cb.swift:29:11:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int'\n\
    \        return x * q\n               ~~^~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p >\
    \ p\")\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tfor y > 1\
    \ {\n\t\tx -= y\n\t\ty >>= 1\n\t}\n\treturn x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmlh8mfnt.swift:25:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpmlh8mfnt.swift:25:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpmlh8mfnt.swift:27:8:\
    \ error: expected 'in' after for-each pattern\n        for y > 1 {\n         \
    \     ^\n/tmp/tmpmlh8mfnt.swift:27:8: error: unary operator cannot be separated\
    \ from its operand\n        for y > 1 {\n              ^~\n               \n/tmp/tmpmlh8mfnt.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpmlh8mfnt.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpmlh8mfnt.swift:17:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpmlh8mfnt.swift:20:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpmlh8mfnt.swift:25:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmpmlh8mfnt.swift:27:8:\
    \ error: '>' is not a prefix unary operator\n        for y > 1 {\n           \
    \   ^\n/tmp/tmpmlh8mfnt.swift:31:9: error: cannot find 'x' in scope\n        return\
    \ x\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tx := n\n\t\
    y := p\n\tq := 1\n\tfor {\n\t\tif y & 1 != 1 {\n\t\t\tbreak\n\t\t}\n\t\ty >>=\
    \ 1\n\t\tq++\n\t}\n\tr := x\n\tfor i := 0; i < q; i++ {\n\t\tr <<= 1\n\t\tr |=\
    \ x & 1\n\t\tx >>= 1\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzkqc1vw5.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpzkqc1vw5.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpzkqc1vw5.swift:25:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpzkqc1vw5.swift:25:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpzkqc1vw5.swift:32:3: error: consecutive statements on a line\
    \ must be separated by ';'\n        r := x\n         ^\n         ;\n/tmp/tmpzkqc1vw5.swift:32:4:\
    \ error: expected expression\n        r := x\n          ^\n/tmp/tmpzkqc1vw5.swift:33:9:\
    \ error: expected type\n        for i := 0; i < q; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpzkqc1vw5.swift:33:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < q; i++ {\n               ^\n/tmp/tmpzkqc1vw5.swift:33:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < q; i++ {\n               ^\n/tmp/tmpzkqc1vw5.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpzkqc1vw5.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpzkqc1vw5.swift:17:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpzkqc1vw5.swift:22:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmpzkqc1vw5.swift:32:2:\
    \ error: cannot find 'r' in scope\n        r := x\n        ^\n/tmp/tmpzkqc1vw5.swift:38:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn (p * n) % p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplahk2h8g.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplahk2h8g.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus || n < p:\n\t\
    \treturn 0\n\tcase n == p:\n\t\treturn 1\n\tcase n == Modulus:\n\t\treturn p\n\
    \tcase n == Modulus - 1:\n\t\treturn p - 1\n\tcase n == Modulus + 1:\n\t\treturn\
    \ p + 1\n\tdefault:\n\t\treturn (p * modpow(n, Modulus - p, p)) % p\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpm6i4j448.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpm6i4j448.swift:16:15: error: cannot\
    \ find 'modpow' in scope\n                return (p * modpow(n, Modulus - p, p))\
    \ % p\n                            ^~~~~~\n/tmp/tmpm6i4j448.swift:16:25: error:\
    \ cannot find 'Modulus' in scope\n                return (p * modpow(n, Modulus\
    \ - p, p)) % p\n                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tx := 1\n\tfor i := 1; i <= n; i++ {\n\t\tx *= p\n\
    \t\tx += p - 1\n\t\tif x % p == 0 {\n\t\t\treturn x\n\t\t}\n\t}\n\treturn 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo9_kkrli.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := 1\n         ^\n         ;\n/tmp/tmpo9_kkrli.swift:19:4:\
    \ error: expected expression\n        x := 1\n          ^\n/tmp/tmpo9_kkrli.swift:20:9:\
    \ error: expected type\n        for i := 1; i <= n; i++ {\n               ^\n\
    \                <#type#>\n/tmp/tmpo9_kkrli.swift:20:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 1; i <= n; i++ {\n               ^\n/tmp/tmpo9_kkrli.swift:20:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 1; i\
    \ <= n; i++ {\n               ^\n/tmp/tmpo9_kkrli.swift:19:2: error: cannot find\
    \ 'x' in scope\n        x := 1\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with\
    \ p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tq :=\
    \ n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp0xzxida.swift:25:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpp0xzxida.swift:25:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpp0xzxida.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpp0xzxida.swift:11:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmpp0xzxida.swift:25:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmpp0xzxida.swift:27:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmpp0xzxida.swift:27:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmpp0xzxida.swift:27:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0: panic(\"modp called with negative n\"\
    )\n\tcase p < 2: panic(\"modp called with p < 2\")\n\tcase p > n: panic(\"modp\
    \ called with p > n\")\n\tdefault: return (p - 1) % n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0v2u2__k.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp0v2u2__k.swift:5:14: error: cannot\
    \ find 'panic' in scope\n        case n < 0: panic(\"modp called with negative\
    \ n\")\n                    ^~~~~\n/tmp/tmp0v2u2__k.swift:6:14: error: cannot\
    \ find 'panic' in scope\n        case p < 2: panic(\"modp called with p < 2\"\
    )\n                    ^~~~~\n/tmp/tmp0v2u2__k.swift:7:14: error: cannot find\
    \ 'panic' in scope\n        case p > n: panic(\"modp called with p > n\")\n  \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tfor y > 1 {\n\t\tx = x\
    \ % y\n\t\ty = y >> 1\n\t}\n\treturn x\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjz38l3a4.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpjz38l3a4.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpjz38l3a4.swift:18:8:\
    \ error: expected 'in' after for-each pattern\n        for y > 1 {\n         \
    \     ^\n/tmp/tmpjz38l3a4.swift:18:8: error: unary operator cannot be separated\
    \ from its operand\n        for y > 1 {\n              ^~\n               \n/tmp/tmpjz38l3a4.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpjz38l3a4.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 2\")\n            \
    \    ^~~~~\n/tmp/tmpjz38l3a4.swift:16:2: error: cannot find 'x' in scope\n   \
    \     x := n\n        ^\n/tmp/tmpjz38l3a4.swift:18:8: error: '>' is not a prefix\
    \ unary operator\n        for y > 1 {\n              ^\n/tmp/tmpjz38l3a4.swift:22:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n % p) + p) % p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn8kxnkwq.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpn8kxnkwq.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0gfhxs78.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp0gfhxs78.swift:19:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp0gfhxs78.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp0gfhxs78.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp0gfhxs78.swift:19:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmp0gfhxs78.swift:21:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmp0gfhxs78.swift:21:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmp0gfhxs78.swift:21:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_pap3d7q.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp_pap3d7q.swift:19:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp_pap3d7q.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmp_pap3d7q.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmp_pap3d7q.swift:19:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmp_pap3d7q.swift:21:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmp_pap3d7q.swift:21:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmp_pap3d7q.swift:21:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (-n)) + (n & p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpzb4hqt1_/tmpzb4hqt1_.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba850d71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba850a68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba850a68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba850a677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzb4hqt1_                        0x0000558e968051bd <unavailable> + 4541

    5    libc.so.6                          0x00002ba850f5d460 __libc_start_main +
    245

    6    tmpzb4hqt1_                        0x0000558e96804e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tdefault:\n\t\treturn\
    \ modp(n >> 1, p) + p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph0p38kbm.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmph0p38kbm.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmph0p38kbm.swift:12:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ >> 1, p) + p\n                           ^\n                            n: \
    \     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6m51f5ek.swift:92:9: error: unterminated string literal\n     \
    \           panic(\"modp: \n                      ^\n/tmp/tmp6m51f5ek.swift:114:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmp6m51f5ek.swift:3:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmp6m51f5ek.swift:5:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:17:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:20:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:23:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:26:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:29:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:32:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:35:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:38:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:41:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:44:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp6m51f5ek.swift:47:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp6m51f5ek.swift:50:3:\
    \ error: can"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tq := n / p\n\t\
    r := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd632684m.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpd632684m.swift:22:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpd632684m.swift:22:2:\
    \ error: cannot find 'q' in scope\n        q := n / p\n        ^\n/tmp/tmpd632684m.swift:24:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) * p + r\n       \
    \             ^\n/tmp/tmpd632684m.swift:24:26: error: cannot find 'r' in scope\n\
    \        return modp(q, p) * p + r\n                                ^\n/tmp/tmpd632684m.swift:24:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\")\n\t}\n\tx := n\n\ty :=\
    \ p\n\tfor y > 1 {\n\t\tx = y\n\t\ty = x % y\n\t}\n\treturn x\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv1ryjvtt.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpv1ryjvtt.swift:22:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpv1ryjvtt.swift:24:8:\
    \ error: expected 'in' after for-each pattern\n        for y > 1 {\n         \
    \     ^\n/tmp/tmpv1ryjvtt.swift:24:8: error: unary operator cannot be separated\
    \ from its operand\n        for y > 1 {\n              ^~\n               \n/tmp/tmpv1ryjvtt.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpv1ryjvtt.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpv1ryjvtt.swift:20:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpv1ryjvtt.swift:22:2: error: cannot find 'x' in scope\n     \
    \   x := n\n        ^\n/tmp/tmpv1ryjvtt.swift:24:8: error: '>' is not a prefix\
    \ unary operator\n        for y > 1 {\n              ^\n/tmp/tmpv1ryjvtt.swift:28:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > 255:\n\t\tpanic(\"invalid\
    \ parameters\")\n\tcase n == 0 && p == 0:\n\t\treturn 0\n\tcase n == p:\n\t\t\
    return 1\n\tcase n == 255:\n\t\treturn 255\n\t}\n\tswitch {\n\tcase p < 2:\n\t\
    \treturn 0\n\tcase p < n:\n\t\treturn modp(n - p, p)\n\tdefault:\n\t\tswitch {\n\
    \t\tcase p % 2 == 0:\n\t\t\treturn modp(n / 2, p)\n\t\tcase p % 2 == 1:\n\t\t\t\
    return modp(n / 2, p) + modp(n / 2, p - 1)\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpojywtz9p.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpojywtz9p.swift:14:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpojywtz9p.swift:20:10:\
    \ error: expected expression in 'switch' statement\n                switch {\n\
    \                       ^\n/tmp/tmpojywtz9p.swift:6:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"invalid parameters\")\n                ^~~~~\n\
    /tmp/tmpojywtz9p.swift:18:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpojywtz9p.swift:22:15: error: missing\
    \ argument labels 'n:p:' in call\n                        return modp(n / 2, p)\n\
    \                                   ^\n                                    n:\
    \     p: \n/tmp/tmpojywtz9p.swift:24:15: error: missing argument labels 'n:p:'\
    \ in call\n                        return modp(n / 2, p) + modp(n / 2, p - 1)\n\
    \                                   ^\n                                    n:\
    \     p: \n/tmp/tmpojywtz9p.swift:24:32: error: missing argument labels 'n:p:'\
    \ in call\n                        return modp(n / 2, p) + modp(n / 2, p - 1)\n\
    \                                                    ^\n                     \
    \                                n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn (n + p) % p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1474576q.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp1474576q.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif p < p {\n\t\treturn modp(n - 1, p) + modp(n, p)\n\t}\n\treturn modp(n\
    \ - 1, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpns3_zsdq.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpns3_zsdq.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n/tmp/tmpns3_zsdq.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) + modp(n,\
    \ p)\n                           ^\n                            n:     p: \n/tmp/tmpns3_zsdq.swift:20:31:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p) + modp(n, p)\n                                            ^\n      \
    \                                       n: p: \n/tmp/tmpns3_zsdq.swift:22:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn (p * n) % p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplahk2h8g.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplahk2h8g.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tif n == p+2 {\n\t\treturn p + 1\n\t\
    }\n\tif n == p+3 {\n\t\treturn p + 2\n\t}\n\tif n == p+4 {\n\t\treturn p + 3\n\
    \t}\n\tif n == p+5 {\n\t\treturn p + 4\n\t}\n\tif n == p+6 {\n\t\treturn p + 5\n\
    \t}\n\tif n == p+7 {\n\t\treturn p + 6\n\t}\n\tif n == p+8 {\n\t\treturn p + 7\n\
    \t}\n\tif n == p+9 {\n\t\treturn p + 8\n\t}\n\tif n == p+10 {\n\t\treturn p +\
    \ 9\n\t}\n\tif n == p+11 {\n\t\treturn p + 10\n\t}\n\tif n == p+12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == p+13 {\n\t\treturn p + 12\n\t}\n\tif n == p+14 {\n\t\t\
    return p + 13\n\t}\n\tif n == p+15 {\n\t\treturn p + 14\n\t}\n\tif n == p+16 {\n\
    \t\treturn p + 15\n\t}\n\tif n == p+17 {\n\t\treturn p + 16\n\t}\n\tif n == p+18\
    \ {\n\t\treturn p + 17\n\t}\n\tif n == p+19 {\n\t\treturn p + 18\n\t}\n\tif n\
    \ == p+20 {\n\t\treturn p + 19\n\t}\n\tif n == p+21 {\n\t\treturn p + 20\n\t}\n\
    \tif n == p+22 {\n\t\treturn p + 21\n\t}\n\tif n == p+23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == p+24 {\n\t\treturn p + 23\n\t}\n\tif n == p+25 {\n\t\treturn p\
    \ + 24\n\t}\n\tif n == p+26 {\n\t\treturn p + 25\n\t}\n\tif n == p+27 {\n\t\t\
    return p + 26\n\t}\n\tif n == p+28 {\n\t\treturn p + 27\n\t}\n\tif n == p+29 {\n\
    \t\treturn p + 28\n\t}\n\tif n == p+30 {\n\t\treturn p + 29\n\t}\n\tif n == p+31\
    \ {\n\t\treturn p + 30\n\t}\n\tif n == p+32 {\n\t\treturn p + 31\n\t}\n\tif n\
    \ == p+33 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp53tdku23.swift:138:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp53tdku23.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp53tdku23.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp53tdku23.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp53tdku23.swift:120:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq31f5u4d.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / p, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (n & (-p)) + (n >> p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpuxpb0ia2/tmpuxpb0ia2.swift:21: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2857b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2854aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2854ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2854ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxpb0ia2                        0x0000562c17cda23d <unavailable> + 4669

    5    libc.so.6                          0x00002ac2859a3460 __libc_start_main +
    245

    6    tmpuxpb0ia2                        0x0000562c17cd9e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tdefault:\n\t\tswitch\
    \ {\n\t\tcase n >= p:\n\t\t\treturn modp(n - p, p)\n\t\tcase n < p:\n\t\t\treturn\
    \ modp(n - p, p) + p\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplymutz9c.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplymutz9c.swift:12:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmplymutz9c.swift:6:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(abs(n), p)\n                          \
    \ ^\n                            n:      p: \n/tmp/tmplymutz9c.swift:14:15: error:\
    \ missing argument labels 'n:p:' in call\n                        return modp(n\
    \ - p, p)\n                                   ^\n                            \
    \        n:     p: \n/tmp/tmplymutz9c.swift:16:15: error: missing argument labels\
    \ 'n:p:' in call\n                        return modp(n - p, p) + p\n        \
    \                           ^\n                                    n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tcase n >= p - 1:\n\t\treturn p - 1 + modp(n - p, p)\n\t}\n\treturn\
    \ modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsp486rqm.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsp486rqm.swift:10:22: error: missing\
    \ argument labels 'n:p:' in call\n                return p - 1 + modp(n - p, p)\n\
    \                                   ^\n                                    n:\
    \     p: \n/tmp/tmpsp486rqm.swift:12:13: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n - p, p)\n                   ^\n             \
    \       n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqtila12_.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpqtila12_.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tdefault:\n\t\tlet r =\
    \ n % p\n\t\tif r == 0 {\n\t\t\treturn p\n\t\t}\n\t\treturn modp(r, p) + p\n\t\
    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp57894u49.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp57894u49.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp57894u49.swift:16:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(r,\
    \ p) + p\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p % 2 == 1:\n\t\t\
    return modp(n / 2, p)\n\tdefault:\n\t\treturn modp(n / 2, p) * p + n % p\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqytm5urr.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpqytm5urr.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpqytm5urr.swift:12:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / 2, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpqytm5urr.swift:14:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n / 2, p) * p + n % p\n                         \
    \  ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase p == 1:\n\t\treturn n\n\tcase p == 2:\n\t\treturn\
    \ n+1\n\tcase p == n:\n\t\treturn 0\n\tdefault:\n\t\tx := 1\n\t\tfor i := 0; i\
    \ < p; i++ {\n\t\t\tx *= n\n\t\t}\n\t\treturn x\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk03zqntz.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpk03zqntz.swift:14:4: error: consecutive\
    \ statements on a line must be separated by ';'\n                x := 1\n    \
    \             ^\n                 ;\n/tmp/tmpk03zqntz.swift:14:5: error: expected\
    \ expression\n                x := 1\n                  ^\n/tmp/tmpk03zqntz.swift:15:10:\
    \ error: expected type\n                for i := 0; i < p; i++ {\n           \
    \            ^\n                        <#type#>\n/tmp/tmpk03zqntz.swift:15:10:\
    \ error: expected 'in' after for-each pattern\n                for i := 0; i <\
    \ p; i++ {\n                       ^\n/tmp/tmpk03zqntz.swift:15:10: error: expected\
    \ Sequence expression for for-each loop\n                for i := 0; i < p; i++\
    \ {\n                       ^\n/tmp/tmpk03zqntz.swift:6:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: invalid arguments\")\n     \
    \           ^~~~~\n/tmp/tmpk03zqntz.swift:14:3: error: cannot find 'x' in scope\n\
    \                x := 1\n                ^\n/tmp/tmpk03zqntz.swift:18:10: error:\
    \ cannot find 'x' in scope\n                return x\n                       ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0: return 0\n\tcase n > 0: return p\n\t\
    case n == 0: return 1\n\t}\n\tswitch {\n\tcase p == 1: return n\n\tcase p == 0:\
    \ return 0\n\tcase p == -1: return -p\n\t}\n\tswitch {\n\tcase p == 2: return\
    \ n\n\tcase p == -2: return -n\n\t}\n\tswitch {\n\tcase p == 3: return n\n\tcase\
    \ p == -3: return -n\n\t}\n\tswitch {\n\tcase p == 4: return n\n\tcase p == -4:\
    \ return -n\n\t}\n\tswitch {\n\tcase p == 5: return n\n\tcase p == -5: return\
    \ -n\n\t}\n\tswitch {\n\tcase p == 6: return n\n\tcase p == -6: return -n\n\t\
    }\n\tswitch {\n\tcase p == 7: return n\n\tcase p == -7: return -n\n\t}\n\tswitch\
    \ {\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\
    \tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\t\
    case p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase\
    \ p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p\
    \ == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p ==\
    \ 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8:\
    \ return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return\
    \ n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\
    \tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\t\
    case p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase\
    \ p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p\
    \ == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p ==\
    \ 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8:\
    \ return n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\tcase p == 8: return\
    \ n\n\tcase p == 8: return n\n\tcase p == 8: return n\n\t\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj6ocwz36.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj6ocwz36.swift:9:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpj6ocwz36.swift:14:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj6ocwz36.swift:18:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj6ocwz36.swift:22:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj6ocwz36.swift:26:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj6ocwz36.swift:30:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj6ocwz36.swift:34:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj6ocwz36.swift:38:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj6ocwz36.swift:107:31: error: expected '}' at end of brace\
    \ statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n\
    /tmp/tmpj6ocwz36.swift:3:34: note: to match this opening '{'\nfunc modp(n: Int,\
    \ p: Int) -> Int {\n                                 ^\n/tmp/tmpj6ocwz36.swift:89:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase n == p:\n\t\treturn 0\n\tcase n == 0 || p == 0:\n\
    \t\treturn n\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\
    \tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch\
    \ {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\t\
    \treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\"\
    )\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"\
    modp: invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\t\
    case p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\t\treturn\
    \ p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\t\
    case p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase\
    \ p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\
    \t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase\
    \ p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid\
    \ arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\
    \t\tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\t\
    switch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase p == n:\n\
    \t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"modp: invalid arguments\"\
    )\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\tcase p < n:\n\t\tpanic(\"\
    modp: invalid arguments\")\n\tcase p == n:\n\t\treturn p\n\t}\n\tswitch {\n\t\
    case p < n:\n\t\tpanic(\"modp: invalid arguments\")\n\tcase p == \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj4yi1dkr.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:14:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:20:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:26:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:32:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:38:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:44:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:50:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:56:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:62:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:68:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:74:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:80:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:86:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:92:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpj4yi1dkr.swift:98:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpj4yi1dkr.swift:102:1:\
    \ error: expected expression after operator\n}\n^\n/tmp/tmpj4yi1dkr.swift:101:11:\
    \ error: expected ':' after 'case'\n        case p == \n                 ^\n/tmp/tmpj4yi1dkr.swift:123:31:\
    \ error: expected '}' at end of brace statement\nas"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0: return 0\n\tcase n == 0: return p\n\
    \tcase n == 1: return 1\n\tcase p < 2: return 0\n\tcase p == 2: return 1\n\tcase\
    \ p < 65536: return modp(n >> 8, p)\n\tcase p < 4294967296: return modp(n >> 16,\
    \ p)\n\tcase p < 18446744073709551616: return modp(n >> 32, p)\n\tcase p < 18446744073709551616:\
    \ return modp(n >> 64, p)\n\tcase p < 18446744073709551616: return modp(n >> 128,\
    \ p)\n\tcase p < 18446744073709551616: return modp(n >> 256, p)\n\tcase p < 18446744073709551616:\
    \ return modp(n >> 512, p)\n\tcase p < 18446744073709551616: return modp(n >>\
    \ 1024, p)\n\tcase p < 18446744073709551616: return modp(n >> 2048, p)\n\tcase\
    \ p < 18446744073709551616: return modp(n >> 4096, p)\n\tcase p < 18446744073709551616:\
    \ return modp(n >> 8192, p)\n\tcase p < 18446744073709551616: return modp(n >>\
    \ 16384, p)\n\tcase p < 18446744073709551616: return modp(n >> 32768, p)\n\tcase\
    \ p < 18446744073709551616: return modp(n >> 65536, p)\n\tcase p < 18446744073709551616:\
    \ return modp(n >> 131072, p)\n\tcase p < 18446744073709551616: return modp(n\
    \ >> 262144, p)\n\tcase p < 18446744073709551616: return modp(n >> 524288, p)\n\
    \tcase p < 18446744073709551616: return modp(n >> 1048576, p)\n\tcase p < 18446744073709551616:\
    \ return modp(n >> 2097152, p)\n\tcase p < 18446744073709551616: return modp(n\
    \ >> 4194304, p)\n\tcase p < 18446744073709551616: return modp(n >> 838860\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbrdwo94a.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpbrdwo94a.swift:31:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpbrdwo94a.swift:30:44: note: to match this\
    \ opening '('\n        case p < 18446744073709551616: return modp(n >> 838860\n\
    \                                                  ^\n/tmp/tmpbrdwo94a.swift:52:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpbrdwo94a.swift:3:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpbrdwo94a.swift:10:29: error: missing argument labels 'n:p:'\
    \ in call\n        case p < 65536: return modp(n >> 8, p)\n                  \
    \                 ^\n                                    n:      p: \n/tmp/tmpbrdwo94a.swift:11:34:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 4294967296:\
    \ return modp(n >> 16, p)\n                                        ^\n       \
    \                                  n:       p: \n/tmp/tmpbrdwo94a.swift:12:44:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 18446744073709551616:\
    \ return modp(n >> 32, p)\n                                                  ^\n\
    \                                                   n:       p: \n/tmp/tmpbrdwo94a.swift:13:44:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 18446744073709551616:\
    \ return modp(n >> 64, p)\n                                                  ^\n\
    \                                                   n:       p: \n/tmp/tmpbrdwo94a.swift:14:44:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 18446744073709551616:\
    \ return modp(n >> 128, p)\n                                                 \
    \ ^\n                                                   n:        p: \n/tmp/tmpbrdwo94a.swift:15:44:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 18446744073709551616:\
    \ return modp(n >> 256, p)\n                                                 \
    \ ^\n                          "
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p == 2 {\n\t\treturn n\n\t}\n\tq := p\n\
    \tr := 1\n\tfor ; n > 0; n-- {\n\t\tif n & 1 {\n\t\t\tr *= q\n\t\t}\n\t\tq /=\
    \ 2\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvaw1o15g.swift:13:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpvaw1o15g.swift:13:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpvaw1o15g.swift:15:2:\
    \ error: C-style for statement has been removed in Swift 3\n        for ; n >\
    \ 0; n-- {\n        ^   ~~~~~~~~~~~~\n/tmp/tmpvaw1o15g.swift:5:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative n\"\
    )\n                ^~~~~\n/tmp/tmpvaw1o15g.swift:13:2: error: cannot find 'q'\
    \ in scope\n        q := p\n        ^\n/tmp/tmpvaw1o15g.swift:21:9: error: cannot\
    \ find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p\
    \ {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa0ufqi8k.swift:186:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa0ufqi8k.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa0ufqi8k.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpa0ufqi8k.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpa0ufqi8k.swift:17:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpa0ufqi8k.swift:164:3:\
    \ error: non-void function should return a value\n                return \n  \
    \              ^\n/tmp/tmpa0ufqi8k.swift:168:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (pow(2, n) % p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg8ekix8e.swift:4:10: error: cannot find 'pow' in scope\n      \
    \  return (pow(2, n) % p)\n                ^~~\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tx := 1\n\tfor ; n > 0; n-- {\n\t\tx = x * p\n\t}\n\treturn x\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjs27_gfh.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := 1\n         ^\n         ;\n/tmp/tmpjs27_gfh.swift:19:4:\
    \ error: expected expression\n        x := 1\n          ^\n/tmp/tmpjs27_gfh.swift:20:2:\
    \ error: C-style for statement has been removed in Swift 3\n        for ; n >\
    \ 0; n-- {\n        ^   ~~~~~~~~~~~~\n/tmp/tmpjs27_gfh.swift:5:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative n\"\
    )\n                ^~~~~\n/tmp/tmpjs27_gfh.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpjs27_gfh.swift:19:2: error: cannot find 'x' in scope\n     \
    \   x := 1\n        ^\n/tmp/tmpjs27_gfh.swift:23:9: error: cannot find 'x' in\
    \ scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tif n == p+2 {\n\t\treturn p + 1\n\t\
    }\n\tif n == p+3 {\n\t\treturn p + 2\n\t}\n\tif n == p+4 {\n\t\treturn p + 3\n\
    \t}\n\tif n == p+5 {\n\t\treturn p + 4\n\t}\n\tif n == p+6 {\n\t\treturn p + 5\n\
    \t}\n\tif n == p+7 {\n\t\treturn p + 6\n\t}\n\tif n == p+8 {\n\t\treturn p + 7\n\
    \t}\n\tif n == p+9 {\n\t\treturn p + 8\n\t}\n\tif n == p+10 {\n\t\treturn p +\
    \ 9\n\t}\n\tif n == p+11 {\n\t\treturn p + 10\n\t}\n\tif n == p+12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == p+13 {\n\t\treturn p + 12\n\t}\n\tif n == p+14 {\n\t\t\
    return p + 13\n\t}\n\tif n == p+15 {\n\t\treturn p + 14\n\t}\n\tif n == p+16 {\n\
    \t\treturn p + 15\n\t}\n\tif n == p+17 {\n\t\treturn p + 16\n\t}\n\tif n == p+18\
    \ {\n\t\treturn p + 17\n\t}\n\tif n == p+19 {\n\t\treturn p + 18\n\t}\n\tif n\
    \ == p+20 {\n\t\treturn p + 19\n\t}\n\tif n == p+21 {\n\t\treturn p + 20\n\t}\n\
    \tif n == p+22 {\n\t\treturn p + 21\n\t}\n\tif n == p+23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == p+24 {\n\t\treturn p + 23\n\t}\n\tif n == p+25 {\n\t\treturn p\
    \ + 24\n\t}\n\tif n == p+26 {\n\t\treturn p + 25\n\t}\n\tif n == p+27 {\n\t\t\
    return p + 26\n\t}\n\tif n == p+28 {\n\t\treturn p + 27\n\t}\n\tif n == p+29 {\n\
    \t\treturn p + 28\n\t}\n\tif n == p+30 {\n\t\treturn p + 29\n\t}\n\tif n == p+31\
    \ {\n\t\treturn p + 30\n\t}\n\tif n == p+32 {\n\t\treturn p + 31\n\t}\n\tif n\
    \ == p+33 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp53tdku23.swift:138:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp53tdku23.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp53tdku23.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp53tdku23.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp53tdku23.swift:120:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 1:\n\t\treturn 0\n\tcase n == 1:\n\t\t\
    return p\n\tcase p < 1:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p\
    \ > n:\n\t\treturn 0\n\t}\n\tswitch {\n\tcase p < n:\n\t\tp %= n\n\tcase p > n:\n\
    \t\tp = n - p\n\t}\n\treturn p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprix7pga5.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmprix7pga5.swift:16:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmprix7pga5.swift:18:5:\
    \ error: left side of mutating operator isn't mutable: 'p' is a 'let' constant\n\
    \                p %= n\n                ~ ^\n/tmp/tmprix7pga5.swift:20:3: error:\
    \ cannot assign to value: 'p' is a 'let' constant\n                p = n - p\n\
    \                ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp\
    \ called with invalid arguments\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p ==\
    \ n:\n\t\treturn 1\n\tcase p == -1:\n\t\treturn -1\n\tcase p == -2:\n\t\treturn\
    \ -2\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(n - p, p)\n\tcase p == 0:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 1\n\tcase p == -1:\n\t\treturn -1\n\t\
    case p == -2:\n\t\treturn -2\n\t}\n\tswitch {\n\tcase n <= 1:\n\t\treturn 0\n\t\
    case n == 2:\n\t\treturn 1\n\tcase n == 3:\n\t\treturn 2\n\tcase n == 4:\n\t\t\
    return 3\n\tcase n == 5:\n\t\treturn 4\n\tcase n == 6:\n\t\treturn 5\n\tcase n\
    \ == 7:\n\t\treturn 6\n\tcase n == 8:\n\t\treturn 7\n\tcase n == 9:\n\t\treturn\
    \ 8\n\tcase n == 10:\n\t\treturn 9\n\tcase n == 11:\n\t\treturn 10\n\tcase n ==\
    \ 12:\n\t\treturn 11\n\tcase n == 13:\n\t\treturn 12\n\tcase n == 14:\n\t\treturn\
    \ 13\n\tcase n == 15:\n\t\treturn 14\n\tcase n == 16:\n\t\treturn 15\n\tcase n\
    \ == 17:\n\t\treturn 16\n\tcase n == 18:\n\t\treturn 17\n\tcase n == 19:\n\t\t\
    return 18\n\tcase n == 20:\n\t\treturn 19\n\tcase n == 21:\n\t\treturn 20\n\t\
    case n == 22:\n\t\treturn 21\n\tcase n == 23:\n\t\treturn 22\n\tcase n == 24:\n\
    \t\treturn 23\n\tcase n == 25:\n\t\treturn 24\n\tcase n == 26:\n\t\treturn 25\n\
    \tcase n == 27:\n\t\treturn 26\n\tcase n == 28:\n\t\treturn 27\n\tcase n == 29:\n\
    \t\treturn 28\n\tcase n == 31:\n\t\treturn 29\n\tcase n == 32:\n\t\treturn 30\n\
    \tcase n == 33:\n\t\treturn 31\n\tcase n == 34:\n\t\treturn 32\n\tcase n == 35:\n\
    \t\treturn 33\n\tcase n == 36:\n\t\treturn 34\n\tcase n == 37:\n\t\treturn 35\n\
    \tcase n == 38:\n\t\treturn 36\n\tcase n == 39:\n\t\treturn 37\n\tcase n == 41:\n\
    \t\treturn 38\n\tcase n == 42:\n\t\treturn 39\n\tcase n == 43:\n\t\treturn 40\n\
    \tcase n == 44:\n\t\treturn 41\n\tcase n == 45:\n\t\treturn 42\n\tcase n == 46:\n\
    \t\treturn 43\n\tcase n == 47:\n\t\treturn 44\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8rb1_voo.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp8rb1_voo.swift:16:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp8rb1_voo.swift:28:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp8rb1_voo.swift:140:31: error: expected '}' at end of brace\
    \ statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n\
    /tmp/tmp8rb1_voo.swift:3:34: note: to match this opening '{'\nfunc modp(n: Int,\
    \ p: Int) -> Int {\n                                 ^\n/tmp/tmp8rb1_voo.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ invalid arguments\")\n                ^~~~~\n/tmp/tmp8rb1_voo.swift:18:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n - p, p)\n\
    \                           ^\n                            n:     p: \n/tmp/tmp8rb1_voo.swift:122:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 2 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\t\
    if n == p+2 {\n\t\treturn p+1\n\t}\n\tif n == p+3 {\n\t\treturn p+2\n\t}\n\tif\
    \ n == p+4 {\n\t\treturn p+3\n\t}\n\tif n == p+5 {\n\t\treturn p+4\n\t}\n\tif\
    \ n == p+6 {\n\t\treturn p+5\n\t}\n\tif n == p+7 {\n\t\treturn p+6\n\t}\n\tif\
    \ n == p+8 {\n\t\treturn p+7\n\t}\n\tif n == p+9 {\n\t\treturn p+8\n\t}\n\tif\
    \ n == p+10 {\n\t\treturn p+9\n\t}\n\tif n == p+11 {\n\t\treturn p+10\n\t}\n\t\
    if n == p+12 {\n\t\treturn p+11\n\t}\n\tif n == p+13 {\n\t\treturn p+12\n\t}\n\
    \tif n == p+14 {\n\t\treturn p+13\n\t}\n\tif n == p+15 {\n\t\treturn p+14\n\t\
    }\n\tif n == p+16 {\n\t\treturn p+15\n\t}\n\tif n == p+17 {\n\t\treturn p+16\n\
    \t}\n\tif n == p+18 {\n\t\treturn p+17\n\t}\n\tif n == p+19 {\n\t\treturn p+18\n\
    \t}\n\tif n == p+20 {\n\t\treturn p+19\n\t}\n\tif n == p+21 {\n\t\treturn p+20\n\
    \t}\n\tif n == p+22 {\n\t\treturn p+21\n\t}\n\tif n == p+23 {\n\t\treturn p+22\n\
    \t}\n\tif n == p+24 {\n\t\treturn p+23\n\t}\n\tif n == p+25 {\n\t\treturn p+24\n\
    \t}\n\tif n == p+26 {\n\t\treturn p+25\n\t}\n\tif n == p+27 {\n\t\treturn p+26\n\
    \t}\n\tif n == p+28 {\n\t\treturn p+27\n\t}\n\tif n == p+29 {\n\t\treturn p+28\n\
    \t}\n\tif n == p+30 {\n\t\treturn p+29\n\t}\n\tif n == p+31 {\n\t\treturn p+30\n\
    \t}\n\tif n == p+32 {\n\t\treturn p+31\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa6k8z_3q.swift:138:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa6k8z_3q.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa6k8z_3q.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpa6k8z_3q.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpa6k8z_3q.swift:120:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbi1a2f7x.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) + p\n                   ^\n            \
    \        n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"invalid\
    \ arguments\")\n\tcase n == 0 || p == 0:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 1\n\t}\n\tswitch {\n\tcase n <= p && p < 2*n:\n\t\treturn modp(n - p, p)\n\t\
    case n <= p && p < 2*n + 1:\n\t\treturn modp(n - p, p + 1) + 1\n\tcase n <= p\
    \ && p < 2*n + 2:\n\t\treturn modp(n - p, p + 2)\n\tcase n <= p && p < 2*n + 3:\n\
    \t\treturn modp(n - p, p + 3)\n\tcase n <= p && p < 2*n + 4:\n\t\treturn modp(n\
    \ - p, p + 4)\n\tcase n <= p && p < 2*n + 5:\n\t\treturn modp(n - p, p + 5)\n\t\
    case n <= p && p < 2*n + 6:\n\t\treturn modp(n - p, p + 6)\n\tcase n <= p && p\
    \ < 2*n + 7:\n\t\treturn modp(n - p, p + 7)\n\tcase n <= p && p < 2*n + 8:\n\t\
    \treturn modp(n - p, p + 8)\n\tcase n <= p && p < 2*n + 9:\n\t\treturn modp(n\
    \ - p, p + 9)\n\tcase n <= p && p < 2*n + 10:\n\t\treturn modp(n - p, p + 10)\n\
    \tcase n <= p && p < 2*n + 11:\n\t\treturn modp(n - p, p + 11)\n\tcase n <= p\
    \ && p < 2*n + 12:\n\t\treturn modp(n - p, p + 12)\n\tcase n <= p && p < 2*n +\
    \ 13:\n\t\treturn modp(n - p, p + 13)\n\tcase n <= p && p < 2*n + 14:\n\t\treturn\
    \ modp(n - p, p + 14)\n\tcase n <= p && p < 2*n + 15:\n\t\treturn modp(n - p,\
    \ p + 15)\n\tcase n <= p && p < 2*n + 16:\n\t\treturn modp(n - p, p + 16)\n\t\
    case n <= p && p < 2*n + 17:\n\t\treturn modp(n - p, p + 17)\n\tcase n <= p &&\
    \ p < 2*n + 18:\n\t\treturn modp(n - p, p + 18)\n\tcase n <= p && p < 2*n + 19:\n\
    \t\treturn modp(n - p, p + 19)\n\tcase n <= p && p < 2*n + 20:\n\t\treturn modp(n\
    \ - p, p + 20)\n\tcase n <= p && p < 2*n + 21:\n\t\treturn modp(n - p, p + 21)\n\
    \tcase n \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmdnwxvmo.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpmdnwxvmo.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpmdnwxvmo.swift:57:8:\
    \ error: expected ':' after 'case'\n        case n \n              ^\n/tmp/tmpmdnwxvmo.swift:79:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpmdnwxvmo.swift:3:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpmdnwxvmo.swift:6:3: error: cannot find 'panic' in scope\n\
    \                panic(\"invalid arguments\")\n                ^~~~~\n/tmp/tmpmdnwxvmo.swift:14:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpmdnwxvmo.swift:16:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p + 1) + 1\n                           ^\n\
    \                            n:     p: \n/tmp/tmpmdnwxvmo.swift:18:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n - p, p\
    \ + 2)\n                           ^\n                            n:     p: \n\
    /tmp/tmpmdnwxvmo.swift:20:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p + 3)\n                           ^\n   \
    \                         n:     p: \n/tmp/tmpmdnwxvmo.swift:22:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p + 4)\n\
    \                           ^\n                            n:     p: \n/tmp/tmpmdnwxvmo.swift:24:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p + 5)\n                           ^\n                            n:  \
    \   p: \n/tmp/tmpmdnwxvmo.swift:26:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p + 6)\n                          \
    \ ^\n                            n:     p: \n/tmp/tmpmdnwxvmo.swift:28:14: "
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\tif n == p+2 {\n\t\treturn p + 1\n\t\
    }\n\tif n == p+3 {\n\t\treturn p + 2\n\t}\n\tif n == p+4 {\n\t\treturn p + 3\n\
    \t}\n\tif n == p+5 {\n\t\treturn p + 4\n\t}\n\tif n == p+6 {\n\t\treturn p + 5\n\
    \t}\n\tif n == p+7 {\n\t\treturn p + 6\n\t}\n\tif n == p+8 {\n\t\treturn p + 7\n\
    \t}\n\tif n == p+9 {\n\t\treturn p + 8\n\t}\n\tif n == p+10 {\n\t\treturn p +\
    \ 9\n\t}\n\tif n == p+11 {\n\t\treturn p + 10\n\t}\n\tif n == p+12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == p+13 {\n\t\treturn p + 12\n\t}\n\tif n == p+14 {\n\t\t\
    return p + 13\n\t}\n\tif n == p+15 {\n\t\treturn p + 14\n\t}\n\tif n == p+16 {\n\
    \t\treturn p + 15\n\t}\n\tif n == p+17 {\n\t\treturn p + 16\n\t}\n\tif n == p+18\
    \ {\n\t\treturn p + 17\n\t}\n\tif n == p+19 {\n\t\treturn p + 18\n\t}\n\tif n\
    \ == p+20 {\n\t\treturn p + 19\n\t}\n\tif n == p+21 {\n\t\treturn p + 20\n\t}\n\
    \tif n == p+22 {\n\t\treturn p + 21\n\t}\n\tif n == p+23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == p+24 {\n\t\treturn p + 23\n\t}\n\tif n == p+25 {\n\t\treturn p\
    \ + 24\n\t}\n\tif n == p+26 {\n\t\treturn p + 25\n\t}\n\tif n == p+27 {\n\t\t\
    return p + 26\n\t}\n\tif n == p+28 {\n\t\treturn p + 27\n\t}\n\tif n == p+29 {\n\
    \t\treturn p + 28\n\t}\n\tif n == p+30 {\n\t\treturn p + 29\n\t}\n\tif n == p+31\
    \ {\n\t\treturn p + 30\n\t}\n\tif n == p+32 {\n\t\treturn p + 31\n\t}\n\tif n\
    \ == p+33 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp53tdku23.swift:138:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp53tdku23.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp53tdku23.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmp53tdku23.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmp53tdku23.swift:120:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqtila12_.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpqtila12_.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n-1)) ? (p ^ n) : p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprq6kg3gs.swift:4:12: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return (p & (n-1)) ? (p ^ n) : p\n        \
    \          ^\n               (           != 0)\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tx := n\n\ty := p\n\tfor y > 2 {\n\t\tx -= y\n\t\ty >>= 1\n\t}\n\treturn\
    \ x % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc6ilf1vg.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpc6ilf1vg.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpc6ilf1vg.swift:21:8:\
    \ error: expected 'in' after for-each pattern\n        for y > 2 {\n         \
    \     ^\n/tmp/tmpc6ilf1vg.swift:21:8: error: unary operator cannot be separated\
    \ from its operand\n        for y > 2 {\n              ^~\n               \n/tmp/tmpc6ilf1vg.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpc6ilf1vg.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpc6ilf1vg.swift:19:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n/tmp/tmpc6ilf1vg.swift:21:8: error: '>' is\
    \ not a prefix unary operator\n        for y > 2 {\n              ^\n/tmp/tmpc6ilf1vg.swift:25:9:\
    \ error: cannot find 'x' in scope\n        return x % p\n               ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tq := p\n\tfor {\n\t\tq /= 2\n\t\tif q == 1 {\n\
    \t\t\treturn n\n\t\t}\n\t\tif q > n {\n\t\t\tpanic(\"modp called with n > q\"\
    )\n\t\t}\n\t\tif q == p {\n\t\t\treturn q\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmup09zop.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpmup09zop.swift:19:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpmup09zop.swift:20:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpmup09zop.swift:20:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpmup09zop.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpmup09zop.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpmup09zop.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpmup09zop.swift:19:2: error: cannot\
    \ find 'q' in scope\n        q := p\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase n == p:\n\t\treturn n\n\tcase n == 0 || p == 0:\n\
    \t\treturn 0\n\tcase p == -1:\n\t\treturn n\n\t}\n\tswitch {\n\tcase p < 0:\n\t\
    \treturn modp(n, -p)\n\tcase p > n:\n\t\treturn modp(n, p - n)\n\t}\n\tswitch\
    \ {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n > p:\n\t\treturn modp(n,\
    \ p - n)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n\
    \ <= -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\t\
    case n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n,\
    \ p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <=\
    \ -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n\
    \ - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n\
    \ >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n, p)\n\t\
    }\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\t\
    return modp(-n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\
    \tcase n <= -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\t\
    return modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch\
    \ {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n,\
    \ p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <=\
    \ -p:\n\t\treturn modp(-n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn modp(n\
    \ - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n, p)\n\t}\n\t\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfju_wnea.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpfju_wnea.swift:14:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:20:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:26:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:32:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:38:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:44:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:50:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:56:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:62:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:68:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:74:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:80:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:86:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpfju_wnea.swift:92:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfju_wnea.swift:6:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid arguments\")\n                ^~~~~\n/tmp/tmpfju_wnea.swift:16:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ -p)\n                           ^\n                            n: p: \n/tmp/tmpfju_wnea.swift:18:14:\
    \ error: missing argument label"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp:\
    \ invalid arguments\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 1\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\
    \treturn 0\n\tcase p == n:\n\t\treturn 1\n\t}\n\tswitch {\n\tcase n <= p:\n\t\t\
    return modp(n - p, p)\n\tcase n >= p:\n\t\treturn modp(n, p - n)\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfb2yhro3.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpfb2yhro3.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpfb2yhro3.swift:20:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpfb2yhro3.swift:6:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid arguments\")\n                ^~~~~\n/tmp/tmpfb2yhro3.swift:14:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmpfb2yhro3.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpfb2yhro3.swift:24:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - n)\n                           ^\n       \
    \                     n: p: \n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tx := n\n\ty := p\n\tfor {\n\
    \t\tx -= y\n\t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t\ty = y*2 + 1\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn2xspae1.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpn2xspae1.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpn2xspae1.swift:18:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpn2xspae1.swift:18:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpn2xspae1.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpn2xspae1.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpn2xspae1.swift:16:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (p & (n-1)) ? (p^n) : p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv4vmuvyr.swift:4:12: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return (p & (n-1)) ? (p^n) : p\n          \
    \        ^\n               (           != 0)\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p == 1 {\n\t\treturn 1\n\t}\n\tif p > 1 {\n\t\treturn modp(n / p, p)\n\
    \t}\n\treturn modp(n / 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprwo6sozx.swift:14:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n / p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmprwo6sozx.swift:16:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / 2, p)\n    \
    \               ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tdefault:\n\t\treturn (p + n) % p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpva_iqnx1.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q,\
    \ p) * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk8v7ov4w.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpk8v7ov4w.swift:22:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpk8v7ov4w.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpk8v7ov4w.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpk8v7ov4w.swift:22:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmpk8v7ov4w.swift:24:14: error: cannot\
    \ find 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n\
    /tmp/tmpk8v7ov4w.swift:24:26: error: cannot find 'r' in scope\n        return\
    \ modp(q, p) * p + r\n                                ^\n/tmp/tmpk8v7ov4w.swift:24:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn 0\n\tdefault:\n\t\treturn p + modp(n - p, p)\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpb5iemc9b.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpb5iemc9b.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmpb5iemc9b.swift:10:18:\
    \ error: missing argument labels 'n:p:' in call\n                return p + modp(n\
    \ - p, p)\n                               ^\n                                n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"invalid\
    \ arguments\")\n\tcase p == 0:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 1\n\t\
    }\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p == 0:\n\t\t\
    return 0\n\tcase p == n:\n\t\treturn 1\n\t}\n\tswitch {\n\tcase n >= p:\n\t\t\
    return modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\t}\n\tswitch\
    \ {\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n\
    \ - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn\
    \ modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\
    \t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase\
    \ n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p,\
    \ p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn\
    \ modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= p:\n\
    \t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase\
    \ n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n - p,\
    \ p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n\
    \ - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\t\treturn\
    \ modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase n <= -p:\n\
    \t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tcase\
    \ n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn modp(n - p,\
    \ p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= p:\n\t\treturn\
    \ modp(n - p, p)\n\tcase n <= -p:\n\t\treturn modp(-n - p, p)\n\tcase n >= \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq3ixa7ep.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpq3ixa7ep.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpq3ixa7ep.swift:20:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpq3ixa7ep.swift:26:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpq3ixa7ep.swift:84:1:\
    \ error: expected expression after operator\n}\n^\n/tmp/tmpq3ixa7ep.swift:83:11:\
    \ error: expected ':' after 'case'\n        case n >= \n                 ^\n/tmp/tmpq3ixa7ep.swift:105:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpq3ixa7ep.swift:3:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpq3ixa7ep.swift:6:3: error: cannot find 'panic' in scope\n\
    \                panic(\"invalid arguments\")\n                ^~~~~\n/tmp/tmpq3ixa7ep.swift:14:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(abs(n),\
    \ p)\n                           ^\n                            n:      p: \n\
    /tmp/tmpq3ixa7ep.swift:22:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpq3ixa7ep.swift:24:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n - p, p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpq3ixa7ep.swift:28:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpq3ixa7ep.swift:30:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(-n - p, p)\n                           ^\n      \
    \                      n:      p: \n/tmp/tmpq3ixa7ep.swift:32:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tdefault:\n\t\treturn (p + modp(n - p, p)) % p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvy15f147.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvy15f147.swift:10:19: error: missing\
    \ argument labels 'n:p:' in call\n                return (p + modp(n - p, p))\
    \ % p\n                                ^\n                                 n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 2 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1 {\n\t\treturn p\n\t}\n\t\
    if n == p+2 {\n\t\treturn p-1\n\t}\n\tif n == p+3 {\n\t\treturn p-2\n\t}\n\tif\
    \ n == p+4 {\n\t\treturn p-3\n\t}\n\tif n == p+5 {\n\t\treturn p-4\n\t}\n\tif\
    \ n == p+6 {\n\t\treturn p-5\n\t}\n\tif n == p+7 {\n\t\treturn p-6\n\t}\n\tif\
    \ n == p+8 {\n\t\treturn p-7\n\t}\n\tif n == p+9 {\n\t\treturn p-8\n\t}\n\tif\
    \ n == p+10 {\n\t\treturn p-9\n\t}\n\tif n == p+11 {\n\t\treturn p-10\n\t}\n\t\
    if n == p+12 {\n\t\treturn p-11\n\t}\n\tif n == p+13 {\n\t\treturn p-12\n\t}\n\
    \tif n == p+14 {\n\t\treturn p-13\n\t}\n\tif n == p+15 {\n\t\treturn p-14\n\t\
    }\n\tif n == p+16 {\n\t\treturn p-15\n\t}\n\tif n == p+17 {\n\t\treturn p-16\n\
    \t}\n\tif n == p+18 {\n\t\treturn p-17\n\t}\n\tif n == p+19 {\n\t\treturn p-18\n\
    \t}\n\tif n == p+20 {\n\t\treturn p-19\n\t}\n\tif n == p+21 {\n\t\treturn p-20\n\
    \t}\n\tif n == p+22 {\n\t\treturn p-21\n\t}\n\tif n == p+23 {\n\t\treturn p-22\n\
    \t}\n\tif n == p+24 {\n\t\treturn p-23\n\t}\n\tif n == p+25 {\n\t\treturn p-24\n\
    \t}\n\tif n == p+26 {\n\t\treturn p-25\n\t}\n\tif n == p+27 {\n\t\treturn p-26\n\
    \t}\n\tif n == p+28 {\n\t\treturn p-27\n\t}\n\tif n == p+29 {\n\t\treturn p-28\n\
    \t}\n\tif n == p+30 {\n\t\treturn p-29\n\t}\n\tif n == p+31 {\n\t\treturn p-30\n\
    \t}\n\tif n == p+32 {\n\t\treturn p-31\n\t}\n\tif n == p+33 {\n\t\treturn p-32\n\
    \t}\n\tif n == p+34 {\n\t\treturn p-33\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa_69cckc.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpa_69cckc.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\t\
    return n\n\tcase p < 2:\n\t\treturn 0\n\tdefault:\n\t\treturn modp(n - p, p) +\
    \ p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2u_i22xx.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2u_i22xx.swift:12:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p) + p\n\
    \                           ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif n == 2 {\n\t\treturn p + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t\
    }\n\tif n == 4 {\n\t\treturn p + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\
    \tif n == 6 {\n\t\treturn p + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\t\
    if n == 8 {\n\t\treturn p + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif\
    \ n == 10 {\n\t\treturn p + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\t\
    if n == 12 {\n\t\treturn p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\
    \tif n == 14 {\n\t\treturn p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t\
    }\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\
    \t}\n\tif n == 18 {\n\t\treturn p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\
    \t}\n\tif n == 20 {\n\t\treturn p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\
    \t}\n\tif n == 22 {\n\t\treturn p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == 24 {\n\t\treturn p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == 26 {\n\t\treturn p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\
    \t}\n\tif n == 28 {\n\t\treturn p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\
    \t}\n\tif n == 30 {\n\t\treturn p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\
    \t}\n\tif n == 32 {\n\t\treturn p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\
    \t}\n\tif n == 34 {\n\t\treturn p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\
    \t}\n\tif n == 36 {\n\t\treturn p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\
    \t}\n\tif n == 38 {\n\t\treturn p + 37\n\t}\n\tif n == 39 {\n\t\treturn p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdagmcn09.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdagmcn09.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpdagmcn09.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpdagmcn09.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpdagmcn09.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\treturn modp(n - 1, p*p) %\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyhyxz6kf.swift:5:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpyhyxz6kf.swift:8:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n/tmp/tmpyhyxz6kf.swift:16:13: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p*p) % p\n      \
    \             ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n >=\
    \ p:\n\t\treturn 0\n\tdefault:\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplvxlmxba.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplvxlmxba.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n >> 1, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxz1t9s0x.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n >> 1, p) + p\n                   ^\n           \
    \         n:      p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (pow2(n) - 1) & ^(p-1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6v9yv_0i.swift:4:10: error: cannot find 'pow2' in scope\n     \
    \   return (pow2(n) - 1) & ^(p-1)\n                ^~~~\n/tmp/tmp6v9yv_0i.swift:4:25:\
    \ error: '^' is not a prefix unary operator\n        return (pow2(n) - 1) & ^(p-1)\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus.MaxValue:\n\t\
    \tpanic(\"modp: invalid arguments\")\n\tcase p == Modulus.One:\n\t\treturn n\n\
    \tcase p == Modulus.Minus:\n\t\treturn Modulus.One\n\tcase p == Modulus.Zero:\n\
    \t\treturn Modulus.Zero\n\t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n == Modulus.One:\n\
    \t\treturn Modulus.One\n\tcase Modulus.IsOne(p) && n == Modulus.Minus:\n\t\treturn\
    \ Modulus.Minus\n\tcase Modulus.IsOne(p) && n == Modulus.Zero:\n\t\treturn Modulus.Zero\n\
    \t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n == Modulus.MaxValue:\n\t\treturn\
    \ Modulus.MaxValue\n\tcase Modulus.IsOne(p) && n == Modulus.MinValue:\n\t\treturn\
    \ Modulus.MinValue\n\t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n == Modulus.MaxValue/2:\n\
    \t\treturn Modulus.MaxValue/2\n\tcase Modulus.IsOne(p) && n == Modulus.MinValue/2:\n\
    \t\treturn Modulus.MinValue/2\n\t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n ==\
    \ Modulus.MaxValue/3:\n\t\treturn Modulus.MaxValue/3\n\tcase Modulus.IsOne(p)\
    \ && n == Modulus.MinValue/3:\n\t\treturn Modulus.MinValue/3\n\t}\n\tswitch {\n\
    \tcase Modulus.IsOne(p) && n == Modulus.MaxValue/4:\n\t\treturn Modulus.MaxValue/4\n\
    \tcase Modulus.IsOne(p) && n == Modulus.MinValue/4:\n\t\treturn Modulus.MinValue/4\n\
    \t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n == Modulus.MaxValue/5:\n\t\treturn\
    \ Modulus.MaxValue/5\n\tcase Modulus.IsOne(p) && n == Modulus.MinValue/5:\n\t\t\
    return Modulus.MinValue/5\n\t}\n\tswitch {\n\tcase Modulus.IsOne(p) && n == Modulus.MaxValue/6:\n\
    \t\treturn Modulus.MaxValue/6\n\tcase Modulus.IsOne(p) && n == Modulus.MinValue/6:\n\
    \t\treturn Modulus.MinValue/6\n\t}\n\tswitch {\n\tcase Modulus.IsOne(p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp67ij91k9.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp67ij91k9.swift:14:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp67ij91k9.swift:22:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp67ij91k9.swift:28:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmp67ij91k9.swift:34:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp67ij91k9.swift:40:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmp67ij91k9.swift:46:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp67ij91k9.swift:52:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmp67ij91k9.swift:58:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp67ij91k9.swift:60:1: error: expected ')' in expression list\n\
    }\n^\n/tmp/tmp67ij91k9.swift:59:20: note: to match this opening '('\n        case\
    \ Modulus.IsOne(p\n                          ^\n/tmp/tmp67ij91k9.swift:59:22:\
    \ error: expected ':' after 'case'\n        case Modulus.IsOne(p\n           \
    \                 ^\n/tmp/tmp67ij91k9.swift:81:31: error: expected '}' at end\
    \ of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                       \
    \       ^\n/tmp/tmp67ij91k9.swift:3:34: note: to match this opening '{'\nfunc\
    \ modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp67ij91k9.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: invalid arguments\"\
    )\n                ^~~~~\n/tmp/tmp67ij91k9.swift:10:10: error: cannot find 'Modulus'\
    \ in scope\n                return Modulus.One\n                       ^~~~~~~\n\
    /tmp/tmp67ij91k9.swift:12:10: error: cannot find 'Modulus' in scope\n        \
    \        return Modulus.Zero\n                       ^~~~~~~\n/tmp/tmp67ij91k9.swift:16:10:\
    \ error: cannot find 'Modu"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv0hvz63e.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) + p\n                   ^\n            \
    \        n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > 255:\n\t\tpanic(\"invalid\
    \ parameters\")\n\tcase n == 0 && p == 0:\n\t\treturn 0\n\tcase n == p:\n\t\t\
    return 1\n\t}\n\tswitch {\n\tcase p < 2:\n\t\treturn 0\n\tcase p < n:\n\t\treturn\
    \ modp(n - p, p)\n\tdefault:\n\t\tn -= p\n\t\treturn modp(n - 1, p)\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpawfed07k.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpawfed07k.swift:12:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpawfed07k.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"invalid parameters\"\
    )\n                ^~~~~\n/tmp/tmpawfed07k.swift:16:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpawfed07k.swift:18:5:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= p\n                ~ ^\n/tmp/tmpawfed07k.swift:19:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n - 1, p)\n\
    \                           ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tx := n\n\ty := 1\n\tfor {\n\t\tif y & 1 == 1 {\n\t\t\tx -= 1\n\t\t}\n\t\
    \ty >>= 1\n\t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxtdrgd8z.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpxtdrgd8z.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpxtdrgd8z.swift:21:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpxtdrgd8z.swift:21:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpxtdrgd8z.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpxtdrgd8z.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpxtdrgd8z.swift:19:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif\
    \ p < 2 {\n\t\tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\
    \tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tq := n /\
    \ p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_z7rcviw.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp_z7rcviw.swift:19:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp_z7rcviw.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp_z7rcviw.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 2\")\n            \
    \    ^~~~~\n/tmp/tmp_z7rcviw.swift:19:2: error: cannot find 'q' in scope\n   \
    \     q := n / p\n        ^\n/tmp/tmp_z7rcviw.swift:21:14: error: cannot find\
    \ 'q' in scope\n        return modp(q, p) * p + r\n                    ^\n/tmp/tmp_z7rcviw.swift:21:26:\
    \ error: cannot find 'r' in scope\n        return modp(q, p) * p + r\n       \
    \                         ^\n/tmp/tmp_z7rcviw.swift:21:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) * p + r\n                 \
    \  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcpj58h2t.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpcpj58h2t.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpcpj58h2t.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpcpj58h2t.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpcpj58h2t.swift:172:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015023
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp called with p > p\")\n\t}\n\tif p < p {\n\t\treturn modp(n - 1, p) % p\n\t\
    }\n\tq := modp(n - 1, p) // q is guaranteed to be a power of 2\n\tq >>= 1\n\t\
    q |= 1\n\treturn q * p % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmav7jyip.swift:22:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p) // q is guaranteed to be a\
    \ power of 2\n         ^\n         ;\n/tmp/tmpmav7jyip.swift:22:4: error: expected\
    \ expression\n        q := modp(n - 1, p) // q is guaranteed to be a power of\
    \ 2\n          ^\n/tmp/tmpmav7jyip.swift:5:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpmav7jyip.swift:8:3: error: cannot find 'panic' in scope\n            \
    \    panic(\"modp called with p < 2\")\n                ^~~~~\n/tmp/tmpmav7jyip.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p > p\")\n                ^~~~~\n/tmp/tmpmav7jyip.swift:20:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) % p\n\
    \                           ^\n                            n:     p: \n/tmp/tmpmav7jyip.swift:22:2:\
    \ error: cannot find 'q' in scope\n        q := modp(n - 1, p) // q is guaranteed\
    \ to be a power of 2\n        ^\n/tmp/tmpmav7jyip.swift:25:9: error: cannot find\
    \ 'q' in scope\n        return q * p % p\n               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0 || p < 0 || p > Modulus || n < p:\n\t\
    \tpanic(\"modp: invalid input\")\n\tcase n == p:\n\t\treturn 1\n\tcase n == Modulus:\n\
    \t\treturn p\n\t}\n\tx := n\n\ty := p\n\tt := 1\n\tfor {\n\t\tif y & 1 == 1 {\n\
    \t\t\tx >>= 1\n\t\t\ty >>= 1\n\t\t\tt *= x\n\t\t} else {\n\t\t\tx >>= 1\n\t\t\t\
    y >>= 1\n\t\t\tt *= y\n\t\t}\n\t\tif x == 0 {\n\t\t\treturn t\n\t\t}\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpczzlkigm.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpczzlkigm.swift:12:3: error: consecutive\
    \ statements on a line must be separated by ';'\n        x := n\n         ^\n\
    \         ;\n/tmp/tmpczzlkigm.swift:12:4: error: expected expression\n       \
    \ x := n\n          ^\n/tmp/tmpczzlkigm.swift:15:6: error: expected pattern\n\
    \        for {\n            ^\n/tmp/tmpczzlkigm.swift:15:6: error: expected Sequence\
    \ expression for for-each loop\n        for {\n            ^\n/tmp/tmpczzlkigm.swift:6:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: invalid input\"\
    )\n                ^~~~~\n/tmp/tmpczzlkigm.swift:12:2: error: cannot find 'x'\
    \ in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == 2 {\n\t\treturn p\
    \ + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif n == 4 {\n\t\treturn p\
    \ + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif n == 6 {\n\t\treturn p\
    \ + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif n == 8 {\n\t\treturn p\
    \ + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif n == 10 {\n\t\treturn p\
    \ + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\t}\n\tif n == 36 {\n\t\treturn\
    \ p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\t}\n\tif n == 38 {\n\t\treturn\
    \ p + 37\n\t}\n\tif n == 39 {\n\t\treturn p + 38\n\t}\n\tif n == 40 {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpspbgz8ao.swift:153:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpspbgz8ao.swift:3:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpspbgz8ao.swift:5:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpspbgz8ao.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpspbgz8ao.swift:135:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif p == 1 {\n\t\
    \treturn n\n\t}\n\tr := 1\n\tfor ; n > 0; n-- {\n\t\tr *= p\n\t\tif r > p {\n\t\
    \t\tbreak\n\t\t}\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqastdphe.swift:13:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmpqastdphe.swift:13:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmpqastdphe.swift:14:2:\
    \ error: C-style for statement has been removed in Swift 3\n        for ; n >\
    \ 0; n-- {\n        ^   ~~~~~~~~~~~~\n/tmp/tmpqastdphe.swift:5:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative n\"\
    )\n                ^~~~~\n/tmp/tmpqastdphe.swift:8:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 2\")\n              \
    \  ^~~~~\n/tmp/tmpqastdphe.swift:13:2: error: cannot find 'r' in scope\n     \
    \   r := 1\n        ^\n/tmp/tmpqastdphe.swift:20:9: error: cannot find 'r' in\
    \ scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * (p - 1) + p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp65nt6d9r.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * (p - 1) + p\n                   ^\n  \
    \                  n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\treturn (n & (-p)) + (n & p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmplixtzyw8/tmplixtzyw8.swift:20: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c5608bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c55d82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c55d82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c55d817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplixtzyw8                        0x00005570812931bd <unavailable> + 4541

    5    libc.so.6                          0x00002b8c56277460 __libc_start_main +
    245

    6    tmplixtzyw8                        0x0000557081292e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with\
    \ p > p\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tx := n\n\ty := 1\n\tfor {\n\t\tif x == 1 {\n\t\t\treturn y\n\t\t}\n\t\t\
    y = y * x\n\t\tx -= 1\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2o0413ed.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp2o0413ed.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp2o0413ed.swift:21:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp2o0413ed.swift:21:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp2o0413ed.swift:5:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmp2o0413ed.swift:11:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmp2o0413ed.swift:19:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t\
    }\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tx := n\n\ty := p\n\tfor y > 1 {\n\t\tx = y\n\t\ty = x % y\n\t}\n\treturn\
    \ x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjdado3dy.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpjdado3dy.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpjdado3dy.swift:21:8:\
    \ error: expected 'in' after for-each pattern\n        for y > 1 {\n         \
    \     ^\n/tmp/tmpjdado3dy.swift:21:8: error: unary operator cannot be separated\
    \ from its operand\n        for y > 1 {\n              ^~\n               \n/tmp/tmpjdado3dy.swift:5:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpjdado3dy.swift:8:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 2\")\n \
    \               ^~~~~\n/tmp/tmpjdado3dy.swift:19:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n/tmp/tmpjdado3dy.swift:21:8: error: '>' is\
    \ not a prefix unary operator\n        for y > 1 {\n              ^\n/tmp/tmpjdado3dy.swift:25:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tx :=\
    \ n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y & 1 != 1 {\n\t\t\tz ^= x\n\t\t}\n\t\
    \ty >>= 1\n\t\tif y == 0 {\n\t\t\tbreak\n\t\t}\n\t\tx <<= 1\n\t\tx ^= p // x =\
    \ x * p % p\n\t}\n\treturn z\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphpw5q52b.swift:16:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmphpw5q52b.swift:16:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmphpw5q52b.swift:19:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmphpw5q52b.swift:19:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmphpw5q52b.swift:16:2: error: cannot find 'x' in scope\n    \
    \    x := n\n        ^\n/tmp/tmphpw5q52b.swift:30:9: error: cannot find 'z' in\
    \ scope\n        return z\n               ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tt := 1\n\tfor {\n\t\tif y &\
    \ 1 != 1 {\n\t\t\tx >>= 1\n\t\t\tt++\n\t\t}\n\t\ty >>= 1\n\t\tif y == 0 {\n\t\t\
    \treturn x\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd1193sxk.swift:19:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpd1193sxk.swift:19:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpd1193sxk.swift:22:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpd1193sxk.swift:22:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpd1193sxk.swift:19:2: error: cannot find 'x' in scope\n    \
    \    x := n\n        ^\n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase\
    \ n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpc972it3u.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpc972it3u.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 1:\n\t\treturn 0\n\tcase n == 1 || (p\
    \ & 1) == 0: // p mod n == 0\n\t\treturn p & 1\n\tcase p < 2:\n\t\treturn 0\n\t\
    default:\n\t\treturn modp(n >> 1, p) + p & 1\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpr5r597lr.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpr5r597lr.swift:12:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n >> 1, p) + p &\
    \ 1\n                           ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2 * p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2e8mrfe.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2 * p\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n <=\
    \ p:\n\t\treturn n\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9mbqv599.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp9mbqv599.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmp9mbqv599.swift:10:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase n <=\
    \ p:\n\t\treturn n\n\tcase n >= p - 1:\n\t\treturn modp(n - p, p)\n\t}\n\treturn\
    \ modp(n - p, p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpud0r6yyg.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpud0r6yyg.swift:6:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmpud0r6yyg.swift:10:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpud0r6yyg.swift:12:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - p, p) + p\n                   ^\n                   \
    \ n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzmp0ky6k.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p) * p + p\n                   ^\n        \
    \            n:     p: \n"
  stdout: ''
  timestamp: 1660015022
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tswitch {\n\tcase n < 0: return modp(-n, p)\n\tcase n == 0:\
    \ return 0\n\tcase n == 1: return p\n\tcase p < 0: return modp(n - p, p)\n\tdefault:\
    \ return modp(n - p, p) + p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2djo97xx.swift:4:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2djo97xx.swift:5:25: error: missing\
    \ argument labels 'n:p:' in call\n        case n < 0: return modp(-n, p)\n   \
    \                            ^\n                                n:  p: \n/tmp/tmp2djo97xx.swift:8:25:\
    \ error: missing argument labels 'n:p:' in call\n        case p < 0: return modp(n\
    \ - p, p)\n                               ^\n                                n:\
    \     p: \n/tmp/tmp2djo97xx.swift:9:22: error: missing argument labels 'n:p:'\
    \ in call\n        default: return modp(n - p, p) + p\n                      \
    \      ^\n                             n:     p: \n"
  stdout: ''
  timestamp: 1660015024
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\nfunc modp(n: Int, p:\
    \ Int) -> Int {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\
    \t}\n\treturn modp(n / 2, p) * p + n % 2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt0qcyg2o.swift:10:13: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n / 2, p) * p + n % 2\n                   ^\n    \
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660015023
